- en: '*Chapter 3*: Automating Infrastructure with Crossplane'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to stop being abstract about ideas and deep-dive into details. Starting
    with this chapter, we will go on a hands-on journey to implement what we have
    learned and explore different Crossplane concepts at the same time. Trying out
    the examples given in this book will ensure that we have the ideas and experience
    to practice modern infrastructure engineering in our day-to-day jobs. This chapter
    will specifically cover the detailed architecture of Crossplane and its out-of-the-box
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Custom Resource Definitions and custom controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Crossplane architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Crossplane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple provider configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of POSTGRES provisioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Custom Resource Definitions and custom controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the concept of **Custom Resource Definitions** (**CRDs**) and
    custom controllers in Kubernetes is vital to know how Crossplane works. Before
    getting into the Crossplane architecture, we will take a quick look at CRDs and
    custom controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs: []
  type: TYPE_NORMAL
- en: The term **resources** in Kubernetes represents a collection of objects of a
    similar kind. Pods, Services, Deployments, namespaces, and many more are the in-built
    object kinds. Each resource has the respective API endpoints at kube-apiserver.
  prefs: []
  type: TYPE_NORMAL
- en: CRDs are the way to extend the in-built resources list. It adds a new resource
    kind, including a set of API endpoints at kube-apiserver, to operate over the
    new resource. The term CRD precisely indicates what it does. The new resource
    added to Kubernetes using a CRD is called a **Custom Resource** (**CR**). Storing
    and retrieving a structured object defined with a CRD is not helpful unless backed
    by a custom controller. Custom controllers are our addition to the in-built controllers.
    They generally operate over a CR to perform specific actions in a control loop
    for each API event of a given resource. [*Chapter 1*](B17830_01_ePub.xhtml#_idTextAnchor014),
    *Introducing the New Operating Model*, has already covered the concept of a control
    loop. Refer to the *Control theory* section if you want to brush up on the idea.
    Note that the custom controllers do not necessarily always work with a CR. They
    can work with any existing resources to extend its functionality, which is not
    in the scope of our discussion. The Prometheus operator is one of the most famous
    and widely used examples of adding a few new CRs and controllers into the Kubernetes
    cluster to perform monitoring of workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs: []
  type: TYPE_NORMAL
- en: The term **operator** when applied to Prometheus is a term coined by CoreOS.
    Operators are nothing but a combination of *CRD + a custom controller + application
    focus*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new CRD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there are a few ways to add CRDs to Kubernetes, let''s add CRDs by creating
    a `yaml` file and applying the same on the cluster. The `yaml` file provides a
    structure to the CR. The following are the key attributes of a CRD YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiextensions.k8s.io/v1beta1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomResourceDefinition`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `clouddbs.book.imarunrk.com`, where `clouddbs` is the plural name and `book.imarunrk.com`
    is a newly defined API group. The term plural name is nothing but a representation
    of the resource name in the plural format. For example, the plural format of the
    existing resource pod is pods. We can always use that with kubectl commands (`kubectl
    get pods`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spec** is the section under which we define the details of the CR. The attributes
    of this section include the API group, version, scope, and name. This section
    also describes the validation requirements of the API itself, such as the parameter
    list, their data types, and whether they are a required parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample CRD YAML that represents a cloud database resource.
    It takes a couple of mandatory parameters, the database type, and the cloud provider
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the following YAML code will enable new rest endpoints at kube-apiserver
    to create, modify, and delete the CloudDB resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to write the custom controller to manage the CR API events.
    We can write a controller in many different languages using different open source
    frameworks. Writing a controller is an advanced topic that is covered later in
    [*Chapter 7*](B17830_07_ePub.xhtml#_idTextAnchor109), *Extending and Scaling Crossplane*.
    Crossplane providers are nothing but controllers to manage external infrastructure
    resources – generally, cloud providers' managed services. For now, we must remember
    that controllers implement functions to execute three actions – observe, analyze,
    and react in a control loop. In the preceding example, the control loop will create,
    update, and delete the cloud database based on the resource's creation, update,
    and delete API events.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the CRD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have the CRD and controller in place, we can start creating and managing
    the cloud database with `kubectl`. It will work very similarly to other in-built
    resources such as the Pod. The following YAML is an example of creating Amazon
    RDS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the following command will create a new CloudDB resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding YAML will not create an RDS, as we have not developed
    and deployed a controller. The example is to explain how CRDs and custom controllers
    work. Now that we have learned about CRDs and custom controllers, it's time to
    look at the Crossplane architecture in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Crossplane architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From what we know so far, Crossplane is nothing but a set of Kubernetes custom
    controllers and CRDs representing external infrastructure resources. If you take
    a closer look, Crossplane is much more than a combination of CRDs and custom controllers.
    Crossplane has four key components. The components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Managed resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Crossplane core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Managed Resource** (**MR**) connects a CRD and respective custom controller
    to represent a single external infrastructure resource. MRs are in a one-to-one
    mapping with infrastructure resources. For example, CloudSQLInstance is an MR
    representing Google Cloud SQL. The following diagram depicts the MR mapping for
    Amazon RDS and Google Cloud Storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – MR mapping'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – MR mapping
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Crossplane Resource Model** (**XRM**) is the open standard used when
    developing an MR. The XRM is an opinionated extension of the **Kubernetes Resource
    Model** (**KRM**). The XRM sets the standards for external resource naming, dependency
    management, package management, and so on. MRs are the basic building blocks on
    which everything else in Crossplane is made. We can use MRs directly to provision
    an external infrastructure, but this is very rarely done. The best practice is
    to compose a higher-level API above an MR to consume. We will look at *how* and
    *why* in a later section of this chapter, as well as a dedicated chapter to address
    this aspect in detail. The following YAML represents the provisioning of CloudSQLInstance
    directly using an MR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML will provision a GCP Cloud SQL instance with the resource constraints
    mentioned in the configurations. Since MR is the low-level Crossplane construct
    mapping to the infrastructure provider API, it will directly support all the attributes
    available in the infrastructure API. The reconciliation control loop of Crossplane
    controllers will fill default values assigned by the infrastructure API for the
    features not provided in the configuration YAML. This concept of MR is called
    late initialization. Whatever we provide under the `forProvider:` section will
    represent the attributes of the infrastructure API. If someone or a parallel process
    performs an unauthorized change to the infrastructure resource, Crossplane will
    roll back the changes to the source of truth mentioned in the YAML. The remaining
    parts of the configuration will help to determine other Crossplane behavior. For
    example, the preceding YAML has `writeConnectionSecretToRef:` to decide how to
    save the database credentials. There can be many more such behavior controls,
    which we will learn as we go further. The following commands can help look at
    the details of the created GCP resource and clean up the resources after testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can also import the existing provisioned infrastructure into the Crossplane
    ecosystem. The MR checks whether the resources named in the configuration YAML
    already exist before fresh provisioning. When we build that YAML for the existing
    infrastructure, we can provide the authorized attributes that need to be maintained
    by the reconciliation loop under `forProvider`. In the next chapter, we will look
    at an example of importing existing infrastructure into Crossplane.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: One of the possible Crossplane behavior controls is the deletion policy, specified
    with an attribute called **deletionPolicy**. It can have two possible values –
    **Delete**, which is the default, and **Orphan**. While Delete will remove the
    resource from the infrastructure provider, Orphan will just remove the Crossplane
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providers are a group of related MRs packaged together as a bundle. Each cloud
    vendor, other infrastructure services such as Rook (the cloud-native storage for
    Kubernetes – [https://rook.io/](https://rook.io/)), and software tools such as
    Helm have a provider package. The format of these packages is nothing but a container
    image. Installing a provider can be done either with a configuration YAML or using
    a Helm package. It requires a ProviderConfig configuration before we can start
    using these packages. The ProviderConfig resource helps us to set up the infrastructure
    vendor credentials. We will look at provider installation and ProviderConfig setup
    in the next section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure represents the AWS and GCP providers extending Crossplane
    for the respective cloud resource provisioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A provider view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – A provider view
  prefs: []
  type: TYPE_NORMAL
- en: Composite resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every organization is different in its structure, size, operating model, technology
    maturity, compliance, and security requirements. All these aspects will directly
    create a set of rules as policies for infrastructure provisioning and usage. Also,
    there is a complexity in assembling multiple pieces of the infrastructure stack.
    Composing is a way to build our custom infrastructure APIs above one or more MR
    APIs. These custom APIs can encode all the policy guidelines and assemble multiple
    pieces of infrastructure into simple, easy-to-use infrastructure recipes. These
    APIs are called **Composite Resources** (**XRs**). The critical aspect is that
    Crossplane allows us to define such resources in a no-code way, just with configurations.
    In the absence of a Crossplane composite, we will end up building complex Kubernetes
    custom controllers. Composition and **Composite Resource Definition** (**XRD**)
    are the configurations that we use to compose a higher-level XR API. XRD defines
    the schema of the new custom API that we are building. It''s the definition of
    a new CRD. Composition is the configuration that provides a mapping between the
    new CRD schema and the existing MRs. Once the new XR resource is available, we
    can start provisioning the infrastructure recipes using a resource claim object.
    The Claim API is something that gets created when we add a new XR API, provided
    we have asked for it in the XRD configuration. The Claim and XR APIs are almost
    the same with minor differences, which we will explore in an upcoming section.
    The following diagram represents how we can use CloudSQLInstance, a firewall,
    and network MRs from the GCP provider to construct an XPOSTGRES database composite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – A composite resource'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – A composite resource
  prefs: []
  type: TYPE_NORMAL
- en: 'We have thousands of cloud-managed services with many attributes requiring
    a detailed configuration. It adds a significant cognitive load to shortlist the
    options and implement the resource provisioning, with good guardrail settings
    that suit our organization''s needs. Every product team in an organization cannot
    take up this level of cognitive load. Usually, organizations use a platform team
    to abstract the cognitive load. The composing layer is for platform teams to build
    such abstractions. Crossplane enables us to expose these abstractions as Kubernetes
    APIs, allowing self-service for the product teams. The following diagram represents
    the platform and product team interaction model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Product and platform team interaction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Product and platform team interaction
  prefs: []
  type: TYPE_NORMAL
- en: Crossplane core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before setting up the providers we are interested in and building XRs above
    that, we need to have a Crossplane core component installed in the cluster. This
    component provides the primitives required to manage multiple providers, build
    new XRs, and build new packages. Again, the core component is a bundle of CRDs
    and custom controllers. It is the glue that holds everything else about Crossplane
    together. The following figure represents how all the pieces fit within the Kubernetes
    ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – All the pieces of Crossplane'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – All the pieces of Crossplane
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit some of the acronyms that we have used so far, which we will
    use going forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CRD** stands for **Custom Resource Definition**, a way to extend the Kubernetes
    API to support new resource types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRs are the resources defined with the CRD. **CR** stands for **Custom Resource**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XRM** stands for **Crossplane Resource Model**, an extension of the **Kubernetes
    Resource Model**. It is a set of rules set by Crossplane on how to build an XR
    or MR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MRs** are nothing but **Managed Resources**, a combination of a CRD and custom
    controllers in a one-to-one mapping with external infrastructure resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XRD** stands for **Composite Resource Definition**, a definition for building
    a custom infrastructure API above Crossplane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XR** stands for **Composite Resource**, which represents a custom infrastructure
    API built with Crossplane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Crossplane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have set up a local Kubernetes cluster on my Macintosh computer. We will
    make this cluster the Crossplane control plane for provisioning resources from
    Google Cloud Platform in our tutorials. To follow the tutorials, we assume that
    you already have access to a Kubernetes cluster. If you need help setting up a
    local Kubernetes cluster, refer to [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/).
    kind is one of the simplest ways to set up a local Kubernetes cluster, but you
    can work on the tutorials with any Kubernetes cluster setup. The following screenshot
    gives a quick glimpse at cluster information, versions, and node details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Cluster information, versions, and node details'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Cluster information, versions, and node details
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a few ways to install Crossplane in Kubernetes, we will install
    it with a Helm chart. Make sure you have Helm installed. Installing Helm is pretty
    simple on both Macintosh and Windows with the `brew` or `choco` package managers.
    The following commands can install `helm` in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For more installation options, visit [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).
    For Crossplane installation, we need a minimum Kubernetes version of v1.16.0 and
    a minimum Helm version of v3.0.0\. Master and stable are the two flavors of Crossplane
    available. Master has the latest commits, but this version may have stability
    issues. Stable is a version that is ready for community use and recommended for
    production usage. We will be using the stable version of the Crossplane in this
    tutorial. The installation of Crossplane is done in three steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new target namespace called `crossplane-system` for installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add and update the Crossplane repository to the `helm` repo list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Crossplane with `helm` in the target namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The Crossplane Helm chart supports quite a few template values for custom configuration
    options. Replica count is one example, which specifies how many Crossplane Pods
    are to run for a high-availability setup. Have a look at all possible configuration
    options available for the Crossplane Helm template at Artifact Hub. The installation
    screenshot is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Crossplane installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Crossplane installation
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove the Crossplane installation with the standard `helm delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A screenshot of the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Crossplane installation health'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Crossplane installation health
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have installed Crossplane, we will learn how to install and configure
    the providers in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have the Crossplane core component installed in the Kubernetes cluster,
    the next step is installing and configuring the Crossplane provider. We will install
    and configure the GCP provider, which is the scope of our tutorial. We can do
    this in a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a cloud account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing a provider
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the provider
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will look at each of these aspects in detail with a step-by-step guide in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a cloud account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to have a Google Cloud account with the project and billing setup enabled.
    Google Cloud offers $300 credit for new users to learn and experiment for a maximum
    of 3 months, provided you have a credit card. It will be more than enough for
    us to learn Crossplane and other infrastructure automation concepts. All we need
    to do is log on to the Google Cloud account to fill out a form and start the free
    trial. The next step is to create a separate project space for us to experiment
    with Crossplane. You can create a new project by clicking the project dropdown
    on the top bar of the GCP console and clicking on **NEW PROJECT**, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Creating a new GCP project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Creating a new GCP project
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a GCP account, free credits, and the project started, the next
    step is to enable all the needed cloud API access. We are going to do that with
    the `gcloud` CLI. Download the CLI from [https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install)
    and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `gcloud` CLI after the download:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the SDK with the cloud credentials and project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`gcloud init` will redirect us to a web browser to authenticate with the Google
    account. Once we can successfully provide necessary access, we must select the
    project when asked for it by the CLI. Now, we should be able to enable the required
    cloud services with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'A screenshot of the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Enabling the cloud APIs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Enabling the cloud APIs
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are done enabling the API access for the project, the next step is
    to create a service account and extract the credentials required to set up the
    GCP Crossplane provider. It involves a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the project ID to use in the necessary upcoming commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the service account, get the name, and enable the required roles on
    the service account. Note that `crossplane-330620` in all the following commands
    is my Google project ID. You will replace that with your Google project ID. Use
    the preceding command to explore the list of your project IDs. Similarly, `crossplane-service-account@crossplane-330620.iam.gserviceaccount.com`
    is the name of the created service account in my GCP environment. Replace this
    with your service account name. You can get your service account name by executing
    the second command in the following code block to list the service accounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To extract the service account file, use the first command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a Kubernetes Secret with the service account file. The Secret
    will be referred to when we make a provider configuration, which you will see
    in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing a provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now install the GCP Crossplane provider. We have to run the following
    provider resource YAML with the latest GCP provider container image version. The
    current available stable version is v0.18.0\. Update the version accordingly when
    you are executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the YAML and validate whether the provider container is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'A screenshot of the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Running the GCP provider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Running the GCP provider
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final step is to set up provider configuration for authentication using
    the `ProviderConfig` Crossplane API. Preparing the credentials can be slightly
    different for each provider, depending on the construct for authentication by
    the infrastructure vendor. In the case of GCP, it will be a service account, it''s
    a service principle for Azure, an IAM for AWS, and so on. The following YAML will
    configure credentials for the GCP provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of crucial aspects of GCP provider configuration are the project ID
    reference and the service account credentials. We need to provide our GCP project
    ID under `projectID:`. We will not have this configuration element for other infrastructure
    provider configurations such as AWS. Note that the provider configuration mentioned
    previously references the Kubernetes Secrets. Apply the YAML and validate the
    provider configuration with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'A screenshot of the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The GCP provider config'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – The GCP provider config
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are concluding Crossplane installation, GCP provider setup, and
    configuration. Other provider setups also mostly look like GCP. Now, the environment
    is ready for provisioning GCP resources with an MR, or we can start composing
    our XR API above the MR.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple provider configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can have multiple ProviderConfig configured against a provider. It''s like
    having many credentials or cloud accounts to access the cloud platform and choosing
    the appropriate credentials based on the given context. When provisioning the
    infrastructure resources with an MR or XR, we specify `providerConfigRef:` to
    determine which ProviderConfig to use in the given context. If `providerConfigRef:`
    is not available in an MR or XR, Crossplane refers to the ProviderConfig named
    `default`. This way of organizing infrastructure resources under different credentials
    can help us manage infrastructure billing and maintain resources concerning the
    organizational structure in groups. The following YAML will provision POSTGRES
    from GCP using the provider config named `gcp-credentials-project-1`, which we
    created in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure represents multiple teams using different provider configs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Multiple provider configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Multiple provider configuration
  prefs: []
  type: TYPE_NORMAL
- en: An example of POSTGRES provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time that we go through an actual provisioning experience. We will create
    a POSTGRES instance in GCP using `CloudSQLInstance`, an MR available in the GCP
    Crossplane provider. Direct provisioning of infrastructure resources with an MR
    or XR is not a good strategy. Instead, we should be using the claim object created
    with XR for provisioning. The next chapter is devoted to covering these topics.
    Currently, we are using an MR for resource provisioning to understand the basic
    building blocks of Crossplane. We are going to use the following attributes while
    provisioning the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the resource provisioned should be `db-gcp`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The region of provisioning will be `us-central`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will request POSTGRES version 9.6 – `POSTGRES_9_6`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the data disk should be 20 GB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GCP tier of the database should be `db-g1-small`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the resource under the `gcp-credentials-project-1` provider configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database credentials should go to a `crossplane-system` namespace with a Secret
    named `db-conn`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are just a few possible parameters. The complete API documentation for
    CloudSQLInstance is available at [https://doc.crds.dev/github.com/crossplane/provider-gcp/database.gcp.crossplane.io/CloudSQLInstance/v1beta1@v0.18.0](https://doc.crds.dev/github.com/crossplane/provider-gcp/database.gcp.crossplane.io/CloudSQLInstance/v1beta1@v0.18.0).
    Note that there is a required tag against a few API parameters, which are mandatory
    in YAML. The following YAML code will provision GCP POSTGRES with the mentioned
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you apply the YAML code, you can see the resources provisioned in the
    GCP console. Use the following command to look at the states. Note that, initially,
    we will see the status as pending creation (`PENDING_CREATE`), and it will soon
    become runnable (`RUNNABLE`). Also, we can see that the database credentials are
    available in the Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Database provisioning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Database provisioning
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we look at the database details in the GCP console and change the database
    machine type. Crossplane will restore it to the original tier mentioned in the
    YAML code. It was fun to try that and see the status change. Initially, it will
    go into maintenance mode when we change the console, and then Crossplane will
    realize that something was changed to put the resource out of sync. Then, Crossplane
    will bring it back to its original state. Please refer to the following screenshot
    and go through values in each column (`STATE`, `SYNCED`, and `READY`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The reconciliation loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – The reconciliation loop
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the resources will sync. We can clean up the provisioned resources
    based on the deletion policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The final state'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B17830.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – The final state
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create the resource in the vendor infrastructure with a name
    different from that of the Crossplane resource claim, use the `crossplane.io/external-name:my-special-name`
    annotation in the metadata section.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples discussed throughout this book can be referred to at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started with understanding CRDs and custom controllers, and then the Kubernetes
    resource extension point concept, which are the building blocks of Crossplane.
    Then, we went through various Crossplane components, their architecture, and how
    those components fit together. Finally, we undertook some hands-on work by installing
    Crossplane and its GCP provider, and experimenting with Postgres database provisioning.
    Now we know how Crossplane works end to end, which brings us to the end of the
    chapter. In the next chapter, we will learn advanced Crossplane concepts.
  prefs: []
  type: TYPE_NORMAL
