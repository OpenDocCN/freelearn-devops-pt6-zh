<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-109"><em class="italic"><a id="_idTextAnchor108"/>Chapter 7</em>: Installing and Running Operators with the Operator Lifecycle Manager</h1>
			<p>Up until now, the Operator development work covered in previous chapters has been mostly self-contained. That is, the development and deployment processes covered so far have been primarily focused on local environments with relatively few external services expected to interact with the Operator we have been writing. While these processes are useful (and in some ways essential) to the early design of an Operator, there is an expectation for most Operators (and indeed, most software projects in general) that they will eventually be exposed to the outside world. This chapter will focus on this phase of an Operator's lifespan, wherein the Operator is presented and consumed by external users.</p>
			<p>In <a href="B18147_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to the Operator Framework</em>, the three main pillars of the Operator Framework were introduced. Several chapters of this book have already been devoted to the first pillar (the Operator SDK), but the remaining pillars have yet to be explored in detail. These are the <strong class="bold">Operator Lifecycle Manager</strong> (<strong class="bold">OLM</strong>) and <strong class="bold">OperatorHub</strong>. These two components of the Operator Framework are the key transitory elements in an Operator's development from an experimental, local prototype to a published, installable product. In this chapter, we will cover the necessary steps to graduate from an Operator in development to one that is accessible by users, through the following sections:</p>
			<ul>
				<li>Understanding the OLM</li>
				<li>Running your Operator</li>
				<li>Working with OperatorHub</li>
				<li>Troubleshooting</li>
			</ul>
			<p>By packaging an Operator to be installed and managed by the OLM and then publishing that Operator on OperatorHub, we will be leveraging the standard deployment workflow that users expect from the Operator Framework. These steps are by no means necessary, as we have already shown that it is possible to manually build and deploy an Operator without the OLM or OperatorHub. But, it is the goal of this chapter to introduce these pillars of the Operator Framework to demonstrate how we can transform an Operator into a rich community project.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Technical requirements</h1>
			<p>This chapter will continue to work with the nginx Operator that was written in <a href="B18147_04_ePub.xhtml#_idTextAnchor066"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing an Operator with the Operator SDK,</em> and <a href="B18147_05_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 5</em></a>, <em class="italic">Developing an Operator – Advanced Functionality</em>. It will also assume access to a public Docker registry (previously used in <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Building and Deploying Your Operator</em>), as well as access to a running <strong class="bold">Kubernetes</strong> cluster. Therefore, the technical requirements of this chapter build upon most of the requirements from previous chapters, including the following:</p>
			<ul>
				<li>Access to a Kubernetes cluster. It is recommended to use a disposable cluster created with a tool such as <strong class="bold">kind</strong> or <strong class="bold">minikube</strong> (see <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Building and Deploying Your Operator</em>).</li>
				<li>The <strong class="source-inline">kubectl</strong> binary available on your local system for interacting with the Kubernetes cluster.</li>
				<li>The <strong class="source-inline">operator-sdk</strong> binary available on your local system for deploying the OLM and building Operator manifests.</li>
				<li>Docker installed and running to build Operator bundle images.</li>
				<li>A GitHub account and familiarity with the GitHub fork and pull request processes for submitting a new Operator to OperatorHub (demonstration only).</li>
			</ul>
			<p>The Code in Action video for this chapter can be viewed at: <a href="https://bit.ly/3PPItsB">https://bit.ly/3PPItsB</a></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>Understanding the OLM</h1>
			<p>The <a id="_idIndexMarker397"/>OLM was introduced in <a href="B18147_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to the Operator Framework,</em> as a tool for installing and managing Operators within a cluster. Its features include the ability to provide control over upgrading installed Operators and making these Operators visible to cluster users. It also helps maintain cluster stability by enforcing Operator dependencies and preventing conflicting APIs from different Operators. This is a brief overview, but these features make it a powerful tool for deploying Operators in production environments. You can find more details about the OLM's features in the Operator Framework documentation at <a href="https://olm.operatorframework.io/docs/#features-provided-by-olm">https://olm.operatorframework.io/docs/#features-provided-by-olm</a>.</p>
			<p>While this<a id="_idIndexMarker398"/> may make the OLM seem like a complex component to work with, it is actually no more than a set of resource manifests that <a id="_idIndexMarker399"/>can <a id="_idIndexMarker400"/>be installed in a cluster similarly to any other component or <a id="_idIndexMarker401"/>application (including Operators themselves). These <a id="_idIndexMarker402"/>resources include<a id="_idIndexMarker403"/> various <strong class="bold">Pods</strong> (managed by Deployments), <strong class="bold">CustomResourceDefinitions</strong> (<strong class="bold">CRDs</strong>), <strong class="bold">namespaces</strong>, <strong class="bold">ServiceAccounts</strong>, and <strong class="bold">RoleBindings</strong>. </p>
			<p>In addition, the Operator SDK command-line tools provide simple commands for easily installing and interacting with the OLM in a Kubernetes cluster.</p>
			<p>So, before it is possible to install Operators with the OLM, we must first install the OLM itself. This section will show the steps required to do so. It will also demonstrate some additional commands for interacting with the OLM via the command line, which will be helpful later on when installing and managing our own Operator.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Installing the OLM in a Kubernetes cluster</h2>
			<p>To<a id="_idIndexMarker404"/> install the OLM, first ensure that you have administrative access to a running Kubernetes cluster. Even though using the OLM to manage Operators is an acceptable practice for production clusters, it is strongly recommended to use a disposable cluster (created with a tool such as kind) while following along with this chapter. This makes it easy and affordable to destroy and re-build the cluster from scratch if necessary. If you already have a cluster running from a previous chapter, it may even be useful to shut down that cluster in order to start fresh (with kind, the command to do so is <strong class="source-inline">kind delete cluster</strong>).</p>
			<p>Next, invoke the <strong class="source-inline">operator-sdk</strong> binary to install the OLM in your cluster with the following command:</p>
			<p class="source-code">$ operator-sdk olm install</p>
			<p class="source-code">INFO[0000] Fetching CRDs for version "latest"           </p>
			<p class="source-code">INFO[0000] Fetching resources for resolved version "latest" </p>
			<p class="source-code">...</p>
			<p class="source-code">INFO[0027]   Deployment "olm/packageserver" successfully rolled out INFO[0028] Successfully installed OLM version "latest"  </p>
			<p>This <a id="_idIndexMarker405"/>command may take a moment to complete, but during that time you will see <strong class="source-inline">operator-sdk</strong> fetching the various resource manifests for the OLM and installing them in your Kubernetes cluster. Once this is complete, it will also print the final list of installed resources. Many of these are either cluster-scoped (such as the OLM-specific CRDs) or installed in the newly created <strong class="source-inline">olm</strong> namespace. You can see these resources by inspecting that namespace with <strong class="source-inline">kubectl</strong> using the following command:</p>
			<p class="source-code">$ kubectl get all -n olm</p>
			<p class="source-code">NAME                                    READY   STATUS    RESTARTS   AGE</p>
			<p class="source-code">pod/catalog-operator-5c4997c789-xr986   1/1     Running   0          4m35s</p>
			<p class="source-code">pod/olm-operator-6d46969488-nsrcl       1/1     Running   0          4m35s</p>
			<p class="source-code">pod/operatorhubio-catalog-h97sx         1/1     Running   0          4m27s</p>
			<p class="source-code">pod/packageserver-69649dc65b-qppvg      1/1     Running   0          4m26s</p>
			<p class="source-code">pod/packageserver-69649dc65b-xc2fr      1/1     Running   0          4m26s</p>
			<p class="source-code">NAME                            TYPE        CLUSTER-IP      EXTERNAL-IP   </p>
			<p class="source-code">service/operatorhubio-catalog   ClusterIP   10.96.253.116   &lt;none&gt;        service/packageserver-service   ClusterIP   10.96.208.29    &lt;none&gt;        </p>
			<p class="source-code">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE</p>
			<p class="source-code">deployment.apps/catalog-operator   1/1     1            1           4m35s</p>
			<p class="source-code">deployment.apps/olm-operator       1/1     1            1           4m35s</p>
			<p class="source-code">deployment.apps/packageserver      2/2     2            2           4m26s</p>
			<p class="source-code">NAME                                          DESIRED   CURRENT   READY   replicaset.apps/catalog-operator-5c4997c789   1         1         1       replicaset.apps/olm-operator-6d46969488       1         1         1       replicaset.apps/packageserver-69649dc65b      2         2         2       </p>
			<p>Notably, there<a id="_idIndexMarker406"/> are five Pods in this namespace that perform the core functions of the OLM. These Pods work together to provide the cohesive functionality that comprises the OLM, including tracking Operator subscriptions and watching for custom resources that indicate Operator installations in the cluster.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Interacting with the OLM</h2>
			<p>Along <a id="_idIndexMarker407"/>with <strong class="source-inline">operator-sdk olm install</strong> (which, as the name implies, installs the OLM in a cluster), the <strong class="source-inline">operator-sdk</strong> binary also provides two more OLM-specific commands: <strong class="source-inline">olm uninstall</strong> and <strong class="source-inline">olm status</strong>. The former will remove the OLM and all of its dependent manifests from your cluster, while the latter provides information on the current status of the OLM resources in the cluster. For a healthy OLM installation, that output looks like this:</p>
			<p class="source-code">$ operator-sdk olm status</p>
			<p class="source-code">INFO[0000] Fetching CRDs for version "v0.20.0"          </p>
			<p class="source-code">INFO[0000] Fetching resources for resolved version "v0.20.0" </p>
			<p class="source-code">INFO[0002] Successfully got OLM status for version "v0.20.0" </p>
			<p class="source-code">NAME                                            NAMESPACE    KIND                        STATUS</p>
			<p class="source-code">operatorgroups.operators.coreos.com                          CustomResourceDefinition    Installed</p>
			<p class="source-code">operatorconditions.operators.coreos.com                      CustomResourceDefinition    Installed</p>
			<p class="source-code">olmconfigs.operators.coreos.com                              CustomResourceDefinition    Installed</p>
			<p class="source-code">installplans.operators.coreos.com                            CustomResourceDefinition     Installed</p>
			<p class="source-code">clusterserviceversions.operators.coreos.com                  CustomResourceDefinition    Installed</p>
			<p class="source-code">olm-operator-binding-olm                                     ClusterRoleBinding          Installed</p>
			<p class="source-code">operatorhubio-catalog                           olm          CatalogSource               Installed</p>
			<p class="source-code">olm-operators                                   olm          OperatorGroup               Installed</p>
			<p class="source-code">aggregate-olm-view                                           ClusterRole                 Installed</p>
			<p class="source-code">catalog-operator                                olm          Deployment                  Installed</p>
			<p class="source-code">cluster                                                      OLMConfig                   Installed</p>
			<p class="source-code">operators.operators.coreos.com                               CustomResourceDefinition    Installed</p>
			<p class="source-code">olm-operator                                    olm          Deployment                  Installed</p>
			<p class="source-code">subscriptions.operators.coreos.com                           CustomResourceDefinition    Installed</p>
			<p class="source-code">aggregate-olm-edit                                           ClusterRole                 Installed</p>
			<p class="source-code">olm                                                          Namespace                   Installed</p>
			<p class="source-code">global-operators                                operators    OperatorGroup               Installed</p>
			<p class="source-code">operators                                                    Namespace                   Installed</p>
			<p class="source-code">packageserver                                   olm          ClusterServiceVersion       Installed</p>
			<p class="source-code">olm-operator-serviceaccount                     olm          ServiceAccount              Installed</p>
			<p class="source-code">catalogsources.operators.coreos.com                          CustomResourceDefinition    Installed</p>
			<p class="source-code">system:controller:operator-lifecycle-manager                 ClusterRole                 Installed</p>
			<p>However, if the <a id="_idIndexMarker408"/>OLM was not behaving properly or there were issues with Operators in your cluster, this command could be used to debug the cause. For example, you can run <strong class="source-inline">kubectl delete crd/operatorgroups.operators.coreos.com</strong> (which deletes the <strong class="source-inline">OperatorGroups</strong> CRD installed by the OLM). Following this, running <strong class="source-inline">operator-sdk olm status</strong> will show the error <strong class="source-inline">no matches for kind "OperatorGroup" in version "operators.coreos.com/v1</strong> next to the <strong class="source-inline">global-operators</strong> and <strong class="source-inline">olm-operators</strong> entries, indicating that the CRD is missing in the cluster. </p>
			<p>This error can be repaired by uninstalling the OLM with <strong class="source-inline">operator-sdk olm uninstall</strong> and reinstalling it. Note that uninstalling the OLM does not uninstall any of the Operators it manages in the cluster. This is intentional to prevent data loss, but it also means that any desire to remove Operators from the cluster cannot be done by simply uninstalling the OLM.</p>
			<p>Besides installing and checking on the health of the OLM itself, the other way to interact with it is by installing and managing Operators. But first, the Operator must be prepared in a way that the OLM will understand. This is<a id="_idIndexMarker409"/> called <strong class="bold">the Operator's bundle</strong>, and we will show how to generate it in the next section.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Running your Operator</h1>
			<p>In <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Building and Deploying Your Operator</em>, we demonstrated ways to build and run an <a id="_idIndexMarker410"/>Operator manually by either compiling locally or building a Docker image to run in a Kubernetes cluster. But, neither of these methods is directly compatible with the OLM, so in order to provide an Operator that can be installed by the OLM, the Operator must be prepared with a bundle that contains metadata about the Operator in a format that the OLM understands. Then, this bundle can be passed to the OLM, which will handle the rest of the installation and life cycle management of the Operator.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Generating an Operator's bundle</h2>
			<p>An <a id="_idIndexMarker411"/>Operator's bundle consists of various manifests that describe the Operator and provide additional metadata, such as its dependencies and APIs. Once created, these manifests can be compiled into a <strong class="bold">bundle image</strong>, which is a deployable<a id="_idIndexMarker412"/> container image that is used by the OLM to install the Operator in a cluster.</p>
			<p>The simplest way to generate the bundle manifests is by running <strong class="source-inline">make bundle</strong>. This command will ask you to provide some metadata about the Operator and compile that input into the output resource manifests. </p>
			<p class="callout-heading">Note </p>
			<p class="callout"><strong class="source-inline">make bundle</strong> generates a container image name in some fields based on the same <strong class="source-inline">IMG</strong> environment variable used in <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Building and Deploying Your Operator</em>. Ensure that this environment variable is still set when generating the bundle, or that it is otherwise being passed to the <strong class="source-inline">make bundle</strong> command when it is invoked.</p>
			<p>The following block shows the output of <strong class="source-inline">make bundle</strong>. In this case, we will fill out the prompts for our nginx Operator with the company name, <strong class="source-inline">MyCompany</strong>, as well as some additional keywords and <a id="_idIndexMarker413"/>contact information for the maintainers of the Operator:</p>
			<p class="source-code">$ make bundle</p>
			<p class="source-code">/Users/mdame/nginx-operator/bin/controller-gen rbac:roleName=manager-role crd webhook paths="./..." output:crd:artifacts:config=config/crd/bases</p>
			<p class="source-code">operator-sdk generate kustomize manifests -q</p>
			<p class="source-code">Display name for the operator (required): </p>
			<p class="source-code">&gt; Nginx Operator</p>
			<p class="source-code">Description for the operator (required): </p>
			<p class="source-code">&gt; Operator for managing a basic Nginx deployment</p>
			<p class="source-code">Provider's name for the operator (required): </p>
			<p class="source-code">&gt; MyCompany</p>
			<p class="source-code">Any relevant URL for the provider name (optional): </p>
			<p class="source-code">&gt; http://mycompany.example</p>
			<p class="source-code">Comma-separated list of keywords for your operator (required): </p>
			<p class="source-code">&gt; nginx,tutorial</p>
			<p class="source-code">Comma-separated list of maintainers and their emails (e.g. 'name1:email1, name2:email2') (required): </p>
			<p class="source-code">&gt; Mike Dame:mike@mycompany.example</p>
			<p class="source-code">cd config/manager &amp;&amp; /Users/mdame/nginx-operator/bin/kustomize edit set image controller=controller:latest</p>
			<p class="source-code">/Users/mdame/nginx-operator/bin/kustomize build config/manifests | operator-sdk generate bundle -q --overwrite --version 0.0.1  </p>
			<p class="source-code">INFO[0000] Creating bundle.Dockerfile                   </p>
			<p class="source-code">INFO[0000] Creating bundle/metadata/annotations.yaml    </p>
			<p class="source-code">INFO[0000] Bundle metadata generated suceessfully       </p>
			<p class="source-code">operator-sdk bundle validate ./bundle</p>
			<p class="source-code">INFO[0000] All validation tests have completed successfully </p>
			<p>During this step, the <a id="_idIndexMarker414"/>generator will request the following inputs one by one: </p>
			<ul>
				<li><strong class="source-inline">Display name for the operator</strong>: This is the name that will be used for displaying the Operator on resources such as OperatorHub. So, it should be readable and clear with proper capitalization. For example, we have chosen <strong class="source-inline">Nginx Operator</strong>.</li>
				<li><strong class="source-inline">Description for the operator</strong>: This field provides a description of the Operator and its functionality. Similar to the display name, this is intended for users to see. Therefore, it should also be clear and thorough to describe the Operator's functionality in detail.</li>
				<li><strong class="source-inline">Provider's name for the operator</strong>: This is the name of the provider, or developer, of the Operator. For a single developer, it can simply be your name. Or, for larger organizations, it could be a company or department name. </li>
				<li><strong class="source-inline">Any relevant URL for the provider name</strong>: This is the opportunity for developers to provide an external URL to find more information about the developer. This could be a personal blog, GitHub account, or corporate website.</li>
				<li><strong class="source-inline">Comma-separated list of keywords for your operator</strong>: This is a list of keywords that can help users categorize and find your Operator. For this example, we have chosen <strong class="source-inline">nginx,tutorial</strong>, but you could just as easily provide a different list, such as <strong class="source-inline">deployment,nginx,high availability,metrics</strong>. This gives more insight into the key functionality we have developed for this Operator. Note also that the list is comma-separated, so <strong class="source-inline">high availability</strong> is one keyword.</li>
				<li><strong class="source-inline">Comma-separated list of maintainers and their emails</strong>: Finally, this section is a chance to provide the contact information for the maintainers of the Operator. This gives users information on who to contact for support or bug reporting. However, it can be useful for the developer's privacy to provide a <a id="_idIndexMarker415"/>corporate address rather than personal contact information.</li>
			</ul>
			<p>These fields correspond<a id="_idIndexMarker416"/> to matching fields in the Operator's <strong class="bold">cluster service version </strong>(<strong class="bold">CSV</strong>) file (the CSV was briefly described in <a href="B18147_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to the Operator Framework</em>, and will be explained in more detail later in this chapter under <em class="italic">Working with OperatorHub</em>). You can find more<a id="_idIndexMarker417"/> information about how each of these fields is used in the Operator Framework documentation at <a href="https://sdk.operatorframework.io/docs/olm-integration/generation/#csv-fields">https://sdk.operatorframework.io/docs/olm-integration/generation/#csv-fields</a>.</p>
			<p>The CSV is one of several new files created in the project after running <strong class="source-inline">make bundle</strong>. The majority of these new files are created under a new directory called <strong class="source-inline">bundle/</strong>. There is also a new file at the root of the project called <strong class="source-inline">bundle.Dockerfile</strong>, which is used to compile the manifests into the bundle image.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Exploring the bundle files</h2>
			<p>The <a id="_idIndexMarker418"/>files generated by <strong class="source-inline">make bundle</strong> contain metadata about the Operator that can be used by the OLM to install and manage the Operator, as well as OperatorHub, to provide information to users about the Operator and its dependencies and capabilities. Within the <strong class="source-inline">bundle/</strong> directory are three subdirectories that contain the following files:</p>
			<ul>
				<li><strong class="source-inline">tests/</strong>: These <a id="_idIndexMarker419"/>are configuration files for running scorecard tests, which are a series of tests designed to validate the Operator's bundle (see <a href="https://sdk.operatorframework.io/docs/testing-operators/scorecard">https://sdk.operatorframework.io/docs/testing-operators/scorecard</a>).</li>
				<li><strong class="source-inline">metadata/</strong>: This <a id="_idIndexMarker420"/>contains an <strong class="source-inline">annotations.yaml</strong> file, which provides the OLM with information about an Operator's version and dependencies. The annotations in this file must be the same as the labels specified in <strong class="source-inline">bundle.Dockerfile</strong> (more on that file shortly), and should usually not be modified.</li>
				<li><strong class="source-inline">manifests/</strong>: This <a id="_idIndexMarker421"/>directory contains various manifests required by your operator, including the Operator's CRD and metrics-related resources (if applicable). Most notably, however, is the CSV, which contains the bulk of the Operator's metadata.</li>
			</ul>
			<p>The Operator's CSV is<a id="_idIndexMarker422"/> the most interesting of these files, as it contains much of the information used by the OLM to process the creation of the Operator, as well as OperatorHub, to display important information to users about the Operator. The one created for our nginx Operator is named <strong class="source-inline">nginx-operator.clusterserviceversion.yaml</strong>, and contains the following sections:</p>
			<ol>
				<li>Metadata, including a sample custom resource object (to be created by the user for configuring the Operator) and its capability level:<p class="source-code">apiVersion: operators.coreos.com/v1alpha1</p><p class="source-code">kind: ClusterServiceVersion</p><p class="source-code">metadata:</p><p class="source-code">  annotations:</p><p class="source-code">    alm-examples: |-</p><p class="source-code">      [</p><p class="source-code">        {                                                                                                                                                                                                 </p><p class="source-code">          "apiVersion": "operator.example.com/v1alpha1",</p><p class="source-code">          "kind": "NginxOperator",</p><p class="source-code">          "metadata": {</p><p class="source-code">            "name": "nginxoperator-sample"</p><p class="source-code">          },                                                                                                                                                                                              </p><p class="source-code">          "spec": null</p><p class="source-code">        }                                                                                                                                                                                                 </p><p class="source-code">      ]                                                                                                                                                                                                   </p><p class="source-code">    capabilities: Basic Install</p><p class="source-code">    operators.operatorframework.io/builder: operator-sdk-v1.17.0</p><p class="source-code">    operators.operatorframework.io/project_layout: go.kubebuilder.io/v3</p><p class="source-code">  name: nginx-operator.v0.0.1</p><p class="source-code">  namespace: placeholder</p></li>
				<li>A <a id="_idIndexMarker423"/>specification field with the Operator's description, display name, display icon (if provided), and related CRDs:<p class="source-code">spec:</p><p class="source-code">  apiservicedefinitions: {}                                                                                                                                                                               </p><p class="source-code">  customresourcedefinitions:</p><p class="source-code">    owned:</p><p class="source-code">    - description: NginxOperator is the Schema for the nginxoperators API</p><p class="source-code">      displayName: Nginx Operator</p><p class="source-code">      kind: NginxOperator</p><p class="source-code">      name: nginxoperators.operator.example.com</p><p class="source-code">      version: v1alpha1</p><p class="source-code">  description: Operator for managing a basic Nginx deployment</p><p class="source-code">  displayName: Nginx Operator</p><p class="source-code">  icon:</p><p class="source-code">  - base64data: ""</p><p class="source-code">    mediatype: ""</p></li>
				<li>Installation instructions, including the cluster permissions and Deployment specification for the Operator Pod (omitted here for brevity).</li>
				<li>The <a id="_idIndexMarker424"/>install modes for the Operator, showing which namespace installation strategies it supports:<p class="source-code">  installModes:</p><p class="source-code">  - supported: false</p><p class="source-code">    type: OwnNamespace</p><p class="source-code">  - supported: false</p><p class="source-code">    type: SingleNamespace</p><p class="source-code">  - supported: false</p><p class="source-code">    type: MultiNamespace</p><p class="source-code">  - supported: true</p><p class="source-code">    type: AllNamespaces</p></li>
				<li>Keywords, maintainer information, provider URL, and version (as provided when running <strong class="source-inline">make bundle</strong>): <p class="source-code">  keywords:</p><p class="source-code">  - nginx</p><p class="source-code">  - tutorial</p><p class="source-code">  links:</p><p class="source-code">  - name: Nginx Operator</p><p class="source-code">    url: https://nginx-operator.domain</p><p class="source-code">  maintainers:</p><p class="source-code">  - email: mike@mycompany.example</p><p class="source-code">    name: Mike Dame</p><p class="source-code">  maturity: alpha</p><p class="source-code">  provider:</p><p class="source-code">    name: MyCompany</p><p class="source-code">    url: http://mycompany.example</p><p class="source-code">  version: 0.0.1</p></li>
			</ol>
			<p>Together, this <a id="_idIndexMarker425"/>information can be packaged together to provide enough data for the OLM to deploy and manage the Operator in a cluster. That package is known as the bundle image. </p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Building a bundle image</h2>
			<p>Once <a id="_idIndexMarker426"/>the bundle manifests have been generated, the bundle image can be built by calling <strong class="source-inline">make bundle-build</strong>. This command builds a Docker container based on the <strong class="source-inline">bundle.Dockerfile</strong> file that was generated earlier by <strong class="source-inline">make bundle</strong>. That <strong class="source-inline">Dockerfile</strong> file contains the following instructions:</p>
			<pre class="source-code">$ cat bundle.Dockerfile </pre>
			<pre class="source-code">FROM scratch</pre>
			<pre class="source-code"># Core bundle labels.</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.bundle.mediatype.v1=registry+v1</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.bundle.manifests.v1=manifests/</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.bundle.metadata.v1=metadata/</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.bundle.package.v1=nginx-operator</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.bundle.channels.v1=alpha</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.metrics.builder=operator-sdk-v1.17.0</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.metrics.mediatype.v1=metrics+v1</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.metrics.project_layout=go.kubebuilder.io/v3</pre>
			<pre class="source-code"># Labels for testing.</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.test.mediatype.v1=scorecard+v1</pre>
			<pre class="source-code">LABEL operators.operatorframework.io.test.config.v1=tests/scorecard/</pre>
			<pre class="source-code"><strong class="bold"># Copy files to locations specified by labels.</strong></pre>
			<pre class="source-code"><strong class="bold">COPY bundle/manifests /manifests/</strong></pre>
			<pre class="source-code"><strong class="bold">COPY bundle/metadata /metadata/</strong></pre>
			<pre class="source-code"><strong class="bold">COPY bundle/tests/scorecard /tests/scorecard/</strong></pre>
			<p>Similar to <a id="_idIndexMarker427"/>the main <strong class="source-inline">Dockerfile</strong> file used to compile the Operator image in <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>,<em class="italic"> Building and Deploying Your Operator</em>, one of the key steps in this Dockerfile's build is to copy the essential bundle files from the <strong class="source-inline">bundle/</strong> directory into its own image (highlighted in the preceding code block). It also labels the resulting image with various metadata about the operator, its versions, and the tools used to build it.</p>
			<p>Running <strong class="source-inline">make bundle-build</strong> produces the following build log:</p>
			<p class="source-code">$ make bundle-build</p>
			<p class="source-code">docker build -f bundle.Dockerfile -t example.com/nginx-operator-bundle:v0.0.1 .</p>
			<p class="source-code">[+] Building 0.4s (7/7) FINISHED                                                                                                                                                 </p>
			<p class="source-code"> =&gt; [internal] load build definition from bundle.Dockerfile                                                                                                                </p>
			<p class="source-code"> =&gt; =&gt; transferring dockerfile: 966B                                                                                                                                       </p>
			<p class="source-code"> =&gt; [internal] load .dockerignore                                                                                                                                          </p>
			<p class="source-code"> =&gt; =&gt; transferring context: 35B                                                                                                                                           </p>
			<p class="source-code"> =&gt; [internal] load build context                                                                                                                                          </p>
			<p class="source-code"> =&gt; =&gt; transferring context: 16.73kB                                                                                                                                       </p>
			<p class="source-code"> =&gt; [1/3] COPY bundle/manifests /manifests/                                                                                                                                </p>
			<p class="source-code"> =&gt; [2/3] COPY bundle/metadata /metadata/                                                                                                                                  </p>
			<p class="source-code"> =&gt; [3/3] COPY bundle/tests/scorecard /tests/scorecard/                                                                                                                    </p>
			<p class="source-code"> =&gt; exporting to image                                                                                                                                                     </p>
			<p class="source-code"> =&gt; =&gt; exporting layers                                                                                                                                                    </p>
			<p class="source-code"> =&gt; =&gt; writing image</p>
			<p class="source-code">sha256:6b4bf32edd5d15461d112aa746a9fd4154fefdb1f9cfc49b 56be52548ac66921                                                                               </p>
			<p class="source-code"> =&gt; =&gt; naming to example.com/nginx-operator-bundle:v0.0.1                                                                                                                  </p>
			<p>However, note<a id="_idIndexMarker428"/> that the name of the new container image is <strong class="source-inline">example.com/nginx-operator-bundle</strong>, which you can confirm by running <strong class="source-inline">docker images</strong>:</p>
			<p class="source-code">$ docker images</p>
			<p class="source-code">REPOSITORY                           TAG       IMAGE ID       CREATED          example.com/nginx-operator-bundle    v0.0.1    6b4bf32edd     29 seconds ago   </p>
			<p>This generic name is used because <strong class="source-inline">make bundle-build</strong> depends on a different environment variable than the <strong class="source-inline">IMG</strong> variable that was used earlier to build the Operator image manually (and generate the bundle manifests). To set a custom bundle image name, either tag the generated image or re-run <strong class="source-inline">make bundle-build</strong> with the <strong class="source-inline">BUNDLE_IMG</strong> variable set. An <a id="_idIndexMarker429"/>example is shown here:</p>
			<p class="source-code">$ BUNDLE_IMG=docker.io/myregistry/nginx-bundle:v0.0.1 make bundle-build</p>
			<p>This will generate the bundle image with the name <strong class="source-inline">docker.io/myregistry/nginx-bundle:v0.0.1</strong>.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Pushing a bundle image</h2>
			<p>Recall <a id="_idIndexMarker430"/>that in <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Building and Deploying Your Operator</em>, it was necessary to not only build the container image for the Operator but also push it to a publicly accessible registry. This made the image available to our Kubernetes cluster. Similarly, the bundle image must also be accessible by the cluster (and the OLM). For this reason, we must also push the bundle image to a registry so that the OLM can pull it into the cluster.</p>
			<p>The Operator SDK makes this step easy with the <strong class="source-inline">make bundle-push</strong> command:</p>
			<p class="source-code">$ make bundle-push</p>
			<p class="source-code">/Library/Developer/CommandLineTools/usr/bin/make docker-push IMG=docker.io/mdame/nginx-bundle:v0.0.1</p>
			<p class="source-code">docker push docker.io/mdame/nginx-bundle:v0.0.1</p>
			<p class="source-code">The push refers to repository [docker.io/mdame/nginx-bundle]</p>
			<p class="source-code">79c3f933fff3: Pushed </p>
			<p class="source-code">93e60c892495: Pushed </p>
			<p class="source-code">dd3276fbf1b2: Pushed </p>
			<p class="source-code">v0.0.1: digest: sha256:f6938300b1b8b5a2ce127273e2e48443 ad3ef2e558cbcf260d9b03dd00d2f230 size: 939</p>
			<p>This command simply calls <strong class="source-inline">docker push</strong>, but it inherits the environment variables that have been set and used in previous commands (for example, <strong class="source-inline">BUNDLE_IMG</strong>). This convenience helps reduce the chance of making a mistake and pushing the wrong image name to the wrong registry.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Deploying an Operator bundle with the OLM</h2>
			<p>With a <a id="_idIndexMarker431"/>bundle image built and pushed to an accessible registry, it is simple to deploy the Operator from its bundle with the <strong class="source-inline">operator-sdk run bundle</strong> command. For example, we can now deploy the nginx Operator bundle from the previous section by running the following:</p>
			<p class="source-code">$ operator-sdk run bundle docker.io/mdame/nginx-bundle:v0.0.1</p>
			<p class="source-code">INFO[0013] Successfully created registry pod: docker-io-mdame-nginx-bundle-v0-0-1 </p>
			<p class="source-code">INFO[0013] Created CatalogSource: nginx-operator-catalog </p>
			<p class="source-code">INFO[0013] OperatorGroup "operator-sdk-og" created      </p>
			<p class="source-code">INFO[0013] Created Subscription: nginx-operator-v0-0-1-sub </p>
			<p class="source-code">INFO[0016] Approved InstallPlan install-44bh9 for the Subscription: nginx-operator-v0-0-1-sub </p>
			<p class="source-code">INFO[0016] Waiting for ClusterServiceVersion "default/nginx-operator.v0.0.1" to reach 'Succeeded' phase </p>
			<p class="source-code">INFO[0016]   Waiting for ClusterServiceVersion "default/nginx-operator.v0.0.1" to appear </p>
			<p class="source-code">INFO[0023]   Found ClusterServiceVersion "default/nginx-operator.v0.0.1" phase: Pending </p>
			<p class="source-code">INFO[0026]   Found ClusterServiceVersion "default/nginx-operator.v0.0.1" phase: Installing </p>
			<p class="source-code">INFO[0046]   Found ClusterServiceVersion "default/nginx-operator.v0.0.1" phase: Succeeded </p>
			<p class="source-code">INFO[0046] OLM has successfully installed "nginx-operator.v0.0.1"</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This command may take a few minutes to succeed. However, if the Operator's  <strong class="source-inline">ClusterServiceVersion</strong> object fails to install, double-check that you have followed the steps to install <strong class="bold">kube-prometheus</strong> in the cluster, as detailed in <a href="B18147_06_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Building and Deploying Your Operator</em>. If the Operator bundle has been built to include references to Prometheus resources, and these resources are not present in the cluster, this can cause the Operator's installation to fail.</p>
			<p>This command<a id="_idIndexMarker432"/> creates the resources necessary for the OLM to install the nginx Operator using only the information in the Operator's bundle, including <strong class="source-inline">CatalogSource</strong>, <strong class="source-inline">OperatorGroup</strong>, <strong class="source-inline">Subscription</strong>, and <strong class="source-inline">InstallPlan</strong>.</p>
			<p>The Operator can then be uninstalled using the <strong class="source-inline">operator-sdk cleanup &lt;packageName&gt;</strong> command, where <strong class="source-inline">&lt;packageName&gt;</strong> is defined in the Operator's <strong class="source-inline">PROJECT</strong> file as <strong class="source-inline">projectName</strong>:</p>
			<p class="source-code">$ operator-sdk cleanup nginx-operator</p>
			<p class="source-code">INFO[0000] subscription "nginx-operator-v0-0-1-sub" deleted </p>
			<p class="source-code">INFO[0000] customresourcedefinition "nginxoperators.operator.example.com" deleted </p>
			<p class="source-code">INFO[0000] clusterserviceversion "nginx-operator.v0.0.1" deleted </p>
			<p class="source-code">INFO[0000] catalogsource "nginx-operator-catalog" deleted </p>
			<p class="source-code">INFO[0000] operatorgroup "operator-sdk-og" deleted      </p>
			<p class="source-code">INFO[0000] Operator "nginx-operator" uninstalled  </p>
			<p>This concludes the normal development workflow for building and deploying Operators with the OLM manually. However, there is another source for Operators to install in a cluster. This is <strong class="bold">OperatorHub</strong>, and it is the focus of the next section.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Working with OperatorHub</h1>
			<p>Any successful <a id="_idIndexMarker433"/>open source project requires a dedicated community of users and developers to help the project's ecosystem thrive. The Operator Framework is no different, and at the center of this community is the Operator catalog of <a href="https://operatorhub.io/">https://operatorhub.io/</a>. In fact, this <a id="_idIndexMarker434"/>centralization is the exact goal of OperatorHub, as stated on <a href="https://operatorhub.io/about">https://operatorhub.io/about</a>:</p>
			<p class="author-quote">While there are several approaches to implement Operators yielding the same level of integration with Kubernetes, what has been missing is a central location to find the wide array of great Operators that have been built by the community. OperatorHub.io aims to be that central location.</p>
			<p>Launched in 2019 <a id="_idIndexMarker435"/>by a collaborative effort between <strong class="bold">Red Hat</strong>, <strong class="bold">AWS</strong>, <strong class="bold">Google Cloud</strong>, and <strong class="bold">Microsoft</strong>, OperatorHub <a id="_idIndexMarker436"/>has been a driving force in the <a id="_idIndexMarker437"/>growth<a id="_idIndexMarker438"/> and<a id="_idIndexMarker439"/> adoption of Kubernetes Operators. As of the time of writing, the OperatorHub index contains over 200 Operators (and this number continues to grow). Backed by only a public GitHub repository and many volunteer maintainers, the open concept of catalog moderation and acceptance of OperatorHub supports the very ideals of Kubernetes, by allowing anyone from any organization to contribute their Operator to the catalog and make it accessible to all.</p>
			<p>In short, OperatorHub makes it easy to promote your own Operators, as well as finding and installing Operators developed by other providers. In this section, we'll demonstrate how to do both of these by working with the OperatorHub website and backend.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Installing Operators from OperatorHub</h2>
			<p>Installing an <a id="_idIndexMarker440"/>Operator from OperatorHub in your own Kubernetes cluster is very easy using the catalog on <a href="https://operatorhub.io/">https://operatorhub.io/</a>. You can begin by browsing the list of all available Operators, or by searching in the text box on the OperatorHub home page. You can also narrow down your search by category (available categories include <strong class="bold">AI/Machine Learning</strong>, <strong class="bold">Big Data</strong>, <strong class="bold">Cloud Provider</strong>, and <strong class="bold">Monitoring</strong>).</p>
			<p>For an arbitrary example, the <strong class="bold">Grafana</strong> Operator <a id="_idIndexMarker441"/>can be found under <strong class="bold">Monitoring</strong>. Grafana is an analytics and monitoring visualization platform that provides rich, insightful tools for viewing application health. The following is a screenshot showing <strong class="bold">Grafana Operator</strong> and others available in the <strong class="bold">Monitoring</strong> category on OperatorHub:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B18147_07_001.jpg" alt="Figure 7.1 – Screenshot of the OperatorHub Monitoring category"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Screenshot of the OperatorHub Monitoring category</p>
			<p>Clicking <a id="_idIndexMarker442"/>on the <strong class="bold">Grafana Operator</strong> tile opens up the information page for this specific Operator. This page includes information such as the Operator's current functionality level in the Capability Model, which versions of the Operator have been published, and information about the provider and maintainer of the Operator. The following is a screenshot showing what the <strong class="bold">Grafana Operator</strong> information page looks like on OperatorHub:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B18147_07_002.jpg" alt="Figure 7.2 – Grafana Operator information page"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Grafana Operator information page</p>
			<p>Also <a id="_idIndexMarker443"/>available on this page are installation instructions for this Operator, found by clicking the <strong class="bold">Install</strong> button on the top right of the Operator's description. This opens a new window with commands that can be copied and pasted to install the OLM, the Operator itself, and how to watch the Operator startup. Since we already have the OLM installed in a cluster, we can skip to <em class="italic">Step 2</em> and copy the <strong class="source-inline">install</strong> command for this Operator. This is shown in the following screenshot of the Grafana Operator installation instructions:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B18147_07_003.jpg" alt="Figure 7.3 – Grafana Operator installation instructions"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Grafana Operator installation instructions</p>
			<p>Running this <a id="_idIndexMarker444"/>command in a terminal produces the following output:</p>
			<p class="source-code">$ kubectl create -f https://operatorhub.io/install/grafana-operator.yaml</p>
			<p class="source-code">namespace/my-grafana-operator created</p>
			<p class="source-code">operatorgroup.operators.coreos.com/operatorgroup created</p>
			<p class="source-code">subscription.operators.coreos.com/my-grafana-operator created</p>
			<p>Following this, the new namespace, <strong class="source-inline">my-grafana-operator</strong>, has been created with the resources necessary for this Operator:</p>
			<p class="source-code">$ kubectl get all -n my-grafana-operator</p>
			<p class="source-code">NAME                                                      READY   STATUS   pod/grafana-operator-controller-manager-b95954bdd-sqwzr   2/2     Running   </p>
			<p class="source-code">NAME                                                          TYPE        service/grafana-operator-controller-manager-metrics-service   ClusterIP  </p>
			<p class="source-code">NAME                                                  READY   UP-TO-DATE   deployment.apps/grafana-operator-controller-manager   1/1     1            1           </p>
			<p class="source-code">NAME                                                            DESIRED   replicaset.apps/grafana-operator-controller-manager-b95954bdd   1         1         </p>
			<p>In addition, this<a id="_idIndexMarker445"/> command also created an <strong class="source-inline">OperatorGroup</strong> object and <strong class="source-inline">Subscription</strong> object for this Operator. These resource types are CRDs that were installed in the cluster by the OLM and implemented by individual Operators to represent their installation. The details about what each of these objects does are available in <a id="_idIndexMarker446"/>the OperatorHub documentation at <a href="https://operatorhub.io/how-to-install-an-operator">https://operatorhub.io/how-to-install-an-operator</a>, but in summary, they define the user's (your) intent to install the Operator and inform the OLM about the location of the Operator's metadata on OperatorHub. The OLM uses this information to create the Deployment, Service, and other resources needed for the new Operator.</p>
			<p>Once an Operator has been installed, it is usually up to the user to create the configuration CRD object for that Operator. With so many different CRDs floating around, this can get confusing to keep track of. However, many of these CRDs (such as <strong class="source-inline">OperatorGroup</strong> and <strong class="source-inline">Subscription</strong>) are installed and managed automatically by tools such as the OLM, and they do not require manual interaction. Generally, the user is only concerned with the CRD object for a specific Operator's configuration (such as the one that we created for our nginx Operator). Most Operator <strong class="source-inline">README</strong> files and OperatorHub descriptions will contain example CRDs and steps to get started with each Operator (and it is a good practice to do so with your own Operator as well).</p>
			<p>Speaking of your own Operator, contributing to the OperatorHub catalog is almost as easy as installing Operators from it. In the next section, we'll look at how each of these Operators made their way onto OperatorHub and how yours can, too.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Submitting your own Operator to OperatorHub</h2>
			<p>While<a id="_idIndexMarker447"/> it is not required to publish any Operator publicly, many providers choose to do so, both for the benefit of the community and their own users. If the Operator you have developed is used to manage an application you offer to your users, public availability of the Operator can increase awareness of the application and bolster your organization's reputation among the open source community. Offering a free Operator shows your users that you are invested in providing a stable product with minimal engineering hours required on their part.</p>
			<p class="callout-heading">What Is Required from Operator SDK Projects?</p>
			<p class="callout">The Operator SDK, like many Kubernetes projects, is released <a id="_idIndexMarker448"/>under the <strong class="bold">Apache 2.0 License</strong>. This gives permissive usability of the project for commercial use, distribution, and private use (among other use cases). More information on the Operator SDK license is available at <a href="https://github.com/operator-framework/operator-sdk/blob/master/LICENSE">https://github.com/operator-framework/operator-sdk/blob/master/LICENSE</a>.</p>
			<p>Because the nginx Operator that we have been developing throughout this book is only intended as a tutorial (and not meant for public use), we cannot demonstrate the process for submitting it to OperatorHub. However, the general process for submitting an Operator to OperatorHub is outlined at <a href="https://operatorhub.io/contribute">https://operatorhub.io/contribute</a>. In broad terms, this involves the following steps:</p>
			<ol>
				<li value="1">Develop an Operator that is ready for publishing.</li>
				<li>Generate the Operator's bundle, including its CSV and related CRDs.</li>
				<li>Create<a id="_idIndexMarker449"/> a <strong class="bold">pull request</strong> (<strong class="bold">PR</strong>) against the OperatorHub repository on GitHub (<a href="https://github.com/k8s-operatorhub/community-operators">https://github.com/k8s-operatorhub/community-operators</a>) with your Operator's metadata.</li>
			</ol>
			<p>If you have been following the steps in this book up until this point, then you are already familiar with the first two steps. However, the third step is the most important part of submitting to <a id="_idIndexMarker450"/>OperatorHub, because the GitHub repository represents the entire catalog of Operators listed on OperatorHub. So, without the proper PR changes necessary to merge your Operator's information into this repository, it will not show up on OperatorHub.</p>
			<p class="callout-heading">Which OperatorHub Repository is which?</p>
			<p class="callout">Some outdated <a id="_idIndexMarker451"/>documentation that is still available refers to two different OperatorHub repository locations, <strong class="source-inline">community-operators</strong> and <strong class="source-inline">upstream-community-operators</strong>, which were originally subdirectories of the now-archived OperatorHub repository at <a href="https://github.com/operator-framework/community-operators">https://github.com/operator-framework/community-operators</a>. The former is a remnant of the initial work done by Red Hat to publish OperatorHub (specifically, it refers to a location that was reserved for Operators to be listed on an integrated version of OperatorHub within Red Hat's OpenShift distribution of Kubernetes). This OpenShift-specific Operator index has since been decoupled from the community repository referenced earlier. There is documentation available for contributing to the OpenShift catalog for developers who are interested in doing so, but this chapter will focus on the community OperatorHub, which is platform-agnostic.</p>
			<p>The steps to submit your Operator through GitHub are as follows (these steps assume some prior familiarity with GitHub and the fork/PR processes involved):</p>
			<ol>
				<li value="1">Fork the OperatorHub repository (<a href="https://github.com/k8s-operatorhub/community-operators">https://github.com/k8s-operatorhub/community-operators</a>) into your own GitHub account. This allows you to clone a local copy of the repository to your machine and make changes to it that will later be pulled into the upstream catalog via your PR.</li>
				<li>Create a new folder for your Operator under the <strong class="source-inline">operators/</strong> directory. It must have a unique name from all other Operators (for example, we could create <strong class="source-inline">operators/nginx-operator</strong>).</li>
				<li>Create a new file called <strong class="source-inline">ci.yaml</strong> in this directory. This file defines versioning semantics as well as the reviewers allowed to make changes to your Operator (more information available at <a href="https://k8s-operatorhub.github.io/community-operators/operator-ci-yaml/">https://k8s-operatorhub.github.io/community-operators/operator-ci-yaml/</a>). A <a id="_idIndexMarker452"/>simple <strong class="source-inline">ci.yaml</strong> file looks like the following:<p class="source-code">reviewers:</p><p class="source-code">  - myGithubUsername</p><p class="source-code">  - yourTeammateUsername</p></li>
				<li>Create a directory in your Operator's folder for each version you wish to publish (for example, <strong class="source-inline">operators/nginx-operator/0.0.1</strong>).</li>
				<li>Copy the contents of the <strong class="source-inline">bundle</strong> directory from your Operator's project into the new version folder.</li>
			</ol>
			<p>Also, copy<a id="_idIndexMarker453"/> the <strong class="source-inline">bundle.Dockerfile</strong> that was generated at your Operator's project root into the version folder.</p>
			<ol>
				<li value="6">Commit and push the changes to a new branch of your forked OperatorHub repository on GitHub.</li>
				<li>Navigate back to the upstream OperatorHub repository's PR page (<a href="https://github.com/k8s-operatorhub/community-operators/pulls">https://github.com/k8s-operatorhub/community-operators/pulls</a>) and click <strong class="bold">New pull request</strong>. Choose your fork and branch to merge into the upstream repository.</li>
				<li>Read the PR template description and ensure that you have followed all of the steps outlined. These prerequisite steps help expedite the review and approval process of your Operator's PR and include the following:<ol><li>Reviewing the community contribution guidelines</li><li>Testing your Operator in a local cluster</li><li>Verifying your Operator's metadata aligns with the standards of OperatorHub</li><li>Ensuring your Operator's description and versioning schema are sufficient for your users</li></ol></li>
			</ol>
			<p>Once you have reviewed the pre-submission checks in the PR template, submit your request. At this point, automated checks will validate your Operator's metadata to ensure it passes the quality<a id="_idIndexMarker454"/> thresholds for submission (and report any problems in a GitHub comment). If you need to make any changes to your submission in order for it to pass these checks, you can simply push the changes to your forked branch of the OperatorHub repository.</p>
			<p>Once your PR passes the pre-submission checks, it should automatically merge your changes into the upstream repository. Soon thereafter, your Operator will be visible on <a href="https://operatorhub.io/">https://operatorhub.io/</a> for the world to install! </p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Troubleshooting</h1>
			<p>While this chapter introduced some new concepts, including the OLM and OperatorHub, many of the resources already listed in earlier <em class="italic">Troubleshooting</em> sections throughout this book still apply. </p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>OLM support</h2>
			<p>The <a id="_idIndexMarker455"/>OLM and its related resources are related in general to<a id="_idIndexMarker456"/> Operator SDK development. So, there is reasonable help for this topic available in the <strong class="source-inline">#operator-sdk-dev</strong> Slack channel on <a href="http://slack.k8s.io">slack.k8s.io</a>. The OLM is also available on GitHub for reporting issues at <a href="https://github.com/operator-framework/operator-lifecycle-manager">https://github.com/operator-framework/operator-lifecycle-manager</a>. The documentation for integrating an Operator with the OLM is available as a primary resource at <a href="https://sdk.operatorframework.io/docs/olm-integration/">https://sdk.operatorframework.io/docs/olm-integration/</a>.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>OperatorHub support</h2>
			<p>OperatorHub <a id="_idIndexMarker457"/>is also available on GitHub at the catalog repository<a id="_idIndexMarker458"/> shown in this chapter (<a href="https://github.com/k8s-operatorhub/community-operators">https://github.com/k8s-operatorhub/community-operators</a>). For issues with the frontend <a href="https://operatorhub.io/">https://operatorhub.io/</a> website specifically, that code is located at <a href="https://github.com/k8s-operatorhub/operatorhub.io">https://github.com/k8s-operatorhub/operatorhub.io</a>. This repository provides detailed documentation on all of the necessary metadata and bundle files for OperatorHub submission (as well as the submission process itself) at <a href="https://k8s-operatorhub.github.io/community-operators/">https://k8s-operatorhub.github.io/community-operators/</a>.</p>
			<p>OperatorHub <a id="_idIndexMarker459"/>also provides validators and tools for <a id="_idIndexMarker460"/>previewing your Operator's submission prior to creating a PR against the repository. The preview tool is available at <a href="https://operatorhub.io/preview">https://operatorhub.io/preview</a>. Submitting the generated CSV in this tool will show a preview of how your Operator will look once it is submitted to OperatorHub:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B18147_07_004.jpg" alt="Figure 7.4 – Screenshot of the Nginx Operator preview on OperatorHub"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Screenshot of the Nginx Operator preview on OperatorHub</p>
			<p>Previewing an<a id="_idIndexMarker461"/> Operator's presentation can be a <a id="_idIndexMarker462"/>very helpful manual step in testing that all of the metadata prepared for that Operator is going to present to new users in the way that you want. It can be easy to lose track of the confusing CRD and CSV definitions, so previewing it gives early visual confirmation that everything is set up correctly. It also verifies that the metadata is syntactically valid.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Summary</h1>
			<p>This chapter concluded the primary development and publication of an Operator. If you have been following along up until this point while developing your own Operator, then congratulations! Your Operator is now published and accessible to new users thanks to the reach of OperatorHub. Starting from the early chapters of this book, we have shown the steps to design an Operator, develop its basic and advanced functionality with Go, build and deploy it for local testing, and finally, package and publish it for public distribution. However, very few Operator project life cycles will end at this point.</p>
			<p>It is likely that most Operators will eventually need to evolve, change their provided features, and release new versions. Doing so in a consistent and predictable way benefits both your users and your maintainers by establishing expected release standards. These standards include policies for deprecation and timelines for new releases. In the next chapter, we will explain some of the existing best practices used among Kubernetes projects and provoke forward-looking thoughts about how to prepare for the ongoing maintenance and development of your new Operator.</p>
		</div>
	</body></html>