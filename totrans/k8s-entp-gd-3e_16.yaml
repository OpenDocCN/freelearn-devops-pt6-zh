- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Introduction to Istio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “If it makes it easier for users to use on the frontend, it’s probably complex
    on the backend.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter will introduce you to Istio, a Service mesh add-on for Kubernetes.
    A Service mesh is a tool for Kubernetes that improves the management, security,
    and visibility of microservices in a cluster. It simplifies complex networking
    tasks by handling service-to-service communication, load balancing, and traffic
    routing outside the application code. Istio also enhances security with features
    like encryption, authentication, and authorization. It provides detailed metrics
    and monitoring, allowing developers to understand how their services are performing.
  prefs: []
  type: TYPE_NORMAL
- en: Istio is a large, complex system that provides benefits to your workloads by
    offering enhanced security, discovery, observability, traffic management, and
    more – all without requiring application developers to write modules or applications
    to handle each task.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Istio presents a steep learning curve, mastering it unlocks the potential
    to offer developers advanced functionalities, enabling intricate Service mesh
    deployments and a broad spectrum of capabilities, including the ability to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Route traffic based on various requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure service-to-service communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic shaping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service observability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The future: Ambient mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers can use these tools with minimal or no changes to their code. When
    something is easy for users, it often means there’s a lot of complexity behind
    the scenes, and Istio is a good example of this. This chapter will show you how
    to set up Istio and Kiali, a tool for monitoring. We’ll also discuss Istio’s key
    features that help manage traffic, enhance security, and reveal workloads.
  prefs: []
  type: TYPE_NORMAL
- en: To fully explain Istio, we’d need a whole other book focused just on its custom
    resources and ways to use them. Our aim in this chapter and the next is to give
    you the basic knowledge you need to start using Istio confidently. We can’t go
    into every detail about each component, so we recommend visiting the Istio website
    at [https://istio.io](https://istio.io) for additional information to build on
    what you will learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the control plane and data plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should you care about a Service mesh?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Istio concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Istio components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Istio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Istio resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying add-on components to provide observability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application into the Service mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The future: Ambient mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive into the chapter, let’s set the scene for what you’re about to
    learn. This chapter is designed to introduce you to deploying Istio and the main
    features it provides. It gives you the key details to understand how Istio functions
    and what its various parts are. By the end of this chapter and the next chapter,
    where you’ll add an application to the mesh, you should have a good grasp of how
    to set up and use a basic Istio Service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: We will close out the chapter with a look at the future of the Service mesh,
    known as the ambient mesh. As of the publishing of this book, the ambient mesh
    is still in beta, and since a lot of things can change between beta and a GA release,
    we will only provide an overview of what the ambient mesh will bring when it’s
    released.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap up this introduction, here’s a fun fact about Kubernetes: like many
    things in Kubernetes, Istio is named after something related to the sea. In Greek,
    “Istio” means “sail.”'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A Docker host installed using the steps from *Chapter 1*, *Docker and Container
    Essentials*, with a minimum of 8 GB of RAM, although 16 GB is recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A KinD cluster configured using the initial scripts from *Chapter 2*, *Deploying
    Kubernetes Using KinD*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation scripts from this book’s GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the code for this chapter by going to this book’s GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16).'
  prefs: []
  type: TYPE_NORMAL
- en: To use Istio to expose workloads, we will remove NGINX from the KinD cluster,
    which will allow Istio to utilize ports `80` and `443` on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Control Plane and Data Plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Service mesh framework enhances how microservices communicate, making these
    interactions more secure, faster, and more reliable. It is separated into two
    main components: the control plane and the data plane, each playing a specific
    role in providing service-to-service communication in Kubernetes. These two layers
    are what make up the Service mesh as a whole and a basic understanding of each
    is key to understanding Istio.'
  prefs: []
  type: TYPE_NORMAL
- en: The Control Plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the Istio control plane.
  prefs: []
  type: TYPE_NORMAL
- en: The control plane in Istio is the central authority that controls and directs
    how services in the mesh communicate with each other. A common analogy is to think
    of a city’s traffic control, managing roads and traffic signals to ensure safe
    and efficient traffic flow and order. It plays an important role in the orchestration
    of service-to-service communication, security, and observability across the entire
    mesh. We will discuss the different features that are controlled by the control
    plane when we discuss the main control plane daemon, `istiod`, in the *Understanding
    the Istio components* section.
  prefs: []
  type: TYPE_NORMAL
- en: The Data Plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second component is the data plane, which is the worker layer that contains
    a set of proxies, known as Envoy proxies, deployed alongside your services. These
    proxies intercept and manage the network traffic between microservices without
    the need for you or your developers to do any additional work or recoding.
  prefs: []
  type: TYPE_NORMAL
- en: To build on the previous analogy we used for the control plane, think of the
    data plane as the roads in a city. Each service in the mesh receives a dedicated
    road where traffic is directed to the service by a traffic controller – in our
    case, the Istio control plane (istiod).
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, you may have been using Kubernetes without a Service mesh. So,
    you may be wondering why you should care about the features that Istio brings
    to your cluster. In the next section, we will go over Istio’s features so you
    will be able to explain to your developers and businesses why a Service mesh is
    an important add-on to clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Why should you care about a Service mesh?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service meshes, like Istio, provide several features that developers would typically
    need to develop on their own, necessitating changes to their existing code. Without
    Istio, if developers require specific capabilities, such as secure communication
    between services coded in various programming languages like Java, Python, or
    Node.js, they would need to implement the necessary code, or libraries, for each
    language individually. This adds complexity to the code and can often lead to
    inefficient coding, causing performance issues with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding security, like encryption, is just one example of what a developer may
    require to create an application. What about other features, like controlling
    data flow, testing how the application will react to failures, or how network
    delays may cause the application to behave in an unexpected way? These, and many
    other features, are all included with Istio – allowing developers to focus on
    their own business code, rather than writing additional code to control traffic
    or to simulate errors or delays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at some of the advantages that Istio offers.
  prefs: []
  type: TYPE_NORMAL
- en: Workload observability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Downtime or slowdowns in an application may impact your organization’s reputation
    and potentially cause lost revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever found it challenging to pinpoint the underlying issue in an application
    with many active services? Imagine the ability to quickly identify and resolve
    problems by monitoring the interactions and status of services in real time, or
    by replaying events from the past to discover where things went wrong hours or
    days before.
  prefs: []
  type: TYPE_NORMAL
- en: Managing complex applications and multiple services can feel overwhelming. The
    features offered by Istio make this task far less intimidating. If only there
    was a way to make this easier for developers! Thanks to Istio and its ecosystem,
    this isn’t just wishful thinking. With powerful features like Prometheus for storing
    metrics, Kiali for deep insights, and Jaeger for detailed tracing, you’re equipped
    with a powerful toolkit for troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to set up all three add-ons, with a focus on using
    Kiali, which lets you observe communications between your services like never
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Istio provides you with powerful traffic management capabilities for your workloads,
    offering the flexibility to adopt any deployment model you need, without the hassle
    of altering your network infrastructure. This control is entirely in your and
    your developers’ hands. Istio also includes tools that enable you to simulate
    various unpredictable scenarios that your application might encounter, such as
    HTTP errors, delays, timeouts, and retries.
  prefs: []
  type: TYPE_NORMAL
- en: We recognize that some of our readers might be new to the concept of deployment
    models. Grasping the different types available is crucial for understanding, and
    appreciating, the benefits that Istio brings to the table. With Istio, developers
    can effectively utilize deployment strategies like blue/green and canary deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Blue/green deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this model, you deploy two versions to production, directing a certain percentage
    of traffic to each version of the application, usually sending a low amount of
    traffic to the “new” (green) release. As you verify that the new deployment is
    working as expected, you can cut over all of the traffic to the green deployment,
    or you use blue/green combined with a canary deployment to the new version until
    you are eventually sending 100% of the traffic to the new deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This term comes from the mining days when miners would put a canary in the mining
    shaft to verify it was safe to work in the environment. In the case of a deployment,
    it allows you to deploy an early test version of the application before graduating
    the release to a new version. Essentially, this is similar to the blue/green deployment,
    but in a canary deployment, you would direct a very small percentage of traffic
    to the canary version of the application. Using a small percentage of traffic
    will minimize any impact that the canary deployment may introduce. As you become
    more confident that the “canary” version of the application is stable, you will
    move over additional traffic until you are 100% on the new version.
  prefs: []
  type: TYPE_NORMAL
- en: Finding issues before they happen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can go a step further from deployment models; Istio also provides tools for
    you to develop resilience and testing for your workloads before you deploy them
    and learn about issues from customers or end-users.
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever worried about how an application will react to certain unseen
    events?
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers need to worry about events that they have little control over, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Application timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delays in communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP error codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Istio provides objects to assist in dealing with these by allowing you to create
    an issue with the workload before you move to production. This allows developers
    to capture and resolve issues in their applications before releasing them to production,
    creating a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In today’s world, security is an issue we should all be concerned about. Many
    of the methods to secure a workload are complex and may require a skillset that
    many developers do not have. This is truly where Istio shines, providing the tools
    to easily deploy security and minimize its impact on development.
  prefs: []
  type: TYPE_NORMAL
- en: The first, and most popular, security feature in Istio is the ability to provide
    **mutual Transport Layer Security** (**mTLS**) between workloads. Using mTLS,
    Istio provides not only encryption for communication but workload identity too.
    When you visit a website that has an expired certificate or a self-signed certificate,
    your browser will warn you that the site can’t be trusted. That’s because your
    browser performs server authentication when establishing a TLS connection by verifying
    that the certificate presented by the server is trusted by the browser. mTLS verifies
    trust from the client to the server, but also from the server to the client. That’s
    the mutual part. The server validates that the certificate presented by the client
    is trusted as well as the client validating the server. When you first start a
    cluster and use the initial certificate created for you, you’re using mTLS. Istio
    makes this much easier because it will create all of the certificates and identities
    for you using its built-in sidecar.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure mTLS as a requirement (STRICT), or as an option (PERMISSIVE),
    for the entire mesh or individual namespaces. If you set either option to STRICT,
    any communication to the service will require mTLS and if a request fails to provide
    an identity, the connection will be denied. However, if you set the PERMISSIVE
    option, traffic that has an identity and requests mTLS will be encrypted, while
    any request that does not provide an identity or encryption request will still
    be allowed to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature provided will give you the ability to secure what communication
    is allowed to a workload, similar to a firewall, but in a much simpler implementation.
    Using Istio, you can decide to only allow HTTP GET requests, or only HTTP POST
    requests, or both – from only defined sources.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can use **JSON Web Tokens** (**JWTs**) for initial user authentication
    to limit who is authorized to communicate with a workload. This allows you to
    secure the initial communication attempt by only accepting JWTs that come from
    an approved token provider.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed some of the reasons you would want to deploy Istio,
    let’s introduce you to some Istio concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Istio concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The principles of Istio can be divided into four main areas: traffic management,
    security, observability, and extensibility. For each of these areas, we’ll introduce
    the components and custom resources that developers can utilize to tap into the
    benefits of using Istio.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Istio components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a standard Kubernetes cluster, Istio refers to two separate planes,
    the control plane and the data plane. Historically, the data plane included four
    different services, Pilot, Galley, Citadel, and Mixer – all broken out in a true
    microservices design. This design was used for multiple reasons, including the
    flexibility to break out the responsibilities to multiple teams, the ability to
    use different programming languages, and the ability to scale each service independently
    of the others.
  prefs: []
  type: TYPE_NORMAL
- en: Istio has evolved quickly since its initial release. The team made the decision
    that breaking out the core services had little benefit and, in the end, made Istio
    more complex. This led the team to redesign Istio and starting with Istio 1.5,
    Istio includes the components that we will discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Control Plane simple with istiod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as Kubernetes bundles multiple controllers into a single executable, kube-controller-manager,
    the Istio team decided to bundle the control plane components into a single daemon
    called istiod. This single daemon grouped all of the control plane components
    into a single pod that can be easily scaled as performance is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantages to the single daemon are listed in an Istio blog at [https://istio.io/latest/blog/2020/istiod/](https://istio.io/latest/blog/2020/istiod/).
    To summarize the team’s reasoning, the single process provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier and quicker control plane installations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of virtual machines into the Service mesh more easily, requiring
    a single agent and Istio’s certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced control plan startup time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reduced amount of overall required resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control plane is responsible for controlling your Service mesh. It has a
    number of important features that are required to create and manage the components
    of Istio, and in the next section, we will explain the features that istiod provides.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the istiod pod
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Moving to a single binary didn’t reduce Istio’s functionality or features;
    it still provides all of the features that the separate components provided, they
    are all just in a single binary now. Each piece provides a key feature to the
    Service mesh, and in this section, we will explain these features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service Discovery**: Ensures that Envoy proxies, deployed alongside a Service
    in the same pod, have up-to-date information about the network locations, including
    the IP address and ports of services in the mesh. Service Discovery provides efficient
    service-to-service communication across the mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services can frequently scale up or down, and pods may be terminated or launched
    as part of rolling updates or auto-scaling activities. Each change can potentially
    alter the endpoints. Service discovery automates the process of tracking these
    changes by watching for updates to services and their associated pods. When a
    change has occurred, the Service discovery component updates the internal registry
    of Service endpoints and pushes these updates to the Envoy sidecars.
  prefs: []
  type: TYPE_NORMAL
- en: Service Discovery is essential for maintaining the responsiveness and efficiency
    of the Service mesh, dynamically adapting to the ever-changing landscape of containerized
    application environments in real time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration Distribution**: Handles the configuration of traffic routing,
    security protocols, and policy enforcement across the data plane’s sidecars. Configuration
    distribution centralizes functions that used to be performed by a component called
    Galley, including the authorization of configuration changes in the Service mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate Lifecycle Management**: Manages the issuing, renewal, and revocation
    of digital certificates, which are used for secure service-to-service communication
    using mutual Transport Layer Security (mTLS) guaranteeing that was previously
    handled by a component called Citadel, which provided identity verification and
    management of certificates, guaranteeing that all services within the mesh can
    trust connections, without requiring any additional components or configuration.
    mTLS reduces security threats by encrypting the transferring of data between services,
    providing the confidentiality and integrity of communication within the Service
    mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated Envoy Proxy Deployment**: Streamlines the deployment process by
    automatically deploying Envoy sidecar proxies within Kubernetes pods. This seamless
    integration optimizes the management of both `Egress` and `Ingress` traffic through
    the pods, serving as an invisible mediator that oversees network traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This automated process ensures that each pod in the Service mesh receives its
    own Envoy proxy, providing advanced traffic capabilities including routing, load
    distribution, and security measures. The automation of Envoy proxy deployment
    removes the complexities involved in establishing and upkeeping the Service mesh,
    allowing developers and operators to spend time on their primary responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic Routing and Control**: Responsible for creating and sharing the rules
    for managing traffic to Envoy proxies, providing a pivotal role in executing advanced
    network operations, and providing a way for precise control over often complex
    network traffic flows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functionalities provided by traffic routing and control, include:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the path(s) for directing traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategic retry mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failover schemes to ensure continuity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The introduction of faults for the purpose of creating realistic testing environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic routing and controls provide a number of advantages, including streamlining
    the management of network traffic, testing the network’s stability and response
    under certain conditions, and increasing workload resilience by simulating disruptions
    and how the application reacts before they occur in production.
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Policy Enforcement**: Uses security rules to make sure only authorized
    users or services have access and can interact within the network securely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observability Data Collection**: In a Service mesh, it’s essential to keep
    an eye on how things are running and to quickly identify and solve any problems.
    This is where observability data collection comes into play, gathering and analyzing
    telemetry information, including metrics, logs, and traces from the data plane,
    enhancing the mesh’s monitoring and operational insight capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have discussed what istiod provides, we will move on to how incoming
    traffic is managed in the Service mesh using the `istio-ingressgateway` component.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding istio-ingressgateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving on from the base istiod pod, we come to one of the most important components
    of Istio, `istio-ingressgateway`. This gateway facilitates external clients’ and
    services’ access to the Service mesh, acting as the entry point into the Kubernetes
    cluster. It’s standard for every Istio-enabled cluster to be equipped with at
    least one instance of `istio-ingressgateway`. However, Istio’s design does not
    confine you to just one; depending on your specific needs, it’s possible to deploy
    multiple ingress gateways to serve various purposes or handle different traffic
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `istio-ingressgateway` provides access to applications using two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard Kubernetes Ingress object support
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Istio Gateway and VirtualService objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we have already discussed and deployed NGINX as an Ingress controller,
    we will not cover using Envoy as a standard Ingress controller; instead, we will
    focus on the second method of using Gateways and Virtual Services for incoming
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using Gateways to expose our services provides more flexibility, customization,
    and security over a standard Ingress object.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding istio-egressgateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `istio-egressgateway` is designed to direct traffic from sidecars to either
    a single pod or a collection of pods, thereby centralizing the exiting (egress)
    traffic from the Service mesh. Normally, Istio sidecars manage both incoming and
    outgoing traffic for services within the mesh. While `istio-ingressgateway` is
    utilized for managing incoming traffic to the mesh, implementing `istio-egressgateway`
    allows for the regulation of outgoing traffic as well. The functionalities and
    details of both `ingressgateway` and `egressgateway` will be explored thoroughly
    in the *Introducing Istio resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s jump into how you install Istio in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Istio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple methods to deploy Istio. The most common methods today are
    to use either `istioctl` or Helm, but there are additional options depending on
    your organization. You may elect to use one of the alternative installation methods
    of creating manifests via `istoctl` or Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief list of advantages and disadvantages for each method is detailed in
    *Table 16.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Deployment method** | **Advantages** | **Disadvantages** |'
  prefs: []
  type: TYPE_TB
- en: '| `istioctl` | Configuration validation and health checksDoes not require any
    privileged pods, increasing cluster securityMultiple configuration options | Each
    Istio version requires a new binary |'
  prefs: []
  type: TYPE_TB
- en: '| Istio operator | Configuration validation and healthDoes not require multiple
    binaries for each Istio versionMultiple configuration options | Requires a privileged
    pod running in the cluster |'
  prefs: []
  type: TYPE_TB
- en: '| Manifests (via `istioctl`) | Generates manifests that can be customized before
    deploying using `kubectl`Multiple configuration options | Not all checks are performed,
    which could lead to deployment errorsError checks and reporting are limited when
    compared to using `istioctl` or the Istio operator |'
  prefs: []
  type: TYPE_TB
- en: '| Helm | Helm and charts are well known to most Kubernetes usersLeverages Helm
    standards, which allow for easy management of deployments | Offers the least validation
    checks of all deployment optionsMost tasks will require additional work and complexity
    versus the other deployment models |'
  prefs: []
  type: TYPE_TB
- en: 'Table 16.1: Istio deployment methods'
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will focus on using the `istioctl` binary for installation,
    and in the next section, we will deploy Istio using `istioctl`.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Istio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have included a script that will deploy Istio, output the verification of
    the installation, remove NGINX Ingress, and expose `istio-ingressgateway` as the
    Ingress to our KinD cluster. The manual process is provided below if you prefer
    to install it manually using `istioctl`. The script, `install-istio.sh`, is provided
    for readers who may use it in automation for their own testing and is located
    in the `chapter16` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need is to define the version of Istio we want to deploy.
    We can do this by setting an environment variable, and in our example, we want
    to deploy Istio 1.20.3\. First, make sure you are in the `chapter16` directory
    where you cloned the repo and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will download the installation script and execute it using the `ISTIO_VERSION`
    that we defined before executing the `curl` command. After executing, you will
    have an `istio-1.20.3` directory in your current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since we will be using executables from the `istio-1.12.3` directory,
    you should add it to your `path` statement. To make this easier, you should be
    in the `chapter16` directory from the book repository before setting the `path`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing Istio using a profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make deploying Istio easier, the team has included a number of pre-defined
    profiles. Each profile defines which components are deployed and the default configuration.
    There are seven profiles included, but only five profiles are used for most deployments.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Profile** | **Installed Components** |'
  prefs: []
  type: TYPE_TB
- en: '| Default | `istio-ingressgateway` and `istiod` |'
  prefs: []
  type: TYPE_TB
- en: '| Demo | `istio-egressgateway`, `istio-ingressgateway`, and `istiod` |'
  prefs: []
  type: TYPE_TB
- en: '| Minimal | `istiod` |'
  prefs: []
  type: TYPE_TB
- en: '| Preview | `istio-ingressgateway` and `istiod` |'
  prefs: []
  type: TYPE_TB
- en: '| Ambient | `istiod`, CNI, and ZtunnelNote: In the 1.20.3 Istio release, ambient
    mesh is an alpha feature |'
  prefs: []
  type: TYPE_TB
- en: 'Table 16.2: Istio profiles'
  prefs: []
  type: TYPE_NORMAL
- en: 'If none of the included profiles fit your deployment requirements, you can
    create a customized deployment. This is beyond the scope of this chapter since
    we will be using the included demo profile – however, you can read more about
    customizing the configuration on Istio’s site: [https://istio.io/latest/docs/setup/additional-setup/customize-installation/](https://istio.io/latest/docs/setup/additional-setup/customize-installation/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy Istio using the demo profile using `istioctl`, we simply need to
    execute a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The installer will ask you to verify that you want to deploy Istio using the
    default profile, which will deploy all of the Istio components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Press the *y* key to say yes to proceed with the deployment. If you want to
    bypass the confirmation, you can add an option to the `istioctl` command line,
    `--skip-confirmation`, which tells `istioctl` to bypass the confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: If everything went well, you should see a confirmation that each component was
    installed, and a completion message that thanks you for installing Istio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `istioctl` executable can be used to verify the installation. To verify
    the installation, you require a manifest. Since we used `istioctl` to deploy Istio
    directly, we do not have a manifest, so we need to create one to check our installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then run the `istioctl verify-install` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will verify each component, and once verified, it will provide a summary
    similar to the output below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have verified the installation, let’s look at what `istioctl` created:'
  prefs: []
  type: TYPE_NORMAL
- en: A new namespace called `istio-system`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three deployments were created, and a corresponding service for each:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`istio-ingressgateway`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`istio-egressgateway`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`istiod`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '15 **CustomResourceDefinitions** (**CRDs**) to provide the Istio resources,
    including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destinationrules.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`envoyfilters.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateways.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`istiooperators.install.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peerauthentications.security.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxyconfigs.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestauthentications.security.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serviceentries.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sidecars.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`telemetries.telemetry.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtualservices.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wasmplugins.extensions.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workloadentries.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workloadgroups.networking.istio.io`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At this stage, there’s no need to be concerned with the details of the Custom
    Resources (CRs). As we progress through this chapter, we’ll delve into the specifics
    of the most commonly used resources. Following that, in the next chapter, we’ll
    cover how to deploy an application into the mesh, which will make use of several
    of the CRs that have been deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any CRs that are not covered in this chapter or the next chapter, you can
    reference the documentation on the istio.io site, located here: [istio.io/latest/docs](http://istio.io/latest/docs)'
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Istio in a KinD cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Istio deployed, our next step is to expose it to our network so we can
    access the applications we’ll build. Since we’re running on KinD, this can be
    tricky. Docker is forwarding all traffic from port `80` (HTTP) and `443` (HTTPS)
    on our KinD server to the worker node. The worker node is in turn running the
    NGINX Ingress controller on ports `443` and `80` to receive that traffic. In a
    real-world scenario, we’d use an external load balancer, like MetalLB, to expose
    the individual services via a LoadBalancer. For our labs though, we’re going to
    instead focus on simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: When you executed the previous script to install Istio, the last step ran a
    separate script called `expose_istio.sh` that does two things. First, it will
    delete the `ingress-nginx` namespace, removing NGINX and freeing up ports `80`
    and `443` on the Docker host. Second, it will patch the `istio-ingressgateway`
    Deployment in the `istio-system` namespace so that it runs on ports `80` and `443`
    on the worker node.
  prefs: []
  type: TYPE_NORMAL
- en: Since the script was executed as part of the installation, you do not need to
    execute it again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Istio fully deployed in our cluster and we know the custom
    resources that Istio includes, let’s move on to the next section, which will explain
    each resource and its use-cases.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Istio resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Istio’s custom resources provide powerful features to your cluster and each
    one could take up a chapter by itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we want to provide enough details so you will have a strong
    understanding of each object. After the object overview, we will deploy a basic
    application that will demonstrate many of the objects in a real-world application
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authorization policies are optional; however, if you do not create any, all
    requests to resources will be allowed access to your cluster workloads. This may
    be the desired default action for some organizations, but most enterprises should
    deploy workloads based on the least required privileges. This means that you should
    only allow what access is required for accessing the application – nothing more
    and nothing less. Least privilege access is often overlooked by organizations
    since it adds some complexity to access and if not configured correctly, it may
    deny access to valid requests. While this is true, it is not a valid argument
    to leave your systems wide open to all access requests.
  prefs: []
  type: TYPE_NORMAL
- en: Istio’s authorization policies offer detailed access management for services
    within your mesh, allowing you to define access rights based on the identities
    of the callers and their permissions. They provide developers with the ability
    to control access to workloads based on actions including deny, allow, and custom.
  prefs: []
  type: TYPE_NORMAL
- en: Before explaining policies in more depth, we need to start with a concept called
    **implicit enablement**. This means that when **any** authorization policy matches
    a request, Istio will change the default allow all to a deny for any request that
    doesn’t have a match in the policy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use an example to explain this in more detail. We have an NGINX server
    running in a namespace where Istio has been enabled and we have a standard that
    access to port `80` must be denied.
  prefs: []
  type: TYPE_NORMAL
- en: At a quick glance, this looks like it should be an easy policy, we would simply
    create a deny policy that contains port `80`. So, we create the policy and deploy
    it to our cluster – and to verify the policy, we try to access the website on
    port `80`. We open a browser and, as expected, we cannot access the site. Great!
    Now let’s verify that we can access the site on port `443`. We change the URL
    to access the site using port `443`, and to our surprise, it is also *denied*.
  prefs: []
  type: TYPE_NORMAL
- en: Wait, what!?!? The deny policy only denies port `80` – why is port `443` also
    being denied?
  prefs: []
  type: TYPE_NORMAL
- en: This is **implicit enablement** in action and it can be confusing at first for
    anyone who is new to Istio. As discussed at the beginning of this section, when
    a policy is created and a request matches that policy, Istio will change from
    an *allow all* security posture, to a *deny all* security posture. Even though
    we intended to deny access to only port `80`, without an allow policy for port
    `443`, access will also be denied.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the requirement, and allow access to our NGINX site on port `443`,
    we would need to create an allow policy that allows all incoming traffic to port
    `443`. We will explain this in more depth in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how a policy’s actions are evaluated is very important, since
    a misconfigured policy may not provide the expected results. The high-level flow
    for policy evaluation is shown in *Figure 16.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Istio policy evaluation flow'
  prefs: []
  type: TYPE_NORMAL
- en: If the evaluation of a **CUSTOM** action defines a **DENY** to the request,
    the access is denied, and the evaluation process stops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, if a **DENY** policy matches the request, the request is denied access
    to the resource, and the evaluation process stops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no **ALLOW** policies that match the request, access will be denied
    to the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an **ALLOW** policy matches the request, access to the resource is granted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Along with understanding the flow of policies, you need to understand how conflicting
    policies will be implemented. If a policy has any conflicting rules, like denying
    and allowing the same request, the deny policy will be evaluated first and the
    request will be denied since the deny policy is evaluated before the allow policy.
    It’s also very important to note that if you allow a certain action, like an HTTP
    GET, the GET request would be allowed, but any other operation would be denied
    since it has not been allowed by the policy.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization policies can get very complex. The Istio team has created a page
    with multiple examples on the Istio site at [https://istio.io/latest/docs/reference/config/security/authorization-policy/](https://istio.io/latest/docs/reference/config/security/authorization-policy/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Policies can be broken down into scope, action, and rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope**: The scope defines what object(s) will be enforced by the policy.
    You can scope a policy to the entire mesh, a namespace, or any Kubernetes object
    label like a pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: There can be one of three actions defined, CUSTOM, ALLOW, or DENIED
    – each either denying or allowing a request based on the defined rules. ALLOW
    and DENY are the most commonly used actions, but CUSTOM actions are beneficial
    when you require complex logic that ALLOW or DENY cannot handle, using an external
    system for additional decision making.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rules**: Define what actions will be allowed or denied by the request. Rules
    can become very complex, allowing you to define actions based on source and destination,
    different operations, keys, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help understand the flow, let’s look at a few example authorization policies
    and what access will be applied when the policy is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: We will deploy a larger application later in the chapter. If you want to see
    how the example policies work in this section, you can deploy an NGINX web server
    using the script in the `chapter16/testapp` directory called `deploy-testapp.sh`.
    This will create all of the required Kubernetes and Istio objects to test the
    policies in a real cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have executed the script and the objects have been created, test that
    NGINX is working by curling to the `nip.io` VirtualService that was created. On
    our server, it created `testapp.10.3.1.248.nip.io`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This should display the NGINX welcome page. Now, we can create some example
    policies to show how authorization policies work. Each of the three examples is
    in the `chapter16/testapp` directory named `exampleX-policy.yaml`, where `X` is
    equal to `1`, `2`, or `3` – each can be deployed using the `kubectl apply <policyname>
    -n testapp` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Denying and allowing all access'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our first example, we will create a policy that will deny all requests
    to the resources in the namespace `testapp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After deploying the policy, attempt to `curl` to the `nip.io` address again.
    You will notice that this time, you will be denied access and Istio will return
    an RBAC error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It can take a few seconds for Istio to enable new policies. If you did not
    receive the `RBAC: access denied` error, wait a few seconds and try again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simple policy that does not include a `selector` and defines
    nothing in the `spec` section. By omitting the `selector` section, Istio will
    apply the policy to all workloads in the namespace, and by not including anything
    in the `spec` section, Istio will deny all traffic. If we refer back to the policy
    flow diagram in *Figure 16.1*, this would flow down the bottom and evaluate as
    circle #3 – there is a `selector` match, which is *all* workloads in the namespace,
    and there hasn’t been an ALLOW policy defined. This will lead to the request being
    denied.'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t deploy the next example; we are showing it to reinforce the example
    provided above. By adding a single entry to the policy, we can change it from
    denying all requests to allowing all requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we add the `rules` section to the policy definition, with a {}, we are
    creating a rule that means all traffic. Similar to the previous example, we have
    not added a `selector`, which means the policy will apply to all deployments in
    the namespace. Since this rule is for all workloads and the rule includes all
    traffic, access would be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: You might be starting to see why we mentioned how not understanding how policies
    are evaluated in the flow may lead to unexpected access results. This is a prime
    example of how a single entry, `rules`, changes the policy from denying all requests
    to allowing all requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, delete the policy by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 2: Allowing only GET methods to a workload'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Policies can get very granular, allowing only certain operations like GET from
    an HTTP request. This example will allow GET requests while denying all other
    request types for pods that are labeled with `app=nginx-web` in the `marketing`
    namespace. For this example, we will use the same NGINX deployment from the first
    example. Create the policy using the manifest in the `chapter16/testapp` directory
    called `exampe2-policy.yaml` using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to `curl` to the same `nip.io` address as we used in example
    1, you will see the NGINX welcome page. This is using an HTTP GET command. To
    prove that HTTP PUT commands will be blocked, we can use a `curl` command to send
    a request to NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause Istio to deny the request with an RBAC error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the policy accepts the GET request from any source, since we
    have only defined an action without a specific `from` object. Since we have not
    added the PUT action in our policy, any attempt to send an HTTP PUT request will
    be denied by the policy.
  prefs: []
  type: TYPE_NORMAL
- en: Policies can get even more granular, accepting (or denying) a request based
    on the source of the request. In the next example, we will show another example
    of a policy but we will limit the source to a single IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, delete the example policy using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 3: Allowing requests from a specific source'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our last policy example, we will limit what source will be allowed access
    to a workload using a GET or POST method.
  prefs: []
  type: TYPE_NORMAL
- en: This will increase security by denying any request from a source that is not
    in the policy source list. We will not create this policy since many readers may
    be limited in the number of machines they have to use for testing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous examples, this policy has a `source:` section, which allows
    you to limit access based on different sources, like an IP address. This policy
    will allow the source IP `192.168.10.100` access to all operations on the NGINX
    server, and all other sources will be denied access.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on from authorization policies, we will introduce our next custom resource,
    destination gateways.
  prefs: []
  type: TYPE_NORMAL
- en: Gateways
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, we mentioned that traffic will come into a central point, `istio-ingressgateway`.
    We didn’t explain how the traffic flows from the `ingressgateway` to a namespace
    and workloads – this is where gateways come in.
  prefs: []
  type: TYPE_NORMAL
- en: A gateway can be configured at the namespace, so you can delegate the creation
    and configuration to a team. It is a load balancer that receives incoming and
    outgoing traffic that can be customized with options like accepted ciphers, TLS
    versions, certificate handling, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Gateways work along with Virtual Services, which we will discuss in the next
    section, but until then, the following figure shows the interaction between the
    `Gateway` and `VirtualService` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Gateway to Virtual Service communication flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'The list below explains the communication shown in *Figure 16.2* in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: An incoming request is sent to the Istio `ingress-gateway` controller, located
    in the `istio-system` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sales` namespace has a gateway configured that is set to use the `ingressgateway`
    with a host of `entry.foowidgets.com`. This tells the `ingressgateway` to send
    the request to the gateway object in the `sales` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the traffic is routed to the service using a Virtual Service object
    that has been created using the gateway in the `sales` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To show an example `Gateway` configuration, we have a namespace called `sales`
    that has Istio enabled, running an application that can be accessed using the
    URL `entry.foowidgets.com`, and we need to expose it for external access. To accomplish
    this, we would create a gateway using the example manifest below. (The example
    below is just for discussion; you do not need to deploy it on your KinD cluster.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This gateway configuration will tell the ingress gateway to listen on port `443`
    for requests that are incoming for `sales.foowidgets.com`. It also defines the
    certificates that will be used to secure the communication for incoming web requests.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, “How does it know to use the ingress gateway that we have
    running in our cluster?” If you look at the `spec` section, and then the selector,
    we have configured the `selector` to use an ingress gateway that has the label
    `istio=ingressgateway`. This `selector` and label tell the gateway object which
    ingress gateway will create our new gateway for incoming connections. When we
    deployed Istio earlier, the ingress gateways were labeled with the default label
    `istio=ingressgateway`, as shown highlighted below, from a `kubectl get pods --show-labels
    -n istio-system`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering how the gateway will be used to direct traffic to a particular
    workload since there are no configuration options in the gateway telling it where
    to direct traffic. That’s because the gateway just configures the ingress gateways
    to accept traffic for a destination URL and the required ports – it does not control
    how the traffic will flow to a service; that’s the job of the next object, the
    `Virtual Service` object.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gateways and virtual services combine to provide the correct traffic route to
    a service, or services. Once you have a gateway deployed, you need to create a
    virtual service object to tell the gateway how to route traffic to your service(s).
  prefs: []
  type: TYPE_NORMAL
- en: Building on the gateway example, we need to tell the gateway how to route traffic
    to our web server running on port `443`. The server has been deployed using NGINX
    in the `marketing` namespace and it has a label of `app-nginx` and a service named
    `frontend`. To route traffic to the NGINX service, we would deploy the manifest
    below. (The example below is just for discussion; you do not need to deploy it
    on your KinD cluster.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Breaking down the manifest, we specify the host(s) that this `VirtualService`
    object will route; in our example, we only have one host, `entry.foowidgets.com`.
    The next field defines which gateway will be used for the traffic; in the previous
    section, we defined a gateway called `marketing-gateway`, which was configured
    to listen on port `443`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last section defines which service the traffic will be routed
    to. The route, destination, and port are all fairly straightforward to understand,
    but the `host` section can be misleading. This field actually defines the service
    that you will route the traffic to. In the example, we are going to route the
    traffic to a service called `entry`, so our field is defined with `host: entry`.'
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge of using gateways and virtual services to route traffic
    in the Service mesh, we can move on to the next topic, destination rules.
  prefs: []
  type: TYPE_NORMAL
- en: Destination rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtual services provide a basic method to direct traffic to a service, but
    Istio offers an additional object to create complex traffic direction by using
    `Destination` rules. `Destination` rules are applied after Virtual Services. Traffic
    is initially routed using a Virtual Service and, if defined, a `Destination` rule
    can be used to route the request to its final destination.
  prefs: []
  type: TYPE_NORMAL
- en: This may be confusing at first, but it becomes easier when you see an example,
    so let’s dive into an example that can route traffic to different versions of
    a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned, incoming requests will use the Virtual Service initially, and
    then a destination rule, if defined, will route the request to the destination.
    In this example, we have already created a Virtual Service but we actually have
    two versions of the application labeled `v1` and `v2` and we want to direct traffic
    between both versions of the application using round-robin. To accomplish this,
    we would create a `DestinationRule` using the manifest below. (The example below
    is just for discussion; you do not need to deploy it on your KinD cluster.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using this example, incoming requests to the NGINX server will be split between
    the two versions of the application equally since we defined the `loadBalancer`
    policy as `ROUND_ROBIN`. But what if we wanted to route traffic to the version
    that had the least number of connections? Destination rules have other options
    for `loadBalancer`, and to route connections to the version with the least connections,
    we would set the `LEAST_CONN` `loadBalancer` policy.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss some of the security features Istio provides, starting
    with an object called Peer Authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Peer authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Istio’s peer authentication object controls how the Service mesh controls the
    mutual TLS settings for workloads, either for the entire Service mesh or just
    a namespace. Each policy can be configured with a value that will either allow
    both encrypted communication and non-encrypted communication between pods or require
    encryption between pods.
  prefs: []
  type: TYPE_NORMAL
- en: '| **mTLS mode** | **Pod communication** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `STRICT` | mTLS required | Any non-encrypted traffic sent to a pod will be
    denied |'
  prefs: []
  type: TYPE_TB
- en: '| `PERMISSIVE` | mTLS optional | Both encrypted and non-encrypted traffic will
    be accepted by the pod |'
  prefs: []
  type: TYPE_TB
- en: 'Table 16.3: PeerAuthentication options'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to set `PeerAuthentication` for the entire mesh, you would create
    a `PeerAuthentication` in the `istio-system` namespace. For example, to require
    mTLS between all pods, you would create the policy shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow both encrypted and non-encrypted traffic, the policy mode just needs
    to be set to `PERMISSIVE`, by changing the mode to `mode: PERMISSIVE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than setting the mode for the entire mesh, many enterprises only set
    the mode to `STRICT` for namespaces that require additional security. In the example
    below, we set the mode to `STRICT` for the `sales` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since this policy is configured for the `sales` namespace, rather than the `istio-system`
    namespace, Istio will only enforce a strict mTLS policy for the namespace rather
    than the entire Service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great security feature provided by the mesh, but encryption won’t
    stop a request from hitting our workload; it simply encrypts it. The next object
    we will discuss will add a level of security to a workload by requiring authentication
    before being allowed access.
  prefs: []
  type: TYPE_NORMAL
- en: Request authentication and authorization policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security requires two pieces. First, the authentication piece, which is “who
    you are.” The second piece is authorization, which is the actions that are allowed
    once authentication has been provided, or “what you can do.”
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestAuthentication` objects are only one part required to secure a workload.
    To fully secure the workload, you need to create the `RequestAuthentication` object
    and an `AuthorizationPolicy`. The `RequestAuthentication` policy will determine
    what identities are allowed access to the workload, and the `AuthorizationPolicy`
    will determine what permissions are allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: A `RequestAuthorization` policy without an `AuthorizationPolicy` can lead to
    unintentionally allowing access to the resource. If you only create a `RequestAuthorization`
    policy, the access in *Table 16.4* shows who would be allowed access.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Token action** | **Access provided** |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid token provided | Access will be denied |'
  prefs: []
  type: TYPE_TB
- en: '| No token provided | Access will be granted |'
  prefs: []
  type: TYPE_TB
- en: '| Valid token provided | Access will be granted |'
  prefs: []
  type: TYPE_TB
- en: 'Table 16.4: RequestAuthentication access'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, once we create a policy, any invalid JWT will be denied access
    to the workload, and any valid token will be allowed access to the workload. However,
    when no token is provided, many people think that access would be denied, but
    in reality, access would be allowed. A `RequestAuthentication` policy only verifies
    the tokens, and if no token is present, the `RequestAuthentication` rule will
    not deny the request.
  prefs: []
  type: TYPE_NORMAL
- en: An example manifest is shown below. We will use this manifest in the examples
    section of the chapter, but we wanted to show it in this section to explain the
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This manifest will create a policy that configures a workload with the label
    `matching app=frontend` in the `demo` namespace to accept JWTs from the issuer
    `testing@secure.istio.io` with a URL to confirm the tokens at [https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json](https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json).
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL contains the key used to validate the tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When a token is presented, it will be verified that it came from the issuer
    defined in the `jwtRules` section of the `RequestAuthenctication` object.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through an example of how token authentication works in depth in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Service entries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a workload is part of a Service mesh, its sidecar proxy will handle all
    outbound communication to services within the mesh. If the workload attempts to
    communicate with an external service that is not part of the mesh, this communication
    may fail if not properly configured. Fortunately, Istio provides mechanisms to
    define and manage external services, allowing workloads to communicate with services
    outside the mesh. One such mechanism is the `ServiceEntry` object, which allows
    you to define services that are external to the mesh and configure how these services
    should be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a requirement for a workload in your Service mesh to communicate
    with a service outside of the Service mesh, you need to create an entry in the
    mesh for the external resource. This can be done in two ways, and the first method
    leads us to our next custom resource, the `ServiceEntry` object, which allows
    you to add external entries to the Service mesh. When you create a `ServiceEntry`
    for an external service, it will appear as if it was part of the actual Service
    mesh. This allows traffic to be routed to manually specified services from inside
    the Service mesh. Without a `ServiceEntry`, any attempt to communicate with the
    external resource would fail since Istio would attempt to look up the service
    in the Service mesh entries and it would fail to find the resource (since it is
    not part of the mesh).
  prefs: []
  type: TYPE_NORMAL
- en: To create a `ServiceEntry`, you need to create a new object that contains the
    hosts and ports for the external service. The example below will create a new
    entry that adds the host `api.foowidgets.com` on port `80`, using HTTP, to the
    Service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ServiceEntries are a great resource to explicitly add external resources to
    a Service mesh. We mentioned that there are two ways to add external resources
    to the Service mesh, Service entries being one – and the other being the `Sidecars`
    object. The choice of which object to use is very specific to your own use-cases
    and organizational standards. Service entries are very specific and you must create
    an entry for each external resource you need to communicate with. Sidecars are
    different, and instead of defining what is external to the Service mesh, you define
    what is in the Service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Sidecars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we know this can be confusing – this object is not the sidecar itself;
    it is an object that allows you to define what items your sidecar considers to
    be “in the mesh.” Depending on the size of your cluster, you may have thousands
    of services in the mesh and if you do not create a sidecar object, your Envoy
    sidecar will assume that your service needs to communicate with every other service.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you may only need your namespace to communicate with services in
    the same namespace or a small number of other namespaces. Since tracking every
    service in the mesh requires resources, it’s considered good practice to create
    a sidecar object to reduce the required memory in each Envoy sidecar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a sidecar object that limits the services in your Envoy proxy, you
    would deploy the manifest shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `spec` in this manifest contains a list of hosts for the mesh, the `./*`
    references the namespace where the object was created, and all sidecars should
    contain the namespace where Istio was deployed, which would be `istio-system`,
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had three namespaces that needed to communicate across the mesh, we would
    simply need to add the additional namespaces to the hosts’ entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Failing to limit the mesh objects may result in your Envoy sidecar crashloops
    due to resources. You may experience an **out of memory** (**OOM**) event, or
    simply crashloops that do not show any details of the root cause. If you experience
    these scenarios, deploying a sidecar object may resolve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Envoy filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Envoy filters provide you with the ability to create custom configurations that
    are generated by Istio. Remember that Pilot (part of istiod) is responsible for
    sidecar management. When any configuration is sent to Istio, Pilot will convert
    the configuration for Envoy to utilize. Since you are “limited” by the options
    in the Istio custom resource, you may not have all of the potential configuration
    options that are required for a workload, and that’s where Envoy filters come
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Filters are very powerful, and potentially dangerous, configuration objects.
    They allow you to customize values that you cannot customize from a standard Istio
    object, allowing you to add filters, listeners, fields, and more. This brings
    a quote used in Spider-Man from the late Stan Lee to mind, “With great power comes
    great responsibility.” Envoy filters provide you with extended configuration options,
    but if a filter is misused, it could bring down the entire Service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Envoy filters are complex and, for the purposes of this book, are not a topic
    that needs deep understanding to understand Istio in general. You can read more
    about Envoy filters on the Istio site at [https://istio.io/latest/docs/reference/config/networking/envoy-filter/](https://istio.io/latest/docs/reference/config/networking/envoy-filter/).
  prefs: []
  type: TYPE_NORMAL
- en: WASM plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to Envoy filters, the `WasmPlugins` object is used to extend the capabilities
    of the Envoy sidecar. While they are similar in what they provide, they each provide
    different degrees of customization.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, `WasmPlugins` are regarded as more straightforward to develop and
    implement, making them less complex and dangerous compared to Envoy filters. This
    simplicity, however, comes at the cost of reduced functionality relative to what
    Envoy filters can offer.
  prefs: []
  type: TYPE_NORMAL
- en: Envoy filters provide detailed, fine-grained control over the proxy settings,
    enabling the creation of more sophisticated operations than is possible with `WasmPlugins`.
    This level of control contributes to their complexity and the potential risk they
    pose if improperly configured or used, which could lead to disruptions within
    your Service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between `EnvoyFilters` and `WasmPlugins` ultimately depends on your
    specific needs and preferences. It’s important to consider various factors when
    deciding which option to adopt, weighing the trade-offs between ease of use, functionality,
    and the potential impact on your Service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying add-on components to provide observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you know how to deploy Istio and understand some of the most used objects,
    but you haven’t seen one of the most useful features yet – observability. At the
    beginning of the chapter, we mentioned that observability is one of our favorite
    features provided by Istio, and in this chapter, we will explain how to deploy
    a popular Istio add-on called Kiali.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Istio add-ons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you deploy Istio, you provide a Service mesh and all of the features to
    your developers. While this is powerful by itself, you need to add a few extra
    components to truly provide a complete solution. There are four add-ons that you
    should add to your Service mesh – while there are alternatives to some of the
    solutions, we are using the most commonly used add-ons, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grafana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jaeger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kiali (which we will cover in the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have discussed Prometheus and Grafana in previous chapters, but Jaeger is
    a new component that we have not mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: Jaeger is an open-source offering that provides tracing between services in
    Istio. Tracing may be a new term to some readers. At a high level, traces are
    a representation of the execution path to a service. These allow us to view the
    actual path of the communication between services, providing an easy-to-understand
    view that provides metrics about performance and latency, allowing you to resolve
    issues quickly.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy all of the add-ons, we have included a script to deploy Prometheus
    in the `chapter16/add-ons` directory, called `deploy-add-ons.sh`. Execute the
    script to deploy the add-ons in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Many add-on example deployments do not maintain state, so for our deployment
    we have added persistency, leveraging the provisioner built into KinD, by adding
    persistent disks to each deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script executes the steps outlined below:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploys each add-on using standard Kubernetes manifests in the `istio-system`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each deployment creates a PVC and mounts it as the data location to maintain
    persistency across reboots.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finds your host’s IP address to create new Gateway and VirtualService entries
    for each add-on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a shared Istio Gateway that will be used by each of the add-ons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creates VirtualServices that contain your `nip.io` URLs. The three URLs that
    will be created are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`prom.<Host IP>.nip.io`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`grafana.<Host IP>.nip.io`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kiali.<Host IP>.nip`.`io`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The final output from the script will contain the URLs that were created for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: With the add-ons deployed, we can move on to the next section, which will cover
    the main tool for observability, Kiali.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kiali
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kiali provides a powerful management console for our Service mesh. It provides
    graphical views of our services, pods, traffic security, and more. Since it’s
    a very useful tool for both developers and operators, the remainder of this chapter
    will focus on deploying and using Kiali.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few options to deploy Kiali, but we will use the most common installation
    method, using a Helm chart. To deploy the chart and create the required objects
    to access the Kiali UI, we have provided a script in the `chapter16/kiali` directory
    called `deploy-kiali.sh`. Execute the script to deploy Kiali.
  prefs: []
  type: TYPE_NORMAL
- en: The script will deploy Kiali into your cluster, in the `istio-system` namespace,
    pre-configured to integrate with the add-ons we deployed in the previous section.
    It will also expose Kiali’s UI using a `nip.io` URL, which will be provided at
    the end of the script execution.
  prefs: []
  type: TYPE_NORMAL
- en: This deploys an anonymous access dashboard; however, Kiali can accept other
    authentication mechanisms to secure the dashboard. In the next chapter, we will
    modify the Kiali deployment to accept JWTs, using OpenUnison as the provider.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application into the Service mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could define the components and objects of Istio all day, but if you are
    like us, you will find examples and use-cases more beneficial to understanding
    advanced concepts like the features provided by Istio. In this section, we will
    explain many of the custom resources in detail, providing examples that you can
    deploy in your KinD cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your first application into the mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally! We have Istio and the add-on components installed and we can move on
    to installing a real application in the Service mesh to verify everything is working.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we will deploy an example application from Google called the
    Boutique app. In the next chapter, we will deploy a different application and
    explain all of the details and communication between the services, but the Boutique
    app is a great application to test out the mesh before we get into that level
    of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chaper16/example-app` directory, there is an installation script called
    `deploy-example.sh` that will deploy the application to the cluster. It will install
    the base application and the required Istio objects to make the application accessible
    to the outside world. The script execution is detailed below:'
  prefs: []
  type: TYPE_NORMAL
- en: A new namespace named `demo` is created with a label containing `istio-injection=enabled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `kubernetes-objects.yaml` manifest, the base application will be deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Istio objects will be created using templates to create the names in the
    `nip.io` domain for easy access to the application. The objects created in Istio
    include the `Gateway` and `VirtualService` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The created `nip.io` domain will be output to the screen. On our server, it
    was `kiali.10.3.1.248.nip.io`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once executed, you will have a working demo application in the `demo` namespace.
    We will use this application to demonstrate the observability features of Istio
    and Kiali.
  prefs: []
  type: TYPE_NORMAL
- en: Quickly verify that the application and Istio objects have been deployed correctly
    by the script by using a browser to open the `nip.io` URL. You should see the
    Kiali home screen, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kiali to observe mesh workloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kiali provides observability in your Service mesh. It provides a number of advantages
    to you and your developers, including a visual map of the traffic flow between
    objects, verifying mTLS between the services, logs, and detailed metrics.
  prefs: []
  type: TYPE_NORMAL
- en: The Kiali overview screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you navigate to the homepage of Kiali, by using the URL provided when you
    executed the `create-ingress` script, this will open the Kiali overview page where
    you will see a list of namespaces in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: The Kiali homepage'
  prefs: []
  type: TYPE_NORMAL
- en: Kiali will show all namespaces in the cluster, even if they do not have Istio
    enabled. In our current deployment, it will show all namespaces, regardless of
    any RBAC that has been implemented since it’s running without any authentication.
    As mentioned in the *Installing Kiali* section, we will secure Kiali with JWTs
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Graph view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first part of the dashboard that we will visit is the **Graph** view, which
    provides a graphical view of our application. Initially, it may look like a simple
    static graphical representation of the objects that make up the workload, but
    this is simply the default view when you open the **Graph** view; it isn’t limited
    to a simple static view, as you will see in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we deployed the example application into the `demo` namespace, scroll
    down a bit and look for the block that contains the `demo` namespace, click the
    three dots on the tile, and then select **Graph**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Using Kiali to show a graph of a namespace'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take you to a new dashboard view that shows the demo application
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Kiali graph example'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of objects on the graph, and if you are new to Kiali, you may
    be wondering what each of the icons represents. Kiali provides a legend to help
    you identify what role each icon plays.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the icon in the lower left-hand section of the **graph** pane,
    you will see the legend icon. Click it to see an explanation of each icon – an
    abbreviated legend list is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Kiali graph legend example'
  prefs: []
  type: TYPE_NORMAL
- en: By default, this view only shows the paths between the application objects in
    a static view. However, you are not limited only to the static view – this is
    where Kiali starts to shine. We can actually enable a live traffic view, enabling
    us to watch the traffic flow for all requests.
  prefs: []
  type: TYPE_NORMAL
- en: To enable this option, click the **Display** option that is just above the Graph
    view, and in the list of options, enable traffic animation by checking the box,
    as shown in *Figure 16.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Enabling traffic animation'
  prefs: []
  type: TYPE_NORMAL
- en: It’s difficult to display in a static image, but once you have enabled the **Traffic
    Animation** option, you will see the flow of all requests in real time.
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited to only traffic flow animations; you can use the **Display**
    option to enable a number of other options in the **Graph** view, including items
    like response time, throughput, traffic rate, and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 16.8*, we have enabled throughput, traffic distribution, traffic
    rate, and security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Kiali graph display options'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the image, the lines between objects now include additional
    information, including:'
  prefs: []
  type: TYPE_NORMAL
- en: A lock, which confirms that the communication is encrypted via the sidecar and
    mTLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RPS, which is the requests per second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the Kiali **Graph** view is a powerful tool for observing the
    end-to-end communication for your workload. This is just one of the additional
    benefits of using a Service mesh. The observability that a mesh provides is an
    incredibly valuable tool for finding issues that would have been very difficult
    to uncover in the past.
  prefs: []
  type: TYPE_NORMAL
- en: We are not limited to only the **Graph** view; we also have three additional
    views that offer additional insight into the application. On the left-hand side
    of the Kiali dashboard, you will see the other three views, **Applications**,
    **Workloads**, and **Services**. You will also notice that there is one other
    option, **Istio Config**, which allows you to view the objects in the namespace
    that control the Istio features for the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Applications view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Applications view shows you the details for the workloads that have the
    same labeling, allowing you to break down the view into smaller sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Boutique Applications view that we have opened in Kiali, click on
    the **Applications** link in the left-hand options. This will take you to the
    overview page for the applications, broken down by labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Kiali Applications view'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the applications can provide additional information by clicking the
    name of the service. If we were to click the **adservice** application, Kiali
    would open a page providing an overview of what the **adservice** application
    interacts with. For each application, you can also look at the overview, traffic,
    inbound and outbound metrics, and traces.
  prefs: []
  type: TYPE_NORMAL
- en: The overview page presents you with a dedicated view of the objects that communicate
    with **adservice**. We saw a similar communications view in the **Graph** view,
    but we also saw every other object – including objects that have nothing to do
    with **adservice**.
  prefs: []
  type: TYPE_NORMAL
- en: The Applications view will streamline what we can see, making it easier to navigate
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Simplified communication view using the Applications view'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Applications view contains the components from the Graph
    view. The communications path that involves **adservice** starts with the frontend
    pod, which targets the **adservice** service, which ultimately routes the traffic
    to the **adservice** pod.
  prefs: []
  type: TYPE_NORMAL
- en: We can see additional details in the application by clicking on one of the tabs
    at the top of the **Applications** view. The first tab next to the overview is
    the **Traffic** tab, which provides you with a view of the traffic for the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Viewing application traffic'
  prefs: []
  type: TYPE_NORMAL
- en: The **Traffic** tab will show inbound and outbound traffic to the application.
    In the **adservice** example from the Boutique store, we can see that **adservice**
    has received inbound requests from the frontend. Below the inbound traffic, we
    can see the outbound traffic and, in our example, Kiali is telling us that there
    is no outbound traffic. As we can see in the overview in *Figure 16.10*, the **adservice**
    pod does not have any object that it connects to; therefore, we would not have
    any traffic to view. To get additional details on the traffic, you can click on
    the **View Metrics** link under **Actions** – this action is the same as if you
    were to click the **Inbound Metrics** tab.
  prefs: []
  type: TYPE_NORMAL
- en: The **Inbound Metrics** tab will provide you with additional details about the
    incoming traffic. *Figure 16.12* shows an abbreviated example for the **adservice**
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Viewing inbound metrics'
  prefs: []
  type: TYPE_NORMAL
- en: The inbound metrics will display a number of different metrics, including request
    volume, request duration, request and response size, request and response throughput,
    gRPC received and sent, TCP opened and closed, and TCP received and sent. This
    page will update in real time, allowing you to view the metrics as they are captured.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last tab will allow you to look at the traces for the **adservice**
    application. This is why we deployed Jaeger in our cluster when we installed Istio.
    Tracing is a fairly complex topic and is outside the scope of this chapter. To
    learn more about tracing using Jaeger, head over to the Jaeger site at [https://www.jaegertracing.io/](https://www.jaegertracing.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Using the Workloads view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next view we will discuss is the **Workloads** view, which breaks down the
    views to the workload type, like deployments. If you click on the **Workloads**
    link in Kiali, you will be taken to a breakdown of the Boutique workloads.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: The Workloads view'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that there is a warning under the **Details** column that tells
    us we are missing a version of the deployments. This is one of the features of
    this view. It will offer details like a workload not being assigned a version,
    which is not an issue for standard functionality in the mesh, but it will limit
    the use of certain features, like routing and some telemetry. It’s a best practice
    to always version your application, but for the example, Boutique from Google,
    they do not include a version in the deployments.
  prefs: []
  type: TYPE_NORMAL
- en: The **Workloads** view offers some of the same details as the **Applications**
    view, including traffic, inbound metrics, outbound metrics, and tracing – however,
    in addition to these details, we can now view the logs and details about Envoy.
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the **Logs** tab, you will see the logs for the **adservice**
    container.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.14: Viewing the container logs'
  prefs: []
  type: TYPE_NORMAL
- en: This is a real-time view of the logs that are being generated by the **adservice**
    container. In this view, you can create a filter to show or hide certain keywords,
    scroll back to previous events, change the default buffer size from 100 lines,
    copy the logs to your clipboard, or enter a fullscreen log view. Many users find
    this tab very useful since it doesn’t require them to use `kubectl` to look at
    the logs; they can simply open up Kiali in a browser and quickly view the logs
    in the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: The last tab we will discuss is the **Envoy** tab, which provides additional
    details about the Envoy sidecar. The details in this tab are extensive – it contains
    all of the mesh objects that you have included in the namespace (recall that we
    created a sidecar object to limit the objects to only the namespace and the `istio-system`
    namespace), all of the listeners, routes, the bootstrap configuration, config,
    and metrics.
  prefs: []
  type: TYPE_NORMAL
- en: By this point in the chapter, you can probably see how Istio would require its
    own book to cover all of the base components. All of the tabs in the **Envoy**
    tab provide a wealth of information, but it gets very detailed and we can’t fit
    them all in this chapter, so for the purposes of this chapter, we will only discuss
    the **Metrics** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the **Metrics** tab, you will see metrics pertaining to the uptime
    of Envoy, the allocated memory, heap size, active upstream connections, upstream
    total requests, downstream active connections, and downstream HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.15: Envoy metrics'
  prefs: []
  type: TYPE_NORMAL
- en: Like most metrics, these will be beneficial if you experience issues with the
    Envoy proxy container. The uptime will let you know how long the pod has been
    running, the allocated memory tells you how much memory has been allocated to
    the pod, which may help to identify why an OOM condition occurred, and active
    connections will identify if the service has issues if the connection count is
    lower than expected, or at zero.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Services view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we will discuss the last view for the application, the Services view.
    Just as the name implies, this will provide a view of the services that are part
    of the workload. You can open the Services view by clicking on the **Services**
    option in Kiali.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.16: The Services view'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the other views, this will provide the names of the services and
    the health of each of the services. If you click on any individual service, you
    will be taken to the details of the service. If you were to click **adservice**,
    you would be taken to the overview for the service.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.17: The services overview'
  prefs: []
  type: TYPE_NORMAL
- en: The **Overview** page should have some objects familiar to you. Just like the
    other views, it provides a view of just the objects that communicate with **adservice**,
    and it has tabs for traffic, inbound metrics, and traces – however, in addition
    to these, it also shows the network information for the service. In our example,
    the service has been configured to use a `ClusterIP` type, the service IP assigned
    is `10.110.47.79`, it has an endpoint of `10.240.189.149`, and it has the gRPC
    TCP port exposed on port `9555`.
  prefs: []
  type: TYPE_NORMAL
- en: This is information you could retrieve using `kubectl`, but for many people,
    it’s quicker to grab the details from the Kiali dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: The Istio Config view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last view we have is not related to the workload in particular. Instead,
    it’s a view for the Istio config for the namespace. This view will contain the
    Istio objects you have created. In our example, we have two objects, the gateway
    and the virtual service.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.18: The Istio Config view'
  prefs: []
  type: TYPE_NORMAL
- en: You can view the YAML for each object by clicking the name. This allows you
    to directly edit the object in the Kiali dashboard. Any changes that are saved
    will edit the object in the cluster, so be careful if you are using this method
    to modify the object.
  prefs: []
  type: TYPE_NORMAL
- en: This view offers one addition that the other views do not – the ability to create
    a new Istio object using a wizard. To create a new object, click the **Actions**
    dropdown in the upper right-hand corner of the Istio config view. This will bring
    up a list of objects that you can create, as shown in *Figure 16.19*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.19: Istio object creation wizard'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the figure, Kiali provides a wizard to create 6 Istio objects
    including **AuthorizationPolicies**, **Gateways**, **PeerAuthentication**, **RequestAuthentication**,
    **ServiceEntries**, and **Sidecars**.
  prefs: []
  type: TYPE_NORMAL
- en: Each option has a wizard to guide you through the specific requirements for
    that object. For example, we could create a sidecar using the wizard, as shown
    in *Figure 16.20*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.20: Using the Istio object wizard'
  prefs: []
  type: TYPE_NORMAL
- en: Once all fields have been entered correctly, you can click **Preview**, which
    will take you to the next screen, where you will see the object YAML source, as
    shown in *Figure 16.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.21: Wizard source YAML'
  prefs: []
  type: TYPE_NORMAL
- en: If it looks good, click **Create** to create the new object.
  prefs: []
  type: TYPE_NORMAL
- en: The wizards are a good tool for people who are new to Istio, but be careful
    not to rely on them too much. You should always understand how to create a manifest
    for all of your objects. Creating objects using wizards like these can lead to
    problems down the road without the knowledge of how the object works or is created.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce where Istio is heading in the future.
    As powerful as the sidecar is, it has its limitations, and it requires additional
    resources for each pod in the mesh. In 2023, Istio introduced a new concept called
    ambient mesh as an early access feature, which removed the requirement for the
    Istio sidecar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The future: Ambient mesh'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, Service meshes, such as Istio, depend on sidecar proxies connected to
    every service instance to handle traffic, security measures, and metric collection.
    Although this approach works well, it leads to extra resource usage and complexity,
    particularly in deployments in larger clusters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we mentioned sidecars a lot – they’re the heart of the mesh,
    providing the layer that removes all of the complexities of using mesh features
    without requiring code changes to our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient mesh marks a significant change in the Service mesh design, attempting
    to make it easier to add Service mesh features to an already complicated system
    without the need for sidecar proxies for every service. Its goal is to cut down
    on the extra work and complexity while keeping the main advantages of a Service
    mesh, including monitoring, security, and traffic management.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Istio 1.20, the ambient mesh has the **Alpha** status. The main reason
    that we haven’t added a chapter on using an ambient mesh is due to potential changes
    that will likely occur between the current alpha stage and when it goes to **general
    availability** (**GA**). However, since it is a giant leap forward and a major
    change in design, we wanted to bring it to your attention. You can read more about
    getting started with ambient mesh on Istio’s site here: [https://istio.io/latest/docs/ops/ambient/getting-started/](https://istio.io/latest/docs/ops/ambient/getting-started/).'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the docs on Istio’s site will provide some great examples of how the
    ambient mesh deploys and works. Since many readers will be new to Istio, jumping
    into the docs for an overview may be a little much, so we wanted to provide our
    view on the key points of what the ambient mesh means to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned, ambient mesh addresses a number of issues by removing the
    tasks that are usually managed by sidecar proxies. Rather than attaching a proxy
    to each service instance, the ambient mesh will integrate these functions directly
    into the network or in a common proxy layer. This design seeks to simplify processes
    and lessen the resources needed compared to the traditional sidecar method. This
    provides a number of advantages, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preservation of Essential Features**: Despite its unique architecture, the
    ambient mesh will continue to deliver the base capabilities found in current Service
    meshes, including secure communications between services, traffic control, and
    the ability to monitor components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined, Efficient Deployments**: The ambient mesh eliminates the necessity
    for individual sidecar proxies, streamlining the setup and management of Service
    meshes. This will facilitate easier adoption and maintenance, especially for organizations
    with complex microservices structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved Resource** **Utilization**: By minimizing the CPU and memory demands
    for service-to-service interactions, the ambient mesh allows the efficient use
    of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance Enhancement**: The ambient mesh enhances system performance by
    optimizing the routes used for service communication, reducing delays and boosting
    efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine the resource and complexity savings in a large cluster where you may
    have thousands, or tens of thousands, of services running. Currently, that would
    require as many proxy instances running, each adding an extra layer in the communication
    and using its own resources – using extra CPU and RAM that are not actually “required”
    for the base applications. The ambient mesh will save you money by reducing the
    required resources, and by simplifying the architecture, it should be easier to
    find issues when an application is not behaving as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We hope that this chapter has provided a useful introduction to Istio and what’s
    in store for Istio’s future. In the next chapter, we will dive deeper into running
    applications in an enterprise using Istio.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the Service mesh world, using the popular
    open-source project Istio. In the first section of the chapter, we explained some
    of the advantages of using a Service mesh, which included security and observability
    for mesh services.
  prefs: []
  type: TYPE_NORMAL
- en: The second section of the chapter detailed the installation of Istio and the
    different installation profiles that are available. We deployed Istio into our
    KinD clusters and we also removed NGNIX to free up ports `80` and `443` to be
    used by Istio’s ingress gateway. This section also included the objects that are
    added to a cluster once you deploy Istio. We covered the most common objects using
    example manifests that reinforce how to use each object in your own deployments.
  prefs: []
  type: TYPE_NORMAL
- en: To close out the chapter, we detailed how to install Kiali, Prometheus, and
    Jaeger to provide powerful observability in our Service mesh. We also explained
    how to use Kiali to look into an application in the mesh to view the application
    metrics and logs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deploy a new application and bind it to the Service
    mesh, building on many of the concepts that were presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Istio object(s) is used to route traffic between multiple versions of an
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ingress rule
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VirtualService
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DestinationRule
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can’t route traffic between multiple versions, only a single instance
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool(s) are required to provide observability in the Service mesh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prometheus
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Jaeger
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kiali
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes Dashboard
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Istio features require developers to change their code to leverage
    features like mutual TLS and authorization.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Istio made the control plane easier to deploy and configure by merging multiple
    components into a single executable called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Istio
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: IstioC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: istiod
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pilot
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b - VirtualService and c - DestinationRule
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a Prometheus and c - Kiali
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b - False
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c - Pilot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
