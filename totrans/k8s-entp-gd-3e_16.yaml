- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: An Introduction to Istio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio简介
- en: “If it makes it easier for users to use on the frontend, it’s probably complex
    on the backend.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果前端用户使用起来很容易，那可能意味着后端很复杂。”
- en: This chapter will introduce you to Istio, a Service mesh add-on for Kubernetes.
    A Service mesh is a tool for Kubernetes that improves the management, security,
    and visibility of microservices in a cluster. It simplifies complex networking
    tasks by handling service-to-service communication, load balancing, and traffic
    routing outside the application code. Istio also enhances security with features
    like encryption, authentication, and authorization. It provides detailed metrics
    and monitoring, allowing developers to understand how their services are performing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Istio，它是Kubernetes的一个服务网格插件。服务网格是一个工具，用于提升Kubernetes集群中微服务的管理、安全性和可视化。它通过处理服务间通信、负载均衡和流量路由，简化了复杂的网络任务，而无需在应用代码中实现这些功能。Istio还通过加密、认证和授权等功能增强了安全性。它提供了详细的指标和监控，帮助开发者了解他们的服务性能。
- en: Istio is a large, complex system that provides benefits to your workloads by
    offering enhanced security, discovery, observability, traffic management, and
    more – all without requiring application developers to write modules or applications
    to handle each task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Istio是一个庞大而复杂的系统，它通过提供增强的安全性、发现、可观察性、流量管理等功能，给你的工作负载带来好处——而无需应用开发者为每个任务编写模块或应用。
- en: 'While Istio presents a steep learning curve, mastering it unlocks the potential
    to offer developers advanced functionalities, enabling intricate Service mesh
    deployments and a broad spectrum of capabilities, including the ability to do
    the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Istio有陡峭的学习曲线，但掌握它能够为开发者提供高级功能，使得复杂的服务网格部署和广泛的功能成为可能，包括以下能力：
- en: Route traffic based on various requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据不同需求路由流量
- en: Secure service-to-service communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全的服务间通信
- en: Traffic shaping
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量整形
- en: Circuit breaking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路
- en: Service observability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可观察性
- en: 'The future: Ambient mesh'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来：环境网格
- en: Developers can use these tools with minimal or no changes to their code. When
    something is easy for users, it often means there’s a lot of complexity behind
    the scenes, and Istio is a good example of this. This chapter will show you how
    to set up Istio and Kiali, a tool for monitoring. We’ll also discuss Istio’s key
    features that help manage traffic, enhance security, and reveal workloads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在最少或无需修改代码的情况下使用这些工具。当某些功能对用户来说很容易使用时，往往意味着背后有很多复杂的工作，Istio就是一个很好的例子。本章将展示如何设置Istio和Kiali，一个用于监控的工具。我们还将讨论Istio的关键功能，这些功能有助于流量管理、增强安全性和揭示工作负载。
- en: To fully explain Istio, we’d need a whole other book focused just on its custom
    resources and ways to use them. Our aim in this chapter and the next is to give
    you the basic knowledge you need to start using Istio confidently. We can’t go
    into every detail about each component, so we recommend visiting the Istio website
    at [https://istio.io](https://istio.io) for additional information to build on
    what you will learn in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面解释Istio，我们需要一本专门介绍其自定义资源及使用方法的书籍。本章及下一章的目标是让你掌握使用Istio的基本知识，以便你可以自信地开始使用它。我们不能涵盖每个组件的所有细节，因此建议你访问Istio官网
    [https://istio.io](https://istio.io)，以获得更多信息，进一步扩展你在本章所学的内容。
- en: 'This chapter will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the control plane and data plane
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解控制平面和数据平面
- en: Why should you care about a Service mesh?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该关心服务网格？
- en: Introduction to Istio concepts
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio概念介绍
- en: Understanding Istio components
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Istio组件
- en: Installing Istio
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Istio
- en: Introducing Istio resources
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Istio资源
- en: Deploying add-on components to provide observability
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署附加组件以提供可观察性
- en: Deploying an application into the Service mesh
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用部署到服务网格中
- en: 'The future: Ambient mesh'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来：环境网格
- en: Before we dive into the chapter, let’s set the scene for what you’re about to
    learn. This chapter is designed to introduce you to deploying Istio and the main
    features it provides. It gives you the key details to understand how Istio functions
    and what its various parts are. By the end of this chapter and the next chapter,
    where you’ll add an application to the mesh, you should have a good grasp of how
    to set up and use a basic Istio Service mesh.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入本章内容之前，先为你即将学习的内容定个基调。本章旨在介绍如何部署 Istio 以及它提供的主要功能。它提供了了解 Istio 功能和各部分的关键细节。在本章以及下一章中（你将把应用程序添加到服务网格中），你应该能够很好地掌握如何设置和使用基本的
    Istio 服务网格。
- en: We will close out the chapter with a look at the future of the Service mesh,
    known as the ambient mesh. As of the publishing of this book, the ambient mesh
    is still in beta, and since a lot of things can change between beta and a GA release,
    we will only provide an overview of what the ambient mesh will bring when it’s
    released.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章结束时，展望服务网格的未来，即所谓的环境网格（ambient mesh）。截至本书发布时，环境网格仍处于测试阶段，由于从测试版到正式版的过程中可能会有许多变化，我们将仅概述环境网格发布时将带来的新特性。
- en: 'To wrap up this introduction, here’s a fun fact about Kubernetes: like many
    things in Kubernetes, Istio is named after something related to the sea. In Greek,
    “Istio” means “sail.”'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章介绍的结尾，这里有一个关于 Kubernetes 的趣味事实：像 Kubernetes 中的许多东西一样，Istio 的名字来源于与海洋相关的事物。在希腊语中，“Istio”意味着“帆”。
- en: Technical requirements
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下技术要求：
- en: A Docker host installed using the steps from *Chapter 1*, *Docker and Container
    Essentials*, with a minimum of 8 GB of RAM, although 16 GB is recommended
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照*第 1 章*《Docker 和容器基础》中的步骤安装的 Docker 主机，至少需要 8 GB 的 RAM，推荐 16 GB。
- en: A KinD cluster configured using the initial scripts from *Chapter 2*, *Deploying
    Kubernetes Using KinD*
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照*第 2 章*《使用 KinD 部署 Kubernetes》中的初始脚本配置的 KinD 集群
- en: Installation scripts from this book’s GitHub repository
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的安装脚本
- en: 'You can access the code for this chapter by going to this book’s GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问本书的 GitHub 仓库来获取本章的代码：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16)。
- en: To use Istio to expose workloads, we will remove NGINX from the KinD cluster,
    which will allow Istio to utilize ports `80` and `443` on the host.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Istio 来暴露工作负载，我们将从 KinD 集群中移除 NGINX，这样可以让 Istio 使用主机上的端口 `80` 和 `443`。
- en: Understanding the Control Plane and Data Plane
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解控制平面和数据平面
- en: 'The Service mesh framework enhances how microservices communicate, making these
    interactions more secure, faster, and more reliable. It is separated into two
    main components: the control plane and the data plane, each playing a specific
    role in providing service-to-service communication in Kubernetes. These two layers
    are what make up the Service mesh as a whole and a basic understanding of each
    is key to understanding Istio.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格框架增强了微服务之间的通信，使这些交互更加安全、快速和可靠。它分为两个主要组件：控制平面和数据平面，每个组件在提供 Kubernetes 中的服务间通信中扮演着特定角色。这两个层次构成了服务网格的整体，了解每个层次的基本概念对于理解
    Istio 非常关键。
- en: The Control Plane
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制平面
- en: Let’s start with the Istio control plane.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Istio 控制平面开始。
- en: The control plane in Istio is the central authority that controls and directs
    how services in the mesh communicate with each other. A common analogy is to think
    of a city’s traffic control, managing roads and traffic signals to ensure safe
    and efficient traffic flow and order. It plays an important role in the orchestration
    of service-to-service communication, security, and observability across the entire
    mesh. We will discuss the different features that are controlled by the control
    plane when we discuss the main control plane daemon, `istiod`, in the *Understanding
    the Istio components* section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 中的控制平面是中央权威，控制并指挥服务网格中各服务之间的通信方式。一个常见的类比是将它比作城市的交通管理，管理道路和交通信号灯，确保交通流畅和有序。它在服务间通信、服务安全以及整个网格的可观察性方面起着重要作用。我们将在*理解
    Istio 组件*部分讨论控制平面中的主要守护进程 `istiod` 时，详细介绍控制平面所管理的不同功能。
- en: The Data Plane
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据平面
- en: The second component is the data plane, which is the worker layer that contains
    a set of proxies, known as Envoy proxies, deployed alongside your services. These
    proxies intercept and manage the network traffic between microservices without
    the need for you or your developers to do any additional work or recoding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件是数据平面，它是包含一组代理（称为 Envoy 代理）的工作层，这些代理与您的服务一起部署。它们拦截并管理微服务之间的网络流量，而无需您或您的开发人员做任何额外的工作或重新编码。
- en: To build on the previous analogy we used for the control plane, think of the
    data plane as the roads in a city. Each service in the mesh receives a dedicated
    road where traffic is directed to the service by a traffic controller – in our
    case, the Istio control plane (istiod).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立我们之前提到的控制平面的类比，可以将数据平面比作城市中的道路。网格中的每个服务都有一条专用的道路，流量通过交通控制器指向该服务——在我们的例子中，交通控制器就是
    Istio 控制平面（istiod）。
- en: Up until now, you may have been using Kubernetes without a Service mesh. So,
    you may be wondering why you should care about the features that Istio brings
    to your cluster. In the next section, we will go over Istio’s features so you
    will be able to explain to your developers and businesses why a Service mesh is
    an important add-on to clusters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能一直在使用 Kubernetes，而没有服务网格。那么，您可能会想，为什么要关心 Istio 为您的集群带来的功能？在接下来的部分中，我们将介绍
    Istio 的特点，以便您能够向开发人员和企业解释为什么服务网格是集群的重要附加组件。
- en: Why should you care about a Service mesh?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要关心服务网格？
- en: Service meshes, like Istio, provide several features that developers would typically
    need to develop on their own, necessitating changes to their existing code. Without
    Istio, if developers require specific capabilities, such as secure communication
    between services coded in various programming languages like Java, Python, or
    Node.js, they would need to implement the necessary code, or libraries, for each
    language individually. This adds complexity to the code and can often lead to
    inefficient coding, causing performance issues with the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格（如 Istio）提供了多个功能，通常开发人员需要自己开发这些功能，这会迫使他们修改现有的代码。如果没有 Istio，当开发人员需要特定功能时，比如在多种编程语言（如
    Java、Python 或 Node.js）编写的服务之间实现安全通信，他们需要为每种语言单独实现必要的代码或库。这会增加代码的复杂性，通常还会导致效率低下，进而引发应用性能问题。
- en: Adding security, like encryption, is just one example of what a developer may
    require to create an application. What about other features, like controlling
    data flow, testing how the application will react to failures, or how network
    delays may cause the application to behave in an unexpected way? These, and many
    other features, are all included with Istio – allowing developers to focus on
    their own business code, rather than writing additional code to control traffic
    or to simulate errors or delays.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 添加安全性，比如加密，仅仅是开发人员在创建应用时可能需要的一个例子。那么其他功能呢，比如控制数据流、测试应用如何应对故障，或者网络延迟如何导致应用行为异常？这些以及许多其他功能，Istio
    都包含其中——它允许开发人员专注于他们自己的业务代码，而不是编写额外的代码来控制流量或模拟错误或延迟。
- en: Let’s take a look at some of the advantages that Istio offers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 Istio 提供的一些优势。
- en: Workload observability
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作负载可观察性
- en: Downtime or slowdowns in an application may impact your organization’s reputation
    and potentially cause lost revenue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的停机时间或变慢可能会影响您组织的声誉，并可能导致收入损失。
- en: Have you ever found it challenging to pinpoint the underlying issue in an application
    with many active services? Imagine the ability to quickly identify and resolve
    problems by monitoring the interactions and status of services in real time, or
    by replaying events from the past to discover where things went wrong hours or
    days before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经在一个有许多活跃服务的应用中，难以找到根本问题？想象一下，通过实时监控服务之间的交互和状态，或者回放过去的事件，快速识别和解决问题，发现几小时或几天前出了什么问题。
- en: Managing complex applications and multiple services can feel overwhelming. The
    features offered by Istio make this task far less intimidating. If only there
    was a way to make this easier for developers! Thanks to Istio and its ecosystem,
    this isn’t just wishful thinking. With powerful features like Prometheus for storing
    metrics, Kiali for deep insights, and Jaeger for detailed tracing, you’re equipped
    with a powerful toolkit for troubleshooting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 管理复杂的应用程序和多个服务可能会让人感到不知所措。Istio 提供的功能使这项任务变得不那么令人生畏。如果开发者能有一种更简单的方法该多好！幸好有了
    Istio 及其生态系统，这不仅仅是空想。凭借 Prometheus 用于存储度量数据、Kiali 用于深入洞察以及 Jaeger 用于详细追踪等强大功能，你可以拥有一套强大的故障排除工具。
- en: In this chapter, we’re going to set up all three add-ons, with a focus on using
    Kiali, which lets you observe communications between your services like never
    before.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置所有三个插件，重点使用 Kiali，它让你以前所未有的方式观察服务之间的通信。
- en: Traffic management
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量管理
- en: Istio provides you with powerful traffic management capabilities for your workloads,
    offering the flexibility to adopt any deployment model you need, without the hassle
    of altering your network infrastructure. This control is entirely in your and
    your developers’ hands. Istio also includes tools that enable you to simulate
    various unpredictable scenarios that your application might encounter, such as
    HTTP errors, delays, timeouts, and retries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 为你的工作负载提供了强大的流量管理能力，提供了灵活性，可以采用任何你需要的部署模型，而无需修改网络基础设施。这种控制完全掌握在你和开发者手中。Istio
    还包括一些工具，使你能够模拟应用程序可能遇到的各种不可预见的情况，如 HTTP 错误、延迟、超时和重试。
- en: We recognize that some of our readers might be new to the concept of deployment
    models. Grasping the different types available is crucial for understanding, and
    appreciating, the benefits that Istio brings to the table. With Istio, developers
    can effectively utilize deployment strategies like blue/green and canary deployments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认识到，一些读者可能对部署模型的概念还不熟悉。掌握可用的不同类型对于理解和欣赏 Istio 带来的好处至关重要。通过 Istio，开发者可以有效地利用蓝绿部署和金丝雀部署等部署策略。
- en: Blue/green deployments
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: In this model, you deploy two versions to production, directing a certain percentage
    of traffic to each version of the application, usually sending a low amount of
    traffic to the “new” (green) release. As you verify that the new deployment is
    working as expected, you can cut over all of the traffic to the green deployment,
    or you use blue/green combined with a canary deployment to the new version until
    you are eventually sending 100% of the traffic to the new deployment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模型中，你将两个版本部署到生产环境，按比例将流量分配到每个版本的应用程序，通常会将少量流量引导到“新”的（绿色）版本。当你验证新部署按预期工作时，可以将所有流量切换到绿色部署，或者将蓝绿部署与金丝雀部署结合使用，直到最终将
    100% 的流量切换到新部署。
- en: Canary deployments
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: This term comes from the mining days when miners would put a canary in the mining
    shaft to verify it was safe to work in the environment. In the case of a deployment,
    it allows you to deploy an early test version of the application before graduating
    the release to a new version. Essentially, this is similar to the blue/green deployment,
    but in a canary deployment, you would direct a very small percentage of traffic
    to the canary version of the application. Using a small percentage of traffic
    will minimize any impact that the canary deployment may introduce. As you become
    more confident that the “canary” version of the application is stable, you will
    move over additional traffic until you are 100% on the new version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语源自矿业时代，当时矿工会将金丝雀放入矿井中，以验证工作环境是否安全。在部署的情况下，它允许你在将发布版本升级为新版本之前，先部署一个早期的测试版本。实质上，这类似于蓝绿部署，但在金丝雀部署中，你会将非常小比例的流量引导到金丝雀版本的应用程序上。使用少量的流量将最大限度地减少金丝雀部署可能引入的影响。当你越来越确信“金丝雀”版本的应用程序是稳定的时，你会逐步增加流量，直到所有流量都切换到新版本。
- en: Finding issues before they happen
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在问题发生之前发现问题
- en: We can go a step further from deployment models; Istio also provides tools for
    you to develop resilience and testing for your workloads before you deploy them
    and learn about issues from customers or end-users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步深化部署模型；Istio 还为你提供了开发弹性和测试工具，在部署工作负载之前，帮助你发现问题，而不是等客户或终端用户反馈。
- en: Have you ever worried about how an application will react to certain unseen
    events?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你曾经担心过应用程序如何应对某些未知事件吗？
- en: 'Developers need to worry about events that they have little control over, including:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要担心他们几乎无法控制的事件，包括：
- en: Application timeouts
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序超时
- en: Delays in communication
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信延迟
- en: HTTP error codes
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 错误代码
- en: Retries
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试
- en: Istio provides objects to assist in dealing with these by allowing you to create
    an issue with the workload before you move to production. This allows developers
    to capture and resolve issues in their applications before releasing them to production,
    creating a better user experience.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 提供了对象来帮助处理这些问题，允许你在迁移到生产环境之前与工作负载创建问题。这使得开发者能够在将应用发布到生产环境之前捕捉并解决应用中的问题，从而提供更好的用户体验。
- en: Security
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: In today’s world, security is an issue we should all be concerned about. Many
    of the methods to secure a workload are complex and may require a skillset that
    many developers do not have. This is truly where Istio shines, providing the tools
    to easily deploy security and minimize its impact on development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界中，安全性是我们每个人都应该关注的问题。许多保护工作负载的方法都很复杂，并可能需要很多开发者没有的技能。这正是 Istio 大显身手的地方，它提供了工具，使得安全部署变得简单，并且尽可能减少对开发的影响。
- en: The first, and most popular, security feature in Istio is the ability to provide
    **mutual Transport Layer Security** (**mTLS**) between workloads. Using mTLS,
    Istio provides not only encryption for communication but workload identity too.
    When you visit a website that has an expired certificate or a self-signed certificate,
    your browser will warn you that the site can’t be trusted. That’s because your
    browser performs server authentication when establishing a TLS connection by verifying
    that the certificate presented by the server is trusted by the browser. mTLS verifies
    trust from the client to the server, but also from the server to the client. That’s
    the mutual part. The server validates that the certificate presented by the client
    is trusted as well as the client validating the server. When you first start a
    cluster and use the initial certificate created for you, you’re using mTLS. Istio
    makes this much easier because it will create all of the certificates and identities
    for you using its built-in sidecar.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 中第一个也是最受欢迎的安全功能是能够在工作负载之间提供**相互传输层安全性**（**mTLS**）。通过使用 mTLS，Istio 不仅为通信提供加密，还提供工作负载身份。当你访问一个证书过期或自签名证书的网站时，浏览器会警告你该站点无法被信任。这是因为浏览器在建立
    TLS 连接时会进行服务器认证，通过验证服务器提供的证书是否被浏览器信任。mTLS 不仅验证客户端到服务器的信任，还验证服务器到客户端的信任。这就是“相互”的部分。服务器验证客户端提供的证书是否被信任，客户端也验证服务器的证书。当你首次启动集群并使用为你创建的初始证书时，你就在使用
    mTLS。Istio 让这一过程变得更加简单，因为它会使用内置的 sidecar 为你创建所有证书和身份。
- en: You can configure mTLS as a requirement (STRICT), or as an option (PERMISSIVE),
    for the entire mesh or individual namespaces. If you set either option to STRICT,
    any communication to the service will require mTLS and if a request fails to provide
    an identity, the connection will be denied. However, if you set the PERMISSIVE
    option, traffic that has an identity and requests mTLS will be encrypted, while
    any request that does not provide an identity or encryption request will still
    be allowed to communicate.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 mTLS 配置为整个网格或单个命名空间的要求（STRICT），或选项（PERMISSIVE）。如果你将选项设置为 STRICT，任何与服务的通信都需要
    mTLS，如果请求未能提供身份，则连接将被拒绝。然而，如果你设置 PERMISSIVE 选项，具有身份并请求 mTLS 的流量将会被加密，而任何未提供身份或加密请求的请求仍然会被允许进行通信。
- en: Another feature provided will give you the ability to secure what communication
    is allowed to a workload, similar to a firewall, but in a much simpler implementation.
    Using Istio, you can decide to only allow HTTP GET requests, or only HTTP POST
    requests, or both – from only defined sources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提供的功能将使你能够控制允许哪些通信访问工作负载，类似于防火墙，但实现方式更简单。通过 Istio，你可以决定只允许 HTTP GET 请求，或只允许
    HTTP POST 请求，或者两者都允许——且仅限于特定来源。
- en: Finally, you can use **JSON Web Tokens** (**JWTs**) for initial user authentication
    to limit who is authorized to communicate with a workload. This allows you to
    secure the initial communication attempt by only accepting JWTs that come from
    an approved token provider.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用**JSON Web 令牌**（**JWTs**）进行初始用户认证，以限制哪些人有权限与工作负载通信。这使得你能够通过只接受来自批准的令牌提供者的
    JWT 来保护初始通信尝试。
- en: Now that we have discussed some of the reasons you would want to deploy Istio,
    let’s introduce you to some Istio concepts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些你可能想要部署 Istio 的原因，让我们来介绍一些 Istio 的概念。
- en: Introduction to Istio concepts
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio概念介绍
- en: 'The principles of Istio can be divided into four main areas: traffic management,
    security, observability, and extensibility. For each of these areas, we’ll introduce
    the components and custom resources that developers can utilize to tap into the
    benefits of using Istio.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Istio的原则可以分为四个主要领域：流量管理、安全性、可观察性和可扩展性。对于这些领域，我们将介绍开发人员可以利用的组件和自定义资源，以便充分利用Istio带来的好处。
- en: Understanding the Istio components
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Istio组件
- en: Similar to a standard Kubernetes cluster, Istio refers to two separate planes,
    the control plane and the data plane. Historically, the data plane included four
    different services, Pilot, Galley, Citadel, and Mixer – all broken out in a true
    microservices design. This design was used for multiple reasons, including the
    flexibility to break out the responsibilities to multiple teams, the ability to
    use different programming languages, and the ability to scale each service independently
    of the others.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于标准Kubernetes集群，Istio指代两个独立的平面：控制平面和数据平面。历史上，数据平面包括四个不同的服务，Pilot、Galley、Citadel和Mixer——所有这些服务都采用真正的微服务设计。这种设计有多种原因，包括将职责分配给多个团队的灵活性、使用不同编程语言的能力，以及独立扩展每个服务的能力。
- en: Istio has evolved quickly since its initial release. The team made the decision
    that breaking out the core services had little benefit and, in the end, made Istio
    more complex. This led the team to redesign Istio and starting with Istio 1.5,
    Istio includes the components that we will discuss in this section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自Istio首次发布以来，Istio发展迅速。团队决定，拆分核心服务几乎没有好处，反而让Istio变得更复杂。这促使团队重新设计Istio，并且从Istio
    1.5开始，Istio包含了我们将在本节中讨论的组件。
- en: Making the Control Plane simple with istiod
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用istiod简化控制平面
- en: Just as Kubernetes bundles multiple controllers into a single executable, kube-controller-manager,
    the Istio team decided to bundle the control plane components into a single daemon
    called istiod. This single daemon grouped all of the control plane components
    into a single pod that can be easily scaled as performance is required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Kubernetes将多个控制器打包成一个可执行文件kube-controller-manager一样，Istio团队决定将控制平面组件打包成一个名为istiod的单一守护进程。这个单一守护进程将所有控制平面组件组合成一个单一的Pod，可以根据需要轻松扩展性能。
- en: 'The main advantages to the single daemon are listed in an Istio blog at [https://istio.io/latest/blog/2020/istiod/](https://istio.io/latest/blog/2020/istiod/).
    To summarize the team’s reasoning, the single process provides:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 单一守护进程的主要优势列在Istio的博客中，地址为[https://istio.io/latest/blog/2020/istiod/](https://istio.io/latest/blog/2020/istiod/)。总结团队的理由，单一进程提供了：
- en: Easier and quicker control plane installations
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简便快捷的控制平面安装
- en: Easier configuration
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单的配置
- en: Integration of virtual machines into the Service mesh more easily, requiring
    a single agent and Istio’s certificates
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易将虚拟机集成到服务网格中，只需要一个代理和Istio的证书
- en: Easier scaling
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易进行扩展
- en: Reduced control plan startup time
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少控制平面的启动时间
- en: A reduced amount of overall required resources
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少所需的整体资源量
- en: The control plane is responsible for controlling your Service mesh. It has a
    number of important features that are required to create and manage the components
    of Istio, and in the next section, we will explain the features that istiod provides.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面负责控制你的服务网格。它具有创建和管理Istio组件所需的多个重要特性，下一节我们将解释istiod所提供的特性。
- en: Breaking down the istiod pod
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 拆解istiod Pod
- en: 'Moving to a single binary didn’t reduce Istio’s functionality or features;
    it still provides all of the features that the separate components provided, they
    are all just in a single binary now. Each piece provides a key feature to the
    Service mesh, and in this section, we will explain these features:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到单一二进制文件并没有减少Istio的功能或特性；它仍然提供了各个独立组件所提供的所有功能，只不过现在它们都集中在一个单一的二进制文件中。每个部分都为服务网格提供了一个关键特性，接下来我们将解释这些特性：
- en: '**Service Discovery**: Ensures that Envoy proxies, deployed alongside a Service
    in the same pod, have up-to-date information about the network locations, including
    the IP address and ports of services in the mesh. Service Discovery provides efficient
    service-to-service communication across the mesh.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：确保与服务一起部署在同一Pod中的Envoy代理，能够获取最新的网络位置信息，包括服务网格中服务的IP地址和端口。服务发现提供了跨服务网格的高效服务间通信。'
- en: Services can frequently scale up or down, and pods may be terminated or launched
    as part of rolling updates or auto-scaling activities. Each change can potentially
    alter the endpoints. Service discovery automates the process of tracking these
    changes by watching for updates to services and their associated pods. When a
    change has occurred, the Service discovery component updates the internal registry
    of Service endpoints and pushes these updates to the Envoy sidecars.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可能频繁地进行扩展或缩减，pod 可能作为滚动更新或自动扩展活动的一部分被终止或启动。每次变化可能会改变端点。服务发现通过监控服务及其相关 pod
    的更新来自动跟踪这些变化。当发生变化时，服务发现组件会更新内部服务端点注册表，并将这些更新推送到 Envoy sidecar。
- en: Service Discovery is essential for maintaining the responsiveness and efficiency
    of the Service mesh, dynamically adapting to the ever-changing landscape of containerized
    application environments in real time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现对于保持服务网格的响应性和效率至关重要，能够实时动态适应容器化应用环境不断变化的格局。
- en: '**Configuration Distribution**: Handles the configuration of traffic routing,
    security protocols, and policy enforcement across the data plane’s sidecars. Configuration
    distribution centralizes functions that used to be performed by a component called
    Galley, including the authorization of configuration changes in the Service mesh.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置分发**：处理数据平面 sidecar 代理的流量路由、安全协议和策略执行的配置。配置分发集中管理以前由名为 Galley 的组件执行的功能，包括在服务网格中授权配置变更。'
- en: '**Certificate Lifecycle Management**: Manages the issuing, renewal, and revocation
    of digital certificates, which are used for secure service-to-service communication
    using mutual Transport Layer Security (mTLS) guaranteeing that was previously
    handled by a component called Citadel, which provided identity verification and
    management of certificates, guaranteeing that all services within the mesh can
    trust connections, without requiring any additional components or configuration.
    mTLS reduces security threats by encrypting the transferring of data between services,
    providing the confidentiality and integrity of communication within the Service
    mesh.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书生命周期管理**：管理数字证书的颁发、续期和撤销，这些证书用于通过相互传输层安全（mTLS）保证的安全服务间通信，之前由一个名为 Citadel
    的组件处理，该组件提供身份验证和证书管理，确保网格内的所有服务都能信任连接，无需任何额外的组件或配置。mTLS 通过加密服务之间的数据传输，减少了安全威胁，提供了服务网格内通信的机密性和完整性。'
- en: '**Automated Envoy Proxy Deployment**: Streamlines the deployment process by
    automatically deploying Envoy sidecar proxies within Kubernetes pods. This seamless
    integration optimizes the management of both `Egress` and `Ingress` traffic through
    the pods, serving as an invisible mediator that oversees network traffic.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化 Envoy 代理部署**：通过在 Kubernetes pod 内自动部署 Envoy sidecar 代理，简化了部署过程。这种无缝集成优化了通过
    pod 管理`Egress`和`Ingress`流量的方式，充当了一个无形的中介，监督网络流量。'
- en: This automated process ensures that each pod in the Service mesh receives its
    own Envoy proxy, providing advanced traffic capabilities including routing, load
    distribution, and security measures. The automation of Envoy proxy deployment
    removes the complexities involved in establishing and upkeeping the Service mesh,
    allowing developers and operators to spend time on their primary responsibilities.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动化过程确保服务网格中的每个 pod 都接收到自己的 Envoy 代理，提供先进的流量能力，包括路由、负载分配和安全措施。Envoy 代理部署的自动化消除了建立和维护服务网格时的复杂性，使开发者和运维人员能够将精力集中在主要职责上。
- en: '**Traffic Routing and Control**: Responsible for creating and sharing the rules
    for managing traffic to Envoy proxies, providing a pivotal role in executing advanced
    network operations, and providing a way for precise control over often complex
    network traffic flows.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量路由与控制**：负责创建并共享管理流量到 Envoy 代理的规则，在执行高级网络操作中扮演关键角色，并提供精确控制通常复杂的网络流量流向的方式。'
- en: 'The functionalities provided by traffic routing and control, include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 流量路由和控制提供的功能包括：
- en: Determining the path(s) for directing traffic
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定流量的路径
- en: Strategic retry mechanisms
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略性重试机制
- en: Failover schemes to ensure continuity
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障转移机制以确保持续性
- en: The introduction of faults for the purpose of creating realistic testing environments
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了创建现实的测试环境，引入故障
- en: Traffic routing and controls provide a number of advantages, including streamlining
    the management of network traffic, testing the network’s stability and response
    under certain conditions, and increasing workload resilience by simulating disruptions
    and how the application reacts before they occur in production.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 流量路由和控制提供了多项优势，包括简化网络流量管理、测试网络在特定条件下的稳定性和响应，以及通过模拟中断和应用程序反应来提高工作负载的弹性，以便在生产环境中发生之前解决潜在问题。
- en: '**Security Policy Enforcement**: Uses security rules to make sure only authorized
    users or services have access and can interact within the network securely.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全策略执行**：使用安全规则确保只有授权用户或服务能够安全地访问并在网络中进行交互。'
- en: '**Observability Data Collection**: In a Service mesh, it’s essential to keep
    an eye on how things are running and to quickly identify and solve any problems.
    This is where observability data collection comes into play, gathering and analyzing
    telemetry information, including metrics, logs, and traces from the data plane,
    enhancing the mesh’s monitoring and operational insight capabilities.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性数据收集**：在服务网格中，跟踪系统运行情况并快速识别和解决问题至关重要。这就是可观察性数据收集的作用，通过收集和分析遥测信息（包括指标、日志和来自数据平面的跟踪），增强网格的监控和运营洞察能力。'
- en: Now that we have discussed what istiod provides, we will move on to how incoming
    traffic is managed in the Service mesh using the `istio-ingressgateway` component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了 istiod 提供的功能，接下来我们将讨论如何使用 `istio-ingressgateway` 组件在服务网格中管理传入流量。
- en: Understanding istio-ingressgateway
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解 istio-ingressgateway
- en: Moving on from the base istiod pod, we come to one of the most important components
    of Istio, `istio-ingressgateway`. This gateway facilitates external clients’ and
    services’ access to the Service mesh, acting as the entry point into the Kubernetes
    cluster. It’s standard for every Istio-enabled cluster to be equipped with at
    least one instance of `istio-ingressgateway`. However, Istio’s design does not
    confine you to just one; depending on your specific needs, it’s possible to deploy
    multiple ingress gateways to serve various purposes or handle different traffic
    patterns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础的 istiod pod 转到 Istio 的一个重要组成部分——`istio-ingressgateway`。这个网关使外部客户端和服务能够访问服务网格，充当进入
    Kubernetes 集群的入口点。每个启用 Istio 的集群通常至少配备一个 `istio-ingressgateway` 实例。然而，Istio 的设计并不限于此；根据具体需求，可以部署多个
    ingress 网关来服务不同的目的或处理不同的流量模式。
- en: 'The `istio-ingressgateway` provides access to applications using two methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`istio-ingressgateway` 提供了两种方式来访问应用程序：'
- en: Standard Kubernetes Ingress object support
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准 Kubernetes Ingress 对象支持
- en: Istio Gateway and VirtualService objects
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio 网关和虚拟服务对象
- en: Since we have already discussed and deployed NGINX as an Ingress controller,
    we will not cover using Envoy as a standard Ingress controller; instead, we will
    focus on the second method of using Gateways and Virtual Services for incoming
    requests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经讨论并部署了 NGINX 作为 Ingress 控制器，因此不会再讨论使用 Envoy 作为标准 Ingress 控制器；相反，我们将重点介绍使用网关和虚拟服务来处理传入请求的第二种方法。
- en: Using Gateways to expose our services provides more flexibility, customization,
    and security over a standard Ingress object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网关暴露我们的服务比标准的 Ingress 对象提供了更多的灵活性、定制性和安全性。
- en: Understanding istio-egressgateway
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解 istio-egressgateway
- en: The `istio-egressgateway` is designed to direct traffic from sidecars to either
    a single pod or a collection of pods, thereby centralizing the exiting (egress)
    traffic from the Service mesh. Normally, Istio sidecars manage both incoming and
    outgoing traffic for services within the mesh. While `istio-ingressgateway` is
    utilized for managing incoming traffic to the mesh, implementing `istio-egressgateway`
    allows for the regulation of outgoing traffic as well. The functionalities and
    details of both `ingressgateway` and `egressgateway` will be explored thoroughly
    in the *Introducing Istio resources* section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`istio-egressgateway` 旨在将流量从 sidecar 定向到单个 pod 或一组 pod，从而集中管理服务网格中的外发（egress）流量。通常，Istio
    sidecar 同时管理网格内服务的传入和传出流量。虽然 `istio-ingressgateway` 用于管理传入流量，但实现 `istio-egressgateway`
    也可以对传出流量进行管理。`ingressgateway` 和 `egressgateway` 的功能和细节将在 *介绍 Istio 资源* 部分中进行详细探讨。'
- en: Now, let’s jump into how you install Istio in a cluster.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解如何在集群中安装 Istio。
- en: Installing Istio
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Istio
- en: There are multiple methods to deploy Istio. The most common methods today are
    to use either `istioctl` or Helm, but there are additional options depending on
    your organization. You may elect to use one of the alternative installation methods
    of creating manifests via `istoctl` or Helm.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 Istio 有多种方法。目前最常见的方法是使用 `istioctl` 或 Helm，但根据你的组织需求，还可以选择其他选项。你可以选择通过 `istioctl`
    或 Helm 创建清单来使用替代的安装方法。
- en: 'A brief list of advantages and disadvantages for each method is detailed in
    *Table 16.1*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法的优缺点简要列在*表 16.1*中：
- en: '| **Deployment method** | **Advantages** | **Disadvantages** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **部署方法** | **优点** | **缺点** |'
- en: '| `istioctl` | Configuration validation and health checksDoes not require any
    privileged pods, increasing cluster securityMultiple configuration options | Each
    Istio version requires a new binary |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `istioctl` | 配置验证与健康检查不需要特权 Pod，增强了集群安全性多个配置选项 | 每个 Istio 版本都需要新的二进制文件 |'
- en: '| Istio operator | Configuration validation and healthDoes not require multiple
    binaries for each Istio versionMultiple configuration options | Requires a privileged
    pod running in the cluster |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| Istio 操作员 | 配置验证和健康检查不需要为每个 Istio 版本准备多个二进制文件多个配置选项 | 需要在集群中运行特权 Pod |'
- en: '| Manifests (via `istioctl`) | Generates manifests that can be customized before
    deploying using `kubectl`Multiple configuration options | Not all checks are performed,
    which could lead to deployment errorsError checks and reporting are limited when
    compared to using `istioctl` or the Istio operator |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| Manifests（通过 `istioctl`） | 生成可定制的清单，在使用 `kubectl` 部署前可以进行调整多个配置选项 | 并未执行所有检查，这可能导致部署错误与使用
    `istioctl` 或 Istio 操作员相比，错误检查和报告功能受限 |'
- en: '| Helm | Helm and charts are well known to most Kubernetes usersLeverages Helm
    standards, which allow for easy management of deployments | Offers the least validation
    checks of all deployment optionsMost tasks will require additional work and complexity
    versus the other deployment models |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Helm | Helm 和 Helm Charts 对大多数 Kubernetes 用户都很熟悉利用 Helm 标准，简化了部署管理 | 提供的验证检查是所有部署选项中最少的，执行大多数任务时需要额外工作和复杂度
    |'
- en: 'Table 16.1: Istio deployment methods'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.1：Istio 部署方法
- en: For this chapter, we will focus on using the `istioctl` binary for installation,
    and in the next section, we will deploy Istio using `istioctl`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍使用 `istioctl` 二进制文件进行安装，在接下来的章节中，我们将使用 `istioctl` 部署 Istio。
- en: Downloading Istio
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载 Istio
- en: We have included a script that will deploy Istio, output the verification of
    the installation, remove NGINX Ingress, and expose `istio-ingressgateway` as the
    Ingress to our KinD cluster. The manual process is provided below if you prefer
    to install it manually using `istioctl`. The script, `install-istio.sh`, is provided
    for readers who may use it in automation for their own testing and is located
    in the `chapter16` directory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个脚本来部署 Istio，输出安装验证，移除 NGINX Ingress，并将 `istio-ingressgateway` 暴露为我们 KinD
    集群的 Ingress。如果你更喜欢手动使用 `istioctl` 安装，也提供了手动过程。脚本 `install-istio.sh` 已经包括在内，供读者在自动化测试时使用，位于
    `chapter16` 目录中。
- en: 'The first thing that we need is to define the version of Istio we want to deploy.
    We can do this by setting an environment variable, and in our example, we want
    to deploy Istio 1.20.3\. First, make sure you are in the `chapter16` directory
    where you cloned the repo and execute the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是定义我们想要部署的 Istio 版本。我们可以通过设置环境变量来完成，在我们的示例中，我们希望部署 Istio 1.20.3。首先，确保你在克隆仓库后的
    `chapter16` 目录中，然后执行以下命令：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will download the installation script and execute it using the `ISTIO_VERSION`
    that we defined before executing the `curl` command. After executing, you will
    have an `istio-1.20.3` directory in your current working directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载安装脚本，并使用我们之前定义的 `ISTIO_VERSION` 执行该脚本。执行后，你的当前工作目录中会有一个 `istio-1.20.3` 目录。
- en: 'Finally, since we will be using executables from the `istio-1.12.3` directory,
    you should add it to your `path` statement. To make this easier, you should be
    in the `chapter16` directory from the book repository before setting the `path`
    variable:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们将使用 `istio-1.12.3` 目录中的可执行文件，因此应将其添加到 `path` 环境变量中。为了简化操作，建议在设置 `path`
    变量之前，先进入书本仓库中的 `chapter16` 目录：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing Istio using a profile
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置文件安装 Istio
- en: To make deploying Istio easier, the team has included a number of pre-defined
    profiles. Each profile defines which components are deployed and the default configuration.
    There are seven profiles included, but only five profiles are used for most deployments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Istio 的部署，团队包含了多个预定义的配置文件。每个配置文件定义了哪些组件被部署以及默认配置。共包含七个配置文件，但大多数部署只使用五个配置文件。
- en: '| **Profile** | **Installed Components** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **配置文件** | **已安装组件** |'
- en: '| Default | `istio-ingressgateway` and `istiod` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | `istio-ingressgateway` 和 `istiod` |'
- en: '| Demo | `istio-egressgateway`, `istio-ingressgateway`, and `istiod` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 演示 | `istio-egressgateway`、`istio-ingressgateway` 和 `istiod` |'
- en: '| Minimal | `istiod` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 精简 | `istiod` |'
- en: '| Preview | `istio-ingressgateway` and `istiod` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 预览 | `istio-ingressgateway` 和 `istiod` |'
- en: '| Ambient | `istiod`, CNI, and ZtunnelNote: In the 1.20.3 Istio release, ambient
    mesh is an alpha feature |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 环境 | `istiod`、CNI 和 Ztunnel 注：在 Istio 1.20.3 版本中，环境网格是一个 Alpha 特性 |'
- en: 'Table 16.2: Istio profiles'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.2：Istio 配置文件
- en: 'If none of the included profiles fit your deployment requirements, you can
    create a customized deployment. This is beyond the scope of this chapter since
    we will be using the included demo profile – however, you can read more about
    customizing the configuration on Istio’s site: [https://istio.io/latest/docs/setup/additional-setup/customize-installation/](https://istio.io/latest/docs/setup/additional-setup/customize-installation/).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何包含的配置文件适合你的部署需求，你可以创建一个定制的部署。由于我们将使用包含的演示配置文件，因此这超出了本章的范围——但是，你可以在 Istio
    的网站上阅读更多有关定制配置的信息：[https://istio.io/latest/docs/setup/additional-setup/customize-installation/](https://istio.io/latest/docs/setup/additional-setup/customize-installation/)。
- en: 'To deploy Istio using the demo profile using `istioctl`, we simply need to
    execute a single command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `istioctl` 部署使用演示配置文件的 Istio，我们只需执行一条命令：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The installer will ask you to verify that you want to deploy Istio using the
    default profile, which will deploy all of the Istio components:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序将询问你是否确认使用默认配置文件部署 Istio，该配置文件将部署所有 Istio 组件：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Press the *y* key to say yes to proceed with the deployment. If you want to
    bypass the confirmation, you can add an option to the `istioctl` command line,
    `--skip-confirmation`, which tells `istioctl` to bypass the confirmation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *y* 键表示同意继续部署。如果你想跳过确认，可以在 `istioctl` 命令行中添加一个选项 `--skip-confirmation`，该选项告诉
    `istioctl` 跳过确认。
- en: If everything went well, you should see a confirmation that each component was
    installed, and a completion message that thanks you for installing Istio.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到每个组件已安装的确认信息，并显示感谢你安装 Istio 的完成信息。
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `istioctl` executable can be used to verify the installation. To verify
    the installation, you require a manifest. Since we used `istioctl` to deploy Istio
    directly, we do not have a manifest, so we need to create one to check our installation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`istioctl` 可执行文件可用于验证安装。要验证安装，你需要一个清单。由于我们使用 `istioctl` 直接部署 Istio，因此没有清单，因此需要创建一个来检查我们的安装。'
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then run the `istioctl verify-install` command.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行 `istioctl verify-install` 命令。
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will verify each component, and once verified, it will provide a summary
    similar to the output below:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将验证每个组件，并在验证完成后，提供类似于下面输出的摘要：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have verified the installation, let’s look at what `istioctl` created:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了安装，让我们看看 `istioctl` 创建了什么：
- en: A new namespace called `istio-system`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `istio-system` 的新命名空间。
- en: 'Three deployments were created, and a corresponding service for each:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了三个部署，并为每个部署创建了相应的服务：
- en: '`istio-ingressgateway`'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istio-ingressgateway`'
- en: '`istio-egressgateway`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istio-egressgateway`'
- en: '`istiod`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istiod`'
- en: '15 **CustomResourceDefinitions** (**CRDs**) to provide the Istio resources,
    including:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15 个 **自定义资源定义** (**CRDs**) 用于提供 Istio 资源，包括：
- en: '`destinationrules.networking.istio.io`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destinationrules.networking.istio.io`'
- en: '`envoyfilters.networking.istio.io`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`envoyfilters.networking.istio.io`'
- en: '`gateways.networking.istio.io`'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gateways.networking.istio.io`'
- en: '`istiooperators.install.istio.io`'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istiooperators.install.istio.io`'
- en: '`peerauthentications.security.istio.io`'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peerauthentications.security.istio.io`'
- en: '`proxyconfigs.networking.istio.io`'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyconfigs.networking.istio.io`'
- en: '`requestauthentications.security.istio.io`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestauthentications.security.istio.io`'
- en: '`serviceentries.networking.istio.io`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serviceentries.networking.istio.io`'
- en: '`sidecars.networking.istio.io`'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sidecars.networking.istio.io`'
- en: '`telemetries.telemetry.istio.io`'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`telemetries.telemetry.istio.io`'
- en: '`virtualservices.networking.istio.io`'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualservices.networking.istio.io`'
- en: '`wasmplugins.extensions.istio.io`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wasmplugins.extensions.istio.io`'
- en: '`workloadentries.networking.istio.io`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workloadentries.networking.istio.io`'
- en: '`workloadgroups.networking.istio.io`'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workloadgroups.networking.istio.io`'
- en: At this stage, there’s no need to be concerned with the details of the Custom
    Resources (CRs). As we progress through this chapter, we’ll delve into the specifics
    of the most commonly used resources. Following that, in the next chapter, we’ll
    cover how to deploy an application into the mesh, which will make use of several
    of the CRs that have been deployed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，您无需关心自定义资源（CR）的细节。随着我们在本章中的进展，我们将深入探讨最常用资源的具体细节。接下来，在下一章中，我们将讲解如何将应用程序部署到网格中，这将涉及几个已部署的
    CR。
- en: 'For any CRs that are not covered in this chapter or the next chapter, you can
    reference the documentation on the istio.io site, located here: [istio.io/latest/docs](http://istio.io/latest/docs)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章或下一章中未涉及的任何 CR，您可以参考 istio.io 网站上的文档，地址如下：[istio.io/latest/docs](http://istio.io/latest/docs)
- en: Exposing Istio in a KinD cluster
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 KinD 集群中暴露 Istio
- en: With Istio deployed, our next step is to expose it to our network so we can
    access the applications we’ll build. Since we’re running on KinD, this can be
    tricky. Docker is forwarding all traffic from port `80` (HTTP) and `443` (HTTPS)
    on our KinD server to the worker node. The worker node is in turn running the
    NGINX Ingress controller on ports `443` and `80` to receive that traffic. In a
    real-world scenario, we’d use an external load balancer, like MetalLB, to expose
    the individual services via a LoadBalancer. For our labs though, we’re going to
    instead focus on simplicity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署 Istio 后，我们的下一步是将其暴露给我们的网络，以便我们可以访问我们将构建的应用程序。由于我们是在 KinD 上运行，这可能有些棘手。Docker
    会将所有来自端口`80`（HTTP）和`443`（HTTPS）的流量转发到我们的 KinD 服务器上的工作节点。工作节点则在端口`443`和`80`上运行
    NGINX Ingress 控制器来接收这些流量。在实际场景中，我们会使用外部负载均衡器，例如 MetalLB，通过 LoadBalancer 来暴露各个服务。然而，针对我们的实验环境，我们将重点关注简化操作。
- en: When you executed the previous script to install Istio, the last step ran a
    separate script called `expose_istio.sh` that does two things. First, it will
    delete the `ingress-nginx` namespace, removing NGINX and freeing up ports `80`
    and `443` on the Docker host. Second, it will patch the `istio-ingressgateway`
    Deployment in the `istio-system` namespace so that it runs on ports `80` and `443`
    on the worker node.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行先前的脚本来安装 Istio 时，最后一步运行了一个名为`expose_istio.sh`的独立脚本，做了两件事。首先，它会删除`ingress-nginx`命名空间，移除
    NGINX 并释放 Docker 主机上的端口`80`和`443`。其次，它会修补`istio-system`命名空间中的`istio-ingressgateway`部署，使其在工作节点上的端口`80`和`443`上运行。
- en: Since the script was executed as part of the installation, you do not need to
    execute it again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该脚本作为安装的一部分执行，因此您无需再次执行它。
- en: Now that we have Istio fully deployed in our cluster and we know the custom
    resources that Istio includes, let’s move on to the next section, which will explain
    each resource and its use-cases.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在集群中完全部署了 Istio，并了解了 Istio 包含的自定义资源，接下来我们将进入下一部分，解释每个资源及其用例。
- en: Introducing Istio resources
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Istio 资源
- en: Istio’s custom resources provide powerful features to your cluster and each
    one could take up a chapter by itself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 的自定义资源为您的集群提供了强大的功能，每个资源都可能成为一个章节的内容。
- en: In this section, we want to provide enough details so you will have a strong
    understanding of each object. After the object overview, we will deploy a basic
    application that will demonstrate many of the objects in a real-world application
    example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供足够的细节，以帮助您充分了解每个对象。概述过后，我们将部署一个基础应用程序，该应用程序将在真实的应用示例中演示许多对象。
- en: Authorization policies
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权策略
- en: Authorization policies are optional; however, if you do not create any, all
    requests to resources will be allowed access to your cluster workloads. This may
    be the desired default action for some organizations, but most enterprises should
    deploy workloads based on the least required privileges. This means that you should
    only allow what access is required for accessing the application – nothing more
    and nothing less. Least privilege access is often overlooked by organizations
    since it adds some complexity to access and if not configured correctly, it may
    deny access to valid requests. While this is true, it is not a valid argument
    to leave your systems wide open to all access requests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 授权策略是可选的；然而，如果您没有创建任何策略，所有请求都将允许访问您的集群工作负载。这可能是一些组织期望的默认行为，但大多数企业应该根据最小所需权限来部署工作负载。这意味着您应仅允许访问应用程序所需的权限——没有更多，也没有更少。最小权限访问常常被组织忽视，因为它增加了访问的复杂性，如果配置不当，可能会拒绝有效请求的访问。虽然这种情况确实存在，但这并不是让系统对所有访问请求敞开大门的合理理由。
- en: Istio’s authorization policies offer detailed access management for services
    within your mesh, allowing you to define access rights based on the identities
    of the callers and their permissions. They provide developers with the ability
    to control access to workloads based on actions including deny, allow, and custom.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Before explaining policies in more depth, we need to start with a concept called
    **implicit enablement**. This means that when **any** authorization policy matches
    a request, Istio will change the default allow all to a deny for any request that
    doesn’t have a match in the policy.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use an example to explain this in more detail. We have an NGINX server
    running in a namespace where Istio has been enabled and we have a standard that
    access to port `80` must be denied.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: At a quick glance, this looks like it should be an easy policy, we would simply
    create a deny policy that contains port `80`. So, we create the policy and deploy
    it to our cluster – and to verify the policy, we try to access the website on
    port `80`. We open a browser and, as expected, we cannot access the site. Great!
    Now let’s verify that we can access the site on port `443`. We change the URL
    to access the site using port `443`, and to our surprise, it is also *denied*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Wait, what!?!? The deny policy only denies port `80` – why is port `443` also
    being denied?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This is **implicit enablement** in action and it can be confusing at first for
    anyone who is new to Istio. As discussed at the beginning of this section, when
    a policy is created and a request matches that policy, Istio will change from
    an *allow all* security posture, to a *deny all* security posture. Even though
    we intended to deny access to only port `80`, without an allow policy for port
    `443`, access will also be denied.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: To complete the requirement, and allow access to our NGINX site on port `443`,
    we would need to create an allow policy that allows all incoming traffic to port
    `443`. We will explain this in more depth in a minute.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how a policy’s actions are evaluated is very important, since
    a misconfigured policy may not provide the expected results. The high-level flow
    for policy evaluation is shown in *Figure 16.1*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_01.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Istio policy evaluation flow'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: If the evaluation of a **CUSTOM** action defines a **DENY** to the request,
    the access is denied, and the evaluation process stops.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, if a **DENY** policy matches the request, the request is denied access
    to the resource, and the evaluation process stops.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no **ALLOW** policies that match the request, access will be denied
    to the request.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an **ALLOW** policy matches the request, access to the resource is granted.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Along with understanding the flow of policies, you need to understand how conflicting
    policies will be implemented. If a policy has any conflicting rules, like denying
    and allowing the same request, the deny policy will be evaluated first and the
    request will be denied since the deny policy is evaluated before the allow policy.
    It’s also very important to note that if you allow a certain action, like an HTTP
    GET, the GET request would be allowed, but any other operation would be denied
    since it has not been allowed by the policy.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Authorization policies can get very complex. The Istio team has created a page
    with multiple examples on the Istio site at [https://istio.io/latest/docs/reference/config/security/authorization-policy/](https://istio.io/latest/docs/reference/config/security/authorization-policy/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Policies can be broken down into scope, action, and rules:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope**: The scope defines what object(s) will be enforced by the policy.
    You can scope a policy to the entire mesh, a namespace, or any Kubernetes object
    label like a pod.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: There can be one of three actions defined, CUSTOM, ALLOW, or DENIED
    – each either denying or allowing a request based on the defined rules. ALLOW
    and DENY are the most commonly used actions, but CUSTOM actions are beneficial
    when you require complex logic that ALLOW or DENY cannot handle, using an external
    system for additional decision making.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rules**: Define what actions will be allowed or denied by the request. Rules
    can become very complex, allowing you to define actions based on source and destination,
    different operations, keys, and more.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help understand the flow, let’s look at a few example authorization policies
    and what access will be applied when the policy is evaluated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We will deploy a larger application later in the chapter. If you want to see
    how the example policies work in this section, you can deploy an NGINX web server
    using the script in the `chapter16/testapp` directory called `deploy-testapp.sh`.
    This will create all of the required Kubernetes and Istio objects to test the
    policies in a real cluster.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Once you have executed the script and the objects have been created, test that
    NGINX is working by curling to the `nip.io` VirtualService that was created. On
    our server, it created `testapp.10.3.1.248.nip.io`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should display the NGINX welcome page. Now, we can create some example
    policies to show how authorization policies work. Each of the three examples is
    in the `chapter16/testapp` directory named `exampleX-policy.yaml`, where `X` is
    equal to `1`, `2`, or `3` – each can be deployed using the `kubectl apply <policyname>
    -n testapp` command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Denying and allowing all access'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our first example, we will create a policy that will deny all requests
    to the resources in the namespace `testapp`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After deploying the policy, attempt to `curl` to the `nip.io` address again.
    You will notice that this time, you will be denied access and Istio will return
    an RBAC error:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can take a few seconds for Istio to enable new policies. If you did not
    receive the `RBAC: access denied` error, wait a few seconds and try again.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simple policy that does not include a `selector` and defines
    nothing in the `spec` section. By omitting the `selector` section, Istio will
    apply the policy to all workloads in the namespace, and by not including anything
    in the `spec` section, Istio will deny all traffic. If we refer back to the policy
    flow diagram in *Figure 16.1*, this would flow down the bottom and evaluate as
    circle #3 – there is a `selector` match, which is *all* workloads in the namespace,
    and there hasn’t been an ALLOW policy defined. This will lead to the request being
    denied.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We won’t deploy the next example; we are showing it to reinforce the example
    provided above. By adding a single entry to the policy, we can change it from
    denying all requests to allowing all requests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we add the `rules` section to the policy definition, with a {}, we are
    creating a rule that means all traffic. Similar to the previous example, we have
    not added a `selector`, which means the policy will apply to all deployments in
    the namespace. Since this rule is for all workloads and the rule includes all
    traffic, access would be allowed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: You might be starting to see why we mentioned how not understanding how policies
    are evaluated in the flow may lead to unexpected access results. This is a prime
    example of how a single entry, `rules`, changes the policy from denying all requests
    to allowing all requests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, delete the policy by executing:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Example 2: Allowing only GET methods to a workload'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Policies can get very granular, allowing only certain operations like GET from
    an HTTP request. This example will allow GET requests while denying all other
    request types for pods that are labeled with `app=nginx-web` in the `marketing`
    namespace. For this example, we will use the same NGINX deployment from the first
    example. Create the policy using the manifest in the `chapter16/testapp` directory
    called `exampe2-policy.yaml` using `kubectl`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you attempt to `curl` to the same `nip.io` address as we used in example
    1, you will see the NGINX welcome page. This is using an HTTP GET command. To
    prove that HTTP PUT commands will be blocked, we can use a `curl` command to send
    a request to NGINX:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will cause Istio to deny the request with an RBAC error:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the example, the policy accepts the GET request from any source, since we
    have only defined an action without a specific `from` object. Since we have not
    added the PUT action in our policy, any attempt to send an HTTP PUT request will
    be denied by the policy.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Policies can get even more granular, accepting (or denying) a request based
    on the source of the request. In the next example, we will show another example
    of a policy but we will limit the source to a single IP address.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, delete the example policy using `kubectl`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Example 3: Allowing requests from a specific source'
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例3：允许来自特定来源的请求
- en: In our last policy example, we will limit what source will be allowed access
    to a workload using a GET or POST method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后的策略示例中，我们将限制哪些来源可以使用GET或POST方法访问工作负载。
- en: This will increase security by denying any request from a source that is not
    in the policy source list. We will not create this policy since many readers may
    be limited in the number of machines they have to use for testing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拒绝任何来自不在策略源列表中的来源的请求，这将增强安全性。我们不会创建这个策略，因为许多读者可能在测试时受限于可用的机器数量。
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unlike the previous examples, this policy has a `source:` section, which allows
    you to limit access based on different sources, like an IP address. This policy
    will allow the source IP `192.168.10.100` access to all operations on the NGINX
    server, and all other sources will be denied access.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例不同，这个策略包含一个`source:`部分，允许你根据不同的来源（如IP地址）限制访问。这个策略将允许源IP `192.168.10.100`访问NGINX服务器上的所有操作，其他所有来源的访问将被拒绝。
- en: Moving on from authorization policies, we will introduce our next custom resource,
    destination gateways.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从授权策略转向，我们将介绍下一个自定义资源——目标网关。
- en: Gateways
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网关
- en: Earlier, we mentioned that traffic will come into a central point, `istio-ingressgateway`.
    We didn’t explain how the traffic flows from the `ingressgateway` to a namespace
    and workloads – this is where gateways come in.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到过流量将进入一个中央点`istio-ingressgateway`。我们没有解释流量如何从`ingressgateway`流向命名空间和工作负载——这就是网关的作用。
- en: A gateway can be configured at the namespace, so you can delegate the creation
    and configuration to a team. It is a load balancer that receives incoming and
    outgoing traffic that can be customized with options like accepted ciphers, TLS
    versions, certificate handling, and more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 网关可以在命名空间级别进行配置，因此你可以将创建和配置的任务委托给一个团队。它是一个负载均衡器，接收传入和传出的流量，可以通过诸如接受的加密套件、TLS版本、证书处理等选项进行自定义。
- en: Gateways work along with Virtual Services, which we will discuss in the next
    section, but until then, the following figure shows the interaction between the
    `Gateway` and `VirtualService` objects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 网关与虚拟服务一起工作，我们将在下一节中讨论虚拟服务，但在此之前，以下图示展示了`Gateway`和`VirtualService`对象之间的交互。
- en: '![](img/B21165_16_02.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_02.png)'
- en: 'Figure 16.2: Gateway to Virtual Service communication flow'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：网关到虚拟服务的通信流
- en: 'The list below explains the communication shown in *Figure 16.2* in more detail:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表更详细地解释了*图16.2*中所示的通信：
- en: An incoming request is sent to the Istio `ingress-gateway` controller, located
    in the `istio-system` namespace.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个传入请求被发送到Istio的`ingress-gateway`控制器，该控制器位于`istio-system`命名空间中。
- en: The `sales` namespace has a gateway configured that is set to use the `ingressgateway`
    with a host of `entry.foowidgets.com`. This tells the `ingressgateway` to send
    the request to the gateway object in the `sales` namespace.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sales`命名空间有一个配置了`ingressgateway`的网关，主机名为`entry.foowidgets.com`。这告诉`ingressgateway`将请求发送到`sales`命名空间中的网关对象。'
- en: Finally, the traffic is routed to the service using a Virtual Service object
    that has been created using the gateway in the `sales` namespace.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，流量通过一个已使用网关在`sales`命名空间中创建的虚拟服务对象路由到服务。
- en: To show an example `Gateway` configuration, we have a namespace called `sales`
    that has Istio enabled, running an application that can be accessed using the
    URL `entry.foowidgets.com`, and we need to expose it for external access. To accomplish
    this, we would create a gateway using the example manifest below. (The example
    below is just for discussion; you do not need to deploy it on your KinD cluster.)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示一个`Gateway`配置示例，我们有一个启用了Istio的名为`sales`的命名空间，运行着一个可以通过URL`entry.foowidgets.com`访问的应用程序，我们需要将其暴露以供外部访问。为此，我们将创建一个网关，使用以下示例清单。（下面的示例仅供讨论；你不需要在你的KinD集群上部署它。）
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This gateway configuration will tell the ingress gateway to listen on port `443`
    for requests that are incoming for `sales.foowidgets.com`. It also defines the
    certificates that will be used to secure the communication for incoming web requests.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网关配置将告诉入口网关在端口`443`上监听来自`sales.foowidgets.com`的传入请求。它还定义了将用于保护传入Web请求的通信的证书。
- en: You may be wondering, “How does it know to use the ingress gateway that we have
    running in our cluster?” If you look at the `spec` section, and then the selector,
    we have configured the `selector` to use an ingress gateway that has the label
    `istio=ingressgateway`. This `selector` and label tell the gateway object which
    ingress gateway will create our new gateway for incoming connections. When we
    deployed Istio earlier, the ingress gateways were labeled with the default label
    `istio=ingressgateway`, as shown highlighted below, from a `kubectl get pods --show-labels
    -n istio-system`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may be wondering how the gateway will be used to direct traffic to a particular
    workload since there are no configuration options in the gateway telling it where
    to direct traffic. That’s because the gateway just configures the ingress gateways
    to accept traffic for a destination URL and the required ports – it does not control
    how the traffic will flow to a service; that’s the job of the next object, the
    `Virtual Service` object.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Virtual services
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gateways and virtual services combine to provide the correct traffic route to
    a service, or services. Once you have a gateway deployed, you need to create a
    virtual service object to tell the gateway how to route traffic to your service(s).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Building on the gateway example, we need to tell the gateway how to route traffic
    to our web server running on port `443`. The server has been deployed using NGINX
    in the `marketing` namespace and it has a label of `app-nginx` and a service named
    `frontend`. To route traffic to the NGINX service, we would deploy the manifest
    below. (The example below is just for discussion; you do not need to deploy it
    on your KinD cluster.)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Breaking down the manifest, we specify the host(s) that this `VirtualService`
    object will route; in our example, we only have one host, `entry.foowidgets.com`.
    The next field defines which gateway will be used for the traffic; in the previous
    section, we defined a gateway called `marketing-gateway`, which was configured
    to listen on port `443`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last section defines which service the traffic will be routed
    to. The route, destination, and port are all fairly straightforward to understand,
    but the `host` section can be misleading. This field actually defines the service
    that you will route the traffic to. In the example, we are going to route the
    traffic to a service called `entry`, so our field is defined with `host: entry`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge of using gateways and virtual services to route traffic
    in the Service mesh, we can move on to the next topic, destination rules.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Destination rules
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtual services provide a basic method to direct traffic to a service, but
    Istio offers an additional object to create complex traffic direction by using
    `Destination` rules. `Destination` rules are applied after Virtual Services. Traffic
    is initially routed using a Virtual Service and, if defined, a `Destination` rule
    can be used to route the request to its final destination.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: This may be confusing at first, but it becomes easier when you see an example,
    so let’s dive into an example that can route traffic to different versions of
    a deployment.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: As we learned, incoming requests will use the Virtual Service initially, and
    then a destination rule, if defined, will route the request to the destination.
    In this example, we have already created a Virtual Service but we actually have
    two versions of the application labeled `v1` and `v2` and we want to direct traffic
    between both versions of the application using round-robin. To accomplish this,
    we would create a `DestinationRule` using the manifest below. (The example below
    is just for discussion; you do not need to deploy it on your KinD cluster.)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using this example, incoming requests to the NGINX server will be split between
    the two versions of the application equally since we defined the `loadBalancer`
    policy as `ROUND_ROBIN`. But what if we wanted to route traffic to the version
    that had the least number of connections? Destination rules have other options
    for `loadBalancer`, and to route connections to the version with the least connections,
    we would set the `LEAST_CONN` `loadBalancer` policy.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss some of the security features Istio provides, starting
    with an object called Peer Authentication.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Peer authentication
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Istio’s peer authentication object controls how the Service mesh controls the
    mutual TLS settings for workloads, either for the entire Service mesh or just
    a namespace. Each policy can be configured with a value that will either allow
    both encrypted communication and non-encrypted communication between pods or require
    encryption between pods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '| **mTLS mode** | **Pod communication** | **Description** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| `STRICT` | mTLS required | Any non-encrypted traffic sent to a pod will be
    denied |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| `PERMISSIVE` | mTLS optional | Both encrypted and non-encrypted traffic will
    be accepted by the pod |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: 'Table 16.3: PeerAuthentication options'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to set `PeerAuthentication` for the entire mesh, you would create
    a `PeerAuthentication` in the `istio-system` namespace. For example, to require
    mTLS between all pods, you would create the policy shown below:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To allow both encrypted and non-encrypted traffic, the policy mode just needs
    to be set to `PERMISSIVE`, by changing the mode to `mode: PERMISSIVE`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Rather than setting the mode for the entire mesh, many enterprises only set
    the mode to `STRICT` for namespaces that require additional security. In the example
    below, we set the mode to `STRICT` for the `sales` namespace.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since this policy is configured for the `sales` namespace, rather than the `istio-system`
    namespace, Istio will only enforce a strict mTLS policy for the namespace rather
    than the entire Service mesh.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: This is a great security feature provided by the mesh, but encryption won’t
    stop a request from hitting our workload; it simply encrypts it. The next object
    we will discuss will add a level of security to a workload by requiring authentication
    before being allowed access.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Request authentication and authorization policies
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security requires two pieces. First, the authentication piece, which is “who
    you are.” The second piece is authorization, which is the actions that are allowed
    once authentication has been provided, or “what you can do.”
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestAuthentication` objects are only one part required to secure a workload.
    To fully secure the workload, you need to create the `RequestAuthentication` object
    and an `AuthorizationPolicy`. The `RequestAuthentication` policy will determine
    what identities are allowed access to the workload, and the `AuthorizationPolicy`
    will determine what permissions are allowed.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: A `RequestAuthorization` policy without an `AuthorizationPolicy` can lead to
    unintentionally allowing access to the resource. If you only create a `RequestAuthorization`
    policy, the access in *Table 16.4* shows who would be allowed access.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '| **Token action** | **Access provided** |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| Invalid token provided | Access will be denied |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| No token provided | Access will be granted |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| Valid token provided | Access will be granted |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: 'Table 16.4: RequestAuthentication access'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, once we create a policy, any invalid JWT will be denied access
    to the workload, and any valid token will be allowed access to the workload. However,
    when no token is provided, many people think that access would be denied, but
    in reality, access would be allowed. A `RequestAuthentication` policy only verifies
    the tokens, and if no token is present, the `RequestAuthentication` rule will
    not deny the request.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: An example manifest is shown below. We will use this manifest in the examples
    section of the chapter, but we wanted to show it in this section to explain the
    fields.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This manifest will create a policy that configures a workload with the label
    `matching app=frontend` in the `demo` namespace to accept JWTs from the issuer
    `testing@secure.istio.io` with a URL to confirm the tokens at [https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json](https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL contains the key used to validate the tokens:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When a token is presented, it will be verified that it came from the issuer
    defined in the `jwtRules` section of the `RequestAuthenctication` object.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through an example of how token authentication works in depth in
    the next chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Service entries
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a workload is part of a Service mesh, its sidecar proxy will handle all
    outbound communication to services within the mesh. If the workload attempts to
    communicate with an external service that is not part of the mesh, this communication
    may fail if not properly configured. Fortunately, Istio provides mechanisms to
    define and manage external services, allowing workloads to communicate with services
    outside the mesh. One such mechanism is the `ServiceEntry` object, which allows
    you to define services that are external to the mesh and configure how these services
    should be accessed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: If you have a requirement for a workload in your Service mesh to communicate
    with a service outside of the Service mesh, you need to create an entry in the
    mesh for the external resource. This can be done in two ways, and the first method
    leads us to our next custom resource, the `ServiceEntry` object, which allows
    you to add external entries to the Service mesh. When you create a `ServiceEntry`
    for an external service, it will appear as if it was part of the actual Service
    mesh. This allows traffic to be routed to manually specified services from inside
    the Service mesh. Without a `ServiceEntry`, any attempt to communicate with the
    external resource would fail since Istio would attempt to look up the service
    in the Service mesh entries and it would fail to find the resource (since it is
    not part of the mesh).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: To create a `ServiceEntry`, you need to create a new object that contains the
    hosts and ports for the external service. The example below will create a new
    entry that adds the host `api.foowidgets.com` on port `80`, using HTTP, to the
    Service mesh.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ServiceEntries are a great resource to explicitly add external resources to
    a Service mesh. We mentioned that there are two ways to add external resources
    to the Service mesh, Service entries being one – and the other being the `Sidecars`
    object. The choice of which object to use is very specific to your own use-cases
    and organizational standards. Service entries are very specific and you must create
    an entry for each external resource you need to communicate with. Sidecars are
    different, and instead of defining what is external to the Service mesh, you define
    what is in the Service mesh.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Sidecars
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we know this can be confusing – this object is not the sidecar itself;
    it is an object that allows you to define what items your sidecar considers to
    be “in the mesh.” Depending on the size of your cluster, you may have thousands
    of services in the mesh and if you do not create a sidecar object, your Envoy
    sidecar will assume that your service needs to communicate with every other service.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you may only need your namespace to communicate with services in
    the same namespace or a small number of other namespaces. Since tracking every
    service in the mesh requires resources, it’s considered good practice to create
    a sidecar object to reduce the required memory in each Envoy sidecar.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a sidecar object that limits the services in your Envoy proxy, you
    would deploy the manifest shown below:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `spec` in this manifest contains a list of hosts for the mesh, the `./*`
    references the namespace where the object was created, and all sidecars should
    contain the namespace where Istio was deployed, which would be `istio-system`,
    by default.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had three namespaces that needed to communicate across the mesh, we would
    simply need to add the additional namespaces to the hosts’ entries:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Failing to limit the mesh objects may result in your Envoy sidecar crashloops
    due to resources. You may experience an **out of memory** (**OOM**) event, or
    simply crashloops that do not show any details of the root cause. If you experience
    these scenarios, deploying a sidecar object may resolve the issue.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Envoy filters
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Envoy filters provide you with the ability to create custom configurations that
    are generated by Istio. Remember that Pilot (part of istiod) is responsible for
    sidecar management. When any configuration is sent to Istio, Pilot will convert
    the configuration for Envoy to utilize. Since you are “limited” by the options
    in the Istio custom resource, you may not have all of the potential configuration
    options that are required for a workload, and that’s where Envoy filters come
    in.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Filters are very powerful, and potentially dangerous, configuration objects.
    They allow you to customize values that you cannot customize from a standard Istio
    object, allowing you to add filters, listeners, fields, and more. This brings
    a quote used in Spider-Man from the late Stan Lee to mind, “With great power comes
    great responsibility.” Envoy filters provide you with extended configuration options,
    but if a filter is misused, it could bring down the entire Service mesh.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Envoy filters are complex and, for the purposes of this book, are not a topic
    that needs deep understanding to understand Istio in general. You can read more
    about Envoy filters on the Istio site at [https://istio.io/latest/docs/reference/config/networking/envoy-filter/](https://istio.io/latest/docs/reference/config/networking/envoy-filter/).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: WASM plugins
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to Envoy filters, the `WasmPlugins` object is used to extend the capabilities
    of the Envoy sidecar. While they are similar in what they provide, they each provide
    different degrees of customization.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Typically, `WasmPlugins` are regarded as more straightforward to develop and
    implement, making them less complex and dangerous compared to Envoy filters. This
    simplicity, however, comes at the cost of reduced functionality relative to what
    Envoy filters can offer.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Envoy filters provide detailed, fine-grained control over the proxy settings,
    enabling the creation of more sophisticated operations than is possible with `WasmPlugins`.
    This level of control contributes to their complexity and the potential risk they
    pose if improperly configured or used, which could lead to disruptions within
    your Service mesh.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The choice between `EnvoyFilters` and `WasmPlugins` ultimately depends on your
    specific needs and preferences. It’s important to consider various factors when
    deciding which option to adopt, weighing the trade-offs between ease of use, functionality,
    and the potential impact on your Service mesh.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Deploying add-on components to provide observability
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you know how to deploy Istio and understand some of the most used objects,
    but you haven’t seen one of the most useful features yet – observability. At the
    beginning of the chapter, we mentioned that observability is one of our favorite
    features provided by Istio, and in this chapter, we will explain how to deploy
    a popular Istio add-on called Kiali.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Installing Istio add-ons
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you deploy Istio, you provide a Service mesh and all of the features to
    your developers. While this is powerful by itself, you need to add a few extra
    components to truly provide a complete solution. There are four add-ons that you
    should add to your Service mesh – while there are alternatives to some of the
    solutions, we are using the most commonly used add-ons, specifically:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grafana
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jaeger
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kiali (which we will cover in the next section)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have discussed Prometheus and Grafana in previous chapters, but Jaeger is
    a new component that we have not mentioned before.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Jaeger is an open-source offering that provides tracing between services in
    Istio. Tracing may be a new term to some readers. At a high level, traces are
    a representation of the execution path to a service. These allow us to view the
    actual path of the communication between services, providing an easy-to-understand
    view that provides metrics about performance and latency, allowing you to resolve
    issues quickly.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: To deploy all of the add-ons, we have included a script to deploy Prometheus
    in the `chapter16/add-ons` directory, called `deploy-add-ons.sh`. Execute the
    script to deploy the add-ons in your cluster.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Many add-on example deployments do not maintain state, so for our deployment
    we have added persistency, leveraging the provisioner built into KinD, by adding
    persistent disks to each deployment.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The script executes the steps outlined below:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Deploys each add-on using standard Kubernetes manifests in the `istio-system`
    namespace.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each deployment creates a PVC and mounts it as the data location to maintain
    persistency across reboots.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finds your host’s IP address to create new Gateway and VirtualService entries
    for each add-on.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a shared Istio Gateway that will be used by each of the add-ons.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creates VirtualServices that contain your `nip.io` URLs. The three URLs that
    will be created are:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`prom.<Host IP>.nip.io`'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`grafana.<Host IP>.nip.io`'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kiali.<Host IP>.nip`.`io`'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The final output from the script will contain the URLs that were created for
    you.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: With the add-ons deployed, we can move on to the next section, which will cover
    the main tool for observability, Kiali.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kiali
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kiali provides a powerful management console for our Service mesh. It provides
    graphical views of our services, pods, traffic security, and more. Since it’s
    a very useful tool for both developers and operators, the remainder of this chapter
    will focus on deploying and using Kiali.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: There are a few options to deploy Kiali, but we will use the most common installation
    method, using a Helm chart. To deploy the chart and create the required objects
    to access the Kiali UI, we have provided a script in the `chapter16/kiali` directory
    called `deploy-kiali.sh`. Execute the script to deploy Kiali.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The script will deploy Kiali into your cluster, in the `istio-system` namespace,
    pre-configured to integrate with the add-ons we deployed in the previous section.
    It will also expose Kiali’s UI using a `nip.io` URL, which will be provided at
    the end of the script execution.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: This deploys an anonymous access dashboard; however, Kiali can accept other
    authentication mechanisms to secure the dashboard. In the next chapter, we will
    modify the Kiali deployment to accept JWTs, using OpenUnison as the provider.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application into the Service mesh
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could define the components and objects of Istio all day, but if you are
    like us, you will find examples and use-cases more beneficial to understanding
    advanced concepts like the features provided by Istio. In this section, we will
    explain many of the custom resources in detail, providing examples that you can
    deploy in your KinD cluster.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your first application into the mesh
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally! We have Istio and the add-on components installed and we can move on
    to installing a real application in the Service mesh to verify everything is working.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we will deploy an example application from Google called the
    Boutique app. In the next chapter, we will deploy a different application and
    explain all of the details and communication between the services, but the Boutique
    app is a great application to test out the mesh before we get into that level
    of information.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chaper16/example-app` directory, there is an installation script called
    `deploy-example.sh` that will deploy the application to the cluster. It will install
    the base application and the required Istio objects to make the application accessible
    to the outside world. The script execution is detailed below:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: A new namespace named `demo` is created with a label containing `istio-injection=enabled`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `kubernetes-objects.yaml` manifest, the base application will be deployed.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Istio objects will be created using templates to create the names in the
    `nip.io` domain for easy access to the application. The objects created in Istio
    include the `Gateway` and `VirtualService` objects.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The created `nip.io` domain will be output to the screen. On our server, it
    was `kiali.10.3.1.248.nip.io`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once executed, you will have a working demo application in the `demo` namespace.
    We will use this application to demonstrate the observability features of Istio
    and Kiali.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Quickly verify that the application and Istio objects have been deployed correctly
    by the script by using a browser to open the `nip.io` URL. You should see the
    Kiali home screen, which we will discuss in the next section.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Using Kiali to observe mesh workloads
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kiali provides observability in your Service mesh. It provides a number of advantages
    to you and your developers, including a visual map of the traffic flow between
    objects, verifying mTLS between the services, logs, and detailed metrics.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The Kiali overview screen
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you navigate to the homepage of Kiali, by using the URL provided when you
    executed the `create-ingress` script, this will open the Kiali overview page where
    you will see a list of namespaces in the cluster.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_03.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: The Kiali homepage'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Kiali will show all namespaces in the cluster, even if they do not have Istio
    enabled. In our current deployment, it will show all namespaces, regardless of
    any RBAC that has been implemented since it’s running without any authentication.
    As mentioned in the *Installing Kiali* section, we will secure Kiali with JWTs
    in the next chapter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Using the Graph view
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first part of the dashboard that we will visit is the **Graph** view, which
    provides a graphical view of our application. Initially, it may look like a simple
    static graphical representation of the objects that make up the workload, but
    this is simply the default view when you open the **Graph** view; it isn’t limited
    to a simple static view, as you will see in this section.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we deployed the example application into the `demo` namespace, scroll
    down a bit and look for the block that contains the `demo` namespace, click the
    three dots on the tile, and then select **Graph**:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_04.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Using Kiali to show a graph of a namespace'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take you to a new dashboard view that shows the demo application
    objects:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_05.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Kiali graph example'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of objects on the graph, and if you are new to Kiali, you may
    be wondering what each of the icons represents. Kiali provides a legend to help
    you identify what role each icon plays.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the icon in the lower left-hand section of the **graph** pane,
    you will see the legend icon. Click it to see an explanation of each icon – an
    abbreviated legend list is shown below:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_06.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Kiali graph legend example'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: By default, this view only shows the paths between the application objects in
    a static view. However, you are not limited only to the static view – this is
    where Kiali starts to shine. We can actually enable a live traffic view, enabling
    us to watch the traffic flow for all requests.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: To enable this option, click the **Display** option that is just above the Graph
    view, and in the list of options, enable traffic animation by checking the box,
    as shown in *Figure 16.7*.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_07.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Enabling traffic animation'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: It’s difficult to display in a static image, but once you have enabled the **Traffic
    Animation** option, you will see the flow of all requests in real time.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited to only traffic flow animations; you can use the **Display**
    option to enable a number of other options in the **Graph** view, including items
    like response time, throughput, traffic rate, and security.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 16.8*, we have enabled throughput, traffic distribution, traffic
    rate, and security:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_08.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Kiali graph display options'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the image, the lines between objects now include additional
    information, including:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: A lock, which confirms that the communication is encrypted via the sidecar and
    mTLS
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RPS, which is the requests per second
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the Kiali **Graph** view is a powerful tool for observing the
    end-to-end communication for your workload. This is just one of the additional
    benefits of using a Service mesh. The observability that a mesh provides is an
    incredibly valuable tool for finding issues that would have been very difficult
    to uncover in the past.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: We are not limited to only the **Graph** view; we also have three additional
    views that offer additional insight into the application. On the left-hand side
    of the Kiali dashboard, you will see the other three views, **Applications**,
    **Workloads**, and **Services**. You will also notice that there is one other
    option, **Istio Config**, which allows you to view the objects in the namespace
    that control the Istio features for the namespace.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Using the Applications view
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Applications view shows you the details for the workloads that have the
    same labeling, allowing you to break down the view into smaller sections.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Using the Boutique Applications view that we have opened in Kiali, click on
    the **Applications** link in the left-hand options. This will take you to the
    overview page for the applications, broken down by labels.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_09.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Kiali Applications view'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Each of the applications can provide additional information by clicking the
    name of the service. If we were to click the **adservice** application, Kiali
    would open a page providing an overview of what the **adservice** application
    interacts with. For each application, you can also look at the overview, traffic,
    inbound and outbound metrics, and traces.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: The overview page presents you with a dedicated view of the objects that communicate
    with **adservice**. We saw a similar communications view in the **Graph** view,
    but we also saw every other object – including objects that have nothing to do
    with **adservice**.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: The Applications view will streamline what we can see, making it easier to navigate
    the application.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_10.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Simplified communication view using the Applications view'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Applications view contains the components from the Graph
    view. The communications path that involves **adservice** starts with the frontend
    pod, which targets the **adservice** service, which ultimately routes the traffic
    to the **adservice** pod.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: We can see additional details in the application by clicking on one of the tabs
    at the top of the **Applications** view. The first tab next to the overview is
    the **Traffic** tab, which provides you with a view of the traffic for the application.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_11.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Viewing application traffic'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: The **Traffic** tab will show inbound and outbound traffic to the application.
    In the **adservice** example from the Boutique store, we can see that **adservice**
    has received inbound requests from the frontend. Below the inbound traffic, we
    can see the outbound traffic and, in our example, Kiali is telling us that there
    is no outbound traffic. As we can see in the overview in *Figure 16.10*, the **adservice**
    pod does not have any object that it connects to; therefore, we would not have
    any traffic to view. To get additional details on the traffic, you can click on
    the **View Metrics** link under **Actions** – this action is the same as if you
    were to click the **Inbound Metrics** tab.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The **Inbound Metrics** tab will provide you with additional details about the
    incoming traffic. *Figure 16.12* shows an abbreviated example for the **adservice**
    traffic.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_12.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Viewing inbound metrics'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The inbound metrics will display a number of different metrics, including request
    volume, request duration, request and response size, request and response throughput,
    gRPC received and sent, TCP opened and closed, and TCP received and sent. This
    page will update in real time, allowing you to view the metrics as they are captured.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last tab will allow you to look at the traces for the **adservice**
    application. This is why we deployed Jaeger in our cluster when we installed Istio.
    Tracing is a fairly complex topic and is outside the scope of this chapter. To
    learn more about tracing using Jaeger, head over to the Jaeger site at [https://www.jaegertracing.io/](https://www.jaegertracing.io/).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Using the Workloads view
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next view we will discuss is the **Workloads** view, which breaks down the
    views to the workload type, like deployments. If you click on the **Workloads**
    link in Kiali, you will be taken to a breakdown of the Boutique workloads.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_13.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: The Workloads view'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that there is a warning under the **Details** column that tells
    us we are missing a version of the deployments. This is one of the features of
    this view. It will offer details like a workload not being assigned a version,
    which is not an issue for standard functionality in the mesh, but it will limit
    the use of certain features, like routing and some telemetry. It’s a best practice
    to always version your application, but for the example, Boutique from Google,
    they do not include a version in the deployments.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The **Workloads** view offers some of the same details as the **Applications**
    view, including traffic, inbound metrics, outbound metrics, and tracing – however,
    in addition to these details, we can now view the logs and details about Envoy.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the **Logs** tab, you will see the logs for the **adservice**
    container.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_14.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.14: Viewing the container logs'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: This is a real-time view of the logs that are being generated by the **adservice**
    container. In this view, you can create a filter to show or hide certain keywords,
    scroll back to previous events, change the default buffer size from 100 lines,
    copy the logs to your clipboard, or enter a fullscreen log view. Many users find
    this tab very useful since it doesn’t require them to use `kubectl` to look at
    the logs; they can simply open up Kiali in a browser and quickly view the logs
    in the GUI.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The last tab we will discuss is the **Envoy** tab, which provides additional
    details about the Envoy sidecar. The details in this tab are extensive – it contains
    all of the mesh objects that you have included in the namespace (recall that we
    created a sidecar object to limit the objects to only the namespace and the `istio-system`
    namespace), all of the listeners, routes, the bootstrap configuration, config,
    and metrics.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: By this point in the chapter, you can probably see how Istio would require its
    own book to cover all of the base components. All of the tabs in the **Envoy**
    tab provide a wealth of information, but it gets very detailed and we can’t fit
    them all in this chapter, so for the purposes of this chapter, we will only discuss
    the **Metrics** tab.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the **Metrics** tab, you will see metrics pertaining to the uptime
    of Envoy, the allocated memory, heap size, active upstream connections, upstream
    total requests, downstream active connections, and downstream HTTP requests.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_15.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.15: Envoy metrics'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Like most metrics, these will be beneficial if you experience issues with the
    Envoy proxy container. The uptime will let you know how long the pod has been
    running, the allocated memory tells you how much memory has been allocated to
    the pod, which may help to identify why an OOM condition occurred, and active
    connections will identify if the service has issues if the connection count is
    lower than expected, or at zero.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Using the Services view
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we will discuss the last view for the application, the Services view.
    Just as the name implies, this will provide a view of the services that are part
    of the workload. You can open the Services view by clicking on the **Services**
    option in Kiali.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_16.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.16: The Services view'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the other views, this will provide the names of the services and
    the health of each of the services. If you click on any individual service, you
    will be taken to the details of the service. If you were to click **adservice**,
    you would be taken to the overview for the service.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_17.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.17: The services overview'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: The **Overview** page should have some objects familiar to you. Just like the
    other views, it provides a view of just the objects that communicate with **adservice**,
    and it has tabs for traffic, inbound metrics, and traces – however, in addition
    to these, it also shows the network information for the service. In our example,
    the service has been configured to use a `ClusterIP` type, the service IP assigned
    is `10.110.47.79`, it has an endpoint of `10.240.189.149`, and it has the gRPC
    TCP port exposed on port `9555`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: This is information you could retrieve using `kubectl`, but for many people,
    it’s quicker to grab the details from the Kiali dashboard.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: The Istio Config view
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last view we have is not related to the workload in particular. Instead,
    it’s a view for the Istio config for the namespace. This view will contain the
    Istio objects you have created. In our example, we have two objects, the gateway
    and the virtual service.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_18.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.18: The Istio Config view'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: You can view the YAML for each object by clicking the name. This allows you
    to directly edit the object in the Kiali dashboard. Any changes that are saved
    will edit the object in the cluster, so be careful if you are using this method
    to modify the object.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: This view offers one addition that the other views do not – the ability to create
    a new Istio object using a wizard. To create a new object, click the **Actions**
    dropdown in the upper right-hand corner of the Istio config view. This will bring
    up a list of objects that you can create, as shown in *Figure 16.19*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_19.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.19: Istio object creation wizard'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the figure, Kiali provides a wizard to create 6 Istio objects
    including **AuthorizationPolicies**, **Gateways**, **PeerAuthentication**, **RequestAuthentication**,
    **ServiceEntries**, and **Sidecars**.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Each option has a wizard to guide you through the specific requirements for
    that object. For example, we could create a sidecar using the wizard, as shown
    in *Figure 16.20*.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_20.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.20: Using the Istio object wizard'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Once all fields have been entered correctly, you can click **Preview**, which
    will take you to the next screen, where you will see the object YAML source, as
    shown in *Figure 16.21*.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21165_16_21.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.21: Wizard source YAML'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: If it looks good, click **Create** to create the new object.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: The wizards are a good tool for people who are new to Istio, but be careful
    not to rely on them too much. You should always understand how to create a manifest
    for all of your objects. Creating objects using wizards like these can lead to
    problems down the road without the knowledge of how the object works or is created.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce where Istio is heading in the future.
    As powerful as the sidecar is, it has its limitations, and it requires additional
    resources for each pod in the mesh. In 2023, Istio introduced a new concept called
    ambient mesh as an early access feature, which removed the requirement for the
    Istio sidecar.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'The future: Ambient mesh'
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, Service meshes, such as Istio, depend on sidecar proxies connected to
    every service instance to handle traffic, security measures, and metric collection.
    Although this approach works well, it leads to extra resource usage and complexity,
    particularly in deployments in larger clusters.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we mentioned sidecars a lot – they’re the heart of the mesh,
    providing the layer that removes all of the complexities of using mesh features
    without requiring code changes to our applications.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Ambient mesh marks a significant change in the Service mesh design, attempting
    to make it easier to add Service mesh features to an already complicated system
    without the need for sidecar proxies for every service. Its goal is to cut down
    on the extra work and complexity while keeping the main advantages of a Service
    mesh, including monitoring, security, and traffic management.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Istio 1.20, the ambient mesh has the **Alpha** status. The main reason
    that we haven’t added a chapter on using an ambient mesh is due to potential changes
    that will likely occur between the current alpha stage and when it goes to **general
    availability** (**GA**). However, since it is a giant leap forward and a major
    change in design, we wanted to bring it to your attention. You can read more about
    getting started with ambient mesh on Istio’s site here: [https://istio.io/latest/docs/ops/ambient/getting-started/](https://istio.io/latest/docs/ops/ambient/getting-started/).'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Reading the docs on Istio’s site will provide some great examples of how the
    ambient mesh deploys and works. Since many readers will be new to Istio, jumping
    into the docs for an overview may be a little much, so we wanted to provide our
    view on the key points of what the ambient mesh means to us.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned, ambient mesh addresses a number of issues by removing the
    tasks that are usually managed by sidecar proxies. Rather than attaching a proxy
    to each service instance, the ambient mesh will integrate these functions directly
    into the network or in a common proxy layer. This design seeks to simplify processes
    and lessen the resources needed compared to the traditional sidecar method. This
    provides a number of advantages, including:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '**Preservation of Essential Features**: Despite its unique architecture, the
    ambient mesh will continue to deliver the base capabilities found in current Service
    meshes, including secure communications between services, traffic control, and
    the ability to monitor components.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined, Efficient Deployments**: The ambient mesh eliminates the necessity
    for individual sidecar proxies, streamlining the setup and management of Service
    meshes. This will facilitate easier adoption and maintenance, especially for organizations
    with complex microservices structures.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved Resource** **Utilization**: By minimizing the CPU and memory demands
    for service-to-service interactions, the ambient mesh allows the efficient use
    of resources.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance Enhancement**: The ambient mesh enhances system performance by
    optimizing the routes used for service communication, reducing delays and boosting
    efficiency.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine the resource and complexity savings in a large cluster where you may
    have thousands, or tens of thousands, of services running. Currently, that would
    require as many proxy instances running, each adding an extra layer in the communication
    and using its own resources – using extra CPU and RAM that are not actually “required”
    for the base applications. The ambient mesh will save you money by reducing the
    required resources, and by simplifying the architecture, it should be easier to
    find issues when an application is not behaving as expected.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: We hope that this chapter has provided a useful introduction to Istio and what’s
    in store for Istio’s future. In the next chapter, we will dive deeper into running
    applications in an enterprise using Istio.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the Service mesh world, using the popular
    open-source project Istio. In the first section of the chapter, we explained some
    of the advantages of using a Service mesh, which included security and observability
    for mesh services.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: The second section of the chapter detailed the installation of Istio and the
    different installation profiles that are available. We deployed Istio into our
    KinD clusters and we also removed NGNIX to free up ports `80` and `443` to be
    used by Istio’s ingress gateway. This section also included the objects that are
    added to a cluster once you deploy Istio. We covered the most common objects using
    example manifests that reinforce how to use each object in your own deployments.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: To close out the chapter, we detailed how to install Kiali, Prometheus, and
    Jaeger to provide powerful observability in our Service mesh. We also explained
    how to use Kiali to look into an application in the mesh to view the application
    metrics and logs.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deploy a new application and bind it to the Service
    mesh, building on many of the concepts that were presented in this chapter.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Istio object(s) is used to route traffic between multiple versions of an
    application?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ingress rule
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VirtualService
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DestinationRule
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can’t route traffic between multiple versions, only a single instance
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool(s) are required to provide observability in the Service mesh?
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prometheus
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Jaeger
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kiali
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes Dashboard
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Istio features require developers to change their code to leverage
    features like mutual TLS and authorization.'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Istio made the control plane easier to deploy and configure by merging multiple
    components into a single executable called:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Istio
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: IstioC
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: istiod
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pilot
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b - VirtualService and c - DestinationRule
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a Prometheus and c - Kiali
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b - False
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c - Pilot
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
