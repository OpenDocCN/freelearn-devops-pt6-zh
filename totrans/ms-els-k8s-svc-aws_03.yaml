- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Your First EKS Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we talked about Kubernetes and EKS in detail. In this
    chapter, we will begin to explore how to configure and build a basic cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although EKS is a managed service from AWS, there are a number of ways you
    can create the cluster, using the console, **Command-Line Interface** (**CLI**),
    and **Infrastructure as Code** (**IaC**). There are also different configurations
    that can be applied to a cluster, including networking, storage, and application
    configurations. This chapter will focus on the prerequisites for building a cluster
    along with the basic configuration you need to build a cluster. Specifically,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the prerequisites for building an EKS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different configuration options for an EKS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating the automation options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first EKS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin by looking at what needs to be done before creating your first cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a familiarity with cloud automation, ideally CloudFormation,
    and some experience with programming languages or software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to follow along, you will also need an AWS account to be able to launch
    EKS resources. If you don’t have an account, please go to AWS and create one:
    [https://aws.amazon.com/](https://aws.amazon.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: These activities will result in AWS charges, so please make sure to delete all
    resources after you have built them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the prerequisites for building an EKS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the email address and password used to create the AWS account are
    the root user’s, and they have privileges to do everything in the AWS Account.
    AWS best practice is to enable **Multi-Factor Authentication** (**MFA**) on this
    account and *never* use this account other than in an emergency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list of activities need to be performed once you have an AWS
    account and the root user access credentials prior to creating an EKS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure your AWS CLI environment with temporary root credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the root user, you should:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an EKS admin policy, using the least privileges that can be used to deploy
    and manage EKS clusters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an EKS cluster Admin group and assign the EKS Admin role to that group
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new user and add them to the EKS cluster Admin group
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the access credentials and add them to your AWS CLI configuration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install kubectl on your workstation using the following guide: [https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html](https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure your AWS CLI environment with temporary root credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally you would simply run the `$ aws configure` command, which will ask
    you for the default access credentials, region, and output format, but we don’t
    want to persist the root credentials, so we will use environment variables to
    hold them temporarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create the EKS Admin policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to provide the right permissions to the EKS administrator is
    to grant them access to the AWS-managed `AdministratorAccess` managed role. You
    can get the unique identity for the role **AWS Resource Name** (**ARN**) using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `AdministratorAccess` role is very broad and allows the resource assigned
    the permission, the principal, with a lot of privileges that are not needed. Ideally,
    the EKS admin role that is created has reduced permissions, defined in the least-privilege
    security model. Creating this role is quite complex as it requires multiple resource
    permissions. The following table lists the minimum permissions you need for EC2,
    EKS, KMS, and IAM. However, you may need to add permissions to this role if you
    need to create a VPC/subnets, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '| **AWS** **Resource** | **Minimal** **Permission Set** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| EC2 API | `"ec2:RunInstances"`, `"ec2:RevokeSecurityGroupIngress"`, `"ec2:RevokeSecurityGroupEgress"`,
    `"ec2:DescribeRegions"`, `"ec2:DescribeVpcs"`, `"ec2:DescribeTags"`, `"ec2:DescribeSubnets"`,
    `"ec2:DescribeSecurityGroups"`, `"ec2:DescribeRouteTables"`,`"ec2:DescribeLaunchTemplateVersions"`,
    `"ec2:DescribeLaunchTemplates"`, `"ec2:DescribeKeyPairs"`, `"ec2:DescribeInternetGateways"`,
    `"ec2:DescribeImages"`, `"ec2:DescribeAvailabilityZones"`, `"ec2:DescribeAccountAttributes"`,
    `"ec2:DeleteTags","ec2:DeleteSecurityGroup"`, `"ec2:DeleteKeyPair"`, `"ec2:CreateTags"`,
    `"ec2:CreateSecurityGroup"`, `"ec2:CreateLaunchTemplateVersion"`, `"ec2:CreateLaunchTemplate"`,
    `"ec2:CreateKeyPair"`, `"``ec2:AuthorizeSecurityGroupIngress"`, `"ec2:AuthorizeSecurity``GroupEgress"`
    |'
  prefs: []
  type: TYPE_TB
- en: '| EKS API | `"eks:UpdateNodegroupVersion"`, `"eks:UpdateNodegroupConfig"`,
    `"eks:UpdateClusterVersion"`, `"eks:UpdateClusterConfig"`, `"eks:UntagResource"`,
    `"eks:TagResource"`, `"eks:ListUpdates"`, `"eks:ListTagsForResource"`, `"eks:ListNodegroups"`,
    `"eks:ListFargateProfiles"`, `"eks:ListClusters"`, `"eks:DescribeUpdate"`, `"eks:DescribeNodegroup"`,
    `"eks:DescribeFargateProfile"`, `"eks:DescribeCluster"`, `"eks:DeleteNodegroup"`,
    `"eks:DeleteFargateProfile"`, `"eks:DeleteCluster"`, `"eks:CreateNodegroup"`,
    `"``eks:CreateFargateProfile"`, `"eks:CreateCluster"` |'
  prefs: []
  type: TYPE_TB
- en: '| KMS API | `"``kms:ListKeys"` |'
  prefs: []
  type: TYPE_TB
- en: '| IAM API | `"iam:PassRole"`, `"iam:ListRoles"`, `"iam:ListRoleTags"`, `"iam:ListInstanceProfilesForRole"`,
    `"iam:ListInstanceProfiles"`, `"iam:ListAttachedRolePolicies"`, `"iam:GetRole"`,
    `"iam:GetInstanceProfile"`, `"iam:DetachRolePolicy"`, `"iam:DeleteRole"`, `"``iam:CreateRole"`,
    `"iam:AttachRolePolicy"` |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – EKS Admin example privileges
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the desired permissions set, you can create a policy document.
    A JSON example is shown in the following snippet with just the KMS permission
    included for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `aws iam create-policy --policy-name bespoke-eks-policy --policy-document
    file://<mypolicyfile.json>` command to create the IAM policy based on the JSON
    file you have created, you can then retrieve the ARN using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create the EKS Admin group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the group using the CLI is pretty straightforward, using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You then need to attach the policy created in the previous step using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Create a new user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have the permissions, and the group has been created, we can create
    a new user and assign it to the group using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add the user you just created to the group using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to create a password using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You now need to create access credentials and store them using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should copy the credentials (`SecretAccessKey` and `AccessKeyId`) output
    from this command, add them to your CLI configuration using the `$aws configure`
    command, and use this account/credentials for the remainder of the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You still need to grant console access. Please refer to this link: [https://docs.aws.amazon.com/IAM/latest/UserGuide/console_controlling-access.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/console_controlling-access.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also enable MFA. Please refer to this link: [https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the prerequisites in place, we need to consider how we
    configure the EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different configuration options for an EKS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is extensible by default, which is one of the reasons it has become
    so popular. As well as the standard API objects we’ve already discussed such as
    **Pods** and **Services**, you can extend the API to support custom resources,
    controllers, operators, and standard plugins for networking and storage. All of
    these elements can be added to an EKS cluster as part of the cluster creation
    process; however, in this chapter, we will cover the basic configuration to get
    a simple cluster up and running. The following table defines what will be configured
    as well as providing a map to other chapters that show additional configuration
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **EKS** **Configuration Domain** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Control plane | As we have mentioned, EKS is really a managed control plane,
    so this must always be done, and the next sections will focus on creating this.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Basic networking | We will cover this briefly in this section using the default
    AWS EKS VPC plugin (CNI), but it’s covered in more detail in [*Chapter 7*](B18129_07.xhtml#_idTextAnchor107).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Base node group | In the next section, we will create a small node group
    on EC2 resources to host key cluster resources such as the VPC network plugin.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pod storage services | We won’t cover this in this section but will go into
    more detail in [*Chapter 12*](B18129_12.xhtml#_idTextAnchor175). |'
  prefs: []
  type: TYPE_TB
- en: '| Additional node groups | We won’t cover this in this section but will go
    into more detail in [*Chapter 8*](B18129_08.xhtml#_idTextAnchor123). |'
  prefs: []
  type: TYPE_TB
- en: '| Fargate profiles | We won’t cover this in this section but will go into more
    detail in [*Chapter 15*](B18129_15.xhtml#_idTextAnchor220). |'
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes applications | We won’t cover this in this section but will go
    into more detail in *Chapters 11*, *13*, and *14*. |'
  prefs: []
  type: TYPE_TB
- en: '| Advanced networking concepts | We won’t cover this in this section but will
    go into more detail in [*Chapter 8*](B18129_08.xhtml#_idTextAnchor123). |'
  prefs: []
  type: TYPE_TB
- en: '| Service mesh | We won’t cover this in this section but will go into more
    detail in [*Chapter 16*](B18129_16.xhtml#_idTextAnchor232). |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – EKS configuration areas
  prefs: []
  type: TYPE_NORMAL
- en: Before we actually create a cluster that is composed of a managed control plane,
    basic networking, and a base node group, let’s review the different ways we can
    approach deploying and automating it and why you would choose one over the others.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating the automation options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following diagram (*Figure 3**.1*) illustrates the evolution of infrastructure
    automation in AWS. Most users start off with manual configuration using playbooks
    or wikis and the AWS console. The challenge with this is it’s difficult to repeat,
    and if you need to change or add something, you need to do it manually.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to then use shell scripts to automate the deployment of AWS
    resources using, for example, the AWS CLI. This is not perfect because if you
    run the same command twice you can get different results. Thus, the AWS CLI is
    not (necessarily) idempotent. So, in 2011, AWS released CloudFormation, an IaC
    framework that can safely create infrastructure resources.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.1 \uFEFF– Automation options](img/B18129_03_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Automation options
  prefs: []
  type: TYPE_NORMAL
- en: IaC has become best practice for deploying AWS resources, and in 2014 HashiCorp
    released Terraform, which has become very popular and again allows you to automate
    and deploy AWS resources safely. The challenge with both CloudFormation and Terraform
    is they have their own markup language that must be learned and can be complex.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, various generators have been produced that allow you to create
    CloudFormation and Terraform scripts without needing to understand how to write
    them. This concept has further been extended with abstractions such as AWS **Cloud
    Development Kit** (**CDK**), which allows you to generate and deploy CloudFormation
    using regular programming languages such as Python, Typeset, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, this additional layer abstraction is part of the cluster with
    manifest, Helm charts, and Kustomize being used to abstract Kubernetes resources,
    and tools such as eksctl providing a simple interface for provisioning EKS clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Which automation tool/framework should I use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A general rule of thumb for any automation is **Don’t Repeat Yourself** (**DRY**),
    so if you are going to create or delete clusters on a regular basis, use automation
    and use the highest level of abstraction you can. Tools such as the CDK and eksctl
    mean you don’t have to learn CloudFormation but can still rely on *safe* deployment
    practices such as declarative configurations and idempotent operations.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform supports these *safe* operations, which in addition means you can
    support other clouds such as Microsoft Azure and Google Cloud Platform, as well
    as other on-premises resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will show you how you can create a basic cluster using
    the console and AWS CLI and then simplify the operation using the following IaC
    Tools: Terraform, eksctl, and the AWS CDK.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first EKS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please verify you are using the credentials for the username you created as
    part of the prerequisites using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Option 1: Creating your EKS cluster with the AWS console'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start this exercise, open a browser, go to the URL [https://aws.amazon.com/](https://aws.amazon.com/),
    and sign in to your account using the username/credentials you created as part
    of the prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have logged in, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `IAM` in the search bar and select **IAM** | **Roles** from the resulting
    search results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now create a cluster Service role by clicking on the **Create Role**
    button, which will allow the cluster to make calls to other AWS Services. It’s
    a simple policy, is defined at [https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html),
    and should be linked to the AmazonEKSClusterPolicy managed policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Service role has been created, select the region that you would like
    to launch the Amazon EKS cluster in, type `EKS` in the search bar, and select
    **Elastic** **Kubernetes Service**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.2 \uFEFF– Select EKS](img/B18129_03_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Select EKS
  prefs: []
  type: TYPE_NORMAL
- en: On the EKS launch screen, click on the **Add cluster** | **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.3 \uFEFF– Add cluster](img/B18129_03_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Add cluster
  prefs: []
  type: TYPE_NORMAL
- en: On the resulting screen, enter the cluster name in the **Name** field, select
    the version of Kubernetes you want to deploy from the **Kubernetes version** field,
    select the Service role created in *step 2*, and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.3 \uFEFF– Configure cluster](img/B18129_03_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Configure cluster
  prefs: []
  type: TYPE_NORMAL
- en: In the first panel of the EKS networking screen, you need to select the VPC
    and subnets that the control plane will use as well as the security group used
    by any worker nodes. If these resources don’t exist, you can add them using the
    VPC console link (make sure you open the link in a browser tab or window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.4 \uFEFF– Enter VPC and security group details](img/B18129_03_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Enter VPC and security group details
  prefs: []
  type: TYPE_NORMAL
- en: In the next panel, select the type of cluster endpoint. In this example, we
    will keep the **Public** default, which means the cluster API is accessible from
    the internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.5 \uFEFF– Cluster endpoints](img/B18129_03_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Cluster endpoints
  prefs: []
  type: TYPE_NORMAL
- en: In the final networking panel, you can leave the defaults, which relate to the
    Kubernetes version chosen in *step 5* and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.6 \uFEFF– Complete networking section](img/B18129_03_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Complete networking section
  prefs: []
  type: TYPE_NORMAL
- en: Enable **Audit** logging to CloudWatch logs by selecting the button and clicking
    **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.7 \uFEFF– Control plane logging](img/B18129_03_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Control plane logging
  prefs: []
  type: TYPE_NORMAL
- en: 'Review your cluster settings and click the **Create** button. This will now
    take 20-30 minutes to complete and involves setting up the control plane (API
    and etcd servers) in an AWS-owned VPC and connecting it through **Elastic Network
    Interfaces** (**ENIs**) to your VPC. When it completes, you will see a new cluster
    with a status of **Active**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.8 \uFEFF– An active cluster](img/B18129_03_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – An active cluster
  prefs: []
  type: TYPE_NORMAL
- en: As this is a public cluster, you can run the `aws eks update-kubeconfig --cluster
    <CLUSTERNAME> --region <YOURREGION>` command to update your `kubeconfig` file.
    We have created an EKS control plane and set up networking but currently, we don’t
    have any nodes attached to it. We can validate this by using the `kubectl get
    nodes` command. You should get a **No resources** **found** message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click on the name link of your cluster (this is **mycluster** in *step
    10*), you will be taken to the cluster configuration screen shown in the following
    screenshot. Click the **Compute** tab, and then click on the **Add node** **group**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.9 \uFEFF– Compute](img/B18129_03_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Compute
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first **Node group configuration** panel, enter a name for the node
    group and an EC2 worker IAM role. If this role doesn’t exist, you can add it using
    the VPC console link (make sure you open the link in a browser tab or window).
    The role should be created in line with this link: [https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.10 \uFEFF– Node group configuration](img/B18129_03_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Node group configuration
  prefs: []
  type: TYPE_NORMAL
- en: You can accept all the defaults in the `t3.medium` EC2 instances in an autoscaling
    group using an EKS-optimized Amazon Linux **operating system** (**OS**) image.
    Click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the subnets you will use for the EC2 worker nodes in your VPC; you should
    select at least two subnets/availability zones. Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.11 \uFEFF– Node group networking](img/B18129_03_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Node group networking
  prefs: []
  type: TYPE_NORMAL
- en: Review your node group settings and click the `kubelet` and `kubeproxy`) and
    connect back to the control plane. Once the job completes, the node group should
    be **Active** and the two EC2 instances should be **Ready**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 — Active node group](img/B18129_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 — Active node group
  prefs: []
  type: TYPE_NORMAL
- en: We can validate this by using the `kubectl get nodes` command. The output should
    now show the two nodes you have just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have finished with the cluster, delete the node group, and then you
    can delete the cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As the AWS console interface may be changed, if you have questions, you can
    always check the AWS documentation for creating the EKS cluster ([https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html](https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html))
    and for creating managed node groups ([https://docs.aws.amazon.com/eks/latest/userguide/create-managed-node-group.html](https://docs.aws.amazon.com/eks/latest/userguide/create-managed-node-group.html))
    to get the latest updated steps.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we have created a basic cluster with a managed control plane,
    an AWS VPC network, and a basic node group with two EC2 workers. In the next subsection,
    we will see how we can create the same cluster using the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: Creating your EKS cluster with the AWS CLI'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AWS CLI is a tool for managing your AWS resources. It can be installed
    using this link: [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an EKS cluster using the AWS CLI, you should follow the steps detailed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: We will reuse the cluster Service role and the same subnets used in *Option
    1*. If they don’t exist, create them using the steps in *Option 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can then create the managed control plane in your account using the following
    commands with the username/credentials you created as part of the prerequisites.
    The subnets and security group can be the same ones used in *Option 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will now take 20-30 minutes to complete and involves setting up the control
    plane (API and etcd servers) in an AWS-owned VPC and connecting it through ENIs
    to your VPC. When it completes, you will see a new cluster with a status of **Active,
    as** shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.13 \uFEFF– Active cluster](img/B18129_03_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Active cluster
  prefs: []
  type: TYPE_NORMAL
- en: Again, we have created an EKS control plane and set up networking but currently,
    we don’t have any nodes attached to it. We can validate this by using the `kubectl
    get nodes` command, after updating the `kubeconfig` file. You should get a **No
    resources** **found** message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create the basic node group using the following command, which will
    create two t3.medium EC2 instances in an autoscaling group using an EKS-optimized
    Amazon Linux OS image using the EC2 role created in *Option 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will now take 10-20 minutes and will create two EC2 instances and configure
    the Kubernetes agents (`kubelet` and `kubeproxy`) and connect back to the control
    plane. Once the job completes, the node group should be **Active** and the two
    EC2 instances should be **Ready**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.14 \uFEFF– A CLI node group](img/B18129_03_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – A CLI node group
  prefs: []
  type: TYPE_NORMAL
- en: We can validate this by using the `kubectl get nodes` command. The output should
    now show the two nodes you have just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have finished with the cluster, delete the node group, and then you
    can delete the cluster using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, this process is much simpler than clicking through the AWS console.
    These commands can be placed in a shell script, and you can use environment variables
    to parameterize the input, changing the cluster name, for example. However, it’s
    not guaranteed that every command is *safe* to run repeatedly, and script execution
    can be problematic if there are any failures. A better way is to use IaC and we
    will explore that over the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 3: Creating your EKS cluster with Terraform'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform is an open source project created by HashiCorp and is composed of
    a single binary that can be used to validate, deploy, and delete (destroy) AWS
    infrastructure resources. You can install Terraform by following the instructions
    shown at [https://learn.hashicorp.com/tutorials/terraform/install-cli](https://learn.hashicorp.com/tutorials/terraform/install-cli).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your first EKS cluster using Terraform, we will clone the official
    example containing the configuration file for creating an EKS cluster provided
    by HashiCorp. This is a very complete solution (creating 53 resources) and will
    create a new VPC, two managed worker node groups, and all the associated roles
    and permissions. Use the following commands to clone and change into the cloned
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Terraform works by aggregating all `.tf` files into a single configuration
    and then deploying it to AWS using your local credentials. You will need to modify
    certain `.tf` files for your AWS account; the following table explains which ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Terraform (.****tf) file** | **Changes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `./``vpc.tf` | Change the region variable to the region you want to use,
    for example:`variable "``region" {`  `default`     `= "``eu-central-1"`  `description
    = "``AWS region"``}` |'
  prefs: []
  type: TYPE_TB
- en: '| `./``eks-cluster.tf` | Change the EKS version to the desired version, for
    example:`module "``eks" {`        `cluster_version = "``1.22" }` |'
  prefs: []
  type: TYPE_TB
- en: Table 3.3 – Terraform changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have made the changes to the Terraform files, you can create an
    EKS cluster and environment using Terraform. You should follow the steps detailed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `$ terraform init` command to create the local state and download all
    the remote module files such as the VPC module used to create the new VPC. It
    can take some time to download all the module files. If this command is successful,
    you will see the **Terraform has been successfully** **initialized!** message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `$ terraform plan` command to see what resources will be created before
    actually deploying them. This is a major advantage over the console and CLI methods,
    as you can also use this to see what will change when you make a change to the
    `.``tf` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `$ terraform apply -auto-approve` command to create/deploy the resources.
    This will take 20-30 minutes to complete (so take a seat). At the end of it, you
    will have a new IAM role, an EKS cluster in a new VPC, new internet and NAT gateways,
    and two managed node groups with three EC2 instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this option, we have actually created managed node groups, which we can validate
    by using the `$ kubectl get nodes` command. After updating the `kubeconfig` file,
    you will see three worker nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have finished with the cluster, use the `$ terraform destroy -auto-approve`
    command to delete all resources. Terraform will automatically figure out the order
    of deletion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, Terraform is a very powerful tool and simplifies the way you
    configure and deploy resources. You still have to configure or create the Terraform
    modules, which in turn requires you to learn the Terraform syntax and markup language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will see how you can use eksctl to create an EKS
    cluster using CloudFormation under the covers without learning any CloudFormation
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 4: Creating your EKS cluster with eksctl'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: eksctl is an open source project on GitHub ([https://github.com/weaveworks/eksctl](https://github.com/weaveworks/eksctl))
    co-developed between Weaveworks and AWS. It’s similar to Terraform in that it
    runs as a single binary and creates AWS resources; however, it can only be used
    to create, update, and manage EKS clusters (and any associated resources).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install eksctl by following the instructions shown at [https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html](https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html).
    After you install the binary on your workstation, you can test the install using
    the `eksctl info` command. The easiest way to create a cluster is to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This works in a similar way to Terraform in that it will create the VPC, EKS
    cluster, a node group, and all the associated resources, such as IAM roles. In
    the background, eksctl uses CloudFormation and will create two CloudFormation
    stacks that will create (29+) AWS resources. If you run the `$ aws cloudformation
    list-stacks` command, you will see stacks called *eksctl-xx*, which deploy all
    the EKS resources: one for the main resources, including the VPC, and one specifically
    for the node group. The CloudFormation stacks manage the state of the resources
    and can also be used to detect drift and make changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, using this option, we have created managed node groups, which we can
    validate by using the `kubectl get nodes` command. After updating the `kubeconfig`
    file, you will see two worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also modify the default configuration by adding command-line options.
    The following command will change the type and number of instances that are being
    deployed as part of the default node group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: eksctl supports different options for your cluster creation. You can list other
    supported options by using the flag `--help` to get more details.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished with the cluster, you can use the `$ eksctl delete cluster
    --name mycluster --region eu-central-1` command to remove all the resources. As
    eksctl is a specific EKS provisioning tool, it does have some built-in features,
    such as node draining.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, eksctl provides a higher level of abstraction to Terraform,
    but it is not as versatile as it is an EKS tool. In the next subsection, we will
    briefly look at the AWS CDK, which uses programming languages such as Python to
    move completely away from any IaC markup languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 5: Creating your EKS cluster with the CDK'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AWS CDK is similar to Terraform and eksctl in that you end up with a set
    of binaries that can deploy AWS infrastructures. It uses CloudFormation under
    the cover, but it has four main advantages over eksctl:'
  prefs: []
  type: TYPE_NORMAL
- en: The IaC code is written in standard programming languages such as Python, TypeScript,
    Golang, and so on, so developers can build code without learning Terraform or
    CloudFormation markup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can leverage existing language control constructs, `IF-THEN-ELSE`, `FOR`
    loops, and so on, as well as existing libraries to build complex logic into your
    IaC scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create non-EKS-related resources such as DynamoDB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates can be tested and linted using standard language tools such as pylint
    or pytest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A detailed exploration of the CDK is out of the scope of this book (in fact,
    it could be a whole new book). If you want to really get to grips with the CDK,
    [https://cdkworkshop.com/](https://cdkworkshop.com/) is a great resource. Instead,
    the following table shows the basic commands needed to create an EKS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python Line** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `my_vpc =` `ec2.Vpc.from_lookup(self,"clusterVPC",vpc_id=params[''VPC''])`
    | This line uses the CDK `ec2.Vpc` object to retrieve VPC details from your AWS
    account using the `params[''VPC'']` dictionary. |'
  prefs: []
  type: TYPE_TB
- en: '| `eks_master_role =` `iam.Role.from_role_arn(self,"iderole",params[''IDEROLE''])`
    | This line uses the CDK `iam.Role` object to retrieve role details from your
    AWS account using the `params[''IDEROLE'']` dictionary, used as the main admin
    role for the cluster. |'
  prefs: []
  type: TYPE_TB
- en: '| `security_group =` `ec2.SecurityGroup.from_lookup_by_id(self,"idesg",params[''IDESG''])`
    | This line uses the CDK `iam.SecurityGroup` object to retrieve an existing security
    group from your AWS account using the `params[''IDESG'']` dictionary, used as
    an additional security group for the cluster. |'
  prefs: []
  type: TYPE_TB
- en: '| `my_subnets=[]``for subnet` `in params[''SUBID'']:``my_subnets.append(ec2.Subnet.from_subnet_id(self,f"1{subnet.split(''-'')[1]}",subnet_id=subnet))`
    | These lines create a blank subnet list, then use a standard `FOR` loop to iterate
    over a list or subnet IDs stored in `params[''SUBID'']`, create a subnet object
    using the CDK `ec2.Subnet` object, and append it to the subnet list. |'
  prefs: []
  type: TYPE_TB
- en: '| `eks.Cluster(self,params[''CLUSTERNAME''],``masters_role=eks_master_role,``security_group=security_group,``version=eval(f"eks.KubernetesVersion.{params[''VERSION'']}"),vpc=my_vpc,``vpc_subnets=my_subnets,``endpoint_access=
    eval(f"eks.EndpointAccess.{params[''CLUSTERTYPE'']}"))` | This line will create
    a cluster using the role, VPC, and subnets retrieved in the previous lines and
    also set the endpoint type and version from the params Python dictionary, which
    has all the configuration information. |'
  prefs: []
  type: TYPE_TB
- en: Table 3.4 – Python EKS CDK example
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the code has been written, the CDK binary can be used to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the AWS region for CDK deployments using the `cdk` `bootstrap` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create CloudFormation templates using the `cdk` `synth` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what will be deployed or changed using the `cdk` `diff` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and deploy CloudFormation templates using the `cdk` `deploy` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CDK provides the highest level of abstraction of all the deployment tools
    and, as such, should be considered a good starting point for EKS automation and
    deployment, but tools such as eksctl and Terraform (Terraform also has a CDK variant)
    provide good options as well. This section has given an overview of the different
    ways a basic EKS cluster can be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the prerequisites needed before the configuration
    and deployment of a basic Amazon EKS cluster, such as setting up a deployment
    user . We reviewed the different EKS configuration and automation options that
    need configuring in EKS and what frameworks and tools are available to you.
  prefs: []
  type: TYPE_NORMAL
- en: We then stepped through five options, from using the AWS console and CLI to
    different IaC frameworks to create a basic EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this lesson, you learned how to provision your EKS cluster
    and have a running cluster under your AWS account, as well as have kubectl and
    the AWS CLI installed to enable interaction with your EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move on to the topic of learning how to
    deploy and run your containerized application on Amazon EKS.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making AWS API calls safely: [https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CDK deep dive: [https://cdkworkshop.com/](https://cdkworkshop.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation overview: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform overview: [https://www.terraform.io/intro](https://www.terraform.io/intro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with eksctl: [https://eksctl.io/](https://eksctl.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
