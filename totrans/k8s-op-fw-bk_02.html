<html><head></head><body>
		<div id="_idContainer010">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Introducing the Operator Framework</h1>
			<p>Managing a Kubernetes cluster is hard. This is partly due to the fact that any microservice architecture is going to be inherently based on the interactions of many small components, each introducing its own potential point of failure. There are, of course, many benefits to this type of system design, such as graceful error handling thanks to the separation of responsibilities. However, diagnosing and reconciling such errors requires significant engineering resources and a keen familiarity with an application's design. This is a major pain point for project teams who migrate to the Kubernetes platform.</p>
			<p>The Operator Framework <a id="_idIndexMarker000"/>was introduced to the Kubernetes ecosystem to address these problems. This chapter will go over a few general topics to give a broad overview of the Operator Framework. The intent is to provide a brief introduction to the Operator Framework, the problems it solves, how it solves them, and the tools and patterns it provides to users. This will highlight key takeaways for the goals and benefits of using Operators to help administrate a Kubernetes cluster. These topics include the following:</p>
			<ul>
				<li>Managing clusters without Operators</li>
				<li>Introducing the Operator Framework</li>
				<li>Developing with the Operator <strong class="bold">software development kit</strong> (<strong class="bold">SDK</strong>)</li>
				<li>Managing Operators with the <strong class="bold">Operator Lifecycle Manager</strong> (<strong class="bold">OLM</strong>)</li>
				<li>Distributing Operators on <strong class="source-inline">OperatorHub.io</strong></li>
				<li>Defining Operator functions with the Capability Model</li>
				<li>Using Operators to manage applications</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements </h1>
			<p>This chapter does not have any technical requirements because we will only be covering general topics. In later chapters, we will discuss these various topics in depth and include technical prerequisites for following along with them. </p>
			<p>The Code in Action video for this chapter can be viewed at: <a href="https://bit.ly/3GKJfmE">https://bit.ly/3GKJfmE</a></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Managing clusters without Operators</h1>
			<p>Kubernetes<a id="_idIndexMarker001"/> is a powerful microservice container orchestration platform. It provides many different controllers, resources, and design patterns to cover almost any use case, and it is constantly growing. Because of this, applications designed to be deployed on Kubernetes can be very complex.</p>
			<p>When designing an <a id="_idIndexMarker002"/>application to use microservices, there are a number of concepts to be familiar with. In Kubernetes, these are<a id="_idIndexMarker003"/> mainly the native <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) resource objects included in the core platform. Throughout this book, we will assume a foundational familiarity with the common Kubernetes resources and their functions.</p>
			<p>These objects include Pods, Replicas, Deployments, Services, Volumes, and more. The orchestration of any microservice-based cloud application on Kubernetes relies on integrating these different concepts to weave a coherent whole. This orchestration is what creates a complexity that many application developers struggle to manage.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Demonstrating on a sample application</h2>
			<p>Take, for example, a <a id="_idIndexMarker004"/>simple web application that accepts, processes, and stores user input (such as a message board or chat server). A good, containerized design for an application such as this would be to have one Pod presenting the frontend to the user and a second backend Pod that accepts the user's input and sends it to a database for storage. </p>
			<p>Of course, you will then need a Pod running the database software and a Persistent Volume to be mounted by the database Pod. These three Pods will benefit from Services to communicate with each other, and they will also need to share some common environment variables (such as access credentials for the database and environment variables to tweak different application settings).</p>
			<p>Here is a diagram of what a sample application of this sort could look like. There are three Pods (frontend, backend, and database), as well as a Persistent Volume:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B18147_Figure_1.1.jpg" alt="Figure 1.1 – Simple application diagram with three Pods and a Persistent Volume"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Simple application diagram with three Pods and a Persistent Volume</p>
			<p>This is just a <a id="_idIndexMarker005"/>small example, but it's already evident how even a simple application can quickly involve tedious coordination between several moving parts. In theory, these discrete components will all continue to function cohesively as long as each individual component does not fail. But what about when a failure does occur somewhere in the application's distributed design? It is never wise to assume that an application's valid state will consistently remain that way.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Reacting to changing cluster states</h2>
			<p>There are <a id="_idIndexMarker006"/>a number of reasons a cluster state can change. Some may not even technically be considered a failure, but they are still changes of which the running application must be aware. For example, if your database access credentials change, then that update needs to be propagated to all the Pods that interact with it. Or, a new feature is available in your application that requires tactful rollout and updated settings for the running workloads. This requires manual effort (and, more importantly, time), along with a keen understanding of the application architecture.</p>
			<p>Time and effort are even more critical in the case of an unexpected failure. These are the kinds of problems that the Operator Framework addresses automatically. If one of the Pods that make up this application hits an exception or the application's performance begins to degrade, these scenarios require intervention. That means a human engineer must not only know the details of the deployment, but they must also be on-call to maintain uptime at any hour.</p>
			<p>There are <a id="_idIndexMarker007"/>additional components that can help administrators monitor the health and performance of their applications, such as metrics aggregation servers. However, these components are essentially additional applications that must also be regularly monitored to make sure they are working, so adding them to a cluster can reintroduce the same issues of managing an application manually.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Introducing the Operator Framework</h1>
			<p>The concept of <a id="_idIndexMarker008"/>Kubernetes Operators was introduced in a blog post in 2016 by CoreOS. CoreOS created their own container-native Linux operating system that was optimized for the needs of cloud architecture. Red Hat acquired the company in 2018, and while the CoreOS operating system's official support ended in 2020, their Operator Framework has thrived.</p>
			<p>The principal idea behind an Operator is to automate cluster and application management tasks that would normally be done manually by a human. This role can be thought of as an automated extension of support <a id="_idIndexMarker009"/>engineers or <strong class="bold">development-operations</strong> (<strong class="bold">DevOps</strong>) teams. </p>
			<p>Most Kubernetes users will already be familiar with some of the design patterns of Operators, even if they have never used the Operator Framework before. This is because Operators are a seemingly complicated topic, but ultimately, they are not functionally much different than many of the core components that already automate most of a Kubernetes cluster by default. These components are called controllers, and at its core, any Operator is essentially just a controller.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Exploring Kubernetes controllers</h2>
			<p>Kubernetes <a id="_idIndexMarker010"/>itself is made up of many default controllers. These <a id="_idIndexMarker011"/>controllers maintain the desired state of the cluster, as set by users and administrators. Deployments, ReplicaSets, and Endpoints are just a few examples of cluster resources that are managed by their own controllers. Each of these resources involves an administrator declaring the desired cluster state, and it is then the controller's job to maintain that state. If there is any deviation, the controller must act to resolve what they control.</p>
			<p>These controllers <a id="_idIndexMarker012"/>work by monitoring the current state of the cluster and comparing it to the desired state. One example is a ReplicaSet with a specification to maintain three replicas of a Pod. Should one of the replicas fail, the ReplicaSet quickly identifies that there are now only two running replicas. It then creates a new Pod to bring stasis back to the cluster.</p>
			<p>In addition, these core <a id="_idIndexMarker013"/>controllers are collectively managed by <a id="_idIndexMarker014"/>the <strong class="bold">Kube Controller Manager</strong>, which is another type of controller. It monitors the state of controllers and attempts to recover from errors if one fails or reports the error for human intervention if it cannot automatically recover. So, it is even possible to have controllers that manage other controllers.</p>
			<p>In the same way, Kubernetes Operators put the development of operational controllers in the hands of users. This provides administrators with the flexibility to write a controller that can manage any aspect of a Kubernetes cluster or custom application. With the ability to define more specific logic, developers can extend the main benefits of Kubernetes to the unique needs of their own applications.</p>
			<p>The Operators that are written following the guidelines of the Operator Framework are designed to function very similarly to native controllers. They do this by also monitoring the current state of the cluster and acting to reconcile it with the desired state. Specifically, an Operator is tailored to a unique workload or component. The Operator then knows how to interact with that component in various ways.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Knowing key terms for Operators</h2>
			<p>The component<a id="_idIndexMarker015"/> that is managed by an Operator is its <strong class="bold">Operand</strong>. An <a id="_idIndexMarker016"/>Operand is any kind of application or workload whose state is reconciled by an Operator. Operators can have many Operands, though most Operators manage—at most—just a few (usually just one). The key distinction is that Operators exist to manage Operands, where the Operator is a meta-application in the architectural design of the system. </p>
			<p>Operands can be almost any type of workload. While some Operators manage application deployments, many others deploy additional, optional cluster components offering meta-functionality such as database backup and restoration. Some Operators even make core native Kubernetes components their Operands, such as <strong class="source-inline">etcd</strong>. So, an Operator doesn't even <a id="_idIndexMarker017"/>need to be managing <a id="_idIndexMarker018"/>your own workloads; they can help with any part of a cluster.</p>
			<p>No matter what the Operator is managing, it must provide a way for cluster administrators<a id="_idIndexMarker019"/> to interact with<a id="_idIndexMarker020"/> it and configure settings for their application. An Operator exposes its configuration options through a <strong class="bold">Custom Resource</strong>. </p>
			<p>Custom Resources are created as API objects following the constraints of a matching <strong class="bold">CustomResourceDefinition</strong> (<strong class="bold">CRD</strong>). CRDs<a id="_idIndexMarker021"/> are themselves a type of native Kubernetes object that allows users and administrators to extend the Kubernetes platform with their own resource objects beyond what is defined in the core API. In other words, while a Pod is a built-in native API object in Kubernetes, CRDs allow cluster administrators to define <em class="italic">MyOperator</em> as another API object and interact with it the same way as native objects.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Putting it all together</h2>
			<p>The Operator Framework<a id="_idIndexMarker022"/> strives to define an entire ecosystem for Operator development and distribution. This ecosystem comprises three pillars that cover the coding, deployment, and publishing of Operators. They are the Operator SDK, OLM, and OperatorHub.</p>
			<p>These three pillars are what have made the Operator Framework so successful. They transform the framework from just development patterns to an encompassing, iterative process that spans the entire lifecycle of an Operator. This helps support the contract between Operator developers and users to provide consistent industry standards for their software.</p>
			<p>The lifecycle of an Operator begins with development. To help with this, the Operator SDK exists to guide developers in the first steps of creating an Operator. Technically, an Operator does not have to be written with the Operator SDK, but the Operator SDK provides development patterns to significantly reduce the effort needed to bootstrap and maintain an Operator's source code.</p>
			<p>While coding and development are certainly important parts of creating an Operator, any project's timeline does not end once the code is compiled. The Operator Framework community recognized that a coherent ecosystem of projects must offer guidance beyond just the initial development stage. Projects need consistent methods for installation, and as software evolves, there is a need to publish and distribute new versions. OLM and OperatorHub help users to install and manage Operators in their cluster, as well as share their Operators in the community.</p>
			<p>Finally, the Operator Framework provides a scale of Operator functionality called the Capability Model. The <a id="_idIndexMarker023"/>Capability Model provides developers with a way to classify the functional abilities of their Operator by answering quantifiable questions. An Operator's classification, along with the Capability Model, gives users information about what they can expect from the Operator.</p>
			<p>Together, these <a id="_idIndexMarker024"/>three pillars establish the basis of the Operator Framework and form the design patterns and community standards that distinguish Operators as a concept. Along with the Capability Model, this standardized framework has led to an explosion in the adoption of Operators in Kubernetes. </p>
			<p>At this point, we have discussed a brief introduction to the core concepts of the Operator Framework. In contrast with a Kubernetes application managed without an Operator, the pillars of the Operator Framework address problems met by application developers. This understanding of the core pillars of the Operator Framework will set us up for exploring each of them in more depth.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Developing with the Operator SDK</h1>
			<p>The<a id="_idIndexMarker025"/> first pillar of the Operator Framework is the Operator SDK. As with any other software development toolkit, the Operator SDK provides packaged functionality and design patterns as code. These include predefined APIs, abstracted common functions, code generators, and project scaffolding tools to easily start an Operator project from scratch.</p>
			<p>The Operator SDK is primarily written in Go, but its tooling allows Operators to be written using Go code, Ansible, or Helm. This gives developers the ability to write their Operators from the ground up by coding the CRDs and reconciliation logic themselves, or by taking advantage of automated deployment tools provided by Ansible and Helm to generate their APIs and reconciliation logic depending on their needs.</p>
			<p>Developers interact with the Operator SDK through its <strong class="source-inline">operator-sdk</strong> command-line binary. The binary is available on Homebrew for Mac and is also available directly from the Operator Framework GitHub repository (<a href="https://github.com/operator-framework/operator-sdk">https://github.com/operator-framework/operator-sdk</a>) as a release, where it can also be compiled from source.</p>
			<p>Whether you are planning to develop an Operator <a id="_idIndexMarker026"/>with <strong class="bold">Go</strong>, <strong class="bold">Ansible</strong>, or <strong class="bold">Helm</strong>, the<a id="_idIndexMarker027"/> Operator SDK<a id="_idIndexMarker028"/> binary provides commands to initialize the boilerplate project source tree. These commands include <strong class="source-inline">operator-sdk init</strong> and <strong class="source-inline">operator-sdk create api</strong>. The first command initializes a project's source directory with boilerplate Go code, dependencies, hack scripts, and even a <strong class="source-inline">Dockerfile</strong> and <strong class="source-inline">Makefile</strong> for compiling the project.</p>
			<p>Creating an API<a id="_idIndexMarker029"/> for your Operator is necessary to define the CRD required to interact with the Operator once it is deployed in a Kubernetes cluster. This is because CRDs are backed by API type definitions written in Go code. The CRD is generated from these code definitions, and the Operator has logic built in to translate between CRD and Go representations of the object. Essentially, CRDs are how users interact with Operators, and Go code is how the Operator understands the settings. CRDs also add benefits such as structural validation schemas to automatically validate inputs.</p>
			<p>The Operator SDK binary has flags to specify the name and version of the API. It then generates the API types as Go code and corresponding <strong class="bold">YAML Ain't Markup Language</strong> (<strong class="bold">YAML</strong>) files <a id="_idIndexMarker030"/>based on best-practice standard definitions. However, you are free to modify the definitions of your API in whichever way you choose.</p>
			<p>If we were to initialize a basic Operator for an application such as the one first demonstrated at the start of this chapter, the steps would be relatively simple. They would look like this:</p>
			<p class="source-code">$ mkdir sample-app</p>
			<p class="source-code">$ cd sample-app/</p>
			<p class="source-code">$ operator-sdk init --domain mysite.com --repo github.com/sample/simple-app</p>
			<p class="source-code">$ operator-sdk create api --group myapp --version v1alpha1 --kind WebApp --resource –controller</p>
			<p class="source-code">$ ls</p>
			<p class="source-code">total 112K</p>
			<p class="source-code">drwxr-xr-x   15 mdame staff  480 Nov 15 17:00 .</p>
			<p class="source-code">drwxr-xr-x+ 270 mdame staff 8.5K Nov 15 16:48 ..</p>
			<p class="source-code">drwx------    3 mdame staff   96 Nov 15 17:00 api</p>
			<p class="source-code">drwxr-xr-x    3 mdame staff   96 Nov 15 17:00 bin</p>
			<p class="source-code">drwx------   10 mdame staff  320 Nov 15 17:00 config</p>
			<p class="source-code">drwx------    4 mdame staff  128 Nov 15 17:00 controllers</p>
			<p class="source-code">drwx------    3 mdame staff   96 Nov 15 16:50 hack</p>
			<p class="source-code">-rw-------    1 mdame staff  129 Nov 15 16:50 .dockerignore</p>
			<p class="source-code">-rw-------    1 mdame staff  367 Nov 15 16:50 .gitignore</p>
			<p class="source-code">-rw-------    1 mdame staff  776 Nov 15 16:50 Dockerfile</p>
			<p class="source-code">-rw-------    1 mdame staff 8.7K Nov 15 16:51 Makefile</p>
			<p class="source-code">-rw-------    1 mdame staff  422 Nov 15 17:00 PROJECT</p>
			<p class="source-code">-rw-------    1 mdame staff  218 Nov 15 17:00 go.mod</p>
			<p class="source-code">-rw-r--r--    1 mdame staff  76K Nov 15 16:51 go.sum</p>
			<p class="source-code">-rw-------    1 mdame staff 3.1K Nov 15 17:00 main.go</p>
			<p>After this, you<a id="_idIndexMarker031"/> would go on to develop the logic of the Operator based on the method you choose. If that's to write Go code directly, it would start by modifying the <strong class="source-inline">*.go</strong> files in the project tree. For Ansible and Helm deployments, you would begin working on the Ansible roles or Helm chart for your project.</p>
			<p>Finally, the Operator SDK binary provides a set of commands to interact with OLM. These include the ability to install OLM in a running cluster, but also install and manage specific Operators within OLM. </p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Managing Operators with OLM</h1>
			<p>OLM is the second<a id="_idIndexMarker032"/> pillar of the Operator Framework. Its purpose is to facilitate the deployment and management of Operators in a Kubernetes cluster. It is a component that <a id="_idIndexMarker033"/>runs within a Kubernetes cluster and provides several commands and features for interacting with Operators.</p>
			<p>OLM is primarily used for the installation and upgrade of Operators—this includes fetching and installing any dependencies for those Operators. Users interact with OLM via commands provided by the Operator SDK binary, the Kubernetes command-line tool (<strong class="source-inline">kubectl</strong>), and declarative YAML.</p>
			<p>To get started, OLM can be initialized in a cluster with the following command:</p>
			<p class="source-code">$ operator-sdk olm install</p>
			<p>Besides <a id="_idIndexMarker034"/>installing Operators, OLM can also make Operators that are currently installed discoverable to users on the cluster. This provides a catalog of already installed Operators available to cluster users. Also, by managing all the known Operators in the cluster, OLM can watch for conflicting Operator APIs and settings that would destabilize the cluster.</p>
			<p>Once an Operator's Go code is compiled into an image, it is ready to be installed into a cluster with OLM running. Technically, OLM is not required to run an Operator in any cluster. For example, it is completely possible to deploy an Operator manually in the cluster, just as with any other container-based application. However, due to the advantages and security measures described previously (including its ability to install Operators and its awareness of other installed Operators), it is highly recommended to use OLM to manage cluster Operators.</p>
			<p>When developing an Operator, the image is compiled into<a id="_idIndexMarker035"/> a <strong class="bold">bundle</strong>, and that bundle is installed via OLM. The bundle consists of several YAML files that describe the Operator, its CRD, and its dependencies. OLM knows how to process this bundle in its standardized format to properly manage the Operator in a cluster. </p>
			<p>Compiling an Operator's code and deploying it can be done with commands such as the ones shown next. The first command shown in the following code snippet builds the bundle of YAML manifests that describe the Operator. Then, it passes that information to OLM to run the Operator in your cluster:</p>
			<p class="source-code">$ make bundle ...</p>
			<p class="source-code">$ operator-sdk run bundle ...</p>
			<p>Later chapters will demonstrate exactly how to use these commands and what they do, but the general idea is that these commands first compile the Operator's Go code into an image and a deployable format that's understandable by OLM. But OLM isn't the only part of the Operator Framework that consumes an Operator's bundle—much of the same information is used by OperatorHub to provide information on an Operator.</p>
			<p>Once an Operator has been compiled into its image, OperatorHub exists as a platform to share and distribute those images to other users.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Distributing Operators on OperatorHub.io</h1>
			<p>The final core component of the<a id="_idIndexMarker036"/> Operator Framework is <strong class="source-inline">OperatorHub.io</strong>. As a major open source project, the Operator Framework ecosystem is built on<a id="_idIndexMarker037"/> the open sharing and distribution of projects. Therefore, OperatorHub powers the growth of Operators as a Kubernetes concept.</p>
			<p>OperatorHub is an open catalog of Operators published and managed by the Kubernetes community. It serves as a central index of freely available Operators, each contributed by developers and organizations. You <a id="_idIndexMarker038"/>can see an overview of the <strong class="source-inline">OperatorHub.io</strong> home page in the following screenshot:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B18147_Figure_1.2.jpg" alt="Figure 1.2 – Screenshot of the OperatorHub.io home page, showing some of the most popular Operators&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Screenshot of the OperatorHub.io home page, showing some of the most popular Operators</p>
			<p>The process for submitting an Operator to OperatorHub for indexing has been standardized to ensure the consistency and compatibility of Operators with OLM. New Operators are reviewed by automated tooling for compliance with this standard definition of an Operator. The process is mainly handled through the open source GitHub repository that provides the backend of OperatorHub. However, OperatorHub does not provide any assistance with the ongoing maintenance of an Operator, which is why it is important for Operator developers to share links to their own open source repositories and contact information where users can report bugs and contribute themselves.</p>
			<p>Preparing an <a id="_idIndexMarker039"/>Operator for submission to OperatorHub involves generating its bundle and associated manifests. The submission process primarily relies on the Operator's <strong class="bold">Cluster Service Version</strong> (<strong class="bold">CSV</strong>). The CSV is a YAML file that provides <a id="_idIndexMarker040"/>most of the metadata to OLM and OperatorHub about your Operator. It includes general information such as the Operator's name, version, and keywords. However, it also defines installation requirements (such as <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) permissions), CRDs, APIs, and additional cluster resource objects owned by the Operator.</p>
			<p>The specific sections of an Operator's CSV include the following:</p>
			<ul>
				<li>The Operator's name and version number, as well as a description of the Operator and its display icon in Base64-encoded image format</li>
				<li>Annotations for the Operator</li>
				<li>Contact information for the maintainers of the Operator and the open source repository where its code is located</li>
				<li>How the Operator should be installed in the cluster</li>
				<li>Example configurations for the Operator's CRD</li>
				<li>Required CRDs and other resources and dependencies that the Operator needs to run</li>
			</ul>
			<p>Because of all the information that it covers, the Operator CSV is usually very long and takes time to prepare properly. However, a well-defined CSV helps an Operator reach a much wider audience. Details of Operator CSVs will be covered in a later chapter.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Defining Operator functions with the Capability Model</h1>
			<p>The Operator Framework defines a<a id="_idIndexMarker041"/> Capability Model (<a href="https://operatorframework.io/operator-capabilities/">https://operatorframework.io/operator-capabilities/</a>) that categorizes Operators based <a id="_idIndexMarker042"/>on their functionality and design. This model helps to <a id="_idIndexMarker043"/>break down Operators based on their maturity, and also describes the extent of an Operator's interoperability with OLM and the capabilities users can expect when using the Operator.</p>
			<p>The <a id="_idIndexMarker044"/>Capability Model is divided into five hierarchical levels. Operators can be published at any one of these levels and, as they grow, may evolve and graduate from one level to the next as features and functionality are added. In addition, the levels are cumulative, with each level generally encompassing all features of the levels below it. </p>
			<p>The current level of an Operator is part of the CSV, and this level is displayed on its OperatorHub listing. The level is based on somewhat subjective yet guided criteria and is purely an informational metric. </p>
			<p>Each level has specific functionalities that define it. These functionalities are broken down into <em class="italic">Basic Install</em>, <em class="italic">Seamless Upgrades</em>, <em class="italic">Full Lifecycle</em>, <em class="italic">Deep Insights</em>, and <em class="italic">Auto Pilot</em>. The specific levels of the Capability Model are outlined here:</p>
			<ol>
				<li><strong class="bold">Level I—Basic Install</strong>: This<a id="_idIndexMarker045"/> level represents the most basic of Operator capabilities. At <em class="italic">Level I</em>, an Operator is only capable of installing its Operand in the cluster and conveying the status of the workload to cluster administrators. This means that it can set up the basic resources required for an application and report when those resources are ready to be used by the cluster. </li>
			</ol>
			<p>At <em class="italic">Level I</em>, an Operator also allows for simple configuration of the Operand. This configuration is specified through the Operator's Custom Resource. The Operator is responsible for reconciling the configuration specifications with the running Operand workload. However, it may not be able to react if the Operand reaches a failed state, whether due to malformed configuration or outside influence. </p>
			<p>Going back to our example web application from the start of the chapter, a <em class="italic">Level I</em> Operator for this application would handle the basic setup of the workloads and nothing else. This is good for a simple application that needs to be quickly set up on many different clusters, or one that should be easily shared with users for them to install themselves.</p>
			<ol>
				<li value="2"><strong class="bold">Level II—Seamless Upgrades</strong>: Operators at <em class="italic">Level II</em> offer the features of basic installation, with added functionality around upgrades. This includes upgrades for the Operand but also upgrades for the Operator itself. </li>
			</ol>
			<p>Upgrades<a id="_idIndexMarker046"/> are a critical part of any application. As bug fixes are implemented and more features are added, being able to smoothly transition between versions helps ensure application uptime. An Operator that handles its own upgrades can either upgrade its Operand when it upgrades itself or manually upgrade its Operand by modifying the Operator's Custom Resource. </p>
			<p>For <a id="_idIndexMarker047"/>seamless upgrades, an Operator must also be able to upgrade older versions of its Operand (which may exist because they were managed by an older version of the Operator). This kind of backward compatibility is essential for both upgrading to newer versions and handling rollbacks (for example, if a new version introduces a high-visibility bug that can't wait for an eventual fix to be published in a patch version). </p>
			<p>Our example <a id="_idIndexMarker048"/>web application Operator could offer the same set of features. This means that if a new version of the application were released, the Operator could handle upgrading the deployed instances of the application to the newer version. Or, if changes were made to the Operator itself, then it could manage its own upgrades (and later upgrade the application, regardless of version skew between Operator and Operand).</p>
			<ol>
				<li value="3"><strong class="bold">Level III—Full Lifecycle</strong>: <em class="italic">Level III</em> Operators <a id="_idIndexMarker049"/>offer at least one out of a list of Operand lifecycle management features. Being able to offer management during the Operand's lifecycle implies that the Operator is more than just passively operating on a workload in a <em class="italic">set and forget</em> fashion. At Level III, Operators are actively contributing to the ongoing function of the Operand. </li>
			</ol>
			<p>The features relevant to the lifecycle management of an Operand include the following:</p>
			<ul>
				<li>The ability to create and/or restore backups of the Operand.</li>
				<li>Support for more complex configuration options and multistep workflows.</li>
				<li>Failover and failback mechanisms<a id="_idIndexMarker050"/> for <strong class="bold">disaster recovery</strong> (<strong class="bold">DR</strong>). When the Operator encounters an error (either in itself or the Operand), it needs to be able to either re-route to a backup process (fail over) or roll the system back to its last known functioning state (fail back).</li>
				<li>The ability to manage clustered Operands, and—specifically—support for adding and removing members to and from Operands. The Operator should be capable of considering quorum for Operands that run multiple replicas.</li>
				<li>Similarly, support for scaling an Operand with worker instances that operate with read-only functionality.</li>
			</ul>
			<p>Any <a id="_idIndexMarker051"/>Operator that implements one or more of these features can be considered to be at least a Level III Operator. The simple web application Operator could take advantage of a few of these, such as DR and<a id="_idIndexMarker052"/> scaling. As the user base grows and resources demands increase, an administrator could instruct the Operator to scale the application with additional replica Pods to handle the increased load. </p>
			<p>Should any of the Pods fail during this process, the Operator would be smart enough to know to fail over to a different Pod or cluster zone entirely. Alternatively, if a new version of the web app was released that introduced an unexpected bug, the Operator could be aware of the previous successful version and provide ways to downgrade its Operand workloads if an administrator noticed the error.</p>
			<ol>
				<li value="4"><strong class="bold">Level IV—Deep Insights</strong>: While the previous levels focus primarily on Operator features<a id="_idIndexMarker053"/> as they relate to functional interaction with the application workload, Level IV emphasizes monitoring and metrics. This means an Operator is capable of providing measurable insights to the status of both itself and its Operand. </li>
			</ol>
			<p>Insights may be seen as less important from a development perspective relative to features and bug fixes, but they are just as critical to an application's success. Quantifiable reports about an application's performance can drive ongoing development<a id="_idIndexMarker054"/> and highlight areas that need improvement. Having a measurable system to push these efforts allows a way to scientifically prove or disprove which changes have an effect. </p>
			<p>Operators most commonly provide their insights in the form of metrics. These metrics are usually compatible with metrics aggregation servers such as Prometheus. (Interestingly enough, Red Hat publishes<a id="_idIndexMarker055"/> an Operator for Prometheus that is a Level IV Operator. That Operator is available on OperatorHub at <a href="https://operatorhub.io/operator/prometheus">https://operatorhub.io/operator/prometheus</a>.) </p>
			<p>However, Operators can provide insights through other means as well. These include alerts and Kubernetes Events. Events are built-in cluster resource objects that are used by core Kubernetes objects and controllers. </p>
			<p>Another key <a id="_idIndexMarker056"/>insight that Level IV Operators report is the performance of the Operator and Operand. Together, these insights help inform administrators about the health of their clusters. </p>
			<p>Our simple web <a id="_idIndexMarker057"/>application Operator could provide insights about the performance of the Operand. Requests to the app would provide information about the current and historic load on the cluster. Additionally, since the Operator can identify failed states at this point, it could trigger an alert when the application is unhealthy. Many alerts would indicate a reliability issue that would gain the attention of an administrator.</p>
			<ol>
				<li value="5"><strong class="bold">Level V—Auto Pilot</strong>: Level V is<a id="_idIndexMarker058"/> the most sophisticated level for Operators. It includes Operators that offer the highest capabilities, in addition to the features in all four previous levels. This level is called <em class="italic">Auto Pilot</em> because the features that define it focus on being able to run almost entirely autonomously. These capabilities include Auto Scaling, Auto-Healing, Auto-Tuning, and Abnormality Detection. </li>
			</ol>
			<p>Auto Scaling<a id="_idIndexMarker059"/> is the ability for an Operator to detect the need to scale an application up or down based on demand. By measuring the current load and performance, an Operator can determine whether more or fewer resources are necessary to satisfy the current usage. Advanced Operators can even try to predict the need to scale based on current and past data. </p>
			<p>Auto-Healing <a id="_idIndexMarker060"/>Operators can react to applications that are reporting unhealthy conditions and work to correct them (or, at least, prevent them from getting any worse). When an Operand is reporting an error, the Operator should take reactive steps to rectify the failure. In addition, Operators can use current metrics to proactively prevent an Operand from transitioning to a failure state. </p>
			<p>Auto-Tuning <a id="_idIndexMarker061"/>means that an Operator can dynamically modify an Operand for peak performance. This involves tuning the settings of an Operand automatically. It can even include complex operations such as shifting workloads to entirely different nodes that are better suited than their current nodes. </p>
			<p>Finally, Abnormality Detection<a id="_idIndexMarker062"/> is the capability of an Operator to identify suboptimal or off-pattern behavior in an Operand. By measuring performance, an Operator has a picture of the application's current and historical levels of functioning. That data can be compared to a manually defined minimum expectation or used to dynamically inform the Operator of that expectation. </p>
			<p>All of these features are heavily dependent upon the use of metrics to automatically inform the Operator of the need to act upon itself or its Operand. Therefore, a Level V Operator is an inherent progression from Level IV, which is the level at which an Operator exposes advanced metrics. </p>
			<p>At Level V, the <a id="_idIndexMarker063"/>simple web application Operator would manage most of the aspects of the application for us. It has insights into <a id="_idIndexMarker064"/>the current number of requests, so it can scale up copies of the app on demand. If this scaling starts to cause errors (for example, too many concurrent database calls), it can identify the number of failing Pods and prevent further scaling. It would also attempt to modify parameters of the web app (such as request timeouts) to help rectify the situation and allow the auto-scaling to proceed. When the load peak subsided, the Operator would then automatically scale down the application to its baseline service levels.</p>
			<p>Levels I and II (<em class="italic">Basic Install</em> and <em class="italic">Seamless Upgrades</em>) can be used with the three facets of the Operator SDK: Helm, Ansible, and Go. However, Level III and above (<em class="italic">Full Lifecycle</em>, <em class="italic">Deep Insights</em>, and <em class="italic">Auto Pilot</em>) are only possible with Ansible and Go. This is because the functionality at these higher levels requires more intricate logic than what is available through Helm charts alone. </p>
			<p>We have now explained the three main pillars of the Operator Framework: Operator SDK, OLM, and OperatorHub. We learned how each contributes different helpful features to the development and usage of Operators. We also learned about the Capability Model, which serves as a reference for the different levels of functionality that Operators can have. In the next section, we'll apply this knowledge to a sample application.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Using Operators to manage applications</h1>
			<p>Clearly, working<a id="_idIndexMarker065"/> with Operators involves more than simply reconciling a cluster state. The Operator Framework is an encompassing<a id="_idIndexMarker066"/> platform for Kubernetes developers and users to solve unique problems, which makes Kubernetes so flexible.</p>
			<p>Cluster administrators' first step in the Operator Framework is usually either with the Operator SDK, to develop their own Operator if there are no existing Operators that address their needs, or OperatorHub if there are.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Summarizing the Operator Framework</h2>
			<p>When<a id="_idIndexMarker067"/> developing an Operator from scratch, there are three choices for development methods: Go, Ansible, or Helm. However, using Ansible or Helm alone will ultimately limit the Operator's capabilities to the most basic levels of functionality.</p>
			<p>If the developer wishes to share their Operator, they will need to package it into the standard manifest bundle for OperatorHub. Following a review, their Operator will be available publicly for other users to download and install in their own clusters.</p>
			<p>OLM then makes it easy for users to launch Operators in a cluster. These Operators can be sourced from OperatorHub or written from scratch. Either way, OLM makes Operator installation, upgrades, and management much easier. It also provides several stability benefits when working with many Operators. You can see the relationship between the three services in the following diagram:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B18147_Figure_1.3.jpg" alt="Figure 1.3 – The relationship between the Operator SDK, OperatorHub, and OLM"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – The relationship between the Operator SDK, OperatorHub, and OLM</p>
			<p>Each of these <a id="_idIndexMarker068"/>pillars provides distinct functions that aid in the development of Operators. Together, they comprise the foundation of the Operator Framework. Utilization of these pillars is the key distinguishing factor between an Operator and a normal Kubernetes controller. To summarize, while every Operator is essentially a controller, not every controller is an Operator.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Applying Operator capabilities</h2>
			<p>Revisiting the <a id="_idIndexMarker069"/>first example in this chapter, the idea of a simple application with three Pods and a Persistent Volume was examined without Operator management. This application relied on optimistic uptime and future-proof design to run continuously. In real-world deployments, these ideas are unfortunately unreasonable. Designs evolve and change, and unforeseeable failures bring applications down. But how could an Operator help this app persist in an unpredictable world?</p>
			<p>By defining a single declarative configuration, this Operator could control various settings of the application deployment in one spot. This is the reason Operators are built on CRDs. These custom objects allow developers and users to easily interact with their Operators just as if they were native Kubernetes objects. So, the first step in writing an Operator to manage our simple web application would be to define a basic code structure with a CRD that has all the settings we think we'll need. Once we have done this, the new diagram of our application will look like this:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B18147_Figure_1.4.jpg" alt="Figure 1.4 – In the new app layout, the cluster administrator only interacts with the Operator; the Operator then manages the workload"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – In the new app layout, the cluster administrator only interacts with the Operator; the Operator then manages the workload</p>
			<p>This shows <a id="_idIndexMarker070"/>how the details of the Operand deployment have been abstracted away from requiring manual administrator control, and the great part about CRDs is that more settings can be added in later versions of the Operator as our app grows. A few examples of settings to start with could be these:</p>
			<ul>
				<li>Database access information</li>
				<li>Application behavior settings</li>
				<li>Log level</li>
			</ul>
			<p>While writing our Operator code, we'll also want to write logic for things such as metrics, error handling, and reporting. The Operator can also start to bidirectionally communicate with the Operand. This means that not only can it install and update the Operand, but <a id="_idIndexMarker071"/>it can receive communication back from the Operand about its status and report that as well.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>
			<p>In this chapter, we introduced the fundamental concepts of the Operator Framework. These include the Operator SDK, OLM, and OperatorHub. In addition to the development and distribution pillars of the Operator Framework, the Capability Model provides an additional tool for measuring the functionality of an Operator. Throughout this book, we will be exploring these components in deeper detail to get a hands-on understanding of how they actually work.</p>
			<p>We began this chapter by examining some of the problems that arise when manually managing applications and clusters without Operators. This was done through the lens of a simple generic web application based on a couple of Pods and a Persistent Volume. The main difficulties in managing something such as this include the time and resources required to debug applications. This is especially important in cloud applications, where <strong class="bold">high availability</strong> (<strong class="bold">HA</strong>) and consistent uptime are top priorities.</p>
			<p>We then looked at how each pillar of the Operator Framework addresses the biggest difficulties of application management. These pillars begin with the Operator SDK, which streamlines Operator development. This allows developers to begin iterating on automated reconciliation logic to get their Operators written quickly. It also provides commands to interact with OLM, which is the next pillar of the framework.</p>
			<p>OLM exists to help administrators install and curate Operators within a cluster. It provides dependency management and notifies administrators of conflicting APIs to promote cluster stability. It also serves as a local catalog of installed Operators, which is useful for users on the cluster.</p>
			<p>Next, we examined OperatorHub and its role in the broader open source Kubernetes community. As an open index of freely available Operators, OperatorHub serves to promote the adoption and maintenance of Operators. It consumes the same manifests as OLM to provide a standardized set of metadata about each Operator to users.</p>
			<p>Finally, the Capability Model summarizes the maturity of an Operator based on the functionality it provides. This is helpful to users, but it also serves as a convenient roadmap for developers to plan features for their Operators.</p>
			<p>To summarize each of these components, we revisited the original application example presented in the first section. We showed that, with an Operator in place to manage the application, cluster administrators do not need to be keenly aware of the architectural details of the app to keep it running. Instead, this information and controls are abstracted away behind the Operator's interface.</p>
			<p>With all of this in mind, we move on to the next chapters to explore each of these topics in depth. We will also be following detailed examples to build our own sample Operator. In the next chapter, we'll begin looking at the important concepts of designing an Operator based on its interactions with a Kubernetes cluster.</p>
		</div>
	</body></html>