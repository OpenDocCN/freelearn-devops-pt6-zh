- en: Getting Started with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 入门
- en: 'So far, we''ve learned about the benefits that containers can bring us, but
    what if we need to scale out our services to meet the needs of our business? Is
    there a way to build services across multiple machines without dealing with cumbersome
    network and storage settings? Is there an easy way to manage and roll out our
    microservices with a different service cycle? This is where Kubernetes comes into
    play. In this chapter, we''ll look at the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了容器可以带来的好处，但如果我们需要扩展我们的服务以满足业务需求该怎么办？有没有一种方法可以在不处理繁琐的网络和存储设置的情况下，在多个机器上构建服务？有没有一种简便的方式来管理并推出具有不同服务周期的微服务？这就是
    Kubernetes 发挥作用的地方。在本章中，我们将讨论以下概念：
- en: Understanding Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kubernetes
- en: Components of Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 组件
- en: Kubernetes resources and their configuration files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 资源及其配置文件
- en: How to launch the kiosk application using Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Kubernetes 启动自助服务应用程序
- en: Understanding Kubernetes
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes
- en: Kubernetes is a platform for managing containers across multiple hosts. It provides
    lots of management features for container-oriented applications, such as auto-scaling,
    rolling deployments, compute resources, and storage management. Like containers,
    it's designed to run anywhere, including on bare metal, in our data center, in
    the public cloud, or even in the hybrid cloud.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个用于跨多个主机管理容器的平台。它为面向容器的应用提供了许多管理功能，如自动扩展、滚动部署、计算资源和存储管理。像容器一样，它设计为可以在任何地方运行，包括裸机、我们的数据中心、公共云，甚至是混合云中。
- en: 'Kubernetes fulfills most application container operational needs. Its highlights
    include the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 满足大多数应用容器操作需求。其亮点包括以下内容：
- en: Container deployment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器部署
- en: Persistent storage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化存储
- en: Container health monitoring
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器健康监控
- en: Compute resource management
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算资源管理
- en: Auto-scaling
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展
- en: High availability by cluster federation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集群联邦实现高可用性
- en: With Kubernetes, we can manage containerized applications easily. For example,
    by creating `Deployment`, we can roll out, roll over, or roll back selected containers
    ([Chapter 9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*)
    with just a single command. Containers are considered ephemeral. If we only have
    one host, we could mount host volumes into containers to preserve data. In the
    cluster world, however, a container might be scheduled to run on any host in the
    cluster. How do we mount a volume without specifying which host it's run on? Kubernetes
    **volumes** and **persistent volumes** were introduced to solve this problem ([Chapter
    4](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml), *Managing Stateful Workloads*).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes，我们可以轻松管理容器化应用。例如，通过创建 `Deployment`，我们可以使用单一命令推出、滚动或回滚选定的容器（[第9章](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml)，*持续交付*）。容器被视为临时的。如果我们只有一个主机，我们可以将主机卷挂载到容器中以保持数据。但在集群环境中，容器可能会被调度到集群中的任何主机上运行。那么，如何在不指定主机的情况下挂载卷呢？Kubernetes
    **卷** 和 **持久化卷** 被引入来解决这个问题（[第4章](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml)，*管理有状态工作负载*）。
- en: The lifetime of containers might be short; they may be killed or stopped anytime
    when they exceed the resource limit. How do we ensure our services are always
    on and are served by a certain number of containers? Deployment in Kubernetes
    ensures that a certain number of groups of containers are up and running. Kubernetes
    also supports **liveness probes** to help you define and monitor your application's
    health. For better resource management, we can define the maximum capacity for
    Kubernetes nodes and the resource limit for each group of containers (also known
    as **pods**). The Kubernetes scheduler will select a node that fulfills the resource
    criteria to run the containers. We'll learn about this further in [Chapter 8](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml), *Resource
    Management and Scaling*. Kubernetes also provides an optional horizontal pod auto-scaling
    feature, which we can use to scale a pod horizontally by core or custom metrics.
    Kubernetes is also designed to have **high availability** (**HA**). We're able
    to create multiple master nodes and prevent single points of failure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的生命周期可能很短；当它们超出资源限制时，它们可能随时被杀死或停止。我们如何确保我们的服务始终可用，并由一定数量的容器提供服务？在 Kubernetes
    中，部署操作确保一定数量的容器组正常运行。Kubernetes 还支持 **存活探针**，以帮助定义和监控应用程序的健康状况。为了更好地管理资源，我们可以为
    Kubernetes 节点定义最大容量和每组容器（也称为 **Pods**）的资源限制。Kubernetes 调度器将选择满足资源条件的节点来运行容器。我们将在[第8章](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml)，*资源管理与扩展*中进一步了解此内容。Kubernetes
    还提供了一个可选的水平 Pod 自动缩放功能，可以按核心或自定义指标水平扩展 Pod。Kubernetes 还设计具有 **高可用性**（**HA**）。我们可以创建多个主控节点以防止单点故障。
- en: Kubernetes components
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 组件
- en: 'Kubernetes includes two major players:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 包括两个主要组件：
- en: '**Masters**: The master is the heart of Kubernetes; it controls and schedules
    all of the activities in the cluster'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主控节点**：主控节点是 Kubernetes 的核心；它控制并安排集群中的所有活动。'
- en: '**Nodes**: Nodes are the workers that run our containers'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：节点是运行我们容器的工作节点'
- en: Master components
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主控节点组件
- en: 'The master includes the **API Server**, the **Controller Manager**, the **Scheduler**,
    and **etcd**. All components can run on different hosts with clustering. However,
    in this case, we''ll make all of the components run on the same node as shown
    in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 主控节点包括 **API 服务器**、**控制器管理器**、**调度器** 和 **etcd**。所有组件可以在不同的主机上运行，并支持集群化。但在本例中，我们将所有组件都运行在同一节点上，如下图所示：
- en: '![](img/a18ae85c-32c3-49cc-9d9f-4ffe4cb8cf54.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a18ae85c-32c3-49cc-9d9f-4ffe4cb8cf54.png)'
- en: Master components
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 主控节点组件
- en: API server (kube-apiserver)
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 服务器（kube-apiserver）
- en: The API server provides an HTTP/HTTPS server, which provides a RESTful API for
    the components in the Kubernetes master. For example, we could use `GET` to get
    the resource status or `POST` to create a new resource. We can also watch for
    updates for resources. The API server stores the object information into etcd,
    which is Kubernetes' backend data store.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务器提供 HTTP/HTTPS 服务器，为 Kubernetes 主控节点中的组件提供 RESTful API。例如，我们可以使用 `GET`
    获取资源状态或使用 `POST` 创建新资源。我们还可以监听资源的更新。API 服务器将对象信息存储到 etcd 中，这是 Kubernetes 的后端数据存储。
- en: Controller manager (kube-controller-manager)
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器管理器（kube-controller-manager）
- en: The controller manager is a set of control loops that watch the changes in the
    API server and ensure the cluster is in the desired state. For example, the deployment
    controller ensures that the whole deployment is run on the desired amount of containers.
    The node controller responds and evicts the pod when the nodes go down. The endpoint
    controller is used to create a relationship between services and pods. The service
    account and the token controller are used to create a default account and API
    access tokens.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器是一组控制循环，负责监视 API 服务器中的更改，并确保集群处于期望的状态。例如，部署控制器确保整个部署在所需数量的容器上运行。节点控制器在节点宕机时响应并清除
    Pod。端点控制器用于创建服务和 Pod 之间的关系。服务账户和令牌控制器用于创建默认账户和 API 访问令牌。
- en: To accommodate different development paces and release cycles from different
    cloud providers, from Kubernetes version 1.6, cloud provider-specific logic was
    moved from `kube-controller-manager` to the cloud controller manager (`cloud-controller-manager`).
    This was promoted to beta in version 1.11.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应来自不同云提供商的不同开发速度和发布周期，从 Kubernetes 版本 1.6 开始，特定于云提供商的逻辑从 `kube-controller-manager`
    移动到了云控制器管理器 (`cloud-controller-manager`)。这在 1.11 版本中升级为 beta 版本。
- en: etcd
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: etcd
- en: etcd is an open source distributed key-value store ([https://coreos.com/etcd](https://coreos.com/etcd)).
    Kubernetes stores all of the RESTful API objects here. etcd is responsible for
    storing and replicating data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: etcd 是一个开源分布式键值存储系统（[https://coreos.com/etcd](https://coreos.com/etcd)）。Kubernetes
    在这里存储所有的 RESTful API 对象。etcd 负责存储和复制数据。
- en: Scheduler (kube-scheduler)
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器（kube-scheduler）
- en: The scheduler determines which nodes are suitable candidates for pods to run
    on. It uses not only resource capacity and the balance of the resource utilization
    on the node but also node affinity, taints, and toleration. For more information,
    refer to [Chapter 8](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml)*,* *Resource
    Management and Scaling*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器决定哪些节点是 pod 运行的合适候选节点。它不仅考虑节点的资源容量和资源利用率平衡，还会考虑节点亲和性、污点和容忍度。更多信息请参见[第八章](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml)，*资源管理与扩展*。
- en: Node components
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点组件
- en: 'Node components are provisioned and run on every node, which report the runtime
    status of the pod to the **master**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点上都会提供并运行节点组件，这些组件将 pod 的运行时状态报告给 **master**：
- en: '![](img/ac50f8a6-f1f5-4154-b21b-1ca694c4ea13.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac50f8a6-f1f5-4154-b21b-1ca694c4ea13.png)'
- en: Node components
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 节点组件
- en: Kubelet
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubelet
- en: Kubelet is a major process in the nodes. It reports node activities back to
    `kube-apiserver` periodically, including pod health, node health, and liveness
    probe. As the preceding diagram shows, it runs containers via container runtimes,
    such as Docker or rkt.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubelet 是节点中的一个重要进程。它定期向 `kube-apiserver` 报告节点活动，包括 pod 健康状态、节点健康状态以及存活探针。如前图所示，它通过容器运行时（如
    Docker 或 rkt）来运行容器。
- en: Proxy (kube-proxy)
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理（kube-proxy）
- en: 'The proxy handles the routing between a pod load balancer (also known as a **service**)
    and pods. It also provides routing from external internet to services. There are
    three proxy modes: `userspace`, `iptables`, and `ipvs`. The `userspace` mode creates
    a large overhead by switching the kernel space and user space. The `iptables`
    mode, on the other hand, is the latest default proxy mode. It changes the `iptables` Network
    Address Translation (NAT: [https://en.wikipedia.org/wiki/Network_address_translation](https://en.wikipedia.org/wiki/Network_address_translation))
    in Linux to achieve routing TCP and UDP packets across all containers. **IP Virtual
    Servers** (**IPVS**) was **general available** (**GA**) in Kubernetes 1.11 and
    is used to address performance degradations when running 1,000+ services in a
    cluster. It runs on a host and acts as a load balancer, forwarding the connection
    to real servers. IPVS mode will fall back to `iptables` in some scenarios; please
    refer to [https://github.com/kubernetes/kubernetes/tree/master/pkg/proxy/ipvs](https://github.com/kubernetes/kubernetes/tree/master/pkg/proxy/ipvs)
    for more detailed information.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '代理负责 pod 负载均衡器（也称为 **service**）与 pods 之间的路由，它还提供从外部互联网到服务的路由。有三种代理模式：`userspace`、`iptables`
    和 `ipvs`。`userspace` 模式通过切换内核空间和用户空间带来较大的开销。而 `iptables` 模式是最新的默认代理模式，它通过修改 Linux
    中的 `iptables` 网络地址转换（NAT: [https://en.wikipedia.org/wiki/Network_address_translation](https://en.wikipedia.org/wiki/Network_address_translation)）来实现跨所有容器的
    TCP 和 UDP 包路由。**IP 虚拟服务器**（**IPVS**）在 Kubernetes 1.11 中**正式发布**（**GA**），旨在解决在集群中运行超过
    1,000 个服务时的性能下降问题。它运行在主机上并充当负载均衡器，将连接转发到真实服务器。在某些情况下，IPVS 模式会回退到 `iptables`；有关更多详细信息，请参阅
    [https://github.com/kubernetes/kubernetes/tree/master/pkg/proxy/ipvs](https://github.com/kubernetes/kubernetes/tree/master/pkg/proxy/ipvs)。'
- en: Docker
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: As described in [Chapter 2](05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml), *DevOps
    with Containers*, Docker is a container runtime implementation. Kubernetes uses
    Docker as a default container engine, and it also supports other container runtimes,
    such as rkt ([https://coreos.com/rkt/](https://coreos.com/rkt/)) and runc ([https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第二章](05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml)《*使用容器进行 DevOps*》中所述，Docker
    是一种容器运行时实现。Kubernetes 使用 Docker 作为默认的容器引擎，也支持其他容器运行时，例如 rkt（[https://coreos.com/rkt/](https://coreos.com/rkt/)）和
    runc（[https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)）。
- en: The interaction between the Kubernetes master and nodes
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes master 与节点之间的交互
- en: As we can see in the following diagram, the client uses **kubectl**, which is
    a command-line interface, to send requests to the **API Server**. The **API Server**,
    a hub between the master components, will respond to the client requests and push
    and pull the object information from etcd. If a new task is created, such as run
    pods, the scheduler will determine which node should be assigned to do that task.
    The **Controller Manager** monitors the running tasks and responds if any undesired
    state occurs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下图中看到的，客户端使用 **kubectl**（一个命令行界面）向 **API 服务器** 发送请求。**API 服务器** 作为主节点组件之间的中枢，将响应客户端请求，并从
    etcd 中推送和拉取对象信息。如果创建了一个新任务，如运行 pod，调度器将决定将任务分配给哪个节点。**控制器管理器** 监控运行中的任务，并在出现任何不期望的状态时做出响应。
- en: 'The **API Server** fetches the logs from pods via the **kubelet**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 服务器** 通过 **kubelet** 获取 pod 的日志：'
- en: '![](img/61844dcf-b0e1-44f6-966a-ea04715091c4.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61844dcf-b0e1-44f6-966a-ea04715091c4.png)'
- en: Interaction between master and nodes
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点与节点之间的交互
- en: Getting started with Kubernetes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 入门
- en: 'In this section, we''ll learn how to set up a single-node cluster. Then, we''ll
    learn how to interact with Kubernetes via its command-line tool: kubectl. We''ll
    go through all of the important Kubernetes API objects and their expressions in
    YAML format, which is the input to kubectl. We''ll then see how kubectl sends
    requests to the API server to create the desired objects accordingly.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何设置单节点集群。接着，我们将学习如何通过 Kubernetes 的命令行工具 kubectl 进行交互。我们将通过所有重要的 Kubernetes
    API 对象及其 YAML 格式的表达式，了解它们作为 kubectl 输入的作用。然后，我们将看到 kubectl 如何向 API 服务器发送请求，以相应地创建所需的对象。
- en: Preparing the environment
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境准备
- en: Firstly, kubectl has to be installed. In major Linux distributions (such as
    Ubuntu or CentOS), you can just search for and install the package named `kubectl`
    via the package manager. In macOS, we can choose to use Homebrew ([https://brew.sh/](https://brew.sh/)) to
    install it. Homebrew is a useful package manager in macOS. We can easily install Homebrew
    via the `/usr/bin/ruby -e "$(curl` `-fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"` command.
    Then, we can run brew install kubernetes-cli to install kubectl via Homebrew.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要安装 kubectl。在主要的 Linux 发行版（如 Ubuntu 或 CentOS）中，你可以通过包管理器搜索并安装名为 `kubectl`
    的包。在 macOS 中，我们可以选择使用 Homebrew ([https://brew.sh/](https://brew.sh/)) 来安装它。Homebrew
    是 macOS 中一个非常实用的包管理工具。我们可以通过执行 `/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"`
    命令轻松安装 Homebrew。然后，我们可以通过 `brew install kubernetes-cli` 使用 Homebrew 安装 kubectl。
- en: Let's now start to provision a Kubernetes cluster. The easiest way to do this
    is to run minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)),
    which is a tool to run Kubernetes on a single-node locally. It can be run on Windows,
    Linux, and macOS. In the following example, we'll run on macOS. Minikube will
    launch a VM with Kubernetes installed. We'll then be able to interact with it
    via kubectl.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始配置一个 Kubernetes 集群。最简单的方法是运行 minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))，它是一个在单节点本地运行
    Kubernetes 的工具。它可以在 Windows、Linux 和 macOS 上运行。在接下来的示例中，我们将在 macOS 上运行。Minikube
    将启动一个虚拟机，并安装 Kubernetes。我们随后可以通过 kubectl 与其交互。
- en: Note that minikube isn't suitable for production or any heavy-load environment.
    It has some limitations due to its single node nature. We'll learn how to run
    a real cluster in [Chapter 10](f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml), *Kubernetes
    on AWS*,[Chapter 11](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml), *Kubernetes
    on GCP*, and [Chapter 12](89891610-4ca4-4216-9d76-2613d186421c.xhtml), *Kubernetes
    on Azure*, instead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，minikube 不适用于生产环境或任何重载环境。由于它是单节点的，存在一些限制。我们将在[第 10 章](f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml)，*Kubernetes
    on AWS*，[第 11 章](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml)，*Kubernetes on GCP*，以及[第
    12 章](89891610-4ca4-4216-9d76-2613d186421c.xhtml)，*Kubernetes on Azure*中学习如何运行真实的集群。
- en: Before installing minikube, we have to install some dependencies first. Minikube's
    official GitHub repository ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    lists the dependencies and drivers for the different platforms. In our case, we're
    using VirtualBox ([https://www.virtualbox.org/](https://www.virtualbox.org/))
    as the driver in macOS. You're free to use other drivers; visit the preceding
    minikube GitHub link to find more options.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 minikube 之前，我们需要先安装一些依赖项。Minikube 的官方 GitHub 仓库 ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    列出了不同平台的依赖项和驱动程序。在我们的案例中，我们在 macOS 上使用 VirtualBox ([https://www.virtualbox.org/](https://www.virtualbox.org/))
    作为驱动程序。你可以自由选择其他驱动程序；请访问上面的 minikube GitHub 链接查找更多选项。
- en: 'After downloading and installing VirtualBox from its official website, we''re
    ready to go. We can install minikube via `brew cask install minikube`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装 VirtualBox 后，我们就准备好了。我们可以通过 `brew cask install minikube` 安装 minikube：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After minikube is installed, we can start the cluster via the `minikube start`
    command. This will launch a Kubernetes cluster locally. At the time of writing,
    the default Kubernetes version that minikube v0.30.0 supports is `v.1.12.0`. You
    also can add the `--kubernetes-version` argument to specify the particular Kubernetes
    version you''d like to run. For example, assume we want to run a cluster with
    the version v1.12.1:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 minikube 后，我们可以通过 `minikube start` 命令启动集群。这将启动一个本地 Kubernetes 集群。在撰写本文时，minikube
    v0.30.0 支持的默认 Kubernetes 版本是 `v.1.12.0`。你也可以添加 `--kubernetes-version` 参数来指定你想运行的特定
    Kubernetes 版本。例如，假设我们想运行版本为 v1.12.1 的集群：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will then proceed to start a VM named `minikube` in VirtualBox and set
    up the cluster via `kubeadm`, a Kubernetes provisioning tool. It''ll also set
    up `kubeconfig`, which is a configuration file to define the context and authentication
    settings of the cluster. With `kubeconfig`, we''re able to switch to different
    clusters via the `kubectl` command. We could use the `kubectl config view` command
    to see the current settings in `kubeconfig`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个名为 `minikube` 的虚拟机，并通过 `kubeadm`（一个 Kubernetes 配置工具）设置集群。它还将设置 `kubeconfig`，这是一个配置文件，用于定义集群的上下文和身份验证设置。通过
    `kubeconfig`，我们能够通过 `kubectl` 命令切换到不同的集群。我们可以使用 `kubectl config view` 命令查看 `kubeconfig`
    中的当前设置：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we're currently using the `minikube` context. The context is a combination
    of the authentication information and the cluster connection information. You
    could use `kubectl config` use-context `$context` to forcibly switch the context
    if you have more than one context.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们当前使用的是`minikube`上下文。上下文是身份验证信息和集群连接信息的组合。如果你有多个上下文，可以使用`kubectl config`
    use-context `$context` 强制切换上下文。
- en: kubectl
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubectl
- en: '`kubectl` is the command-line tool to manage Kubernetes clusters. The most
    general usage of `kubectl` is to check the `version` of the cluster:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是用于管理 Kubernetes 集群的命令行工具。`kubectl` 最常见的用法是检查集群的 `version`：'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then know our server version is upto date, which is the latest at the time
    of writing—version 1.12.0\. The general syntax of `kubectl` is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们知道我们的服务器版本是最新的，即撰写本文时的最新版本——版本 1.12.0。`kubectl` 的一般语法如下：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`command` indicates the operation you want to perform. If you type `kubectl
    help` in Terminal, it''ll show the supported commands. `type` means the resource
    type. We''ll learn about the major resource types in the next section. `name`
    is how we name our resources. It''s always good practice to have clear and informative
    names throughout. For the `flags`, if you type `kubectl options`, the `stdout `will
    show all of the flags you could pass on.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`command` 表示你想执行的操作。如果你在终端输入 `kubectl help`，它会显示支持的命令。`type` 表示资源类型。我们将在下一节学习主要的资源类型。`name`
    是我们如何命名资源的。最好始终使用清晰且具有信息性的名称。对于 `flags`，如果你输入 `kubectl options`，`stdout` 将显示你可以传递的所有标志。'
- en: 'We can always add `--help` to get more detailed information on specific commands,
    as in the example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随时添加 `--help` 来获取关于特定命令的更详细信息，如以下示例所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can then get examples and supported options in the `kubectl logs` command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `kubectl logs` 命令中获得示例和支持的选项。
- en: Kubernetes resources
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 资源
- en: Kubernetes objects are the entries in the cluster, which are stored in etcd.
    They represent the desired state of your cluster. When we create an object, we
    send the request to the API server by kubectl or a RESTful API. The API server
    will check whether the request is valid, store the state in etcd, and interact
    with other master components to ensure the object exists. Kubernetes uses namespaces
    to isolate the objects virtually, so we could create different namespaces for
    different teams, usages, projects, or environments. Every object has its own name
    and unique ID. Kubernetes also supports labels and annotations to let us tag our
    objects. Labels in particular can be used to group the objects together.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 对象是集群中的条目，存储在etcd中。它们表示集群的期望状态。当我们创建一个对象时，我们通过 kubectl 或 RESTful
    API 向 API 服务器发送请求。API 服务器会检查请求是否有效，将状态存储在etcd中，并与其他主控组件交互以确保对象的存在。Kubernetes 使用命名空间将对象虚拟隔离，因此我们可以为不同的团队、用途、项目或环境创建不同的命名空间。每个对象都有自己的名称和唯一
    ID。Kubernetes 还支持标签和注解，让我们可以给对象打标签。特别是标签，可以用来将对象分组。
- en: Kubernetes objects
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 对象
- en: The object `spec` describes the desired state of Kubernetes objects. Most of
    the time, we write an object `spec` and send it to the API server via `kubectl`.
    Kubernetes will try to fulfill that desired `state` and `update` the object's
    status.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的 `spec` 描述了 Kubernetes 对象的期望状态。大多数时候，我们编写对象的 `spec` 并通过 `kubectl` 发送给 API
    服务器。Kubernetes 会尽力实现该期望的 `state` 并 `update` 对象的状态。
- en: 'The object `spec` could be written in YAML ([http://www.yaml.org/](http://www.yaml.org/))
    or JSON ([http://www.json.org/](http://www.json.org/)). YAML is more common in
    the Kubernetes world. We''ll use YAML to write object `spec` in the rest of this
    book. The following code block shows a YAML-formatted spec fragment:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的 `spec` 可以用 YAML ([http://www.yaml.org/](http://www.yaml.org/)) 或 JSON ([http://www.json.org/](http://www.json.org/))
    编写。在 Kubernetes 中，YAML 更为常见。我们将在本书的其余部分使用 YAML 来编写对象 `spec`。以下代码块展示了一个 YAML 格式的
    spec 片段：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Namespaces
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'Kubernetes namespaces allow us to implement isolation of multiple virtual clusters.
    Objects in different namespaces are invisible to each other. This is useful when
    different teams or projects share the same cluster. Most resources come under
    a namespace (these are known as namespaced resources); however, some generic resources,
    such as nodes or namespaces themselves, don''t belong to any namespace. Kubernetes
    has three namespaces:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 命名空间允许我们实现多个虚拟集群的隔离。不同命名空间中的对象互相不可见。当不同的团队或项目共享同一个集群时，这非常有用。大多数资源都属于某个命名空间（这些被称为命名空间资源）；然而，一些通用资源，如节点或命名空间本身，并不属于任何命名空间。Kubernetes
    有三个命名空间：
- en: '`default`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`'
- en: '`kube-system`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-system`'
- en: '`kube-public`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-public`'
- en: If we don't explicitly assign a namespace to a namespaced resource, it'll be
    located in the namespace of the current context. If we never add a new namespace,
    a default namespace will be used.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确为命名空间资源指定命名空间，它将位于当前上下文的命名空间中。如果我们从未添加新命名空间，则将使用默认命名空间。
- en: Kube-system namespaces are used by objects created by the Kubernetes system,
    such as addon, which are the pods or services that implement cluster features,
    such as dashboard. Kube-public namespace was introduced in Kubernetes version
    1.6, which is used by a beta controller manager (BootstrapSigner: [https://kubernetes.io/docs/admin/bootstrap-tokens](https://kubernetes.io/docs/admin/bootstrap-tokens)),
    putting the signed cluster location information into the `kube-public` namespace.
    This information could be viewed by authenticated or unauthenticated users.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kube-system 命名空间由 Kubernetes 系统创建的对象使用，如 addon，这些是实现集群功能的 pods 或服务，如仪表盘。Kube-public
    命名空间是在 Kubernetes 版本 1.6 中引入的，用于由 beta 控制器管理器（BootstrapSigner：[https://kubernetes.io/docs/admin/bootstrap-tokens](https://kubernetes.io/docs/admin/bootstrap-tokens)）使用，将签名的集群位置信息放入
    `kube-public` 命名空间。此信息可以被认证或未认证的用户查看。
- en: In the following sections, all of the namespaced resources are located in a
    default namespace. Namespaces are also very important for resource management
    and roles. We'll provide further information in [Chapter 8](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml), *Resource
    Management and Scaling*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，所有命名空间资源都位于默认命名空间中。命名空间对于资源管理和角色也非常重要。我们将在[第8章](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml)中提供更多信息，*资源管理与扩展*。
- en: 'Let''s see how to create a namespace. A namespace is a Kubernetes object. We
    can specify the type to be a namespace, just like other objects. An example of
    how to create a namespace called `project1` follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个命名空间。命名空间是一个 Kubernetes 对象。我们可以指定类型为命名空间，就像其他对象一样。以下是如何创建一个名为 `project1`
    的命名空间的示例：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s now try to start two nginx containers via deployment in the `project1` namespace:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试通过在 `project1` 命名空间中进行部署来启动两个 nginx 容器：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we list pods by `kubectl get pods`, we''ll see nothing in our cluster.
    This is because Kubernetes uses the current context to decide which namespace
    is current. If we don''t explicitly specify namespaces in the context or the `kubectl` command
    line, the `default` namespace will be used:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 `kubectl get pods` 列出 pods 时，集群中将不会显示任何内容。这是因为 Kubernetes 使用当前上下文来决定哪个命名空间是当前的。如果我们没有在上下文或
    `kubectl` 命令行中明确指定命名空间，默认将使用 `default` 命名空间：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You could use `--namespace <namespace_name>`, `--namespace=<namespace_name>`, `-n
    <namespace_name>`, or `-n=<namespace_name>` to specify the namespace for a command.
    To list the resources across namespaces, use the `--all-namespaces` parameter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `--namespace <namespace_name>`，`--namespace=<namespace_name>`，`-n <namespace_name>`
    或 `-n=<namespace_name>` 来指定命令的命名空间。要列出跨命名空间的资源，使用 `--all-namespaces` 参数。
- en: Another way to do this is to change the current context to point to the desired
    namespace rather than the `default` namespace.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做法是将当前上下文更改为指向所需的命名空间，而不是`default`命名空间。
- en: Name
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称
- en: Every object in Kubernetes owns its own name that's uniquely identified within
    the same namespace. Kubernetes uses object names as part of a resource's URL for
    the API server, so it has be a combination of lowercase alphanumeric characters
    and dashes and dots, and it has to be less than 254 characters long. Besides the
    object name, Kubernetes also assigns a **Unique ID** (**UID**) to every object
    to distinguish historical occurrences of similar entities.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的每个对象都有自己独特的名称，在相同的命名空间内是唯一的。Kubernetes将对象名称作为API服务器资源URL的一部分，因此它必须是小写字母、数字、短横线和点的组合，并且长度不得超过254个字符。除了对象名称，Kubernetes还为每个对象分配了一个**唯一ID**（**UID**），用于区分历史上类似实体的发生。
- en: Label and selector
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签和选择器
- en: 'Labels are sets of key/pair values that attach to objects. They''re designed
    to provide meaningful, identifying information about objects. Common usages are
    to indicate the name of the micro-service, the tier, the environment, and the
    software version. Users can define meaningful labels that could be used with selectors
    later. The syntax of labels in an object `spec` is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是附加到对象上的键/值对集合。它们旨在提供有关对象的有意义的标识信息。常见的用途包括指示微服务名称、层级、环境和软件版本。用户可以定义有意义的标签，后续可以与选择器一起使用。对象`spec`中标签的语法如下：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Along with labels, label selectors are used to filter sets of objects. Separated
    by commas, multiple requirements will be joined by the `AND` logical operator.
    There are two ways to filter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与标签一起使用，标签选择器用于过滤对象集合。多个要求用逗号分隔，将通过`AND`逻辑运算符连接。过滤有两种方式：
- en: Equality-based requirements
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于相等的要求
- en: Set-based requirements
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于集合的要求
- en: 'Equality-based requirements support the following operators: `=`, `==`, and
    `!=`. Take the following diagram as an example: if the selector is `chapter=2,version!=0.1`,
    the result will be **object C**. If the requirement is `version=0.1`, the result
    will be **object A** and **object B**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于相等的要求支持以下运算符：`=`、`==`和`!=`。以以下图示为例：如果选择器是`chapter=2, version!=0.1`，则结果为**对象
    C**。如果要求是`version=0.1`，则结果为**对象 A**和**对象 B**：
- en: '![](img/cc386b25-27c1-4c82-b314-e58590b38c19.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc386b25-27c1-4c82-b314-e58590b38c19.png)'
- en: Selector example
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器示例
- en: 'If we write the requirement in the supported object `spec`, it''ll be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在支持的对象`spec`中编写要求，它将如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set-based requirement supports `in`, `notin`, and `exists` (for `key` only).
    For example, if the requirement is `chapter in (3, 4),version`, then **object
    A** will be returned. If the requirement is `version notin (0.2), !author_info`,
    the result will be **object A** and **object B**. The following example shows
    an object `spec` that uses set-based requirements:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基于集合的要求支持`in`、`notin`和`exists`（仅适用于`key`）。例如，如果要求是`chapter in (3, 4), version`，则返回**对象
    A**。如果要求是`version notin (0.2), !author_info`，则结果将是**对象 A**和**对象 B**。以下示例展示了使用基于集合要求的`spec`对象：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The requirements of `matchLabels` and `matchExpressions` are combined together.
    This means that the filtered objects need to be true for both requirements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchLabels`和`matchExpressions`的要求是结合在一起的。这意味着过滤的对象必须同时满足两个要求。'
- en: Annotation
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: 'Annotation is a set of user-specified key-value pairs, used for specifying
    non-identifying metadata. With annotation acts such as normal tagging, for example,
    a user could add timestamps, commit hashes, or build numbers to an annotation.
    Some kubectl commands support the `--record` option to record commands that make
    changes to the objects. Another use case of annotation is storing the configuration,
    such as Kubernetes deployments ([https://kubernetes.io/docs/concepts/workloads/controllers/deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment))
    or critical add-on pods ([https://coreos.com/kubernetes/docs/latest/deploy-addons.html](https://coreos.com/kubernetes/docs/latest/deploy-addons.html)).
    The syntax of annotations is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一组用户指定的键值对，用于指定非标识性的元数据。注解的作用类似于普通的标签，例如，用户可以在注解中添加时间戳、提交哈希或构建号。某些`kubectl`命令支持`--record`选项，用于记录对对象进行更改的命令。注解的另一个用例是存储配置信息，例如Kubernetes部署（[https://kubernetes.io/docs/concepts/workloads/controllers/deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment)）或关键附加组件Pod（[https://coreos.com/kubernetes/docs/latest/deploy-addons.html](https://coreos.com/kubernetes/docs/latest/deploy-addons.html)）。注解的语法如下：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Namespace, name, label, and annotation are located in the metadata section of
    the object `spec`. Selector is located in the `spec` section of selector-supported
    resources, such as pod, service, ReplicaSet, and deployment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间、名称、标签和注释位于对象`spec`的元数据部分。选择器位于支持选择器的资源的`spec`部分，例如pod、service、ReplicaSet和deployment。
- en: Pods
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pods
- en: A pod is the smallest deployable unit in Kubernetes. It can contain one or more
    containers. Most of the time, we just need one container per pod. In some special
    cases, more than one container is included in the same pod, such as sidecar containers
    ([http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html](http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html)).
    Containers in the same pod run in a shared context, on the same node, sharing
    the network namespace and shared volumes. Pods are also designed as mortal. When
    a pod dies for some reason, for example, if it's killed by Kubernetes controller
    if resources are lacking, it won't recover by itself. Instead, Kubernetes uses
    controllers to create and manage the desired state of pods for us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes中最小的可部署单元。它可以包含一个或多个容器。大多数情况下，我们每个pod只需要一个容器。在一些特殊情况下，多个容器可能会被包含在同一个pod中，例如sidecar容器（[http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html](http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html)）。同一个pod中的容器共享一个上下文，在同一节点上运行，共享网络命名空间和共享卷。Pod的设计也是“易死”的。当pod因某种原因死掉时，比如被Kubernetes控制器因为资源不足而杀死，它不会自行恢复。相反，Kubernetes使用控制器为我们创建并管理pod的期望状态。
- en: 'We can use `kubectl explain <resource>` to get the detailed description of
    the resource by the command line. This will show the fields that the resource
    supports:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl explain <resource>`通过命令行获取资源的详细描述。这将显示该资源支持的字段：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following example, we''ll show how to create two containers in a pod,
    and demonstrate how they access each other. Please note that this is neither a
    meaningful nor a classic sidecar pattern example. Instead, it''s just an example
    of how we can access other containers within a pod:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将展示如何在一个pod中创建两个容器，并演示它们如何互相访问。请注意，这既不是一个有意义的也不是经典的sidecar模式示例。它只是展示了我们如何在同一个pod内访问其他容器的一个例子：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following diagram shows the relationship between containers in a **Pod**.
    They share the same network namespace:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了**Pod**中容器之间的关系。它们共享相同的网络命名空间：
- en: '![](img/c5d57b7a-537b-4e2a-8fd6-5b6745261a6d.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5d57b7a-537b-4e2a-8fd6-5b6745261a6d.png)'
- en: Containers inside a pod are visible via localhost
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Pod内的容器可以通过localhost访问
- en: This spec will create two containers, `web` and `centos`. Web is an `nginx`
    container ([https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)). The
    container port `80` is exposed by default. Since `centos` shares the same context
    as nginx, when using `curl` in `http://localhost:80/`, it should be able to access
    nginx.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个spec将创建两个容器，`web`和`centos`。Web是一个`nginx`容器（[https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)）。容器端口`80`默认被暴露。由于`centos`与nginx共享相同的上下文，当在`http://localhost:80/`中使用`curl`时，它应该能够访问nginx。
- en: 'Next, use the `kubectl create` command to launch the pod. The `-f` argument
    allows us to feed a configuration file to the `kubectl` command and creates the
    desired resources specified in the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`kubectl create`命令来启动pod。`-f`参数允许我们将配置文件传递给`kubectl`命令，并创建文件中指定的所需资源：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we add `--record=true` at the end of the `kubectl` command when we create
    the resources, Kubernetes will add the latest command while creating or updating
    this resource. Therefore, we won't forget which resources are created by which
    spec.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建资源时，我们在`kubectl`命令的末尾添加`--record=true`，Kubernetes会在创建或更新资源时记录最新的命令。因此，我们不会忘记哪些资源是由哪个spec创建的。
- en: 'We can use the `kubectl get <resource>` command to get the current status of
    the object. In this case, we use the `kubectl get pods` command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl get <resource>`命令来获取对象的当前状态。在这个例子中，我们使用`kubectl get pods`命令：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Adding `--namespace=$namespace_name` allows us to access the object in different
    namespaces. The following is an example of how to check the pods in the `kube-system`
    namespace, which is used by system-type pods:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`--namespace=$namespace_name`允许我们访问不同命名空间中的对象。以下是如何检查`kube-system`命名空间中pods的示例，该命名空间用于系统类型的pods：
- en: '`**// list pods in kube-system namespace**`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`**// 列出kube-system命名空间中的pods**`'
- en: '`**# kubectl get pods --namespace=kube-system**`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`**# kubectl get pods --namespace=kube-system**`'
- en: '`**NAME                            READY STATUS RESTARTS AGE**`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`**NAME                            READY STATUS RESTARTS AGE**`'
- en: '`**coredns-99b9bb8bd-p2dvw               1/1 Running 0 1m**`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`**coredns-99b9bb8bd-p2dvw               1/1 正在运行 0 1分钟**`'
- en: '`**etcd-minikube                         1/1 Running 0 47s**`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`**etcd-minikube                         1/1 正在运行 0 47秒**`'
- en: '`**kube-addon-manager-minikube           1/1 Running 0 13s**`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kube-addon-manager-minikube           1/1 正在运行 0 13秒**`'
- en: '`**kube-apiserver-minikube               1/1 Running 0 38s**`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kube-apiserver-minikube               1/1 正在运行 0 38秒**`'
- en: '`**kube-controller-manager-minikube      1/1 Running 0 32s**`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kube-controller-manager-minikube      1/1 正在运行 0 32秒**`'
- en: '`**kube-proxy-pvww2                      1/1 Running 0 1m**`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kube-proxy-pvww2                      1/1 正在运行 0 1分钟**`'
- en: '`**kube-scheduler-minikube               1/1 Running 0 26s**`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kube-scheduler-minikube               1/1 正在运行 0 26秒**`'
- en: '`**kubernetes-dashboard-7db4dc666b-f8b2w 1/1 Running 0 1m**`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kubernetes-dashboard-7db4dc666b-f8b2w 1/1 正在运行 0 1分钟**`'
- en: '`**storage-provisioner                   1/1 Running 0 1m**`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`**storage-provisioner                   1/1 正在运行 0 1分钟**`'
- en: The status of our example pod is `ContainerCreating`. In this phase, Kubernetes
    has accepted the request and is trying to schedule the pod and pull down the image.
    Zero containers are currently running.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的pod状态是`ContainerCreating`。在此阶段，Kubernetes已接受请求，并正在尝试调度pod并拉取镜像。当前没有容器在运行。
- en: Most objects have short names, which come in handy when we use `kubectl get
    <object>` to list their status. For example, pods could be called `po`, services
    could be called `svc`, and deployment could be called `deploy`. Type `kubectl
    get` to know more. Alternatively, the `kubectl api-resources` command could list
    all resources with their short names and attributes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对象都有简短的名称，这在我们使用`kubectl get <object>`列出它们的状态时非常有用。例如，pod可以叫做`po`，服务可以叫做`svc`，部署可以叫做`deploy`。输入`kubectl
    get`可以查看更多信息。或者，`kubectl api-resources`命令可以列出所有资源及其简短名称和属性。
- en: 'After waiting a moment, we could get the status again:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一会儿后，我们可以再次获取状态：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can see that two containers are currently running. The uptime is three seconds.
    Using `kubectl logs <pod_name> -c <container_name>` gets `stdout` for the container,
    similar to `docker logs <container_name>`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个容器当前正在运行，运行时间为三秒。使用`kubectl logs <pod_name> -c <container_name>`可以获取该容器的`stdout`，这类似于`docker
    logs <container_name>`：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`centos` in the pod shares the same networking with nginx via localhost. Kubernetes
    creates a network container along with the pod. One of the functions in the network
    container is to forward the traffic between containers within a pod. We''ll learn
    more about this in [Chapter 6](fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml), *Kubernetes
    Network*.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: pod中的`centos`与nginx通过localhost共享相同的网络。Kubernetes会与pod一起创建一个网络容器。网络容器的一个功能是转发pod内容器之间的流量。我们将在[第6章](fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml)中了解更多内容，*Kubernetes网络*。
- en: If we specify labels in the pod spec, we could use the `kubectl get pods -l
    <requirement>` command to get the pods that satisfy the requirements, for example, `kubectl
    get pods -l 'tier in (frontend, backend)'`. Additionally, if we use `kubectl pods
    -o wide`, this will list which pods are running on which nodes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pod规格中指定标签，我们可以使用`kubectl get pods -l <requirement>`命令获取符合要求的pod，例如，`kubectl
    get pods -l 'tier in (frontend, backend)'`。此外，如果我们使用`kubectl pods -o wide`，它会列出哪些pod在何种节点上运行。
- en: 'We could use `kubectl describe <resource> <resource_name>` to get detailed
    information about a resource:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl describe <resource> <resource_name>`来获取资源的详细信息：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, we know which node this pod is running on. In `minikube`, we
    only get a single node so it won''t make any difference. In the real cluster environment,
    knowing which node the pod is running on is useful for troubleshooting. We haven''t
    associated any labels, annotations, or controllers for it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道这个pod运行在哪个节点上。在`minikube`中，我们只有一个节点，因此它没有什么区别。在真实的集群环境中，知道pod运行在哪个节点上对于故障排除非常有用。我们还没有为它关联任何标签、注解或控制器：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the containers section, we''ll see there are two containers included in
    this pod. We can see their states, source images, port mappings, and restart count:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器部分，我们将看到这个pod包含两个容器。我们可以看到它们的状态、源镜像、端口映射和重启次数：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A pod has `PodStatus`, which includes a map of array representations as `PodConditions`.
    The possible types of `PodConditions` are `PodScheduled`, `Ready`, `Initialized`, `Unschedulable`,
    and `ContainersReady`. The value will be `true`, `false`, or unknown. If the pod
    isn''t created accordingly, `PodStatus` will give us a brief overview of which
    part failed. In the preceding example, we launched the pod successfully in each
    phase without any errors:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 pod 具有 `PodStatus`，其中包含以 `PodConditions` 数组表示的映射。`PodConditions` 的可能类型有 `PodScheduled`、`Ready`、`Initialized`、`Unschedulable`
    和 `ContainersReady`。其值可以是 `true`、`false` 或未知。如果 pod 没有按预期创建，`PodStatus` 将简要概述哪个部分出现了故障。在前面的示例中，我们在每个阶段成功启动了
    pod，且没有出现任何错误：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A pod is associated with a service account that provides an identity for processes
    that are running the pod. It's controlled by service account and a token controller
    in the API Server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 pod 与服务账户相关联，服务账户为运行该 pod 的进程提供身份。它由服务账户和 API 服务器中的令牌控制器进行管理。
- en: 'It''ll mount a read-only volume to each container under `/var/run/secrets/kubernetes.io/serviceaccount`
    in a pod that contains a token for API access. Kubernetes creates a default service
    account. We can use the `kubectl get serviceaccounts` command to list the service
    accounts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在 pod 中的每个容器下挂载一个只读卷，路径为 `/var/run/secrets/kubernetes.io/serviceaccount`，该卷包含一个用于
    API 访问的令牌。Kubernetes 创建了一个默认的服务账户。我们可以使用 `kubectl get serviceaccounts` 命令列出服务账户：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We don''t assign any selectors to this pod yet. Toleration is used to restrict
    how many pods a node can use. We''ll learn more about this in [Chapter 8](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml), *Resource
    Management and Scaling*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有为这个 pod 分配任何选择器。容忍度用于限制节点可以使用的 pod 数量。我们将在[第 8 章](a7a72300-181d-41ad-a08a-7e42744d365f.xhtml)
    *资源管理和扩展*中进一步学习这一点：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By seeing the events, we can identify the steps required for Kubernetes to run
    a node. First, the scheduler assigns the task to a node, which here is called
    `minikube`. Then, kubelet starts pulling the first image and creates a container
    accordingly. After that, kubelet pulls down the second container and starts the
    container.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看事件，我们可以识别 Kubernetes 运行节点所需的步骤。首先，调度器将任务分配给一个节点，这里叫做 `minikube`。然后，kubelet
    开始拉取第一个镜像并相应地创建一个容器。之后，kubelet 拉取第二个容器并启动容器。
- en: ReplicaSet
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReplicaSet
- en: A pod isn't self-healing. When a pod encounters failure, it won't recover on
    its own. This is where **ReplicaSet** (**RS**) comes into play. ReplicaSet ensures
    that the specified number of replica pods are always up and running in the cluster.
    If a pod crashes for any reason, ReplicaSet will send a request to spin up a new
    pod.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: pod 并不是自愈的。当 pod 遇到故障时，它不会自动恢复。这时，**ReplicaSet**（**RS**）发挥作用。ReplicaSet 确保集群中始终有指定数量的副本
    pod 正在运行。如果一个 pod 因为任何原因崩溃，ReplicaSet 会发送请求来启动一个新的 pod。
- en: ReplicaSet is similar to **ReplicationController** (**RC**), which was used
    in older versions of Kubernetes. Unlike ReplicaSet, which uses set-based selector
    requirement, ReplicationController used equality-based selector requirements. It
    has now been completely replaced by ReplicaSet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 类似于旧版本 Kubernetes 中使用的 **ReplicationController**（**RC**）。与 ReplicaSet
    使用基于集合的选择器要求不同，ReplicationController 使用基于等式的选择器要求。现在，ReplicationController 已被完全替代为
    ReplicaSet。
- en: 'Let''s see how ReplicaSet works:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 ReplicaSet 是如何工作的：
- en: '![](img/040fd899-1e2e-4a91-bef9-8cfb5eb08a1e.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/040fd899-1e2e-4a91-bef9-8cfb5eb08a1e.png)'
- en: ReplicaSet with a desired count of 2
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 具有期望数量为 2 的 ReplicaSet
- en: Let's say that we want to create a `ReplicaSet` object, with a desired count
    of 2\. This means that we'll always have two pods in the service. Before we write
    the spec for ReplicaSet, we'll have to decide on the pod template first. This
    is similar to the spec of a pod. In a ReplicaSet, labels are required in the metadata
    section. A ReplicaSet uses a pod selector to select which pods it manages. Labels
    allow ReplicaSet to distinguish whether all of the pods matching the selectors
    are all on track.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个 `ReplicaSet` 对象，期望数量为 2。这意味着我们将始终在服务中拥有两个 pod。在编写 ReplicaSet 的 spec
    之前，我们必须首先确定 pod 模板。这类似于 pod 的 spec。在 ReplicaSet 中，标签在元数据部分是必需的。ReplicaSet 使用 pod
    选择器来选择它管理的 pod。标签使得 ReplicaSet 能够区分是否所有与选择器匹配的 pod 都在正常运行。
- en: 'In this example, we''ll create two pods, each with the labels `project`, `service`,
    and `version`, as shown in the preceding diagram:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建两个 pod，每个 pod 都带有 `project`、`service` 和 `version` 标签，如前图所示：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can use `kubectl` to get the current RS status:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `kubectl` 来获取当前的 RS 状态：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This shows that we desire two pods, we currently have two pods, and two pods
    are ready. How many pods do we have now? Let''s check it out via the `kubectl`
    command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们期望有两个Pod，当前有两个Pod，并且两个Pod都已准备就绪。现在我们有多少Pod呢？让我们通过`kubectl`命令检查一下：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This shows we have two pods up and running. As described previously, ReplicaSet
    manages all of the pods matching the selector. If we create a pod with the same
    label manually, in theory, it should match the pod selector of the RS we just
    created. Let''s try it out:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们有两个Pod正在运行。如前所述，ReplicaSet管理所有匹配选择器的Pod。如果我们手动创建一个具有相同标签的Pod，理论上，它应该匹配我们刚刚创建的RS的Pod选择器。让我们试试看：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s see if it''s up and running:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是否正常运行：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It''s scheduled, and ReplicaSet catches it. The amount of pods becomes three,
    which exceeds our desired count. The pod is eventually killed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它已调度，ReplicaSet捕捉到了这个变化。Pod的数量变为三个，超过了我们期望的数量。该Pod最终被终止：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following diagram is an illustration of how our self-created pod was evicted.
    The labels are matched with ReplicaSet, but the desired count is 2\. Therefore,
    the additional pod was evicted:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了我们自创建的Pod是如何被驱逐的。标签与ReplicaSet匹配，但期望数量为2。因此，额外的Pod被驱逐掉了：
- en: '![](img/892b39bb-e749-4a51-a070-90a0530ab9eb.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/892b39bb-e749-4a51-a070-90a0530ab9eb.png)'
- en: ReplicaSet makes sure pods are in the desired state
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet确保Pod处于期望的状态
- en: 'If we want to scale on demand, we could simply use `kubectl edit <resource>
    <resource_name>` to update the spec. Here, we''ll change the replica count from
    `2` to `5`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想根据需求进行扩展，可以简单地使用`kubectl edit <resource> <resource_name>`来更新规格。在这里，我们将副本数量从`2`更改为`5`：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s check the RS information:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查RS的相关信息：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We now have five pods. Let''s check how RS works:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有五个Pod。让我们检查一下RS是如何工作的：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By describing the command, we can learn the spec of RS and the events. When
    we created the `nginx` RS, it launched two containers by spec. Then, we created
    another pod manually by another spec, named `our-nginx`. RS detected that the
    pod matches its pod selector. After the amount exceeded our desired count, it
    evicted it. Then, we scaled out the replicas to five. RS detected that it didn't
    fulfill our desired state and launched three pods to fill the gap.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过描述命令，我们可以了解RS的规格和事件。当我们创建`nginx` RS时，它根据规格启动了两个容器。然后，我们根据另一种规格手动创建了一个名为`our-nginx`的Pod。RS检测到该Pod与其Pod选择器匹配。随着数量超过我们期望的数量，它将该Pod驱逐掉。然后，我们将副本数扩展到五个。RS检测到它没有达到我们期望的状态，并启动了三个Pod来填补空缺。
- en: 'If we want to delete an RC, simply use the `kubectl` command: `kubectl delete
    <resource> <resource_name>`. Since we have a configuration file on hand, we could
    also use `kubectl delete -f <configuration_file>` to delete the resources listing
    in the file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想删除一个RC，只需使用`kubectl`命令：`kubectl delete <resource> <resource_name>`。由于我们手头有配置文件，我们也可以使用`kubectl
    delete -f <configuration_file>`来删除文件中列出的资源：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Deployments
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deployments
- en: Deployments are the best primitive to manage and deploy our software in Kubernetes
    after version 1.2\. They allow us to deploy pods, carry out rolling updates, and
    roll back pods and ReplicaSets. We can define our desired software updates declaratively using
    Deployments and then Deployments will do them for us progressively.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.2版本之后，Deployments是管理和部署软件的最佳基础构件。它们允许我们部署Pod，执行滚动更新，并回滚Pod和ReplicaSets。我们可以使用Deployments声明性地定义期望的软件更新，Deployments会逐步为我们执行这些操作。
- en: Before Deployments, ReplicationController and kubectl rolling-update were the
    major ways to implement rolling updates for software. These methods were much
    more imperative and slower. Deployment is now the main high-level object used
    to manage our application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Deployments之前，ReplicationController和kubectl rolling-update是实现软件滚动更新的主要方式。这些方法更加命令式且速度较慢。Deployment现在是用于管理我们应用程序的主要高级对象。
- en: Let's take a look at how it works. In this section, we'll get a taste of how
    a Deployment is created, how to perform rolling updates, and rollbacks. [Chapter
    9](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml), *Continuous Delivery*, has more
    information with practical examples about how we can integrate Deployments into
    our continuous delivery pipeline.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。在本节中，我们将体验一下如何创建Deployment，如何进行滚动更新和回滚。[第9章](acaa9855-1a87-4fd4-ad40-0955f5d12f28.xhtml)，*持续交付*，提供了更多有关如何将Deployments集成到我们的持续交付管道中的实际例子。
- en: 'First, we use the `kubectl run` command to create `deployment` for us:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`kubectl run`命令为我们创建`deployment`：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Before Kubernetes 1.2, the `kubectl run` command would create pods instead.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.2之前，`kubectl run`命令会创建Pod。
- en: 'There are two pods that are deployed by `deployment`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 pod 是由 `deployment` 部署的：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is a diagram of the relationship between Deployments, ReplicaSets,
    and pods. In general, Deployments manage ReplicaSets and ReplicaSets manage pods.
    Note that we shouldn''t manipulate ReplicaSets that are managed by Deployments,
    just like there''s no reason to directly change pods if they''re managed by ReplicaSets:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个关于 Deployments、ReplicaSets 和 pods 之间关系的图示。一般来说，Deployments 管理 ReplicaSets，而
    ReplicaSets 管理 pods。请注意，我们不应该直接操作由 Deployments 管理的 ReplicaSets，就像如果 pods 是由 ReplicaSets
    管理的，我们也没有理由直接改变它们一样：
- en: '![](img/0dae5898-fe53-4992-9c95-5c96ab5dc84b.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dae5898-fe53-4992-9c95-5c96ab5dc84b.png)'
- en: The relationship between Deployments, ReplicaSets, and pods
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Deployments、ReplicaSets 和 pods 之间的关系
- en: 'If we delete one of the pods, the replaced pod will be scheduled and launched
    immediately. This is because Deployments create a ReplicaSet behind the scenes,
    which will ensure that the number of replicas matches our desired count:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们删除其中一个 pod，替换的 pod 会立即被调度并启动。这是因为 Deployments 在后台创建了一个 ReplicaSet，它会确保副本的数量与我们期望的数量一致：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We could also expose the port for deployment using the `kubectl` command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过 `kubectl` 命令暴露端口以供部署：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Deployments can be created by spec as well. The previous Deployments and Service
    launched by kubectl can be converted into the following spec:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Deployments 也可以通过 spec 来创建。之前通过 kubectl 启动的 Deployments 和 Service 可以转换为以下 spec：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In order to perform rolling updates, we''ll need to add a rolling update strategy.
    There are three parameters used to control the process:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行滚动更新，我们需要添加滚动更新策略。此过程中有三个参数用来控制流程：
- en: '| **Parameters** | **Description** | **Default value** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** | **默认值** |'
- en: '| `minReadySeconds` | This is the warm-up time and indicates how long a newly
    created pod is considered to be available. By default, Kubernetes assumes the
    application will be available once it''s successfully launched. | 0 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `minReadySeconds` | 这是热身时间，表示新创建的 pod 被认为可用的时间。默认情况下，Kubernetes 假设应用程序一旦成功启动即认为其可用。
    | 0 |'
- en: '| `maxSurge` | This indicates how many pods can be surged when carrying out
    rolling update processes. | 25% |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `maxSurge` | 这表示在执行滚动更新过程中，允许有多少个 pod 被提升。 | 25% |'
- en: '| `maxUnavailable` | This indicates how many pods can be unavailable when carrying
    out rolling update processes. | 25% |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `maxUnavailable` | 这表示在执行滚动更新过程中，允许有多少个 pod 不可用。 | 25% |'
- en: '`minReadySecond` is an important setting. If our application isn''t available
    immediately when the pod is up, the pods will roll too fast without proper waiting.
    Although all of the new pods are up, the application might be still warming up;
    there''s a chance that a service outage might occur. In the following example,
    we''ll add the configuration into the `Deployment.spec` section:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`minReadySecond` 是一个重要的设置。如果我们的应用程序在 pod 启动时并未立即可用，pods 将过快滚动，且没有适当的等待。尽管所有新
    pods 都已启动，但应用程序可能仍在热身；这时可能会发生服务中断。以下示例中，我们将在 `Deployment.spec` 部分添加该配置：'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This indicates that we allow only one of the pods to be unavailable at any time
    and one pod to be launched when rolling the pods. The warm-up time before proceeding
    to the next operation is three seconds. We can use either `kubectl edit deployments
    nginx` (edit directly) or `kubectl replace -f 3-2-3_deployments_rollingupdate.yaml`
    to update the strategy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们允许在任何时刻只有一个 pod 不可用，并且在滚动更新 pod 时每次只能启动一个 pod。进入下一操作之前的热身时间是三秒钟。我们可以使用
    `kubectl edit deployments nginx`（直接编辑）或 `kubectl replace -f 3-2-3_deployments_rollingupdate.yaml`
    来更新策略。
- en: 'Let''s say we want to simulate a new software rollout from nginx 1.12.0 to
    1.13.1\. We can still use the preceding two commands to change the image version
    or use `kubectl set image deployment nginx nginx=nginx``:1.13.1` to trigger the
    update. If we use `kubectl describe` to check what''s going on, we''ll see that
    Deployments have triggered rolling updates on ReplicaSets by deleting/creating
    pods:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要模拟一个新的软件发布，从 nginx 1.12.0 更新到 1.13.1。我们仍然可以使用前面提到的两个命令来更改镜像版本，或者使用 `kubectl
    set image deployment nginx nginx=nginx:1.13.1` 来触发更新。如果我们使用 `kubectl describe`
    来查看发生了什么，我们会看到 Deployments 已通过删除/创建 pods 触发了对 ReplicaSets 的滚动更新：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is a diagram of how rolling update works in a Deployment:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是滚动更新在 Deployment 中如何工作的图示：
- en: '![](img/ff5abaf1-dbb3-4c85-a2ee-84c98925e6cd.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff5abaf1-dbb3-4c85-a2ee-84c98925e6cd.png)'
- en: Illustration of a Deployment
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 示意图
- en: The preceding diagram shows an illustration of a Deployment. At a certain point
    in time, our desired count is 2 and we have one maxSurge pod. After launching
    each new pod, Kubernetes will wait three seconds (`minReadySeconds`) and then
    perform the next action.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了一个 Deployment 的示意图。在某一时刻，我们希望的副本数是 2，并且有一个 maxSurge pod。在启动每个新 pod 后，Kubernetes
    会等待三秒（`minReadySeconds`），然后执行下一步操作。
- en: If we use the `kubectl set image deployment nginx nginx=nginx:1.12.0` command to
    roll back to the previous version 1.12.0, Deployments will do the rollback for
    us.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `kubectl set image deployment nginx nginx=nginx:1.12.0` 命令回滚到先前的版本 1.12.0，Deployment
    将为我们执行回滚。
- en: Services
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Services in Kubernetes are abstraction layers for routing traffic to a logical
    set of pods. With Services, we don't need to trace the IP address of each pod.
    Services usually use the label selector to select the pods that they need to route
    to while, in some cases, Services are created without a selector on purpose. The
    Service abstraction is powerful. It enables decoupling and makes communication
    between micro-services possible. Currently, Kubernetes Services support TCP, UDP,
    and SCTP.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 Service 是将流量路由到一组逻辑 pods 的抽象层。通过 Service，我们不需要追踪每个 pod 的 IP 地址。Service
    通常使用标签选择器来选择它们需要路由到的 pod，在某些情况下，Service 会故意不使用选择器。Service 抽象非常强大，它实现了解耦并使微服务之间的通信成为可能。目前，Kubernetes
    的 Service 支持 TCP、UDP 和 SCTP。
- en: 'Services don''t care about how we create the pod. Just like ReplicaSet, it
    only cares that the pods match its label selectors, so the pods could belong to
    different ReplicaSets:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Service 不关心我们如何创建 pod。就像 ReplicaSet 一样，它只关心 pod 是否匹配它的标签选择器，因此 pod 可以属于不同的 ReplicaSets：
- en: '![](img/98efea3b-cc56-41b0-af68-a8f78701f916.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98efea3b-cc56-41b0-af68-a8f78701f916.png)'
- en: Service maps pods via label selector
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Service 通过标签选择器映射 pods
- en: In the preceding diagram, all of the pods match the service selector, `project=chapter3,
    service=web`, so the Service will be responsible for distributing the traffic
    into all of the pods without explicit assignment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，所有的 pods 都匹配 service 选择器，`project=chapter3, service=web`，因此 Service 将负责将流量分发到所有这些
    pods，而无需明确分配。
- en: 'There are four types of Services: `ClusterIP`, `NodePort`, `LoadBalancer`,
    and `ExternalName`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的 Service：`ClusterIP`、`NodePort`、`LoadBalancer` 和 `ExternalName`：
- en: '![](img/1e5774fc-aeb4-4247-80d4-853782f8c68f.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e5774fc-aeb4-4247-80d4-853782f8c68f.png)'
- en: LoadBalancer includes the features of NodePort and ClusterIP
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: LoadBalancer 包括 NodePort 和 ClusterIP 的特性
- en: ClusterIP
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClusterIP
- en: '`ClusterIP` is the default Service type. It exposes the Service on a cluster-internal
    IP. Pods in the cluster could reach the Service via the IP address, environment
    variables, or DNS. In the following example, we''ll learn how to use both native
    Service environment variables and DNS to access the pods behind Services in the
    cluster.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterIP` 是默认的 Service 类型。它在集群内部 IP 上公开 Service。集群中的 pods 可以通过 IP 地址、环境变量或
    DNS 访问 Service。在下面的示例中，我们将学习如何使用本地 Service 环境变量和 DNS 来访问集群中 Service 后面的 pods。'
- en: 'Before starting a Service, we''d like to create two sets of RS with different
    version labels, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Service 之前，我们希望创建两个不同版本标签的 RS，具体如下：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we could make our pod selector, targeting project and service labels:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建我们的 pod 选择器，目标是 project 和 service 标签：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since a `Service` object might create a DNS label, the service name must be
    a combination of alphanumeric characters and hyphens. A hyphen at the beginning
    or end of a label isn't allowed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Service` 对象可能会创建 DNS 标签，因此服务名称必须由字母数字字符和连字符组成。标签的开头或结尾不能有连字符。
- en: 'We can then use `kubectl describe service <service_name>` to check the Service
    information:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用 `kubectl describe service <service_name>` 来检查 Service 的信息：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: One Service could expose multiple ports. Just extend the `.spec.ports` list
    in the `service` spec.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Service 可以暴露多个端口。只需在 `service` 规范中扩展 `.spec.ports` 列表。
- en: We can see that it's a `ClusterIP` type Service and its assigned internal IP
    is `10.0.0.188`. The endpoints show that we have four IPs behind the Service.
    The pod IPs can be found by the `kubectl describe pods <pod_name>` command. Kubernetes
    creates an `endpoints` object along with a `service` object to route the traffic
    to the matching pods.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这是一个 `ClusterIP` 类型的 Service，它分配的内部 IP 地址是 `10.0.0.188`。端点显示我们在 Service
    后面有四个 IP。通过 `kubectl describe pods <pod_name>` 命令可以找到 pod 的 IP 地址。Kubernetes 会与
    `service` 对象一起创建一个 `endpoints` 对象，将流量路由到匹配的 pods。
- en: 'When the Service is created with selectors, Kubernetes will create corresponding
    endpoint entries and keep updating, which will indicate the destination that the
    Service routes to:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务创建时使用了选择器，Kubernetes 会创建相应的端点条目并保持更新，这将指示服务路由的目标：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The ClusterIP could be defined within your cluster, though most of the time
    we don't explicitly use the IP address to access clusters. Using `.spec.clusterIP`
    can do this for us.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterIP 可以在集群内定义，尽管大多数情况下我们不会显式使用 IP 地址来访问集群。使用 `.spec.clusterIP` 可以为我们完成这项工作。
- en: 'By default, Kubernetes will expose seven environment variables for each Service.
    In most cases, the first two allow us to use the `kube-dns` add-on to carry out
    service discovery for us:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 会为每个服务暴露七个环境变量。在大多数情况下，前两个变量使我们能够使用 `kube-dns` 插件来进行服务发现：
- en: '`${SVCNAME}_SERVICE_HOST`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${SVCNAME}_SERVICE_HOST`'
- en: '`${SVCNAME}_SERVICE_PORT`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${SVCNAME}_SERVICE_PORT`'
- en: '`${SVCNAME}_PORT`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${SVCNAME}_PORT`'
- en: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}`'
- en: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}_PROTO`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}_PROTO`'
- en: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}_PORT`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}_PORT`'
- en: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}_ADDR`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${SVCNAME}_PORT_${PORT}_${PROTOCAL}_ADDR`'
- en: 'In the following example, we''ll use `${SVCNAME}_SERVICE_HOST` in another pod
    to check whether we can access our nginx pods:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将在另一个 pod 中使用 `${SVCNAME}_SERVICE_HOST` 来检查是否能够访问我们的 nginx pod：
- en: '![](img/96e290d8-2b77-4137-820c-8b48abf5c963.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96e290d8-2b77-4137-820c-8b48abf5c963.png)'
- en: Accessing ClusterIP via environment variables and DNS names
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过环境变量和 DNS 名称访问 ClusterIP
- en: 'We''ll then create a pod called `clusterip-chk` to access nginx containers
    via `nginx-service`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个名为 `clusterip-chk` 的 pod 来通过 `nginx-service` 访问 nginx 容器：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can check `stdout` of the `cluserip-chk` pod via the `kubectl logs` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `kubectl logs` 命令查看 `cluserip-chk` pod 的 `stdout`：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This abstraction level decouples the communication between pods. Pods are mortal.
    With RS and Services, we can build robust services without worrying about whether
    one pod will influence all microservices.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象层解耦了 pod 之间的通信。Pod 是短暂的。通过 RS 和服务，我们可以构建稳健的服务，而无需担心一个 pod 是否会影响所有微服务。
- en: With the DNS server enabled, the pods in the same cluster and the same namespace
    as the Services can access Services via their DNS records.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 DNS 服务器后，位于同一集群和命名空间中的 pod 可以通过其 DNS 记录访问服务。
- en: CoreDNS GA was introduced in Kubernetes 1.11 and is now the default option in
    Kubernetes. Before this, the kube-dns add-on was in charge of DNS-based service
    discovery
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: CoreDNS GA 在 Kubernetes 1.11 中引入，现在是 Kubernetes 的默认选项。在此之前，kube-dns 插件负责基于 DNS
    的服务发现。
- en: The DNS server creates DNS records for newly created services by watching the
    Kubernetes API. The DNS format for the cluster IP is `$servicename.$namespace` and
    the port is `_$portname_$protocal.$servicename.$namespace`. The spec of the `clusterip_chk`
    pod will be similar to the environment variables one. Change the URL to `http://nginx-service.default:_http_tcp.nginx-service.default/`
    in our previous example, and they should work exactly the same.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 服务器通过监视 Kubernetes API 为新创建的服务创建 DNS 记录。集群 IP 的 DNS 格式是 `$servicename.$namespace`，端口是
    `_$portname_$protocal.$servicename.$namespace`。`clusterip_chk` pod 的规格将与环境变量类似。在我们之前的示例中，将
    URL 更改为 `http://nginx-service.default:_http_tcp.nginx-service.default/`，它们的工作方式应该完全相同。
- en: NodePort
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NodePort
- en: If the Service is set as `NodePort`, Kubernetes will allocate a port within
    a certain range on each node. Any traffic going to the nodes on that port will
    be routed to the Service port. The port number may be user-specified. If not,
    Kubernetes will randomly choose a port between 30,000 and 32,767 that doesn't
    cause any collision. On the other hand, if it's specified, the user should be
    responsible for managing the collision by themselves. `NodePort` includes a `ClusterIP ` feature.
    Kubernetes assigns an internal IP to the Service.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务设置为 `NodePort`，Kubernetes 将在每个节点的特定端口范围内分配一个端口。任何发送到该端口的流量都会被路由到服务端口。端口号可以由用户指定。如果没有指定，Kubernetes
    将在 30,000 到 32,767 之间随机选择一个不会发生冲突的端口。另一方面，如果指定了端口，用户应自行负责管理端口冲突。`NodePort` 包含
    `ClusterIP` 功能，Kubernetes 会为服务分配一个内部 IP。
- en: 'In the following example, we''ll see how we can create a `NodePort` Service
    and use it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将看到如何创建一个 `NodePort` 服务并使用它：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You should then be able to access the Service via `http://${NODE_IP}:80`. The
    node could be any node. The `kube-proxy` watches for any updates by the Service
    and the endpoints, and updates the iptable rules accordingly (if using default
    `iptables` proxy-mode).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该能够通过`http://${NODE_IP}:80`访问该服务。节点可以是任何节点。`kube-proxy`会监视服务和端点的任何更新，并相应地更新iptables规则（如果使用默认的`iptables`代理模式）。
- en: If you're using minikube, you can access the Service via the `minikube service
    [-n NAMESPACE] [--url] NAME` command. In this example, this is `minikube service
    nginx-nodeport`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是minikube，可以通过`minikube service [-n NAMESPACE] [--url] NAME`命令访问服务。在这个例子中，这是`minikube
    service nginx-nodeport`。
- en: LoadBalancer
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LoadBalancer
- en: This type is only usable with cloud provider support, such as Amazon Web Services
    ([Chapter 10](f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml), *Kubernetes on AWS*), Google
    Cloud Platform ([Chapter 11](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml), *Kubernetes
    on GCP*), and Azure ([Chapter 12](89891610-4ca4-4216-9d76-2613d186421c.xhtml), *Kubernetes
    on Azure*). If we create a LoadBalancer Service, Kubernetes will provision a load
    balancer by the cloud provider to the Service.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型仅在云服务提供商支持下使用，例如Amazon Web Services（[第10章](f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml)，*Kubernetes
    on AWS*），Google Cloud Platform（[第11章](d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml)，*Kubernetes
    on GCP*），以及Azure（[第12章](89891610-4ca4-4216-9d76-2613d186421c.xhtml)，*Kubernetes
    on Azure*）。如果我们创建一个LoadBalancer服务，Kubernetes会由云服务提供商为该服务提供负载均衡器。
- en: ExternalName (kube-dns version >= 1.7)
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExternalName（kube-dns版本>= 1.7）
- en: Sometimes, we use different services in the cloud. Kubernetes is flexible enough
    to be hybrid. We can use ExternalName to create a CNAME for the external endpoints
    in the cluster.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们在云中使用不同的服务。Kubernetes足够灵活，能够支持混合环境。我们可以使用ExternalName为集群中的外部端点创建CNAME。
- en: Service without selectors
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有选择器的服务
- en: 'Services use selectors to match the pods to direct the traffic. However, sometimes
    you need to implement a proxy to be the bridge between the Kubernetes cluster
    and another namespace, another cluster, or an external resource. In the following
    example, we''ll demonstrate how to implement a proxy for [http://www.google.com](http://www.google.com)
    in your cluster. This is just an example; the source of the proxy in your case
    might be the endpoint of your database or another resource in the cloud:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 服务使用选择器来匹配Pod并引导流量。然而，有时你需要实现一个代理作为Kubernetes集群与另一个命名空间、另一个集群或外部资源之间的桥梁。在以下示例中，我们将展示如何在集群中实现一个代理来访问[http://www.google.com](http://www.google.com)。这只是一个示例；在你的情况下，代理的来源可能是你数据库的端点或云中的其他资源：
- en: '![](img/aad76cc0-0822-460d-9680-8ab29368220a.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aad76cc0-0822-460d-9680-8ab29368220a.png)'
- en: How a Service without a selector works
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 没有选择器的服务如何工作
- en: 'The configuration file is similar to the previous one, just without the selector
    section:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件与之前的类似，只是没有选择器部分：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: No Kubernetes endpoint will be created, since there's no selector. Kubernetes
    doesn't know where to route the traffic, since no selector can match the pods.
    We'll have to create the endpoints manually.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 不会创建Kubernetes端点，因为没有选择器。Kubernetes不知道如何路由流量，因为没有选择器可以匹配Pod。我们必须手动创建端点。
- en: 'In the `Endpoints` object, the source addresses can''t be the DNS name, so
    we''ll use `nslookup` to find the current Google IP from the domain, and add it
    to `Endpoints.subsets.addresses.ip`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Endpoints`对象中，源地址不能是DNS名称，因此我们将使用`nslookup`从域名查找当前的Google IP，并将其添加到`Endpoints.subsets.addresses.ip`：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s create another pod in the cluster to access our Google proxy:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在集群中创建另一个Pod来访问我们的Google代理：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s check `stdout` from the pod:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查Pod的`stdout`：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Hurray! We can now confirm that the proxy works. The traffic to the Service
    will be routed to the endpoints we specified. If it doesn't work, make sure you
    add the proper inbound rules to the network of your external resources.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们可以确认代理正常工作了。流量会被路由到我们指定的端点。如果它不起作用，请确保你在外部资源的网络中添加了正确的入站规则。
- en: Endpoints don't support DNS as a source. Alternatively, we can use the ExternalName,
    which doesn't have selectors either. This requires kube-dns version >= 1.7.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 端点不支持DNS作为来源。我们可以使用ExternalName，它也没有选择器。这需要kube-dns版本>= 1.7。
- en: In some use cases, users need neither load balancing nor proxy functionalities
    for the Service. In those cases, we can set `CluterIP = "None"` as a so-called
    headless service. For more information, please refer to [https://kubernetes.io/docs/concepts/services-networking/service/#headless-services](https://kubernetes.io/docs/concepts/services-networking/service/#headless-services).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些使用场景中，用户不需要负载均衡或代理功能。此时，我们可以将 `CluterIP = "None"` 设置为所谓的无头服务。有关更多信息，请参见 [https://kubernetes.io/docs/concepts/services-networking/service/#headless-services](https://kubernetes.io/docs/concepts/services-networking/service/#headless-services)。
- en: Volumes
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷
- en: A container is ephemeral and so is its disk. We either use the `docker commit
    [CONTAINER]` command or mount data volumes into a container ([Chapter 2](05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml),
    *DevOps with Containers*). In the Kubernetes domain, volume management is critical,
    since pods might run on any node. Also, ensuring that containers in the same pod
    can share the same files becomes extremely hard. This is an important topic in
    Kubernetes. [Chapter 4](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml), *Managing
    Stateful Workloads*, introduces volume management.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是临时的，其磁盘也是临时的。我们可以使用 `docker commit [CONTAINER]` 命令，或将数据卷挂载到容器中（[第2章](05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml)，*容器化
    DevOps*）。在 Kubernetes 领域，卷管理至关重要，因为 Pod 可能会运行在任何节点上。此外，确保同一 Pod 中的容器能够共享相同的文件变得极为困难。这是
    Kubernetes 中的一个重要话题。[第4章](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml)，*有状态工作负载的管理*，介绍了卷管理。
- en: Secrets
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密
- en: A secret, as its name suggests, is an object that stores secrets in key-value
    format for providing sensitive information to pods. It might be a password, an
    access key, or a token. A secret isn't stored in the disk; instead, it's stored
    in a per-node `tmpfs` filesystem. Kubelet on the node will create a `tmpfs` filesystem
    to store the secret. A secret isn't designed to store large amounts of data due
    to storage management considerations. The current size limit of one secret is
    1 MB.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，秘密是一个存储以键值对格式存储机密信息的对象，供 Pod 提供敏感信息。它可能是一个密码、访问密钥或令牌。秘密不会存储在磁盘中，而是存储在每个节点的
    `tmpfs` 文件系统中。节点上的 Kubelet 将创建一个 `tmpfs` 文件系统来存储该秘密。由于存储管理的考虑，秘密并不设计用来存储大量数据。当前单个秘密的大小限制为
    1 MB。
- en: 'We can create a secret based on a file, a directory, or a specified literal
    value by launching kubectl to create a secret command or by the spec. There are
    three types of secret format: generic (or opaque, if encoded), docker registry,
    and TLS.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动 kubectl 创建一个秘密命令或通过规范，根据文件、目录或指定的字面值来创建一个秘密。秘密的格式有三种类型：通用类型（或编码后为不透明类型）、docker
    注册表类型和 TLS 类型。
- en: We'll use either the generic or opaque type in our application. The docker registry
    type is used to store the credentials of a private docker registry. A TLS secret
    is used to store the CA certificate bundle for cluster administration.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中使用通用或不透明类型。docker 注册表类型用于存储私有 Docker 注册表的凭证。TLS 秘密用于存储用于集群管理的 CA 证书包。
- en: The `docker-registry` type of secret is also called `imagePullSecrets` and is
    used to pass the password of a private Docker registry via kubelet when pulling
    the image. This means we don't have to enter `docker login` for each provisioned
    node. The command is as follows: `kubectl create secret docker-registry` `<registry_name>`
    `--docker-server``=<docker_server> --docker-username=<docker_username>` `--docker-password=<docker_password>
    --docker-email=<docker_email>`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-registry` 类型的秘密也叫做 `imagePullSecrets`，用于通过 kubelet 在拉取镜像时传递私有 Docker
    注册表的密码。这意味着我们不需要为每个配置的节点输入 `docker login`。命令如下：`kubectl create secret docker-registry`
    `<registry_name>` `--docker-server` `=<docker_server> --docker-username=<docker_username>`
    `--docker-password=<docker_password> --docker-email=<docker_email>`。'
- en: 'We''ll start with a generic example to show how it works:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个通用示例开始，展示它是如何工作的：
- en: '[PRE54]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The options for creating secrets based on a directory and a literal value are
    pretty similar to the file ones. If we specify a directory after `--from-file`,
    the files in the directory will be iterated. The filename will be the secret key
    if it's a legal secret name. Non-regular files, such as subdirectories, symlinks,
    devices, or pipes, will be ignored. On the other hand, `--from-literal=<key>=<value>`
    is the option to use if you want to specify plain text directly from the command,
    for example, `--from-literal=username=root`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 基于目录和字面值创建秘密的选项与基于文件的选项非常相似。如果我们在 `--from-file` 后指定一个目录，目录中的文件将会被遍历。如果文件名是合法的秘密名称，则该文件名将作为秘密键。非普通文件，如子目录、符号链接、设备或管道将被忽略。另一方面，`--from-literal=<key>=<value>`
    是一个选项，用于直接从命令中指定纯文本，例如 `--from-literal=username=root`。
- en: 'Here, we create a secret name, `mypassword`, from the `mypassword.txt` file.
    By default, the key of the secret is the filename, which is equivalent to the
    `--from-file=mypassword=./mypassword.txt` option. We could append multiple `--from-file` instances
    as well. We can use the `kubectl get secret -o yaml` command to see more detailed
    information about the secret:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`mypassword.txt`文件中创建一个名为`mypassword`的密钥。默认情况下，密钥的键是文件名，这相当于`--from-file=mypassword=./mypassword.txt`选项。我们也可以添加多个`--from-file`实例。我们可以使用`kubectl
    get secret -o yaml`命令来查看密钥的更多详细信息：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can see that the type of the secret becomes `Opaque` since the text has
    been encrypted by kubectl. It''s `base64` encoded. We can use a simple `bash`
    command to decode it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，密钥的类型变成了`Opaque`，因为文本已经通过kubectl加密，它是`base64`编码的。我们可以使用一个简单的`bash`命令来解码它：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There are two ways for a pod to retrieve the secret. The first one is by a file,
    and the second one is by an environment variable. The first method is implemented
    by the volume. The syntax involves adding `containers.volumeMounts` in container
    specs and adding a volumes section with the secret configuration.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Pod获取密钥有两种方式。第一种是通过文件，第二种是通过环境变量。第一种方法通过卷实现。语法涉及在容器规范中添加`containers.volumeMounts`，并在卷部分中添加密钥配置。
- en: Retrieving secrets via files
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过文件获取密钥
- en: 'Let''s see how to read secrets from files inside a pod first:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何从Pod内的文件读取密钥：
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The secret file will be mounted in `/<mount_point>/<secret_name>` without specifying
    `items``key`, `path`, or `/<mount_point>/<path>` in the pod. In this case, the
    file path is `/secret/password-example`. If we describe the pod, we find that
    there are two mount points in this pod: the read-only volume that stores our secret
    and the one that stores the credentials to communicate with the API servers, which
    is created and managed by Kubernetes. We''ll learn more about this in [Chapter
    6](fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml), *Kubernetes Network*:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥文件将被挂载到`/<mount_point>/<secret_name>`，无需在Pod中指定`items``key`、`path`或`/<mount_point>/<path>`。在这种情况下，文件路径是`/secret/password-example`。如果我们描述Pod，我们会发现这个Pod中有两个挂载点：一个只读卷存储我们的密钥，另一个存储与API服务器通信的凭证，该凭证由Kubernetes创建和管理。我们将在[第6章](fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml)，*Kubernetes
    网络*中了解更多内容：
- en: '[PRE58]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can delete a secret using the `kubectl delete secret` `<secret_name>` command.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl delete secret` `<secret_name>`命令删除一个密钥。
- en: 'After describing the pod, we can find a `FailedMount` event, since the volume
    no longer exists:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 描述Pod后，我们可以发现一个`FailedMount`事件，因为卷不再存在：
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If the pod is generated before a secret is created, the pod will encounter failure
    as well.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pod在密钥创建之前生成，Pod也会遇到失败。
- en: 'We''ll now learn how to create a secret using the command line. We''ll briefly
    introduce its spec format:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何使用命令行创建密钥。我们将简要介绍它的spec格式：
- en: '[PRE60]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Since the spec is plain text, we need to encode the secret by our own `echo
    -n <password>` `| base64` command. Please note that the type here becomes `Opaque`.
    This should work in the same way as the one we create via the command line.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于spec是纯文本，我们需要使用自己的`echo -n <password>` `| base64`命令来编码密钥。请注意，此时类型变为`Opaque`。这应该和我们通过命令行创建的方式相同。
- en: Retrieving secrets via environment variables
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过环境变量获取密钥
- en: 'Alternatively, we could use environment variables to retrieve secrets, which
    is more flexible for short credentials, such as a password. Applications are able
    to use environment variables to retrieve database passwords without tackling files
    and volumes:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用环境变量来获取密钥，这对于短期凭证（如密码）来说更灵活。应用程序能够使用环境变量来获取数据库密码，而无需处理文件和卷：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A secret should always be created before the pods that need it. Otherwise, the
    pods won't be launched successfully.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥应该始终在需要它的Pod之前创建。否则，Pod将无法成功启动。
- en: The declaration is under `spec.containers[].env[]`. We'll need the secret name
    and the key name. Both are `mypassword` in this case. The example should work
    the same as the one we looked at previously.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 声明在`spec.containers[].env[]`下。我们需要密钥的名称和键的名称。在本例中，两者都是`mypassword`。这个示例应该和我们之前看的那个相同。
- en: ConfigMap
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ConfigMap
- en: ConfigMap is a resource that allows you to leave your configuration outside
    a Docker image. It injects the configuration data as key-value pairs into pods.
    Its properties are similar to secrets, but, whereas secrets are used to store
    sensitive data, such as passwords, ConfigMaps are used to store insensitive configuration
    data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 是一种资源，它允许你将配置留在 Docker 镜像外部。它将配置数据作为键值对注入到 Pod 中。它的特性类似于 secrets，但是，虽然
    secrets 用于存储敏感数据（如密码），ConfigMap 用于存储不敏感的配置信息。
- en: 'Like secrets, ConfigMaps could be based on files, directories, or specified
    literal value. They also have a similar syntax to secrets but use `kubectl create
    configmap`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 secrets，ConfigMap 可以基于文件、目录或指定的字面值。它们的语法与 secrets 相似，但使用`kubectl create
    configmap`：
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since two `config` files are located in the same folder name, `config`, we could
    pass a `config` folder instead of specifying the files one by one. The equivalent
    command to the preceding command is `kubectl create configmap example --from-file=config`
    in this case.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个`config`文件位于同一个文件夹`config`中，我们可以传递整个`config`文件夹，而不是逐一指定文件。在这种情况下，等效的命令是`kubectl
    create configmap example --from-file=config`。
- en: 'If we describe the ConfigMap, it''ll show the current information:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们描述该 ConfigMap，它将显示当前信息：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We could use `kubectl edit configmap` `<configmap_name>` to update the configuration
    after creation.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl edit configmap` `<configmap_name>`来更新创建后的配置。
- en: We also could use `literal` as the input. The equivalent commands for the preceding
    example would be `kubectl create configmap example --from-literal=app.properties.name=name=DevOps-with-Kubernetes`.
    This isn't always very practical when we have many configurations in an app.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`literal`作为输入。前面示例的等效命令是`kubectl create configmap example --from-literal=app.properties.name=name=DevOps-with-Kubernetes`。当我们在应用程序中有许多配置时，这种方式并不总是很实用。
- en: 'Let''s see how to use this inside a pod. There are two ways to use ConfigMap
    inside a pod: by volume or environment variables.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Pod 内部使用这个功能。将 ConfigMap 用于 Pod 内部有两种方式：通过卷或环境变量。
- en: Using ConfigMap via volume
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过卷使用 ConfigMap
- en: 'Similar to previous examples in the *Secrets* subsection, we mount a volume
    with `configmap` syntax and add `volumeMounts` inside a container template. The
    command in `centos` will loop to `cat ${MOUNTPOINT}/$CONFIG_FILENAME`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 与*Secrets*子章节中的示例类似，我们使用`configmap`语法挂载一个卷，并在容器模板内添加`volumeMounts`。在`centos`中的命令将循环执行`cat
    ${MOUNTPOINT}/$CONFIG_FILENAME`：
- en: '[PRE64]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We then could use this method to inject our non-sensitive configuration into
    the pod.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用这种方法将我们的非敏感配置注入到 Pod 中。
- en: Using ConfigMap via environment variables
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过环境变量使用 ConfigMap
- en: 'To use ConfigMap inside a pod, you''ll have to use `configMapKeyRef` as the
    value source in the `env` section. This will populate whole ConfigMap pairs to
    environment variables:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Pod 内部使用 ConfigMap，你需要在`env`部分使用`configMapKeyRef`作为值来源。这将把整个 ConfigMap 键值对填充到环境变量中：
- en: '[PRE65]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The Kubernetes system itself also uses ConfigMap to do some authentication.
    Check out the system ConfigMap by adding `--namespace=kube-system` in the `kubectl
    describe configmap` command.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 系统本身也使用 ConfigMap 来进行一些认证。通过在`kubectl describe configmap`命令中添加`--namespace=kube-system`，可以查看系统的
    ConfigMap。
- en: Multi-container orchestration
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多容器编排
- en: 'In this section, we''ll revisit our ticketing service: a kiosk web service
    as a frontend that provides an interface for get/put tickets. There is a Redis
    acting as cache to manage how many tickets we have. Redis also acts as a publisher/subscriber
    channel. Once a ticket is sold, the kiosk will publish an event into it. The subscriber
    is called recorder and will write a timestamp and record it to the MySQL database.
    Please refer to the last section in [Chapter 2](05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml),
    *DevOps with Containers*, for a detailed Dockerfile and Docker compose implementation.
    We''ll use `Deployment`, `Service`, `Secret`, `Volume`, and `ConfigMap` objects
    to implement this example in Kubernetes. The source code can be found at the following
    link: [https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter3/3-3_kiosk](https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter3/3-3_kiosk).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将重新审视我们的售票服务：一个作为前端的自助服务机web服务，提供获取/放置票据的接口。这里有一个Redis作为缓存，管理我们拥有的票据数量。Redis还充当发布/订阅通道。一旦票据售出，自助服务机将发布一个事件到该通道。订阅者叫做recorder，它会写入时间戳并将其记录到MySQL数据库中。有关详细的Dockerfile和Docker
    Compose实现，请参考[第2章](05e2d0b4-0e70-4480-b5a0-f3860ddb24f2.xhtml)最后一节，*容器中的DevOps*。我们将在Kubernetes中使用`Deployment`、`Service`、`Secret`、`Volume`和`ConfigMap`对象来实现这个示例。源代码可以在以下链接找到：[https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter3/3-3_kiosk](https://github.com/DevOps-with-Kubernetes/examples/tree/master/chapter3/3-3_kiosk)。
- en: 'The service architecture with Kubernetes resources is shown in the following
    diagram:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes资源的服务架构如下图所示：
- en: '![](img/c0837b43-ba18-449e-becf-62a3c83c5913.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0837b43-ba18-449e-becf-62a3c83c5913.png)'
- en: An example of a kiosk in the Kubernetes world
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes世界中的一个自助服务机示例
- en: We'll need four kinds of pods. Deployment is the best choice to manage or deploy
    the pods. This will reduce the effort required when we carry out deployments in
    the future thanks to its deployment strategy feature. Since the kiosk, Redis,
    and MySQL will be accessed by other components, we'll associate services to their
    pods. MySQL acts as a datastore and, for simplicity, we'll mount a local volume
    to it. Note that Kubernetes offers a bunch of choices. Check out the details and
    examples in [Chapter 4](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml), *Managing
    Stateful Workload*s. We'll want to store sensitive information such as our MySQL
    root and user password in secrets. The other insensitive configuration, such as
    the DB name or username, we'll leave to ConfigMap.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要四种类型的pods。Deployment是管理或部署pods的最佳选择。由于其部署策略功能，这将减少我们未来执行部署时所需的工作量。由于自助服务机、Redis和MySQL将被其他组件访问，我们将为它们的pods关联服务。MySQL作为数据存储，对于简单起见，我们将挂载一个本地卷到MySQL。请注意，Kubernetes提供了许多选择。有关详细信息和示例，请查看[第4章](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml)，*管理有状态工作负载*。我们希望将敏感信息，如MySQL的root用户和密码存储在secrets中。其他不敏感的配置，如数据库名称或用户名，我们将交给ConfigMap来处理。
- en: 'We''ll launch MySQL first, as the recorder depends on it. Before creating MySQL,
    we''ll have to create a corresponding `secret` and `ConfigMap` first. To create
    a `secret`, we need to generate `base64` encrypted data:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先启动MySQL，因为记录器依赖于它。在创建MySQL之前，我们需要先创建相应的`secret`和`ConfigMap`。要创建一个`secret`，我们需要生成`base64`加密数据：
- en: '[PRE66]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we''re able to create the secret:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就可以创建secret了：
- en: '[PRE67]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After that, we come to our ConfigMap. Here, we put the database user and the
    database name as an example:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看我们的ConfigMap。这里，我们以数据库用户和数据库名称为例：
- en: '[PRE68]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It''s then time to launch MySQL and its service:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是时候启动MySQL及其服务了：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can put more than one spec into a file by adding three dashes as separation.
    Here, we mount `hostPath /mysql/data` into pods with the path `/var/lib/mysql`.
    In the environment section, we use the secret and ConfigMap syntax with `secretKeyRef`
    and `configMapKeyRef`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在文件中添加三个短横线来将多个规格放在一个文件中。在这里，我们将`hostPath /mysql/data`挂载到pods的路径`/var/lib/mysql`。在环境部分，我们使用`secretKeyRef`和`configMapKeyRef`语法来引用secret和ConfigMap。
- en: 'After creating MySQL, Redis would be the next best candidate, since other services
    are dependent on it but it doesn''t have any prerequisites:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建MySQL之后，Redis将是下一个最佳候选项，因为其他服务依赖于它，但它没有任何先决条件：
- en: '[PRE70]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'It would then be a good time to start the kiosk:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是启动自助服务机的好时机：
- en: '[PRE71]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, we expose `lcredis-service.default` to environment variables to kiosk
    pods. This is the DNS name that kube-dns creates for `Service` objects (referred
    to as Services in this chapter). Hence, the kiosk can access the Redis host via
    environment variables.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`lcredis-service.default`暴露给kiosk pods作为环境变量。这是kube-dns为`Service`对象创建的DNS名称（在本章中称为Services）。因此，kiosk可以通过环境变量访问Redis主机。
- en: 'In the end, we''ll create a recorder. This doesn''t expose any interface to
    others, so it doesn''t need a `Service` object:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将创建一个录制器。这个录制器不会向外暴露任何接口，因此不需要`Service`对象：
- en: '[PRE72]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The recorder needs to access both Redis and MySQL. It uses root credentials
    that are injected via a secret. Both endpoints for Redis and MySQL are accessed
    via a service DNS name, `<service_name>.<namespace>`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 录制器需要同时访问Redis和MySQL。它使用通过密钥注入的root凭据。Redis和MySQL的两个端点通过服务的DNS名称`<service_name>.<namespace>`进行访问。
- en: 'We could then check the `Deployment` objects:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以检查`Deployment`对象：
- en: '[PRE73]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As expected, we have four `Deployment` objects with a different desired count
    of pods.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们有四个`Deployment`对象，且每个对象的期望pod数量不同。
- en: As we expose the kiosk as a NodePort, we should be able to access its service
    endpoint and see whether it works properly. Assume we have a node, the IP of which
    is `192.168.99.100`, and the NodePort that Kubernetes allocates is `30520`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将kiosk暴露为NodePort时，我们应该能够访问它的服务端点，并检查它是否正常工作。假设我们有一个节点，它的IP地址是`192.168.99.100`，Kubernetes分配的NodePort是`30520`。
- en: 'If you''re using minikube, `minikube service [-n NAMESPACE] [--url] NAME` could
    help you access service NodePort via your default browser:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用minikube，`minikube service [-n NAMESPACE] [--url] NAME`可以帮助你通过默认浏览器访问服务的NodePort：
- en: '`**// open kiosk console**`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`**// 打开kiosk控制台**`'
- en: '`**# minikube service kiosk-service**`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`**# minikube service kiosk-service**`'
- en: '`**Opening kubernetes service default/kiosk-service in default browser...**`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`**正在默认浏览器中打开kuberenetes服务default/kiosk-service...**`'
- en: This will allow us to find out the IP and the port.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们找到IP和端口。
- en: 'We could then create and get a ticket using `POST` and `GET /tickets`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`POST`和`GET /tickets`创建并获取票据：
- en: '[PRE74]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned the basic concepts of Kubernetes. We learned that
    a Kubernetes master has kube-apiserver to handle requests and controller managers
    are the control center of Kubernetes. These ensure our desired container amount
    is fulfilled, they control the endpoint to associate pods and services, and they
    control API access tokens. We also have Kubernetes nodes, which are the workers
    to host the containers, receive the information from the master, and route the
    traffic based on the configuration.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Kubernetes的基本概念。我们了解到，Kubernetes主节点有kube-apiserver来处理请求，而控制器管理器是Kubernetes的控制中心。它们确保我们期望的容器数量得到满足，控制pods与服务之间的关联端点，并且控制API访问令牌。我们还学习了Kubernetes节点，它们是用来托管容器的工作节点，接收来自主节点的信息，并根据配置路由流量。
- en: We then used minikube to demonstrate basic Kubernetes objects, including pods,
    ReplicaSets, Deployments, Services, secrets, and ConfigMaps. Finally, we demonstrated
    how to combine all of the concepts we've learned into our kiosk application.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用minikube演示了基本的Kubernetes对象，包括pods、ReplicaSets、Deployments、Services、secrets和ConfigMaps。最后，我们演示了如何将我们学到的所有概念结合起来构建我们的kiosk应用。
- en: As we mentioned previously, the data inside containers will disappear when a
    container is gone. Therefore, volume is extremely important to persist the data
    in the container world. In [Chapter 4](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml),
    *Managing Stateful Workloads*, we'll be learning how volume works and how to use
    persistent volume.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，容器中的数据会在容器被删除时消失。因此，在容器世界中，卷（volume）是非常重要的，它能够持久化数据。在[第4章](c3083748-0f68-488f-87e0-f8c61deeeb80.xhtml)《管理有状态工作负载》中，我们将学习卷是如何工作的，以及如何使用持久卷。
