- en: '*Chapter 5*: Exploring Infrastructure Platform Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success of running an infrastructure platform product with Crossplane depends
    on following a few principles and patterns as and when required. This chapter
    will explore some of these critical practices. We will also learn a few debugging
    skills while exploring the concepts. After learning the basics of the Crossplane
    in the last few chapters, this will be a place for learning advanced patterns
    that are key to building the state-of-the-art infrastructure platform for your
    organization. You will learn a few critical aspects of building robust XR APIs
    and debugging issues with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Evolving the APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested and multi-resource XRs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XRD detailed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing external software resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolving the APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Crossplane is primarily an API-based infrastructure automation platform. Changes
    to the APIs are inevitable as the business requirements and technology landscape
    evolve. We can classify these changes into three different buckets:'
  prefs: []
  type: TYPE_NORMAL
- en: API implementation change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-breaking API contract change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking API contract change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the API implementation change.
  prefs: []
  type: TYPE_NORMAL
- en: API implementation change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These changes are limited to the API implementation details without any changes
    to the contract. In other words, these are changes to Compositions YAML, a construct
    used by XR for API implementation. `CompositionRevision` is the Crossplane concept
    that will work with compositions to support such changes. If the `--enable-composition-revisions`
    flag is set while installing Crossplane, a `CompositionRevision` object is created
    with all the updates to composition. The name of the `CompositionRevision` object
    is autogenerated on every increment. The compositions are mutable objects that
    can change forever, but individual `CompositionRevision` is immutable. `Composition`
    and `CompositionRevision` are in one-to-many relationships. We will have only
    one `CompositionRevision` active at any given instance. The latest revision number
    will always be active, excluding the following scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Each configuration state of the composition maps to a single `CompositionRevision`.
    Let’s say we are in revision 2 and changing the composition configuration the
    same as the first revision. A new revision is not created. Instead, revision 1
    becomes active, making revision 2 inactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Crossplane environment where the composition revision flag is enabled,
    we will have two attributes automatically added to every XR/Claim object by Crossplane.
    The following are attribute names and how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spec.compositionRevisionRef`: This will hold the name of `CompositionRevision`
    with which the resources are created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.compositionUpdatePolicy`: This attribute will indicate whether the XR/Claim
    will automatically migrate to a new, available `CompositionRevision`. Manual and
    automatic are the two possible values, with automatic as the default value. If
    you would like to override the default behavior, add this attribute with a manual
    indicator in the XR/Claim configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents how `Composition` and `CompositionRevision`
    work together to evolve infrastructure API implementation continuously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Evolving compositions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Evolving compositions
  prefs: []
  type: TYPE_NORMAL
- en: To manually migrate the composition, update the `spec.compositionRevisionRef`
    configuration in the XR/Claim with the latest revision name. This specific design
    enables the separation of concerns between the platform API creator and consumers.
    Infrastructure API creators will update the compositions, and API consumers can
    choose their revision upgrade strategy. If you want a specific revision of composition
    to be used while creating an XR/Claim, explicitly mention the revision name under
    `spec.compositionRevisionRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some examples of such changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bugfix**: Let''s say we mapped an incorrect attribute to the XRD status field.
    The scope of the correct mapping is limited to changes in the respective Composition
    patch section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy changes without contract change**: Adding a new infrastructure compliance
    policy to provide all new resources in a specific region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared infrastructure**: Moving toward a shared **Virtual Private Cloud**
    (**VPC**) instead of dynamically provisioning a new VPC for all new XR/Claim requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The composition revision flag is not enabled by default. Use the `--enable-composition-revisions`
    argument with a Crossplane pod to enable composition revision. The following Helm
    command will set up/update the Crossplane environment with composition revision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The following section will look at composition revision with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on journey with composition revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go through a hands-on journey to experience composition revision. The
    objectives of the exercise will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building an XR API for GCP MySQL provisioning in a composition revision-enabled
    Crossplane environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating two MySQL instances with automated and manual composition revision
    policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the Composition to change the calculation for database disk size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating if the MySQL instance with automated revision policy automatically
    migrates to the latest composition revision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing that the MySQL instance with the manual revision policy does not migrate
    to the latest composition revision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, migrating the second MySQL instance manually to the latest composition
    revision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use a simple XRD and composition to explore composition revision. The
    following is the XRD with just one parameter that takes the MySQL disk size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The composition for the preceding XRD is as follows, which patches the `size`
    attribute from XR into the GCP CloudSQLInstance MR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply both the YAML to a target Crossplane cluster with composition revision
    enabled. You will see that `CompositionRevision` is created for the composition.
    Execute the following command to view all `CompositionRevision` for the given
    composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot with one revision object created for the
    `gcp-mysql` composition. Note that the `current` attribute is true for revision
    1\. It will change if we update the composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Composition Revision list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Composition Revision list
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s provision two MySQL instances with the Claim API. An example of
    manual revision update policy configuration is as follows. The automated revision
    version of the YAML will be the same without the `compositionUpdatePolicy` parameter,
    which defaults to an automatic revision update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to the following screenshot with two MySQL instances onboarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – MySQL claims'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – MySQL claims
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the composition patch with a transform function to multiply the
    disk size by four before patching. The patches section of the updated composition
    will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the composition, you will see two revisions. Only the latest
    revision will have the `current` flag of `true`. Also, we can notice that the
    MySQL provisioned with an automated revision update policy would have increased
    the storage. The following screenshot summarizes the output after applying the
    updated composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – New Composition Revision'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – New Composition Revision
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can manually upgrade the second MySQL instance by adding the `spec.compositionRevisionRef`
    attribute to the XR/Claim configuration. The field will hold the autogenerated
    composition revision name. The composition revision hands-on journey example is
    available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision).
    In the following section, we will explore the ways to change the XR API contract.
  prefs: []
  type: TYPE_NORMAL
- en: API contract changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'API implementation details are just one direction in which XR changes can evolve.
    The highly interoperable API contract between the XR creating and consuming teams
    also needs to change over time. Contract change can fall under two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-breaking changes**: The XR API will be backward-compatible, meaning that
    consumers are either not impacted by the change or can choose to adopt the new
    changes at their phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breaking changes**: The XR API will not be backward-compatible. A new API
    version must be introduced, and the old API version must be deprecated at an appropriate
    time. All old API users should be safely migrating to the new API version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s delve into non-breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: Non-breaking changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding one or more optional parameters to the XRD contract can be considered
    a non-breaking change. It is non-breaking because the old external resources provisioned
    can co-exist with the new schema as the new parameters are optional. Note that
    removing an existing optional parameter in the XRD is a breaking change as Crossplane
    upfront does not know how to reconcile existing provisioned resources. A simple
    way to think about this is that if Composition/CompositionRevision can handle
    the co-existence of old and newly provisioned resources, then the XRD contract
    change is non-breaking. A new optional parameter in the MySQL XR to choose the
    disk size is an example of a non-breaking change. The change will involve both
    a contract change and a composition revision. Let’s go through a hands-on journey
    to make the previous XR example. All the configuration YAML required for this
    journey is available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking).
    Refer to the following screenshot of our hands-on journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Non-breaking contract change'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Non-breaking contract change
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to be performed throughout the hands-on journey
    to experiment with the non-breaking contract change:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the first version of the XRD in the target cluster (`xrd-v1.yaml`). The
    schema has `vm` as a mandatory parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the first revision of the composition (`Composition-V1.yaml`). It will
    patch the `vm` value back into the `MR-CloudSQLInstance` tier attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the MySQL resource can be provisioned with `db-n1-standard-1` as the tire
    in GCP (`Claim-v1.yaml`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update and apply the XRD with an additional optional parameter, `size`, to specify
    the database disk size (`xrd-v2.yaml`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update and apply the new composition (`Composition-V2.yaml`). It will patch
    the additional size parameter into the MR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create the second MySQL instance with a specific disk size and tire
    (`Claim-v2.yaml`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To validate whether the first MySQL instance can be sill updated, change the
    tier with an update YAML (`Claim-v1-validate.yaml`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We did not upgrade the API version when updating the contract. We will discuss
    this more in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Version upgrade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we did not change the XRD version number from v1\.
    Crossplane does not currently support XR version upgrades once a contract changes.
    API versioning without a contract change will be helpful in indicating API stability
    (alpha, beta, v1, and so on). We can just move from alpha to beta to a more stable
    version without changing the contract. The version upgrade is currently achieved
    by listing the old and new version definitions in the XRD. The `versions` array
    is the construct used for listing multiple versions. The two critical Boolean
    attributes under each version are `served` and `referenceable`. The `referenceable`
    flag will determine whether we can define a composition implementation for the
    given version. Only one version can have the referenceable flag set to `true`.
    This will be the version used by any new XR create/update event. A create/update
    event triggered by the old API version will still use the composition from the
    latest version, marked as referenceable. The `served` flag will indicate whether
    the given XR API version is in use. Some teams may still use the old version to
    consume the API. Switching off the `served` flag means that the given version
    is no longer available for clients. It will be the last step before removing the
    old version from the XR.
  prefs: []
  type: TYPE_NORMAL
- en: Look at a sample XRD with three versions, alpha, beta, and v1, at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml).
    This XRD has three versions. Version alpha will no longer be served, and beta
    will be served but cannot be referred for resource creation or update. The latest
    version, v1, will be the preferred version for any resource creation or updates.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes CRDs support multiple API versions both with and without an API contract
    change. When there is an API contract change, a conversion webhook is configured
    by the CRD author to support conversion between the versions. Conversions are
    required as CR objects will be stored in the etcd with both old and new contracts.
    XRD, the Crossplane equivalent to CRDs, does not take this approach. A conversion
    webhook involves programming. Taking that route will violate the no-code agenda
    of Crossplane when composing APIs. It’s important to note that the Crossplane
    community is actively working to build a configuration-based solution to support
    conversion and migration between versions.
  prefs: []
  type: TYPE_NORMAL
- en: Version upgrade with breaking changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative approach supports breaking contracts by introducing a new XR
    API parallel. This approach uses an external naming technique and deletion policy
    to handle breaking changes. With this pattern, we will migrate the resources to
    a new XR API and remove the old API once the migration is finished in its entirety.
    The steps to achieve such a version upgrade are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the v1 version of XRD. In the composition, define a standard nomenclature
    for naming the external resources (MRs). We should be able to reconstruct the
    names again in the new API. Generally, we can concatenate the XR and the composition
    name (`<XR>+'-'+<Composition>`). You can come up with a resource naming strategy
    that suits your environment. Maybe we can even use the namespace name to represent
    the product owner of the resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that all the MRs in the composition have `spec.deletionPolicy` defined
    as `Orphan`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s say we have a couple of consumers for the XR, and they have created a
    few external resources. Assume that we have a policy requirement that requires
    breaking changes to the API contract.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To support the breaking change, delete all v1 versions of the XR. It will just
    delete the Crossplane references. The external resources are not deleted on account
    of the orphan deletion policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, delete the v1 version of XRD and Composition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create the new v2 version of XRD with the same XR name. Update the
    composition to handle the recent breaking changes. Ensure that the new composition
    follows the same external resource name creation logic and maps to the new XRD
    version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the deleted XR objects again, pointing to the v2 version of the API.
    The new XR objects will reference the old orphaned external resources. Crossplane
    controllers will reconcile any attribute value change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that this type of migration to a new API version must be coordinated with
    all the XR-consuming teams. Once the migration is completed, the old API version
    will no longer be available. The following figure represents the migration process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Version migration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Version migration
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is always good to have a standard way of generating external resource names.
    In addition to version migration, a reproducible naming pattern can afford several
    other advantages. Using pre-provisioned resources for a shared or cached infrastructure
    is an example of using the standard external resource naming pattern. Migrating
    resources to a new Crossplane environment can be another example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s recommended to go through a hands-on journey of breaking API contract,
    with the sample configuration provided at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking).
    Perform the following steps to go through the hands-on journey to handle breaking
    contract changes:'
  prefs: []
  type: TYPE_NORMAL
- en: First, execute `xrd-v1.yaml`, `Composition-V1.yaml`, and `Claim.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will create an XRD and a Composition with the database size as optional parameter
    and the VM as a mandatory parameter. The Claim will provision the database wih
    the specified size and VM. The provisioned resource will get a standard external
    resource name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `claim.name` label in `Claim.yaml` is used for constructing the
    external resource name in the composition section. It should be unique for every
    XR/Claim object to generate unique external resource names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s now delete the v1 version of Claim, Composition, and XRD. When we delete
    the v1 claim, the external resource will not be deleted because the deletion policy
    is configured as an orphan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, apply the v2 version of Claim, Composition, and XRD. In the v2 XRD,
    we have broken the contract by removing the mandatory parameter, `vm`. The new
    v2 claim (`Claim-migrate.yaml`) will not have the `vm` parameter. Note that both
    Composition and Claim will point to the v2 version XRD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the Crossplane will reclaim the orphaned resource and reconcile
    the virtual machine with the new default value provided in the Composition. We
    can validate that by looking into the GCP console or the Claim resource description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot where the preceding example is tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – XRD breaking changes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – XRD breaking changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code snippet relating to external resource name patching from
    the preceding Composition example. This must be present in both composition versions,
    and the name generated should be the same for both versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have used a new transform type to format the string before we patch.
    With this, we conclude the different ways of evolving the XR APIs. We will dive
    into an interesting case in the following section to build one XR composing another
    XR.
  prefs: []
  type: TYPE_NORMAL
- en: Nested and multi-resource XRs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every software product depends on more than one infrastructure resource. It
    is essential to build single infrastructure recipes in order for the product teams
    to consume with a unified experience. The orchestration of infrastructure dependencies
    should remain abstracted. Such recipes require multiple resources to be composed
    into a single XR. In all the examples hitherto, we have always composed a single
    GCP resource inside an XR. Let’s look at an XR sample where multiple GCP resources
    are composed into a single XR API. The following figure represents the resources
    and XR APIs that we are going to work with in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Multi-resource nested XR'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Multi-resource nested XR
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to multiple resource provisioning in a single XR, we also have
    a nested XR pattern in *Figure 5.8*. We are composing three resources within two
    XRs. The first XR composes two resources, and the second XR composes the first
    XR and a database resource. Let’s look at the details of each XR:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XR 1**: We will compose a Google Kubernetes Engine cluster and a Google Cloud
    storage resource with this XR. The idea is to provide cloud storage to hold the
    application logs for future analysis. Note that this XR will not have a claim
    name in the XRD definition. It will be of a cluster scope and a private API for
    the platform team. Product teams with access only to a namespace will not use
    this API directly. This XR will expose the region and the autopilot configuration
    as parameters. The region will be propagated back into both the resources and
    the autopilot configuration is used for the Kubernetes provisioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XR/Claim 2**: The second XR will compose the MySQL database, an MR, and the
    first XR to create a nested API. We will patch region parameters to the MySQL
    MR and propagate the same into the inner XR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All examples in this hands-on journey are available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create the XRD and Composition for both the XRs. Apply `xrd k8s.yaml`,
    `Composition k8s.yaml`, `xrd Application.yaml`, and `Composition Application.yaml`
    to the Crossplane cluster. You will see that the `ESTABLISHED` flag is `True`
    for both the XRDs. This indicates that the Crossplane has started a new controller
    to reconcile the established XR. The `OFFERED` flag will be `True` for the application
    XR and `False` for the Kubernetes XR. This indicates that the Crossplane has started
    a new controller to reconcile the established Claim only for the application XR.
    It is false for the Kubernetes XR because we don’t have the respective claim.
    Refer to the following screenshot regarding XRD creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Nested XR-XRD and Composition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Nested XR-XRD and Composition
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Similar to creating an XR API with multiple resources from a single cloud provider,
    we can also mix and match resources from multiple clouds. We just have to add
    the resources concerned with respective ProviderConfig clouds.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s now time to create an application Claim resource. Apply Claim `Application.yaml`
    to the Crossplane cluster. You will see that a `CloudSQLInstance` instance, a
    cluster, and a bucket resource have been provisioned. Refer to the following screenshot
    where the resources are provisioned successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Resource provisioning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Resource provisioning
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to explore each resource in detail, use the Resource references.
    Execute `kubectl describe application my-application -n alpha` to see the details
    of the claim. It will refer to the `XApplication` XR object. If we look at the
    details of the `XApplication` object, it will hold the reference to the `CloudSQLInstance`
    MR and `XGCPCluster` XR. Similarly, we can go on till you reach the last MR. This
    is beneficial for debugging activities. Sometimes you may see that the resources
    are not getting ready. In those instances, explore each nested resource and refer
    to the events section to ascertain what is happening. An example of referring
    nested resources from the resource description is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Nested resource reference example 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Nested resource reference example 1
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot represented the Application claim description referring
    to the `XApplication` XR resource. The following screenshot represents the `XApplication`
    XR description referring to the `XGCPCluster` XR instance and `CloudSQLInstance`
    MR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Nested resource reference example 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Nested resource reference example 2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example event that tells us that we have provided the wrong
    region as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Resource description with an error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Resource description with an error
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: We need to follow many more patterns when we compose multiple resources to give
    a unified experience for product teams. The preceding example is a simple example
    to start the topic. We will see more on this in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: PatchSets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look at the composition in the preceding example, you can see that we
    have used a new pattern called `patchSets` function definition to patch a region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define multiple `patchSet` functions. To include a specific patch set
    function within a given resource, use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We will see more nested and multi-resource XR examples in the upcoming chapters.
    In the following section, we will look at detailed configuration options for defining
    the XRD schema.
  prefs: []
  type: TYPE_NORMAL
- en: XRD detailed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While looking at **Composite Resource Definition** (**XRD**) in the previous
    chapter, we touched on limited configuration options required to learn the basics
    of XR. It’s now time to look at more detailed configuration options to build clean
    and robust XR APIs. A significant part of the details we will look at are about
    openAPIV3Schema, which is used to define the input and output of the XR API. The
    following are the topics we will cover in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Naming the versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The openAPIV3Schema structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The additional parameter of an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printer columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the *Naming the versions section*.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The version name of our XRD cannot have any random string. It has a specific
    validation inherited from the CRDs and standard Kubernetes APIs. The string can
    contain only lowercase alphanumeric characters and `-`. Also, it must always start
    with an alphabetic character and end with an alphanumeric character, which means
    that `-` cannot be the start or ending character. Also, a number cannot be the
    starting character. Some valid versions are `my-version`, `version-1`, `abc-version1`,
    and `v1`. While we can have many permutations and combinations for naming a version,
    some standard practices are followed across CRDs. Following the same with XRDs
    will enable API consumers to understand the stability of the API. The version
    string starts with `v` followed by a number with these standards (v1, v2). This
    is then optionally followed by either `alpha` or `beta`, depending on the API’s
    stability. Generally, the `alpha` string represents the lowest stability (`v5alpha`),
    while `beta` is the next stability level (`v3beta`). If both texts are missing,
    the XR is ready for production use. An optional number can follow the optional
    `alpha`/`beta` text representing the incremental releases (`v2alpha1`, `v2alpha2`,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an invalid version string provided with the XRD, you will see that
    the XRD will not get configured properly. The `ESTABLISHED` flag will not be set
    to `True`. You apply the `– xrd\ invalid\ version\ test.yaml` file from the `samples`
    folder to see what happens when you have an incorrect version number. Refer to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Invalid version XRD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – Invalid version XRD
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you will be able to see the following error logs in the Crossplane pod
    in the crossplane-system namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When we troubleshoot an issue with Crossplane, logs from the Crossplane pod
    can help. Enable debugging mode by adding an argument, `--debug`, to the Crossplane
    pod. Similarly, we can even look at the provider’s container logs.
  prefs: []
  type: TYPE_NORMAL
- en: The openAPIV3Schema structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The specification of the XR API is defined using `openAPIV3Schema`. Every configuration
    element in the XRD under this section represents the input and output of the XR
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, we configure the `openAPIV3Schema` section with two objects, `spec`
    and `status`. The `spec` object represents the API input, while the `status` object
    represents the response. We can skip defining the `status` section in XRD if we
    don’t have any custom requirements. Crossplane would inject the standard status
    fields into the XR/Claim. Refer to the following code snippet representing the
    `openAPIV3Schema` configuration template for the XR API input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The schema configuration is all about a mix of `-` attributes, their types,
    and properties. An `attribute` type of `object` will hold a list of properties.
    For example, the root attribute `openAPIV3Schema:` is of the `object` type followed
    by a list of properties (`spec` and `status`). A list of properties is nothing
    but a list of attributes. Suppose the attribute type is primitive, such as `string`
    or `integer`. Such an attribute will be the end node. The object-properties recursion
    can continue in as much depth as we require. Refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we can look at a few additional valuable configuration
    options along with the basic `openAPIV3Schema` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The additional parameter of an attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The attribute node can configure a few other critical configurations that API
    developers will use daily. Following are some of the frequently used configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description** is a string that will help us provide valuable information
    for the API consumers about the attribute. It can hold information about the use
    of the parameter, possible values we can configure, and validation requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Required** is an attribute representing the list of mandatory inputs that
    are required from the user for the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default** is an attribute that provides a default value if the user does
    not input a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enum** can configure the list of possible values for a given attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these fields, there is a list of validation-related configurations
    including `minimum`, `maximum`, `pattern`, `maxLength`, and `minLength`. Refer
    to the following sample configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: To explore more detailed possibilities, visit [https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We can use the description field to announce the parameter deprecation information.
    This technique can be helpful in delaying breaking changes to a contract by making
    a mandatory field optional with a deprecation message.
  prefs: []
  type: TYPE_NORMAL
- en: Printer columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the printer columns to add what `kubectl` will display when we get
    the resource list. We should provide a name, data type, and JSON path mapping
    to the attribute we wish to display for each column. Optionally, we may also provide
    a description. Refer to the following sample configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The printer column configuration remains parallel to the schema configuration.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of detailed XRD configuration. We have covered
    most of the configuration required for day-to-day work, but there are endless
    possibilities. It will add value by reading up on CRD at [https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/).
  prefs: []
  type: TYPE_NORMAL
- en: Managing external software resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have always talked about managing external infrastructure resources using
    Crossplane from the beginning of this book. However, it does not always have to
    be just an infrastructure resource. We could even manage external software applications
    from Crossplane. For a software application to be able to work best with the Crossplane
    ecosystem, it must have the following qualities:'
  prefs: []
  type: TYPE_NORMAL
- en: We should have well-defined and stable APIs to perform CRUD operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API should have a high-fidelity design with filters to control granular
    application configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s time to look at an example. Think about deploying an application in Kubernetes
    using Helm. Helm can package any application and provide a well-defined CRUD API
    to deploy, read, update, and uninstall. Above all, we can create granular control
    over the application configuration with parameters. We have a helm Crossplane
    provider already available and used extensively by the community. The idea of
    managing external applications from a Crossplane control plane can enable a new
    world of unifying application and infrastructure automation. The following section
    will cover the unifying aspect in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Unifying the automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing external software resources with Crossplane is the crossroad for unifying
    infrastructure and application DevOps. We could package software and infrastructure
    dependencies into a single XRs. Such a complete package of applications and infrastructure
    introduces numerous advantages, some of which are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The approach will unify the tooling and skills required for application and
    infrastructure automation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More importantly, the entire stack will enjoy the advantages of the Kubernetes
    operating model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating vendor software into an enterprise ecosystem will become quicker
    and more standardized. Software vendors can quickly build packages that fit into
    different ecosystems. Currently, software vendors must custom-build for the individual
    cloud provider marketplace. This approach can assist in building a universal vendor
    software marketplace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily apply the audit process to comply with any compliance standards.
    Previously, this would have been complicated as software and its infrastructure
    dependencies are spread about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure represents a unified XR API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Unified XR'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – Unified XR
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: In a later chapter, we can go through a hands-on journey to experience building
    an XR API covering both applications and infrastructure dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope it’s been fun to read this chapter and go through the hands-on journey.
    It covered different patterns that are useful in our day-to-day work when adopting
    Crossplane. We covered different ways to evolve our XR APIs, detailed XR configurations,
    how to manage application resources, and nested and multi-resource XRs. There
    are more patterns to be covered.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will discuss more advanced Crossplane methods and their respective
    hands-on journeys.
  prefs: []
  type: TYPE_NORMAL
