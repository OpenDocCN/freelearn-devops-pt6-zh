- en: '*Chapter 5*: Exploring Infrastructure Platform Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success of running an infrastructure platform product with Crossplane depends
    on following a few principles and patterns as and when required. This chapter
    will explore some of these critical practices. We will also learn a few debugging
    skills while exploring the concepts. After learning the basics of the Crossplane
    in the last few chapters, this will be a place for learning advanced patterns
    that are key to building the state-of-the-art infrastructure platform for your
    organization. You will learn a few critical aspects of building robust XR APIs
    and debugging issues with ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Evolving the APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested and multi-resource XRs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XRD detailed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing external software resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolving the APIs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Crossplane is primarily an API-based infrastructure automation platform. Changes
    to the APIs are inevitable as the business requirements and technology landscape
    evolve. We can classify these changes into three different buckets:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: API implementation change
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-breaking API contract change
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking API contract change
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the API implementation change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: API implementation change
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These changes are limited to the API implementation details without any changes
    to the contract. In other words, these are changes to Compositions YAML, a construct
    used by XR for API implementation. `CompositionRevision` is the Crossplane concept
    that will work with compositions to support such changes. If the `--enable-composition-revisions`
    flag is set while installing Crossplane, a `CompositionRevision` object is created
    with all the updates to composition. The name of the `CompositionRevision` object
    is autogenerated on every increment. The compositions are mutable objects that
    can change forever, but individual `CompositionRevision` is immutable. `Composition`
    and `CompositionRevision` are in one-to-many relationships. We will have only
    one `CompositionRevision` active at any given instance. The latest revision number
    will always be active, excluding the following scenario.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Each configuration state of the composition maps to a single `CompositionRevision`.
    Let’s say we are in revision 2 and changing the composition configuration the
    same as the first revision. A new revision is not created. Instead, revision 1
    becomes active, making revision 2 inactive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Crossplane environment where the composition revision flag is enabled,
    we will have two attributes automatically added to every XR/Claim object by Crossplane.
    The following are attribute names and how they are used:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`spec.compositionRevisionRef`: This will hold the name of `CompositionRevision`
    with which the resources are created.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.compositionUpdatePolicy`: This attribute will indicate whether the XR/Claim
    will automatically migrate to a new, available `CompositionRevision`. Manual and
    automatic are the two possible values, with automatic as the default value. If
    you would like to override the default behavior, add this attribute with a manual
    indicator in the XR/Claim configuration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents how `Composition` and `CompositionRevision`
    work together to evolve infrastructure API implementation continuously:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Evolving compositions'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Evolving compositions
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: To manually migrate the composition, update the `spec.compositionRevisionRef`
    configuration in the XR/Claim with the latest revision name. This specific design
    enables the separation of concerns between the platform API creator and consumers.
    Infrastructure API creators will update the compositions, and API consumers can
    choose their revision upgrade strategy. If you want a specific revision of composition
    to be used while creating an XR/Claim, explicitly mention the revision name under
    `spec.compositionRevisionRef`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some examples of such changes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**Bugfix**: Let''s say we mapped an incorrect attribute to the XRD status field.
    The scope of the correct mapping is limited to changes in the respective Composition
    patch section.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy changes without contract change**: Adding a new infrastructure compliance
    policy to provide all new resources in a specific region.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared infrastructure**: Moving toward a shared **Virtual Private Cloud**
    (**VPC**) instead of dynamically provisioning a new VPC for all new XR/Claim requests.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The composition revision flag is not enabled by default. Use the `--enable-composition-revisions`
    argument with a Crossplane pod to enable composition revision. The following Helm
    command will set up/update the Crossplane environment with composition revision:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following section will look at composition revision with an example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on journey with composition revision
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go through a hands-on journey to experience composition revision. The
    objectives of the exercise will be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Building an XR API for GCP MySQL provisioning in a composition revision-enabled
    Crossplane environment
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating two MySQL instances with automated and manual composition revision
    policies
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the Composition to change the calculation for database disk size
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating if the MySQL instance with automated revision policy automatically
    migrates to the latest composition revision
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing that the MySQL instance with the manual revision policy does not migrate
    to the latest composition revision
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, migrating the second MySQL instance manually to the latest composition
    revision
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use a simple XRD and composition to explore composition revision. The
    following is the XRD with just one parameter that takes the MySQL disk size:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The composition for the preceding XRD is as follows, which patches the `size`
    attribute from XR into the GCP CloudSQLInstance MR:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Apply both the YAML to a target Crossplane cluster with composition revision
    enabled. You will see that `CompositionRevision` is created for the composition.
    Execute the following command to view all `CompositionRevision` for the given
    composition:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Refer to the following screenshot with one revision object created for the
    `gcp-mysql` composition. Note that the `current` attribute is true for revision
    1\. It will change if we update the composition:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Composition Revision list'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Composition Revision list
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s provision two MySQL instances with the Claim API. An example of
    manual revision update policy configuration is as follows. The automated revision
    version of the YAML will be the same without the `compositionUpdatePolicy` parameter,
    which defaults to an automatic revision update:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can refer to the following screenshot with two MySQL instances onboarded:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – MySQL claims'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – MySQL claims
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the composition patch with a transform function to multiply the
    disk size by four before patching. The patches section of the updated composition
    will look like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'After updating the composition, you will see two revisions. Only the latest
    revision will have the `current` flag of `true`. Also, we can notice that the
    MySQL provisioned with an automated revision update policy would have increased
    the storage. The following screenshot summarizes the output after applying the
    updated composition:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – New Composition Revision'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_04.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – New Composition Revision
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can manually upgrade the second MySQL instance by adding the `spec.compositionRevisionRef`
    attribute to the XR/Claim configuration. The field will hold the autogenerated
    composition revision name. The composition revision hands-on journey example is
    available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision).
    In the following section, we will explore the ways to change the XR API contract.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: API contract changes
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'API implementation details are just one direction in which XR changes can evolve.
    The highly interoperable API contract between the XR creating and consuming teams
    also needs to change over time. Contract change can fall under two categories:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-breaking changes**: The XR API will be backward-compatible, meaning that
    consumers are either not impacted by the change or can choose to adopt the new
    changes at their phase.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breaking changes**: The XR API will not be backward-compatible. A new API
    version must be introduced, and the old API version must be deprecated at an appropriate
    time. All old API users should be safely migrating to the new API version.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性变更**：XR API将不兼容旧版本。必须引入新API版本，并在适当的时候弃用旧API版本。所有旧的API用户应安全地迁移到新API版本。'
- en: Let’s delve into non-breaking changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨非破坏性变更。
- en: Non-breaking changes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非破坏性变更
- en: 'Adding one or more optional parameters to the XRD contract can be considered
    a non-breaking change. It is non-breaking because the old external resources provisioned
    can co-exist with the new schema as the new parameters are optional. Note that
    removing an existing optional parameter in the XRD is a breaking change as Crossplane
    upfront does not know how to reconcile existing provisioned resources. A simple
    way to think about this is that if Composition/CompositionRevision can handle
    the co-existence of old and newly provisioned resources, then the XRD contract
    change is non-breaking. A new optional parameter in the MySQL XR to choose the
    disk size is an example of a non-breaking change. The change will involve both
    a contract change and a composition revision. Let’s go through a hands-on journey
    to make the previous XR example. All the configuration YAML required for this
    journey is available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking).
    Refer to the following screenshot of our hands-on journey:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向XRD合同中添加一个或多个可选参数可以视为非破坏性变更。这是非破坏性的，因为旧的外部资源可以与新模式共存，因为新参数是可选的。请注意，移除XRD中现有的可选参数是破坏性变更，因为Crossplane在前端无法知道如何调和现有的已配置资源。一个简单的思考方式是，如果Composition/CompositionRevision能够处理旧资源和新配置资源的共存，那么XRD合同变更就是非破坏性的。选择磁盘大小的MySQL
    XR中的新可选参数就是一个非破坏性变更的例子。此变更将涉及合同变更和组合修订。让我们通过一个动手实践过程来完成前面的XR示例。此过程所需的所有配置YAML文件可以在[https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking)查看。参考以下动手过程的截图：
- en: '![Figure 5.5 – Non-breaking contract change'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 非破坏性合同变更'
- en: '](img/B17830_05_05.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_05.jpg)'
- en: Figure 5.5 – Non-breaking contract change
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 非破坏性合同变更
- en: 'The following are the steps to be performed throughout the hands-on journey
    to experiment with the non-breaking contract change:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是整个动手实践过程中实验非破坏性合同变更时需要执行的步骤：
- en: Create the first version of the XRD in the target cluster (`xrd-v1.yaml`). The
    schema has `vm` as a mandatory parameter.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标集群中创建XRD的第一个版本（`xrd-v1.yaml`）。该模式将`vm`作为必需参数。
- en: Create the first revision of the composition (`Composition-V1.yaml`). It will
    patch the `vm` value back into the `MR-CloudSQLInstance` tier attribute.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组合的第一个修订版（`Composition-V1.yaml`）。它将把`vm`值补丁回`MR-CloudSQLInstance`层属性。
- en: Now, the MySQL resource can be provisioned with `db-n1-standard-1` as the tire
    in GCP (`Claim-v1.yaml`).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，MySQL资源可以通过`db-n1-standard-1`作为GCP中的配置选择来配置（`Claim-v1.yaml`）。
- en: Update and apply the XRD with an additional optional parameter, `size`, to specify
    the database disk size (`xrd-v2.yaml`).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并应用XRD，增加一个可选参数`size`来指定数据库磁盘大小（`xrd-v2.yaml`）。
- en: Update and apply the new composition (`Composition-V2.yaml`). It will patch
    the additional size parameter into the MR.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并应用新的组合（`Composition-V2.yaml`）。它将把额外的大小参数补丁到MR中。
- en: Finally, create the second MySQL instance with a specific disk size and tire
    (`Claim-v2.yaml`).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建第二个具有特定磁盘大小和配置的MySQL实例（`Claim-v2.yaml`）。
- en: To validate whether the first MySQL instance can be sill updated, change the
    tier with an update YAML (`Claim-v1-validate.yaml`).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证第一个MySQL实例是否仍然可以更新，请使用更新的YAML（`Claim-v1-validate.yaml`）更改配置。
- en: We did not upgrade the API version when updating the contract. We will discuss
    this more in the upcoming section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新合同时，我们没有升级API版本。我们将在接下来的部分讨论这个问题。
- en: Version upgrade
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本升级
- en: In the previous section, we did not change the XRD version number from v1\.
    Crossplane does not currently support XR version upgrades once a contract changes.
    API versioning without a contract change will be helpful in indicating API stability
    (alpha, beta, v1, and so on). We can just move from alpha to beta to a more stable
    version without changing the contract. The version upgrade is currently achieved
    by listing the old and new version definitions in the XRD. The `versions` array
    is the construct used for listing multiple versions. The two critical Boolean
    attributes under each version are `served` and `referenceable`. The `referenceable`
    flag will determine whether we can define a composition implementation for the
    given version. Only one version can have the referenceable flag set to `true`.
    This will be the version used by any new XR create/update event. A create/update
    event triggered by the old API version will still use the composition from the
    latest version, marked as referenceable. The `served` flag will indicate whether
    the given XR API version is in use. Some teams may still use the old version to
    consume the API. Switching off the `served` flag means that the given version
    is no longer available for clients. It will be the last step before removing the
    old version from the XR.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Look at a sample XRD with three versions, alpha, beta, and v1, at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml).
    This XRD has three versions. Version alpha will no longer be served, and beta
    will be served but cannot be referred for resource creation or update. The latest
    version, v1, will be the preferred version for any resource creation or updates.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes CRDs support multiple API versions both with and without an API contract
    change. When there is an API contract change, a conversion webhook is configured
    by the CRD author to support conversion between the versions. Conversions are
    required as CR objects will be stored in the etcd with both old and new contracts.
    XRD, the Crossplane equivalent to CRDs, does not take this approach. A conversion
    webhook involves programming. Taking that route will violate the no-code agenda
    of Crossplane when composing APIs. It’s important to note that the Crossplane
    community is actively working to build a configuration-based solution to support
    conversion and migration between versions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Version upgrade with breaking changes
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative approach supports breaking contracts by introducing a new XR
    API parallel. This approach uses an external naming technique and deletion policy
    to handle breaking changes. With this pattern, we will migrate the resources to
    a new XR API and remove the old API once the migration is finished in its entirety.
    The steps to achieve such a version upgrade are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Create the v1 version of XRD. In the composition, define a standard nomenclature
    for naming the external resources (MRs). We should be able to reconstruct the
    names again in the new API. Generally, we can concatenate the XR and the composition
    name (`<XR>+'-'+<Composition>`). You can come up with a resource naming strategy
    that suits your environment. Maybe we can even use the namespace name to represent
    the product owner of the resource.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that all the MRs in the composition have `spec.deletionPolicy` defined
    as `Orphan`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s say we have a couple of consumers for the XR, and they have created a
    few external resources. Assume that we have a policy requirement that requires
    breaking changes to the API contract.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To support the breaking change, delete all v1 versions of the XR. It will just
    delete the Crossplane references. The external resources are not deleted on account
    of the orphan deletion policy.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, delete the v1 version of XRD and Composition.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create the new v2 version of XRD with the same XR name. Update the
    composition to handle the recent breaking changes. Ensure that the new composition
    follows the same external resource name creation logic and maps to the new XRD
    version.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the deleted XR objects again, pointing to the v2 version of the API.
    The new XR objects will reference the old orphaned external resources. Crossplane
    controllers will reconcile any attribute value change.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that this type of migration to a new API version must be coordinated with
    all the XR-consuming teams. Once the migration is completed, the old API version
    will no longer be available. The following figure represents the migration process:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Version migration'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Version migration
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: It is always good to have a standard way of generating external resource names.
    In addition to version migration, a reproducible naming pattern can afford several
    other advantages. Using pre-provisioned resources for a shared or cached infrastructure
    is an example of using the standard external resource naming pattern. Migrating
    resources to a new Crossplane environment can be another example.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s recommended to go through a hands-on journey of breaking API contract,
    with the sample configuration provided at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking).
    Perform the following steps to go through the hands-on journey to handle breaking
    contract changes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: First, execute `xrd-v1.yaml`, `Composition-V1.yaml`, and `Claim.yaml`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will create an XRD and a Composition with the database size as optional parameter
    and the VM as a mandatory parameter. The Claim will provision the database wih
    the specified size and VM. The provisioned resource will get a standard external
    resource name.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `claim.name` label in `Claim.yaml` is used for constructing the
    external resource name in the composition section. It should be unique for every
    XR/Claim object to generate unique external resource names.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s now delete the v1 version of Claim, Composition, and XRD. When we delete
    the v1 claim, the external resource will not be deleted because the deletion policy
    is configured as an orphan.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, apply the v2 version of Claim, Composition, and XRD. In the v2 XRD,
    we have broken the contract by removing the mandatory parameter, `vm`. The new
    v2 claim (`Claim-migrate.yaml`) will not have the `vm` parameter. Note that both
    Composition and Claim will point to the v2 version XRD.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the Crossplane will reclaim the orphaned resource and reconcile
    the virtual machine with the new default value provided in the Composition. We
    can validate that by looking into the GCP console or the Claim resource description.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot where the preceding example is tested:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – XRD breaking changes'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_07.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – XRD breaking changes
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code snippet relating to external resource name patching from
    the preceding Composition example. This must be present in both composition versions,
    and the name generated should be the same for both versions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that we have used a new transform type to format the string before we patch.
    With this, we conclude the different ways of evolving the XR APIs. We will dive
    into an interesting case in the following section to build one XR composing another
    XR.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Nested and multi-resource XRs
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every software product depends on more than one infrastructure resource. It
    is essential to build single infrastructure recipes in order for the product teams
    to consume with a unified experience. The orchestration of infrastructure dependencies
    should remain abstracted. Such recipes require multiple resources to be composed
    into a single XR. In all the examples hitherto, we have always composed a single
    GCP resource inside an XR. Let’s look at an XR sample where multiple GCP resources
    are composed into a single XR API. The following figure represents the resources
    and XR APIs that we are going to work with in the example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Multi-resource nested XR'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_08.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Multi-resource nested XR
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to multiple resource provisioning in a single XR, we also have
    a nested XR pattern in *Figure 5.8*. We are composing three resources within two
    XRs. The first XR composes two resources, and the second XR composes the first
    XR and a database resource. Let’s look at the details of each XR:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**XR 1**: We will compose a Google Kubernetes Engine cluster and a Google Cloud
    storage resource with this XR. The idea is to provide cloud storage to hold the
    application logs for future analysis. Note that this XR will not have a claim
    name in the XRD definition. It will be of a cluster scope and a private API for
    the platform team. Product teams with access only to a namespace will not use
    this API directly. This XR will expose the region and the autopilot configuration
    as parameters. The region will be propagated back into both the resources and
    the autopilot configuration is used for the Kubernetes provisioning.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XR/Claim 2**: The second XR will compose the MySQL database, an MR, and the
    first XR to create a nested API. We will patch region parameters to the MySQL
    MR and propagate the same into the inner XR.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All examples in this hands-on journey are available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create the XRD and Composition for both the XRs. Apply `xrd k8s.yaml`,
    `Composition k8s.yaml`, `xrd Application.yaml`, and `Composition Application.yaml`
    to the Crossplane cluster. You will see that the `ESTABLISHED` flag is `True`
    for both the XRDs. This indicates that the Crossplane has started a new controller
    to reconcile the established XR. The `OFFERED` flag will be `True` for the application
    XR and `False` for the Kubernetes XR. This indicates that the Crossplane has started
    a new controller to reconcile the established Claim only for the application XR.
    It is false for the Kubernetes XR because we don’t have the respective claim.
    Refer to the following screenshot regarding XRD creation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Nested XR-XRD and Composition'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_09.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Nested XR-XRD and Composition
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Similar to creating an XR API with multiple resources from a single cloud provider,
    we can also mix and match resources from multiple clouds. We just have to add
    the resources concerned with respective ProviderConfig clouds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s now time to create an application Claim resource. Apply Claim `Application.yaml`
    to the Crossplane cluster. You will see that a `CloudSQLInstance` instance, a
    cluster, and a bucket resource have been provisioned. Refer to the following screenshot
    where the resources are provisioned successfully:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Resource provisioning'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_10.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Resource provisioning
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to explore each resource in detail, use the Resource references.
    Execute `kubectl describe application my-application -n alpha` to see the details
    of the claim. It will refer to the `XApplication` XR object. If we look at the
    details of the `XApplication` object, it will hold the reference to the `CloudSQLInstance`
    MR and `XGCPCluster` XR. Similarly, we can go on till you reach the last MR. This
    is beneficial for debugging activities. Sometimes you may see that the resources
    are not getting ready. In those instances, explore each nested resource and refer
    to the events section to ascertain what is happening. An example of referring
    nested resources from the resource description is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Nested resource reference example 1'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_11.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Nested resource reference example 1
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot represented the Application claim description referring
    to the `XApplication` XR resource. The following screenshot represents the `XApplication`
    XR description referring to the `XGCPCluster` XR instance and `CloudSQLInstance`
    MR:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Nested resource reference example 2'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_12.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Nested resource reference example 2
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example event that tells us that we have provided the wrong
    region as a parameter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Resource description with an error'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_13.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Resource description with an error
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Important
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We need to follow many more patterns when we compose multiple resources to give
    a unified experience for product teams. The preceding example is a simple example
    to start the topic. We will see more on this in the upcoming chapters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: PatchSets
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look at the composition in the preceding example, you can see that we
    have used a new pattern called `patchSets` function definition to patch a region:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can define multiple `patchSet` functions. To include a specific patch set
    function within a given resource, use the following code snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We will see more nested and multi-resource XR examples in the upcoming chapters.
    In the following section, we will look at detailed configuration options for defining
    the XRD schema.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: XRD detailed
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While looking at **Composite Resource Definition** (**XRD**) in the previous
    chapter, we touched on limited configuration options required to learn the basics
    of XR. It’s now time to look at more detailed configuration options to build clean
    and robust XR APIs. A significant part of the details we will look at are about
    openAPIV3Schema, which is used to define the input and output of the XR API. The
    following are the topics we will cover in this section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Naming the versions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The openAPIV3Schema structure
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The additional parameter of an attribute
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printer columns
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the *Naming the versions section*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Naming the versions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The version name of our XRD cannot have any random string. It has a specific
    validation inherited from the CRDs and standard Kubernetes APIs. The string can
    contain only lowercase alphanumeric characters and `-`. Also, it must always start
    with an alphabetic character and end with an alphanumeric character, which means
    that `-` cannot be the start or ending character. Also, a number cannot be the
    starting character. Some valid versions are `my-version`, `version-1`, `abc-version1`,
    and `v1`. While we can have many permutations and combinations for naming a version,
    some standard practices are followed across CRDs. Following the same with XRDs
    will enable API consumers to understand the stability of the API. The version
    string starts with `v` followed by a number with these standards (v1, v2). This
    is then optionally followed by either `alpha` or `beta`, depending on the API’s
    stability. Generally, the `alpha` string represents the lowest stability (`v5alpha`),
    while `beta` is the next stability level (`v3beta`). If both texts are missing,
    the XR is ready for production use. An optional number can follow the optional
    `alpha`/`beta` text representing the incremental releases (`v2alpha1`, `v2alpha2`,
    and so on).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an invalid version string provided with the XRD, you will see that
    the XRD will not get configured properly. The `ESTABLISHED` flag will not be set
    to `True`. You apply the `– xrd\ invalid\ version\ test.yaml` file from the `samples`
    folder to see what happens when you have an incorrect version number. Refer to
    the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Invalid version XRD'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_14.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – Invalid version XRD
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you will be able to see the following error logs in the Crossplane pod
    in the crossplane-system namespace:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Tip
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When we troubleshoot an issue with Crossplane, logs from the Crossplane pod
    can help. Enable debugging mode by adding an argument, `--debug`, to the Crossplane
    pod. Similarly, we can even look at the provider’s container logs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The openAPIV3Schema structure
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The specification of the XR API is defined using `openAPIV3Schema`. Every configuration
    element in the XRD under this section represents the input and output of the XR
    API:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Generally, we configure the `openAPIV3Schema` section with two objects, `spec`
    and `status`. The `spec` object represents the API input, while the `status` object
    represents the response. We can skip defining the `status` section in XRD if we
    don’t have any custom requirements. Crossplane would inject the standard status
    fields into the XR/Claim. Refer to the following code snippet representing the
    `openAPIV3Schema` configuration template for the XR API input and output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The schema configuration is all about a mix of `-` attributes, their types,
    and properties. An `attribute` type of `object` will hold a list of properties.
    For example, the root attribute `openAPIV3Schema:` is of the `object` type followed
    by a list of properties (`spec` and `status`). A list of properties is nothing
    but a list of attributes. Suppose the attribute type is primitive, such as `string`
    or `integer`. Such an attribute will be the end node. The object-properties recursion
    can continue in as much depth as we require. Refer to the following code snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: In the following section, we can look at a few additional valuable configuration
    options along with the basic `openAPIV3Schema` configuration.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The additional parameter of an attribute
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The attribute node can configure a few other critical configurations that API
    developers will use daily. Following are some of the frequently used configurations:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '**Description** is a string that will help us provide valuable information
    for the API consumers about the attribute. It can hold information about the use
    of the parameter, possible values we can configure, and validation requirements.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Required** is an attribute representing the list of mandatory inputs that
    are required from the user for the API.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default** is an attribute that provides a default value if the user does
    not input a value.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enum** can configure the list of possible values for a given attribute.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these fields, there is a list of validation-related configurations
    including `minimum`, `maximum`, `pattern`, `maxLength`, and `minLength`. Refer
    to the following sample configuration:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: To explore more detailed possibilities, visit [https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We can use the description field to announce the parameter deprecation information.
    This technique can be helpful in delaying breaking changes to a contract by making
    a mandatory field optional with a deprecation message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Printer columns
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the printer columns to add what `kubectl` will display when we get
    the resource list. We should provide a name, data type, and JSON path mapping
    to the attribute we wish to display for each column. Optionally, we may also provide
    a description. Refer to the following sample configuration:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The printer column configuration remains parallel to the schema configuration.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of detailed XRD configuration. We have covered
    most of the configuration required for day-to-day work, but there are endless
    possibilities. It will add value by reading up on CRD at [https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Managing external software resources
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have always talked about managing external infrastructure resources using
    Crossplane from the beginning of this book. However, it does not always have to
    be just an infrastructure resource. We could even manage external software applications
    from Crossplane. For a software application to be able to work best with the Crossplane
    ecosystem, it must have the following qualities:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: We should have well-defined and stable APIs to perform CRUD operations.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API should have a high-fidelity design with filters to control granular
    application configuration.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s time to look at an example. Think about deploying an application in Kubernetes
    using Helm. Helm can package any application and provide a well-defined CRUD API
    to deploy, read, update, and uninstall. Above all, we can create granular control
    over the application configuration with parameters. We have a helm Crossplane
    provider already available and used extensively by the community. The idea of
    managing external applications from a Crossplane control plane can enable a new
    world of unifying application and infrastructure automation. The following section
    will cover the unifying aspect in more detail.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Unifying the automation
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing external software resources with Crossplane is the crossroad for unifying
    infrastructure and application DevOps. We could package software and infrastructure
    dependencies into a single XRs. Such a complete package of applications and infrastructure
    introduces numerous advantages, some of which are listed here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The approach will unify the tooling and skills required for application and
    infrastructure automation.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More importantly, the entire stack will enjoy the advantages of the Kubernetes
    operating model.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating vendor software into an enterprise ecosystem will become quicker
    and more standardized. Software vendors can quickly build packages that fit into
    different ecosystems. Currently, software vendors must custom-build for the individual
    cloud provider marketplace. This approach can assist in building a universal vendor
    software marketplace.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily apply the audit process to comply with any compliance standards.
    Previously, this would have been complicated as software and its infrastructure
    dependencies are spread about.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure represents a unified XR API:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Unified XR'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_05_15.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – Unified XR
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Important
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In a later chapter, we can go through a hands-on journey to experience building
    an XR API covering both applications and infrastructure dependencies.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope it’s been fun to read this chapter and go through the hands-on journey.
    It covered different patterns that are useful in our day-to-day work when adopting
    Crossplane. We covered different ways to evolve our XR APIs, detailed XR configurations,
    how to manage application resources, and nested and multi-resource XRs. There
    are more patterns to be covered.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will discuss more advanced Crossplane methods and their respective
    hands-on journeys.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
