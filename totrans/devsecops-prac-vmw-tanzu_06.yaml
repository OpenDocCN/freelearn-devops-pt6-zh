- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Managing Container Images with Harbor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Harbor 管理容器镜像
- en: In the previous chapters, we covered the tools in the Tanzu portfolio that help
    us build cloud-native applications. We started our first segment with an overview
    of the evolution of building, running, and managing modern cloud-native applications
    and their platforms. Then, we saw how we can start application development using
    templates, how to build secure container images, how to quickly provision backing
    services for the applications, and how to manage APIs using various Tanzu products.
    After learning about building cloud-native applications, in this chapter, we will
    take a deep dive into various aspects of running them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们介绍了 Tanzu 产品组合中的工具，帮助我们构建云原生应用程序。我们从回顾构建、运行和管理现代云原生应用程序及其平台的发展历程开始。接着，我们看到如何使用模板开始应用开发，如何构建安全的容器镜像，如何为应用程序快速配置后端服务，以及如何使用各种
    Tanzu 产品管理 API。在了解了如何构建云原生应用程序后，本章将深入探讨运行它们的各个方面。
- en: As the title of this chapter indicates, we will learn how to manage our container
    images and securely make them accessible using Harbor to deploy our applications
    on Kubernetes. Harbor is an open source container registry project under the **Cloud
    Native Computing Foundation** (**CNCF**) umbrella. Despite Harbor being a fully
    open source tool, we have included it in this book for three main reasons. Firstly,
    Harbor was incubated by VMware and donated to CNCF in mid-2018\. VMware is also
    one of the major contributors to the project and has actively invested in Harbor
    since then. Secondly, Harbor has also been recognized as a graduate project under
    the CNCF umbrella, which is a state that is tagged as a very popular, mature,
    and stable project within the CNCF ecosystem. Finally, the main reason to include
    Harbor in this book is that VMware, being a significant stakeholder in this project,
    also provides commercial enterprise support for Harbor as a part of its Tanzu
    portfolio.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章标题所示，我们将学习如何管理我们的容器镜像，并通过 Harbor 安全地使其可访问，以便在 Kubernetes 上部署我们的应用程序。Harbor
    是一个开源容器注册表项目，隶属于**云原生计算基金会**（**CNCF**）。尽管 Harbor 完全是开源工具，我们仍将其纳入本书，主要有三个原因。首先，Harbor
    是由 VMware 孵化的，并于 2018 年中期捐赠给 CNCF。自那时起，VMware 也是该项目的主要贡献者之一，并积极投资于 Harbor。其次，Harbor
    也被 CNCF 认定为一个毕业项目，这是 CNCF 生态系统中被标记为非常流行、成熟且稳定的项目状态。最后，将 Harbor 纳入本书的主要原因是，作为该项目的重要利益相关者，VMware
    也为 Harbor 提供商业企业支持，并将其作为 Tanzu 产品组合的一部分。
- en: Sidenote
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 附注
- en: Henceforth, in this chapter, we will refer to a *container image* as an *image*
    only for brevity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从此章开始，为了简洁起见，我们将把*容器镜像*简称为*镜像*。
- en: 'In this chapter, we will cover Harbor in detail by covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍 Harbor，涵盖以下主题：
- en: '**Why Harbor?**: A walkthrough of the features and capabilities of Harbor'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为什么选择 Harbor？**：Harbor 的功能和特性概述'
- en: '**Unboxing Harbor**: A detailed overview of the anatomy of Harbor'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索 Harbor**：对 Harbor 架构的详细概述'
- en: '**Getting started with Harbor**: Learn how to install and configure Harbor'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始使用 Harbor**：学习如何安装和配置 Harbor'
- en: '**Common day-2 operations with Harbor**: Learn how to perform various configuration
    and usage-related activities on Harbor'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Harbor 常见的二次操作**：学习如何执行与 Harbor 配置和使用相关的各种活动'
- en: Let’s start by learning about the background of Harbor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解 Harbor 的背景开始。
- en: Why Harbor?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Harbor？
- en: In this section, we will review the various features, capabilities, and reasons
    to consider using Harbor as a container registry. These reasons will be explained
    using the security, control, and extensibility features of Harbor as described
    henceforth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾使用 Harbor 作为容器注册表的各种特性、功能以及使用 Harbor 的理由。这些理由将通过以下内容进行解释：Harbor 的安全性、控制能力和可扩展性特性。
- en: Using Harbor for security
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Harbor 保障安全
- en: 'There are some strong security reasons and features that make Harbor a good
    choice for a container registry, which shifts security to a proactive measure
    rather than reactive in the applications’ journey toward production. Let’s review
    these security benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Harbor 具备一些强大的安全性特点，使其成为容器注册表的优秀选择，它将安全性从应用程序生产过程中的反应性措施转变为主动性措施。让我们来回顾一下这些安全性优势：
- en: Harbor comes with the capability to scan each image for the presence of **critical
    vulnerability exposures** (**CVEs**) as a result of certain software libraries
    and operating system versions used in the image. Such scanning provides a detailed
    report of the CVEs found in the corresponding image, along with their severity
    level, details of the exposure, and the version of the software in which that
    CVE is remediated. We can get such scanning results using either the web portal
    or using the REST APIs provided by Harbor. Harbor also allows you to use an external
    image scanning tool in place of or in addition to the default one. Such visibility
    of the possible security loopholes in the images could provide a preventative
    security posture well in advance in the application deployment process.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harbor 具备扫描每个镜像是否存在**关键漏洞暴露**（**CVEs**）的功能，这些漏洞可能源自镜像中使用的某些软件库和操作系统版本。此类扫描提供了详细的
    CVE 报告，包括发现的 CVE 及其严重性等级、漏洞的详细信息以及该 CVE 已被修复的软版本。我们可以通过 web 门户或使用 Harbor 提供的 REST
    API 获取这些扫描结果。Harbor 还允许您使用外部镜像扫描工具，替代或附加默认工具。通过这种方式，您可以在应用部署过程中提前了解镜像中可能存在的安全漏洞，从而提供预防性的安全防护。
- en: Depending on the application environment and the preferred tolerance level,
    Harbor also provides a way to prevent its clients from pulling such images that
    are scanned for CVEs and contain CVEs higher than the allowed severity level.
    For example, we can configure a policy in Harbor that any image that has CVEs
    found with categories more than medium severity in a project named `Production
    Repo` may not be pulled to deploy containers. This capability provides required
    guardrails to prevent damage at the front gate itself. It ensures that the flagged
    images are never allowed to be pulled to run workloads and allow bad actors to
    exploit them later.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据应用环境和偏好的容忍度，Harbor 还提供了一种方法，防止客户端拉取那些已扫描 CVE 且包含高于允许严重性等级的 CVE 的镜像。例如，我们可以在
    Harbor 中配置一个策略，要求任何在名为 `Production Repo` 的项目中发现的 CVE 严重性高于中等的镜像，无法被拉取来部署容器。此功能提供了所需的保护措施，防止在前门就发生损害，确保被标记的镜像永远无法被拉取来运行工作负载，避免不法分子稍后利用它们。
- en: Harbor also supports integrations with Notary ([https://github.com/notaryproject/notary](https://github.com/notaryproject/notary)),
    which is an open source project that can digitally sign the images for authenticity.
    You can create a container deployment pipeline using such an image signing utility
    to allow only signed and hence authorized images to be deployed in your production
    environment. Such an arrangement can greatly enhance your security posture as
    no unverified, unscanned, or potentially dangerous images can be deployed in your
    environment.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harbor 还支持与 Notary（[https://github.com/notaryproject/notary](https://github.com/notaryproject/notary)）的集成，Notary
    是一个开源项目，可以为镜像进行数字签名以保证其真实性。您可以使用这种镜像签名工具创建一个容器部署管道，从而仅允许签名且经过授权的镜像在生产环境中进行部署。这样的安排可以大大增强您的安全防护，因为在您的环境中无法部署任何未验证、未扫描或潜在危险的镜像。
- en: Harbor has robust **role-based access control** (**RBAC**) capabilities. It
    allows you to configure users with two levels, mainly at the project level and
    at the system level, to provide the required control and flexibility for a multi-tenant
    environment.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harbor 拥有强大的**基于角色的访问控制**（**RBAC**）功能。它允许您在项目级别和系统级别配置用户，提供在多租户环境中所需的控制和灵活性。
- en: Moreover, Harbor also allows you to separate user accounts from system accounts
    (known as **r****obot accounts** in Harbor) that can be used for **continuous
    integration** (**CI**) and **continuous deployment** (**CD**) automation processes.
    We may specify required permissions to such robot accounts to perform only allowed
    operations using the automation processes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Harbor 还允许您将用户帐户与系统帐户（在 Harbor 中称为**机器人帐户**）分开，后者可以用于**持续集成**（**CI**）和**持续部署**（**CD**）自动化流程。我们可以为这些机器人帐户指定所需的权限，使其仅能通过自动化流程执行允许的操作。
- en: We may create a hub-and-spoke architecture while using Harbor as the hub that
    replicates images to and from either external or other internal Harbor container
    registries. An example of such a deployment is shown in *Figure 6**.1*. Such an
    arrangement may allow organizations to prevent their internal users from pulling
    arbitrary and insecure images from unauthorized sources. But at the same time,
    it allows them to pull those images from only the internally deployed Harbor,
    which would have replicated authorized images from an external image repository.
    This feature provides the required control to ensure security without affecting
    developers’ freedom and productivity.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个中心-辐射架构，在这种架构中，Harbor 作为中心节点，负责将镜像从外部或其他内部 Harbor 容器注册表之间进行复制。这样的部署示例如
    *图 6.1* 所示。通过这种安排，组织可以防止内部用户从未经授权的来源拉取任意和不安全的镜像。与此同时，它允许他们只从内部部署的 Harbor 拉取镜像，而这些镜像已经从外部镜像库复制了授权的镜像。这个功能提供了所需的控制机制，以确保安全，同时不影响开发人员的自由和生产力。
- en: As we will see later in this chapter, Harbor has several components and supports
    many external integrations for various capabilities. To ensure the safety of such
    data transfers, all these inter-component communication channels use **Transport
    Layer Security** (**TLS**) encryption.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在本章稍后将看到的，Harbor 拥有多个组件，并支持许多外部集成，以实现各种功能。为了确保这些数据传输的安全性，所有这些组件间的通信通道都使用
    **传输层安全性**（**TLS**）加密。
- en: After reviewing the key features of Harbor around security, let’s check what
    its benefits are from an operational control point of view.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了 Harbor 在安全方面的关键特性之后，我们来看看从运营控制的角度来看，它的优势是什么。
- en: Using Harbor for operational control
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Harbor 进行运营控制
- en: There are several popular container registries available in the market as online
    **Software-as-a-Service** (**SaaS**) offerings, including Docker Hub, **Google
    Container Registry** (**GCR**), and offerings from many other cloud providers.
    The point where Harbor differs from these online options is the fact that it can
    be deployed in an air-gapped environment. When there is a need to keep the application
    images private and on-premise, we need an offering like Harbor. With such on-premises
    deployments, as discussed in the previous section about security-specific reasons,
    Harbor provides a control mechanism to expose only authorized images that are
    replicated in Harbor from external sources for internal consumption. This way,
    the operators can prevent internal image users from downloading potentially vulnerable
    images from unauthorized sources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有多个流行的容器注册表，作为在线 **软件即服务**（**SaaS**）提供，包括 Docker Hub、**Google 容器注册表**（**GCR**）以及许多其他云服务提供商的产品。Harbor
    与这些在线选项的不同之处在于，它可以部署在隔离的环境中。当需要保持应用镜像私密且本地存储时，我们需要像 Harbor 这样的解决方案。通过此类本地部署，如前一节关于安全性的讨论，Harbor
    提供了一个控制机制，确保仅暴露从外部源复制到 Harbor 中的授权镜像供内部使用。这样，运营人员可以防止内部镜像用户从未经授权的源下载可能存在漏洞的镜像。
- en: Additionally, Harbor is also an open source community-driven project that is
    at the **Graduated** maturity level in CNCF, like Kubernetes. CNCF only graduates
    an open source project when there is a significant community contribution and
    adoption. Since VMware is one of the major contributors to the project, it also
    provides commercial support for Harbor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Harbor 还是一个由社区驱动的开源项目，处于 CNCF 的 **毕业级**成熟度阶段，类似于 Kubernetes。CNCF 只有在开源项目有显著的社区贡献和采用时才会将其毕业。由于
    VMware 是该项目的主要贡献者之一，它也为 Harbor 提供商业支持。
- en: Along with the point of being a CNCF-mature and commercially supported open
    source project, Harbor has an array of multi-tenancy features. We will visit some
    of these features later in this chapter. But at a high level, Harbor admins can
    configure team-wise storage quotas for images and choose from different image
    vulnerability scanners, image retention periods, team-wise webhook configurations
    to trigger a CD pipeline, CVE whitelisting, and a few others. Having these configurations
    separate for different teams using the same deployment of Harbor provides the
    required operational control to Harbor admins, along with the required flexibility
    to the user groups.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为一个成熟的 CNCF 项目并且得到商业支持的开源项目外，Harbor 还具有一系列的多租户功能。我们将在本章稍后讨论其中的一些功能。但从高层来看，Harbor
    管理员可以为不同团队配置存储配额，选择不同的镜像漏洞扫描器、镜像保留期限、为触发 CD 流水线配置团队级别的 Webhook、CVE 白名单等其他选项。为使用同一
    Harbor 部署的不同团队设置这些独立的配置，为 Harbor 管理员提供所需的操作控制，并为用户组提供所需的灵活性。
- en: 'Lastly, under the operational control area, Harbor provides various general
    administrative configurations that are common for the deployment and all user
    groups. Such configurations include the following administrative controls:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在操作控制领域，Harbor 提供了各种通用的管理配置，适用于部署和所有用户组。这些配置包括以下管理控制：
- en: Cleaning up all untagged artifacts using a garbage collection routine that can
    be triggered on-demand or scheduled
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用垃圾回收程序清理所有未标记的工件，该程序可以按需触发或定期调度。
- en: Managing user groups and their permissions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户组及其权限。
- en: Configuring external or internal authentication providers, including **Light-weight
    Directory Access Protocol** (**LDAP**) and **Open ID Connect** (**OIDC**) systems
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置外部或内部认证提供者，包括**轻量级目录访问协议**（**LDAP**）和**开放ID连接**（**OIDC**）系统。
- en: Configuring custom **Open Container Initiative** (**OCI**) artifacts to store
    binary objects other than images in Harbor
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义**开放容器倡议**（**OCI**）工件，将除镜像外的二进制对象存储在 Harbor 中。
- en: Configuring image proxy caching to allow externally hosted images to be stored
    in an offline mode
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置镜像代理缓存，以允许外部托管的镜像以离线模式存储。
- en: Accessing key performance metrics to check on Harbor’s health
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问关键性能指标，检查 Harbor 的健康状况。
- en: Enabling the distributed tracing telemetry data for enhanced troubleshooting
    capabilities for Harbor
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用分布式追踪遥测数据，以增强 Harbor 的故障排除能力。
- en: Tip
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Open Container Initiative** (**OCI**) is an open governance structure for
    creating open industry standards around container formats and runtimes. Source:
    [https://opencontainers.org/](https://opencontainers.org/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放容器倡议**（**OCI**）是一个开放的治理结构，旨在围绕容器格式和运行时创建开放的行业标准。来源：[https://opencontainers.org/](https://opencontainers.org/)。'
- en: After seeing how Harbor can help to obtain control over various types of configurations,
    let’s see one more category of reasons to use Harbor – its extensibility.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 Harbor 如何帮助获得对各种配置类型的控制之后，让我们来看一下使用 Harbor 的另一个原因——它的可扩展性。
- en: Using Harbor for its extensibility
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Harbor 以利用其可扩展性。
- en: Harbor is a solution that is comprised of a few different microservices that
    work together to serve the purpose of being a purpose-built container registry.
    It has several components that can be replaced with other available options providing
    similar functionalities. Moreover, we can extend some functionalities to provide
    more choices for the end users to pick from. Such areas of extensibility include
    integration with an external container registry, CVE scanners, authentication
    providers, and OCI-compliant objects that can be hosted on Harbor. The following
    sections describe them in detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Harbor 是一个由几个不同的微服务组成的解决方案，这些微服务协同工作，旨在作为一个专用的容器注册表。它有多个组件，可以用其他提供类似功能的选项替换。此外，我们可以扩展一些功能，为最终用户提供更多选择。可扩展性领域包括与外部容器注册表、CVE
    扫描器、认证提供者和可以托管在 Harbor 上的 OCI 合规对象的集成。以下部分将详细描述这些内容。
- en: Extending image sources and destinations through replication
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过复制扩展镜像源和目标。
- en: 'Harbor allows you to create image replication rules to extend the image library
    using an external image repository. That way, the clients of Harbor can the pull
    required images from an external repository such as Docker Hub without accessing
    Docker Hub. Such extensions are helpful for an air-gapped deployment where open
    internet access and open image downloading from a public repository are not desirable
    from a security point of view. Additionally, Harbor allows you to create replication
    rules for push and pull operations for a bidirectional flow of artifacts. *Figure
    6**.1* shows how *the central Harbor repository* pulls (replicates) images from
    *Docker Hub* and *GCR* and then pushes those images to the *remote Harbor repositories*
    for a better network co-location for the nearby Kubernetes clusters. The arrows
    in the figure indicate the flow of images:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Harbor 允许你创建镜像复制规则，通过外部镜像仓库扩展镜像库。这样，Harbor 客户端可以从外部仓库（如 Docker Hub）拉取所需的镜像，而无需直接访问
    Docker Hub。此类扩展对于空中隔离部署（即不希望从安全角度访问公开互联网和公开仓库下载镜像）非常有帮助。此外，Harbor 允许你为推送和拉取操作创建复制规则，实现双向的工件流动。*图6.1*
    展示了 *中央 Harbor 仓库* 如何从 *Docker Hub* 和 *GCR* 拉取（复制）镜像，然后将这些镜像推送到 *远程 Harbor 仓库*，以便更好地网络共址在附近的
    Kubernetes 集群中。图中的箭头指示了镜像的流动方向：
- en: '![Figure 6.1 – Harbor deployment topology to take advantage of the replication
    feature](img/B18145_06_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – Harbor部署拓扑图，以利用复制功能](img/B18145_06_01.jpg)'
- en: Figure 6.1 – Harbor deployment topology to take advantage of the replication
    feature
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – Harbor 部署拓扑图，以利用复制功能
- en: Such extensions of image repository locations for different sources and destinations
    can be very useful to provide controlled access to the replicated images from
    security and governance. Additionally, it can also help reduce network latency
    and bandwidth requirements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 针对不同来源和目标的镜像仓库位置扩展，对于从安全性和治理角度控制对复制镜像的访问非常有用。此外，它还可以帮助减少网络延迟和带宽需求。
- en: In addition to using Harbor for replication, we can also configure Harbor as
    a proxy to cache externally located images. This caching arrangement can help
    save network latency in transferring frequently used images and save the network
    bandwidth required for internet traffic. Additionally, using Harbor for caching
    may cache only used images for a given timeframe. And if the image is not actively
    pulled, then it is removed. However, such a proxy configuration allows more freedom
    to access any available images versus only replicated ones. Both replication and
    caching have their use cases, pros, and cons.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 Harbor 进行复制外，我们还可以将 Harbor 配置为代理来缓存外部位置的镜像。此缓存安排有助于减少传输频繁使用镜像时的网络延迟，并节省所需的互联网流量带宽。此外，使用
    Harbor 进行缓存时，可能只会缓存在给定时间段内被使用的镜像。如果镜像没有被主动拉取，它会被移除。然而，这种代理配置相比仅复制的镜像，更加自由地访问任何可用的镜像。复制和缓存各自有其使用场景、优点和缺点。
- en: Adding or replacing vulnerability scanners
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加或更换漏洞扫描器
- en: By default, Harbor comes with Trivy ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))
    for CVE scanning of images. However, you can incorporate your own instance of
    a Trivy implementation if you have one. You may also integrate a different CVE
    scanner with Harbor in place of or in addition to Trivy. This extension allows
    different teams to use their preferred scanner from the list of supported ones
    by Harbor. In the present scenario, Harbor supports Clair, Anchore, Aqua, DoSec,
    Sysdig Secure, and Tensor Security in addition to Trivy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Harbor 配备了 Trivy（[https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy)）用于对镜像进行
    CVE 扫描。然而，如果你有自己的 Trivy 实例，也可以将其集成到 Harbor 中。你还可以在 Harbor 中集成其他 CVE 扫描器，替代或与 Trivy
    一起使用。此扩展功能允许不同的团队使用 Harbor 支持的扫描器列表中他们偏好的扫描器。在当前场景下，Harbor 除了 Trivy 外，还支持 Clair、Anchore、Aqua、DoSec、Sysdig
    Secure 和 Tensor Security。
- en: Extending authentication providers
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展身份验证提供程序
- en: Harbor provides database-level authentication where user accounts can be directly
    configured in Harbor as the default and primitive approach. However, the administrator
    may configure Harbor to use either an LDAP/Active Directory service or an OIDC
    provider. In that case, such external authentication providers will be used to
    create and manage user accounts. Harbor will redirect authentication requests
    to these external authentication providers and based on the identity provided
    by the authentication provider, Harbor grants the required access to the user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Harbor 提供数据库级别的身份验证，用户帐户可以直接在 Harbor 中配置，作为默认和原始方法。然而，管理员可以配置 Harbor 使用 LDAP/Active
    Directory 服务或 OIDC 提供者。在这种情况下，这些外部身份验证提供者将用于创建和管理用户帐户。Harbor 将把身份验证请求重定向到这些外部身份验证提供者，并根据身份验证提供者提供的身份信息，Harbor
    授予用户所需的访问权限。
- en: Extending user-defined OCI artifacts hosting
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展用户定义的 OCI 制品托管
- en: Along with images, Harbor can also store Helm charts and other user-defined
    OCI artifacts. Such artifacts can be **Kubeflow** data models, which are used
    for machine learning on Kubernetes. For such extensions, the objects must follow
    Harbor-specific configuration using a manifest file. The use cases of such user-defined
    extensions are rare but possible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了镜像外，Harbor 还可以存储 Helm 图表和其他用户定义的 OCI 制品。这些制品可以是**Kubeflow** 数据模型，用于 Kubernetes
    上的机器学习。对于这种扩展，对象必须遵循 Harbor 特定的配置，并使用清单文件。这些用户定义扩展的使用场景较少，但也是可能的。
- en: So far in this chapter, we have seen different security, operational, and extensibility
    reasons explaining the *Why* behind using Harbor as a container repository. It
    is open source but supported by VMware and a lightweight, flexible, and purpose-built
    container registry that also helps enhance the overall container security posture
    via image scanning, replication, and signing features. In the next section of
    this chapter, we will discuss the *What* part of Harbor to see what is under the
    hood.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了一些不同的安全、运营和可扩展性的原因，解释了使用 Harbor 作为容器注册表的*原因*。它是开源的，但由 VMware
    支持，是一个轻量级、灵活、专为容器注册设计的注册表，还通过镜像扫描、复制和签名功能帮助增强整体容器安全性。在本章的下一节中，我们将讨论 Harbor 的*功能*部分，了解它的内部工作原理。
- en: Unboxing Harbor
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开箱 Harbor
- en: After seeing some good reasons to consider using Harbor as a container artifact
    repository around business, security, operational control, and extensibility,
    let’s learn what Harbor is made up of. In this section, we will learn about the
    internal components and functions of Harbor. Being a container registry to serve
    the cloud-native community, Harbor itself is a cloud-native application comprised
    of multiple smaller microservices performing different activities. Let’s understand
    how they work together by providing an architectural overview of Harbor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到一些关于使用 Harbor 作为容器制品库的商业、安全、运营控制和可扩展性等方面的好理由后，让我们了解一下 Harbor 的组成部分。在本节中，我们将学习
    Harbor 的内部组件和功能。作为一个服务于云原生社区的容器注册表，Harbor 本身是一个由多个较小的微服务组成的云原生应用，这些微服务执行不同的任务。让我们通过提供
    Harbor 的架构概述来理解它们如何协同工作。
- en: Architecture overview
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构概述
- en: 'Harbor has several internal and external components. As shown in *Figure 6**.2*,
    we can distribute these components into the following categories:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Harbor 有多个内部和外部组件。如 *图 6.2* 所示，我们可以将这些组件分为以下几类：
- en: '**Consumers**: Consist of all clients and client interfaces'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：由所有客户端和客户端接口组成'
- en: '**Fundamental Services**: Consist of all core functionalities that are part
    of the Harbor project and other key third-party projects that are essential components
    of the overall package'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础服务**：由 Harbor 项目中的所有核心功能和其他对整体包至关重要的第三方关键项目组成'
- en: '**Data Access Layer**: Consists of all the different data stores'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**：由所有不同的数据存储组成'
- en: '**Identity Providers**: Consist of all external authentication provider extensions'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份提供者**：由所有外部身份验证提供者扩展组成'
- en: '**Scan Providers**: Consist of all external image CVE scanner extensions'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扫描提供者**：由所有外部镜像 CVE 扫描扩展组成'
- en: '**Replicated Registry Providers**: Consist of all external image replication
    extensions:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制的注册表提供者**：由所有外部镜像复制扩展组成：'
- en: '![Figure 6.2 – Harbor 2.0 architecture (https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor)](img/B18145_06_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Harbor 2.0 架构（https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor)](img/B18145_06_02.jpg)'
- en: Figure 6.2 – Harbor 2.0 architecture ([https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor](https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – Harbor 2.0 架构 ([https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor](https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor))
- en: Let’s review some of the key components covered in *Figure 6**.2*. You will
    see these components deployed in your Kubernetes environment when we install and
    configure Harbor later in this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下*图6.2*中涵盖的一些关键组件。你将在稍后安装和配置 Harbor 时，看到这些组件在你的 Kubernetes 环境中被部署。
- en: Harbor Chart Museum
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Harbor 图表博物馆
- en: As we discussed previously, along with images, Harbor also supports storing
    Helm charts. To support this feature, Harbor internally uses `my-harbor-chartmuseum`
    with a Kubernetes service running with the same name once you have a running instance
    of Harbor in your Kubernetes cluster.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除了镜像，Harbor 还支持存储 Helm 图表。为了支持这一功能，Harbor 内部使用 `my-harbor-chartmuseum`，并且当你在
    Kubernetes 集群中运行一个 Harbor 实例时，会有一个名称相同的 Kubernetes 服务在后台运行。
- en: Harbor Core
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Harbor 核心
- en: As described in *Figure 6**.2*, Harbor Core is a collection of several modules
    that include key capabilities of Harbor being a container registry. These capabilities
    include concerns such as API management, authentication and authorization, interfacing
    glues, including pluggable image replication providers, image scanners, and image
    signature providers, and other foundational functionalities such as multitenancy
    capabilities, configuration management, artifact manager, and others. In our Kubernetes-based
    Harbor deployment, all the modules displayed in *Figure 6**.2* under `my-harbor-core`,
    and this is exposed as a Kubernetes service resource with the same name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6.2*所示，Harbor 核心是由多个模块组成的集合，这些模块包括 Harbor 作为容器注册中心的关键功能。这些功能包括诸如 API 管理、身份验证和授权、接口连接（包括可插拔的镜像复制提供者、镜像扫描器、镜像签名提供者）以及其他基础功能，如多租户能力、配置管理、工件管理器等。在我们的基于
    Kubernetes 的 Harbor 部署中，所有在*图6.2*中显示的模块都位于`my-harbor-core`下，并作为具有相同名称的 Kubernetes
    服务资源对外暴露。
- en: Harbor job service
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Harbor 作业服务
- en: This is Harbor’s asynchronous task execution engine that exposes the required
    REST APIs for other components to submit their job requests. One such example
    is a job to scan an image. You will see this microservice also getting deployed
    as its own Kubernetes deployment and a service named `my-harbor-jobservice`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Harbor 的异步任务执行引擎，暴露了所需的 REST API 供其他组件提交其作业请求。例如，一个作业是扫描一个镜像。你将看到这个微服务也会作为独立的
    Kubernetes 部署和名为`my-harbor-jobservice`的服务进行部署。
- en: Harbor Notary
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Harbor 公证服务
- en: Notary ([https://github.com/notaryproject/notary](https://github.com/notaryproject/notary))
    is a third-party open source project under the CNCF umbrella. It is used to provide
    content trust establishment capabilities, which are achieved through an image
    signing procedure. As reviewed under the security-related reasons to use Harbor,
    such an image signing capability could be a great way to ensure that only verified
    images are deployed in a Kubernetes environment. It allows the image publisher
    to digitally sign an image using a private key authenticating the signer. Then,
    the consumers of that image can verify the publisher/signer of the image and take
    an informed decision to either trust or distrust the image based on the digital
    signature and the associated metadata. In secured and fully automated Kubernetes
    platforms, such operations of image signing and their verification are the steps
    of a CI/CD pipeline. Notary provides this functionality using its two main components
    – the server and the signer. The Notary server is responsible to store content
    metadata, ensuring the validity of the uploaded content, attaching the timestamps,
    and serving this content to the clients when requested. On the other side, the
    Notary signer is responsible for storing the private signing keys in a separate
    database from the Notary server database and performing the signing operations
    using these keys as and when requested by the Notary server. You will see these
    two components deployed as Kubernetes deployment resources named `my-harbor-notary-server`
    and `my-harbor-notary-signer`, along with their corresponding service resources,
    in a Kubernetes-based Harbor deployment that we will cover later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Notary ([https://github.com/notaryproject/notary](https://github.com/notaryproject/notary))
    是一个在 CNCF 旗下的第三方开源项目。它用于提供内容可信度建立能力，这通过镜像签名过程来实现。如前文所述，出于安全相关的原因使用 Harbor，这种镜像签名能力是确保只有经过验证的镜像在
    Kubernetes 环境中部署的好方法。它允许镜像发布者使用私钥对镜像进行数字签名，从而验证签名者的身份。然后，镜像的消费者可以验证该镜像的发布者/签名者，并根据数字签名及相关元数据做出是否信任该镜像的决策。在安全且完全自动化的
    Kubernetes 平台中，镜像签名及其验证操作是 CI/CD 流水线的步骤之一。Notary 通过其两个主要组件——服务器和签名者，提供此功能。Notary
    服务器负责存储内容元数据，确保上传内容的有效性，附加时间戳，并在客户请求时提供这些内容。另一方面，Notary 签名者负责将私钥存储在与 Notary 服务器数据库分开的数据库中，并在
    Notary 服务器请求时使用这些密钥执行签名操作。你将在本章稍后看到这两个组件作为名为 `my-harbor-notary-server` 和 `my-harbor-notary-signer`
    的 Kubernetes 部署资源进行部署，以及其对应的服务资源。
- en: Harbor portal
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Harbor 门户
- en: As the name suggests, it is the `my-harbor-portal`, along with its corresponding
    service with the same name, later in this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，它就是 `my-harbor-portal`，以及其对应的同名服务，稍后将在本章中讲解。
- en: Harbor registry
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Harbor 注册表
- en: This is based on the open source project named Distribution ([https://github.com/distribution/distribution](https://github.com/distribution/distribution)),
    which wraps functionalities to pack, ship, store, and deliver content. It implements
    the standards defined by the OCI Distribution Specification. It is the core library
    used for image registry operations and used by many open source and commercial
    registries, including Docker Hub, GitLab Container Registry, and DigitalOcean
    Container Registry, including Harbor. You will see this component deployed as
    a Kubernetes deployment resource named `my-harbor-registry`, along with its exposed
    service with the same name, later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于一个名为 Distribution 的开源项目（[https://github.com/distribution/distribution](https://github.com/distribution/distribution)），该项目封装了打包、运输、存储和交付内容的功能。它实现了由
    OCI Distribution Specification 定义的标准，是进行镜像注册表操作的核心库，被许多开源和商业注册表所使用，包括 Docker Hub、GitLab
    容器注册表和 DigitalOcean 容器注册表，包括 Harbor。你将在本章稍后看到这个组件作为一个名为 `my-harbor-registry` 的
    Kubernetes 部署资源进行部署，以及其暴露的同名服务。
- en: PostgreSQL database
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL 数据库
- en: This is the main database of Harbor and is used to store all required configurations
    and metadata used in Harbor. It stores all Harbor constructs, including but not
    limited to the data related to projects, users, policies, scanners, charts, and
    images. It is deployed as a stateful set on a Kubernetes cluster called `my-harbor-postgresql`,
    along with its service resource exposed with the same name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Harbor 的主数据库，用于存储所有所需的配置和元数据。它存储了所有 Harbor 结构，包括但不限于与项目、用户、策略、扫描器、图表和镜像相关的数据。它作为一个
    StatefulSet 部署在 Kubernetes 集群上，名为 `my-harbor-postgresql`，同时暴露其同名的服务资源。
- en: Redis cache
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis 缓存
- en: This is also deployed as a stateful set on Kubernetes and it is called `my-harbor-redis-master`.
    It is used as a key-value store to cache the required metadata used by the job
    service.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它也作为一个有状态集部署在 Kubernetes 上，称为 `my-harbor-redis-master`。它作为键值存储，用于缓存作业服务所需的元数据。
- en: Trivy Scanner
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Trivy 扫描器
- en: This is an open source project by Aqua Security ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))
    and the default image CVE scanner that is deployed with Harbor 2.x. It can scan
    operating system layers and language-specific packages that are used in the image
    to find known vulnerability exposures present in those artifacts. Harbor uses
    such scanners to provide a comprehensive scanning capability. Such scanners can
    scan images and produce detailed reports, including CVE metadata. Such metadata
    includes a list of CVE numbers, vulnerability areas, severity levels, fixed versions
    if available, and other details. You will see this component getting deployed
    as `my-harbor-trivy` as a Kubernetes deployment post our installation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Aqua Security 提供的一个开源项目（[https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy)），也是
    Harbor 2.x 中默认部署的图像 CVE 扫描器。它可以扫描操作系统层和图像中使用的特定语言包，查找这些工件中存在的已知漏洞。Harbor 使用此类扫描器提供全面的扫描能力。这些扫描器可以扫描图像并生成详细的报告，包括
    CVE 元数据。此类元数据包括 CVE 编号、漏洞领域、严重性级别、修复版本（如果可用）以及其他详细信息。安装后，你会看到这个组件作为 Kubernetes
    部署 `my-harbor-trivy` 被部署。
- en: What is my-harbor?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 my-harbor？
- en: The prefix, `my-harbor`, that you have seen in the names of different components
    that will be deployed in your Kubernetes cluster is an arbitrary name given to
    the Helm chart instance of Harbor at the time of deployment. It can be replaced
    with any other name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你在不同组件名称中看到的前缀 `my-harbor` 是在部署时为 Harbor 的 Helm 图表实例指定的一个任意名称。它可以替换为任何其他名称。
- en: 'There are several other internal and external components described in *Figure
    6**.2* other than what we have covered here. The components we have covered are
    based on what is deployed on our Kubernetes cluster under Harbor’s namespace.
    To learn more details about Harbor’s architecture, visit this link: [https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor](https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在此介绍的内容，*图 6**.2* 中还描述了其他一些内部和外部组件。我们介绍的组件基于在 Kubernetes 集群中 Harbor 命名空间下部署的内容。要了解有关
    Harbor 架构的更多详细信息，请访问此链接：[https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor](https://github.com/goharbor/harbor/wiki/Architecture-Overview-of-Harbor)。
- en: Now that we’ve learned about the different modules of Harbor, let’s learn how
    to install and configure it on a Kubernetes cluster.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Harbor 的不同模块，接下来我们将学习如何在 Kubernetes 集群上安装和配置它。
- en: Getting started with Harbor
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Harbor
- en: In this section, we will learn how to install and configure a Harbor registry
    instance on an existing Kubernetes cluster. But before we do that, we need to
    ensure that the following prerequisites are met.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在现有的 Kubernetes 集群上安装和配置 Harbor 注册表实例。但在此之前，我们需要确保满足以下前提条件。
- en: Prerequisites
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'The following are the prerequisites for the Harbor installation instructions
    given in this section:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本节中给出的 Harbor 安装说明的前提条件：
- en: Kubernetes cluster with version 1.10+
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群版本 1.10+
- en: Open internet connectivity from the Kubernetes cluster
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群需要具备对外的互联网连接
- en: 'The operator machine should have the following tools:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作机应该具备以下工具：
- en: '`docker` CLI: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker` CLI: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
- en: '`helm` CLI version 2.8.0+: [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helm` CLI 版本 2.8.0+: [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)'
- en: '`kubectl` CLI version 1.10+: [https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` CLI 版本 1.10+: [https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)'
- en: There should be a default **StorageClass** configured in your Kubernetes cluster
    that Harbor can use to create required storage volumes. By default, Harbor will
    need several **PersistentVolumeClaim** resources that are used by Redis cache,
    a PostgreSQL database, the registry storage, and more.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Kubernetes 集群中应该配置有一个默认的 **StorageClass**，Harbor 可以使用它来创建所需的存储卷。默认情况下，Harbor
    需要多个 **PersistentVolumeClaim** 资源，这些资源被 Redis 缓存、PostgreSQL 数据库、注册表存储等使用。
- en: The infrastructure running the Kubernetes cluster should be able to expose an
    externally accessible IP address upon the creation of a `LoadBalancer` type Kubernetes
    service, making it accessible outside the Kubernetes cluster. We have used `LoadBalancer`
    type service deployed in the GKE cluster.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Kubernetes 集群的基础设施应该能够在创建 `LoadBalancer` 类型的 Kubernetes 服务时暴露一个外部可访问的 IP
    地址，使其能够从 Kubernetes 集群外部访问。我们在 GKE 集群中使用了 `LoadBalancer` 类型的服务。
- en: The operator machine should have a browser to access the Harbor GUI.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作机器应该具备浏览器来访问 Harbor 的图形用户界面（GUI）。
- en: Additional learning
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 额外学习
- en: To keep the deployment of Harbor on Kubernetes simpler, we could also deploy
    it as a `NodePort` service and access it externally using the Kubernetes node
    IP address and the port associated with the Harbor service. However, we cannot
    access this deployment of Harbor from a Docker client to push and pull images
    using the node port. This is because the Docker client can only connect to a registry
    using port `443` (HTTPS) or port `80` (HTTP).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Kubernetes 上的 Harbor 部署更简单，我们也可以将它部署为 `NodePort` 服务，并通过 Kubernetes 节点的 IP
    地址和与 Harbor 服务关联的端口进行外部访问。但是，我们无法通过 Docker 客户端访问此 Harbor 部署来推送和拉取镜像，因为 Docker
    客户端只能通过端口 `443`（HTTPS）或端口 `80`（HTTP）连接到仓库。
- en: Deploying a load balancer machine or a service instance for each `LoadBalancer`
    type service running on a Kubernetes cluster is not an efficient approach when
    several `LoadBalancer` type services are running on a Kubernetes cluster. Because,
    in this way, we may need several external load balancer instances for each externally
    facing service in the Kubernetes cluster. It is especially inefficient in a public
    cloud environment such as GKE, where such load balancer instances are charged
    separately. In a more sophisticated way, we can expose such externally facing
    services outside of a Kubernetes cluster using an **Ingress Controller** service
    running in the Kubernetes cluster. **Contour** ([https://projectcontour.io/](https://projectcontour.io/))
    is one such open source project under CNCF to be an Ingress Controller used for
    this reason that is supported by VMware and supplied with **Tanzu Kubernetes Grid**,
    which we will cover in the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中运行多个 `LoadBalancer` 类型服务时，为每个 `LoadBalancer` 类型的服务部署一个负载均衡器机器或服务实例并不是一种高效的方式。因为这样，我们可能需要为
    Kubernetes 集群中每个面向外部的服务部署多个外部负载均衡器实例。在 GKE 等公共云环境中，这种方式尤其低效，因为此类负载均衡器实例需要单独收费。更为高级的方式是，我们可以使用在
    Kubernetes 集群中运行的 **Ingress Controller** 服务，将这些面向外部的服务暴露到 Kubernetes 集群之外。**Contour**
    ([https://projectcontour.io/](https://projectcontour.io/)) 就是一个这样的开源项目，旨在作为 Ingress
    Controller，支持 VMware，并随 **Tanzu Kubernetes Grid** 提供，我们将在下一章中详细介绍。
- en: To keep things simple for learning, we have used GKE to expose Harbor externally
    for this chapter. However, AWS Elastic Kubernetes Service and Azure Kubernetes
    Service can also provision the load balancers, similar to GKE. If your Kubernetes
    cluster is running on an infrastructure that cannot automatically expose a `LoadBalancer`
    service using an external endpoint, you can also do that manually. For that, you
    need to create a reverse-proxy server such as Nginx and deploy Harbor as a NodePort
    service rather than a `LoadBalancer` service using the `--set service.type=NodePort`
    option for the `helm install` command for Harbor deployment, which will be covered
    later in the installation steps.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化学习，我们在本章中使用了 GKE 来将 Harbor 公开到外部。然而，AWS 弹性 Kubernetes 服务（EKS）和 Azure Kubernetes
    服务（AKS）也可以像 GKE 一样提供负载均衡器。如果你的 Kubernetes 集群运行在一个无法自动使用外部端点暴露 `LoadBalancer` 服务的基础设施上，你也可以手动进行此操作。为此，你需要创建一个反向代理服务器，例如
    Nginx，并将 Harbor 部署为 NodePort 服务，而不是使用 `LoadBalancer` 服务，方法是在部署 Harbor 时，使用 `--set
    service.type=NodePort` 选项来执行 `helm install` 命令，后续的安装步骤中将会详细讲解。
- en: Now, let’s start installing Harbor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始安装 Harbor。
- en: Installing Harbor
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Harbor
- en: 'While there are various ways to install and configure the Harbor repository,
    we will use a simple and easy-to-follow Bitnami-provided Helm chart approach to
    get a Harbor instance up and running in a Kubernetes cluster. It is required that
    all the steps in this section are performed using the same workstation. Let’s
    get started:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多种方法可以安装和配置 Harbor 仓库，但我们将使用 Bitnami 提供的 Helm chart 方法，这是一种简单且易于跟随的方式，在 Kubernetes
    集群中启动和运行 Harbor 实例。本节中的所有步骤必须在同一台工作站上执行。让我们开始吧：
- en: 'Add Bitnami’s Helm repository to your workstation:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Bitnami 的 Helm 仓库添加到你的工作站：
- en: '[PRE0]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a namespace on the cluster to deploy all Harbor components within it:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集群中创建一个命名空间，用于部署所有 Harbor 组件：
- en: '[PRE2]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install the Helm chart to get Harbor components deployed in the `harbor` namespace.
    It should deploy all Harbor components to expose a `LoadBalancer` type Kubernetes
    service to expose the portal:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Helm chart 以在 `harbor` 命名空间中部署 Harbor 组件。它应该会部署所有 Harbor 组件，并暴露一个 `LoadBalancer`
    类型的 Kubernetes 服务来暴露门户：
- en: '[PRE3]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Within just a few seconds, you will see the following output if the command
    was successfully executed. Here, `my-harbor` is just a name given to this Helm
    deployment that can be used to upgrade or delete the installation with that name
    reference:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功执行，你将在几秒钟内看到以下输出。这里，`my-harbor` 是给此 Helm 部署指定的一个名称，可以使用该名称引用来升级或删除该安装：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code snippet shows the output of the successful execution of the
    `helm` `install` command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段显示了成功执行 `helm` `install` 命令后的输出。
- en: 'Check the status of all the pods deployed in the `harbor` namespace to ensure
    everything is running fine:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `harbor` 命名空间中所有 Pod 的状态，确保一切正常运行：
- en: '[PRE5]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see all the pods running and all the containers in a ready state,
    as shown in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到所有 Pod 正在运行，且所有容器处于就绪状态，如以下代码片段所示：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Retrieve the admin user password generated by the installation. Note down this
    password as we will use it later to access the Harbor GUI:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索安装过程中生成的管理员用户密码。记下此密码，稍后我们将用它访问 Harbor GUI：
- en: '[PRE7]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Retrieve the external IP address on which Harbor service is exposed by running
    the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以检索 Harbor 服务暴露的外部 IP 地址：
- en: '[PRE8]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Access the Harbor portal from a browser using `https://<external-ip>/`. You
    may need to ignore the browser security prompts as we are not using a certificate
    signed by a valid certificate authority for the portal. You should see the following
    screen:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器访问 Harbor 门户，地址为 `https://<external-ip>/`。由于我们未使用有效证书颁发机构签名的证书，因此可能需要忽略浏览器的安全提示。你应该能看到以下屏幕：
- en: '![Figure 6.3 – Harbor login page](img/B18145_06_03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – Harbor 登录页面](img/B18145_06_03.jpg)'
- en: Figure 6.3 – Harbor login page
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – Harbor 登录页面
- en: 'Enter the username as `admin` and the password that you retrieved in *step
    5* previously. You should be able to log in successfully and see the following
    home page of the Harbor GUI:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入用户名 `admin` 和你在 *第 5 步* 中检索到的密码。你应该能够成功登录并看到 Harbor GUI 的首页：
- en: '![Figure 6.4 – Harbor landing page](img/B18145_06_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – Harbor 登陆页面](img/B18145_06_04.jpg)'
- en: Figure 6.4 – Harbor landing page
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – Harbor 登陆页面
- en: If you can log in using the aforementioned credentials and see the previous
    screen, you are done with the required setup to have a Harbor instance on your
    Kubernetes cluster running. As the next step, we will perform a small smoke test
    by pushing an image to this registry to validate our setup.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能使用上述凭据登录并看到之前的屏幕，那么你已经完成了在 Kubernetes 集群中运行 Harbor 实例所需的设置。接下来的步骤是通过将一个镜像推送到此注册表来进行一个小的烟雾测试，以验证我们的设置。
- en: Validating the setup
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证设置
- en: 'Perform the following steps to validate the installation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以验证安装：
- en: 'Retrieve the CA certificate used by Harbor by following these steps. We need
    to add this certificate in the trust store used by the Docker client to connect
    to the Harbor deployment:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤检索 Harbor 使用的 CA 证书。我们需要将此证书添加到 Docker 客户端使用的信任存储中，以便连接到 Harbor 部署：
- en: 'Go into the **library** project by clicking on the highlighted link:'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击高亮链接进入 **library** 项目：
- en: '![Figure 6.5 – Clicking the library project](img/B18145_06_05.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 点击库项目](img/B18145_06_05.jpg)'
- en: Figure 6.5 – Clicking the library project
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 点击库项目
- en: 'Download the certificate into your workstation using the **REGISTRY CERTIFICATE**
    link shown in the following screenshot:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下屏幕截图中的 **REGISTRY CERTIFICATE** 链接下载证书到工作站：
- en: '![Figure 6.6 – Downloading the registry certificate](img/B18145_06_06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 下载注册表证书](img/B18145_06_06.jpg)'
- en: Figure 6.6 – Downloading the registry certificate
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 下载注册表证书
- en: 'Import the Harbor portal certificate in the trust store used by the Docker
    client running in your workstation as explained here, depending on your operating
    system: [https://docs.docker.com/registry/insecure/#use-self-signed-certificates](https://docs.docker.com/registry/insecure/#use-self-signed-certificates).'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据操作系统的不同，按照此处的说明，将 Harbor 门户证书导入到 Docker 客户端使用的信任存储：[https://docs.docker.com/registry/insecure/#use-self-signed-certificates](https://docs.docker.com/registry/insecure/#use-self-signed-certificates)。
- en: 'For macOS, run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS，运行以下命令：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, replace `<downloaded-harbor-certificate>` with the certificate path that
    was downloaded in *step 1*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将 `<downloaded-harbor-certificate>` 替换为 *第 1 步* 中下载的证书路径。
- en: Restart the Docker daemon in your workstation if it is running; otherwise, start
    it to make the certificate visible to the Docker client.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Docker 守护进程正在运行，请重启它；否则，启动它，使证书对 Docker 客户端可见。
- en: Create a local DNS entry in the `/etc/hosts` file to link the default domain
    name, `core.harbor.domain`, with the external load balancer IP address that was
    used to access the portal in the previous steps.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/etc/hosts` 文件中创建一个本地 DNS 条目，将默认域名 `core.harbor.domain` 与用于访问门户的外部负载均衡器 IP
    地址关联。
- en: 'Log in to the Harbor registry using the `docker` CLI to enable push/pull operations:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker` CLI 登录 Harbor 注册表以启用推送/拉取操作：
- en: '[PRE10]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Push an image into your newly setup Harbor registry using the Docker client:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Docker 客户端将镜像推送到你新设置的 Harbor 注册表：
- en: 'Download the `busybox:latest` image using the `docker` CLI. The following command
    will download the image from the Docker Hub repository into your local workstation:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker` CLI 下载 `busybox:latest` 镜像。以下命令将从 Docker Hub 仓库下载镜像到你的本地工作站：
- en: '[PRE13]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Verify the presence of the `busybox:latest` image in your local image repository
    by running the following command:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令，验证 `busybox:latest` 镜像是否存在于你的本地镜像仓库中：
- en: '[PRE14]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should see a record indicating the `busybox` image with a `latest` tag as
    a result of the previous command.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到一个记录，显示前面命令的结果中带有 `latest` 标签的 `busybox` 镜像。
- en: 'Tag the `busybox:latest` image to prepare it to push to our Harbor registry
    instance:'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给 `busybox:latest` 镜像打标签，以准备将其推送到我们的 Harbor 注册表实例：
- en: '[PRE15]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Push the newly tagged image to your Harbor instance:'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新标记的镜像推送到你的 Harbor 实例：
- en: '[PRE16]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Upon this successful push operation, you should be able to see the image listed
    in your **library** project in the portal, as shown in the following screenshot:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功推送操作之后，你应该能看到该镜像在门户的 **library** 项目中列出，如下图所示：
- en: '![Figure 6.7 – Verifying the new image presence](img/B18145_06_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 验证新镜像的存在](img/B18145_06_07.jpg)'
- en: Figure 6.7 – Verifying the new image presence
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 验证新镜像的存在
- en: If you see the `busybox` image in the previous screen, your Harbor installation
    is complete. You may also choose to perform a pull test either from the same workstation
    by removing the existing image from the local repository, or a different workstation
    that has a Docker client. If you prefer to use a different workstation, you may
    need to configure the Harbor certificate there and authenticate against the Harbor
    repository using the `docker` CLI.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在之前的界面中看到了`busybox`镜像，那么你的 Harbor 安装已完成。你也可以选择进行拉取测试，方法是通过删除本地仓库中的现有镜像，在同一工作站上执行，或者使用具有
    Docker 客户端的另一台工作站。如果你希望使用不同的工作站，可能需要在那里配置 Harbor 证书，并通过 `docker` CLI 对 Harbor
    仓库进行身份验证。
- en: In the next section, we will cover some of the crucial day-2 operations for
    Harbor using this installation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些使用此安装的 Harbor 的关键第二天操作。
- en: Common day-2 operations with Harbor
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Harbor 的常见第二天操作
- en: 'Now that we have a working setup of Harbor, let’s look into some important
    day-2 operations that we may need to perform on it. We will cover the following
    activities in this section:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个可以正常工作的 Harbor 设置，接下来让我们来看看在其上可能需要执行的一些重要第二天操作。本节中我们将涵盖以下活动：
- en: Creating and configuring a project in Harbor, which is the multi-tenancy enabling
    construct on Harbor that allows different teams to have separate configurations
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Harbor 中创建并配置一个项目，这是 Harbor 上启用多租户的构造，允许不同的团队拥有各自独立的配置
- en: Configuring automated image scanning and working with the scan results
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自动化镜像扫描并处理扫描结果
- en: Preventing insecure images from being used to deploy containers using them
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止使用不安全的镜像来部署容器
- en: Configuring image replication to allow selective access to the external images
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置镜像复制以允许选择性访问外部镜像
- en: Performing a cleanup of unused image tags to free up the storage quota of a
    project
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行清理操作，删除未使用的镜像标签，以释放项目的存储配额
- en: As you can see here, we have lots of ground to cover. So, let’s get started.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，我们有很多内容需要涵盖。那么，让我们开始吧。
- en: Configuring a project in Harbor
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Harbor 中配置项目
- en: 'Let’s create a new project called **project-1** and configure it using the
    admin user we used previously to verify the installation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建一个名为 **project-1** 的新项目，并使用之前用来验证安装的管理员用户进行配置：
- en: 'Click on the **NEW PROJECT** button on the home screen of the Harbor portal
    after logging in as **admin**:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为**admin**登录Harbor门户的主屏幕上，点击**新项目**按钮：
- en: '![Figure 6.8 – Creating a new project](img/B18145_06_08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 创建新项目](img/B18145_06_08.jpg)'
- en: Figure 6.8 – Creating a new project
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 创建新项目
- en: 'Configure the project’s name and quota, as shown in the following screenshot,
    and click **OK**. We will keep this project private, which means that you need
    to get authenticated to pull images. We will also not configure this project to
    be used as a pull-through cache for an external registry such as Docker Hub:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置项目的名称和配额，如下截图所示，并点击**确定**。我们将保持此项目私有，这意味着您需要进行身份验证才能拉取图像。我们也不会将此项目配置为用于外部注册表（如Docker
    Hub）的拉取缓存：
- en: '![Figure 6.9 – Entering New Project details](img/B18145_06_09.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 输入新项目详细信息](img/B18145_06_09.jpg)'
- en: Figure 6.9 – Entering New Project details
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 输入新项目详细信息
- en: 'You should be able to see a new project listed on the screen, as shown in the
    following screenshot:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够在屏幕上看到列出的新项目，如下截图所示：
- en: '![Figure 6.10 – Verifying the new project’s presence](img/B18145_06_10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 验证新项目的存在](img/B18145_06_10.jpg)'
- en: Figure 6.10 – Verifying the new project’s presence
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 验证新项目的存在
- en: Now that we have this project created, the users of this project may push their
    images with the `core.harbor.domain/project-1/` prefix for the images. The project
    will not accept new images after it reaches its 2 GB storage quota, which we configured
    while creating it in *step 2*. Now, let’s learn about some of the important project-level
    configurations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了这个项目，该项目的用户可以通过在图像中应用`core.harbor.domain/project-1/`前缀来推送他们的图像。该项目在达到2GB存储配额后将不再接受新图像，这是我们在*步骤2*创建时配置的。现在，让我们了解一些重要的项目级配置。
- en: Configuring image scanning for a project in Harbor
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Harbor项目的图像扫描
- en: 'Scanning images for the presence of CVEs is an important security feature of
    Harbor. Now, let’s configure **project-1** to enable automated CVE scanning as
    soon as an image is pushed in this project using the default scanner, **Trivy**:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证Harbor的安全性，扫描图像中CVE的存在是一个重要的安全功能。现在，让我们配置**project-1**，以便在将图像推送到该项目时立即启用自动CVE扫描，使用默认的扫描工具**Trivy**：
- en: 'Go to the **project-1** detail page by clicking on the highlighted link:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击高亮链接进入**project-1**详细页面：
- en: '![Figure 6.11 – Selecting the newly created project](img/B18145_06_11.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 选择新创建的项目](img/B18145_06_11.jpg)'
- en: Figure 6.11 – Selecting the newly created project
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 选择新创建的项目
- en: 'Open the **Configuration** tab and select the highlighted option to scan every
    image upon push. Finally, click **SAVE**:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**配置**选项卡，并选择高亮选项，以便在每次推送时扫描每个图像。最后，点击**保存**：
- en: '![Figure 6.12 – Enabling image auto-scanning for the project](img/B18145_06_12.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 启用项目图像自动扫描](img/B18145_06_12.jpg)'
- en: Figure 6.12 – Enabling image auto-scanning for the project
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 启用项目图像自动扫描
- en: Now, let’s verify whether this configuration works by pushing the `busybox:latest`
    image that we pulled from Docker Hub previously. This should be present in your
    local workstation’s Docker repository.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们验证这个配置是否有效，通过推送我们之前从Docker Hub拉取的`busybox:latest`镜像。这应该存在于您本地工作站的Docker仓库中。
- en: 'Prepare the `busybox:latest` image to be pushed into the **project-1** repository
    of Harbor by applying the appropriate tag:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备将`busybox:latest`镜像推送到Harbor的**project-1**仓库，通过应用适当的标签：
- en: '[PRE17]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Push the newly tagged `busybox:latest` image to the **project-1** repository:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送新标记的`busybox:latest`镜像到**project-1**仓库：
- en: '[PRE18]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see in the result of the previous command, Harbor used the same layer
    of the image that we had pushed under the **library** project during the verification
    process we performed earlier.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在之前的命令结果中所见，Harbor在我们之前执行验证过程中，使用了图像的同一层，我们将其推送到**library**项目下。
- en: 'erify the image presence under **project-1** and click on the **project/busybox**
    link that is highlighted in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 验证**project-1**中图像的存在，并点击以下截图中突出显示的**project/busybox**链接：
- en: '![Figure 6.13 – Clicking the image repository](img/B18145_06_13.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 点击图像仓库](img/B18145_06_13.jpg)'
- en: Figure 6.13 – Clicking the image repository
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 点击图像仓库
- en: 'As shown in the following screenshot, the scanning of the `busybox:latest`
    image has already been completed with no vulnerabilities found in it. This scanning
    was triggered automatically upon pushing the new image into the repository:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，`busybox:latest` 镜像的扫描已完成，且未发现任何漏洞。此扫描是在将新镜像推送到仓库时自动触发的：
- en: '![Figure 6.14 – Verifying the scanning results](img/B18145_06_14.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 验证扫描结果](img/B18145_06_14.jpg)'
- en: Figure 6.14 – Verifying the scanning results
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 验证扫描结果
- en: Now, let’s create a policy based on such scan results to prevent pulling an
    image that has CVEs of more than medium severity to prevent running a container
    with such vulnerabilities.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们基于这样的扫描结果创建一个策略，防止拉取具有中等以上严重性 CVE 的镜像，以避免运行包含此类漏洞的容器。
- en: Preventing insecure images from being used in Harbor
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止在 Harbor 中使用不安全的镜像
- en: 'To stop insecure images from being pulled, navigate to the project landing
    page of **project-1**. You may see an option named **Prevent vulnerable images
    from running** under the **Configuration** tab, as shown in the following screenshot.
    Check this option, select **High** from the dropdown menu, and save the configuration
    changes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止不安全的镜像被拉取，导航到 **project-1** 的项目主页。在 **配置** 选项卡下，你可以看到一个名为 **防止易受攻击的镜像运行**
    的选项，如下图所示。选中此选项，从下拉菜单中选择 **高**，并保存配置更改：
- en: '![Figure 6.15 – Preventing image pulling with high and critical CVEs](img/B18145_06_15.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 防止拉取包含高危 CVE 的镜像](img/B18145_06_15.jpg)'
- en: Figure 6.15 – Preventing image pulling with high and critical CVEs
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 防止拉取包含高危 CVE 的镜像
- en: 'Now, let’s test this configuration change. For that, we need to push an insecure
    image into **project-1**. You may follow these steps to perform this test:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这个配置更改。为此，我们需要将一个不安全的镜像推送到 **project-1**。你可以按照以下步骤执行此测试：
- en: 'Pull the `nginx:1.9.5` image from Docker Hub, which is very old and full of
    CVEs:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Docker Hub 拉取 `nginx:1.9.5` 镜像，这是一个非常旧且漏洞多的版本：
- en: '[PRE22]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Tag `nginx:1.9.5` for the Harbor **project-1** repository:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Harbor **project-1** 仓库打标签 `nginx:1.9.5`：
- en: '[PRE23]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Push `nginx:1.9.5` to the Harbor **project-1** repository:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `nginx:1.9.5` 推送到 Harbor **project-1** 仓库：
- en: '[PRE24]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verify that the image on Harbor under **project-1** has been scanned and showing
    CVEs, as shown in the following screenshot:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 Harbor 中 **project-1** 下的镜像已扫描并显示 CVE，如下图所示：
- en: '![Figure 6.16 – Verifying the CVE scan results](img/B18145_06_16.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 验证 CVE 扫描结果](img/B18145_06_16.jpg)'
- en: Figure 6.16 – Verifying the CVE scan results
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 验证 CVE 扫描结果
- en: 'Delete the `nginx:1.9.5` image from the local Docker repository so that we
    can attempt to pull it from our Harbor **project-1** repository:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本地 Docker 仓库中删除 `nginx:1.9.5` 镜像，以便我们可以尝试从 Harbor **project-1** 仓库拉取它：
- en: '[PRE25]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Try to pull `nginx:1.9.5` from the Harbor **project-1** repository:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试从 Harbor **project-1** 仓库拉取 `nginx:1.9.5` 镜像：
- en: '[PRE26]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, Harbor denied sending the image because of the CVEs present
    in the image above the configured tolerance threshold.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Harbor 因镜像中存在超出配置容忍阈值的 CVE，拒绝发送该镜像。
- en: Important note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We took this testing approach to keep it simple. But alternatively, you may
    also attempt to create a pod using this image on a Kubernetes cluster to mimic
    a practical scenario. The result would be the same and you may not create a pod
    using the `core.harbor.domain/project-1/nginx:1.9.5` image. However, to test creating
    a pod using this Harbor setup, you may need to add the DNS entries to all your
    Kubernetes cluster nodes’ `/etc/hosts` file. Alternatively, you might need to
    create a more production-like Harbor setup with a proper domain name that can
    be resolved using an external DNS record from within the Kubernetes cluster.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用这种测试方法是为了简化操作。但你也可以尝试在 Kubernetes 集群中使用该镜像创建一个 Pod，以模拟实际场景。结果是一样的，你将无法使用
    `core.harbor.domain/project-1/nginx:1.9.5` 镜像创建 Pod。然而，要测试使用此 Harbor 设置创建 Pod，你可能需要将
    DNS 条目添加到所有 Kubernetes 集群节点的 `/etc/hosts` 文件中。或者，你可能需要创建一个更像生产环境的 Harbor 设置，使用正确的域名，通过
    Kubernetes 集群中的外部 DNS 记录解析。
- en: This concludes our configuration and its test to prevent insecure container
    images from being pulled from a Harbor repository. In the next section, we will
    learn how to configure a remote repository sync to allow internal developers to
    pull the required externally available allowed images via Harbor.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们配置及其测试的总结，旨在防止从 Harbor 仓库中拉取不安全的容器镜像。在下一节中，我们将学习如何配置远程仓库同步，以允许内部开发人员通过
    Harbor 拉取所需的外部可用的允许镜像。
- en: Replicating images in Harbor
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Harbor 中复制镜像
- en: 'In this section, we will learn how to configure image replication in Harbor.
    There are two types of replications in Harbor, as described here, along with their
    practical applications:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将学习如何在 Harbor 中配置镜像复制。Harbor 中有两种类型的复制，如下所述，并介绍了它们的实际应用：
- en: '**Push-based**: To configure a rule to push certain images from Harbor to another
    repository, which could be another remote Harbor deployment or even a public repository.
    This type of replication is very useful to implement a hub-and-spoke type of deployment
    where we need to make certain images available in the Kubernetes clusters running
    at edge locations. Having the required images on the same Kubernetes clusters
    available at the edge location could be a great help to reduce network latency
    and dependency (hence application availability) when the image pulls are required
    to deploy containers on the edge Kubernetes clusters. This scenario is depicted
    in *Figure 6**.1*.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**推送型**：配置规则将特定镜像从 Harbor 推送到另一个仓库，这可以是另一个远程 Harbor 部署，甚至是公共仓库。这种类型的复制对于实现“中心-边缘”类型的部署非常有用，其中需要在边缘位置的
    Kubernetes 集群中提供某些镜像。在边缘位置的 Kubernetes 集群上拥有所需的镜像有助于减少网络延迟和依赖（从而提高应用可用性），尤其是在需要拉取镜像以在边缘
    Kubernetes 集群上部署容器时。此场景在 *图 6.1* 中有所描绘。'
- en: '**Pull-based**: To configure a rule to pull certain images from a remote public
    or private repository. Such a replication policy allows access to developers of
    certain allowed container images from an external repository such as Docker Hub
    or GCR. This feature of Harbor not only allows freedom for developers to use approved
    externally hosted images but also allows operators to prevent the wild-wild-west
    situation where anyone may pull any image from an external repository. *Figure
    6**.1* shows how the central Harbor repository pulls required images from Docker
    Hub and GCR using this feature.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**拉取型**：配置规则从远程公共或私有仓库拉取特定镜像。这种复制策略允许开发者从外部仓库（如 Docker Hub 或 GCR）访问某些允许的容器镜像。Harbor
    的这一功能不仅允许开发者自由使用经批准的外部托管镜像，而且还允许运维人员防止“无人管辖”的情况，避免任何人从外部仓库拉取任何镜像。*图 6.1* 显示了中心
    Harbor 仓库如何使用此功能从 Docker Hub 和 GCR 拉取所需镜像。'
- en: 'Now that we understand the types and their uses, let’s see how we can configure
    these replication rules in Harbor. Here, we will configure a pull-based policy
    to allow developers to access MySQL images from Docker Hub. We will configure
    a remote repository location and the replication rule in Harbor, followed by quickly
    verifying that these configurations are working as expected:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了这些类型及其用途，接下来我们来看如何在 Harbor 中配置这些复制规则。在这里，我们将配置一个拉取型策略，以允许开发者从 Docker
    Hub 访问 MySQL 镜像。我们将配置远程仓库位置和复制规则，然后快速验证这些配置是否按预期工作：
- en: 'Add Docker Hub as an external registry endpoint:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Docker Hub 作为外部仓库端点：
- en: 'Click on the **Registries** option under the **Administration** menu and click
    on the **NEW ENDPOINT** button, as shown in the following screenshot:'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **管理** 菜单下的 **Registries** 选项，然后点击 **NEW ENDPOINT** 按钮，如下图所示：
- en: '![Figure 6.17 – Adding a new external registry endpoint](img/B18145_06_17.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 添加新的外部仓库端点](img/B18145_06_17.jpg)'
- en: Figure 6.17 – Adding a new external registry endpoint
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 添加新的外部仓库端点
- en: 'Select **Docker Hub** from the dropdown, enter a name and description, and
    click on the **TEST CONNECTION** button. You may leave the authentication details
    empty for this test. However, for a production-grade deployment, you should supply
    these credentials to prevent Docker Hub from applying an image pull rate limit.
    Docker Hub throttles unauthenticated pull requests with lower rate limits:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择 **Docker Hub**，输入名称和描述，然后点击 **TEST CONNECTION** 按钮。您可以在此测试中将身份验证详情留空。然而，对于生产环境部署，您应该提供这些凭据，以防止
    Docker Hub 应用镜像拉取速率限制。Docker Hub 会对未验证的拉取请求应用较低的速率限制：
- en: '![Figure 6.18 – Adding Docker Hub details and testing the connection](img/B18145_06_18.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.18 – 添加 Docker Hub 详情并测试连接](img/B18145_06_18.jpg)'
- en: Figure 6.18 – Adding Docker Hub details and testing the connection
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 添加 Docker Hub 详情并测试连接
- en: Click the **OK** button to save and exit.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **OK** 按钮以保存并退出。
- en: 'Verify the newly created entry under the **Registries** page, as shown in the
    following screenshot:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Registries** 页面下验证新创建的条目，如下图所示：
- en: '![Figure 6.19 – Verifying the presence of the Docker Hub endpoint](img/B18145_06_19.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19 – 验证 Docker Hub 端点的存在](img/B18145_06_19.jpg)'
- en: Figure 6.19 – Verifying the presence of the Docker Hub endpoint
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 验证 Docker Hub 端点是否存在
- en: 'Create a replication rule that allows us to pull MySQL images from Docker Hub
    using the registry endpoint we just created:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个复制规则，允许我们通过刚才创建的注册表端点从 Docker Hub 拉取 MySQL 镜像：
- en: 'Click on the **Replications** option under the **Administration** menu and
    click on the **NEW REPLICATION RULE** button, as shown in the following screenshot:'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**管理**菜单下的**复制**选项，并点击**新建复制规则**按钮，如下图所示：
- en: '![Figure 6.20 – Creating a new replication rule](img/B18145_06_20.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.20 – 创建新的复制规则](img/B18145_06_20.jpg)'
- en: Figure 6.20 – Creating a new replication rule
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 创建新的复制规则
- en: 'Enter the name and the description of the replication rule, select the **Pull-based**
    replication option, select the Docker Hub registry endpoint from the dropdown
    that we created in *step 1*, provide image filter criteria, as shown in the following
    screenshot, and click the **SAVE** button:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入复制规则的名称和描述，选择**基于拉取**的复制选项，从下拉菜单中选择我们在*步骤 1*中创建的 Docker Hub 注册表端点，提供镜像过滤标准，如下图所示，并点击**保存**按钮：
- en: '![Figure 6.21 – Submitting the replication rule’s details](img/B18145_06_21.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.21 – 提交复制规则的详细信息](img/B18145_06_21.jpg)'
- en: Figure 6.21 – Submitting the replication rule’s details
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 提交复制规则的详细信息
- en: We will leave the other options as-is. These other options include the image
    destination details to specify if we want a different image folder name and the
    directory structure, which is different from the source. It also has the option
    to select when we want to trigger pulling the images matching the filter criteria.
    The default value of the same is to pull manually when required but we can also
    create a schedule-based pull. Then, we have the option to restrict the bandwidth
    requirements to prevent the network from being overwhelmed with a flood of pull
    requests being executed for large filter criteria. And finally, there is the option
    to enable/disable the images from being overwritten when there is an image with
    a different SHA but the same name and tag available on the source registry endpoint.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持其他选项不变。这些选项包括镜像目标详情，用于指定我们是否想要一个与源不同的镜像文件夹名称和目录结构。它还提供了选择何时触发拉取符合过滤标准的镜像的选项。默认值是根据需要手动拉取，但我们也可以创建基于计划的拉取。然后，我们可以限制带宽要求，以防止网络因执行大量拉取请求而被淹没。最后，还有一个选项，可以在源注册表端点上有一个不同
    SHA 但相同名称和标签的镜像时，启用/禁用镜像被覆盖。
- en: Customized filter patterns
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义过滤模式
- en: 'In the previous configuration, we used very basic filter criteria to pick all
    MySQL images that have tags starting with `8.` characters. However, you may apply
    complex patterns here to allow/disallow images based on your requirements. You
    may learn more about such patterns here: [https://goharbor.io/docs/2.4.0/administration/configuring-replication/create-replication-rules/](https://goharbor.io/docs/2.4.0/administration/configuring-replication/create-replication-rules/).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置中，我们使用了非常基础的过滤标准来选择所有标签以`8.`开头的 MySQL 镜像。然而，你可以在这里应用复杂的模式，根据需求允许/拒绝镜像。你可以在这里了解更多关于这些模式的信息：[https://goharbor.io/docs/2.4.0/administration/configuring-replication/create-replication-rules/](https://goharbor.io/docs/2.4.0/administration/configuring-replication/create-replication-rules/)。
- en: 'Trigger the replication manually by selecting the newly created rule and clicking
    on the **REPLICATE** button:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择新创建的规则并点击**复制**按钮，手动触发复制操作：
- en: '![Figure 6.22 – Triggering image replication](img/B18145_06_22.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.22 – 触发镜像复制](img/B18145_06_22.jpg)'
- en: Figure 6.22 – Triggering image replication
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 触发镜像复制
- en: 'Confirm the replication by pressing the **REPLICATE** button:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认复制操作，点击**复制**按钮：
- en: '![Figure 6.23 – Confirming image replication](img/B18145_06_23.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.23 – 确认镜像复制](img/B18145_06_23.jpg)'
- en: Figure 6.23 – Confirming image replication
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 确认镜像复制
- en: 'Verify whether the replication execution was successful from the **Executions**
    section on the **Replications** page, as shown in the following screenshot. Depending
    on the network connection, it may take a few minutes before all the images are
    successfully replicated:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**复制**页面的**执行**部分验证复制是否成功，如下图所示。根据网络连接情况，可能需要几分钟才能成功复制所有镜像：
- en: '![Figure 6.24 – Verifying image replication execution](img/B18145_06_24.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.24 – 验证镜像复制执行](img/B18145_06_24.jpg)'
- en: Figure 6.24 – Verifying image replication execution
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – 验证镜像复制执行
- en: 'Upon successful completion of this replication, go to the **Projects** screen
    and click on the **library** project:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复制成功完成后，转到 **项目** 屏幕并点击 **库** 项目：
- en: '![Figure 6.25 – Opening the library project](img/B18145_06_25.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.25 – 打开库项目](img/B18145_06_25.jpg)'
- en: Figure 6.25 – Opening the library project
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25 – 打开库项目
- en: 'You will see a new namespace under the **Repositories** tab named **library/mysql**.
    Click on that link:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在 **仓库** 标签页下看到一个名为 **library/mysql** 的新命名空间。点击该链接：
- en: '![Figure 6.26 – Verifying the newly replicated repository](img/B18145_06_26.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.26 – 验证新复制的仓库](img/B18145_06_26.jpg)'
- en: Figure 6.26 – Verifying the newly replicated repository
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 – 验证新复制的仓库
- en: 'You may see several images listed under **library/mysql** as a result of the
    replication operation:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会看到在 **library/mysql** 下列出了多个图像，这是由于复制操作的结果：
- en: '![Figure 6.27 – Verifying the newly replicated repository’s content](img/B18145_06_27.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.27 – 验证新复制的仓库内容](img/B18145_06_27.jpg)'
- en: Figure 6.27 – Verifying the newly replicated repository’s content
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27 – 验证新复制的仓库内容
- en: 'Pull one of these images into the local workstation’s Docker repository to
    verify it is working as expected:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其中一个图像拉取到本地工作站的 Docker 仓库，以验证其是否按预期工作：
- en: '[PRE28]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command should be able to pull the image successfully from our Harbor repository.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应该能够从我们的 Harbor 仓库成功拉取图像。
- en: This concludes our replication configuration step. Now, the developers may pull
    a required MySQL image directly from the Harbor repository rather than getting
    them from Docker Hub.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们复制配置步骤的结束。现在，开发人员可以直接从 Harbor 仓库拉取所需的 MySQL 图像，而无需从 Docker Hub 获取。
- en: As the next day-2 activity in this list, we will learn how to configure a rule-based
    tag retention policy to clean up stale images and free up the storage.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个列表中的下一个第2天活动，我们将学习如何配置基于规则的标签保留策略，以清理过期的图像并释放存储空间。
- en: Configuring rule-based tag retention policies in Harbor
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Harbor 中配置基于规则的标签保留策略
- en: 'As you saw in the previous configuration, we replicated over 25 different images
    for MySQL. In production-grade implementations, we often encounter situations
    where there are several stale images not being used but occupying the project’s
    allocated space quota. In our previous MySQL replication, we may see only a few
    image tags that are used, and we can remove the rest. For that, we will learn
    how to configure such automated tag-based retention policies to clean up old and
    useless content. Let’s get started:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在之前的配置中所见，我们为 MySQL 复制了超过 25 个不同的图像。在生产环境中，我们经常会遇到一些过期的图像，这些图像未被使用，却占用了项目分配的空间配额。在我们之前的
    MySQL 复制中，可能只会看到几个使用的图像标签，而我们可以移除其余的图像。为此，我们将学习如何配置基于标签的自动化保留策略，以清理旧的和无用的内容。让我们开始吧：
- en: 'Go to the **Projects** screen and click on the **library** project:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **项目** 屏幕并点击 **库** 项目：
- en: '![Figure 6.28 – Opening the library project](img/B18145_06_28.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.28 – 打开库项目](img/B18145_06_28.jpg)'
- en: Figure 6.28 – Opening the library project
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.28 – 打开库项目
- en: 'Under the **library** project, go to the **Policy** tab and click on the **ADD**
    **RULE** button:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **库** 项目下，转到 **策略** 标签页，点击 **添加** **规则** 按钮：
- en: '![Figure 6.29 – Adding a new image retention rule](img/B18145_06_29.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.29 – 添加新的图像保留规则](img/B18145_06_29.jpg)'
- en: Figure 6.29 – Adding a new image retention rule
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29 – 添加新的图像保留规则
- en: 'Enter `mysql` as the matching repository, select `1` as the count to retain,
    and press the **ADD** button:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `mysql` 作为匹配仓库，选择 `1` 作为保留数量，然后点击 **添加** 按钮：
- en: '![Figure 6.30 – Entering details about the image retention rule](img/B18145_06_30.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.30 – 输入图像保留规则的详细信息](img/B18145_06_30.jpg)'
- en: Figure 6.30 – Entering details about the image retention rule
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30 – 输入图像保留规则的详细信息
- en: This policy will remove all MySQL images except for `mysql:8.0.27` because we
    pulled that one in the verification step earlier.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略将移除所有 MySQL 图像，除了 `mysql:8.0.27`，因为我们在验证步骤中已经拉取了这个图像。
- en: 'As you can see, the new tag retention policy is in place. While we can also
    schedule this activity at a regular frequency, for now, we will run it manually
    using the **RUN** **NOW** button:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，新的标签保留策略已经生效。虽然我们也可以按照定期频率安排此活动，但现在我们将通过点击 **立即运行** 按钮手动执行它：
- en: '![Figure 6.31 – Verifying the creation of the image retention rule](img/B18145_06_31.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.31 – 验证图像保留规则的创建](img/B18145_06_31.jpg)'
- en: Figure 6.31 – Verifying the creation of the image retention rule
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.31 – 验证图像保留规则的创建
- en: 'Move on by pressing the **RUN** button by accepting the warning of a mass deletion
    operation:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下**RUN**按钮并接受批量删除操作的警告来继续：
- en: '![Figure 6.32 – Executing the image retention rule](img/B18145_06_32.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.32 – 执行镜像保留规则](img/B18145_06_32.jpg)'
- en: Figure 6.32 – Executing the image retention rule
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32 – 执行镜像保留规则
- en: 'Verify whether the clean-up activity was completed successfully by inspecting
    the activity log record, which indicates there was only 1 tag retained out of
    24 total. This was the expected outcome:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查活动日志记录，验证清理活动是否成功完成，日志应显示从24个标签中只保留了一个标签，这是预期的结果：
- en: '![Figure 6.33 – Verifying the image retention rule’s execution](img/B18145_06_33.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.33 – 验证镜像保留规则的执行情况](img/B18145_06_33.jpg)'
- en: Figure 6.33 – Verifying the image retention rule’s execution
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33 – 验证镜像保留规则的执行情况
- en: 'Click on the **Repositories** tab to list the existing repositories. On that
    screen, you should be able to see only 1 tag available for **mysql** instead of
    the 24 from earlier:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Repositories**标签，列出现有的仓库。在该页面上，你应该能看到只有一个**mysql**标签，而不是之前的24个标签：
- en: '![Figure 6.34 – Verifying the remaining image count post-retention rule’s execution](img/B18145_06_34.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.34 – 验证保留规则执行后剩余镜像的数量](img/B18145_06_34.jpg)'
- en: Figure 6.34 – Verifying the remaining image count post-retention rule’s execution
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34 – 验证保留规则执行后剩余镜像的数量
- en: 'Navigate to the `mysql` repository to verify that the tags other than `8.0.27`
    have been deleted:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `mysql` 仓库，验证除了 `8.0.27` 之外的标签是否已被删除：
- en: '![Figure 6.35 – Verifying the remaining image’s post-retention rule’s execution](img/B18145_06_35.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.35 – 验证剩余镜像的保留规则执行情况](img/B18145_06_35.jpg)'
- en: Figure 6.35 – Verifying the remaining image’s post-retention rule’s execution
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.35 – 验证剩余镜像的保留规则执行情况
- en: This concludes our tag retention policy configuration. Like tag retention, we
    may also configure tag immutability policies to configure certain critical image
    tags from being overwritten with a new version of the image. Without such a policy
    in place, you may push new images with changes but with the same tag value. Hence,
    an application that is tested against one tagged version of an image may not be
    able to fully ensure that the content of the same tag would be the same in the
    next pull of the image. This could potentially break applications from working
    in case of any unexpected changes in the newer version of the same tagged images
    are pushed. Ideally, this should not be the case as it is a poor development practice.
    But there should be some controls in place to prevent it from happening. Hence,
    Harbor helps in this case by allowing you to create policies where the Harbor
    users may not push images with the same tag with different content determined
    by the SHA-256 algorithm.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们的标签保留策略配置结束。与标签保留类似，我们还可以配置标签不可变性策略，以防止某些关键的镜像标签被新的镜像版本覆盖。如果没有这样的策略，你可能会推送带有相同标签值的新的镜像版本。这样，针对某一标签版本的应用测试，可能无法确保下次拉取该标签时内容不变。如果新版本的同一标签镜像发生了任何意外变化，这可能会导致应用程序无法正常工作。理想情况下，这种情况不应发生，因为这是一种不良的开发实践。但应该有一些控制措施来防止这种情况发生。因此，Harbor
    在这种情况下提供了帮助，允许你创建策略，防止 Harbor 用户推送具有不同内容但相同标签的镜像，而这些内容是由 SHA-256 算法决定的。
- en: Important information
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: To safeguard our containerized applications from failing because of changed
    image content for the same tag value, it is always a good practice to pull images
    using their SHA values rather than their tags. Pulling an image using its SHA
    value (also known as the digest) ensures you always get the same image with the
    same content and there is no fear of it getting accidentally overwritten with
    the same tag value. For example, the image content pulled with the `docker pull
    ubuntu:20.04` command can be theoretically different for multiple executions,
    but the image content will always be the same when it is pulled with its digest
    using the `docker pull` `ubuntu@sha256:82becede498899ec668628e7cb0ad87b6e1c371cb8a1e597d83a47fac21d6af3`
    command.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的容器化应用免于因相同标签值的镜像内容发生变化而失败，最好使用镜像的 SHA 值而不是标签来拉取镜像。使用 SHA 值拉取镜像（也称为摘要）可以确保你始终获取相同的镜像，并且没有被意外覆盖的风险。例如，使用
    `docker pull ubuntu:20.04` 命令拉取的镜像内容在多次执行时理论上可能会有所不同，但当你使用其摘要通过 `docker pull ubuntu@sha256:82becede498899ec668628e7cb0ad87b6e1c371cb8a1e597d83a47fac21d6af3`
    命令拉取时，镜像内容始终相同。
- en: There are several more administrative and user day-2 activities we may need
    to perform on Harbor, including user account management, robot accounts for automation,
    image signing, webhook-based automation triggers, and many more. In this chapter,
    we covered some of the most common activities that we usually perform on a container
    registry such as Harbor. While we can add more details for other operations, the
    goal of this book is not to be a Harbor guide alone. But if you want, you may
    find more details in the official documentation for Harbor at [https://goharbor.io/docs/2.4.0/](https://goharbor.io/docs/2.4.0/).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Harbor 上，我们可能需要执行更多的管理和用户 day-2 活动，包括用户账号管理、用于自动化的机器人账号、镜像签名、基于 Webhook 的自动化触发器等等。在本章中，我们涵盖了一些通常在容器注册表（如
    Harbor）上执行的最常见活动。虽然我们可以为其他操作添加更多细节，但本书的目标并不仅限于成为 Harbor 指南。不过，如果你愿意，你可以在 Harbor
    的官方文档 [https://goharbor.io/docs/2.4.0/](https://goharbor.io/docs/2.4.0/) 中找到更多详细信息。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Let’s review what we have covered in this chapter. First, we discussed several
    benefits and the use cases of Harbor while explaining the *Why* behind using it.
    We looked at the different security-related benefits of Harbor, including image
    scanning, robust RBAC capabilities, and the ability to restrict public repository
    access requirements using image replications. For the operational control aspect,
    we discussed the benefits, such as on-premises and air-gapped deployment, a popular
    open source project under CNCF, comprehensive multi-tenancy, and administrative
    configurations. For the extensibility aspect, we saw how Harbor can be used with
    its replication feature of extending image library contents. Harbor’s pluggable
    model for vulnerability scanners and authentication providers was also discussed
    in this category.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章我们所涵盖的内容。首先，我们讨论了 Harbor 的多种好处和用例，同时解释了使用它的原因。我们查看了 Harbor 的不同安全相关好处，包括镜像扫描、强大的
    RBAC 功能以及使用镜像复制限制公共库访问需求的能力。对于操作控制方面，我们讨论了诸如本地部署和空隙部署、作为 CNCF 下的热门开源项目、全面的多租户支持以及管理配置等好处。在可扩展性方面，我们看到了
    Harbor 如何通过其镜像库内容的扩展功能与复制特性一起使用。本类别还讨论了 Harbor 的漏洞扫描器和认证提供程序的可插拔模型。
- en: After that, we covered details of Harbor’s architecture and learned about the
    different components that make up Harbor in detail. Following this, we learned
    how to quickly get started with Harbor using the Bitnami Helm chart and verified
    the installation. Finally, we walked through some of the important day-2 operations
    around Harbor, including creating a project, performing image scanning, preventing
    risky images from being pulled, image replication from Docker Hub, and cleaning
    stale images to free up the storage quota for a project.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们详细讨论了 Harbor 的架构细节，并了解了构成 Harbor 的不同组件。接着，我们学习了如何使用 Bitnami Helm 图表快速开始使用
    Harbor，并验证了安装。最后，我们深入探讨了围绕 Harbor 的一些重要 day-2 操作，包括创建项目、执行镜像扫描、阻止拉取风险镜像、从 Docker
    Hub 复制镜像以及清理过期镜像以释放项目的存储配额。
- en: In the next chapter, we will learn how to run these images using Tanzu Kubernetes
    Grid, a multi-cloud Kubernetes offering from VMware.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Tanzu Kubernetes Grid 在多云环境中运行这些镜像，这是 VMware 提供的多云 Kubernetes
    解决方案。
