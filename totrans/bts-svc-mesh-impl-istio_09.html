<html><head></head><body>
		<div id="_idContainer113">
			<h1 id="_idParaDest-140" class="chapter-number"><a id="_idTextAnchor139"/>9</h1>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Extending Istio Data Plane</h1>
			<p>Istio provides various APIs to manage data plane traffic. There is one API called <strong class="source-inline">EnvoyFilter</strong> that we have not yet used. The <strong class="source-inline">EnvoyFilter</strong> API provides a means to customize the istio-proxy configuration generated by the Istio control plane. Using the <strong class="source-inline">EnvoyFilter</strong> API, you can directly use Envoy filters even if they are not directly supported by <span class="No-Break">Istio APIs.</span></p>
			<p>There is another API called <strong class="source-inline">WasmPlugins</strong>, which is another mechanism to extend the istio-proxy functionality <strong class="bold">WebAssembly</strong> (<strong class="bold">Wasm</strong>) support is becoming common for proxies such as Envoy<a id="_idIndexMarker754"/> to enable developers to <span class="No-Break">build extensions.</span></p>
			<p>In this chapter, we will discuss these two topics; however, the content on <strong class="source-inline">EnvoyFilter</strong> will be brief, as you have already learned about filters and plugins for Envoy in <span class="No-Break"><em class="italic">Chapter 3</em></span>. Rather, we will focus on how to invoke Envoy plugins from Istio configurations. However, we will delve deeper into Wasm with hands-on activities <span class="No-Break">as usual.</span></p>
			<p>In this chapter we will be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Why extensibility?</span></li>
				<li>Customizing the data plane <span class="No-Break">using EnvoyFilter</span></li>
				<li>Understanding the fundamentals <span class="No-Break">of Wasm</span></li>
				<li>Extending the Istio data plane <span class="No-Break">using Wasm</span></li>
			</ul>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Technical requirements</h1>
			<p>To keep it simple, we will be using minikube to perform the hands-on exercises in this chapter. By now, you must be familiar with installing and configuring minikube, and if not, please refer to the <em class="italic">Technical requirements</em> section of <span class="No-Break"><em class="italic">Chapter 4</em></span><span class="No-Break">.</span></p>
			<p>In addition to minikube, it is good to have Go and TinyGo installed on your workstation. If you are new to Go, then follow the instructions at <a href="https://go.dev/doc/install">https://go.dev/doc/install</a> to install it. Install TinyGo for your host OS by following the instructions at <a href="https://tinygo.org/getting-started/install/macos/">https://tinygo.org/getting-started/install/macos/</a>. Then validate the installation by using the <span class="No-Break">following command:</span></p>
			<pre class="console">
% tinygo version
tinygo version 0.26.0 darwin/amd64 (using go version go1.18.5 and LLVM version 14.0.0)</pre>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Why extensibility</h1>
			<p>As with<a id="_idIndexMarker755"/> any good architecture, <strong class="bold">extensibility</strong> is very important because there is no <em class="italic">one size fits all</em> approach to technology that can adapt to every application. Extensibility is important in Istio as it provides options to users to build corner cases and extend Istio as per their individual needs. In the early days of Istio and Envoy, the projects took different approaches to build extensibility. Istio took the approach<a id="_idIndexMarker756"/> of building a generic<a id="_idIndexMarker757"/> out-of-process extension model called <strong class="bold">Mixer</strong> (<a href="https://istio.io/v1.6/docs/reference/config/policy-and-telemetry/mixer-overview/">https://istio.io/v1.6/docs/reference/config/policy-and-telemetry/mixer-overview/</a>), whereas Envoy focused on in-proxy extensions (<a href="https://www.envoyproxy.io/docs/envoy/latest/extending/extending">https://www.envoyproxy.io/docs/envoy/latest/extending/extending</a>). Mixer is now deprecated; it was<a id="_idIndexMarker758"/> a plugin-based implementation used for building extensions (also called adaptors) for various infrastructure<a id="_idIndexMarker759"/> backends. Some examples of adapters are Bluemix, AWS, Prometheus, Datadog, and SolarWinds. These adapters allowed Istio to interface with various kinds of backend systems for logging, monitoring, and telemetry, but the adapter-based extension model suffered from significant resource inefficiencies that impacted tail latencies and resource utilization. This model was also intrinsically limited and had limited application. The Envoy extension approach required users to write filters in C++, which is also Envoy’s native language. Extensions written in C++ are then packaged along with Envoy’s code base, compiled, and tested to make sure that they are working as expected. The in-proxy extension approach for Envoy imposed a constraint of writing extensions in C++ followed by a monolithic build process and the fact that you must now maintain the Envoy code base yourself. Some bigger organizations were able to manage their own copy of the Envoy code base, but most of the Envoy community found this approach impractical. So, Envoy adopted other approaches<a id="_idIndexMarker760"/> for building extensions, one being <strong class="bold">Lua-based filters</strong> and the other being Wasm extensions. In Lua-based extensions, users can write inline Lua code in an existing Envoy HTTP Lua filter. The following is an example of a Lua filter; the Lua script has <span class="No-Break">been highlighted:</span></p>
			<pre class="source-code">
http_filters:
name: envoy.filters.http.lua
typed_config:
  "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
  default_source_code:
    inline_string: |
     <strong class="bold">function envoy_on_request(request_handle)</strong>
<strong class="bold">...... -- Do something on the request path.</strong>
<strong class="bold">       request_handle:headers():add("NewHeader", "XYZ")</strong>
<strong class="bold">     end</strong>
<strong class="bold">     function envoy_on_response(response_handle)</strong>
<strong class="bold">       -- Do something on the response path.</strong>
<strong class="bold">      response_handle:logInfo("Log something")</strong>
<strong class="bold">     response_handle:headers:add("response_size",response_handle:body():length())</strong>
<strong class="bold">      response_handle:headers:remove("proxy")</strong>
<strong class="bold">    end</strong></pre>
			<p>In this example, we are using the <strong class="bold">HTTP Lua filter</strong>. The HTTP Lua filter allows Lua<a id="_idIndexMarker761"/> scripts to be run during both<a id="_idIndexMarker762"/> the request and response cycle. Envoy runs the Lua script as a coroutine; LuaJIT is used as the Lua runtime environment and is allocated per Envoy worker thread. The Lua scripts should contain the <strong class="source-inline">envoy_on_request</strong> and/or <strong class="source-inline">envoy_on_response</strong> functions, which are then executed as coroutines on the request and response cycles, respectively. You can write Lua code in these functions to perform the following during <span class="No-Break">request/response processing:</span></p>
			<ul>
				<li>Inspection and modification of headers, body, and trailers of request and <span class="No-Break">response flows</span></li>
				<li>Asynchronous HTTP invocation of <span class="No-Break">upstream systems</span></li>
				<li>Performing direct response and skipping further <span class="No-Break">filter iteration</span></li>
			</ul>
			<p>You can read<a id="_idIndexMarker763"/> more about Envoy HTTP Lua filters at <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/lua_filter.html?highlight=lua%20filter">https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/lua_filter.html?highlight=lua%20filter</a>. This approach is great for simple logic, but when writing complex processing instructions then writing inline Lua code is not practical. Inline code cannot be easily shared with other developers or easily aligned with best practices of software programming. The other drawback is the lack of flexibility, as developers are obliged to only use Lua, which inhibits non-Lua developers from writing <span class="No-Break">these extensions.</span></p>
			<p>To provide extensibility<a id="_idIndexMarker764"/> to Istio, an approach that imposed fewer tradeoffs was needed. As Istio’s data plane comprises Envoy, it made sense to converge on a common approach for extensibility for Envoy and Istio. This can decouple Envoy releases from their extension ecosystem, enables Istio consumers to build data plane extensions using their languages of choice, using best-of-breed programming languages and practices, and then deploy these extensions without causing any downtime risk to their Istio deployments in production. Based on this common effort, Wasm support for Istio was introduced. In the upcoming sections, we will discuss Wasm. But before that, let’s quickly touch on Istio support for running Envoy filters in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Customizing the data plane using Envoy Filter</h1>
			<p>Istio provides an <strong class="source-inline">EnvoyFilter</strong> API, which provides<a id="_idIndexMarker765"/> options to modify<a id="_idIndexMarker766"/> configurations created via other Istio <strong class="bold">custom resource definitions</strong> (<strong class="bold">CRDs</strong>). Essentially one of the functions<a id="_idIndexMarker767"/> performed by Istio is translating high-level Istio CRDs into low-level Envoy configurations. Using the <strong class="source-inline">EnvoyFilter</strong> CRD, you can change those low-level configurations directly. This is a very powerful feature but also should be used cautiously as it has the potential to make things worse if not used correctly. Using <strong class="source-inline">EnvoyFilter</strong>, you can apply configurations<a id="_idIndexMarker768"/> that are not directly available in Istio CRDs<a id="_idIndexMarker769"/> and perform more advanced Envoy functions. The filter can be applied at the namespace level as well as selective workload levels identified <span class="No-Break">by labels.</span></p>
			<p>Let’s try to understand this further via <span class="No-Break">an example.</span></p>
			<p>We will pick one of the hands-on exercises we performed in <span class="No-Break"><em class="italic">Chapter 7</em></span> to route a request to <strong class="source-inline">hhtppbin.org</strong>. Do not forget to create the <strong class="source-inline">Chapter09</strong> folder and turn on <strong class="source-inline">istio-injection</strong>. The following commands will deploy the <strong class="source-inline">httpbin</strong> Pod as described <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Chapter09/01-httpbin-deployment.yaml</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
kubectl apply -f Chapter09/01-httpbin-deployment.yaml
curl -H "Host:httpbin.org" http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/get</pre>
			<p>Carefully check all the response fields containing all the headers passed in <span class="No-Break">the request.</span></p>
			<p>Using <strong class="source-inline">EnvoyFilter</strong>, we will add a custom header to the request before sending it to the <strong class="source-inline">httpbin</strong> Pod. For this example, let’s pick the <strong class="source-inline">ChapterName</strong> header name and set its value to <strong class="source-inline">ExtendingIstioDataPlane</strong>. The configuration in <strong class="source-inline">Chapter09/02-httpbinenvoyfilter-httpbin.yaml</strong> adds the custom header to <span class="No-Break">the request.</span></p>
			<p>Apply the following configuration <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">EnvoyFilter</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ kubectl apply -f Chapter09/02-httpbinenvoyfilter-httpbin.yaml
envoyfilter.networking.istio.io/updateheaderhorhttpbin configured</pre>
			<p>Let’s go through <strong class="source-inline">Chapter09/02-httpbinenvoyfilter-httpbin.yaml</strong> in <span class="No-Break">two parts:</span></p>
			<pre class="source-code">
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: updateheaderforhttpbin
  namespace: chapter09
spec:
  workloadSelector:
    labels:
      app: httpbin
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        portNumber: 80
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
            subFilter:
              name: "envoy.filters.http.router"</pre>
			<p>In this part, we<a id="_idIndexMarker770"/> will create<a id="_idIndexMarker771"/> an EnvoyFilter named <strong class="source-inline">updateheaderforhttpbin</strong> in the <strong class="source-inline">chapter09</strong> namespace, which will be applied to the workload which has the <strong class="source-inline">app</strong> label with a <strong class="source-inline">httpbin</strong> value. For that configuration, we are applying a configuration patch to all inbound traffic to the Istio sidecar aka istio-proxy aka Envoy for port <strong class="source-inline">80</strong> of the <strong class="source-inline">httpbin</strong> Pod. The configuration patch is applied to <strong class="source-inline">HTTP_FILTER</strong> and, in particular, to the HTTP router filter of the <strong class="source-inline">http_connection_manager</strong> <span class="No-Break">network filter.</span></p>
			<p>In the next part of the EnvoyFilter configuration, we apply configuration before the existing route configuration and, in particular, we are appending a Lua filter with inline code as specified in the <strong class="source-inline">inlineCode</strong> section. The Lua code runs during the <strong class="source-inline">envoy_on_request</strong> phase<a id="_idIndexMarker772"/> and adds a request<a id="_idIndexMarker773"/> header with the <strong class="source-inline">X-ChapterName</strong> name and the <span class="No-Break"><strong class="source-inline">ExtendingIstioDataPlane</strong></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
 patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.lua
        typed_config:
          "@type": "type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua"
          inlineCode: |
            function envoy_on_request(request_handle)
              request_handle:logInfo(" ========= XXXXX ==========");
              request_handle:headers():add("X-ChapterName", "ExtendingIstioDataPlane");
            end</pre>
			<p>Now, go ahead and test the endpoint using the <span class="No-Break">following command:</span></p>
			<pre class="console">
% curl -H "Host:httpbin.org" http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/get</pre>
			<p>You will receive the added headers in <span class="No-Break">the response.</span></p>
			<p>You can see the final Envoy config applied using the following commands. To find the exact name of the <strong class="source-inline">httpbin</strong> Pod, you can make use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">proxy-status</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
% istioctl proxy-status | grep httpbin
httpbin-7bffdcffd-l52sh.chapter09
Kubernetes     SYNCED     SYNCED     SYNCED     SYNCED      NOT SENT     istiod-56fd889679-ltxg5     1.14.3</pre>
			<p>This is followed by the <strong class="source-inline">proxy-config</strong> details <span class="No-Break">for listeners:</span></p>
			<pre class="console">
% istioctl proxy-config listener httpbin-7bffdcffd-l52sh.chapter09  -o json</pre>
			<p>In the output, look for <strong class="source-inline">envoy.lua</strong>, which is the name<a id="_idIndexMarker774"/> of the patch and the filter<a id="_idIndexMarker775"/> we applied via the config. In the output, look for <strong class="source-inline">filterChainMatch</strong> and for <strong class="source-inline">destinationPort</strong> set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">80</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
"filterChainMatch": {
                    "destinationPort": 80,
                    "transportProtocol": "raw_buffer"
                },</pre>
			<p>We applied the config <span class="No-Break">via EnvoyFilter:</span></p>
			<pre class="source-code">
  {
                                    "name": "envoy.lua",
                                    "typedConfig": {
                                        "@type": "type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua",
                                        "inlineCode": "function envoy_on_request(request_handle)\n  request_handle:logInfo(\" ========= XXXXX ==========\");\n  request_handle:headers():add(\"X-ChapterName\", \"ExtendingIstioDataPlane\");\nend \n"
                                    }
                                }</pre>
			<p>Hopefully, that gave you an idea of EnvoyFilter and how the overall mechanism works. In the hands-on exercise for this chapter, another example applies the same changes but at the Ingress gateway level. You can find the example at <strong class="source-inline">Chapter09/03-httpbinenvoyfilter-httpbiningress.yaml</strong>. Make sure that you delete the <strong class="source-inline">Chapter09/02-httpbinenvoyfilter-httpbin.yaml</strong> file before applying the Ingress <span class="No-Break">gateway changes.</span></p>
			<p>For more details<a id="_idIndexMarker776"/> about the various configurations<a id="_idIndexMarker777"/> of EnvoyFilter, please refer<a id="_idIndexMarker778"/> to the Istio documentation <span class="No-Break">at </span><a href="https://istio.io/latest/docs/reference/config/networking/envoy-filter/#EnvoyFilter-EnvoyConfigObjectPatch"><span class="No-Break">https://istio.io/latest/docs/reference/config/networking/envoy-filter/#EnvoyFilter-EnvoyConfigObjectPatch</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">For cleanup, use this command: <strong class="source-inline">kubectl delete </strong><span class="No-Break"><strong class="source-inline">ns chapter09</strong></span><span class="No-Break">.</span></p>
			<p>In the next section, we will read about Wasm fundamentals, followed by how to use Wasm to extend the Istio <span class="No-Break">data plane.</span></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Understanding the fundamentals of Wasm</h1>
			<p>Wasm is a portable<a id="_idIndexMarker779"/> binary format designed to run on <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>), allowing it to run on various computer<a id="_idIndexMarker780"/> hardware and digital devices, and is very actively used to improve the performance<a id="_idIndexMarker781"/> of web applications. It is a virtual <strong class="bold">instruction set architecture</strong> (<strong class="bold">ISA</strong>) for a stack machine designed to be portable, compact, and secure with a smaller binary file size to reduce download times when executed on web browsers. A modern browser’s JavaScript engines can parse and download the Wasm binary format in order of magnitude faster than JavaScript. All major browser vendors have adopted Wasm, and as per the Mozilla Foundation, Wasm code runs between 10% and 800% faster than the equivalent JavaScript code. It provides faster startup time and higher peak performance without <span class="No-Break">memory bloat.</span></p>
			<p>Wasm is also a preferred and practical<a id="_idIndexMarker782"/> choice for building extensions for Envoy for the <span class="No-Break">following reasons:</span></p>
			<ul>
				<li>Wasm extensions can be delivered at runtime without needing to restart istio-proxy. Furthermore, the extension can be loaded to istio-proxy through various means without needing any changes to istio-proxy. This allows the delivery of changes to the extension and changes to proxy behavior in the form of extensions without <span class="No-Break">any outages.</span></li>
				<li>Isolated from<a id="_idIndexMarker783"/> the host and executed in a sandbox/VM environment, Wasm communicates with the host machine via an <strong class="bold">application binary interface</strong> (<strong class="bold">ABI</strong>). Through ABIs, we can control what can and cannot be modified and what is visible to <span class="No-Break">the extension.</span></li>
				<li>Another benefit of running Wasm in a sandbox<a id="_idIndexMarker784"/> environment is the isolation and defined fault boundaries. If anything goes wrong with Wasm execution, then the scope of disruption is limited to the sandbox and won’t spread to the <span class="No-Break">host process.</span></li>
			</ul>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B17989_09_01.jpg" alt="Figure 9.1 – An overview of Wasm"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – An overview of Wasm</p>
			<p>There are over thirty programming<a id="_idIndexMarker785"/> languages that support compilation to Wasm modules. Some examples are C, Java, Go, Rust, C++, and TypeScript. This allows most developers to build Istio extensions using the programming language of <span class="No-Break">their choice.</span></p>
			<p>To get familiar with Wasm, we will build a sample application using Go. The source code is available in the <span class="No-Break"><strong class="source-inline">Chapter09/go-Wasm-example</strong></span><span class="No-Break"> folder.</span></p>
			<p>The problem statement<a id="_idIndexMarker786"/> is to build an HTML page that takes a string in lowercase and provides the output in uppercase. We assume that you have some experience working with Go and that it is installed in your hands-on environment. If you don’t want to use Go, then try implementing the example using the language of <span class="No-Break">your choice:</span></p>
			<ol>
				<li>Copy the code from <strong class="source-inline">Chapter09/go-Wasm-example</strong> and reinitialize the <span class="No-Break">Go module:</span><pre class="console">
<strong class="bold">% go mod init Bootstrap-Service-Mesh-Implementations-with-Istio/Chapter09/go-Wasm-example</strong>
<strong class="bold">% go mod tidy</strong></pre></li>
			</ol>
			<p>First, let’s <span class="No-Break">check </span><span class="No-Break"><strong class="source-inline">Chapter09/go-Wasm-example/cmd/Wasm/main.go</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
package main
import (
    "strings"
    "syscall/js"
)
func main() {
    done := make(chan struct{}, 0)
    js.Global().Set("WasmHash", js.FuncOf(convertToUpper))
    &lt;-done
}
func convertToUpper(this js.Value, args []js.Value) interface{} {
    strings.ToUpper(args[0].String())
    return strings.ToUpper(args[0].String())
}</pre>
			<p><strong class="source-inline">done := make(chan struct{}, 0)</strong> and <strong class="source-inline">&lt;-done</strong> is a Go channel. A Go channel is used for communication between <span class="No-Break">concurrent functions.</span></p>
			<p><strong class="source-inline">js.Global().Set("WasmHash", hash)</strong> exposes the Go hash function <span class="No-Break">to JavaScript.</span></p>
			<p>The <strong class="source-inline">convertToUpper</strong> function takes a string as an argument, which is then typecasted using the <strong class="source-inline">.String()</strong> function from the <strong class="source-inline">syscall/js</strong> package. The <strong class="source-inline">strings.ToUpper(args[0].String())</strong> line converts all arguments provided by JavaScript into an uppercase string and returns it as output of <span class="No-Break">the function.</span></p>
			<ol>
				<li value="2">The next step<a id="_idIndexMarker787"/> is to compile <strong class="source-inline">Chapter09/go-Wasm-example/cmd/Wasm/main.go</strong> using the <span class="No-Break">following command:</span><pre class="console">
<strong class="bold">% GOOS=js GOARCH=Wasm go build -o static/main.Wasm cmd/Wasm/main.go</strong></pre></li>
			</ol>
			<p>The secret recipe here is <strong class="source-inline">GOOS=js GOARCH=Wasm</strong>, which tells the Go compiler to compile for JavaScript as the target host and Wasm as the target architecture. Without this, the Go compiler will compile for the target OS and architecture as per your workstation specifications. You can find more about the possible values of <strong class="source-inline">GOOS</strong> and <strong class="source-inline">GOARCH</strong> <span class="No-Break">at </span><a href="https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63"><span class="No-Break">https://gist.github.com/asukakenji/f15ba7e588ac42795f421b48b8aede63</span></a><span class="No-Break">.</span></p>
			<p>The command will then produce the Wasm file with the <strong class="source-inline">main.Wasm</strong> name in the <span class="No-Break">static folder.</span></p>
			<ol>
				<li value="3">We also need to fetch and execute Wasm in the browser. Luckily, Go makes that possible <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Wasm_exec.js</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>The JavaScript file can be found in the <strong class="source-inline">GOROOT</strong> folder. To copy it to the static directory, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
<strong class="bold">% cp "$(go env GOROOT)/misc/Wasm/Wasm_exec.js" ./static</strong></pre>
			<ol>
				<li value="4">We have Wasm and JavaScript<a id="_idIndexMarker788"/> to load and execute Wasm in the browser. We need to create an HTML page and then load JavaScript from there. You will find the sample HTML page at <strong class="source-inline">Chapter09/go-Wasm-example/static/index.html</strong>. You will find the following snippet in the HTML to load JavaScript and <span class="No-Break">instantiate Wasm:</span><pre class="console">
&lt;script src="Wasm_exec.js"&gt;&lt;/script&gt;
&lt;script&gt;
    const go = new Go();
    WebAssembly.instantiateStreaming(fetch("main.Wasm"), go.importObject).then((result) =&gt; {
        go.run(result.instance);
    });
&lt;/script&gt;</pre></li>
				<li>As the last step, we need a web server. You can use <strong class="source-inline">nginx</strong> or a sample HTTP server package with the sample code at <strong class="source-inline">Chapter09/go-Wasm-example/cmd/webserver/main.go</strong>. Run the server using the <span class="No-Break">following command:</span><pre class="console">
<strong class="bold">% go run ./cmd/webserver/main.go</strong>
<strong class="bold">Listening on http://localhost:3000/index.html</strong></pre></li>
				<li>Open <a href="http://localhost:3000/index.html">http://localhost:3000/index.html</a> in a browser and test that whatever lowercase letters you type in the text box are converted <span class="No-Break">to uppercase:</span></li>
			</ol>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B17989_09_02.jpg" alt="Figure 9.2 – ﻿Go used to create Wasm"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Go used to create Wasm</p>
			<p>This concludes<a id="_idIndexMarker789"/> the introduction to Wasm, and I hope you have acquired a basic understanding of Wasm after reading this section. In the next section, we will learn about how Wasm helps to extend the Istio <span class="No-Break">data plane.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Extending the Istio data plane using Wasm</h1>
			<p>The main goal for Wasm was to enable<a id="_idIndexMarker790"/> high-performance applications<a id="_idIndexMarker791"/> on web pages, and hence Wasm was originally designed for execution<a id="_idIndexMarker792"/> in web browsers. There is a <strong class="bold">World Wide Web Consortium</strong> (<strong class="bold">W3C</strong>) working group for Wasm, whose<a id="_idIndexMarker793"/> details are available at <a href="https://www.w3.org/Wasm/">https://www.w3.org/Wasm/</a>. The working group manages<a id="_idIndexMarker794"/> the Wasm specification available at <a href="https://www.w3.org/TR/Wasm-core-1/">https://www.w3.org/TR/Wasm-core-1/</a> and <a href="https://www.w3.org/TR/Wasm-core-2/">https://www.w3.org/TR/Wasm-core-2/</a>. Most internet browsers have implemented the specification, and you can find details for Google Chrome at <a href="https://chromestatus.com/feature/5453022515691520">https://chromestatus.com/feature/5453022515691520</a>. Mozilla Foundation also maintains browser compatibility at <a href="https://developer.mozilla.org/en-US/docs/WebAssembly#browser_compatibility">https://developer.mozilla.org/en-US/docs/WebAssembly#browser_compatibility</a>. When it comes to supporting the execution of Wasm on layer 4 and 7 proxies, most of the effort is recent. When executing Wasm on proxies, we need a way to communicate with the host environment. Similar to how web browsers are developed, Wasm should be written once, after which it should be able to run on <span class="No-Break">any proxy.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Introducing Proxy-Wasm</h2>
			<p>For Wasm to communicate<a id="_idIndexMarker795"/> with the host environment and the development of Wasm to be agnostic of the underlying host <a id="_idIndexMarker796"/>environment, there is a <strong class="source-inline">Proxy-Wasm</strong> specification, also known as Wasm for proxies. The specification is made up of <strong class="source-inline">Proxy-Wasm</strong> ABIs, which are low-level. The specification<a id="_idIndexMarker797"/> is then abstracted in high-level languages, called <strong class="source-inline">Proxy-Wasm</strong> <strong class="bold">software development kits</strong> (<strong class="bold">SDKs</strong>), which are developer friendly and easy to understand and integrate with high-level language implementations. Every proxy also then implements a <strong class="source-inline">Proxy-Wasm</strong> ABI specification in the form of the <span class="No-Break"><strong class="source-inline">Proxy-Wasm</strong></span><span class="No-Break"> modules.</span></p>
			<p>The concepts of <strong class="source-inline">Proxy-Wasm</strong> can be difficult to understand. To make it easy to digest them, let’s break them down into the following sections and go through them one <span class="No-Break">by one.</span></p>
			<h3>Proxy-Wasm ABI</h3>
			<p>ABI is a low-level<a id="_idIndexMarker798"/> interface specification that describes how Wasm communicates with the VM and host. The specification details are available at <a href="https://github.com/proxy-Wasm/spec/blob/master/abi-versions/vNEXT/README.md">https://github.com/proxy-Wasm/spec/blob/master/abi-versions/vNEXT/README.md</a>, and the specification itself is available at <a href="https://github.com/proxy-Wasm/spec">https://github.com/proxy-Wasm/spec</a>. To understand the API, it is best to go through some of the most commonly used methods of the ABI specification to appreciate what <span class="No-Break">it does:</span></p>
			<ul>
				<li><strong class="source-inline">_start</strong>: This function needs to be implemented on Wasm and will be called when Wasm is loaded <span class="No-Break">and initialized.</span></li>
				<li><strong class="source-inline">proxy_on_vm_start</strong>: This is called when the host machine starts the Wasm VM. Wasm can use this method to retrieve any configuration details of <span class="No-Break">the VM.</span></li>
				<li><strong class="source-inline">proxy_on_configure</strong>: This is called when the host environment starts the plugin, which loads Wasm. Using this method, Wasm can retrieve any <span class="No-Break">plugin-related configuration.</span></li>
				<li><strong class="source-inline">proxy_on_new_connection</strong>: This is a level 4 extension that is called when a TCP connection is established between the proxy and <span class="No-Break">the client.</span></li>
				<li><strong class="source-inline">proxy_on_downstream_data</strong>: This is a level 4 extension that is called for each data chunk received from <span class="No-Break">the client.</span></li>
				<li><strong class="source-inline">proxy_on_downstream_close</strong>: This is a level 4 extension that is called when the connection with downstream <span class="No-Break">is closed.</span></li>
				<li><strong class="source-inline">proxy_on_upstream_data</strong>: This is a level 4 extension that is called for each data chunk received <span class="No-Break">from upstream.</span></li>
				<li><strong class="source-inline">proxy_on_upstream_close</strong>: This is a level 4 extension that is called when the connection with upstream <span class="No-Break">is closed.</span></li>
				<li><strong class="source-inline">proxy_on_http_request_headers</strong>: This is a level 7 extension that is called when HTTP request headers are received from <span class="No-Break">the client.</span></li>
				<li><strong class="source-inline">proxy_on_http_request_body</strong>: This is a level 7 extension that is called when the HTTP request body is received from <span class="No-Break">the client.</span></li>
				<li><strong class="source-inline">proxy_on_http_response_headers</strong>: This is a level 7 extension that is called when HTTP response headers are received <span class="No-Break">from upstream.</span></li>
				<li><strong class="source-inline">proxy_on_http_response_body</strong>: This is a level 7 extension that is called when the HTTP response body is received <span class="No-Break">from upstream.</span></li>
				<li><strong class="source-inline">proxy_send_http_response</strong>: This is also a level 7 extension that is implemented in the host environment, Envoy. Using this method, Wasm can instruct Envoy to send an HTTP response without actually calling the <span class="No-Break">upstream services.</span></li>
			</ul>
			<p>This list doesn’t cover all methods in the ABI, but we hope it gave you a good understanding of what the ABI is used for. The following diagram illustrates what we covered in <span class="No-Break">this section:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B17989_09_03.jpg" alt="Figure 9.3 – Proxy-wasm ABI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Proxy-wasm ABI</p>
			<p>If we analyze this diagram in the context of Envoy, we arrive at the <span class="No-Break">following interpretation:</span></p>
			<ul>
				<li>Native extensions execute in the order specified in <span class="No-Break">the configuration.</span></li>
				<li>There is also a native<a id="_idIndexMarker799"/> extension in Envoy for loading Wasm, specified at <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/Wasm/v3/Wasm.proto">https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/Wasm/v3/Wasm.proto</a>. The extension is responsible for loading and asking Envoy to <span class="No-Break">execute Wasm.</span></li>
				<li>Envoy executes Wasm on <span class="No-Break">a VM.</span></li>
				<li>During execution, Wasm can interact with the request, VM, and Envoy via the <strong class="source-inline">Proxy-Wasm</strong> ABI, and we saw some of those interaction points earlier in <span class="No-Break">the section.</span></li>
				<li>Once Wasm completes execution, the execution flows back to other native extensions defined in the <span class="No-Break">configuration file.</span></li>
			</ul>
			<p>While ABIs are elaborate, they are also<a id="_idIndexMarker800"/> very low-level and not programmer-friendly, who usually prefer writing code in high-level programming languages. In the following section, we will read about how the Proxy-Wasm SDK can solve <span class="No-Break">this problem.</span></p>
			<h3>Proxy-Wasm SDK</h3>
			<p>Proxy-Wasm SDK is a higher-level<a id="_idIndexMarker801"/> abstraction of the Proxy-Wasm ABI and is implemented in various programming languages. Proxy-Wasm SDK complies with the ABI so that when creating Wasm, you don’t need to know about the Proxy-Wasm ABI. At the time of writing this chapter, there are SDKs of the Proxy-Wasm API in Go with TinyGo compiler, Rust, C++, and AssemblyScript. Similar to what we did for ABIs, we will pick SDKs for one of the languages and go through it to understand the correlation between the ABI and the SDK. So, let’s go through some of the functions in the Proxy-Wasm Go SDK to get a feel of them; the SDK is available <span class="No-Break">at </span><a href="https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK/proxyWasm"><span class="No-Break">https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK/proxyWasm</span></a><span class="No-Break">.</span></p>
			<p>First, you need to understand the various types defined in the SDK, so we have provided the following list of the <span class="No-Break">fundamental ones:</span></p>
			<ul>
				<li><strong class="source-inline">VMContext</strong>: This corresponds to each Wasm VM. For every Wasm VM, there is one and only one <strong class="source-inline">VMContext</strong>. <strong class="source-inline">VMContext</strong> has the <span class="No-Break">following methods:</span><ul><li><strong class="source-inline">OnVMStart(vmConfigurationSize int) OnVMStartStatus</strong>: This method is called when the VM is created. From within this method, Wasm can retrieve the <span class="No-Break">VM configuration.</span></li><li><strong class="source-inline">NewPluginContext(contextID uint32) PluginContext</strong>: This creates a plugin context for each <span class="No-Break">plugin configuration.</span></li></ul></li>
				<li><strong class="source-inline">PluginContext</strong>: This corresponds to each plugin configuration in the host. Plugins are configured at HTTP or network filters for listeners. Some of the methods in <strong class="source-inline">PluginContext</strong> are <span class="No-Break">as follows:</span><ul><li><strong class="source-inline">OnPluginStart(pluginConfigurationSize int) OnPluginStartStatus</strong>: This is called for all plugins configured. Once the VM has been created, Wasm can retrieve the plugin configuration using <span class="No-Break">this method.</span></li><li><strong class="source-inline">OnPluginDone() bool</strong>: This is called when the host deletes <strong class="source-inline">PluginContext</strong>. If this method returns <strong class="source-inline">true</strong>, it signals to the host that <strong class="source-inline">PluginContext</strong> can be deleted, and <strong class="source-inline">false</strong> means that the plugin is in a pending state and cannot yet <span class="No-Break">be deleted.</span></li><li><strong class="source-inline">NewTcpContext(contextID uint32) TcpContext</strong>: This method creates <strong class="source-inline">TCPContext</strong>, corresponding to every <span class="No-Break">TCP request.</span></li><li><strong class="source-inline">NewHttpContext(contextID uint32) HttpContext</strong>: This method creates <strong class="source-inline">HTTPContext</strong>, corresponding to every <span class="No-Break">HTTP request.</span></li></ul></li>
				<li><strong class="source-inline">HTTPContext</strong>: This method is created by <strong class="source-inline">PluginContext</strong> for every HTTP stream. The following are some of the methods available in <span class="No-Break">this interface:</span><ul><li><strong class="source-inline">OnHttpRequestHeaders(numHeaders int, endOfStream bool) Action</strong>: This method provides access to HTTP headers as part of the <span class="No-Break">request stream.</span></li><li><strong class="source-inline">OnHttpRequestBody(bodySize int, endOfStream bool) Action</strong>: This method provides access to data frames of the request body. It is called multiple times for every individual data frame in the <span class="No-Break">request body.</span></li><li><strong class="source-inline">OnHttpResponseHeaders(numHeaders int, endOfStream bool) Action</strong>: This method provides access to <span class="No-Break">response headers.</span></li><li><strong class="source-inline">OnHttpResponseBody(bodySize int, endOfStream bool) Action</strong>: This method provides access to response <span class="No-Break">body frames.</span></li><li><strong class="source-inline">OnHttpStreamDone()</strong>: This method is called before the deletion of <strong class="source-inline">HTTPContext</strong>. From this method, Wasm can access all information about the request and response phases of the <span class="No-Break">HTTP connection.</span></li></ul></li>
			</ul>
			<p>Among other types <a id="_idIndexMarker802"/>to read about is <strong class="source-inline">TCPContext</strong>. We have not covered all methods and types available in the SDK; you can find the complete list along with details <span class="No-Break">at </span><a href="https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK@v0.20.0/proxyWasm/types#pkg-types"><span class="No-Break">https://pkg.go.dev/github.com/tetratelabs/proxy-Wasm-go-SDK@v0.20.0/proxyWasm/types#pkg-types</span></a><span class="No-Break">.</span></p>
			<p>With this overview in mind, let’s write a Wasm to inject a custom header in the response of the <strong class="source-inline">envoydummy</strong> Pod. Please note that in the <em class="italic">Customizing the data plane using the Envoy filter</em> section, we used EnvoyFilter to patch Istio and applied a Lua filter with inline code to inject headers to requests bound for the <span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break"> Pod.</span></p>
			<p>Create the <strong class="source-inline">chapter09-temp</strong> namespace with <span class="No-Break"><strong class="source-inline">istio-injection</strong></span><span class="No-Break"> disabled:</span></p>
			<pre class="console">
% kubectl create ns chapter09-temp
namespace/chapter09-temp created</pre>
			<p>Run <strong class="source-inline">envoydummy</strong> to check that it is working <span class="No-Break">as expected:</span></p>
			<pre class="console">
% kubectl apply -f Chapter09/01-envoy-dummy.yaml
namespace/chapter09-temp created
service/envoydummy created
configmap/envoy-dummy-2 created
deployment.apps/envoydummy-2 created</pre>
			<p>Forward the ports so that you can <span class="No-Break">test locally:</span></p>
			<pre class="console">
% kubectl port-forward svc/envoydummy 18000:80 -n chapter09-t
emp
Forwarding from 127.0.0.1:18000 -&gt; 10000</pre>
			<p>Then, test <span class="No-Break">the endpoint:</span></p>
			<pre class="console">
% curl  localhost:18000
V2----------Bootstrap Service Mesh Implementation with Istio----------V2%</pre>
			<p>So, we have verified that <strong class="source-inline">envoydummy</strong> is working. The next<a id="_idIndexMarker803"/> step is to create Wasm to inject headers into the response. You will find the source code <span class="No-Break">at </span><a href="http://Chapter09/go_Wasm_example_for_envoy"><span class="No-Break">Chapter09/go_Wasm_example_for_envoy</span></a><span class="No-Break">.</span></p>
			<p>There is only one <strong class="source-inline">main.go</strong> file in the Go module, and the following are the key parts of <span class="No-Break">the code:</span></p>
			<p>The entry point in the Go module is the <strong class="source-inline">main</strong> method. In the <strong class="source-inline">main</strong> method, we are setting up the Wasm VM by calling <strong class="source-inline">SetVMContext</strong>. The method is described in the <strong class="source-inline">Entrypoint.go</strong> file at <a href="https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/proxywasm">https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/proxywasm</a>. The following code snippet shows the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func main() {
    proxyWasm.SetVMContext(&amp;vmContext{})
}</pre>
			<p>The following method injects a header into the <span class="No-Break">response headers:</span></p>
			<pre class="source-code">
func (ctx *httpHeaders) OnHttpResponseHeaders(numHeaders int, endOfStream bool) types.Action {
    if err := proxyWasm.AddHttpResponseHeader("X-ChapterName", "ExtendingEnvoy"); err != nil {
        proxyWasm.LogCritical("failed to set response header: X-ChapterName")
    }
    return types.ActionContinue
}</pre>
			<p>Also, notice <strong class="source-inline">AddHttpResponseHeader</strong>, which is defined <span class="No-Break">at </span><a href="https://github.com/tetratelabs/proxy-Wasm-go-SDK/blob/v0.20.0/proxyWasm/hostcall.go#L395"><span class="No-Break">https://github.com/tetratelabs/proxy-Wasm-go-SDK/blob/v0.20.0/proxyWasm/hostcall.go#L395</span></a><span class="No-Break">.</span></p>
			<p>The next step<a id="_idIndexMarker804"/> is to compile the Go module for Wasm, for which we will need to use TinyGo. Please note that we cannot use the standard Go compiler due to a lack of support for the Proxy-Wasm <span class="No-Break">Go SDK.</span></p>
			<p>Install TinyGo<a id="_idIndexMarker805"/> for your host OS by following the instructions <span class="No-Break">at </span><a href="https://tinygo.org/getting-started/install/macos/"><span class="No-Break">https://tinygo.org/getting-started/install/macos/</span></a><span class="No-Break">.</span></p>
			<p>Using TinyGo, compile the Go module with Wasm using the <span class="No-Break">following command:</span></p>
			<pre class="console">
% tinygo build -o main.Wasm -scheduler=none -target=wasi main.go</pre>
			<p>Once the Wasm file is created, we need to load the Wasm file <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">configmap</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
% kubectl create configmap 01-Wasm --from-file=main.Wasm -n chapter09-temp
configmap/01-Wasm created</pre>
			<p>Modify the <strong class="source-inline">envoy.yaml</strong> file to apply Wasm filters and load Wasm <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">configmap</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
http_filters:
              - name: envoy.filters.http.Wasm
                typed_config:
                  "@type": type.googleapis.com/udpa.type.v1.TypedStruct
                  type_url: type.googleapis.com/envoy.extensions.filters.http.Wasm.v3.Wasm
                  value:
                    config:
                      vm_config:
                        runtime: "envoy.Wasm.runtime.v8"
                        code:
                          local:
                            filename: "/Wasm2/main.Wasm"
              - name: envoy.filters.http.router
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router</pre>
			<p>We specify <strong class="source-inline">envoy</strong> in the config<a id="_idIndexMarker806"/> to use the <strong class="source-inline">v8</strong> runtime for running Wasm. The changes are also available at <strong class="source-inline">Chapter09/02-envoy-dummy.yaml</strong>. Apply the changes, as <span class="No-Break">shown here:</span></p>
			<pre class="console">
% kubectl apply -f Chapter09/02-envoy-dummy.yaml
service/envoydummy created
configmap/envoy-dummy-2 created
deployment.apps/envoydummy-2 created</pre>
			<p>Forward the port <strong class="source-inline">80</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">18000</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
% kubectl port-forward svc/envoydummy 18000:80 -n chapter09-temp</pre>
			<p>Test the endpoint to check whether Wasm injected the <span class="No-Break">response header:</span></p>
			<pre class="console">
% curl -v localhost:18000
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 200 OK
&lt; content-length: 72
&lt; content-type: text/plain
&lt; x-chaptername: ExtendingEnvoy
* Connection #0 to host localhost left intact
V2----------Bootstrap Service Mesh Implementation with Istio----------V2%</pre>
			<p>Hopefully, this section<a id="_idIndexMarker807"/> gave you confidence on how to create Wasm that is compliant with Proxy-Wasm and how to apply it to Envoy. We suggest you do more hands-on exercises by looking at examples available <span class="No-Break">at </span><a href="https://github.com/tetratelabs/proxy-Wasm-go-SDK/tree/main/examples"><span class="No-Break">https://github.com/tetratelabs/proxy-Wasm-go-SDK/tree/main/examples</span></a><span class="No-Break">.</span></p>
			<p>Before we conclude this section, let’s also check<a id="_idIndexMarker808"/> how Wasm is compliant with the Proxy-Wasm ABI. For that, we will install the <strong class="bold">Wasm Binary Toolkit</strong> (<strong class="bold">WABT</strong>) available at <a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a>. On MacOS, it is simple to install <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">brew</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
% brew install wabt</pre>
			<p>WABT provides various methods to manipulate and introspect Wasm. One such tool, <strong class="source-inline">Wasm-objdump</strong>, prints information about a Wasm binary. Using the following command, you can print a list of all functions that become accessible to the host environment once Wasm has <span class="No-Break">been instantiated:</span></p>
			<pre class="console">
% Wasm-objdump main.Wasm --section=export -x.</pre>
			<p>You will notice the output is a list of functions that are defined in the <span class="No-Break">Proxy-Wasm ABI.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">To do the cleanup, you can use the <span class="No-Break">following command:</span></p>
			<pre class="console">
<strong class="source-inline">% kubectl delete ns chapter09-temp</strong></pre>
			<p>That completes the section on Proxy-Wasm, and we hope you now understand how to create Proxy-Wasm-compliant Wasm using<a id="_idIndexMarker809"/> the Go SDK. In the next section, we will deploy Wasm <span class="No-Break">in Istio.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Wasm with Istio</h2>
			<p>In this section, we will extend<a id="_idIndexMarker810"/> the Istio data plane using Wasm that we built in the previous<a id="_idIndexMarker811"/> section. We will be using Istio’s <strong class="bold">WasmPlugin API</strong>, and we will go into the details<a id="_idIndexMarker812"/> of this plugin once we have configured it for the <span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break"> application:</span></p>
			<ol>
				<li value="1">The first step is to upload <strong class="source-inline">main.Wasm</strong> created in the Go module available at <strong class="source-inline">Chapter09/go_Wasm_example_for_envoy</strong> to an HTTPS location. You can make use of AWS S3 or something<a id="_idIndexMarker813"/> similar for that purpose; another option is to use an OCI registry such as <strong class="bold">Docker Hub</strong>. To complete this exercise, I uploaded <strong class="source-inline">main.Wasm</strong> to AWS S3. The HTTPS location of the S3 bucket hosting the file is <strong class="source-inline">https://anand-temp.s3.amazonaws.com/main.Wasm</strong>. Please note that for security reasons, the link might not be accessible to you while reading this book, but I am sure you can manage to create your own S3 buckets or <span class="No-Break">Docker registry.</span></li>
				<li>The second step is to deploy the <strong class="source-inline">httpbin</strong> application, which is already available <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">Chapter09/01-httpbin-deployment.yaml</strong></span><span class="No-Break">:</span><pre class="console">
<strong class="bold">% kubectl apply -f Chapter09/01-httpbin-deployment.yaml</strong></pre></li>
			</ol>
			<p>Check the response of the following commands and observe the headers added during <span class="No-Break">the request:</span></p>
			<pre class="console">
<strong class="bold">% curl -H "Host:httpbin.org" http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/get</strong></pre>
			<ol>
				<li value="3">After this, we will apply the following changes <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">WasmPlugin</strong></span><span class="No-Break">:</span><pre class="console">
apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: addheaders
  namespace: chapter09
spec:
  selector:
    matchLabels:
      app: httpbin
  url: https://anand-temp.s3.amazonaws.com/main.Wasm
  imagePullPolicy: Always
  phase: AUTHZ</pre></li>
			</ol>
			<p>Apply <strong class="source-inline">WasmPlugin</strong> using the <span class="No-Break">following command:</span></p>
			<pre class="console">
<strong class="bold">% kubectl apply -f Chapter09/01-Wasmplugin.yaml</strong>
<strong class="bold">Wasmplugin.extensions.istio.io/addheaders configured</strong></pre>
			<p>We will read<a id="_idIndexMarker814"/> more about <strong class="source-inline">WasmPlugin</strong> after <em class="italic">step 5</em>. For now, let’s check<a id="_idIndexMarker815"/> the response headers <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
<strong class="bold">% curl --head -H "Host:httpbin.org" http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/get</strong></pre>
			<p>You will notice that, as expected, we have <strong class="source-inline">x-chaptername: ExtendingEnvoy</strong> in <span class="No-Break">the response.</span></p>
			<ol>
				<li value="4">Let’s create another Wasm to add a custom header to <strong class="source-inline">request</strong> so that we can see it in the response of the <strong class="source-inline">httpbin</strong> payload. There is a Wasm already created in <strong class="source-inline">Chapter09/go_Wasm_example_for_istio</strong> for this purpose. Notice the <strong class="source-inline">OnHTTPRequestHeaders</strong> function <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="console">
func (ctx *httpHeaders) OnHttpRequestHeaders(numHeaders int, endOfStream bool) types.Action {
    if err := proxyWasm.AddHttpRequestHeader("X-Chapter", "Chapter09"); err != nil {
        proxyWasm.LogCritical("failed to set request header: X-ChapterName")
    }
    proxyWasm.LogInfof("added custom header to request")
    return types.ActionContinue
}</pre></li>
			</ol>
			<p>Compile that into Wasm and copy<a id="_idIndexMarker816"/> it to the S3 location. There<a id="_idIndexMarker817"/> is also another Istio config file available at <strong class="source-inline">Chapter09/02-Wasmplugin.yaml</strong>, which deploys <span class="No-Break">this Wasm:</span></p>
			<pre class="console">
apiVersion: extensions.istio.io/v1alpha1
kind: <strong class="bold">WasmPlugin</strong>
metadata:
  name: addheaderstorequest
  namespace: chapter09
spec:
  selector:
    matchLabels:
      app: httpbin
  url: https://anand-temp.s3.amazonaws.com/AddRequestHeader.Wasm
  imagePullPolicy: Always
  phase: AUTHZ</pre>
			<ol>
				<li value="5">After applying<a id="_idIndexMarker818"/> the changes, test<a id="_idIndexMarker819"/> the endpoints, and you will find that both Wasm have executed, adding a header in the response as well as one in the request, which is reflected in the <strong class="source-inline">httpbin</strong> response. The following is a shortened version of <span class="No-Break">the response:</span><pre class="console">
<strong class="bold">% curl -v -H "Host:httpbin.org" http://a816bb2638a5e4a8c990ce790b47d429-1565783620.us-east-1.elb.amazonaws.com/get</strong>
<strong class="bold">&lt; HTTP/1.1 200 OK</strong>
<strong class="bold">……</strong>
<strong class="bold">&lt; x-chaptername: ExtendingEnvoy</strong>
<strong class="bold">&lt;</strong>
<strong class="bold">{</strong>
<strong class="bold">  "args": {},</strong>
<strong class="bold">  "headers": {</strong>
<strong class="bold">    "Accept": "*/*",</strong>
<strong class="bold">    "Host": "httpbin.org",</strong>
<strong class="bold">    "User-Agent": "curl/7.79.1",</strong>
<strong class="bold">…..,</strong>
<strong class="bold">    "X-Chapter": "Chapter09",</strong>
<strong class="bold">…</strong>
<strong class="bold">  },</strong>
<strong class="bold">  "origin": "10.10.10.216",</strong>
<strong class="bold">  "url": "http://httpbin.org/get"</strong>
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>In <em class="italic">steps 3</em> and <em class="italic">4</em>, we used <strong class="source-inline">WasmPlugin</strong> to apply Wasm on the Istio data plane. The following are the parameters we configured <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">WasmPlugin</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">selector</strong>: Specify the resource<a id="_idIndexMarker820"/> on which the Wasm should be applied<a id="_idIndexMarker821"/> in the <strong class="source-inline">selector</strong> field. It can be the Istio gateway and Kubernetes Pods. You provide labels that must match the workload on whose Envoy sidecar the Wasm configuration will be applied. In the examples we implemented, we applied the <strong class="source-inline">app:httpbin</strong> label, which corresponds to the <span class="No-Break"><strong class="source-inline">httpbin</strong></span><span class="No-Break"> Pod.</span></li>
				<li><strong class="source-inline">url</strong>: This is the location where the Wasm file is available to download. We provided the HTTP location, but OCI locations are also supported. The default value is <strong class="source-inline">oci://</strong>, used for referencing OCI images. To reference file-based locations, use <strong class="source-inline">file://</strong>, which is used for referencing Wasm files present locally within the <span class="No-Break">proxy container.</span></li>
				<li><strong class="source-inline">imagePullPolicy</strong>: The possible values for this are <span class="No-Break">the following:</span><ul><li><strong class="source-inline">UNSPECIFIED_POLICY</strong>: This is the same as <strong class="source-inline">IfNotPresent</strong> unless the URL points to an OCI image with the latest tag. In that case, this field will default <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Always</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">Always</strong>: We will always pull the latest version of an image from the location specified in <span class="No-Break">the URL.</span></li><li><strong class="source-inline">IfNotPresent</strong>: Use this to pull Wasm only if the requested version is <span class="No-Break">unavailable locally.</span></li></ul></li>
				<li><strong class="source-inline">phase</strong>: The possible values for this are <span class="No-Break">the following:</span><ul><li><strong class="source-inline">UNSPECIFIED_PHASE</strong>: This means the Wasm filter will be inserted at the end of the <span class="No-Break">filter chain.</span></li><li><strong class="source-inline">AUTHN</strong>: This inserts the plugin before the Istio <span class="No-Break">authentication filters.</span></li><li><strong class="source-inline">AUTHZ</strong>: This inserts the plugin between the authentication and <span class="No-Break">authorization filters.</span></li><li><strong class="source-inline">STATS</strong>: This inserts the plugin after the authorization filter but before the <span class="No-Break">stats filter.</span></li></ul></li>
			</ul>
			<p>We have described the values we used in the example, but various fields can be configured in <strong class="source-inline">WasmPlugin</strong>; you can find the detailed list <span class="No-Break">at </span><a href="https://istio.io/latest/docs/reference/config/proxy_extensions/Wasm-plugin/#WasmPlugin"><span class="No-Break">https://istio.io/latest/docs/reference/config/proxy_extensions/Wasm-plugin/#WasmPlugin</span></a><span class="No-Break">.</span></p>
			<p>For production<a id="_idIndexMarker822"/> deployment, we definitely<a id="_idIndexMarker823"/> suggest you use the <strong class="source-inline">sha256</strong> field to ensure the integrity of the <span class="No-Break">Wasm modules.</span></p>
			<p>Istio provides<a id="_idIndexMarker824"/> a reliable, out-of-the-box distribution mechanism for Wasm by leveraging the xDS proxy inside istio-agent and Envoy’s <strong class="bold">Extension Configuration Discovery Service</strong> (<strong class="bold">ECDS</strong>). Details about ECDS<a id="_idIndexMarker825"/> are available <span class="No-Break">at </span><a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/extension"><span class="No-Break">https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/extension</span></a><span class="No-Break">.</span></p>
			<p>After applying <strong class="source-inline">WasmPlugin</strong>, you can check the <strong class="source-inline">istiod</strong> logs for <span class="No-Break">ECDS entries:</span></p>
			<pre class="console">
% kubectl logs istiod-56fd889679-ltxg5 -n istio-system</pre>
			<p>You will find log entries similar to <span class="No-Break">the following:</span></p>
			<pre class="console">
10-18T12:02:03.075545Z     info ads  ECDS: PUSH for node:httpbin-7bffdcffd-4zrhj.chapter09 resources:1 size:305B</pre>
			<p>Istio makes an ECDS call to istio-proxy about applying the <strong class="source-inline">WasmPlugin</strong>. The following diagram describes the process of applying Wasm via the <span class="No-Break">ECDS API:</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B17989_09_04.jpg" alt="Figure 9.4 – Distributing Wasm to the Istio data plane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Distributing Wasm to the Istio data plane</p>
			<p>The istio-agent deployed alongside Envoy intercepts the ECDS call from <strong class="source-inline">istiod</strong>. It then downloads the Wasm module, saves it locally, and updates the ECDS configuration with the path of the downloaded Wasm module. If the WASM modules are not accessible to Istio-agent, it will reject the ECDS<a id="_idIndexMarker826"/> update. You will be able<a id="_idIndexMarker827"/> to see ECDS update failure in the <span class="No-Break"><strong class="source-inline">istiod</strong></span><span class="No-Break"> logs.</span></p>
			<p>This concludes this section, and I hope it arms you with enough knowledge to start applying Wasm to your <span class="No-Break">production workload.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Summary</h1>
			<p>In this chapter, we read about Wasm and its use. We learned about how Wasm is used on the web due to its high performance, and we also familiarized ourselves with how to build Wasm using Go and use it from a web browser using JavaScript. Wasm is also becoming a popular choice on the server side, especially among network proxies such <span class="No-Break">as Envoy.</span></p>
			<p>To get a standardized interface for implementing Wasm for proxies, there are the Proxy-Wasm ABI specifications which are low-level specifications describing the interface between Wasm and the proxy hosting the Wasm. Wasm for Envoy needs to be Proxy-Wasm compliant, but the Proxy-Wasm ABIs are difficult to work with; the Proxy-Wasm SDKs are much easier to work with. At the time of writing this chapter, there are many programming languages in which Proxy-Wasm SDK implementations are available, of which Rust, Go, C++, and AssemblyScript are among the most popular. We made use of the Envoy Wasm filter to configure a Wasm on an Envoy HTTP filter chain. We then built a few simple Wasm examples to manipulate request and response headers and deployed them on Istio using <strong class="source-inline">WasmPlugin</strong>. Wasm is not the only option to extend the Istio data plane, and there is another filter called EnvoyFilter, which can be used to apply the Envoy configuration as a patch on top of the Envoy configuration created <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">Istiod</strong></span><span class="No-Break">.</span></p>
			<p>The next chapter is very interesting as we will learn about how to deploy an Istio Service Mesh for <span class="No-Break">non-Kubernetes workloads.</span></p>
		</div>
	</body></html>