- en: '*Chapter 2*: Understanding How Operators Interact with Kubernetes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand *what* kinds of things an Operator does (and *why* it
    does them), we can begin to explore *how* it performs these tasks. After identifying
    a use case for an Operator, taking the steps to lay out its technical design is
    the next step of the process. Though this is the period before any actual coding
    begins, it is still an essential part of development. This is the standard approach
    for almost any software project, and in this chapter, we will frame it in the
    context of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: During this planning phase, there are several factors to consider and questions
    to answer that will help guide the Operator's design. These factors are both technical
    and organic since your Operator needs to interact with not only the Kubernetes
    resources in your cluster but also the human resources of your engineers and administrators.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain some of the key considerations that should factor
    into your Operator's design. First, we will provide an introduction to some of
    the native Kubernetes components and resources that many Operators interact with.
    By looking at the ways that Operators consume these resources and the use cases
    for doing so, we can start looking at some of the patterns for functional Operator
    design. Next, we'll look at designing an Operator while keeping its unique user
    base in mind and the ways that the design can benefit users. Finally, we'll discuss
    some of the best practices for futureproofing an Operator for ongoing developments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Kubernetes cluster resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying your users and maintainers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing beneficial features for your Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning for evolving changes in your Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of this chapter is to help guide you through the early design process
    of an Operator. Poorly planning an Operator's design can lead to many changes
    and updates being needed during the Operator's life cycle. This puts stress on
    engineering resources, but it can also confuse and frustrate users. That is why
    most of this chapter will focus on non-technical specifics. However, we do need
    to know some baseline technical interactions to shape these for our users. By
    the end of this chapter, you may find that you are not currently able to address
    all of the pre-design concerns that are described here. This is fine – the important
    part is to understand certain concepts that you must be aware of as you head into
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Kubernetes cluster resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you decide on how to design an Operator with users' experiences in mind,
    it is important to understand what an Operator is capable of from a technical
    standpoint. Having a mindset for the specific capabilities of the Operator's code
    base will help guide the rest of the design process around what is truly possible.
    Otherwise, trying to define the scope of an Operator based solely on user requests
    without considering feasibility could lead to over-promising and under-delivering
    on functionality and usability.
  prefs: []
  type: TYPE_NORMAL
- en: The possibilities of any Operator are inherently limited by the underlying features
    of the Kubernetes platform. This platform is composed of different native cluster
    resources, some of which you may already be familiar with. This section will examine
    the most common resources that Operators work with and explain how they can and
    should use them. When you're developing an Operator, these resources will usually
    be consumed via the Kubernetes client libraries, which allow any application to
    interact with cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: Pods, ReplicaSets, and Deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most basic unit of a Kubernetes cluster architecture is the **Pod**.
    These objects represent one or more running containers. Under the hood, a Pod
    is essentially a definition of container images that the **Kubelet** can use to
    instruct the container runtime where and how to run certain containers. Applications
    are deployed on Kubernetes as Pods, Kubernetes itself is made up of many system
    Pods, and Operators are deployed as Pods as well.
  prefs: []
  type: TYPE_NORMAL
- en: While Pods are essential to a Kubernetes cluster, they are usually too atomic
    to manage manually. It is also often necessary to run multiple copies of an application,
    which is where **ReplicaSets** come in. The role of ReplicaSets is to define several
    replicas for a certain template of Pods.
  prefs: []
  type: TYPE_NORMAL
- en: However, ReplicaSets are also limited in their abilities. They simply maintain
    the number of replicas of a Pod on the cluster. **Deployments** add even more
    functionality to this by encompassing ReplicaSets and defining further controls
    such as rollout strategies and revision management for rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: From an Operator developer's perspective, Deployments are usually the most important
    resources to interact with. The advanced mechanics of Deployments provide flexibility
    for an application's runtime. These mechanics can be abstracted or restricted
    from users since they will only be interacting with the Operator through its CRD
    (rather than using the Deployment directly). However, the flexibility is still
    there to add it later or automatically program it into the Operator's reconciliation
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the encapsulation of application workload Pods
    within ReplicaSets and Deployments can still be managed by an Operator. In this
    example, the Operator only cares about the Deployment, but the status of that
    Deployment reflects the health of the actual workloads within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – An Operator managing a Deployment with two ReplicaSets, each
    with several Pods](img/B18147_Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – An Operator managing a Deployment with two ReplicaSets, each with
    several Pods
  prefs: []
  type: TYPE_NORMAL
- en: An Operator will usually be installed and managed by a Deployment. The Deployment
    then provides a good owner reference of all the resource components that comprise
    the Operator for garbage collection. This is useful for upgrading and uninstalling
    the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not uncommon for an Operator to directly manage some Pods or
    ReplicaSets, there are certainly tradeoffs. For one, such an Operator's design
    would lead to a simpler application architecture at the expense of the capabilities
    and conveniences of using Deployments. So, when you're deciding if your Operator
    will directly manage Pods or a Deployment, it is important to consider the intent
    of the application itself and the needs of the design.
  prefs: []
  type: TYPE_NORMAL
- en: Custom resource definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introducing
    the Operator Framework*, most Operators are dependent on **CustomResourceDefinitions**
    (**CRDs**). CRDs are native Kubernetes resources that allow users to extend the
    Kubernetes platform with their resource definitions at runtime. They are like
    plugins to the Kubernetes API. Upon installing a CRD in the cluster, it provides
    the API server with information on how to handle and validate objects of that
    custom type.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use case for an Operator to consume CRDs is to provide its configuration
    object as one. Once the Kubernetes API knows how to handle this CRD, the Operator
    or user will then create the Operator object from YAML (just like when creating
    a Pod or Deployment).
  prefs: []
  type: TYPE_NORMAL
- en: Users can then interact solely with the Operator resource, rather than having
    to manually tweak the Operator's Deployment to adjust its settings. This allows
    developers to present a curated frontend user experience and abstract away the
    Kubernetes internals of the application, all in an interface that feels just like
    any other native Kubernetes resource object.
  prefs: []
  type: TYPE_NORMAL
- en: But Operators can package more than just their configuration in a CRD. Depending
    on the application that's being managed, an Operator can also install and monitor
    custom resources that are needed by the application. Because of the many use cases
    for CRDs, it's not unusual for an application to provide and depend on its custom
    resource objects. An application Operator should know these resources and be able
    to install and manage them too.
  prefs: []
  type: TYPE_NORMAL
- en: CRDs are a core aspect of Operator development because, without them, all that
    is left are the core Kubernetes resources (such as Pods, ReplicaSets, and Deployments)
    to achieve our goals. While these resources can accomplish many things, they do
    not have the inherent flexibility to be customized to any specific need. An Operator's
    custom resource object provides a user interface that seamlessly fits into a cluster
    with other Kubernetes objects. In addition, the Kubernetes API clients and Operator
    SDK provide code tools so that you can easily interact with these custom resources,
    just like they were any other cluster resource.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccounts, roles, and RoleBindings (RBAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access policies are often overlooked but can be critical to ensuring the stability
    and security of your and your users' clusters. Just like an application manages
    other cluster components, an Operator is going to require certain RBAC policies
    to complete its job within the necessary access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators require RBAC policies to manage their Operands. Defining an RBAC
    policy for any application in Kubernetes starts with a **role**. Roles define
    the types of API objects that an application or user has access to, as well as
    the verbs that are allowed to be used with those objects. The following is an
    example of a role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This sample creates a role that allows an Operator to *get*, *watch*, and *list*
    the Pods in the specified namespace. It also allows the Operator to access all
    the resources under the `operator.sample.com` API group. This is included to indicate
    how an Operator gains access to its CRD. Since there is nothing inherently tying
    the Operator to the CRD, it still needs RBAC access to that object, just like
    it would with any other API object. In this case, the CRD would be created under
    that API group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roles can be scoped to a single namespace, or they can be cluster-scoped with
    **ClusterRoles**. Either way, the role is bound to a **ServiceAccount** with a
    **RoleBinding** (or **ClusterRoleBinding**). ServiceAccounts are specified on
    Pods to complete the chain of identifying what RBAC-based access a Pod has within
    the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Diagram of cluster versus namespace-scoped roles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18147_Figure_2.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Diagram of cluster versus namespace-scoped roles
  prefs: []
  type: TYPE_NORMAL
- en: The difference between roles and ClusterRoles depends on the breadth of access
    an Operator will need within a cluster. Specifically, this is mostly based on
    the namespaces that an Operator, its Operand, and their dependencies are installed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Kubernetes applications run within **namespaces**. A namespace is a logical
    partition for application resources to reside in that separates components and
    allows certain degrees of access control. Operators are also deployed within namespaces,
    but they sometimes require access to other namespaces as well.
  prefs: []
  type: TYPE_NORMAL
- en: The breadth of an Operator's namespace coverage is called its scope. Operators
    can either be scoped to a single namespace (**namespace-scoped**), or they can
    be **cluster-scoped**. When an Operator is cluster-scoped, it can observe and
    interact with resources in multiple namespaces. In contrast, a namespace-scoped
    operator is installed on a single namespace and manages the resources within that
    namespace. Which scope a developer chooses for their Operator depends on the resources
    the Operator will manage.
  prefs: []
  type: TYPE_NORMAL
- en: If the Operator must be able to manage resources that are created in any namespace,
    then it should be cluster-scoped. This could be an Operator that manages an Operand
    in a specific separate namespace from the Operator itself. Or, it could simply
    need to manage Operands that exist in many namespaces (such as a resource provisioner
    where users request development environments to be deployed).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, namespace-scoped Operators have some benefits. Specifically,
    restricting an Operator to a single namespace allows for easier debugging and
    failure isolation. It also allows for flexible installation (including installing
    multiples of the same Operator across multiple namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: The Operator's scope is ultimately defined by its CRD and access roles. Cluster-scoped
    custom resources are created outside of any specific namespace. This can be good
    for Operators that will only have one instance in a cluster (for example, Operators
    that manage core Kubernetes components, such as the API server). The access roles
    an Operator needs will usually follow the scope of the Operator's CRD.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the resources we have covered here (Pods, ReplicaSets, Deployments,
    CRDs, RBAC, and namespaces) are only a few of the possible resources an Operator
    will depend on. However, they are the most common and likely the first ones you
    should consider when you''re designing your Operator''s cluster interactions.
    In the next section, we''ll look at the other side of an Operator''s interactions:
    how it interacts with humans.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying users and maintainers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other way that an Operator interacts with Kubernetes is through its users.
    While Operators exist to automate many of the cluster interactions that are required
    by humans, the organic element in a Kubernetes cluster is still present. Users
    must still interact with the Operator somehow, and the ways that different users
    will want and need to engage in that interaction can influence an Operator's design.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is important to identify what type of user your Operator is intended
    for; there are a few categories. Each category will have different needs and opinions
    on what their Operator should do. So, by identifying the target audience for your
    Operator, you can ensure that the Operator has been designed to appeal to the
    widest user base and fulfill the most use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most Operators, the type of users that will be interacting with them can
    be broken into a couple of groups based on the level of access those users have
    in the cluster and the role those users play in the application at large. These
    user groups are usually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster administrators**: The admin users of a cluster that are responsible
    for its maintenance and stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster users**: Individual users with internal access to a cluster, such
    as the engineers on a team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-users/customers**: The external users of a cluster for a public or enterprise
    product. These users don''t directly interact with a cluster, but they use the
    applications that run on the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types of users all have similar motivations and use cases, but also some
    stark differences. Thinking about each group individually helps highlight these
    comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster administrators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cluster administrators are commonly the consumers of Operators. These are the
    users that have the most access to and knowledge about a cluster's architecture.
    As such, they require the most power and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Foremost, a cluster administrator's job is to ensure the stability of their
    cluster. This is why they need the broadest array of tools and controls at their
    disposal to modify cluster settings as necessary. But, as the saying goes, *with
    great power comes great responsibility*. In this case, an Operator can provide
    administrators with great power to run their cluster however they need to. But
    that power can backfire and harm the cluster if it doesn't work exactly as intended.
  prefs: []
  type: TYPE_NORMAL
- en: So, the developer of an Operator that is going to be used by cluster administrators
    may consider restricting its capabilities to a defined set that is known to be
    supportable. This can help them design the Operator so that it doesn't become
    *too powerful* and expose settings that can inadvertently damage the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: However, if an administrator finds that their cluster is suddenly *on fire*
    or critically failing, they will need to fix that problem as soon as possible.
    If this is due to the component that an Operator is managing (or the Operator
    itself), then the administrator will require direct access to the Operator, Operand,
    or both. At times like this, a restricted feature set may hinder the recovery
    time to restore cluster stability.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of developing Operators for cluster administrators is that they
    are very knowledgeable about their clusters and have high levels of internal access
    to them. This provides some trust that allows more powerful functionality to be
    created. Also, having homogenous consumers limits the different workflows that
    need to be supported in an Operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the simple layout of an internal cluster administrator
    interacting with an Operator to manage the Operands in their cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – A single cluster administrator directly managing an Operator
    via its CRD](img/B18147_Figure_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – A single cluster administrator directly managing an Operator via
    its CRD
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, it is up to the developers of the Operator to determine what to
    provide for the cluster administrators (if that is the target audience). Depending
    on the application the Operator is going to manage, it may make sense and be safe
    and limit the administrator's direct access to the Operand through the Operator.
    But if there is the potential for an Operand deployment to go haywire and require
    manual intervention, then emergency accessibility should be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The users of a cluster interact with the cluster but without the access and
    control of an administrator. For example, these could be developers working on
    a shared cluster who need certain resources to be deployed and destroyed on-demand.
    Provisioning development resources involves having users request those resources
    from the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster users require less control over underlying cluster components. They
    also are less likely to be touching parts of a cluster and potentially breaking
    it. These are two reassurances for developing an Operator that helps limit the
    scope of features that must be supported by these users. Additionally, these users
    may have personal access to a cluster administrator if they require more than
    the Operator provides.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster users may also interact with Operators through internal applications.
    It is not uncommon for organizations to deploy custom applications within their
    intranets. Using an internal application like this can provide a more user-friendly
    frontend for your cluster users. It also allows the cluster users' access to be
    restricted below the underlying Operator's actual capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a setup where multiple internal users are using
    an Operator to provision resources in the cluster. Some of these users are interacting
    with the Operator directly, while others must go through an internal application
    to interact with the Operator (the Operator could even be managing this frontend
    application). With patterns like this, intra-organizational privilege hierarchies
    can be defined for working with the internal tools that are provided by Operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Internal cluster users requesting resources, either directly
    from the Operator or via an intermediary internal application](img/B18147_Figure_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Internal cluster users requesting resources, either directly from
    the Operator or via an intermediary internal application
  prefs: []
  type: TYPE_NORMAL
- en: The options for exposing an Operator to internal cluster users are some of the
    most flexible. These users benefit from a level of trust and investment in the
    cluster's stability that's high enough that the risk of negligent or malicious
    behavior is mitigated. However, there is still a risk in exposing application
    management controls to a broader audience. So, you must think about this when
    you're designing the capabilities of your Operator.
  prefs: []
  type: TYPE_NORMAL
- en: End users and customers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The end users of a product can also benefit from Operators. These users may
    not even know they are interacting with an Operator since the architectural design
    of the product is usually not apparent to everyday users. But it is still important
    to know how the users of a product will expect it to function, especially in this
    case, where we are designing a critical component of the product.
  prefs: []
  type: TYPE_NORMAL
- en: These end users will likely not be directly interacting with the Operator. This
    would mean that your users and customers have access to the Kubernetes cluster
    themselves, which is not ideal for security or usability. The customers of an
    application benefit from an interactive frontend, whether this is a website or
    mobile app. But that frontend is just a tool for interacting with a backend, which
    could be made up of many different components, including Operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, your user might be yourself – that is, you (or your organization)
    will be developing the Operator but also probably developing the frontend applications
    that depend on it. In situations like this, cross-project collaboration is necessary
    to elaborate on the needs and expectations of each team. Operators in this kind
    of scenario will benefit the most from elegant API design that communicates easily
    with other programs, rather than human users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – External end users interacting with an Operator via an external-facing
    application](img/B18147_Figure_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – External end users interacting with an Operator via an external-facing
    application
  prefs: []
  type: TYPE_NORMAL
- en: The end users of an application will usually be completely detached from interacting
    with an Operator. However, this doesn't mean that an application and its resources
    can't still be managed by one. In this scenario, the Operator is still an important
    and helpful tool for maintaining the state of the cluster that end users expect,
    even if those users don't need to know they are interacting with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'End users are the final type of users we''ll discuss that interact with your
    Operator in a functional capacity. However, there are other people we must consider
    when we''re designing an Operator: the people who maintain the Operator and its
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintainers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final type of user who will interact with your Operator does so in a different
    way than the other three. These are the maintainers of the project, who work on
    the code to resolve issues and implement new features. The role of a maintainer
    in any software project is an important one, but in an open source ecosystem such
    as Kubernetes, there are additional points to consider.
  prefs: []
  type: TYPE_NORMAL
- en: If your Operator's source code is going to be open and accepting contributions
    from anyone, it will be essential to appoint trusted owners to review code changes.
    This is true for any open source project, but for an Operator, it is very beneficial
    that these reviewers are familiar with the core Kubernetes concepts that any Operator
    depends on.
  prefs: []
  type: TYPE_NORMAL
- en: From an enterprise perspective, investing in a reliable team of engineers to
    build and maintain an Operator provides a long-term incentive for your maintainers
    to continue building the Operator's source code. This also creates a level of
    trust between the maintainers of the Operator and its primary stakeholders. Ongoing
    maintenance for the Operator code base will be necessary, especially given the
    changing nature of the Kubernetes platform. Maintainers who are familiar with
    the Kubernetes community are an important addition to teams that use Operators.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few of the types of users that your Operator may interact with.
    This list is by no means exhaustive, but it is intended to provoke thoughts about
    your user base. Identifying the type of user for an Operator helps narrow down
    what kind of features an Operator will need. It also provides a starting point
    for determining what features are necessary. In the next section, we'll look at
    some ideas for thinking about feature design that benefits users the most.
  prefs: []
  type: TYPE_NORMAL
- en: Designing beneficial features for your operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've identified the target audience for your Operator, the next step
    is to define what the Operator will do. Listing the problems that must be solved
    by the Operator will give you a better understanding of the goals of the project.
    It will also highlight whether or not those goals provide a tangible, measurable
    benefit to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Figuring out what kind of functions are truly beneficial is hard to define.
    The exact definition of "helpful" is different on a case-by-case basis. Some beneficial
    Operators solve widespread headaches in a novel and intuitive way. Others address
    more niche problems that may only affect small communities of users, but the impact
    of eliminating those problems is significant. However, it is a bit easier to describe
    beneficial functions in terms of what is not useful.
  prefs: []
  type: TYPE_NORMAL
- en: Foremost, useful Operators are not redundant. In specific examples, redundancy
    can mean a lot of different things. But it is fundamentally the essence of nonduplication
    that Operator designers should strive for. The most basic example of this is not
    rewriting an Operator that already exists elsewhere without having a sufficient
    reason to do so. Researching the proposed area of your Operator can prevent this.
    Researching the approaches that others have undertaken will also reveal potential
    pitfalls to avoid in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Operators can also be redundant in terms of Kubernetes concepts. Since an Operator
    is essentially interacting with the cluster and exposing some of that interaction
    to users, the Operator is an extension of Kubernetes. Because of this, it can
    be inadvertently tempting to "reinvent the wheel" when it comes to brainstorming
    functions for the Operator. This kind of functional redundancy can be related
    to the next issue we'll discuss, wherein developers try to address nonexistent
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: The next issue concerns beneficial tasks, which are not hypothetical. The world
    of software development benefits from many passionate engineers who are eager
    to fix the problems they run into. This zeal for contribution can extend to fixing
    potential issues, even if they have not been witnessed in practice. This is certainly
    a good mentality to have, and in no way should this kind of passion be stifled.
    There are, of course, many types of issues and bugs that can be identified and
    should be patched – hopefully before anyone runs into them in production. But
    occasionally, real solutions are proposed for purely theoretical problems.
  prefs: []
  type: TYPE_NORMAL
- en: These hypothetical use cases may be proposed without any actual evidence that
    users are seeking such a solution. This can be tricky because sometimes, the use
    case seems obvious enough that it almost shouldn't necessitate any explicit demand.
    But when each new feature costs resources to implement and binds the maintainers
    to support it, paying close attention to silence can reveal unnecessary work.
  prefs: []
  type: TYPE_NORMAL
- en: While there could be many breakthrough ideas for features, it is important to
    try to validate a feature's proposal with real demand. This type of research can
    also uncover redundancy in the idea and lead to more effective alternative solutions
    that already exist.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, an infinite number of criteria that could be used to define
    the usefulness of features. In the context of Kubernetes Operators, however, these
    are just some initial thoughts to get started with. By thinking about your Operator
    in terms of its benefits, and by asking "What makes this useful?" you can avoid
    excessive or unnecessary changes that will require maintenance later down the
    road.
  prefs: []
  type: TYPE_NORMAL
- en: That foresight will come in handy as your Operator grows and evolves. Like most
    software, Operators are prone to changes over time, especially given their dependence
    on the upstream Kubernetes code base. In the next section, we'll learn how to
    prepare for and navigate these changes as they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Planning for changes in your Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over any software project's lifespan, changes will be made to the code base.
    These include bug fixes, refactors, new features, and old features being removed.
    This is true for Kubernetes, its subprojects, and projects that are built on the
    platform, such as Operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s impossible to predict the future of what your Operator will evolve
    into one day, there are a few ideas that can help you during the design phase
    to ease transitions and new developments later. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start small.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecate gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These decisions have significant benefits in practice when you're maintaining
    an Operator. However, these are not definitive or strictly specific to Kubernetes
    Operators. Consider them as general suggestions for developing any software project.
    But here, we will be examining them in the context of writing an Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Starting small
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When planning the original design for an Operator, considering how the Operator
    may change over time can prevent future challenges. Designing with growth in mind
    also helps limit the initial scope of the project so that it only covers essential
    purposes. This allows adequate resources to be allocated to the development of
    a strong first product that can be efficiently iterated over time.
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem like the best goal for developing an Operator is to start
    with as many features as possible, in reality, the opposite is often true. After
    all, one purpose of an Operator is to create a layer of abstraction between its
    users and the underlying cluster functions. By exposing too many options, you
    may lose the benefit of automation by requiring your users to understand more
    of the native Kubernetes cluster functionality. This also makes your users more
    vulnerable to changes in the Kubernetes platform that shouldn't directly affect
    them.
  prefs: []
  type: TYPE_NORMAL
- en: When you're deciding whether to add a feature to an Operator or not, think critically
    about the importance of the feature, as well as the risks and costs of implementing
    it. This goes back to the topics of avoiding redundancy and addressing hypothetical
    problems, which we looked at in the previous section. It also relates to the topic
    of deprecation, which we will cover shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, most of the time, it is better to lack features than to ship a complex
    and confusing Operator. Every new feature has maintenance costs and the potential
    to introduce bugs later. These are some of the biggest reasons for starting small
    and building as you listen to feedback from your users.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating effectively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have a minimal set of features, it will eventually be necessary to
    add improvements. Fortunately, it is much easier to add new things than it is
    to take old things away.
  prefs: []
  type: TYPE_NORMAL
- en: You should actively seek feedback from users on what kind of features they need.
    This can be done in many ways, from maintaining an active presence online around
    your Operator and its related projects to implementing detailed usage metrics
    in the Operator's code. In addition, having an awareness of the broader Kubernetes
    project communities can help highlight upcoming changes in the underlying platform
    that you may want to support in your Operator.
  prefs: []
  type: TYPE_NORMAL
- en: As you add features, continue to monitor their usage to gauge their effectiveness.
    Keeping the guidelines for the initial design of an Operator, such as its user
    base and feature tips, in mind will also make sure that each new feature is just
    as effective as the original set of features you designed when you first built
    the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecating gracefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One type of change that can be incredibly inconvenient for users is deprecation.
    Many aspects of large software projects inevitably have to be replaced or have
    their support dropped by official maintainers. With a minimal Operator design,
    the possibility of your users' experience having to be changed is also minimized.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a small design and thoughtful, effective iterations after that
    will help reduce the need to remove features. Unfortunately, it may be inevitable
    at some point. In this case, it is important to give users plenty of notice so
    that they have sufficient time to transition to an alternative, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes community has defined policies for deprecation, which will be
    covered in detail [*Chapter 8*](B18147_08_ePub.xhtml#_idTextAnchor126), *Preparing
    for Ongoing Maintenance of Your Operator*. But these guidelines serve as a good
    template for your deprecation. Kubernetes users will be familiar with the timelines
    and processes for deprecation, so by remaining consistent with those processes,
    your users will benefit from a familiarity they already have.
  prefs: []
  type: TYPE_NORMAL
- en: Just as all good things must come to an end, so too must some good features
    be eventually retired. Fortunately, this is not a foreign concept to the Kubernetes
    community, which offers a well-established template for deprecation. As a responsible
    citizen of the open source community, you and your users will benefit from a respectful,
    considerate approach to removing and changing aspects of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping all these practices in mind during the design stage of an Operator will
    pay off by limiting the scope of the project. This allows resources to focus on
    building a stable tool that does not radically change over time. Users and maintainers
    will both benefit from this stability, as users can seamlessly work with different
    versions of the Operator without changing their workflows, and maintainers can
    invest long-term effort into growing the project and passing knowledge about it
    to others.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on the different ways in which an Operator can interact
    with a Kubernetes cluster. Besides the literal technical interactions between
    an Operator's code base and the cluster's native resources, we also explored some
    other interactions that are worth considering in an Operator's design. These include
    an Operator's users and an Operator's lifecycle over time.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes clusters comprise many different types of native resources. These
    are the fundamental building blocks of all the applications that are deployed
    on Kubernetes. Operators are no different in that sense compared to any other
    application, so they must be able to natively consume these resources. This chapter
    focused on breaking down a few Operator resources, including Pods, Deployments,
    CRDs, and RBAC policies, so that you know how to define how Operators consume
    them.
  prefs: []
  type: TYPE_NORMAL
- en: How humans interact with an Operator is one of the most important design concepts
    to consider. Operators are designed to work for humans by automating various tasks,
    but like any power tool that automates manual labor, they still require human
    input to operate and produce output for humans. Due to this, we discussed some
    of the types of users that your Operator can be built for and the unique needs
    and expectations of each type.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered some good approaches to feature design. To help you set
    up an Operator for success, we discussed ideas for drafting an initial design
    that provides tangible benefits to users. We then proposed some more concepts
    you should keep in mind as your Operator evolves.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll apply these lessons to hands-on Operator design.
    We will begin by building a sample Operator, starting with designing for its CRD,
    API, and reconciliation loop. Here, we will begin building an actual Operator,
    which we will then code and deploy in the remainder of this book.
  prefs: []
  type: TYPE_NORMAL
