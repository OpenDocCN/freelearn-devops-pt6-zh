- en: '*Chapter 2*: Understanding How Operators Interact with Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：理解操作符如何与Kubernetes交互'
- en: Now that we understand *what* kinds of things an Operator does (and *why* it
    does them), we can begin to explore *how* it performs these tasks. After identifying
    a use case for an Operator, taking the steps to lay out its technical design is
    the next step of the process. Though this is the period before any actual coding
    begins, it is still an essential part of development. This is the standard approach
    for almost any software project, and in this chapter, we will frame it in the
    context of Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了操作符做*什么*（以及*为什么*要做这些事情），我们可以开始探索*如何*执行这些任务。在确定了操作符的使用场景后，接下来的步骤就是制定它的技术设计。虽然这还是在实际编码之前的阶段，但它仍然是开发过程中的一个重要部分。这是几乎所有软件项目的标准做法，在本章中，我们将把它框架化并应用于Kubernetes的背景中。
- en: During this planning phase, there are several factors to consider and questions
    to answer that will help guide the Operator's design. These factors are both technical
    and organic since your Operator needs to interact with not only the Kubernetes
    resources in your cluster but also the human resources of your engineers and administrators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划阶段，有几个因素需要考虑，并且需要回答一些问题，这些问题将有助于指导操作符的设计。这些因素既有技术性的，也有有机性的，因为你的操作符不仅需要与集群中的Kubernetes资源进行交互，还需要与工程师和管理员等人力资源进行互动。
- en: This chapter will explain some of the key considerations that should factor
    into your Operator's design. First, we will provide an introduction to some of
    the native Kubernetes components and resources that many Operators interact with.
    By looking at the ways that Operators consume these resources and the use cases
    for doing so, we can start looking at some of the patterns for functional Operator
    design. Next, we'll look at designing an Operator while keeping its unique user
    base in mind and the ways that the design can benefit users. Finally, we'll discuss
    some of the best practices for futureproofing an Operator for ongoing developments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释一些应该考虑纳入操作符设计的关键因素。首先，我们将介绍一些Kubernetes的原生组件和资源，这些资源是许多操作符交互的对象。通过查看操作符如何使用这些资源以及使用它们的用例，我们可以开始探索一些功能性操作符设计的模式。接下来，我们将研究如何在设计操作符时考虑其独特的用户群体，以及如何使设计对用户有利。最后，我们将讨论一些最佳实践，帮助操作符应对未来的持续发展。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Interacting with Kubernetes cluster resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Kubernetes集群资源进行交互
- en: Identifying your users and maintainers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你的用户和维护者
- en: Designing beneficial features for your Operator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的操作符设计有益的功能
- en: Planning for evolving changes in your Operator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为操作符的演进变化进行规划
- en: The goal of this chapter is to help guide you through the early design process
    of an Operator. Poorly planning an Operator's design can lead to many changes
    and updates being needed during the Operator's life cycle. This puts stress on
    engineering resources, but it can also confuse and frustrate users. That is why
    most of this chapter will focus on non-technical specifics. However, we do need
    to know some baseline technical interactions to shape these for our users. By
    the end of this chapter, you may find that you are not currently able to address
    all of the pre-design concerns that are described here. This is fine – the important
    part is to understand certain concepts that you must be aware of as you head into
    development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助你了解操作符的早期设计过程。若操作符的设计规划不当，可能会导致在操作符生命周期内需要进行大量的更改和更新。这会给工程资源带来压力，也可能会让用户感到困惑和沮丧。因此，本章的大部分内容将集中在非技术性细节上。然而，我们确实需要了解一些基本的技术交互，以便为我们的用户进行设计调整。在本章结束时，你可能会发现自己目前无法解决所有在此描述的预设计问题。这没关系——重要的是要理解在进入开发阶段时你必须意识到的某些概念。
- en: Interacting with Kubernetes cluster resources
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Kubernetes集群资源进行交互
- en: Before you decide on how to design an Operator with users' experiences in mind,
    it is important to understand what an Operator is capable of from a technical
    standpoint. Having a mindset for the specific capabilities of the Operator's code
    base will help guide the rest of the design process around what is truly possible.
    Otherwise, trying to define the scope of an Operator based solely on user requests
    without considering feasibility could lead to over-promising and under-delivering
    on functionality and usability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你决定如何从用户体验角度设计 Operator 之前，理解 Operator 的技术能力是非常重要的。了解 Operator 代码库的具体能力，有助于指导整个设计过程，明确哪些是实际可行的。否则，仅根据用户需求定义
    Operator 的范围而忽视可行性，可能会导致承诺过多而功能和可用性不足。
- en: The possibilities of any Operator are inherently limited by the underlying features
    of the Kubernetes platform. This platform is composed of different native cluster
    resources, some of which you may already be familiar with. This section will examine
    the most common resources that Operators work with and explain how they can and
    should use them. When you're developing an Operator, these resources will usually
    be consumed via the Kubernetes client libraries, which allow any application to
    interact with cluster resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Operator 的可能性本质上受到 Kubernetes 平台底层特性的限制。该平台由不同的原生集群资源组成，其中一些资源你可能已经熟悉。本节将介绍
    Operator 常用的资源，并解释如何以及为何使用它们。当你开发 Operator 时，这些资源通常会通过 Kubernetes 客户端库进行访问，这些库允许任何应用与集群资源进行交互。
- en: Pods, ReplicaSets, and Deployments
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pods、ReplicaSets 和 Deployments
- en: Perhaps the most basic unit of a Kubernetes cluster architecture is the **Pod**.
    These objects represent one or more running containers. Under the hood, a Pod
    is essentially a definition of container images that the **Kubelet** can use to
    instruct the container runtime where and how to run certain containers. Applications
    are deployed on Kubernetes as Pods, Kubernetes itself is made up of many system
    Pods, and Operators are deployed as Pods as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或许 Kubernetes 集群架构中最基本的单元就是 **Pod**。这些对象代表一个或多个正在运行的容器。从底层来看，Pod 本质上是容器镜像的定义，**Kubelet**
    可以利用这些定义来指导容器运行时在哪里以及如何运行特定容器。应用程序以 Pods 形式部署在 Kubernetes 上，Kubernetes 本身由许多系统
    Pods 组成，Operators 也作为 Pods 部署。
- en: While Pods are essential to a Kubernetes cluster, they are usually too atomic
    to manage manually. It is also often necessary to run multiple copies of an application,
    which is where **ReplicaSets** come in. The role of ReplicaSets is to define several
    replicas for a certain template of Pods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Pods 对 Kubernetes 集群至关重要，但它们通常过于原子化，难以手动管理。而且通常需要运行多个副本的应用程序，这时 **ReplicaSets**
    就派上用场了。ReplicaSets 的作用是为某个 Pod 模板定义多个副本。
- en: However, ReplicaSets are also limited in their abilities. They simply maintain
    the number of replicas of a Pod on the cluster. **Deployments** add even more
    functionality to this by encompassing ReplicaSets and defining further controls
    such as rollout strategies and revision management for rollbacks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ReplicaSets 的能力也有限。它们仅维护集群中 Pod 的副本数量。**Deployments** 通过包含 ReplicaSets 并定义更多控制功能，如发布策略和回滚修订管理，进一步增强了这一功能。
- en: From an Operator developer's perspective, Deployments are usually the most important
    resources to interact with. The advanced mechanics of Deployments provide flexibility
    for an application's runtime. These mechanics can be abstracted or restricted
    from users since they will only be interacting with the Operator through its CRD
    (rather than using the Deployment directly). However, the flexibility is still
    there to add it later or automatically program it into the Operator's reconciliation
    logic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Operator 开发者的角度来看，Deployments 通常是最重要的交互资源。Deployments 的高级机制为应用程序的运行时提供了灵活性。这些机制可以从用户角度进行抽象或限制，因为用户将通过
    Operator 的 CRD 与之交互（而不是直接使用 Deployment）。然而，灵活性依然存在，可以稍后将其添加或自动编程到 Operator 的调和逻辑中。
- en: 'The following diagram shows how the encapsulation of application workload Pods
    within ReplicaSets and Deployments can still be managed by an Operator. In this
    example, the Operator only cares about the Deployment, but the status of that
    Deployment reflects the health of the actual workloads within it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了应用工作负载 Pod 在 ReplicaSets 和 Deployments 中的封装，如何仍然可以通过 Operator 进行管理。在此示例中，Operator
    只关注 Deployment，但该 Deployment 的状态反映了其中实际工作负载的健康状况：
- en: '![Figure 2.1 – An Operator managing a Deployment with two ReplicaSets, each
    with several Pods](img/B18147_Figure_2.1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 一个操作符管理着一个包含两个 ReplicaSets（每个包含若干 Pods）的部署](img/B18147_Figure_2.1.jpg)'
- en: Figure 2.1 – An Operator managing a Deployment with two ReplicaSets, each with
    several Pods
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 一个操作符管理着一个包含两个 ReplicaSets（每个包含若干 Pods）的部署
- en: An Operator will usually be installed and managed by a Deployment. The Deployment
    then provides a good owner reference of all the resource components that comprise
    the Operator for garbage collection. This is useful for upgrading and uninstalling
    the Operator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符通常由部署安装和管理。部署提供了一个良好的所有者引用，用于所有构成操作符的资源组件的垃圾回收。这对于升级和卸载操作符非常有用。
- en: Although it is not uncommon for an Operator to directly manage some Pods or
    ReplicaSets, there are certainly tradeoffs. For one, such an Operator's design
    would lead to a simpler application architecture at the expense of the capabilities
    and conveniences of using Deployments. So, when you're deciding if your Operator
    will directly manage Pods or a Deployment, it is important to consider the intent
    of the application itself and the needs of the design.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管操作符直接管理某些 Pods 或 ReplicaSets 并不罕见，但确实存在权衡问题。首先，这样的操作符设计会导致应用程序架构更简单，但以牺牲使用部署（Deployments）时的能力和便利性为代价。因此，当你决定是否让操作符直接管理
    Pods 或部署时，考虑应用程序本身的意图和设计需求非常重要。
- en: Custom resource definitions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义资源定义
- en: As we mentioned in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introducing
    the Operator Framework*, most Operators are dependent on **CustomResourceDefinitions**
    (**CRDs**). CRDs are native Kubernetes resources that allow users to extend the
    Kubernetes platform with their resource definitions at runtime. They are like
    plugins to the Kubernetes API. Upon installing a CRD in the cluster, it provides
    the API server with information on how to handle and validate objects of that
    custom type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 1 章*](B18147_01_ePub.xhtml#_idTextAnchor015)中提到的，*引入操作符框架*，大多数操作符依赖于**自定义资源定义**（**CRDs**）。CRD
    是本地 Kubernetes 资源，允许用户在运行时扩展 Kubernetes 平台的资源定义。它们就像 Kubernetes API 的插件。当在集群中安装
    CRD 后，它会向 API 服务器提供如何处理和验证该自定义类型对象的信息。
- en: The most common use case for an Operator to consume CRDs is to provide its configuration
    object as one. Once the Kubernetes API knows how to handle this CRD, the Operator
    or user will then create the Operator object from YAML (just like when creating
    a Pod or Deployment).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符使用 CRD 的最常见用例是提供其配置对象作为其中之一。一旦 Kubernetes API 知道如何处理这个 CRD，操作符或用户将从 YAML
    创建操作符对象（就像创建 Pod 或部署一样）。
- en: Users can then interact solely with the Operator resource, rather than having
    to manually tweak the Operator's Deployment to adjust its settings. This allows
    developers to present a curated frontend user experience and abstract away the
    Kubernetes internals of the application, all in an interface that feels just like
    any other native Kubernetes resource object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以仅与操作符资源进行交互，而不必手动调整操作符的部署设置。这允许开发人员展示精心设计的前端用户体验，并抽象化应用程序的 Kubernetes 内部实现，所有这些都可以在一个界面中进行，就像其他任何本地的
    Kubernetes 资源对象一样。
- en: But Operators can package more than just their configuration in a CRD. Depending
    on the application that's being managed, an Operator can also install and monitor
    custom resources that are needed by the application. Because of the many use cases
    for CRDs, it's not unusual for an application to provide and depend on its custom
    resource objects. An application Operator should know these resources and be able
    to install and manage them too.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，操作符不仅仅可以在 CRD 中打包它们的配置。根据所管理的应用程序，操作符还可以安装和监控应用程序所需的自定义资源。由于 CRD 的多种使用场景，应用程序提供和依赖其自定义资源对象并不罕见。一个应用程序操作符应该了解这些资源，并能够安装和管理它们。
- en: CRDs are a core aspect of Operator development because, without them, all that
    is left are the core Kubernetes resources (such as Pods, ReplicaSets, and Deployments)
    to achieve our goals. While these resources can accomplish many things, they do
    not have the inherent flexibility to be customized to any specific need. An Operator's
    custom resource object provides a user interface that seamlessly fits into a cluster
    with other Kubernetes objects. In addition, the Kubernetes API clients and Operator
    SDK provide code tools so that you can easily interact with these custom resources,
    just like they were any other cluster resource.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CRD 是操作员开发的核心部分，因为如果没有 CRD，剩下的只有核心 Kubernetes 资源（如 Pods、ReplicaSets 和 Deployments），这些资源本身虽然能完成很多工作，但没有内在的灵活性，可以根据特定需求进行定制。操作员的自定义资源对象提供了一个用户界面，可以与集群中的其他
    Kubernetes 对象无缝集成。此外，Kubernetes API 客户端和 Operator SDK 提供了代码工具，便于你与这些自定义资源交互，就像与任何其他集群资源一样。
- en: ServiceAccounts, roles, and RoleBindings (RBAC)
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ServiceAccount、角色和 RoleBinding（RBAC）
- en: Access policies are often overlooked but can be critical to ensuring the stability
    and security of your and your users' clusters. Just like an application manages
    other cluster components, an Operator is going to require certain RBAC policies
    to complete its job within the necessary access.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 访问策略往往被忽视，但它们对于确保你和你用户集群的稳定性和安全性至关重要。就像应用程序管理其他集群组件一样，操作员也需要一定的 RBAC 策略来完成其在所需访问权限内的工作。
- en: 'Operators require RBAC policies to manage their Operands. Defining an RBAC
    policy for any application in Kubernetes starts with a **role**. Roles define
    the types of API objects that an application or user has access to, as well as
    the verbs that are allowed to be used with those objects. The following is an
    example of a role:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员需要 RBAC 策略来管理其操作对象。为 Kubernetes 中的任何应用定义 RBAC 策略时，首先需要定义一个**角色**。角色定义了应用或用户可以访问的
    API 对象类型，以及允许与这些对象一起使用的操作动词。以下是一个角色的示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This sample creates a role that allows an Operator to *get*, *watch*, and *list*
    the Pods in the specified namespace. It also allows the Operator to access all
    the resources under the `operator.sample.com` API group. This is included to indicate
    how an Operator gains access to its CRD. Since there is nothing inherently tying
    the Operator to the CRD, it still needs RBAC access to that object, just like
    it would with any other API object. In this case, the CRD would be created under
    that API group.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建了一个角色，允许操作员对指定命名空间中的 Pods 执行*获取*、*观察*和*列出*操作。它还允许操作员访问 `operator.sample.com`
    API 组下的所有资源。这个例子用来说明操作员如何访问其 CRD。由于操作员与 CRD 之间没有任何固有的绑定，它仍然需要 RBAC 权限来访问该对象，就像访问任何其他
    API 对象一样。在此情况下，CRD 会在该 API 组下创建。
- en: 'Roles can be scoped to a single namespace, or they can be cluster-scoped with
    **ClusterRoles**. Either way, the role is bound to a **ServiceAccount** with a
    **RoleBinding** (or **ClusterRoleBinding**). ServiceAccounts are specified on
    Pods to complete the chain of identifying what RBAC-based access a Pod has within
    the cluster:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 角色可以限定在单一命名空间内，或者可以通过**ClusterRoles**被限定为集群角色。无论哪种方式，角色都会绑定到一个**ServiceAccount**，并通过**RoleBinding**（或**ClusterRoleBinding**）进行绑定。ServiceAccount
    会在 Pods 上进行指定，以便完整地识别 Pod 在集群内具有的基于 RBAC 的访问权限：
- en: '![Figure 2.2 – Diagram of cluster versus namespace-scoped roles'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 集群角色与命名空间角色的对比图'
- en: '](img/B18147_Figure_2.2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18147_Figure_2.2.jpg)'
- en: Figure 2.2 – Diagram of cluster versus namespace-scoped roles
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 集群角色与命名空间角色的对比图
- en: The difference between roles and ClusterRoles depends on the breadth of access
    an Operator will need within a cluster. Specifically, this is mostly based on
    the namespaces that an Operator, its Operand, and their dependencies are installed
    in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 角色和 ClusterRole 之间的区别取决于操作员在集群中需要的访问范围。具体来说，这主要取决于操作员、其操作对象（Operand）及其依赖项安装所在的命名空间。
- en: Namespaces
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: All Kubernetes applications run within **namespaces**. A namespace is a logical
    partition for application resources to reside in that separates components and
    allows certain degrees of access control. Operators are also deployed within namespaces,
    but they sometimes require access to other namespaces as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Kubernetes 应用程序都在**命名空间**内运行。命名空间是一个逻辑分区，用于存放应用程序资源，它将各个组件隔离开来，并允许一定程度的访问控制。操作员也被部署在命名空间内，但有时它们还需要访问其他命名空间。
- en: The breadth of an Operator's namespace coverage is called its scope. Operators
    can either be scoped to a single namespace (**namespace-scoped**), or they can
    be **cluster-scoped**. When an Operator is cluster-scoped, it can observe and
    interact with resources in multiple namespaces. In contrast, a namespace-scoped
    operator is installed on a single namespace and manages the resources within that
    namespace. Which scope a developer chooses for their Operator depends on the resources
    the Operator will manage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 的命名空间覆盖范围被称为其作用域。Operator 可以是**命名空间作用域**（namespace-scoped），也可以是**集群作用域**（cluster-scoped）。当
    Operator 是集群作用域时，它可以观察并与多个命名空间中的资源进行交互。相反，命名空间作用域的 Operator 仅安装在一个命名空间中，并管理该命名空间内的资源。开发者为其
    Operator 选择的作用域取决于该 Operator 将要管理的资源。
- en: If the Operator must be able to manage resources that are created in any namespace,
    then it should be cluster-scoped. This could be an Operator that manages an Operand
    in a specific separate namespace from the Operator itself. Or, it could simply
    need to manage Operands that exist in many namespaces (such as a resource provisioner
    where users request development environments to be deployed).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Operator 必须能够管理在任何命名空间中创建的资源，则应该选择集群作用域。这可以是管理在与 Operator 本身分开的命名空间中的操作数（Operand）的
    Operator，或者它可能仅仅需要管理存在于多个命名空间中的操作数（例如一个资源供应器，用户请求部署开发环境）。
- en: On the other hand, namespace-scoped Operators have some benefits. Specifically,
    restricting an Operator to a single namespace allows for easier debugging and
    failure isolation. It also allows for flexible installation (including installing
    multiples of the same Operator across multiple namespaces).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，命名空间作用域的 Operator 有一些优势。具体而言，将 Operator 限制在单个命名空间内便于调试和故障隔离。它还允许灵活的安装（包括在多个命名空间中安装多个相同的
    Operator）。
- en: The Operator's scope is ultimately defined by its CRD and access roles. Cluster-scoped
    custom resources are created outside of any specific namespace. This can be good
    for Operators that will only have one instance in a cluster (for example, Operators
    that manage core Kubernetes components, such as the API server). The access roles
    an Operator needs will usually follow the scope of the Operator's CRD.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 的作用域最终由其 CRD 和访问角色来定义。集群作用域的自定义资源在任何特定命名空间之外创建。这对于那些在集群中只会有一个实例的 Operator
    很有用（例如，管理核心 Kubernetes 组件的 Operator，如 API 服务器）。Operator 所需的访问角色通常会遵循其 CRD 的作用域。
- en: 'In summary, the resources we have covered here (Pods, ReplicaSets, Deployments,
    CRDs, RBAC, and namespaces) are only a few of the possible resources an Operator
    will depend on. However, they are the most common and likely the first ones you
    should consider when you''re designing your Operator''s cluster interactions.
    In the next section, we''ll look at the other side of an Operator''s interactions:
    how it interacts with humans.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们在这里介绍的资源（Pods、ReplicaSets、Deployments、CRDs、RBAC 和命名空间）只是 Operator 可能依赖的资源中的一小部分。然而，它们是最常见的，也是你在设计
    Operator 集群交互时应该首先考虑的资源。在下一节中，我们将讨论 Operator 交互的另一面：它如何与人类交互。
- en: Identifying users and maintainers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别用户和维护者
- en: The other way that an Operator interacts with Kubernetes is through its users.
    While Operators exist to automate many of the cluster interactions that are required
    by humans, the organic element in a Kubernetes cluster is still present. Users
    must still interact with the Operator somehow, and the ways that different users
    will want and need to engage in that interaction can influence an Operator's design.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 与 Kubernetes 交互的另一种方式是通过其用户。尽管 Operator 的存在是为了自动化许多人类所需的集群交互，但 Kubernetes
    集群中的有机元素依然存在。用户仍然必须以某种方式与 Operator 进行交互，而不同用户希望和需要如何进行这种交互，会影响 Operator 的设计。
- en: Therefore, it is important to identify what type of user your Operator is intended
    for; there are a few categories. Each category will have different needs and opinions
    on what their Operator should do. So, by identifying the target audience for your
    Operator, you can ensure that the Operator has been designed to appeal to the
    widest user base and fulfill the most use cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，识别你的 Operator 目标用户类型非常重要；它有几种不同的类别。每个类别对 Operator 的需求和看法都有所不同。因此，通过识别 Operator
    的目标用户，你可以确保 Operator 设计得足够吸引最广泛的用户群体，并满足最多的使用场景。
- en: 'For most Operators, the type of users that will be interacting with them can
    be broken into a couple of groups based on the level of access those users have
    in the cluster and the role those users play in the application at large. These
    user groups are usually as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数操作器，用户与之交互的类型可以根据这些用户在集群中的访问级别以及他们在整个应用程序中的角色分为几组。这些用户组通常如下：
- en: '**Cluster administrators**: The admin users of a cluster that are responsible
    for its maintenance and stability.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群管理员**：负责集群维护和稳定性的管理员用户。'
- en: '**Cluster users**: Individual users with internal access to a cluster, such
    as the engineers on a team.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群用户**：具有集群内部访问权限的个人用户，例如团队中的工程师。'
- en: '**End-users/customers**: The external users of a cluster for a public or enterprise
    product. These users don''t directly interact with a cluster, but they use the
    applications that run on the cluster.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终用户/客户**：公共或企业产品的集群外部用户。这些用户不会直接与集群互动，但他们使用运行在集群上的应用程序。'
- en: These types of users all have similar motivations and use cases, but also some
    stark differences. Thinking about each group individually helps highlight these
    comparisons.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的用户具有相似的动机和使用场景，但也存在一些明显的差异。逐个考虑每个群体有助于突显这些比较。
- en: Cluster administrators
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群管理员
- en: Cluster administrators are commonly the consumers of Operators. These are the
    users that have the most access to and knowledge about a cluster's architecture.
    As such, they require the most power and flexibility.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理员通常是操作器的使用者。他们是对集群架构拥有最多访问权限和知识的用户。因此，他们需要最大的权限和灵活性。
- en: Foremost, a cluster administrator's job is to ensure the stability of their
    cluster. This is why they need the broadest array of tools and controls at their
    disposal to modify cluster settings as necessary. But, as the saying goes, *with
    great power comes great responsibility*. In this case, an Operator can provide
    administrators with great power to run their cluster however they need to. But
    that power can backfire and harm the cluster if it doesn't work exactly as intended.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，集群管理员的工作是确保集群的稳定性。这就是为什么他们需要尽可能多的工具和控制权限来根据需要修改集群设置的原因。但正如俗话所说，*权力越大，责任越大*。在这种情况下，操作器可以为管理员提供极大的权限，以根据他们的需要运行集群。但如果操作器没有按预期工作，这种权力可能会适得其反，甚至损害集群。
- en: So, the developer of an Operator that is going to be used by cluster administrators
    may consider restricting its capabilities to a defined set that is known to be
    supportable. This can help them design the Operator so that it doesn't become
    *too powerful* and expose settings that can inadvertently damage the cluster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打算由集群管理员使用的操作器开发者可能会考虑将其功能限制在已知可以支持的定义集内。这可以帮助他们设计操作器，使其不会变得*过于强大*，从而暴露出可能会无意中损害集群的设置。
- en: However, if an administrator finds that their cluster is suddenly *on fire*
    or critically failing, they will need to fix that problem as soon as possible.
    If this is due to the component that an Operator is managing (or the Operator
    itself), then the administrator will require direct access to the Operator, Operand,
    or both. At times like this, a restricted feature set may hinder the recovery
    time to restore cluster stability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果管理员发现他们的集群突然*着火*或严重故障，他们将需要尽快修复这个问题。如果这是由于操作器正在管理的组件（或操作器本身）引起的，那么管理员将需要直接访问操作器、操作对象或两者。在这种情况下，受限的功能集可能会延迟恢复时间，从而影响集群的稳定性恢复。
- en: One benefit of developing Operators for cluster administrators is that they
    are very knowledgeable about their clusters and have high levels of internal access
    to them. This provides some trust that allows more powerful functionality to be
    created. Also, having homogenous consumers limits the different workflows that
    need to be supported in an Operator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为集群管理员开发操作器的一个好处是，他们对自己的集群非常了解，并且拥有很高的内部访问权限。这提供了一定的信任，使得可以创建更强大的功能。此外，拥有统一的用户群体可以限制操作器需要支持的不同工作流程。
- en: 'The following diagram shows the simple layout of an internal cluster administrator
    interacting with an Operator to manage the Operands in their cluster:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了一个内部集群管理员与操作器互动来管理其集群中操作对象的简单布局：
- en: '![Figure 2.3 – A single cluster administrator directly managing an Operator
    via its CRD](img/B18147_Figure_2.3.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 一位集群管理员通过其 CRD 直接管理操作器](img/B18147_Figure_2.3.jpg)'
- en: Figure 2.3 – A single cluster administrator directly managing an Operator via
    its CRD
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 单一集群管理员通过 CRD 直接管理 Operator
- en: Ultimately, it is up to the developers of the Operator to determine what to
    provide for the cluster administrators (if that is the target audience). Depending
    on the application the Operator is going to manage, it may make sense and be safe
    and limit the administrator's direct access to the Operand through the Operator.
    But if there is the potential for an Operand deployment to go haywire and require
    manual intervention, then emergency accessibility should be provided.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，由 Operator 的开发人员来决定为集群管理员提供什么功能（如果集群管理员是目标用户的话）。根据 Operator 管理的应用程序，限制管理员通过
    Operator 直接访问 Operand 可能是合理且安全的。但是，如果 Operand 部署可能会出错并需要手动干预，那么应提供紧急访问权限。
- en: Cluster users
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群用户
- en: The users of a cluster interact with the cluster but without the access and
    control of an administrator. For example, these could be developers working on
    a shared cluster who need certain resources to be deployed and destroyed on-demand.
    Provisioning development resources involves having users request those resources
    from the Operator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 集群的用户与集群进行交互，但不具备管理员的访问和控制权限。例如，这些可能是正在共享集群上工作的开发人员，他们需要按需部署和销毁某些资源。为开发资源提供服务涉及到用户从
    Operator 请求这些资源。
- en: Cluster users require less control over underlying cluster components. They
    also are less likely to be touching parts of a cluster and potentially breaking
    it. These are two reassurances for developing an Operator that helps limit the
    scope of features that must be supported by these users. Additionally, these users
    may have personal access to a cluster administrator if they require more than
    the Operator provides.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 集群用户对底层集群组件的控制要求较少。他们也不太可能接触到集群的某些部分，从而可能破坏集群。这两个因素为开发一个有助于限制这些用户支持的功能范围的 Operator
    提供了保证。此外，这些用户如果需要更多的功能，可以通过集群管理员获得个人访问权限。
- en: Cluster users may also interact with Operators through internal applications.
    It is not uncommon for organizations to deploy custom applications within their
    intranets. Using an internal application like this can provide a more user-friendly
    frontend for your cluster users. It also allows the cluster users' access to be
    restricted below the underlying Operator's actual capabilities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 集群用户也可能通过内部应用程序与 Operator 进行交互。对于组织来说，在内部网络中部署定制的应用程序并不罕见。使用这样的内部应用程序可以为集群用户提供更友好的前端界面，同时也可以将集群用户的访问权限限制在底层
    Operator 的实际能力范围内。
- en: 'The following diagram shows a setup where multiple internal users are using
    an Operator to provision resources in the cluster. Some of these users are interacting
    with the Operator directly, while others must go through an internal application
    to interact with the Operator (the Operator could even be managing this frontend
    application). With patterns like this, intra-organizational privilege hierarchies
    can be defined for working with the internal tools that are provided by Operators:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个多位内部用户使用 Operator 在集群中配置资源的设置。其中一些用户直接与 Operator 交互，而其他用户必须通过内部应用程序与
    Operator 交互（Operator 甚至可能在管理这个前端应用程序）。在这种模式下，可以为使用 Operator 提供的内部工具的跨组织特权层级定义规则：
- en: '![Figure 2.4 – Internal cluster users requesting resources, either directly
    from the Operator or via an intermediary internal application](img/B18147_Figure_2.4.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 内部集群用户请求资源，既可以直接通过 Operator，也可以通过中介的内部应用程序](img/B18147_Figure_2.4.jpg)'
- en: Figure 2.4 – Internal cluster users requesting resources, either directly from
    the Operator or via an intermediary internal application
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 内部集群用户请求资源，既可以直接通过 Operator，也可以通过中介的内部应用程序
- en: The options for exposing an Operator to internal cluster users are some of the
    most flexible. These users benefit from a level of trust and investment in the
    cluster's stability that's high enough that the risk of negligent or malicious
    behavior is mitigated. However, there is still a risk in exposing application
    management controls to a broader audience. So, you must think about this when
    you're designing the capabilities of your Operator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Operator 向内部集群用户开放的选项是非常灵活的。这些用户对于集群稳定性的信任和投入程度足够高，因此能有效降低疏忽或恶意行为的风险。然而，将应用程序管理控制权限暴露给更广泛的受众仍然存在一定的风险。因此，在设计
    Operator 的功能时，必须考虑这一点。
- en: End users and customers
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终用户和客户
- en: The end users of a product can also benefit from Operators. These users may
    not even know they are interacting with an Operator since the architectural design
    of the product is usually not apparent to everyday users. But it is still important
    to know how the users of a product will expect it to function, especially in this
    case, where we are designing a critical component of the product.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 产品的终端用户也可以从操作员中受益。这些用户可能甚至不知道他们正在与操作员互动，因为产品的架构设计通常对普通用户来说是不明显的。但了解产品用户期望其功能的方式仍然很重要，尤其是在我们设计产品关键组件的情况下。
- en: These end users will likely not be directly interacting with the Operator. This
    would mean that your users and customers have access to the Kubernetes cluster
    themselves, which is not ideal for security or usability. The customers of an
    application benefit from an interactive frontend, whether this is a website or
    mobile app. But that frontend is just a tool for interacting with a backend, which
    could be made up of many different components, including Operators.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些终端用户可能不会直接与操作员互动。这意味着您的用户和客户自己能够访问 Kubernetes 集群，这对于安全性或可用性来说并不理想。应用程序的客户受益于交互式前端，无论是网站还是移动应用。但这个前端仅仅是与后端进行交互的工具，而后端可能由许多不同的组件组成，包括操作员。
- en: 'In this case, your user might be yourself – that is, you (or your organization)
    will be developing the Operator but also probably developing the frontend applications
    that depend on it. In situations like this, cross-project collaboration is necessary
    to elaborate on the needs and expectations of each team. Operators in this kind
    of scenario will benefit the most from elegant API design that communicates easily
    with other programs, rather than human users:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您的用户可能就是您自己——也就是说，您（或您的组织）将开发操作员，同时也可能开发依赖于该操作员的前端应用程序。在这种情况下，跨项目的协作对于阐明每个团队的需求和期望至关重要。在这种场景下，操作员将从优雅的
    API 设计中受益最多，这种设计能更轻松地与其他程序进行通信，而非与人工用户互动：
- en: '![Figure 2.5 – External end users interacting with an Operator via an external-facing
    application](img/B18147_Figure_2.5.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 外部终端用户通过外部应用程序与操作员互动](img/B18147_Figure_2.5.jpg)'
- en: Figure 2.5 – External end users interacting with an Operator via an external-facing
    application
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 外部终端用户通过外部应用程序与操作员互动
- en: The end users of an application will usually be completely detached from interacting
    with an Operator. However, this doesn't mean that an application and its resources
    can't still be managed by one. In this scenario, the Operator is still an important
    and helpful tool for maintaining the state of the cluster that end users expect,
    even if those users don't need to know they are interacting with it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序的终端用户通常与操作员的互动是完全隔离的。然而，这并不意味着一个应用程序及其资源不能仍然由操作员进行管理。在这种情况下，操作员仍然是维护集群状态的重要且有用的工具，即使这些终端用户不需要知道他们正在与操作员互动。
- en: 'End users are the final type of users we''ll discuss that interact with your
    Operator in a functional capacity. However, there are other people we must consider
    when we''re designing an Operator: the people who maintain the Operator and its
    code.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 终端用户是我们将讨论的与操作员进行功能性互动的最终用户类型。然而，在设计操作员时，我们还必须考虑其他人：那些维护操作员及其代码的人。
- en: Maintainers
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护者
- en: The final type of user who will interact with your Operator does so in a different
    way than the other three. These are the maintainers of the project, who work on
    the code to resolve issues and implement new features. The role of a maintainer
    in any software project is an important one, but in an open source ecosystem such
    as Kubernetes, there are additional points to consider.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一类将与您的操作员互动的用户与前三类有所不同。这些是项目的维护者，他们处理代码以解决问题并实施新特性。在任何软件项目中，维护者的角色都很重要，但在像
    Kubernetes 这样的开源生态系统中，还有其他额外的考虑因素。
- en: If your Operator's source code is going to be open and accepting contributions
    from anyone, it will be essential to appoint trusted owners to review code changes.
    This is true for any open source project, but for an Operator, it is very beneficial
    that these reviewers are familiar with the core Kubernetes concepts that any Operator
    depends on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的操作员源代码将开放并接受任何人的贡献，那么任命受信任的负责人来审查代码更改将是至关重要的。这对于任何开源项目都是如此，但对于操作员而言，审查人员熟悉任何操作员所依赖的核心
    Kubernetes 概念将极为有利。
- en: From an enterprise perspective, investing in a reliable team of engineers to
    build and maintain an Operator provides a long-term incentive for your maintainers
    to continue building the Operator's source code. This also creates a level of
    trust between the maintainers of the Operator and its primary stakeholders. Ongoing
    maintenance for the Operator code base will be necessary, especially given the
    changing nature of the Kubernetes platform. Maintainers who are familiar with
    the Kubernetes community are an important addition to teams that use Operators.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从企业角度来看，投资建立一个可靠的工程师团队来构建和维护 Operator，为你的维护者提供了一个长期的动力，促使他们继续开发 Operator 的源代码。这也在
    Operator 的维护者与其主要利益相关者之间建立了信任关系。由于 Kubernetes 平台的不断变化，Operator 代码库的持续维护是必要的。熟悉
    Kubernetes 社区的维护者是使用 Operator 的团队中一个重要的补充。
- en: These are just a few of the types of users that your Operator may interact with.
    This list is by no means exhaustive, but it is intended to provoke thoughts about
    your user base. Identifying the type of user for an Operator helps narrow down
    what kind of features an Operator will need. It also provides a starting point
    for determining what features are necessary. In the next section, we'll look at
    some ideas for thinking about feature design that benefits users the most.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你的 Operator 可能与之互动的一些用户类型。这个列表并不详尽无遗，但目的是激发你对用户群体的思考。确定 Operator 的用户类型有助于缩小
    Operator 需要哪些功能的范围。它也为确定哪些功能是必要的提供了一个起点。在接下来的部分，我们将探讨一些有助于设计对用户最有利功能的思路。
- en: Designing beneficial features for your operator
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计对你的 Operator 有益的功能
- en: Once you've identified the target audience for your Operator, the next step
    is to define what the Operator will do. Listing the problems that must be solved
    by the Operator will give you a better understanding of the goals of the project.
    It will also highlight whether or not those goals provide a tangible, measurable
    benefit to your users.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了 Operator 的目标用户群，下一步就是定义 Operator 的功能。列出 Operator 必须解决的问题将帮助你更好地理解项目的目标。它还将突出这些目标是否为用户提供了切实、可衡量的收益。
- en: Figuring out what kind of functions are truly beneficial is hard to define.
    The exact definition of "helpful" is different on a case-by-case basis. Some beneficial
    Operators solve widespread headaches in a novel and intuitive way. Others address
    more niche problems that may only affect small communities of users, but the impact
    of eliminating those problems is significant. However, it is a bit easier to describe
    beneficial functions in terms of what is not useful.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 确定什么样的功能真正有益是很难界定的。“有帮助”的确切定义因案例而异。一些有益的 Operator 以新颖且直观的方式解决了广泛的难题。另一些则解决了更小众的问题，这些问题可能只影响小范围的用户社区，但消除这些问题的影响却是显著的。然而，描述有益功能时，从什么是不有用的方面来阐述会稍微容易一些。
- en: Foremost, useful Operators are not redundant. In specific examples, redundancy
    can mean a lot of different things. But it is fundamentally the essence of nonduplication
    that Operator designers should strive for. The most basic example of this is not
    rewriting an Operator that already exists elsewhere without having a sufficient
    reason to do so. Researching the proposed area of your Operator can prevent this.
    Researching the approaches that others have undertaken will also reveal potential
    pitfalls to avoid in the process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有用的 Operator 不是冗余的。在具体的示例中，冗余可能意味着很多不同的事情。但从根本上讲，Operator 设计者应该努力追求的是不重复的本质。最基本的例子是，不应该在没有充分理由的情况下重新编写一个已经存在的
    Operator。研究你提议的 Operator 所涉及的领域可以防止这种情况发生。研究其他人已经采取的方法也能揭示出在过程中需要避免的潜在陷阱。
- en: Operators can also be redundant in terms of Kubernetes concepts. Since an Operator
    is essentially interacting with the cluster and exposing some of that interaction
    to users, the Operator is an extension of Kubernetes. Because of this, it can
    be inadvertently tempting to "reinvent the wheel" when it comes to brainstorming
    functions for the Operator. This kind of functional redundancy can be related
    to the next issue we'll discuss, wherein developers try to address nonexistent
    problems.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 在 Kubernetes 概念上也可能是冗余的。由于 Operator 本质上是与集群进行交互并将一些交互暴露给用户，因此它是 Kubernetes
    的扩展。因此，在为 Operator 思考功能时，很容易不自觉地去“重新发明轮子”。这种功能性冗余可能与我们接下来要讨论的另一个问题相关，即开发人员试图解决不存在的问题。
- en: The next issue concerns beneficial tasks, which are not hypothetical. The world
    of software development benefits from many passionate engineers who are eager
    to fix the problems they run into. This zeal for contribution can extend to fixing
    potential issues, even if they have not been witnessed in practice. This is certainly
    a good mentality to have, and in no way should this kind of passion be stifled.
    There are, of course, many types of issues and bugs that can be identified and
    should be patched – hopefully before anyone runs into them in production. But
    occasionally, real solutions are proposed for purely theoretical problems.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题涉及有益的任务，这些任务并非假设性的。软件开发的世界从许多充满激情的工程师中受益，他们急于解决遇到的问题。对贡献的热情甚至可以延伸到解决潜在问题，即便这些问题尚未在实践中出现。这种对贡献的热情当然是一个很好的心态，绝不应当被压制。当然，确实存在许多类型的问题和
    bug 可以被发现并且应该被修复——希望是在生产环境中没有人遇到它们之前。但有时，针对纯粹理论性问题也会提出真实的解决方案。
- en: These hypothetical use cases may be proposed without any actual evidence that
    users are seeking such a solution. This can be tricky because sometimes, the use
    case seems obvious enough that it almost shouldn't necessitate any explicit demand.
    But when each new feature costs resources to implement and binds the maintainers
    to support it, paying close attention to silence can reveal unnecessary work.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些假设性的使用场景可能在没有实际证据表明用户需要这样的解决方案时被提出。这可能是个棘手的问题，因为有时，使用场景看起来足够明显，似乎不需要任何明确的需求。但当每个新特性都需要投入资源来实现，并且将维护人员绑定于支持它时，密切关注“沉默”可以揭示出不必要的工作。
- en: While there could be many breakthrough ideas for features, it is important to
    try to validate a feature's proposal with real demand. This type of research can
    also uncover redundancy in the idea and lead to more effective alternative solutions
    that already exist.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能会有许多突破性的特性创意，但验证特性提案是否有真实需求非常重要。这种类型的研究还可以揭示想法中的冗余，进而提出已经存在的、更有效的替代解决方案。
- en: There are, of course, an infinite number of criteria that could be used to define
    the usefulness of features. In the context of Kubernetes Operators, however, these
    are just some initial thoughts to get started with. By thinking about your Operator
    in terms of its benefits, and by asking "What makes this useful?" you can avoid
    excessive or unnecessary changes that will require maintenance later down the
    road.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有无限多的标准可以用来定义特性是否有用。然而，在 Kubernetes Operator 的上下文中，这些只是一些起步的初步想法。通过从它的益处角度考虑你的
    Operator，并问自己“这有什么用？”你可以避免进行过度或不必要的更改，这些更改日后可能需要维护。
- en: That foresight will come in handy as your Operator grows and evolves. Like most
    software, Operators are prone to changes over time, especially given their dependence
    on the upstream Kubernetes code base. In the next section, we'll learn how to
    prepare for and navigate these changes as they arrive.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种前瞻性思维将对你的 Operator 在发展和演进过程中非常有用。像大多数软件一样，Operators 随着时间的推移容易发生变化，尤其是它们依赖于上游的
    Kubernetes 代码库。在接下来的部分中，我们将学习如何为这些变化做好准备，并在变化到来时进行应对。
- en: Planning for changes in your Operator
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的 Operator 的变更做好规划。
- en: Over any software project's lifespan, changes will be made to the code base.
    These include bug fixes, refactors, new features, and old features being removed.
    This is true for Kubernetes, its subprojects, and projects that are built on the
    platform, such as Operators.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何软件项目的生命周期中，代码库都会发生变化。这些变化包括修复 bug、重构、添加新特性以及删除旧特性。这对 Kubernetes、其子项目以及建立在该平台上的项目（如
    Operators）都适用。
- en: 'While it''s impossible to predict the future of what your Operator will evolve
    into one day, there are a few ideas that can help you during the design phase
    to ease transitions and new developments later. These are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无法预测你的 Operator 将来会发展成什么样子，但在设计阶段有一些想法可以帮助你顺利过渡并应对之后的新发展。具体如下：
- en: Start small.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从小开始。
- en: Iterate effectively.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效迭代。
- en: Deprecate gracefully.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地弃用。
- en: These decisions have significant benefits in practice when you're maintaining
    an Operator. However, these are not definitive or strictly specific to Kubernetes
    Operators. Consider them as general suggestions for developing any software project.
    But here, we will be examining them in the context of writing an Operator.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你维护一个 Operator 时，这些决策在实践中会带来显著的好处。然而，这些并不是绝对的，也并非严格限定于 Kubernetes Operator。你可以将它们视为开发任何软件项目的一般建议。这里，我们将从编写
    Operator 的角度来审视这些建议。
- en: Starting small
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从小做起。
- en: When planning the original design for an Operator, considering how the Operator
    may change over time can prevent future challenges. Designing with growth in mind
    also helps limit the initial scope of the project so that it only covers essential
    purposes. This allows adequate resources to be allocated to the development of
    a strong first product that can be efficiently iterated over time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划 Operator 的原始设计时，考虑 Operator 随时间变化的可能性可以避免未来的挑战。以增长为导向的设计还可以帮助限制项目的初始范围，使其仅涵盖必要的目的。这使得能够为开发一个强大的首个产品分配足够的资源，并且该产品能够在时间上高效迭代。
- en: While it may seem like the best goal for developing an Operator is to start
    with as many features as possible, in reality, the opposite is often true. After
    all, one purpose of an Operator is to create a layer of abstraction between its
    users and the underlying cluster functions. By exposing too many options, you
    may lose the benefit of automation by requiring your users to understand more
    of the native Kubernetes cluster functionality. This also makes your users more
    vulnerable to changes in the Kubernetes platform that shouldn't directly affect
    them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来开发 Operator 的最佳目标是从尽可能多的功能开始，但实际上，往往相反。毕竟，Operator 的一个目的就是在用户和底层集群功能之间创建一个抽象层。暴露过多的选项可能会让你失去自动化的好处，因为这会要求用户理解更多的本地
    Kubernetes 集群功能。这也让你的用户在 Kubernetes 平台发生变化时更加脆弱，这些变化本不该直接影响他们。
- en: When you're deciding whether to add a feature to an Operator or not, think critically
    about the importance of the feature, as well as the risks and costs of implementing
    it. This goes back to the topics of avoiding redundancy and addressing hypothetical
    problems, which we looked at in the previous section. It also relates to the topic
    of deprecation, which we will cover shortly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否为 Operator 添加某个功能时，需批判性地思考该功能的重要性，以及实现它的风险和成本。这与避免冗余和解决假设性问题的主题相关，这些内容我们在上一节中已经探讨过。同时，这也与即将讨论的“弃用”主题相关。
- en: Ultimately, most of the time, it is better to lack features than to ship a complex
    and confusing Operator. Every new feature has maintenance costs and the potential
    to introduce bugs later. These are some of the biggest reasons for starting small
    and building as you listen to feedback from your users.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，大多数时候，缺乏功能比发布一个复杂且令人困惑的 Operator 更好。每新增一个功能都会带来维护成本，并且可能在后期引入漏洞。这些都是从小做起并根据用户反馈进行开发的最大原因之一。
- en: Iterating effectively
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效迭代
- en: Once you have a minimal set of features, it will eventually be necessary to
    add improvements. Fortunately, it is much easier to add new things than it is
    to take old things away.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了一组最小功能，最终就需要进行改进。幸运的是，添加新功能比移除旧功能要容易得多。
- en: You should actively seek feedback from users on what kind of features they need.
    This can be done in many ways, from maintaining an active presence online around
    your Operator and its related projects to implementing detailed usage metrics
    in the Operator's code. In addition, having an awareness of the broader Kubernetes
    project communities can help highlight upcoming changes in the underlying platform
    that you may want to support in your Operator.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该积极寻求用户对所需功能的反馈。这可以通过多种方式实现，从在 Operator 及其相关项目周围保持活跃的在线存在，到在 Operator 的代码中实施详细的使用度量。此外，了解更广泛的
    Kubernetes 项目社区也能帮助你关注潜在的底层平台变化，从而支持你的 Operator。
- en: As you add features, continue to monitor their usage to gauge their effectiveness.
    Keeping the guidelines for the initial design of an Operator, such as its user
    base and feature tips, in mind will also make sure that each new feature is just
    as effective as the original set of features you designed when you first built
    the Operator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在你添加功能的同时，继续监控它们的使用情况，以衡量它们的效果。牢记最初设计 Operator 时的指导方针，例如其用户群体和功能提示，也能确保每个新功能的效果与最初设计的功能集一样有效。
- en: Deprecating gracefully
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅地弃用
- en: One type of change that can be incredibly inconvenient for users is deprecation.
    Many aspects of large software projects inevitably have to be replaced or have
    their support dropped by official maintainers. With a minimal Operator design,
    the possibility of your users' experience having to be changed is also minimized.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一种对用户非常不便的变化是弃用。许多大型软件项目的部分功能不可避免地会被替换，或者官方维护者会停止对其的支持。通过最小化的 Operator 设计，你可以最大限度地减少用户体验被更改的可能性。
- en: Starting with a small design and thoughtful, effective iterations after that
    will help reduce the need to remove features. Unfortunately, it may be inevitable
    at some point. In this case, it is important to give users plenty of notice so
    that they have sufficient time to transition to an alternative, if applicable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从小范围的设计开始，并在此基础上进行深思熟虑的有效迭代，将有助于减少删除功能的需求。不幸的是，某些时候这一点可能是不可避免的。在这种情况下，重要的是提前给予用户足够的通知，以便他们有足够的时间过渡到替代方案（如果适用的话）。
- en: The Kubernetes community has defined policies for deprecation, which will be
    covered in detail [*Chapter 8*](B18147_08_ePub.xhtml#_idTextAnchor126), *Preparing
    for Ongoing Maintenance of Your Operator*. But these guidelines serve as a good
    template for your deprecation. Kubernetes users will be familiar with the timelines
    and processes for deprecation, so by remaining consistent with those processes,
    your users will benefit from a familiarity they already have.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes社区已经定义了废弃政策，这将在[*第8章*](B18147_08_ePub.xhtml#_idTextAnchor126)《为你的Operator准备持续维护》中详细介绍。尽管如此，这些指南作为废弃处理的良好模板仍然很有价值。Kubernetes用户对废弃的时间线和流程已经非常熟悉，因此，如果你遵循这些流程，你的用户将受益于他们已经熟悉的方式。
- en: Just as all good things must come to an end, so too must some good features
    be eventually retired. Fortunately, this is not a foreign concept to the Kubernetes
    community, which offers a well-established template for deprecation. As a responsible
    citizen of the open source community, you and your users will benefit from a respectful,
    considerate approach to removing and changing aspects of your project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有美好的事物都必须走到尽头一样，一些优秀的功能最终也必须被淘汰。幸运的是，对于Kubernetes社区来说，这并不是一个陌生的概念，它提供了一个成熟的废弃处理模板。作为开源社区的责任成员，你和你的用户将从一种尊重且体贴的方式中受益，这种方式有助于移除和更改项目中的某些方面。
- en: Keeping all these practices in mind during the design stage of an Operator will
    pay off by limiting the scope of the project. This allows resources to focus on
    building a stable tool that does not radically change over time. Users and maintainers
    will both benefit from this stability, as users can seamlessly work with different
    versions of the Operator without changing their workflows, and maintainers can
    invest long-term effort into growing the project and passing knowledge about it
    to others.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计Operator时，牢记这些实践将有助于限制项目的范围，从而让资源能够专注于构建一个稳定的工具，避免随时间剧烈变化。用户和维护者都能从这种稳定性中受益，用户能够在不改变工作流程的情况下，无缝使用不同版本的Operator，而维护者则可以投入长期精力，发展项目并将相关知识传授给他人。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter focused on the different ways in which an Operator can interact
    with a Kubernetes cluster. Besides the literal technical interactions between
    an Operator's code base and the cluster's native resources, we also explored some
    other interactions that are worth considering in an Operator's design. These include
    an Operator's users and an Operator's lifecycle over time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了Operator与Kubernetes集群互动的不同方式。除了Operator代码库与集群原生资源之间的字面技术交互外，我们还探讨了一些在设计Operator时值得考虑的其他交互。这些交互包括Operator的用户以及Operator随时间变化的生命周期。
- en: Kubernetes clusters comprise many different types of native resources. These
    are the fundamental building blocks of all the applications that are deployed
    on Kubernetes. Operators are no different in that sense compared to any other
    application, so they must be able to natively consume these resources. This chapter
    focused on breaking down a few Operator resources, including Pods, Deployments,
    CRDs, and RBAC policies, so that you know how to define how Operators consume
    them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群包含多种不同类型的原生资源。这些资源是所有部署在Kubernetes上的应用程序的基本构建块。从这一点来看，Operator与任何其他应用程序没有不同，它们必须能够原生地使用这些资源。本章重点介绍了几种Operator资源的分解，包括Pods、Deployments、CRDs和RBAC策略，以便你了解如何定义Operator如何使用这些资源。
- en: How humans interact with an Operator is one of the most important design concepts
    to consider. Operators are designed to work for humans by automating various tasks,
    but like any power tool that automates manual labor, they still require human
    input to operate and produce output for humans. Due to this, we discussed some
    of the types of users that your Operator can be built for and the unique needs
    and expectations of each type.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 人类与Operator的互动是设计时最重要的概念之一。Operator的设计目的是通过自动化各种任务为人类服务，但像任何自动化人工劳动的工具一样，它们仍然需要人为的输入来操作，并为人类生成输出。因此，我们讨论了为不同类型的用户构建Operator时需要考虑的各种用户类型及其独特的需求和期望。
- en: Finally, we covered some good approaches to feature design. To help you set
    up an Operator for success, we discussed ideas for drafting an initial design
    that provides tangible benefits to users. We then proposed some more concepts
    you should keep in mind as your Operator evolves.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了一些关于功能设计的好方法。为了帮助你成功搭建一个 Operator，我们讨论了制定初步设计的想法，以便为用户提供实际的好处。然后，我们提出了一些你在
    Operator 演化过程中需要记住的概念。
- en: In the next chapter, we'll apply these lessons to hands-on Operator design.
    We will begin by building a sample Operator, starting with designing for its CRD,
    API, and reconciliation loop. Here, we will begin building an actual Operator,
    which we will then code and deploy in the remainder of this book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将把这些知识应用到实际的 Operator 设计中。我们将从构建一个示例 Operator 开始，首先设计它的 CRD、API 和协调循环。在这里，我们将开始构建一个实际的
    Operator，并在本书的剩余部分进行编码和部署。
