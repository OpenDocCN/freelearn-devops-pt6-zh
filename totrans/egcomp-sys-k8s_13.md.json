["```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    metadata:\n      name: db-pv-claim-1\n    spec:\n      accessModes:\n        - ReadWriteOnce\n      resources:\n        requests:\n          storage: 5Gi\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: redis-configmap\n    data:\n      redis-config: |\n        dir /data\n        requirepass YOUR_PASSWORD\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: redis\n      name: redis\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: redis\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: redis\n    spec: \n    containers: \n          - name: redis\n    image: redis:6.2 \n    command: \n    - redis-server \n    - /redisconf/redis.conf \n    ports: \n    - containerPort: 6379 \n    resources: \n    limits: \n                cpu: \"0.2\"\n    memory: \"128Mi\" \n    volumeMounts: \n    - mountPath: \"/data\" \n    name: redis-storage \n    - mountPath: /redisconf \n              name: config\n          volumes:\n    - name: config \n    configMap: \n    name: redis-configmap \n    items: \n    - key: redis-config \n    path: redis.conf \n            - name: redis-storage\n    persistentVolumeClaim: \n                claimName: db-pv-claim-1\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        app: redis\n      name: redis\n    spec:\n      ports:\n      - port: 6379\n        protocol: TCP\n        targetPort: 6379\n      selector:\n        app: redis\n      type: ClusterIP\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    metadata:\n      name: db-pv-claim-2\n    spec:\n      accessModes:\n        - ReadWriteOnce\n      #storageClassName: your_driver\n      resources:\n        requests:\n          storage: 5Gi\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: mongo-configmap\n    data:\n      mongod-conf: |\n        dbpath=/var/lib/mongodb\n        logpath=/var/log/mongodb/mongodb.log\n        logappend=true\n        bind_ip = 0.0.0.0\n        port = 27017\n        journal=true\n        auth = true\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      labels:\n        app: mongo\n      name: mongo\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: mongo\n      template:\n        metadata:\n          labels:\n            app: mongo\n        spec:\n          containers:\n          - name: mongo\n            image: mongo:4.4\n            env:\n            - name: MONGO_INITDB_ROOT_USERNAME\n              value: \"admin\"\n            - name: MONGO_INITDB_ROOT_PASSWORD\n              value: \"YOUR_PASSWORD\"\n            - name: MONGO_INITDB_DATABASE\n              value: \"mydatabase\"\n            ports:\n            - containerPort: 27017\n            resources:\n              limits:\n                cpu: \"0.2\"\n                memory: \"200Mi\"\n            volumeMounts:\n            - mountPath: \"/data/db\"\n              name: mongo-storage\n            - mountPath: /mongoconf\n              name: config\n          volumes:\n            - name: config\n              configMap:\n                name: mongo-configmap\n                items:\n                - key: mongod-conf\n                  path: mongod.conf\n            - name: mongo-storage\n              persistentVolumeClaim:\n                claimName: db-pv-claim-2\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        app: mongo\n      name: mongo\n    spec:\n      ports:\n      - port: 27017\n        protocol: TCP\n        targetPort: 27017\n      selector:\n        app: mongo\n      type: ClusterIP\n    EOF\n    ```", "```\n<imported libraries>\n<app_initialization>\n<CORS configuration>\n\ndef redisCon():\n<return Redis connection object>\n\n@app.route(\"/client/<cid>/position\", methods=[\"POST\"])\ndef setPosition(cid):\n   <Call redisCon>\n   <Store of data in a Redis hash data type using \n    the fields cid,lat,lng\n    in the hash key named client:{cid}:position>\n   <set the expiration of the key>\n   <call the tracking-server in /client/{cid}/position\n    to store the position in Mongo>\n   return  {\"client_id\":cid,\"setPosition\":\"done\"}\n\n@app.route(\"/clients/positions/unit/<unit>/r/<radius>\"\n          ,methods=[\"GET\"])\ndef getPositions(unit,radius):\n   <Call redisCon>\n   <Search for client:*:position keys>\n      <Search the near geospacial index for\n       the current position>\n     <Add the position to data Array>\n   <Returns the near positions for each unit in JSON>\n    return jsonify({\"clients\":data})\n\n@app.route(\"/client/<cid>/stops\", methods=[\"POST\"])\ndef setStops(cid):\n   <Call redisCon>\n   <GET json values stops to set>\n   <Store the stops in the key client:{cid}:stops >\n    return jsonify({\"setStops\":\"done\"})\n<App initialization in port 3000>\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: gps-server\n      name: gps-server\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: gps-server\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: gps-server\n        spec:\n          containers:\n          - image: sergioarmgpl/gps_server\n            name: gps-server\n            imagePullPolicy: Always\n            env:\n            - name: REDIS_HOST\n              value: \"redis\"\n            - name: REDIS_AUTH\n              value: \"YOUR_PASSWORD\"\n            - name: ENDPOINT\n              value: \"http://tracking-server:3000\"          \n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: gps-server\n      name: gps-server-lb\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: gps-server\n      type: LoadBalancer\n    status:\n      loadBalancer: {}\n    EOF\n    ```", "```\n    $ GPS_SERVER_IP=\"$(kubectl get svc gps-server-lb  -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    ```", "```\n$ echo $GPS_SERVER_IP\n```", "```\n$ kubectl get svc gps-server-lb\n```", "```\n    $ curl -X POST -H \"Accept: application/json\" \\\n    -H \"Content-Type: application/json\" \\\n    --data '{\n        \"stops\":[\n        {\"name\":\"stop1\",\"lat\":1.633518,\"lng\": -90.591706},\n        {\"name\":\"stop2\",\"lat\":2.631566,\"lng\": -91.591529},\n        {\"name\":\"stop3\",\"lat\":3.635043,\"lng\": -92.589982}\n        ]\n    }' http://$GPS_SERVER_IP:3000/client/1/stops\n    ```", "```\n    {\"setStops\":\"done\"}\n    ```", "```\n<Imported libraries> \n<Application initialization> \n<CORS configuration> \n\ndef mongoCon():\n    <return Mongo connection with tracking collection set>  \n\n@app.route(\"/client/<cid>/position\", methods=[\"POST\"]) \ndef storePosition(cid): \n    <Get the position JSON values to store it \n     in the tracking collection> \n    <Get current time and store it using UTC> \n    <Call MongoCon function>\n    <Store data in the format:\n     {\"cid\":XX,\"lat\":XX,\"lng\":XX,\"ts\":XXXXXXX,\"dtxt\":XXXXXX}\n     Inside the tracking collection in the database \n     called mydatabase> \n    <return JSON {\"client_id\":cid,\"positionStored\":\"done\"}>\n\n@app.route(\"/client/<cid>/positions/s/<sdate>/e/<edate>\" \n           ,methods=[\"GET\"]) \ndef getPositions(cid,sdate,edate): \n    <Get the start date to query in the format\n     dd-mm-yy-HH:MM:SS and convert it into UTC>\n    <get the end date to query in the format\n    dd-mm-yy-HH:MM:SS and convert it into UTC>\n    <Call MongoCon function>\n    <Query the tracking collection to get the\n     tracking data for a unit\n     or truck between the time range> \n    <Return the positions in an array called data> \n    return jsonify({\"tracking\":data}) \n\n<App initialization in port 3000>\n```", "```\n    { \n        \"tracking\":[\n            {\"lat\":0.0,\"lng\":0.0,\"ts\":166666666\n            ,\"dtxt\":\"01-01-22-23:59:59\"}\n        ] \n    }\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: tracking-server\n      name: tracking-server\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: tracking-server\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: tracking-server\n        spec:\n          containers:\n          - image: sergioarmgpl/tracking_server\n            name: tracking-server\n            imagePullPolicy: Always\n            env:\n            - name: MONGO_URI\n              value: \"mongodb://admin:YOUR_PASSWORD@mongo/mydatabase?authSource=admin\"\n            - name: MONGO_DB\n              value: \"mydatabase\"\n            - name: TIMEZONE\n              value: \"America/Guatemala\"\n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: tracking-server\n      name: tracking-server\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: tracking-server\n      type: ClusterIP\n    status:\n      loadBalancer: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: tracking-server\n      name: tracking-server-lb\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: tracking-server\n      type: LoadBalancer\n    status:\n      loadBalancer: {}\n    EOF\n    ```", "```\n    $ TRACKING_SERVER_IP=\"$(kubectl get svc tracking-server-lb -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    ```", "```\n$ echo $TRACKING_SERVER_IP\n```", "```\n    $ sudo raspi-config\n    ```", "```\n    $ ifconfig -a\n    ```", "```\n    $ ssh YOUR_USER@RASPBERRY_IP\n    ```", "```\n    cgroup_memory=1 cgroup_enable=memory\n    ```", "```\n    $ sudo shutdown -r now\n    ```", "```\n    $ sudo raspi-config\n    ```", "```\n    $ curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\"--write-kubeconfig-mode 644\" sh -s -\n    ```", "```\n    $ kubectl get nodes\n    ```", "```\n<Imported libraries>\nwhile True:\n   <Set serial Device /dev/ttyACM0 with baud rate 9600>\n   ser=serial.Serial(device, baudrate=9600, timeout=0.5)\n   <Set the PynMEA2 reader>\n   <Read data from the device>\n\n   <Read for GRPMC lines>\n    <Extract latitude, longitude> \n    <Call /client/{cid}/position from GPS Server\n     To store the position in Redis>\n    <If cannot read data show\n     \"No GPS data to send\">\n```", "```\n$GPRMC,052326.00,V,,,,,,,,,,N*7D\n$GPVTG,,,,,,,,,N*30\n$GPGGA,052326.00,,,,,0,00,99.99,,,,,,*66\n$GPGSA,A,1,,,,,,,,,,,,,99.99,99.99,99.99*30\n$GPTXT,01,01,01,NMEA unknown msg*58\n$GPTXT,01,01,01,NMEA unknown msg*58\n$GPGSV,1,1,02,01,,,30,22,,,36*7C\n$GPGLL,,,,,052326.00,V,N*4A\n```", "```\n$GPRMC,054003.00,A,1437.91511,N,09035.52679,W,0.077,,020622,,,D*6D\n$GPVTG,,T,,M,0.077,N,0.142,K,D*21\n$GPGGA,054003.00,1437.91511,N,09035.52679,W,2,06,2.54,1668.7,M,-4.9,M,,0000*68\n$GPGSA,A,3,22,01,48,31,32,21,,,,,,,3.95,2.54,3.02*02\n$GPTXT,01,01,01,NMEA unknown msg*58\n$GPGSV,4,1,13,01,18,301,33,10,49,124,11,16,20,189,12,21,29,276,24*74\n$GPGSV,4,2,13,22,39,008,32,23,18,135,,25,19,052,11,26,47,169,09*79\n$GPGSV,4,3,13,27,02,204,18,31,64,342,30,32,35,037,29,46,43,252,*7A\n$GPGSV,4,4,13,48,47,250,30*40\n$GPGLL,1437.91511,N,09035.52679,W,054003.00,A,D*70\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Pod\n    metadata:\n      name: gps-reader\n    spec:\n      containers:\n      - image: sergioarmgpl/gps_reader\n        name: gpsreader\n        imagePullPolicy: Always\n        env:\n        - name: DEVICE\n          value: \"/dev/ttyACM0\"\n        - name: CLIENT_ID\n          value: \"1\"\n        - name: ENDPOINT\n          value: \"http://<GPS_SERVER_IP>:3000\"\n        securityContext:\n          privileged: true\n          capabilities:\n            add: [\"SYS_ADMIN\"]\n        volumeMounts:\n        - mountPath: /dev\n          name: dev-volume\n      volumes:\n      - name: dev-volume\n        hostPath:\n          path: /dev\n          type: Directory\n    EOF\n    ```", "```\n    $ kubectl logs pod/gps-reader -f\n    ```", "```\n<Response [200]>\n{'lat': 11.6318615, 'lng': -80.59205166666666, 'cid': '1'}\n```", "```\n<!DOCTYPE html>\n<html lang=\"en\"> \n<head> \n<Load Javascript libraries> \n<Load page styles>   \n<body>\n    <div id='map'></div> \n<script> \n    <Load Map in an initial GPS position>\n    var marker \n    var markers = [] \n    var osm = L.tileLayer( \n    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n    {  \n        <Set Open Street Map Initial \n        Configuration using Leaflet>\n    });  \n\n    osm.addTo(map);     \n    setInterval(() => {  \n        $.getJSON(\"URL\",\n        function(pos) {  \n            <Delete current markers> \n            <Get current positions for each unit or truck> \n            <For each position set a marker \n             in the map calling\n             the function markPosition> \n        });  \n    }, 5000);  \n\n    function markPosition(cid,lat,lng,near)  \n    {  \n        <Create a maker in the map with \n        Latitude, Longitude, Unit number and near destinies> \n    } \n</script> \n</body> \n</html>\n```", "```\n<!DOCTYPE html> \n<html lang=\"en\">  \n<head>  \n<Load Javascript libraries>  \n<Load page styles>    \n<body>\n    <form>\n        <input id=\"cid\" name=\"cid\"></input>\n        <input id=\"sdate\" name=\"sdate\"></input> \n        <input id=\"edate\" name=\"edate\"></input> \n        <button onclick=\"loadMap()\"></button> \n    </form> \n    <div id='map'></div> \n<script>  \n    <Load Map in an initial GPS position> \n    var tiles = L.tileLayer(  \n    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', \n    {   \n        <Set Open Street Map Initial  \n        Configuration using Leaflet> \n    }).addTo(map);   \n\n    function onEachFeature(feature, layer) { \n            <Set a popup with the line visualizing the route \n            of the vehicle> \n    } \n\n    var trip;\n\n    function loadMap(){ \n        $.getJSON(<DYNAMIC_URL>, function(pos) { \n            var coordinates = [];\n            <Creating an array with the coordinates \n            between the time range> \n            this.trip = { \n            <The array with the coordinates and fields \n            to visualize in the map> \n            }; \n            var tripLayer = L.geoJSON(this.trip, { \n                <Get the trip data and visualize it \n                into the map> \n            }).addTo(map); \n        }); \n    } \n</script>  \n</body> \n</html>\n```", "```\n<imported libraries>\n<app_initialization>\n<CORS configuration>\n@app.route(\"/\")\ndef map():\n   return render_template(<Render map.html\n                           Using environment variables) \n@app.route(\"/report\")\ndef report():\n   return render_template(<Render report.html\n                           using environment variables>)\n<Starting the application on port 3000>\n```", "```\n    $ cat <<EOF | kubectl apply -f - \n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: frontend\n      name: frontend\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: frontend\n      strategy: {}\n      template:\n        metadata:\n          creationTimestamp: null\n          labels:\n            app: frontend\n        spec:\n          containers:\n          - image: sergioarmgpl/frontend\n            name: tracking-server\n            imagePullPolicy: Always\n            env:\n            - name: LATITUDE\n              value: \"<YOUR_LATITUDE_COORDINATE>\"\n            - name: LONGITUDE\n              value: \"<YOUR_LONGITUDE_COORDINATE>\"\n            - name: GPS_SERVER\n              value: \"<YOUR_GPS_SERVER_IP>\"\n            - name: TRACKING_SERVER\n              value: \"<YOUR_TRACKING_SERVER_IP>\"\n            resources: {}\n    status: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: frontend\n      name: frontend-lb\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: frontend\n      type: LoadBalancer\n    status:\n    loadBalancer: {} \n    EOF\n    ```", "```\n    $ FRONTEND_IP=\"$(kubectl get svc frontend-lb  -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    ```", "```\n$ echo $FRONTEND_IP\n```"]