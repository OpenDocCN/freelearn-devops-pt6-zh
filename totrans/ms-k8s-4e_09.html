<html><head></head><body>
  <div id="_idContainer173" class="Basic-Text-Frame">
    <h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-413" class="chapterTitle">Packaging Applications</h1>
    <p class="normal">In this chapter, we are going to look into Helm, the popular Kubernetes package manager. Every successful and non-trivial platform must have a good packaging system. Helm was developed by Deis (acquired by Microsoft in April 2017) and later contributed to the Kubernetes project directly. It became a CNCF project in 2018. We will start by understanding the motivation for Helm, its architecture, and its components. Then, we’ll get hands-on and see how to use Helm and its charts within Kubernetes. That includes finding, installing, customizing, deleting, and managing charts. Last but not least, we’ll cover how to create your own charts and handle versioning, dependencies, and templating.</p>
    <p class="normal">The topics we will cover are as follows:</p>
    <ul>
      <li class="bulletList">Understanding Helm</li>
      <li class="bulletList">Using Helm</li>
      <li class="bulletList">Creating your own charts</li>
      <li class="bulletList">Helm alternatives</li>
    </ul>
    <h1 id="_idParaDest-414" class="heading-1">Understanding Helm</h1>
    <p class="normal">Kubernetes provides many ways to organize and orchestrate your containers at runtime, but it lacks a higher-level organization of grouping sets of images together. This is where Helm <a id="_idIndexMarker903"/>comes in. In this section, we’ll go over the motivation for Helm, its architecture, and its components. We will discuss Helm 3. You might still find Helm 2 in the wild, but its end of life was at the end of 2020.</p>
    <p class="normal">As you might recall, Kubernetes means helmsman or navigator in Greek. The Helm project took the nautical theme very seriously, as the project’s name implies. The main Helm concept is the chart. Just as nautical charts describe in detail an area in the sea or a coastal region, a Helm chart describes in detail all the parts of an application.</p>
    <p class="normal">Helm is designed to perform the following:</p>
    <ul>
      <li class="bulletList">Build charts<a id="_idIndexMarker904"/> from the ground up</li>
      <li class="bulletList">Bundle charts into archive files (<code class="inlineCode">.tgz</code>)</li>
      <li class="bulletList">Interact with repositories containing charts</li>
      <li class="bulletList">Deploy and remove charts in an existing Kubernetes cluster</li>
      <li class="bulletList">Handle the lifecycle of installed charts</li>
    </ul>
    <h2 id="_idParaDest-415" class="heading-2">The motivation for Helm</h2>
    <p class="normal">Helm provides support for<a id="_idIndexMarker905"/> several important use cases:</p>
    <ul>
      <li class="bulletList">Managing complexity</li>
      <li class="bulletList">Easy upgrades</li>
      <li class="bulletList">Simple sharing</li>
      <li class="bulletList">Safe rollbacks</li>
    </ul>
    <p class="normal">Charts can define even the most intricate applications, offer consistent application installation, and act as a central source of authority. In-place upgrades and custom hooks allow for easy updates. It’s simple to share charts that can be versioned and hosted on public or private servers. When you need to roll back recent upgrades, Helm provides a single command to roll back a cohesive set of changes to your infrastructure.</p>
    <h2 id="_idParaDest-416" class="heading-2">The Helm 3 architecture</h2>
    <p class="normal">The Helm 3 architecture<a id="_idIndexMarker906"/> relies fully on client-side tooling and keeps its state as Kubernetes secrets. Helm 3 has several components: release secrets, client, and library.</p>
    <p class="normal">The client is the command-line interface, and often a CI/CD pipeline is used to package and install applications. The client utilizes the Helm library to perform the requested operations, and the state of each deployed application is stored in a release secret.</p>
    <p class="normal">Let’s review the components.</p>
    <h3 id="_idParaDest-417" class="heading-3">Helm release secrets</h3>
    <p class="normal">Helm stores its releases as Kubernetes <a id="_idIndexMarker907"/>secrets in the target namespace. This means you can have multiple releases with the same name as long they are stored in different namespaces. Here is what a release secret looks like:</p>
    <pre class="programlisting gen"><code class="hljs">$ kubectl describe secret sh.helm.release.v1.prometheus.v1 -n monitoring
Name:         sh.helm.release.v1.prometheus.v1
Namespace:    monitoring
Labels:       modifiedAt=1659855458
name=prometheus
owner=helm
status=deployed
version=1
Annotations:  &lt;none&gt;
Type:  helm.sh/release.v1
Data
====
release:  51716 bytes
</code></pre>
    <p class="normal">The data is Base64-encoded twice and then GZIP-compressed.</p>
    <h3 id="_idParaDest-418" class="heading-3">The Helm client</h3>
    <p class="normal">You install the <a id="_idIndexMarker908"/>Helm client on your machine. Helm carries out the following tasks:</p>
    <ul>
      <li class="bulletList">Facilitating local chart development</li>
      <li class="bulletList">Managing repositories</li>
      <li class="bulletList">Overseeing releases</li>
      <li class="bulletList">Interacting with the Helm library for:<ul>
          <li class="bulletList">Deployment of new releases</li>
          <li class="bulletList">Upgrade of existing releases</li>
          <li class="bulletList">Removal of existing releases</li>
        </ul>
      </li>
    </ul>
    <h3 id="_idParaDest-419" class="heading-3">The Helm library</h3>
    <p class="normal">The Helm library<a id="_idIndexMarker909"/> is the component at the heart of Helm and is responsible for performing all the heavy lifting. The Helm library communicates with the Kubernetes API server and provides the following capabilities:</p>
    <ul>
      <li class="bulletList">Combining Helm charts, templates, and values files to build a release</li>
      <li class="bulletList">Installing the releases into Kubernetes</li>
      <li class="bulletList">Creating a release object</li>
      <li class="bulletList">Upgrading <a id="_idIndexMarker910"/>and uninstalling charts</li>
    </ul>
    <h2 id="_idParaDest-420" class="heading-2">Helm 2 vs Helm 3</h2>
    <p class="normal">Helm 2 was great and<a id="_idIndexMarker911"/> played a very important role in the Kubernetes ecosystem. But, there was a lot of criticism about Tiller, its server-side component. Helm 2 was designed and implemented before RBAC became the official access-control method. In the interest of usability, Tiller is installed by default with a very open set of permissions. It wasn’t easy to lock it down for production usage. This is especially challenging in multi-tenant clusters.</p>
    <p class="normal">The Helm team listened to the criticisms and came up with the Helm 3 design. Instead of the Tiller in-cluster component, Helm 3 utilizes the Kubernetes API server itself via CRDs to manage the state of releases. The bottom line is that Helm 3 is a client-only program. It can still manage releases and perform the same tasks as Helm 2, but without installing a server-side component.</p>
    <p class="normal">This approach is more Kubernetes-native and less complicated, and the security concerns are gone. Helm users can perform via Helm only as much as their kube config allows.</p>
    <h1 id="_idParaDest-421" class="heading-1">Using Helm</h1>
    <p class="normal">Helm is a rich<a id="_idIndexMarker912"/> package management system that lets you perform all the necessary steps to manage the applications installed on your cluster. Let’s roll up our sleeves and get going. We’ll look at installing both Helm 2 and Helm 3, but we will use Helm 3 for all of our hands-on experiments and demonstrations.</p>
    <h2 id="_idParaDest-422" class="heading-2">Installing Helm</h2>
    <p class="normal">Installing Helm involves installing<a id="_idIndexMarker913"/> the client and the server. Helm is implemented in Go. The Helm 2 executable can serve as either the client or server. Helm 3, as mentioned before, is a client-only program.</p>
    <h3 id="_idParaDest-423" class="heading-3">Installing the Helm client</h3>
    <p class="normal">You must have Kubectl <a id="_idIndexMarker914"/>configured properly to talk to your Kubernetes cluster because the Helm client uses the Kubectl configuration to talk to the Kubernetes API server.</p>
    <p class="normal">Helm provides binary releases for all platforms here: <a href="https://github.com/helm/helm/releases"><span class="url">https://github.com/helm/helm/releases</span></a>.</p>
    <p class="normal">For Windows, the <a id="_idIndexMarker915"/>Chocolatey (<a href="https://chocolatey.org"><span class="url">https://chocolatey.org</span></a>) package manager is the best option (usually up to date):</p>
    <pre class="programlisting gen"><code class="hljs">choco install kubernetes-helm
</code></pre>
    <p class="normal">For macOS and Linux, you can install the client from a script:</p>
    <pre class="programlisting gen"><code class="hljs">$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
$ chmod 700 get_helm.sh
$ ./get_helm.sh
</code></pre>
    <p class="normal">On macOS, you can also use<a id="_idIndexMarker916"/> Homebrew (<a href="https://brew.sh"><span class="url">https://brew.sh</span></a>):</p>
    <pre class="programlisting gen"><code class="hljs">brew install helm
$ helm version
version.BuildInfo{Version:"v3.9.2", GitCommit:"1addefbfe665c350f4daf868a9adc5600cc064fd", GitTreeState:"clean", GoVersion:"go1.18.4"}
</code></pre>
    <h2 id="_idParaDest-424" class="heading-2">Finding charts</h2>
    <p class="normal">To install useful<a id="_idIndexMarker917"/> applications and software with Helm, you need to find their charts first. Helm was designed to work with multiple repositories of charts. Helm 2 was configured to search the stable repository by default, but you could add additional repositories. Helm 3 comes with no default, but you can search the Helm Hub (<a href="https://artifacthub.io"><span class="url">https://artifacthub.io</span></a>) or specific repositories. The Helm Hub<a id="_idIndexMarker918"/> was launched in December 2018 and it was designed to make it easy to discover charts and repositories hosted outside the stable or incubator repositories.</p>
    <p class="normal">This is where the <code class="inlineCode">helm search</code> command comes in. Helm can search the Helm Hub for a specific repository.</p>
    <p class="normal">The hub contains 9,053 charts at the moment:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm search hub | wc -l
     9053
</code></pre>
    <p class="normal">We can search the hub<a id="_idIndexMarker919"/> for a specific keyword like <code class="inlineCode">mariadb</code>. Here are the first 10 charts (there are 38):</p>
    <pre class="programlisting gen"><code class="hljs">$ helm search hub mariadb --max-col-width 60 | head -n 10
URL                                                             CHART VERSION   APP VERSION DESCRIPTION
https://artifacthub.io/packages/helm/cloudnativeapp/mariadb     6.1.0           10.3.15     Fast, reliable, scalable, and easy to use open-source rel...
https://artifacthub.io/packages/helm/riftbit/mariadb            9.6.0           10.5.12     Fast, reliable, scalable, and easy to use open-source rel...
https://artifacthub.io/packages/helm/bitnami/mariadb            11.1.6          10.6.8      MariaDB is an open source, community-developed SQL databa...
https://artifacthub.io/packages/helm/bitnami-aks/mariadb        11.1.5          10.6.8      MariaDB is an open source, community-developed SQL databa...
https://artifacthub.io/packages/helm/camptocamp3/mariadb        1.0.0                       Fast, reliable, scalable, and easy to use open-source rel...
https://artifacthub.io/packages/helm/openinfradev/mariadb       0.1.1                       OpenStack-Helm MariaDB
https://artifacthub.io/packages/helm/sitepilot/mariadb          1.0.3           10.6        MariaDB chart for the Sitepilot platform.
https://artifacthub.io/packages/helm/groundhog2k/mariadb        0.5.0           10.8.3      A Helm chart for MariaDB on Kubernetes
https://artifacthub.io/packages/helm/nicholaswilde/mariadb      1.0.6           110.4.21    The open source relational database
</code></pre>
    <p class="normal">As you can see, there are several charts that match the keyword <code class="inlineCode">mariadb</code>. You can investigate those further and find the best one for your use case.</p>
    <h3 id="_idParaDest-425" class="heading-3">Adding repositories</h3>
    <p class="normal">By default, Helm 3 <a id="_idIndexMarker920"/>comes with no repositories set up, so you can search only the hub. In the past, the <code class="inlineCode">stable</code> repo hosted by the CNCF was a good option to look for charts. But, CNCF didn’t want to pay for hosting it, so now it just contains a lot of deprecated charts.</p>
    <p class="normal">Instead, you can either install charts from the hub or do some research and add individual repositories. For example, for Prometheus, there is the <code class="inlineCode">prometheus-community</code> Helm repository. Let’s add it:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
"prometheus-community" has been added to your repositories
</code></pre>
    <p class="normal">Now, we <a id="_idIndexMarker921"/>can search the <code class="inlineCode">prometheus</code> repo:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm search repo prometheus
NAME                                                CHART VERSION   APP VERSION DESCRIPTION                                                                                                                       test | default
prometheus-community/kube-prometheus-stack          39.4.1          0.58.0      kube-prometheus-stack collects Kubernetes manif...
prometheus-community/prometheus                     15.12.0         2.36.2      Prometheus is a monitoring system and time seri...
prometheus-community/prometheus-adapter             3.3.1           v0.9.1      A Helm chart for k8s prometheus adapter
prometheus-community/prometheus-blackbox-exporter   6.0.0           0.20.0      Prometheus Blackbox Exporter
prometheus-community/prometheus-cloudwatch-expo...  0.19.2          0.14.3      A Helm chart for prometheus cloudwatch-exporter
prometheus-community/prometheus-conntrack-stats...  0.2.1           v0.3.0      A Helm chart for conntrack-stats-exporter
prometheus-community/prometheus-consul-exporter     0.5.0           0.4.0       A Helm chart for the Prometheus Consul Exporter
prometheus-community/prometheus-couchdb-exporter    0.2.0           1.0         A Helm chart to export the metrics from couchdb...
prometheus-community/prometheus-druid-exporter      0.11.0          v0.8.0      Druid exporter to monitor druid metrics with Pr...
prometheus-community/prometheus-elasticsearch-e...  4.14.0          1.5.0       Elasticsearch stats exporter for Prometheus
prometheus-community/prometheus-json-exporter       0.2.3           v0.3.0      Install prometheus-json-exporter
prometheus-community/prometheus-kafka-exporter      1.6.0           v1.4.2      A Helm chart to export the metrics from Kafka i...
prometheus-community/prometheus-mongodb-exporter    3.1.0           0.31.0      A Prometheus exporter for MongoDB metrics
prometheus-community/prometheus-mysql-exporter      1.9.0           v0.14.0     A Helm chart for prometheus mysql exporter with...
prometheus-community/prometheus-nats-exporter       2.9.3           0.9.3       A Helm chart for prometheus-nats-exporter
prometheus-community/prometheus-node-exporter       3.3.1           1.3.1       A Helm chart for prometheus node-exporter
prometheus-community/prometheus-operator            9.3.2           0.38.1      DEPRECATED - This chart will be renamed. See ht...
prometheus-community/prometheus-pingdom-exporter    2.4.1           20190610-1  A Helm chart for Prometheus Pingdom Exporter
prometheus-community/prometheus-postgres-exporter   3.1.0           0.10.1      A Helm chart for prometheus postgres-exporter
prometheus-community/prometheus-pushgateway         1.18.2          1.4.2       A Helm chart for prometheus pushgateway
prometheus-community/prometheus-rabbitmq-exporter   1.3.0           v0.29.0     Rabbitmq metrics exporter for prometheus
prometheus-community/prometheus-redis-exporter      5.0.0           1.43.0      Prometheus exporter for Redis metrics
prometheus-community/prometheus-snmp-exporter       1.1.0           0.19.0      Prometheus SNMP Exporter
prometheus-community/prometheus-stackdriver-exp...  4.0.0           0.12.0      Stackdriver exporter for Prometheus
prometheus-community/prometheus-statsd-exporter     0.5.0           0.22.7      A Helm chart for prometheus stats-exporter
prometheus-community/prometheus-to-sd               0.4.0           0.5.2       Scrape metrics stored in prometheus format and ...
prometheus-community/alertmanager                   0.19.0          v0.23.0     The Alertmanager handles alerts sent by client ...
prometheus-community/kube-state-metrics             4.15.0          2.5.0       Install kube-state-metrics to generate and expo...
prometheus-community/prom-label-proxy               0.1.0           v0.5.0      A proxy that enforces a given label in a given ...
</code></pre>
    <p class="normal">There are quite <a id="_idIndexMarker922"/>a few charts there. To get more information about a specific chart, we can use the <code class="inlineCode">show</code> command (you can use the <code class="inlineCode">inspectalias</code> command too). Let’s check out <code class="inlineCode">prometheus-community/prometheus</code>:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm show chart prometheus-community/prometheus 
apiVersion: v2
appVersion: 2.36.2
dependencies:
- condition: kubeStateMetrics.enabled
  name: kube-state-metrics
  repository: https://prometheus-community.github.io/helm-charts
  version: 4.13.*
description: Prometheus is a monitoring system and time series database.
home: https://prometheus.io/
icon: https://raw.githubusercontent.com/prometheus/prometheus.github.io/master/assets/prometheus_logo-cb55bb5c346.png
maintainers:
- email: gianrubio@gmail.com
  name: gianrubio
- email: zanhsieh@gmail.com
  name: zanhsieh
- email: miroslav.hadzhiev@gmail.com
  name: Xtigyro
- email: naseem@transit.app
  name: naseemkullah
name: prometheus
sources:
- https://github.com/prometheus/alertmanager
- https://github.com/prometheus/prometheus
- https://github.com/prometheus/pushgateway
- https://github.com/prometheus/node_exporter
- https://github.com/kubernetes/kube-state-metrics
type: application
version: 15.12.0
</code></pre>
    <p class="normal">You can also<a id="_idIndexMarker923"/> ask Helm to show you the <code class="inlineCode">README</code> file, the values, or all the information associated with a chart. This can be overwhelming at times.</p>
    <h2 id="_idParaDest-426" class="heading-2">Installing packages</h2>
    <p class="normal">OK. You’ve found <a id="_idIndexMarker924"/>the package of your dreams. Now, you probably want to install it on your Kubernetes cluster. When you install a package, Helm creates a release that you can use to keep track of the installation progress. We install <code class="inlineCode">prometheus</code> using the <code class="inlineCode">helm install</code> command in the monitoring namespace and instruct Helm to create the namespace for us:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm install prometheus prometheus-community/prometheus -n monitoring --create-namespace
</code></pre>
    <p class="normal">Let’s go over the output. The first part of the output lists the name of the release that we provided, <code class="inlineCode">prometheus</code>, when it was deployed, the namespace, and the revision:</p>
    <pre class="programlisting gen"><code class="hljs">NAME: prometheus
LAST DEPLOYED: Sat Aug  6 23:54:50 2022
NAMESPACE: monitoring
STATUS: deployed
REVISION: 1
TEST SUITE: None
</code></pre>
    <p class="normal">The next part is custom notes, which can be pretty wordy. There is a lot of good information here about how to connect to the Prometheus server, the alert manager, and the <code class="inlineCode">Pushgateway</code>:</p>
    <pre class="programlisting gen"><code class="hljs">NOTES:
The Prometheus server can be accessed via port 80 on the following DNS name from within your cluster:
prometheus-server.default.svc.cluster.local
Get the Prometheus server URL by running these commands in the same shell:                                                                                        test | default
  export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus,component=server" -o jsonpath="{.items[0].metadata.name}")
  kubectl --namespace default port-forward $POD_NAME 9090
The Prometheus alertmanager can be accessed via port 80 on the following DNS name from within your cluster:
prometheus-alertmanager.default.svc.cluster.local
Get the Alertmanager URL by running these commands in the same shell:
  export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus,component=alertmanager" -o jsonpath="{.items[0].metadata.name}")
  kubectl --namespace default port-forward $POD_NAME 9093
#################################################################################
######   WARNING: Pod Security Policy has been moved to a global property.  #####
######            use .Values.podSecurityPolicy.enabled with pod-based      #####
######            annotations                                               #####
######            (e.g. .Values.nodeExporter.podSecurityPolicy.annotations) #####
#################################################################################
The Prometheus PushGateway can be accessed via port 9091 on the following DNS name from within your cluster:
prometheus-pushgateway.default.svc.cluster.local
Get the PushGateway URL by running these commands in the same shell:
  export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus,component=pushgateway" -o jsonpath="{.items[0].metadata.name}")
  kubectl --namespace default port-forward $POD_NAME 9091
For more information on running Prometheus, visit:
https://prometheus.io/
</code></pre>
    <h3 id="_idParaDest-427" class="heading-3">Checking the installation status</h3>
    <p class="normal">Helm doesn’t wait for<a id="_idIndexMarker925"/> the installation to complete because it may take a while. The <code class="inlineCode">helm status</code> command displays the latest information on a release in the same format as the output of the initial <code class="inlineCode">helm install</code> command. </p>
    <p class="normal">If you just care about the status without all the extra information, you can just <code class="inlineCode">grep</code> for the <code class="inlineCode">STATUS</code> line:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm status -n monitoring prometheus | grep STATUS
STATUS: deployed
</code></pre>
    <p class="normal">Let’s list all the Helm releases in the <code class="inlineCode">monitoring</code> namespace and verify that <code class="inlineCode">prometheus</code> is listed:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm list -n monitoring
NAME        NAMESPACE   REVISION    UPDATED                                 STATUS      CHART               APP VERSION
prometheus  monitoring  1           2022-08-06 23:57:34.124225 -0700 PDT    deployed    prometheus-15.12.0  2.36.2
</code></pre>
    <p class="normal">As you recall, Helm stores the release information in a secret:</p>
    <pre class="programlisting gen"><code class="hljs">$ kubectl describe secret sh.helm.release.v1.prometheus.v1 -n monitoring
Name:         sh.helm.release.v1.prometheus.v1
Namespace:    monitoring
Labels:       modifiedAt=1659855458
              name=prometheus
              owner=helm
              status=deployed
              version=1
Annotations:  &lt;none&gt;
Type:  helm.sh/release.v1
Data
====
release:  51716 bytes
</code></pre>
    <p class="normal">If you want to find all the Helm releases across all namespaces, use:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm list -A
</code></pre>
    <p class="normal">If you want to go low-level, you can list all the secrets that have the <code class="inlineCode">owner=helm</code> label:</p>
    <pre class="programlisting gen"><code class="hljs">$ kubectl get secret -A -l owner=helm
</code></pre>
    <p class="normal">To actually extract the release data from a secret, you need to jump through some hoops as it is Base64-encoded twice (why?) and GZIP-compressed. The final result is JSON:</p>
    <pre class="programlisting gen"><code class="hljs">kubectl get secret sh.helm.release.v1.prometheus.v1 -n monitoring -o jsonpath='{.data.release}' | base64 --decode | base64 --decode | gunzip &gt; prometheus.v1.json
</code></pre>
    <p class="normal">You may also be <a id="_idIndexMarker926"/>interested in extracting just the manifests using the following command:</p>
    <pre class="programlisting gen"><code class="hljs">kubectl get secret sh.helm.release.v1.prometheus.v1 -n monitoring -o jsonpath='{.data.release}' | base64 --decode | base64 --decode | gunzip | jq .manifest -r
</code></pre>
    <h3 id="_idParaDest-428" class="heading-3">Customizing a chart</h3>
    <p class="normal">Very often as a <a id="_idIndexMarker927"/>user, you want to customize or configure the charts you install. Helm fully supports customization via config files. To learn about possible customizations, you can use the <code class="inlineCode">helm show</code> command again, but this time, focus on the values. For a complex project like Prometheus, the <code class="inlineCode">values</code> file can be pretty large:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm show values prometheus-community/prometheus | wc -l
    1901
</code></pre>
    <p class="normal">Here is a partial output:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm show values prometheus-community/prometheus | head -n 20
rbac:
  create: true
podSecurityPolicy:
  enabled: false
imagePullSecrets:
# - name: "image-pull-secret"
## Define serviceAccount names for components. Defaults to component's fully qualified name.
##
serviceAccounts:
  alertmanager:
    create: true
    name:
    annotations: {}
  nodeExporter:
    create: true
    name:
    annotations: {}
</code></pre>
    <p class="normal">Commented-out lines often contain default values like the name of the <code class="inlineCode">imagePullSecrets</code>:</p>
    <pre class="programlisting gen"><code class="hljs">imagePullSecrets:
# - name: "image-pull-secret"
</code></pre>
    <p class="normal">If you want to customize any part of the Prometheus installation, then save the values to a file, make any modifications you like, and then install Prometheus using the custom values file:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm install prometheus prometheus-community/prometheus --create-namespace -n monitoring -f custom-values.yaml
</code></pre>
    <p class="normal">You can also set<a id="_idIndexMarker928"/> individual values on the command line with <code class="inlineCode">--set</code>. If both <code class="inlineCode">-f</code> and <code class="inlineCode">--set</code> try to set the same values, then <code class="inlineCode">--set</code> takes precedence. You can specify multiple values using comma-separated lists: <code class="inlineCode">--set a=1,b=2</code>. Nested values can be set as <code class="inlineCode">--set outer.inner=value</code>.</p>
    <h3 id="_idParaDest-429" class="heading-3">Additional installation options</h3>
    <p class="normal">The <code class="inlineCode">helm install</code> command <a id="_idIndexMarker929"/>can work with a variety of sources:</p>
    <ul>
      <li class="bulletList">A chart repository (as demonstrated)</li>
      <li class="bulletList">A local chart archive (<code class="inlineCode">helm install foo-0.1.1.tgz</code>)</li>
      <li class="bulletList">An extracted chart directory (<code class="inlineCode">helm install path/to/foo</code>)</li>
      <li class="bulletList">A complete URL (<code class="inlineCode">helm install https://example.com/charts/foo-1.2.3.tgz</code>)</li>
    </ul>
    <h3 id="_idParaDest-430" class="heading-3">Upgrading and rolling back a release</h3>
    <p class="normal">You may want to <a id="_idIndexMarker930"/>upgrade a package you installed to the latest and greatest version. Helm provides the <code class="inlineCode">upgrade</code> command, which operates intelligently and only updates things that have changed. For example, let’s check the current values of our <code class="inlineCode">prometheus</code> installation:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm get values prometheus -n monitoring
USER-SUPPLIED VALUES:
null
</code></pre>
    <p class="normal">So far, we haven’t provided any user values. As part of the default installation, <code class="inlineCode">prometheus</code> installed an alert manager component:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get deploy prometheus-alertmanager -n monitoring
NAME                      READY   UP-TO-DATE   AVAILABLE   AGE
prometheus-alertmanager   1/1     1            1           19h 
</code></pre>
    <p class="normal">Let’s disable the alert manager by upgrading and passing a new value:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm upgrade --set alertmanager.enabled=false \
     prometheus prometheus-community/prometheus \
     -n monitoring
Release "prometheus" has been upgraded. Happy Helming!
NAME: prometheus
LAST DEPLOYED: Sun Aug  7 19:55:52 2022
NAMESPACE: monitoring
STATUS: deployed
REVISION: 2
TEST SUITE: None
NOTES:
...     
</code></pre>
    <p class="normal">The upgrade completed successfully. We <a id="_idIndexMarker931"/>can see that the output doesn’t mention how to get the URL of the alert manager anymore. Let’s verify that the alert manager deployment was removed:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get deployment -n monitoring
NAME                            READY   UP-TO-DATE   AVAILABLE   AGE
prometheus-kube-state-metrics   1/1     1            1           20h
prometheus-pushgateway          1/1     1            1           20h
prometheus-server               1/1     1            1           20h
</code></pre>
    <p class="normal">Now, if we check the custom values, we can see our modification:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm get values prometheus -n monitoring
USER-SUPPLIED VALUES:
alertmanager:
  enabled: false
</code></pre>
    <p class="normal">Suppose we decide that alerts <a id="_idIndexMarker932"/>are kind of important and, actually, we want to have the Prometheus alert manager. No problem, we can roll back to our original installation. The <code class="inlineCode">helm history</code> command shows us all the available revisions we can roll back to:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm history prometheus -n monitoring
REVISION    UPDATED                     STATUS      CHART               APP VERSION DESCRIPTION
1           Sat Aug  6 23:57:34 2022    superseded  prometheus-15.12.0  2.36.2      Install complete
2           Sun Aug  7 19:55:52 2022    deployed    prometheus-15.12.0  2.36.2      Upgrade complete
</code></pre>
    <p class="normal">Let’s roll back to revision 1:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm rollback prometheus 1 -n monitoring
Rollback was a success! Happy Helming!
$ helm history prometheus -n monitoring
REVISION    UPDATED                     STATUS      CHART           APP VERSION DESCRIPTION
REVISION    UPDATED                     STATUS      CHART               APP VERSION DESCRIPTION
1           Sat Aug  6 23:57:34 2022    superseded  prometheus-15.12.0  2.36.2      Install complete
2           Sun Aug  7 19:55:52 2022    superseded  prometheus-15.12.0  2.36.2      Upgrade complete
3           Sun Aug  7 20:02:30 2022    deployed    prometheus-15.12.0  2.36.2      Rollback to 1
</code></pre>
    <p class="normal">As you can see, the rollback actually created a new revision number 3. Revision 2 is still there in case we want to go back to it.</p>
    <p class="normal">Let’s verify<a id="_idIndexMarker933"/> that our changes were rolled back:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get deployment -n monitoring
NAME                            READY   UP-TO-DATE   AVAILABLE   AGE
prometheus-alertmanager         1/1     1            1           152m
prometheus-kube-state-metrics   1/1     1            1           22h
prometheus-pushgateway          1/1     1            1           22h
prometheus-server               1/1     1            1           22h
</code></pre>
    <p class="normal">Yep. The alert manager is back.</p>
    <h3 id="_idParaDest-431" class="heading-3">Deleting a release</h3>
    <p class="normal">You can, of<a id="_idIndexMarker934"/> course, uninstall a release too by using the <code class="inlineCode">helm uninstall</code> command.</p>
    <p class="normal">First, let’s examine the list of releases. We have only the <code class="inlineCode">prometheus</code> release in the monitoring namespace:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm list -n monitoring
NAME        NAMESPACE   REVISION    UPDATED                                 STATUS      CHART               APP VERSION
prometheus  monitoring  3           2022-08-07 20:02:30.270229 -0700 PDT    deployed    prometheus-15.12.0  2.36.2
</code></pre>
    <p class="normal">Now, let’s uninstall it. You can use any of the following equivalent commands:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">uninstall</code></li>
      <li class="bulletList"><code class="inlineCode">un</code></li>
      <li class="bulletList"><code class="inlineCode">delete</code></li>
      <li class="bulletList"><code class="inlineCode">del</code></li>
    </ul>
    <p class="normal">Here we are using the <code class="inlineCode">uninstall</code> command:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm uninstall prometheus -n monitoring
release "prometheus" uninstalled
</code></pre>
    <p class="normal">With that, there are no more releases:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm list -n monitoring
NAME    NAMESPACE   REVISION    UPDATED STATUS  CHART   APP VERSION
</code></pre>
    <p class="normal">Helm can keep track of uninstalled releases too. If you provide <code class="inlineCode">--keep-history</code> when you uninstall, then you’ll be able to see uninstalled releases by adding the <code class="inlineCode">--all</code> or <code class="inlineCode">--uninstalled</code> flags to <code class="inlineCode">helm list</code>.</p>
    <p class="normal">Note that the <a id="_idIndexMarker935"/>monitoring namespace remained even though it was created by Helm as part of installing Prometheus, but it is empty now:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get all -n monitoring
No resources found in monitoring namespace.
</code></pre>
    <h2 id="_idParaDest-432" class="heading-2">Working with repositories</h2>
    <p class="normal">Helm stores charts in <a id="_idIndexMarker936"/>repositories that are simple HTTP servers. Any standard HTTP server can host a Helm repository. In the cloud, the Helm team verified that AWS S3 and Google Cloud Storage can both serve as Helm repositories in web-enabled mode. You can even store Helm repositories on GitHub pages.</p>
    <p class="normal">Note that Helm doesn’t provide tools for uploading charts to remote repositories because that would require the remote server to understand Helm, know where to put the chart, and know how to update the <code class="inlineCode">index.yaml</code> file.</p>
    <div class="note">
      <p class="normal">Note that Helm recently added experimental support for storing Helm charts in OCI registries. Check out <a href="https://helm.sh/docs/topics/registries/"><span class="url">https://helm.sh/docs/topics/registries/</span></a> for more details.</p>
    </div>
    <p class="normal">On the client<a id="_idIndexMarker937"/> side, the <code class="inlineCode">helm repo</code> command lets you list, add, remove, index, and update:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm repo
This command consists of multiple subcommands to interact with chart repositories.
It can be used to add, remove, list, and index chart repositories.
Usage:
  helm repo [command]
Available Commands:
  add         add a chart repository
  index       generate an index file given a directory containing packaged charts
  list        list chart repositories
  remove      remove one or more chart repositories
  update      update information of available charts locally from chart repositories
</code></pre>
    <p class="normal">We already used the <code class="inlineCode">helm repo add</code> and <code class="inlineCode">helm repo list</code> commands earlier. Let’s see how to create our own charts and manage them.</p>
    <h2 id="_idParaDest-433" class="heading-2">Managing charts with Helm</h2>
    <p class="normal">Helm<a id="_idIndexMarker938"/> provides <a id="_idIndexMarker939"/>several commands to manage charts.</p>
    <p class="normal">It can create a new chart for you:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm create cool-chart
Creating cool-chart
</code></pre>
    <p class="normal">Helm will create the following files and directories under <code class="inlineCode">cool-chart</code>:</p>
    <pre class="programlisting gen"><code class="hljs">$ tree cool-chart
cool-chart
├── Chart.yaml
├── charts
├── templates
│  ├── _helpers.tpl
│  ├── deployment.yaml
│  ├── hpa.yaml
│  ├── ingress.yaml
│  ├── NOTES.txt
│  ├── service.yaml
│  ├── serviceaccount.yaml
│  └── tests
│     └── test-connection.yaml
</code></pre>
    <p class="normal">Once you have edited your chart, you can package it into a <code class="inlineCode">tar.gz</code> archive:</p>
    <pre class="programlisting gen"><code class="hljs">     $ helm package cool-chart
Successfully packaged chart and saved it to: cool-chart-0.1.0.tgz
</code></pre>
    <p class="normal">Helm will create an archive called <code class="inlineCode">cool-chart-0.1.0.tgz</code> and store it in the local directory.</p>
    <p class="normal">You<a id="_idIndexMarker940"/> can also use <code class="inlineCode">helm lint</code> to help you find issues with your chart’s formatting or<a id="_idIndexMarker941"/> information:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm lint cool-chart
==&gt; Linting cool-chart
[INFO] Chart.yaml: icon is recommended
1 chart(s) linted, 0 chart(s) failed
</code></pre>
    <h3 id="_idParaDest-434" class="heading-3">Taking advantage of starter packs</h3>
    <p class="normal">The <code class="inlineCode">helm create</code> command offers an optional <code class="inlineCode">--starter</code> flag, allowing you to specify a starter chart. Starters are <a id="_idIndexMarker942"/>regular charts located in <code class="inlineCode">$XDG_DATA_HOME/helm/starters</code>. As a chart developer, you can create charts explicitly intended to serve as starter templates for creating new charts. When developing such charts, please keep the following considerations in mind:</p>
    <ul>
      <li class="bulletList">The YAML content within a starter chart will be overwritten by the generator.</li>
      <li class="bulletList">Users will typically modify the contents of a starter chart, so it is crucial to provide clear documentation explaining how users can make modifications.</li>
    </ul>
    <p class="normal">Presently, there is no built-in mechanism for installing starter charts. The only way to add a chart to <code class="inlineCode">$XDG_DATA_HOME/helm/starters</code> is through manual copying. If you create starter pack charts, ensure that your chart’s documentation explicitly mentions this requirement. </p>
    <h1 id="_idParaDest-435" class="heading-1">Creating your own charts</h1>
    <p class="normal">A chart<a id="_idIndexMarker943"/> represents a group of files that define a cohesive set of Kubernetes resources. It can range from a simple deployment of a Memcached pod to a complex configuration of a complete web application stack, including HTTP servers, databases, caches, queues, and more.</p>
    <p class="normal">To organize a chart, its files are structured within a specific directory tree. These files can then be bundled into versioned archives, which can be easily deployed and managed. The key file is <code class="inlineCode">Chart.yaml</code>.</p>
    <h2 id="_idParaDest-436" class="heading-2">The Chart.yaml file</h2>
    <p class="normal">The <code class="inlineCode">Chart.yaml</code> file is the main file of a <a id="_idIndexMarker944"/>Helm chart. It requires a name and version fields:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">apiVersion</code>: The <a id="_idIndexMarker945"/>API version of the chart.</li>
      <li class="bulletList"><code class="inlineCode">name</code>: The name of the chart, which should match the directory name.</li>
      <li class="bulletList"><code class="inlineCode">version</code>: The version of the chart using the <code class="inlineCode">SemVer</code> 2 format.</li>
    </ul>
    <p class="normal">Additionally, there are several optional fields that can be included in the <code class="inlineCode">Chart.yaml</code> file:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">kubeVersion</code>: A range of <a id="_idIndexMarker946"/>compatible Kubernetes versions specified in <code class="inlineCode">SemVer</code> format.</li>
      <li class="bulletList"><code class="inlineCode">description</code>: A brief description of the project in a single sentence.</li>
      <li class="bulletList"><code class="inlineCode">keywords</code>: A list of keywords associated with the project.</li>
      <li class="bulletList"><code class="inlineCode">home</code>: The URL of the project’s homepage.</li>
      <li class="bulletList"><code class="inlineCode">sources</code>: A list of URLs to the project’s source code.</li>
      <li class="bulletList"><code class="inlineCode">dependencies</code>: A list of dependencies for the chart, including the name, version, repository, condition, tags, and alias.</li>
      <li class="bulletList"><code class="inlineCode">maintainers</code>: A list of maintainers for the chart, including the name, email, and URL.</li>
      <li class="bulletList"><code class="inlineCode">icon</code>: The URL to an SVG or PNG image that can be used as an icon.</li>
      <li class="bulletList"><code class="inlineCode">appVersion</code>: The version of the application contained within the chart. It does not have to follow <code class="inlineCode">SemVer</code>.</li>
      <li class="bulletList"><code class="inlineCode">deprecated</code>: A boolean value indicating whether the chart is deprecated.</li>
      <li class="bulletList"><code class="inlineCode">annotations</code>: Additional key-value pairs that <a id="_idIndexMarker947"/>provide extra information.</li>
    </ul>
    <h3 id="_idParaDest-437" class="heading-3">Versioning charts</h3>
    <p class="normal">The <code class="inlineCode">version</code> field<a id="_idIndexMarker948"/> in the <code class="inlineCode">Chart.yaml</code> file plays a crucial role for various Helm tools. It is used by the <code class="inlineCode">helm package</code> command when creating a package, as it constructs the package name based on the version specified in the <code class="inlineCode">Chart.yaml</code>. It is important to ensure that the version number in the package name matches the version number in the <code class="inlineCode">Chart.yaml</code> file. Deviating from this expectation can result in an error, as the system assumes the consistency of these version numbers. Therefore, it is essential to maintain the coherence between the version field in the <code class="inlineCode">Chart.yaml</code> file and the generated package name to avoid any issues.</p>
    <h3 id="_idParaDest-438" class="heading-3">The appVersion field</h3>
    <p class="normal">The optional <code class="inlineCode">appVersion</code> field is not <a id="_idIndexMarker949"/>related to the <code class="inlineCode">version</code> field. It is not used by Helm and serves as metadata or documentation for users that want to understand what they are deploying. Helm ignores it.</p>
    <h3 id="_idParaDest-439" class="heading-3">Deprecating charts</h3>
    <p class="normal">From time to time, you may<a id="_idIndexMarker950"/> want to deprecate a chart. You can mark a chart as deprecated by setting the optional <code class="inlineCode">deprecated</code> field in <code class="inlineCode">Chart.yaml</code> to <code class="inlineCode">true</code>. It’s enough to deprecate the latest version of a chart. You can later reuse the chart name and publish a newer version that is not deprecated. The workflow for deprecating charts typically involves the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Update the Chart.yaml file</strong>: Modify the <code class="inlineCode">Chart.yaml</code> file of the chart to indicate that it is deprecated. This can be done by adding a <code class="inlineCode">deprecated</code> field and setting it to <code class="inlineCode">true</code>. Additionally, it is common practice to bump the version of the chart to indicate that a new version with deprecation information has been released.</li>
      <li class="numberedList"><strong class="keyWord">Release the new version</strong>: Package and release the updated chart with the deprecation information to the chart repository. This ensures that users are aware of the deprecation when they try to install or upgrade the chart.</li>
      <li class="numberedList"><strong class="keyWord">Communicate the deprecation</strong>: It is important to communicate the deprecation to users and provide information on alternative options or recommended migration paths. This can be done through documentation, release notes, or other channels to ensure that users are informed about the deprecation and can plan accordingly.</li>
      <li class="numberedList"><strong class="keyWord">Remove the chart from the source repository</strong>: Once the deprecated chart has been released and communicated to users, it is recommended to remove the chart from the source repository, such as a Git repository, to avoid confusion and ensure that users are directed to the latest version in the chart repository.</li>
    </ol>
    <p class="normal">By following these steps, you can effectively deprecate a chart and provide a clear process for users to transition to newer versions or alternative solutions.</p>
    <h2 id="_idParaDest-440" class="heading-2">Chart metadata files</h2>
    <p class="normal">Charts can <a id="_idIndexMarker951"/>include several metadata files, such as <code class="inlineCode">README.md</code>, <code class="inlineCode">LICENSE</code>, and <code class="inlineCode">NOTES.txt</code>, which provide important information about the chart. The <code class="inlineCode">README.md</code> file, formatted as markdown, is particularly crucial and should contain the following details:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Application or service description</strong>: Provide a clear and concise description of the application or service that the chart represents. This description should help users understand the purpose and functionality of the chart.</li>
      <li class="bulletList"><strong class="keyWord">Prerequisites and requirements</strong>: Specify any prerequisites or requirements that need to be met before using the chart. This could include specific versions of Kubernetes, required dependencies, or other conditions that must be satisfied.</li>
      <li class="bulletList"><strong class="keyWord">YAML options and default values</strong>: Document the available options that users can configure in the chart’s YAML files. Describe each option, its purpose, accepted values or format, and the default values. This information empowers users to customize the chart according to their needs.</li>
      <li class="bulletList"><strong class="keyWord">Installation and configuration instructions</strong>: Provide clear instructions on how to install and configure the chart. This may involve specifying the command-line options or Helm commands to deploy the chart and any additional steps or considerations during the configuration process.</li>
      <li class="bulletList"><strong class="keyWord">Additional information</strong>: Include any other relevant information that may assist users during the installation or configuration of the chart. This could involve best practices, troubleshooting tips, or known limitations.</li>
    </ul>
    <p class="normal">By including these details in the <code class="inlineCode">README.md</code> file, chart users can easily understand the chart’s purpose, requirements, and how to effectively install and configure it for their specific use case.</p>
    <p class="normal">If the chart<a id="_idIndexMarker952"/> contains a template or <code class="inlineCode">NOTES.txt</code> file, then the file will be displayed, printed out after installation and when viewing the release status, or upgraded. The notes should be concise to avoid clutter and point to the <code class="inlineCode">README.md</code> file for detailed explanations. It’s common to put usage notes and next steps in <code class="inlineCode">NOTES.txt</code>. Remember that the file is evaluated as a template. The notes are printed on the screen when you run <code class="inlineCode">helm install</code> as well as <code class="inlineCode">helm status</code>.</p>
    <h2 id="_idParaDest-441" class="heading-2">Managing chart dependencies</h2>
    <p class="normal">In Helm, a chart may depend <a id="_idIndexMarker953"/>on other charts. These dependencies are expressed explicitly by listing them in the <code class="inlineCode">dependencies</code> field of the <code class="inlineCode">Chart.yaml</code> file or copied directly to the <code class="inlineCode">charts/</code> subdirectory. This provides a great way to benefit from and reuse the knowledge and work of others. A dependency in Helm can take the form of either a chart archive (e.g., <code class="inlineCode">foo-1.2.3.tgz</code>) or an unpacked chart directory. However, it’s important to note that the name of a dependency should not begin with an underscore (<code class="inlineCode">_</code>) or a period (<code class="inlineCode">.</code>), as these files are ignored by the chart loader. Therefore, it’s recommended to avoid starting dependency names with these characters to ensure they are properly recognized and loaded by Helm.</p>
    <p class="normal">Let’s add <code class="inlineCode">kube-state-metrics</code> from the <code class="inlineCode">prometheus-community</code> repo as a dependency to our <code class="inlineCode">cool-chart</code>'s <code class="inlineCode">Chart.yaml</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span>
    <span class="hljs-attr">version:</span> <span class="hljs-string">"</span><span class="hljs-string">4.13.*"</span>
    <span class="hljs-attr">repository:</span> <span class="hljs-string">https://prometheus-community.github.io/helm-charts</span>
    <span class="hljs-attr">condition:</span> <span class="hljs-string">kubeStateMetrics.enabled</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">name</code> field represents the desired name of the chart you want to install. It should match the name of the chart as it is defined in the repository.</p>
    <p class="normal">The <code class="inlineCode">version</code> field specifies the specific version of the chart you want to install. It helps to ensure that you get the desired version of the chart.</p>
    <p class="normal">The <code class="inlineCode">repository</code> field contains the complete URL of the chart repository that the chart will be fetched from. It points to the location where the chart and its versions are stored and can be accessed.</p>
    <p class="normal">The <code class="inlineCode">condition</code> field is discussed in the subsequent section.</p>
    <p class="normal">If the repository is not added yet use <code class="inlineCode">helm repo</code> to add it locally.</p>
    <p class="normal">Once your dependencies are defined, you can run the <code class="inlineCode">helm dependency update</code> command. Helm will download all of the specified charts into the charts subdirectory for you:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm dep up cool-chart
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "prometheus-community" chart repository
Update Complete. <img src="../Images/B18998_09_001.png" alt=""/>Happy Helming!<img src="../Images/B18998_09_001.png" alt=""/>
Saving 1 charts
Downloading kube-state-metrics from repo https://prometheus-community.github.io/helm-charts
Deleting outdated charts
</code></pre>
    <p class="normal">Helm stores the dependency charts as archives in the <code class="inlineCode">charts/</code> directory:</p>
    <pre class="programlisting gen"><code class="hljs">$ ls cool-chart/charts
kube-state-metrics-4.13.0.tgz
</code></pre>
    <p class="normal">Managing charts <a id="_idIndexMarker954"/>and their dependencies in the <code class="inlineCode">Chart.yaml</code> dependencies field (as opposed to just copying charts into the <code class="inlineCode">charts/</code> subdirectory) is a best practice. It explicitly documents dependencies, facilitates sharing across the team, and supports automated pipelines.</p>
    <h3 id="_idParaDest-442" class="heading-3">Utilizing additional subfields of the dependencies field</h3>
    <p class="normal">Each <a id="_idIndexMarker955"/>entry in the <code class="inlineCode">requirements.yaml</code> file’s <code class="inlineCode">requirements</code> entry may include optional fields such as <code class="inlineCode">tags</code> and <code class="inlineCode">condition</code>.</p>
    <p class="normal">These fields can be used to dynamically control the loading of charts (if not specified all charts will be loaded). If <code class="inlineCode">tags</code> or <code class="inlineCode">condition</code> fields are present, Helm will evaluate them and determine if the target chart should be loaded or not.</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">condition</code> field in chart dependencies holds one or more comma-delimited YAML paths. These paths refer to values in the top parent’s values file. If a path exists and evaluates to a Boolean value, it determines whether the chart will be enabled or disabled. If multiple paths are provided, only the first valid path encountered is evaluated. If no paths exist, the condition has no effect, and the chart will be loaded regardless.</li>
      <li class="bulletList">The <code class="inlineCode">tags</code> field allows you to associate labels with the chart. It is a YAML list where you can specify one or more tags. In the top parent’s values file, you can enable or disable all charts with specific tags by specifying the tag and a corresponding Boolean value. This provides a convenient way to manage and control charts based on their associated tags.</li>
    </ul>
    <p class="normal">Here is an example <code class="inlineCode">dependencies</code> field and a <code class="inlineCode">values.yaml</code> that makes good use of conditions and tags to enable and disable the installation of dependencies. The <code class="inlineCode">dependencies</code> field defines two conditions for installing its dependencies based on the value of the global enabled field and the specific subchart’s enabled field:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">subchart1</span>
    <span class="hljs-attr">repository:</span> <span class="hljs-string">http://localhost:10191</span>
    <span class="hljs-attr">version:</span> <span class="hljs-number">0.1.0</span>
    <span class="hljs-attr">condition:</span> <span class="hljs-string">subchart1.enabled,</span> <span class="hljs-string">global.subchart1.enabled</span>
    <span class="hljs-attr">tags:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">front-end</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">subchart1</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">subchart2</span>
    <span class="hljs-attr">repository:</span> <span class="hljs-string">http://localhost:10191</span>
    <span class="hljs-attr">version:</span> <span class="hljs-number">0.1.0</span>
    <span class="hljs-attr">condition:</span> <span class="hljs-string">subchart2.enabled,global.subchart2.enabled</span>
    <span class="hljs-attr">tags:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">back-end</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">subchart2</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">values.yaml</code> file assigns values to some of the <code class="inlineCode">condition</code> variables. The <code class="inlineCode">subchart2</code> tag doesn’t get a value, so it is enabled automatically:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># parentchart/values.yaml</span>
<span class="hljs-attr">subchart1:</span>
  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">tags:</span>
  <span class="hljs-attr">front-end:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">back-end:</span> <span class="hljs-literal">true</span>
</code></pre>
    <p class="normal">You can set <code class="inlineCode">tags</code> and <code class="inlineCode">condition</code> values from the command line too when installing a chart, and they’ll take precedence over the <code class="inlineCode">values.yaml</code> file:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm install --set subchart2.enabled=false
</code></pre>
    <p class="normal">The resolution<a id="_idIndexMarker956"/> of tags and conditions is as follows:</p>
    <ul>
      <li class="bulletList">Conditions that are set in values override tags. The first <code class="inlineCode">condition</code> path that exists per chart takes effect, and other conditions are ignored.</li>
      <li class="bulletList">If any of the tags associated with a chart are set to <code class="inlineCode">true</code> in the top parent’s values, the chart is considered enabled. </li>
      <li class="bulletList">The <code class="inlineCode">tags</code> and <code class="inlineCode">condition</code> values must be set at the top level of the values file. </li>
      <li class="bulletList">Nested tags tables or tags within global configurations are not currently supported. This means that the tags should be directly under the top parent’s values and not nested within other structures.</li>
    </ul>
    <h2 id="_idParaDest-443" class="heading-2">Using templates and values</h2>
    <p class="normal">Any non-trivial <a id="_idIndexMarker957"/>application will <a id="_idIndexMarker958"/>require configuration and adaptation to the specific use case. Helm charts are templates that use the Go template language to populate placeholders. Helm supports additional functions from the Sprig library, which contains a lot of useful helpers as well as several other specialized functions. The template files are stored in the <code class="inlineCode">templates/</code> subdirectory of the chart. Helm will use the template engine to render all files in this directory and apply the provided value files.</p>
    <h3 id="_idParaDest-444" class="heading-3">Writing template files</h3>
    <p class="normal">Template files are just text<a id="_idIndexMarker959"/> files that follow the Go template language rules. They can generate Kubernetes configuration files as well as any other file. Here is the service template file of the Prometheus server’s <code class="inlineCode">service.yaml</code> template from the <code class="inlineCode">prometheus-community</code> repo:</p>
    <pre class="programlisting code"><code class="hljs-code">{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">and</span> <span class="hljs-string">.Values.server.enabled</span> <span class="hljs-string">.Values.server.service.enabled</span> <span class="hljs-string">-</span>}}
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.annotations</span> }}
  <span class="hljs-attr">annotations:</span>
{{ <span class="hljs-string">toYaml</span> <span class="hljs-string">.Values.server.service.annotations</span> <span class="hljs-string">|</span> <span class="hljs-string">indent</span> <span class="hljs-number">4</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
  <span class="hljs-attr">labels:</span>
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">include</span> <span class="hljs-string">"prometheus.server.labels"</span> <span class="hljs-string">.</span> <span class="hljs-string">|</span> <span class="hljs-string">nindent</span> <span class="hljs-number">4</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.labels</span> }}
{{ <span class="hljs-string">toYaml</span> <span class="hljs-string">.Values.server.service.labels</span> <span class="hljs-string">|</span> <span class="hljs-string">indent</span> <span class="hljs-number">4</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
  <span class="hljs-attr">name:</span> {{ <span class="hljs-string">template</span> <span class="hljs-string">"prometheus.server.fullname"</span> <span class="hljs-string">.</span> }}
{{ <span class="hljs-string">include</span> <span class="hljs-string">"prometheus.namespace"</span> <span class="hljs-string">.</span> <span class="hljs-string">|</span> <span class="hljs-string">indent</span> <span class="hljs-number">2</span> }}
<span class="hljs-attr">spec:</span>
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.clusterIP</span> }}
  <span class="hljs-attr">clusterIP:</span> {{ <span class="hljs-string">.Values.server.service.clusterIP</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.externalIPs</span> }}
  <span class="hljs-attr">externalIPs:</span>
{{ <span class="hljs-string">toYaml</span> <span class="hljs-string">.Values.server.service.externalIPs</span> <span class="hljs-string">|</span> <span class="hljs-string">indent</span> <span class="hljs-number">4</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.loadBalancerIP</span> }}
  <span class="hljs-attr">loadBalancerIP:</span> {{ <span class="hljs-string">.Values.server.service.loadBalancerIP</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.loadBalancerSourceRanges</span> }}
  <span class="hljs-attr">loadBalancerSourceRanges:</span>
  {{<span class="hljs-bullet">-</span> <span class="hljs-string">range</span> <span class="hljs-string">$cidr</span> <span class="hljs-string">:=</span> <span class="hljs-string">.Values.server.service.loadBalancerSourceRanges</span> }}
    <span class="hljs-bullet">-</span> {{ <span class="hljs-string">$cidr</span> }}
  {{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
      <span class="hljs-attr">port:</span> {{ <span class="hljs-string">.Values.server.service.servicePort</span> }}
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9090</span>
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.nodePort</span> }}
      <span class="hljs-attr">nodePort:</span> {{ <span class="hljs-string">.Values.server.service.nodePort</span> }}
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.gRPC.enabled</span> }}
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">grpc</span>
      <span class="hljs-attr">port:</span> {{ <span class="hljs-string">.Values.server.service.gRPC.servicePort</span> }}
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">10901</span>
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.gRPC.nodePort</span> }}
      <span class="hljs-attr">nodePort:</span> {{ <span class="hljs-string">.Values.server.service.gRPC.nodePort</span> }}
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
  <span class="hljs-attr">selector:</span>
  {{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">and</span> <span class="hljs-string">.Values.server.statefulSet.enabled</span> <span class="hljs-string">.Values.server.service.statefulsetReplica.enabled</span> }}
    <span class="hljs-attr">statefulset.kubernetes.io/pod-name:</span> {{ <span class="hljs-string">template</span> <span class="hljs-string">"</span><span class="hljs-string">prometheus.server.fullname"</span> <span class="hljs-string">.</span> }}<span class="hljs-string">-{{</span> <span class="hljs-string">.Values.server.service.statefulsetReplica.replica</span> <span class="hljs-string">}}</span>
  {{<span class="hljs-bullet">-</span> <span class="hljs-string">else</span> <span class="hljs-string">-</span>}}
    {{<span class="hljs-bullet">-</span> <span class="hljs-string">include</span> <span class="hljs-string">"</span><span class="hljs-string">prometheus.server.matchLabels"</span> <span class="hljs-string">.</span> <span class="hljs-string">|</span> <span class="hljs-string">nindent</span> <span class="hljs-number">4</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">.Values.server.service.sessionAffinity</span> }}
  <span class="hljs-attr">sessionAffinity:</span> {{ <span class="hljs-string">.Values.server.service.sessionAffinity</span> }}
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
  {{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
  <span class="hljs-attr">type:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ .Values.server.service.type }}</span><span class="hljs-string">"</span>
{{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> <span class="hljs-string">-</span>}}
</code></pre>
    <p class="normal">It is available here: <a href="https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus/templates/service.yaml"><span class="url">https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus/templates/service.yaml</span></a>.</p>
    <p class="normal">Don’t worry if it <a id="_idIndexMarker960"/>looks confusing. The basic idea is that you have a simple text file with placeholders for values that can be populated later in various ways as well as conditions, some functions, and pipelines that can be applied to those values.</p>
    <h4 class="heading-4">Using pipelines and functions</h4>
    <p class="normal">Helm allows rich and <a id="_idIndexMarker961"/>sophisticated syntax in the template files via the built-in Go template functions, Sprig functions, and pipelines. Here is an example template that takes advantage of these capabilities. It uses the <code class="inlineCode">repeat</code>, <code class="inlineCode">quote</code>, and <code class="inlineCode">upper</code> functions for the <code class="inlineCode">food</code> and <code class="inlineCode">drink</code> keys, and it uses pipelines to chain multiple functions together:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> {{ <span class="hljs-string">.Release.Name</span> }}<span class="hljs-string">-configmap</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">greeting:</span> <span class="hljs-string">"Hello World"</span>
  <span class="hljs-attr">drink:</span> {{ <span class="hljs-string">.Values.favorite.drink</span> <span class="hljs-string">|</span> <span class="hljs-string">repeat</span> <span class="hljs-number">3</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> }}
  <span class="hljs-attr">food:</span> {{ <span class="hljs-string">.Values.favorite.food</span> <span class="hljs-string">|</span> <span class="hljs-string">upper</span> }}
</code></pre>
    <p class="normal">Let’s add a <code class="inlineCode">values.yaml</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">favorite:</span>
  <span class="hljs-attr">drink:</span> <span class="hljs-string">coffee</span>
  <span class="hljs-attr">food:</span> <span class="hljs-string">pizza</span>
</code></pre>
    <h3 id="_idParaDest-445" class="heading-3">Testing and troubleshooting your charts</h3>
    <p class="normal">Now, we<a id="_idIndexMarker962"/> can<a id="_idIndexMarker963"/> use the <code class="inlineCode">helm template</code> command to see the result:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm template food food-chart
---
# Source: food-chart/templates/config-map.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: food-configmap
data:
  greeting: "Hello World"
  drink: "coffeecoffeecoffee"
  food: PIZZA
</code></pre>
    <p class="normal">As you can see, our templating worked. The drink <code class="inlineCode">coffee</code> was repeated 3 times and quoted. The food <code class="inlineCode">pizza</code> became uppercase <code class="inlineCode">PIZZA</code> (unquoted).</p>
    <p class="normal">Another good way of <a id="_idIndexMarker964"/>debugging is to run <code class="inlineCode">install</code> with the <code class="inlineCode">--dry-run</code> flag. It <a id="_idIndexMarker965"/>provides additional information:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm install food food-chart --dry-run -n monitoring
NAME: food
LAST DEPLOYED: Mon Aug  8 00:24:03 2022
NAMESPACE: monitoring
STATUS: pending-install
REVISION: 1
TEST SUITE: None
HOOKS:
MANIFEST:
---
# Source: food-chart/templates/config-map.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: food-configmap
data:
  greeting: "Hello World"
  drink: "coffeecoffeecoffee"
  food: PIZZA
</code></pre>
    <p class="normal">You can also override values on the command line:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm template food food-chart --set favorite.drink=water
---
# Source: food-chart/templates/config-map.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: food-configmap
data:
  greeting: "Hello World"
  drink: "waterwaterwater"
  food: PIZZA
</code></pre>
    <p class="normal">The ultimate test is, of course, to install your chart into your cluster. You don’t need to upload your chart to a chart repository for testing; just run <code class="inlineCode">helm install</code> locally:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm install food food-chart -n monitoring 
NAME: food
LAST DEPLOYED: Mon Aug  8 00:25:53 2022
NAMESPACE: monitoring
STATUS: deployed
REVISION: 1
TEST SUITE: None
</code></pre>
    <p class="normal">There is now a Helm release called <code class="inlineCode">food</code>:</p>
    <pre class="programlisting gen"><code class="hljs">$ helm list -n monitoring
NAME    NAMESPACE   REVISION    UPDATED                                 STATUS      CHART               APP VERSION
food    monitoring  1           2022-08-08 00:25:53.587342 -0700 PDT    deployed    food-chart-0.1.0    1.16.0
</code></pre>
    <p class="normal">Most <a id="_idIndexMarker966"/>importantly, the <code class="inlineCode">food-configmap</code> config map was created with the correct<a id="_idIndexMarker967"/> data:</p>
    <pre class="programlisting gen"><code class="hljs">$ k get cm food-configmap -o yaml -n monitoring
apiVersion: v1
data:
  drink: coffeecoffeecoffee
  food: PIZZA
  greeting: Hello World
kind: ConfigMap
metadata:
  annotations:
    meta.helm.sh/release-name: food
    meta.helm.sh/release-namespace: monitoring
  creationTimestamp: "2022-08-08T07:25:54Z"
  labels:
    app.kubernetes.io/managed-by: Helm
  name: food-configmap
  namespace: monitoring
  resourceVersion: "4247163"
  uid: ada4957d-bd6d-4c2e-8b2c-1499ca74a3c3
</code></pre>
    <h3 id="_idParaDest-446" class="heading-3">Embedding built-in objects</h3>
    <p class="normal">Helm provides some <a id="_idIndexMarker968"/>built-in objects you can use in your templates. In the Prometheus chart template above, <code class="inlineCode">Release.Name</code>, <code class="inlineCode">Release.Service</code>, <code class="inlineCode">Chart.Name</code>, and <code class="inlineCode">Chart.Version</code> are examples of Helm predefined values. Other objects are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Values</code></li>
      <li class="bulletList"><code class="inlineCode">Chart</code></li>
      <li class="bulletList"><code class="inlineCode">Template</code></li>
      <li class="bulletList"><code class="inlineCode">Files</code></li>
      <li class="bulletList"><code class="inlineCode">Capabilities</code></li>
    </ul>
    <p class="normal">The <code class="inlineCode">Values</code> object contains all the values defined in the <code class="inlineCode">values</code> file or on the command line. The <code class="inlineCode">Chart</code> object is the content of <code class="inlineCode">Chart.yaml</code>. The <code class="inlineCode">Template</code> object contains information about the current template. <code class="inlineCode">Files</code> and <code class="inlineCode">Capabilities</code> are map-like objects that allow access via various functions to the non-specialized files and general information about the <a id="_idIndexMarker969"/>Kubernetes cluster.</p>
    <p class="normal">Note that unknown fields in <code class="inlineCode">Chart.yaml</code> are ignored by the template engine and cannot be used to pass arbitrary structured data to templates.</p>
    <h3 id="_idParaDest-447" class="heading-3">Feeding values from a file</h3>
    <p class="normal">Here is part of the<a id="_idIndexMarker970"/> Prometheus server’s default <code class="inlineCode">values</code> file. The values from this file are used to populate multiple templates. The values represent defaults that you can override by copying the file and modifying it to fit your needs. Note the useful comments that explain the purpose and various options for each value:</p>
    <pre class="programlisting gen"><code class="hljs">server:
  ## Prometheus server container name
  ##
  enabled: true
  ## Use a ClusterRole (and ClusterRoleBinding)
  ## - If set to false - we define a RoleBinding in the defined namespaces ONLY
  ##
  ## NB: because we need a Role with nonResourceURL's ("/metrics") - you must get someone with Cluster-admin privileges to define this role for you, before running with this setting enabled.
  ##     This makes prometheus work - for users who do not have ClusterAdmin privs, but wants prometheus to operate on their own namespaces, instead of clusterwide.
  ##
  ## You MUST also set namespaces to the ones you have access to and want monitored by Prometheus.
  ##
  # useExistingClusterRoleName: nameofclusterrole
  ## namespaces to monitor (instead of monitoring all - clusterwide). Needed if you want to run without Cluster-admin privileges.
  # namespaces:
  #   - yournamespace
  name: server
  # sidecarContainers - add more containers to prometheus server
  # Key/Value where Key is the sidecar `- name: &lt;Key&gt;`
  # Example:
  #   sidecarContainers:
  #      webserver:
  #        image: nginx
  sidecarContainers: {}
</code></pre>
    <p class="normal">That was a deep dive into creating your own charts with Helm. Well, Helm is used widely and extensively to package and deploy Kubernetes applications. However, Helm is not the only game in town. There are several good alternatives that you may prefer. In the next section, we will review some of the most promising Helm alternatives.</p>
    <h1 id="_idParaDest-448" class="heading-1">Helm alternatives</h1>
    <p class="normal">Helm is battle tested and very common in the Kubernetes world, but it has its downsides and critics, especially when you develop your own charts. A lot of the criticism was about Helm 2 and its <a id="_idIndexMarker971"/>server-side component, Tiller. However, Helm 3 is not a panacea either. On a large scale, when you develop your own charts and complex templates with lots of conditional logic and massive <code class="inlineCode">values</code> files, it can become very challenging to manage.</p>
    <p class="normal">If you feel the pain, you may want to investigate some alternatives. Note that most of these projects focus on the deployment aspect. Helm’s dependency management is still a strength. Let’s look at some interesting projects that you may want to consider.</p>
    <h2 id="_idParaDest-449" class="heading-2">Kustomize</h2>
    <p class="normal">Kustomize is an alternative to<a id="_idIndexMarker972"/> YAML templating by using the concept of overlays on top of raw YAML files. It was<a id="_idIndexMarker973"/> added to kubectl in Kubernetes 1.14.</p>
    <p class="normal">See <a href="https://github.com/kubernetes-sigs/kustomize"><span class="url">https://github.com/kubernetes-sigs/kustomize</span></a>.</p>
    <h2 id="_idParaDest-450" class="heading-2">Cue</h2>
    <p class="normal">Cue is a very interesting <a id="_idIndexMarker974"/>project. Its data validation language and inference were strongly inspired by logic programming. It is not a general-purpose programming language. It is focused on data validation, data templating, configuration, querying, and code generation, but has some scripting too. The main concept of Cue is the unification of types and data. That gives Cue a lot of expressive power and obviates the need for constructs like enums and<a id="_idIndexMarker975"/> generics.</p>
    <p class="normal">See <a href="https://cuelang.org"><span class="url">https://cuelang.org</span></a>.</p>
    <p class="normal">See the specific discussion about replacing Helm with Cue here: <a href="https://github.com/cue-lang/cue/discussions/1159"><span class="url">https://github.com/cue-lang/cue/discussions/1159</span></a>.</p>
    <h2 id="_idParaDest-451" class="heading-2">kapp-controller</h2>
    <p class="normal">kapp-controller provides<a id="_idIndexMarker976"/> continuous delivery and package management capabilities for Kubernetes.</p>
    <p class="normal">Its declarative APIs and layered approach allow you to build, deploy, and manage your applications effectively. With Kapp-controller, you can package your software into distributable packages and empower users to discover, configure, and install these packages on a Kubernetes <a id="_idIndexMarker977"/>cluster seamlessly.</p>
    <p class="normal">See <a href="https://carvel.dev/kapp-controller/"><span class="url">https://carvel.dev/kapp-controller/</span></a>.</p>
    <p class="normal">That concludes our quick review of Helm alternatives.</p>
    <h1 id="_idParaDest-452" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we took a look at Helm, a popular Kubernetes package manager. Helm gives Kubernetes the ability to manage complicated software composed of many Kubernetes resources with inter-dependencies. It serves the same purpose as an OS package manager. It organizes packages and lets you search charts, install and upgrade charts, and share charts with collaborators. You can develop your own charts and store them in repositories. Helm 3 is a client-side-only solution that uses Kubernetes secrets to manage the state of releases in your cluster. We also looked at some Helm alternatives.</p>
    <p class="normal">At this point, you should understand the important role that Helm serves in the Kubernetes ecosystem and community. You should be able to use it productively and even develop and share your own charts.</p>
    <p class="normal">In the next chapter, we will look at how Kubernetes does networking at a pretty low level.</p>
  </div>
</body></html>