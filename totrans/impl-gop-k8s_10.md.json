["```\n$ terraform version\n```", "```\nTerraform v1.7.5\n```", "```\n    $ minikube start --profile flux-cluster\n    ```", "```\n    ğŸ˜„Â Â [flux-cluster] minikube v1.33.0 on Ubuntu 22.04 (amd64)\n    âœ¨Â Â Automatically selected the docker driver\n    ğŸ“ŒÂ Â Using Docker driver with root privileges\n    ğŸ‘Â Â Starting \"flux-cluster\" primary control-plane node in \"flux-cluster\" cluster\n    â€¦\n    ğŸŒŸÂ Â Enabled addons: storage-provisioner, default-storageclass\n    ğŸ„Â Â Done! kubectl is now configured to use \"flux-cluster\" cluster and \"default\" namespace by default\n    ```", "```\n    gitops-terraform-workflow, but feel free to create a repository according to your preferences. We will use a private repository for this setup. To create a GitHub account, please refer to the *GitHub account* section in *Chapter 3* of this book. After creating the GitHub repository, clone it locally to your laptop. For the Git commands, please refer to the *Basics of Git* section in *Chapter 3* of this book.\n    ```", "```\n$ export GITHUB_TOKEN=[GITHUB_PAT_TOKEN]\n```", "```\nÂ Â Â Â flux bootstrap github \\\nÂ Â Â Â Â Â --token-auth \\\nÂ Â Â Â Â Â --owner=[GITHUB_ACCOUNT] \\\nÂ Â Â Â Â Â --repository=gitops-terraform-workflow \\\nÂ Â Â Â Â Â --branch=main \\\nÂ Â Â Â Â Â --path=clusters/local \\\nÂ Â Â Â Â Â --personal\n```", "```\nâ–º connecting to github.com\nâ–º cloning branch \"main\" from Git repository \"https://github.com/pietrolibro/gitops-terraform-workflow.git\"\nâ€¦\nâ–º confirming components are healthy\nâœ” helm-controller: deployment ready\nâœ” kustomize-controller: deployment ready\nâœ” notification-controller: deployment ready\nâœ” source-controller: deployment ready\nâœ” all components are healthy\n```", "```\n$ kubectl get namespaces\nNAMEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â STATUSÂ Â Â AGE\ndefaultÂ Â Â Â Â Â Â Â Â Â Â ActiveÂ Â Â 26m\nflux-systemÂ Â Â Â Â Â Â ActiveÂ Â Â 3m30s\nkube-node-leaseÂ Â Â ActiveÂ Â Â 26m\nkube-publicÂ Â Â Â Â Â Â ActiveÂ Â Â 26m\nkube-systemÂ Â Â Â Â Â Â ActiveÂ Â Â 26m\n```", "```\n    $ kubectl apply -f https://raw.githubusercontent.com/flux-iac/tofu-controller/main/docs/release.yaml\n    ```", "```\n    helmrepository.source.toolkit.fluxcd.io/tf-controller created\n    helmrelease.helm.toolkit.fluxcd.io/tf-controller created\n    ```", "```\n    subscriptionId=\"$(az account list --query \"[?name=='AZURE_SUBSCRIPTION_NAME'].id\" --output tsv)\"\n    az account set --subscription=$subscriptionId\n    az ad sp create-for-rbac --role=\"Contributor\" --scopes=\"/subscriptions/$subscriptionId\" --name gitops-terraform-sp\n    ```", "```\n    {\n    Â Â \"appId\": \"application-id\",\n    Â Â \"displayName\": \"gitops-terraform-sp\",\n    Â Â \"password\": \"generated-password\",\n    Â Â \"tenant\": \"tenant-uid\"\n    }\n    ```", "```\napiVersion: v1\nkind: Secret\nmetadata:\nÂ Â name: github-repository-secret\nÂ Â namespace: flux-system\ntype: Opaque\ndata:\nÂ Â username: <github_accountname-base64>\nÂ Â password: <github_pat-base64>\n```", "```\n$ kubectl apply -f github-repository-secret.yaml\n```", "```\n$ kubectl create secret generic azure-creds \\\nÂ Â Â Â --from-literal=ARM_SUBSCRIPTION_ID='SP_SUB_ID' \\\nÂ Â Â Â --from-literal=ARM_TENANT_ID='SP_TENANT_ID' \\\nÂ Â Â Â --from-literal=ARM_CLIENT_ID='SP_APPID' \\\nÂ Â Â Â --from-literal=ARM_CLIENT_SECRET='SP_PASSWORD' \\\nÂ Â Â Â --namespace flux-system\n```", "```\n$ kubectl get secrets -n flux-system\nNAMEÂ Â Â Â Â Â Â TYPEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â DATAÂ Â Â AGE\nazure-credsÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â OpaqueÂ Â Â Â Â Â 4Â Â Â Â Â Â 16s\nflux-systemÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â OpaqueÂ Â Â Â Â Â 2Â Â Â Â Â Â 34m\ngithub-repository-secretÂ Â OpaqueÂ Â Â Â Â Â 2Â Â Â Â Â Â 25s\nâ€¦\n```", "```\n    $ kubectl apply -f github-repository-definition.yaml\n    gitrepository.source.toolkit.fluxcd.io/gitops-terraform-repository created\n    ```", "```\n    $ docker build -f ./Docker/dockerfile -t pietrolibro/gitops-terraform:tf_az_cli_1_1 .\n    ```", "```\n    main.tf in the iac/azure/vnet subfolder of the repository accompanying this chapter.  The Terraform script provisions a set of network resources in Microsoft Azure. It configures the Azure provider and defines a resource group named gitops-terraform-rg in the Switzerland North region, serving as a container for related Azure resources. The script also establishes a virtual network called gitops-terraform-vnet within this resource group, with an address space of 10.0.0.0/16. Additionally, it creates a default subnet within this virtual network, allocated with an address range of 10.0.0.0/24. This setup structures the Azure cloud infrastructure effectively, facilitating the management and scalability of network components within the specified region.\n    ```", "```\napiVersion: infra.contrib.fluxcd.io/v1alpha2\nkind: Terraform\nmetadata:\nÂ Â name: gitops-terraform-automation\nÂ Â namespace: flux-system\nspec:\nÂ Â interval: 1m\nÂ Â approvePlan: auto\nÂ Â destroyResourcesOnDeletion: true\nÂ Â path: ./iac/azure/vnet\nÂ Â sourceRef:\nâ€¦\nÂ Â runnerPodTemplate:\nÂ Â Â Â spec:\nÂ Â Â Â Â Â env:\nÂ Â Â Â Â Â Â Â - name: ARM_SUBSCRIPTION_ID\nÂ Â Â Â Â Â Â Â Â Â valueFrom:\nÂ Â Â Â Â Â Â Â Â Â Â Â secretKeyRef:\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â name: azure-creds\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â key: ARM_SUBSCRIPTION_ID\nÂ Â Â Â Â Â Â Â â€¦\n```", "```\n$ kubectl apply -f ./definitions/azvnet-gitops-automation.yaml\nkubectl command to query the status of resources managed by Flux. Hereâ€™s how to check the reconciliation process:\n\n```", "```\n\n\t\t\tThis command displays the current status of the Terraform configuration:\n\n```", "```\n\n\t\t\tAs indicated by the output of the previous command, the Terraform script has been successfully applied at a certain point. For further confirmation, we can open the Azure portal and visually inspect the provisioned infrastructure, as illustrated in *Figure 10**.2*:\n\t\t\t![Figure 10.2 â€“ Azure resources provisioned by Terraform and GitOps](img/B22100_10_02.jpg)\n\n\t\t\tFigure 10.2 â€“ Azure resources provisioned by Terraform and GitOps\n\t\t\tFantastic work! You have successfully integrated IaC using Terraform along with GitOps principles through Flux CD. By adopting this approach, you have laid a robust foundation for managing your cloud resources in a way that promotes consistency, reduces errors, and streamlines operations.\n\t\t\tCombining Terraform and Flux CD for enhanced automation\n\t\t\tCombining Terraform and Flux CD for enhanced automation offers significant advantages in managing cloud infrastructure efficiently and resiliently. Hereâ€™s how this integration can be advantageous in various practical scenarios.\n\t\t\tProviding new infrastructure by updating Terraform files\n\t\t\tOne of the standout benefits of integrating Terraform with Flux CD is the simplicity with which new infrastructure components can be added. For example, suppose you need to add a new subnet to an existing Azure virtual network. By merely updating the Terraform file to include the new subnet definition and committing this change to your repository, Flux CD automatically detects the update and applies it. This seamless process eliminates the need for manual intervention in the cloud environment, thereby reducing the potential for human error and accelerating deployment times. Automation ensures that infrastructure adjustments, such as scaling out to accommodate growth, are handled promptly and accurately.\n\t\t\tWe can immediately test this aspect by updating the `main.tf` file presented in *step 8* of the *Setting up Terraform in a GitOps workflow* section. Append the following code block to the end of the file:\n\n```", "```\n\n\t\t\tThis Terraform code block creates a subnet named `AzureBastionSubnet` within a specified Azure virtual network and resource group. It assigns the subnet an IP address range of `10.0.1.0/26`. The subnet resource is identified within Terraform as `azure_bastion_subnet`, and it references the names of both the virtual network and resource group from other resources defined in the Terraform configuration.\n\t\t\tAt this point, simply commit and push the code to trigger a reconciliation loop. You will then see the process in action, as illustrated next:\n\n```", "```\n\n\t\t\tOpen the Azure portal to visually verify the results, as illustrated in *Figure 10**.3*:\n\t\t\t![Figure 10.3 â€“ After the reconciliation process, the gitops-terraform-vnet virtual network in the Azure portal contains two subnets](img/B22100_10_03.jpg)\n\n\t\t\tFigure 10.3 â€“ After the reconciliation process, the gitops-terraform-vnet virtual network in the Azure portal contains two subnets\n\t\t\tEnhanced disaster recovery capabilities\n\t\t\tIn the event of a disaster, the combination of Terraform and Flux CD significantly enhances recovery capabilities. Terraformâ€™s ability to describe the complete IaC means that entire environments can be replicated swiftly and accurately. Flux CD plays a crucial role by continuously ensuring that the state of the cloud environment matches the configurations defined in your Git repository. If a disaster strikes, you can quickly redeploy your infrastructure to a known good state as defined in the repository, drastically reducing downtime and the complexity often associated with recovery processes.\n\t\t\tCreating and managing multi-stage environments\n\t\t\tWhen managing complex deployments that involve multiple stages, such as development, staging, and production, the division of the repository becomes essential. With Terraform and Flux CD, you can split your repository appropriately to manage these environments separately yet consistently. Each environment can have its configuration files and Terraform plans, which Flux CD can manage independently. This setup not only keeps your deployments organized but also enforces consistency and isolation between environments. Changes can be tested in development or staging environments through automated pipelines and only promoted to production once verified, ensuring stability and reliability in your production deployments.\n\t\t\tAs seen so far, this strategic integration of Terraform and Flux CD not only streamlines the operational aspects of cloud infrastructure management but also enhances strategic capabilities such as quick scaling, robust **disaster recovery** (**DR**), and effective multi-environment handling. With Flux CD, updates and changes are applied systematically and predictably, reducing the likelihood of human error and the overhead associated with manual deployments.\n\t\t\tIn the next section, we will explore how Terraform and Flux CD utilize version control and automation to enhance infrastructure management, ensuring transparency, collaboration, and security throughout the deployment process.\n\t\t\tVersion control and automation with Terraform and Flux CD\n\t\t\tTerraform uses version control to manage the state of your infrastructure, which allows for tracking changes, auditing, and collaborating on infrastructure development. By storing Terraform configurations in version-controlled repositories, teams can review changes through pull requests, maintain a history of configurations, and revert to previous states when necessary. This process enhances transparency and collaboration among team members, fostering a more controlled and secure environment for deploying infrastructure.\n\t\t\tSecurity and best practices with Terraform and Flux CD\n\t\t\tWhen combining Terraform with Flux CD, security is significantly enhanced by the inherent design of GitOps and the nature of declarative infrastructure management. All changes to the infrastructure are committed to version control, which means every change is auditable and traceable.\n\t\t\tTo enhance security further, we can deploy the following:\n\n\t\t\t\t*   **Access control**: Implement strict access controls on your Git repositories. Use branch protection rules to ensure that changes are reviewed and approved before they are merged, preventing unauthorized modifications to your infrastructure.\n\t\t\t\t*   **Secrets management**: Never store secrets directly in your Git repositories. Instead, leverage Kubernetes Secrets or integrate with a secrets management tool such as HashiCorp Vault or Azure Key Vault. Flux CD can securely pull secrets and inject them into the deployment pipeline.\n\t\t\t\t*   **Automated compliance scans**: Integrate compliance scanning tools into your CI/CD pipeline to automatically check Terraform plans for compliance with security policies and best practices before they are applied.\n\n\t\t\tBest practices for configuration and maintenance\n\t\t\tHere are some best practices for configuration and maintenance:\n\n\t\t\t\t*   **Immutability**: Treat infrastructure as immutable. Rebuild infrastructure from scratch frequently to ensure that the actual state aligns with the state defined in Terraform configurations.\n\t\t\t\t*   **Code review and pair programming**: Enforce code reviews for all infrastructure changes. Pair programming can also be used for critical changes, involving more than one set of eyes before changes go live.\n\t\t\t\t*   **CI**: Integrate CI processes to test infrastructure changes automatically. This includes testing Terraform plans and applying them to a non-production environment before they affect your production infrastructure.\n\n\t\t\tBest practices for managing multi-environment configurations\n\t\t\tManaging multiple environments (dev, staging, production) effectively requires a well-organized repository structure.\n\t\t\tHere are some best practices:\n\n\t\t\t\t*   **Environment branching**: Maintains a single repository, but uses different branches for each environment, merging changes from development branches to production branches through a controlled process.\n\t\t\t\t*   **Parameterization**: Use variables and outputs to customize Terraform configurations for different environments. Avoid hardcoding values directly into Terraform files.\n\t\t\t\t*   **Environment parity**: Keep your development, staging, and production environments as similar as possible. This reduces the chances of encountering unexpected behaviors in production that werenâ€™t evident in dev or staging. The optimal approach to managing multi-environment configurations hinges on several factors, such as organization size, project complexity, regulatory demands, and the balancing act between security and operational efficiency. For organizations in highly regulated industries, such as finance or healthcare, where security is paramount, using separate repositories for each environment might be advisable to enhance security by isolating production settings from development and testing environments. This method limits access to sensitive configurations and minimizes the risk of inadvertent changes. Alternatively, if rapid development and deployment are critical, a single repository with separate directories for each environment can simplify the management of changes across environments, though it necessitates strict access controls and vigilant monitoring to protect production configurations. For those seeking a balance between security and simplicity, a hybrid approach could be suitable, involving a single repository for all non-sensitive environments and a separate one for production. Regardless of the chosen strategy, implementing robust version control practices, clear access controls, and automated deployment pipelines will be essential to maintain efficiency and safeguard the integrity of environments.\n\n\t\t\tGit workflow strategies\n\t\t\tTo effectively manage your infrastructure and streamline your development workflow, itâ€™s essential to adopt best practices that align with your teamâ€™s dynamics and project requirements. Consider the following strategies:\n\n\t\t\t\t*   **Trunk-based development versus Git Flow**: Choose a Git workflow that suits your teamâ€™s needs. Trunk-based development encourages shorter-lived branches and might be more suitable for fast-paced environments, while Git Flow can provide more control through designated branches for features, releases, and hotfixes.\n\t\t\t\t*   **Automated testing and promotion**: Use automated testing to validate changes in lower environments. Only promote changes to the next environment once they pass all tests. Automate this promotion using Flux CD, which can monitor different branches or folders and apply changes to the respective environments.\n\n\t\t\tNow that we have a comprehensive understanding of Terraform, GitOps, and Flux, along with best practices, we can combine all these elements in a practical example. This example will focus on managing a multi-environment setup, which we will describe in the next section.\n\t\t\tMulti-environment management with Terraform and Flux CD\n\t\t\tIn the final section of this book, youâ€™ll explore a detailed application of the concepts weâ€™ve discussed, using a Kubernetes cluster (`minikube`) to manage a multi-environment setup with Flux CD for IaC. This real-world example will demonstrate how to effectively deploy separate environments for `dev`), `staging`), and `prod`). *Figure 10**.4* illustrates the described example:\n\t\t\t![Figure 10.4 â€“ Example of multi-environment management with Terraform and Flux CD](img/B22100_10_04.jpg)\n\n\t\t\tFigure 10.4 â€“ Example of multi-environment management with Terraform and Flux CD\n\t\t\tGitHub will serve as the VCS, and the directory hierarchy will be organized as follows:\n\n```", "```\n\n\t\t\tIn this structure, we have the following:\n\n\t\t\t\t*   `clusters/mgmt`: Contains the Flux configuration files installed by the bootstrap for the management cluster (`minikube`, running locally).\n\t\t\t\t*   `multi-env/iac/azure`: Contains subdirectories for the different environments (`dev`, `staging`, and `prod`), each intended for managing infrastructure specific to that environment using Terraform scripts.\n\t\t\t\t*   `Base`: Contains the main Terraform files (`main.tf` and `variables.tf`), which define the Azure resources (such as AKS, virtual network, **Azure Container Registry** (**ACR**), and so on) from an infrastructure perspective. These files are copied into the corresponding environment subfolder as needed to tailor the infrastructure setup for each specific environment.\n\n\t\t\tThe `flux-gitops-definitions` directory contains various manifest YAML files essential for configuring the GitHub repository and secret. This setup involves the following:\n\n\t\t\t\t*   **GitHub repository configuration**: YAML files in this directory help link the Flux installation with the GitHub repository, specifying where Flux should listen for updates and which branch to monitor.\n\t\t\t\t*   **Secrets management**: Includes the setup for Kubernetes secrets that store sensitive information, such as GitHub access tokens or cloud provider credentials. These secrets ensure that Flux can securely access the repository and interact with other services as needed.\n\t\t\t\t*   **Resource definitions**: Manifests that define how resources should be applied, rolled out, and managed across different environments.\n\n\t\t\tFor the following example, we will continue using the same GitHub repository as before (although you are welcome to create a new one if you prefer). Additionally, we will initiate a new `minikube` cluster:\n\n\t\t\t\t1.  To do this, start by opening a new terminal window and enter the following command:\n\n    ```", "```\n    GITHUB_TOKEN is set, you can proceed to install Flux on your cluster using the bootstrap command. Execute the following in your terminal:\n\n    ```", "```\n\n    Once the command has finished executing, you should see an output similar to the following:\n\n    ```", "```\n\n    ```", "```\n\n    \t\t\t\t2.  Now that Flux is successfully bootstrapped, the next step is to install the TF-Controller. Hereâ€™s how to proceed:\n\n    ```", "```\n    $ kubectl get pods -n flux-system\n    NAMEÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â READYÂ Â Â STATUSÂ Â Â Â RESTARTSÂ Â AGE\n    helm-controllerâ€¦Â Â Â Â Â Â Â Â Â Â 1/1Â Â Â Â Â RunningÂ Â Â 0Â Â Â Â Â Â Â Â Â 4m47s\n    kustomize-contrâ€¦Â Â Â Â Â Â Â Â Â Â Â Â 1/1Â Â Â Â Â RunningÂ Â Â 0Â Â Â Â Â Â Â Â Â 4m47s\n    notification-coâ€¦Â Â Â Â Â Â Â Â Â Â 1/1Â Â Â Â Â RunningÂ Â Â 0Â Â Â Â Â Â Â Â Â 4m47s\n    Running state.\n    ```", "```\n\n    \t\t\t\t3.  Since we are using a new `minikube` cluster (or alternative cluster) and our goal is to provision resources on Azure, we need to create the corresponding secret:\n\n    ```", "```\n    provider \"azurerm\" {\n    Â Â features {}\n    }\n    ```", "```\n\n    \t\t\t\t4.  Now, change your working directory to where `flux-gitops-definitions` is located. This directory should contain your YAML files for the GitHub repository configuration (`github-repository-definition.yaml`) and the secret (`github-repository-secret.yaml`). First, apply the *GitHub repository secret*, which contains the credentials that Flux CD will use to access your GitHub repository:\n\n    ```", "```\n\n    \t\t\t\t5.  Next, apply the *GitHub repository definition*. This  definition will link your Kubernetes setup with the GitHub repository, setting the groundwork for Flux CD to monitor changes and manage resources according to GitOps principles:\n\n    ```", "```\n\n    \t\t\t\t6.  Before continuing, itâ€™s important to commit and push the changes weâ€™ve made so far. Then, we need to apply the automation configurations for each environment by executing the following commands:\n\n    ```", "```\n\n    \t\t\t\t7.  Afterward, check the reconciling process to ensure that the configurations are being applied correctly:\n\n    ```", "```\n\n    \t\t\t\t8.  At this point, the reconciliation process is in progress, but no resources will be provisioned because the `main.tf` file in each directory does not define any resources. To address this, copy the `main.tf` and `variables.tf` files from the `base` directory to each subdirectory corresponding to the specific environments. Then, for each environment, open the `variables.tf` file and update it according to the needs of the `dev`, `staging`, and `prod` environments:\n\n    ```", "```\n\n    \t\t\t\t9.  Now, itâ€™s time to commit and push the updated code to your Git repository. After doing so, you can observe the reconciliation process to see how Flux CD responds to the changes:\n\n    ```", "```\n\n    This procedure provides real-time feedback on how Flux CD manages and applies updates from your Git repository. The reconciliation process may take some time to fully provision the resources defined in the Terraform scripts. The results are illustrated in *Figure 10**.5*:\n\n\t\t\t![Figure 10.5 â€“ Resources provisioned by the GitOps automation reconciliation process](img/B22100_10_05.jpg)\n\n\t\t\tFigure 10.5 â€“ Resources provisioned by the GitOps automation reconciliation process\n\t\t\tWell done! Now, you can try making changes to the infrastructure code in one of the environments and see how the GitOps automation updates and syncs the infrastructure with your repository. What weâ€™ve explored is just a glimpse of using GitOps for managing multi-environment setups. We havenâ€™t covered using pull requests or installing applications yetâ€”these topics will be addressed in the next chapter.\n\t\t\tSummary\n\t\t\tIn this chapter, we explored the dynamic synergy between Terraform and Flux CD, showcasing how these tools bolster infrastructure automation using GitOps and IaC principles. The chapter introduced Terraform for defining and provisioning cloud infrastructure, alongside Flux CD, which automates the deployment process by continuously syncing changes from Git repositories to Kubernetes clusters. It thoroughly covered the fundamentals of integrating Terraform within a GitOps workflow, ensuring seamless management and scaling of cloud resources. Special attention was given to best practices for maintaining multiple environments such as development, QA, and staging, emphasizing the importance of environment-specific configurations to maintain consistency, reduce errors, and streamline operations across various cloud setups. Practical examples throughout the chapter demonstrated how to utilize these tools to effectively manage complex deployments, with a strong focus on the critical roles of version control and automated reconciliation.\n\t\t\tBuilding on the foundational concepts and best practices discussed, the next chapter will delve deeper into practical applications and real-world scenarios, showcasing how these strategies can be effectively implemented to optimize cloud infrastructure management.\n\n```"]