["```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: PersistentVolume\n    metadata:\n      name: db-pv-volume\n      labels:\n        type: local\n    spec:\n      storageClassName: manual\n      capacity:\n        storage: 5Gi\n      accessModes:\n        - ReadWriteOnce\n      hostPath:\n        path: \"/mnt/data\"\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    metadata:\n      name: db-pv-claim\n    spec:\n      storageClassName: manual\n      accessModes:\n        - ReadWriteOnce\n      resources:\n        requests:\n          storage: 5Gi\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: redis-configmap\n      namespace: monitoring\n    data:\n      redis-config: |\n        dir /data\n        requirepass YOUR_PASSWORD\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      labels:\n        run: redis\n      name: redis\n      namespace: monitoring\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          run: redis\n      template:\n        metadata:\n          labels:\n            run: redis\n        spec:\n          containers:\n          - name: redis\n            image: redis:6.2\n            command:\n              - redis-server\n              - /redisconf/redis.conf\n            ports:\n            - containerPort: 6379\n            resources:\n              limits:\n                cpu: \"0.2\"\n                memory: \"128Mi\"\n            volumeMounts:\n            - mountPath: \"/data\"\n              name: redis-storage\n            - mountPath: /redisconf\n              name: config\n          volumes:\n            - name: config\n              configMap:\n                name: redis-configmap\n                items:\n                - key: redis-config\n                  path: redis.conf\n            - name: redis-storage\n              persistentVolumeClaim:\n                claimName: db-pv-claim\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        run: redis\n      name: redis\n      namespace: monitoring\n    spec:\n      ports:\n      - port: 6379\n        protocol: TCP\n        targetPort: 6379\n      selector:\n        run: redis\n      type: ClusterIP\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        run: redis\n      name: redis-lb\n      namespace: monitoring\n    spec:\n      ports:\n      - port: 6379\n        protocol: TCP\n        targetPort: 6379\n      selector:\n        run: redis\n      type: LoadBalancer\n    EOF\n    ```", "```\n    $ EXTERNAL_IP=\"$(kubectl get svc redis-lb -n monitoring  -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: mosquitto-configmap\n    data:\n      mosquitto-config: |\n        listener 1883 0.0.0.0\n        allow_anonymous true\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1 \n    kind: Deployment\n    metadata:\n      labels:\n        app: mosquitto\n      name: mosquitto\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: mosquitto\n      template:\n        metadata:\n          labels:\n            app: mosquitto\n        spec:\n          containers:\n          - name: mosquitto\n            image: arm64v8/eclipse-mosquitto:2.0.14\n            ports:\n            - containerPort: 1883\n              name: mqtt\n            - containerPort: 9001\n              name: http\n            resources:\n              limits:\n                cpu: \"0.2\"\n                memory: \"128Mi\"\n            volumeMounts:\n    - mountPath: /mosquitto/config \n    name: config \n          volumes:\n            - name: config\n              configMap:\n                name: mosquitto-configmap\n                items:\n                - key: mosquitto-config\n    path: mosquitto.conf \n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        app: mosquitto\n      name: mosquitto\n    spec:\n      ports:\n      - name: mqtt\n        port: 1883\n        protocol: TCP\n        targetPort: 1883\n      - name: http\n        port: 9001\n        protocol: TCP\n        targetPort: 9001\n      selector:\n        app: mosquitto\n      type: ClusterIP\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        app: mosquitto\n      name: mosquitto-lb\n    spec:\n      ports:\n      - name: mqtt\n        port: 1883\n        protocol: TCP\n        targetPort: 1883\n      - name: http\n        port: 9001\n        protocol: TCP\n        targetPort: 9001\n      selector:\n        app: mosquitto\n      type: LoadBalancer\n    EOF\n    ```", "```\nimport paho.mqtt.client as mqtt\nimport os\nimport redis\nimport sys\n\nmqhost = os.environ['MOSQUITTO_HOST']\nrhost = os.environ['REDIS_HOST']\nrauth = os.environ['REDIS_AUTH']\nstopic = os.environ['SENSOR_TOPIC']\n\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(stopic)\n\ndef on_message(client, userdata, msg):\n    r = redis.StrictRedis(host=rhost,\\\n        port=6379,db=0,password=rauth,\\\n        decode_responses=True)\n    r.rpush(stopic,msg.payload)\n\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\nclient.connect(mqhost, 1883, 60)\nclient.loop_forever()\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Secret\n    metadata:\n      name: db-password\n    data:\n      password: WU9VUl9QQVNTV09SRA==\n    EOF\n    ```", "```\n$ echo \"YOUR_PASSWORD\" | tr -d '\\n'  | base64\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      labels:\n        app: process\n      name: process\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: process\n      template:\n        metadata:\n          labels:\n            app: process\n        spec:\n          containers:\n          - image: sergioarmgpl/mqttsubs\n            imagePullPolicy: Always\n            name: mqttsubs\n            env:\n            - name: MOSQUITTO_HOST\n              value: \"mosquitto\"\n            - name: REDIS_HOST\n              value: \"192.168.0.242\"\n            - name: REDIS_AUTH\n              valueFrom:\n                 secretKeyRef:\n                    name: db-password\n                    key: password\n            - name: SENSOR_TOPIC\n    value: \"sensor1\" \n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: monitoring\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1 \n    kind: ConfigMap \n    metadata: \n    name: prometheus-server-conf \n    labels: \n    name: prometheus-server-conf \n    namespace: monitoring \n    data: \n    prometheus.yml: |- \n    global: \n    scrape_interval: 5s \n    evaluation_interval: 5s \n    external_labels: \n    monitor: 'codelab-monitor' \n    scrape_configs: \n    - job_name: 'MonitoringJob1' \n    scrape_interval: 5s \n    static_configs: \n    - targets: ['service1:5555'] \n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: prometheus-deployment\n      namespace: monitoring\n      labels:\n        app: prometheus-server\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: prometheus-server\n      template:\n        metadata:\n          labels:\n            app: prometheus-server\n        spec:\n          containers:\n            - name: prometheus\n              image: prom/prometheus:v2.34.0\n              args:\n                - \"--storage.tsdb.retention.time=12h\"\n                - \"--config.file=/etc/prom/prometheus.yml\"\n                - \"--storage.tsdb.path=/prometheus/\"\n              ports:\n                - containerPort: 9090\n              resources:\n                requests:\n                  cpu: 500m\n                  memory: 500M\n                limits:\n                  cpu: 1\n                  memory: 1Gi\n              volumeMounts:\n                - name: prometheus-config-volume\n                  mountPath: /etc/prom/\n                - name: prometheus-storage-volume\n                  mountPath: /prometheus/\n          volumes:\n            - name: prometheus-config-volume\n              configMap:\n                defaultMode: 420\n                name: prometheus-server-conf\n            - name: prometheus-storage-volume\n              emptyDir: {}\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: prometheus-server\n      name: prometheus-service\n      namespace: monitoring\n    spec:\n      ports:\n      - port: 8080\n        protocol: TCP\n        targetPort: 9090\n      selector:\n        app: prometheus-server\n      type: ClusterIP\n    EOF\n    ```", "```\n    $ kubectl port-forward svc/prometheus-service 8080 -n monitoring --address 0.0.0.0\n    ```", "```\nfrom flask import Response, Flask, request, jsonify\nimport prometheus_client\nfrom prometheus_client import Gauge\nimport redis\nimport os\nimport sys\nimport json\nt = Gauge('weather_metric1', 'temperature')\nh = Gauge('weather_metric2', 'humidity')\n\nrhost = os.environ['REDIS_HOST']\nrauth = os.environ['REDIS_AUTH']\nstopic = os.environ['SENSOR_TOPIC']\nr = redis.StrictRedis(host=rhost,\\\n        port=6379,db=0,password=rauth,\\\n        decode_responses=True)\n\n@app.route(\"/metrics\")\ndef metrics():\n    data = r.lpop(stopic)\n    values = json.loads(str(data).replace(\"\\'\",\"\\\"\"))\n    t.set(int(values[\"temperature\"]))\n    h.set(int(values[\"humidity\"]))\n    res = []\n    res.append(prometheus_client.generate_latest(t))\n    res.append(prometheus_client.generate_latest(h))\n    print({\"processed\":\"done\"},file=sys.stderr)\n    return Response(res, mimetype=\"text/plain\")\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5555, debug=True)\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      labels:\n        app: service1\n      name: service1\n      namespace: monitoring\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: service1\n      template:\n        metadata:\n          labels:\n            app: service1\n          annotations:\n            prometheus.io/scrape: \"true\"\n            prometheus.io/path: /metrics\n            prometheus.io/port: \"5555\"\n        spec:\n          containers:\n          - image: sergioarmgpl/exporter\n            name: exporter\n            env:\n            - name: REDIS_HOST\n              value: \"redis\"\n            - name: REDIS_AUTH\n              value: \"YOUR_PASSWORD\"\n            - name: SENSOR_TOPIC\n              value: \"sensor1\"\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      labels:\n        app: service1\n      name: service1\n      namespace: monitoring\n    spec:\n      ports:\n      - port: 5555\n        protocol: TCP\n        targetPort: 5555\n      selector:\n        app: service1\n      type: ClusterIP\n    EOF\n    ```", "```\n        $ sudo apt-get install python3 -y\n        ```", "```\n        $ sudo apt-get install libgpiod2 git -y\n        $ sudo python3 sensor.py\n        $ sudo pip3 install adafruit-circuitpython-dht\n        $ sudo pip3 install psutil\n        $ sudo apt-get install i2c-tools\n        ```", "```\n    $ git clone https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes\n    $ cd Edge-Computing-Systems-with-Kubernetes/ch11/code\n    ```", "```\n    $ sudo python3 send.py\n    ```", "```\nimport time\nimport board\nimport adafruit_dht\nimport psutil\nimport paho.mqtt.client as mqtt\nimport sys\nfor proc in psutil.process_iter():\n   if proc.name() == 'libgpiod_pulsein'\n      or proc.name() == 'libgpiod_pulsei':\n      proc.kill()\nsensor = adafruit_dht.DHT11(board.D22)\nmqhost=\"192.168.0.243\"\nclient = mqtt.Client()\nclient.connect(mqhost, 1883, 60)\nclient.loop_start()\n\n def main(): \n   while True:\n      t = sensor.temperature \n      h = sensor.humidity\n      client.publish(\"sensor1\",\\\n      str({\"t\":int(t),\"h\":int(h)}))\n      time.sleep(2)\ntry:\n  main()\nexcept KeyboardInterrupt:\n  pass\nfinally:\n  sensor.exit()\n```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: grafana-datasources\n      namespace: monitoring\n    data:\n      prometheus.yaml: |-\n        {\n          \"apiVersion\": 1,\n          \"datasources\": [\n            {\n              \"access\":\"proxy\",\n              \"editable\": true,\n              \"name\": \"prometheus\",\n              \"orgId\": 1,\n              \"type\": \"prometheus\",\n              \"url\": \"http://prometheus-service.monitoring.svc:8080\",\n              \"version\": 1\n            }\n          ]\n        }\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: grafana\n      namespace: monitoring\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          app: grafana\n      template:\n        metadata:\n          name: grafana\n          labels:\n            app: grafana\n        spec:\n          containers:\n          - name: grafana\n            image: grafana/grafana:8.4.4\n            ports:\n            - name: grafana\n              containerPort: 3000\n            resources:\n              limits:\n                memory: \"1Gi\"\n                cpu: \"1000m\"\n    requests: \n                memory: 500M\n                cpu: \"500m\"\n            volumeMounts:\n              - mountPath: /var/lib/grafana\n                name: grafana-storage\n              - mountPath: /etc/grafana/provisioning/datasources\n                name: grafana-datasources\n                readOnly: false\n          volumes:\n            - name: grafana-storage\n              emptyDir: {}\n            - name: grafana-datasources\n              configMap:\n                  defaultMode: 420\n                  name: grafana-datasources\n    EOF\n    ```", "```\n    $ cat <<EOF | kubectl apply -f -\n    apiVersion: v1\n    kind: Service\n    metadata:\n      creationTimestamp: null\n      labels:\n        app: grafana\n      name: grafana\n      namespace: monitoring\n    spec:\n      ports:\n      - port: 3000\n        protocol: TCP\n        targetPort: 3000\n      selector:\n        app: grafana\n      type: ClusterIP\n    EOF\n    ```", "```\n    $ kubectl port-forward svc/grafana 3000 -n monitoring --address 0.0.0.0\n    ```"]