- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Kubernetes Secrets Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide you with a refresher about containers, as well as
    a comprehensive overview of Kubernetes and its Secrets management implementation.
    By the end of this first walk-through, all personas (developers, platform, and
    security engineers) will know how to design and implement these topics with a
    set of hands-on examples. While going through these examples, we will highlight
    the respective security concerns that this book will address by covering a series
    of use cases that will lead to a production-grade solution for hybrid multi-cloud
    scenarios, including the business continuity perspective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kubernetes’ origins and design principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our first Kubernetes testing environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Kubernetes `Secret` and `ConfigMap` objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing why Kubernetes Secrets are important
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unveiling the challenges and risks associated with Kubernetes Secrets management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping the objectives and scope of this book
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the hands-on parts of this chapter, we will be leveraging a series
    of tools and platforms that are commonly used to interact with containers, Kubernetes,
    and Secrets management. For this first chapter, we will be setting up this environment
    together and ramping up with a friendly desktop graphical solution for the first
    set of examples. Don’t worry – we have you covered with our Code in Action and
    GitHub repository, which contains the macOS installation example. Here is the
    list of required tools:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` at the user level to autostart containers/Pods.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Podman Desktop** ([https://podman-desktop.io](https://podman-desktop.io))
    is an open source software that provides a graphical user interface for building,
    starting, and debugging containers, running local Kubernetes instances, easing
    the migration from containers to Pods, and even connecting with remote platforms
    such as Red Hat OpenShift, Azure Kubernetes Engine, and more.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Golang** ([https://go.dev](https://go.dev)) or Go is a programming language
    that will be used within our examples. Note that Kubernetes and most of its third-party
    components are written in Go.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git** ([https://git-scm.com](https://git-scm.com)) is a version control system
    that we will be using to cover this book’s examples but will also leverage in
    our discovery of Secrets management solutions.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book’s GitHub repository contains the digital material linked to this
    book: [https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kubernetes’ origins and design principles
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the evolution from one platform to another might be obvious, the compelling
    event and inner mechanics might not be. To safely handle sensitive data within
    Kubernetes, we have to understand both its historical and architectural evolutions.
    This will help us implement a secure production-grade environment for our critical
    business applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从一个平台到另一个平台的演变可能显而易见，但其中的关键事件和内部机制可能并不明显。为了在Kubernetes中安全地处理敏感数据，我们必须理解其历史和架构演变。这将帮助我们为关键业务应用程序实施一个安全的生产级环境。
- en: The next few sections will describe a series of concepts, explore and practice
    them with a simple container runtime and Kubernetes cluster, and establish their
    direct relationships with security concerns that this handbook will address.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个章节将介绍一系列概念，探索并通过一个简单的容器运行时和Kubernetes集群进行实践，并建立这些概念与本手册将要解决的安全问题之间的直接联系。
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: While we expect you to perform the hands-on examples while reading along, we
    understand that you might not have the opportunity to do so. As such, we have
    provided briefings and debriefings for each hands-on example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们希望你在阅读的同时进行实际操作示例，但我们理解你可能没有机会这样做。因此，我们为每个实际操作示例提供了简要说明和回顾。
- en: From bare metal to containers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从裸金属到容器
- en: 'Four decades ago, deploying applications was done on a physical server, usually
    referred to as a *bare metal* installation. This approach allowed workloads to
    have direct access to physical resources with the best native performance possible.
    Due to out-of-the-box limitations for resource management from a software perspective,
    deploying more than one application on a physical server has always been an operational
    challenge that has resulted in a suboptimal model with the following root causes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 四十年前，应用程序的部署通常是在物理服务器上完成，这种方式通常被称为*裸金属*安装。这种方法使工作负载可以直接访问物理资源，提供最佳的原生性能。然而，由于从软件角度来看资源管理的局限性，在物理服务器上部署多个应用程序一直是一个运营挑战，这导致了一个次优的模型，根本原因如下：
- en: '**Physical resource utilization**: A reduced set of applications is deployed
    on a physical machine to limit the potential degradation of services due to the
    lack of proper resource management capabilities that would have helped address
    applications hogging all the compute resources.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理资源利用率**：在物理机器上部署较少的应用程序，以限制由于缺乏有效资源管理能力而导致的服务质量下降，这些能力本可以帮助解决某些应用程序占用所有计算资源的问题。'
- en: '**Scalability, flexibility, and time to market**: The lead time in weeks or
    even months to procure, rack and stack, provision the physical machine, and have
    the application installed, which impacts business growth.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性、灵活性和市场响应时间**：采购、安装、配置物理机器，并安装应用程序的时间通常需要几周甚至几个月，这会影响业务增长。'
- en: '**The total cost of ownership** (**TCO**) **versus innovation**: The procurement,
    integration, operations, and life cycle of physical servers, along with underutilized
    resources with limited prototyping due to high costs and lead time, slows down
    the organization’s innovation capabilities.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥有总成本**（**TCO**）**与创新**：物理服务器的采购、集成、运维和生命周期管理，加上由于高成本和长交付周期而导致的资源低利用和有限的原型开发，减缓了组织的创新能力。'
- en: Then, in the early 2000s, virtualization or *hypervisors* became available for
    commoditized open systems. A hypervisor is a piece of software that’s merged into
    the operating system, installed on bare metal, that allows the IT department to
    create virtual machines. With this, operations teams were able to create and tailor
    these virtual machines to the application’s precise requirements with the ability
    to adapt the compute resources during the application’s life cycle and their usage
    by the business. Thanks to proper resource management and isolation, multiple
    virtual machines could run on a single server without having noisy neighbors causing
    potential service degradations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在2000年代初，虚拟化或*虚拟机监控程序*开始在商品化的开放系统中得到应用。虚拟机监控程序是一种集成到操作系统中的软件，安装在裸金属服务器上，允许IT部门创建虚拟机。通过这一技术，运维团队能够根据应用程序的具体需求创建和定制这些虚拟机，并在应用生命周期中根据业务需求调整计算资源。得益于合理的资源管理和隔离，多个虚拟机可以在单一服务器上运行，而不会因邻近虚拟机的影响导致潜在的服务降级。
- en: 'This model provided tremendous optimizations that helped accelerate the digitalization
    of services and introduce a new market aside from the traditional data center
    business – cloud computing. However, the virtualization model created a new set
    of challenges:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The never-ending increase of virtual machines thanks to continuous innovation.
    This exponential growth of assets amplifies the operational burden to maintain
    and secure operating systems, libraries, and applications.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The increasing need for automation to perform daily **Create, Read, Update,
    and Delete** (**CRUD**) operations at a large scale involving complex infrastructure
    and security components.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for a well-thought governance that’s enforced to address the life cycle,
    security, and business continuity for thousands of services to support the business
    continuity of the organization’s critical applications.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, containers made their way as the next layer of optimization. Although
    the construct of containers was not new, as with virtualization, it required a
    major player to invest in the commoditized open systems to organically make it
    the next (r)evolution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think about a container as a lightweight virtual machine but without
    the need for a full operating system, which reduces the overall footprint and
    operational burden related to the software development life cycle and security
    management. Instead, multiple applications, as containers, share the underlying
    physical host from a software and hardware level without the overhead of the hypervisor
    benefiting from nearly machine-native performance. The container provides you
    with the following benefits:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: A well-defined standard by the OCI ([https://opencontainers.org](https://opencontainers.org))
    to ease with building, (re)distributing, and deploying containers to any platform
    that’s compliant with the specifications of the OCI
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A highly efficient, predictable, and immutable medium that’s application-centric
    and only includes the necessary libraries and the application runtime
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application portability thanks to an infrastructure and platform-agnostic solution
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An organic separation of concerns between the developers and platform engineers
    as there is no need to access the physical or virtual host operating system to
    develop, build, test, and deploy applications
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing an automation-first approach and DevOps practices to address the infrastructure,
    application, and security management
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not mentioning a few challenges would be wrong, so here are some:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Most IT organizations have difficulties embracing a new paradigm from both an
    architectural and management perspective
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the organic serparation of concerns between the developers and platform
    engineers as a support to silos
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s an overhype around microservices, which leads to potential suboptimal
    application architecture with no performance optimization but added complexity
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the bottom-up stack, which shows the potential
    application density per physical server with their respective deployment type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Layer comparison between bare metal, virtual machines, and containers](img/B20970_01_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Layer comparison between bare metal, virtual machines, and containers
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already cited a series of benefits, and yet, we should emphasize additional
    ones that help with rapid prototyping, faster deployment, easy live functional
    testing, and so on:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: A smaller code base to maintain and enrich per microservice with easier rollout/rollback
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capability to run in a degraded mode when one of the microservices fails
    but not the others
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to troubleshoot misbehaving microservices without impacting the
    entire application
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s faster to recover from failure as only the related microservice must be
    rescheduled
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granular compute resource allocation and scalability
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only do microservices help decouple large monolithic applications but they
    also introduce new design patterns to accelerate innovation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'This sounds fantastic, doesn’t it? It does, but we still have a major missing
    element here: container runtimes such as Docker or Podman do not provide any resiliency
    in case of failures. To do so, a container runtime requires an additional software
    layer providing the applications with high availability capabilities. Managing
    hundreds of microservices at scale demands a robust and highly resilient orchestrator
    to ensure the business continuity of the applications while guaranteeing a high
    level of automation and abstraction toward the underlying infrastructure. This
    will lead to frictionless build, deploy, and run operations, improving the day-to-day
    responsibilities of the IT staff involved with the workloads that are deployed
    on the application platforms.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This is a big ask and a challenge that many IT departments are facing and trying
    to solve, even more so with legacy patterns. The answer to this complex equation
    is Kubernetes, a container platform or, as we should call it, an application platform.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes overview
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no better words to describe what Kubernetes is all about than the
    words from the Kubernetes project maintainers: “*Containers are a good way to
    bundle and run your applications. In a production environment, you need to manage
    the containers that run the applications and ensure that there is no downtime.
    For example, if a container goes down, another container needs to start. Wouldn’t
    it be easier if this behavior was handled by* *a system?*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '*That’s how Kubernetes comes to the rescue! Kubernetes provides you with a
    framework to run distributed systems resiliently. It takes care of scaling and
    failover for your application, provides deployment patterns, and* *more.*” ([https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do](https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do))'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The same page lists the following benefits of Kubernetes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的同一页面列出以下Kubernetes的优势：
- en: Service discovery and load balancing
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现和负载平衡
- en: Storage orchestration
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储编排
- en: Automated rollouts and rollbacks
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化的部署和回滚
- en: Automatic bin packing
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动的装箱
- en: Self-healing
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自愈
- en: Secret and configuration management
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secret和配置管理
- en: While reading through this handbook, we will explore and practice all of these
    benefits while designing a production-grade Secrets management solution for critical
    workloads.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本手册时，我们将探索并实践所有这些优势，同时为关键工作负载设计生产级别的Secrets管理解决方案。
- en: Kubernetes design principles
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes的设计原则
- en: We have established the context regarding the evolution and adoption of containers
    with the need for Kubernetes to support our applications with resiliency, scalability,
    and deployment patterns in mind. But how is Kubernetes capable of such a frictionless
    experience?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了关于容器的演变和采用的背景，以及Kubernetes在考虑到我们的应用程序需要具备弹性、可伸缩性和部署模式的情况下的能力。但是，Kubernetes如何实现如此无摩擦的体验？
- en: 'Here is my attempt to answer this question based on having experience as a
    former cloud architect within the Red Hat Professional Services organization:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基于作为Red Hat专业服务组织中的前云架构师的经验，我尝试回答这个问题：
- en: From a workload perspective, every infrastructure requirement that an application
    will consume is simply defined in a declarative way without the need for there
    to be a domain specialist in networking, storage, security, and so on. The YAML
    manifest describing the desired state of `Pod`, `Service`, and `Deployment` objects
    is then handled by Kubernetes as a service broker for every specific vendor who
    has a Kubernetes integration. In other words, application teams can safely write
    a manifest that is agnostic of the environment and Kubernetes distribution on
    which they will deploy the workloads.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从工作负载的角度来看，应用程序将使用的每个基础设施需求都以声明方式简单定义，无需网络、存储、安全等领域专家介入。描述`Pod`、`Service`和`Deployment`对象期望状态的YAML清单然后由Kubernetes作为服务代理处理，供应商为每个具有Kubernetes集成的特定供应商编写一个与环境和Kubernetes发行版无关的清单。
- en: From an infrastructure perspective, every component of the stack has a corresponding
    Kubernetes API object. If not, the vendor can introduce their own with the standard
    Kubernetes API object called `CustomResourceDefinition`, also known as **CRD**.
    This guarantees a common standard, even when interacting with third-party software,
    hardware, or cloud vendors.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从基础设施的角度来看，堆栈的每个组件都有相应的Kubernetes API对象。如果没有，供应商可以通过标准的Kubernetes API对象`CustomResourceDefinition`（也称为**CRD**）引入自己的对象。这确保了一个共同的标准，即使与第三方软件、硬件或云供应商交互时也是如此。
- en: When Kubernetes receives a request with a valid object definition, the orchestrator
    will apply the related CRUD operation. In other words, Kubernetes introduces native
    automation and orchestration. The same principles should apply to every Kubernetes
    component running as a container so that they benefit from self-healing, resiliency,
    and scalability while being agnostic of the underlying software, hardware, or
    cloud provider.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当Kubernetes收到具有有效对象定义的请求时，编排器将应用相关的CRUD操作。换句话说，Kubernetes引入了本地自动化和编排。同样的原则应适用于作为容器运行的每个Kubernetes组件，以便它们从自愈、弹性和可伸缩性中受益，同时不依赖于底层软件、硬件或云提供商。
- en: This approach supports the portability not only of containerized applications
    but of the entire application platform while reducing the need for technology
    domain specialists to be involved when deploying an application, maintaining the
    platform, and even enriching the Kubernetes project with new features or components.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅支持容器化应用程序的可移植性，还支持整个应用程序平台的可移植性，同时减少了在部署应用程序、维护平台甚至通过新功能或组件丰富Kubernetes项目时需要技术专家参与的需求。
- en: 'The concept of a YAML manifest to define a Kubernetes API object has been floating
    around for a while. It is time to look at a simple example that shows the desired
    state of a `Pod` object (a logical grouping for one or multiple containers):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义Kubernetes API对象的YAML清单的概念已经流行了一段时间。现在是时候看一个简单的例子，显示`Pod`对象（一个或多个容器的逻辑分组）的期望状态：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `Pod` object’s definition provides the necessary information for Kubernetes
    to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此`Pod`对象的定义为Kubernetes提供了以下必要信息：
- en: Define the desired state for a `Pod` object with the name `hello-app`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义具有名称`hello-app`的`Pod`对象的期望状态。
- en: Specify that there are `containers` and that one of them is called `hello-world`
    and uses a container image of `hello-path`. For this, we want version `0.1` to
    be pulled from a container registry.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept incoming traffic to the `hello-world` application, using port `8080`
    at the container level.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s it! This is our first `Pod` definition. It allows us to deploy a simple
    containerized application with no fuzz and zero knowledge of the underlying infrastructure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes architecture
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is not much magic behind this orchestration but the work of multiple
    components provides a fantastic level of resilience and abstraction, as well as
    a frictionless experience. The following diagram provides an overview of the components
    that run within a Kubernetes instance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Kubernetes components](img/B20970_01_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Kubernetes components
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster can be divided into two logical groups – the control plane
    (some distributions refer to this as the master node) and the (worker) nodes.
    Let’s drill down into each logical group and discover their respective components:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Control plane:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-apiserver`: This component is responsible for exposing the Kubernetes
    API and enabling CRUD operations regarding the object definitions and their state
    within `etcd`.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd`: This component is a key value store and serves as the asset management
    service. A corrupted `etcd` results in a full disaster scenario.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-scheduler`: This component tracks the desired state of `Pod` and will
    address any potential drift within the cluster. As an example, if a `Pod` object
    definition is created or modified, `kube-scheduler` will adjust its state so that
    the containers only run on a healthy node.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-controller-manager`: This component runs a series of controllers that
    are responsible for handling the desired state of the nodes, jobs, endpoints,
    and service accounts. Controllers are reconciliation loops that track the difference
    between the desired and current state of an object and adjust the latter so that
    it matches the latest object definition.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud-controller-manager` (*optional*): Similar to `kube-controller-manager`,
    this component, when deploying Kubernetes in the cloud, enriches the cluster with
    additional abstractions to interact with the related cloud provider services.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nodes (and the control plane too!):'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubelet`: This component interacts with `kube-apiserver` to verify and adjust
    the desired states of Pods bound to the node'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubeproxy`: This component provides the basic network plumbing on each node
    while maintaining the networking rules to allow (or not) the internal and external
    network traffic to Pods'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container runtime`: This component runs the containers'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are additional components that should be considered as add-ons due to
    their direct dependency on the Kubernetes distribution. These add-ons would be
    responsible for handling services such as DNS, logging, metrics, the user interface,
    and more.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In a dev/test environment, a single node might be deployed to act both as a
    control plane and a worker node on which Pods will be scheduled. However, for
    resiliency purposes, a production-grade environment should consider a minimum
    of three control planes with dedicated worker nodes to improve resilience and
    separation of concerns, as well as dedicate compute resources for the applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Getting hands-on – from a local container to a Kubernetes Pod
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main benefits of containers are their portability and being platform agnostic.
    Deploying the famous *Hello World* application within a container using Docker,
    Podman, or Kubernetes should not require us to modify the application code. I
    will even go a step further and say that we should not care about the underlying
    infrastructure. On the other hand, there would be a large umbrella of constraints
    to deal with when deploying an application with a bare metal or virtualization
    approach.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we assume that you have the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: All the technical requirements mentioned at the beginning of this chapter
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to this book’s GitHub repository ([https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook))
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example at hand; it is available in the `ch01/example01` folder
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have a look at a simple example illustrating a basic software supply
    chain:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**Building the application binary**: The example is a simple Go application
    showcasing an HTTP service and console logging capabilities'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building the container image, including the application binary**: The application
    will be built using a Golang toolset container image; a second small footprint
    container image will be used to carry the application binary'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running the containerized application using Podman**: This first run will
    leverage the graphical interface of Podman Desktop to illustrate the rather simple
    process of running a container'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl` command line to showcase how to process our first YAML manifest to
    create a Kubernetes `Pod` object'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this example is agnostic of the CPU architecture on which the overall
    process will take place. This means that you can safely perform the same exercise
    on different CPU targets without the need to rewrite code or change any of the
    configuration files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to note that a container runtime such as Docker or Podman
    is used to build the application and the container image containing our application
    binary. This is done via a text file called a Dockerfile, which defines all the
    necessary steps to build our container image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Dockerfile build steps are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the `go-toolset` image for the build.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get all the application content in that image.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Go build process.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the `ubi-micro` image as the target container.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set some container image metadata.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the binary from the build image to the target image.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a port exposure for the application. Here, this is `8080`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application binary.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序二进制文件。
- en: That’s it! Once the application has been built and the container image has been
    successfully created and pushed to the registry, the container image will be available
    in the localhost container registry, after which the container can be started
    using either Docker or Podman. This can be done through one simple command line
    with a few parameters, though you can leverage the Podman Desktop graphical interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一旦应用程序构建完成，容器镜像成功创建并推送到注册中心，容器镜像将可在本地容器注册中心使用，之后可以使用 Docker 或 Podman 启动容器。只需通过一个简单的命令行加上几个参数即可完成此操作，尽管你也可以利用
    Podman Desktop 图形界面。
- en: On the other hand, running this container on an application platform such as
    Kubernetes requires a different approach – that is, declaratively using a YAML
    manifest. An example was supplied earlier in this chapter and can be found in
    this book’s GitHub repository. This YAML manifest is submitted to `kube-apiserver`
    via a tool such as `kubectl`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在像 Kubernetes 这样的应用平台上运行容器需要不同的方法——也就是说，声明性地使用 YAML 清单。一个示例已在本章前面提供，并可以在本书的
    GitHub 仓库中找到。此 YAML 清单通过诸如 `kubectl` 之类的工具提交给 `kube-apiserver`。
- en: 'Here is a transactional overview of a Kubernetes `Pod` object’s creation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kubernetes `Pod` 对象创建的事务性概览：
- en: '![Figure 1.3 – Kubernetes Pod creation](img/B20970_01_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – Kubernetes Pod 创建](img/B20970_01_03.jpg)'
- en: Figure 1.3 – Kubernetes Pod creation
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – Kubernetes Pod 创建
- en: As we can see, the `etcd` record is continuously updated during the `Pod` object’s
    creation. The desired state is saved; the current status of every component involved
    in the process is also saved, which generates a sort of audit trail. Such a design
    allows for easier debugging when the desired outcome is not achieved.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`etcd` 记录在 `Pod` 对象创建期间持续更新。所需状态被保存；过程中的每个组件的当前状态也被保存，从而生成一种审计轨迹。这种设计使得当未达到预期结果时，调试变得更加容易。
- en: As soon as the `Pod` object is registered within `etcd`, all the Kubernetes
    components are on a mission to converge toward the desired state, regardless of
    potential issues such as network partitioning, node failure, and more. This is
    the difference between running containers on a single machine with a local container
    runtime such as Docker or Podman and orchestrating containers at scale with a
    container platform such as Kubernetes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Pod` 对象在 `etcd` 中注册，所有 Kubernetes 组件便会开始执行任务，向所需状态聚合，无论是否存在网络分区、节点故障等潜在问题。这就是在单台机器上使用本地容器运行时（如
    Docker 或 Podman）运行容器与使用像 Kubernetes 这样的容器平台进行大规模编排的区别。
- en: 'Here’s some food for thought:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些值得思考的内容：
- en: I wrote “*running the containerized applications*” and “*deploying the containerized
    application*” to illustrate the difference between a container runtime such as
    Docker or Podman running a containerized application and Kubernetes scheduling
    containers and orchestrating other resources such as networking, storage, Secrets,
    and more. Note that there is a Kubernetes object called `Deployment` that addresses
    release management and scalability capabilities. For more details, see [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我写了“*运行容器化应用程序*”和“*部署容器化应用程序*”来说明容器运行时（如 Docker 或 Podman）运行容器化应用程序与 Kubernetes
    调度容器并编排其他资源（如网络、存储、密钥等）之间的区别。请注意，Kubernetes 中有一个名为`Deployment`的对象，用于处理发布管理和可扩展性功能。更多细节请参见
    [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)。
- en: Performing such an exercise even in a non-production environment using virtual
    machines could take days, even weeks.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在非生产环境中使用虚拟机执行这样的操作，也可能需要几天甚至几周的时间。
- en: Developing applications using containers, for both monolithic or microservice
    application architecture, allows for a truly agile development cycle calling for
    everything to be continuous (development, integration, improvement, and deployment).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器开发应用程序，无论是单体架构还是微服务架构，都可以实现真正敏捷的开发周期，要求一切都必须是持续的（开发、集成、改进和部署）。
- en: Using YAML manifests to deploy applications will trigger an organic usage of
    Git repositories that will spark another practice – GitOps. In short, every desired
    state definition of an application and its infrastructure management lands in
    a Git repository, providing the *application* and *infrastructure* teams with
    a central point of configuration management, including, by default, authorization,
    peer review, and organization.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we’ve transitioned from running the target application through a
    local container to running it through a Kubernetes Pod. By doing so, we acquired
    an understanding of how a Pod is created, which Kubernetes components are involved,
    the interactions that are involved, and more.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Secrets within Kubernetes
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we had a refresher on containers and Kubernetes, and we also
    proceeded with a hands-on example that helped us establish key concepts, such
    as the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of application deployment through times and technologies
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why containers and Kubernetes
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture and principles of Kubernetes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running containers using Podman Desktop and Kubernetes
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the knowledge we’ve acquired, we can start looking at the more advanced
    concept of Secrets within Kubernetes. We will dive into the details of how Secrets
    are stored on Kubernetes, how they are injected into a Pod, which is the smallest
    execution unit, and the security concerns that we have to tackle.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Secrets concepts
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interestingly enough, during my time designing and deploying Red Hat OpenShift,
    this topic was always considered irrelevant to the customer and partner teams
    that I was working with. Reflecting, I concluded that this is linked to the legacy
    patterns we have been working with for the last two or three decades.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional environment, both with physical and virtual machines, there
    is a clear outcome from the separation of concerns principle. The infrastructure
    teams care about the infrastructure and the application teams care about applications.
    This includes managing Secrets such as credentials, tokens, license keys, certificates,
    and more. No one from the application teams will share credentials for a MySQL
    database with the infrastructure teams.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to Kubernetes, these concerns are, by design, merged into a point
    of entry: the application platform. Despite the separation of concerns, the Kubernetes
    integration with external API-driven services requires credentials, tokens, or
    certificates to authenticate and trust themselves. These Secrets have to stay
    within the platform to ensure resiliency, scalability, and orchestration for both
    the cluster and applications.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the container image’s design, Secrets cannot be hardcoded or
    included in the container image. By hardcoding Secrets, they become available
    to all internal and external stakeholders with access to the container image registry.
    If the container image is pushed to a public registry, which is common to ease
    with redistribution, it will make the Secrets available to an even wider audience.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the reason why Kubernetes has a Secrets management framework built
    into it with a dedicated API object called `Secret`. Here is an overview of what
    a `Secret` object definition would look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s go through the manifest:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We informed Kubernetes that we wanted to create a `Secret` object
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name for this object is `mysecret` and we defined a type called `Opaque`,
    which means that we are defining the container of the `data` field ourselves
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data` field is composed of two key-value pairs
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s have a closer look at these key-value pairs. What seems to be a random
    set of characters is data being encoded in `base64`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Why `base64`? While we could assume the need to encrypt sensitive data such
    as credentials, the usage of `base64` is only to ease the processing that’s done
    through the command line, the network, and by `kube-apiserver` to avoid us processing
    a truncated payload due to special characters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: These two entries can be decoded on every operating system or website offering
    a `base64` encoding/decoding tool. So, should we assume that `kube-apiserver`,
    when saving the payload within the `etcd` key store, will encrypt the data? Well,
    this handbook has already given you a good hint that it doesn’t!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Another API object has a similar data field that can be used to share sensitive
    data with an application: `ConfigMap`. While `ConfigMap` was designed to carry
    out environment variables and application arguments, its usage has been rapidly
    adopted by developers to also include advanced application configuration, similar
    to a license key file. This object’s content could be leveraged by a malicious
    hacker to access containers, gain access to other workloads either inside or outside
    the platform, and even gain control of the Kubernetes cluster. As such, `ConfigMap`
    should be carefully handled, just like `Secret` objects. Here is an overview of
    a `ConfigMap` object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, there is a major difference between the `data` field of `Secret`
    and the `data` field of `ConfigMap` – the encoding part. The `data` field specification
    of `ConfigMap` expects UTF-8 strings while the `Secret` one expects key-value
    pairs with the value encoded in `base64`. This example shows a way to set an application
    to `dev` mode, thus enabling extra instrumentation for debugging purposes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Storing Secrets on Kubernetes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now is a good time for a second hands-on example so that we can understand
    the differences between Secrets and the other Kubernetes objects, such as `ConfigMap`.
    Before we start, we assume that you have the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: All the technical requirements mentioned at the beginning of this chapter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to this book’s GitHub repository: [https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example at hand; it is available in the `ch01/example02` folder
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have a look at what we are accomplishing with this example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: First, we are creating a `Secret` object using the provided YAML manifest, a
    secret definition similar to the one we created for `mysecret` earlier. We are
    also checking its status and how to recover its definition from Kubernetes. This
    is always handy when we want to recover the current state of an object so that
    we can create it again later. We are also decoding the `base64` payload to reveal
    the key-value pairs.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we are recovering the YAML manifest from Kubernetes to show a very simple
    way to get back our `Secret` object and its sensitive data. In other words, if
    malicious hackers succeed in interacting with `kube-apiserver`, then they can
    extract some or all `Secret` objects from a Kubernetes cluster.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we are creating a new `Secret` object from scratch by encoding the key-value
    pairs in `base64`, writing the YAML manifest, and pushing it via the command line.
    Here is a transactional overview of a Kubernetes `Secret` object’s creation:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Secret creation](img/B20970_01_04.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Secret creation
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to access the `Secret` payload from a `Pod` object. In this
    example, we are using a special type of container called `busybox` that provides
    a small footprint environment that’s ideal for performing testing/debugging. The
    `Pod` manifest includes the reference to our newly created `Secret` object and
    assigns the value to an environment variable that we will `echo` from `busybox`.
    This will appear within container logs. Here is a transactional overview of a
    Kubernetes `Pod` object being created, including the `Secret` object being injected:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Injecting Secret into Pod](img/B20970_01_05.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Injecting Secret into Pod
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `kubelet` component will be responsible for decoding the `base64`
    payload. This is to ensure that the payload is transported between the different
    components and across the wire.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we access the `etcd` key store via its API. This shows that the data that’s
    retrieved via such a method is not encrypted nor `base64` encoded! At this stage,
    malicious hackers who have successfully breached the `etcd` Pod have full access
    to Kubernetes asset management and can control the entire destiny of the application
    platform up to a cloud provider account if it’s deployed in such a setup.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we are going one step further by extracting the `etcd` file locally
    and examining it to retrieve our last created `Secret` object. This seems to be
    a far-fetched scenario but think about filesystem access or backups taken of the
    Kubernetes cluster, which includes the `etcd` file. Even if the Kubernetes cluster
    is well-hardened with limited security exposure, malicious hackers who breach
    the storage and/or backup system(s) can retrieve all the `Secret` objects from
    such files.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compared to the previous `Pod` creation workflow, we can establish the relatively
    low impact from a transaction perspective on the overall process. Note that our
    first example shows how to load the `Secret` key-value pairs as environment variables.
    However, other options also exist; we will be exploring their potential mitigations
    later in this book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the container that has the environment variable defined within its `Pod`
    specs will have access to the key-value pairs. However, containers running with
    `privileged: true` will have access to all Secrets from the node on which it runs,
    resulting in a major security exposure.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Why should we care?
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Kubernetes provides a frictionless experience for both the platform and
    application teams, it does not provide you with a hardened solution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The first approach to tackle this security concern would be to leverage a vault
    solution (the likes of HashiCorp Vault, CyberArk Conjure, or Azure Key Vault).
    However, this would only secure the application side. We are still exposed to
    taking into account the usage of `ConfigMap` or multi-cluster services such as
    application interconnect, which involves leveraging mutual authentication with
    certificates generated and deployed within the application platform.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s rethink the requirements into simple layers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`Secret` objects are created to allow internal components to interact with
    others (storage, networking, execution units, controllers, and so on). Third-party
    components being deployed later on to enrich the platform’s capabilities will
    follow the same model. These `Secret` objects should not be offloaded to a vault
    solution for resilience purposes. If there is any type of partitioning with the
    external Vault solution, the Kubernetes cluster will start collapsing, along with
    all the workloads.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigMap` object, an encryption key for their volumes, TLS certificates,
    and so on.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the observation about platform-related `Secret` objects, these should
    be stored within Kubernetes to ensure the scheduling, self-healing, and operability
    capabilities of the application platform.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By design, Kubernetes will not become a storage system or an encrypted Vault
    to protect sensitive data. Instead, Kubernetes will provide the necessary framework
    to interconnect and leverage the expertise of third-party solutions addressing
    each domain’s specific needs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Considering these aspects, addressing the security concerns for Secrets Management
    in Kubernetes is not as simple as ticking a box.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Security exposures
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have established the benefits of containerized applications
    running on Kubernetes but also the security challenges of Secrets Management on
    such application platforms.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Through our hands-on examples, we have acknowledged how unsafe our sensitive
    data is within `Secret` and `ConfigMap` objects. We can also list a series of
    security exposures to be exploited to compromise the application platform, including
    external services:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-apiserver**: This is the main component of Kubernetes and malicious
    hackers can leverage this first point of entry to the application platform'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd` does not provide any encryption capabilities. The database file is a
    binary file that can be easily read.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-apiserver` component, `etcd` is an API-driven service and any access
    or network trace can expose the data.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pod` object means accessing the filesystem on which the database file is written.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd` Pod has its filesystem hosted on a volume to provide persistent storage.
    This volume is attached to the node, and by accessing the node, the data can also
    be accessed through the attached volume.*   `etcd` file. Accessing the backup
    can expose the data.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are various ways that Secrets can be exposed. For example, you can interact
    with Kubernetes components such as `kube-apiserver` and `etcd` to do this or go
    through a physical level such as direct node access or access to backups.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced containers, Kubernetes, and Secrets. We provided
    an overview of the history so far, going through the concepts of bare metal, virtual
    machine, and container-based deployments. We had the opportunity to understand
    the benefits of containerization and introduce container orchestration engines.
    We learned more about Kubernetes and its components, which made it possible for
    us to run our first Kubernetes secret example and also have a deep dive into the
    Kubernetes components involved to facilitate secret usage. This helped us identify
    the security and robustness concerns that come with the usage of Kubernetes Secrets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on the different types of Kubernetes Secrets,
    their usages, and the cross-cutting concerns that Secrets come with, such as auditing
    and access permissions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
