- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Kubernetes Secrets Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes Secrets 管理
- en: This chapter will provide you with a refresher about containers, as well as
    a comprehensive overview of Kubernetes and its Secrets management implementation.
    By the end of this first walk-through, all personas (developers, platform, and
    security engineers) will know how to design and implement these topics with a
    set of hands-on examples. While going through these examples, we will highlight
    the respective security concerns that this book will address by covering a series
    of use cases that will lead to a production-grade solution for hybrid multi-cloud
    scenarios, including the business continuity perspective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供容器的复习内容，以及 Kubernetes 和其 Secrets 管理实现的全面概述。在这个第一部分的实践中，所有角色（开发人员、平台和安全工程师）都将了解如何设计和实现这些主题，并通过一系列实际示例加以说明。在这些示例中，我们将重点突出本书将解决的相应安全问题，涵盖一系列用例，最终为混合多云场景提供一个生产级的解决方案，包括业务连续性视角。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Kubernetes’ origins and design principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 的起源和设计原则
- en: Setting up our first Kubernetes testing environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的第一个 Kubernetes 测试环境
- en: Exploring Kubernetes `Secret` and `ConfigMap` objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Kubernetes 的 `Secret` 和 `ConfigMap` 对象
- en: Analyzing why Kubernetes Secrets are important
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析为什么 Kubernetes Secrets 很重要
- en: Unveiling the challenges and risks associated with Kubernetes Secrets management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示与 Kubernetes Secrets 管理相关的挑战和风险
- en: Mapping the objectives and scope of this book
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书目标和范围的映射
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the hands-on parts of this chapter, we will be leveraging a series
    of tools and platforms that are commonly used to interact with containers, Kubernetes,
    and Secrets management. For this first chapter, we will be setting up this environment
    together and ramping up with a friendly desktop graphical solution for the first
    set of examples. Don’t worry – we have you covered with our Code in Action and
    GitHub repository, which contains the macOS installation example. Here is the
    list of required tools:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为完成本章的实践部分，我们将利用一系列常用于与容器、Kubernetes 和 Secrets 管理交互的工具和平台。在本章中，我们将一起设置这个环境，并通过一个友好的桌面图形解决方案进行第一组示例的启动。别担心——我们为您准备了
    Code in Action 和 GitHub 仓库，其中包含 macOS 安装示例。以下是所需工具的列表：
- en: '`systemd` at the user level to autostart containers/Pods.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户级别使用 `systemd` 来自动启动容器/Pods。
- en: '**Podman Desktop** ([https://podman-desktop.io](https://podman-desktop.io))
    is an open source software that provides a graphical user interface for building,
    starting, and debugging containers, running local Kubernetes instances, easing
    the migration from containers to Pods, and even connecting with remote platforms
    such as Red Hat OpenShift, Azure Kubernetes Engine, and more.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Podman Desktop** ([https://podman-desktop.io](https://podman-desktop.io))
    是一款开源软件，提供图形用户界面用于构建、启动和调试容器，运行本地 Kubernetes 实例，简化从容器到 Pod 的迁移，甚至可以连接到如 Red Hat
    OpenShift、Azure Kubernetes Engine 等远程平台。'
- en: '**Golang** ([https://go.dev](https://go.dev)) or Go is a programming language
    that will be used within our examples. Note that Kubernetes and most of its third-party
    components are written in Go.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Golang** ([https://go.dev](https://go.dev)) 或 Go 是我们示例中将使用的编程语言。请注意，Kubernetes
    及其大多数第三方组件都是用 Go 编写的。'
- en: '**Git** ([https://git-scm.com](https://git-scm.com)) is a version control system
    that we will be using to cover this book’s examples but will also leverage in
    our discovery of Secrets management solutions.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git** ([https://git-scm.com](https://git-scm.com)) 是我们将用来展示本书示例的版本控制系统，也将在我们探索
    Secrets 管理解决方案时发挥作用。'
- en: 'This book’s GitHub repository contains the digital material linked to this
    book: [https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 GitHub 仓库包含与本书相关的数字资料：[https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)。
- en: Understanding Kubernetes’ origins and design principles
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 的起源和设计原则
- en: While the evolution from one platform to another might be obvious, the compelling
    event and inner mechanics might not be. To safely handle sensitive data within
    Kubernetes, we have to understand both its historical and architectural evolutions.
    This will help us implement a secure production-grade environment for our critical
    business applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从一个平台到另一个平台的演变可能显而易见，但其中的关键事件和内部机制可能并不明显。为了在Kubernetes中安全地处理敏感数据，我们必须理解其历史和架构演变。这将帮助我们为关键业务应用程序实施一个安全的生产级环境。
- en: The next few sections will describe a series of concepts, explore and practice
    them with a simple container runtime and Kubernetes cluster, and establish their
    direct relationships with security concerns that this handbook will address.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个章节将介绍一系列概念，探索并通过一个简单的容器运行时和Kubernetes集群进行实践，并建立这些概念与本手册将要解决的安全问题之间的直接联系。
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: While we expect you to perform the hands-on examples while reading along, we
    understand that you might not have the opportunity to do so. As such, we have
    provided briefings and debriefings for each hands-on example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们希望你在阅读的同时进行实际操作示例，但我们理解你可能没有机会这样做。因此，我们为每个实际操作示例提供了简要说明和回顾。
- en: From bare metal to containers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从裸金属到容器
- en: 'Four decades ago, deploying applications was done on a physical server, usually
    referred to as a *bare metal* installation. This approach allowed workloads to
    have direct access to physical resources with the best native performance possible.
    Due to out-of-the-box limitations for resource management from a software perspective,
    deploying more than one application on a physical server has always been an operational
    challenge that has resulted in a suboptimal model with the following root causes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 四十年前，应用程序的部署通常是在物理服务器上完成，这种方式通常被称为*裸金属*安装。这种方法使工作负载可以直接访问物理资源，提供最佳的原生性能。然而，由于从软件角度来看资源管理的局限性，在物理服务器上部署多个应用程序一直是一个运营挑战，这导致了一个次优的模型，根本原因如下：
- en: '**Physical resource utilization**: A reduced set of applications is deployed
    on a physical machine to limit the potential degradation of services due to the
    lack of proper resource management capabilities that would have helped address
    applications hogging all the compute resources.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理资源利用率**：在物理机器上部署较少的应用程序，以限制由于缺乏有效资源管理能力而导致的服务质量下降，这些能力本可以帮助解决某些应用程序占用所有计算资源的问题。'
- en: '**Scalability, flexibility, and time to market**: The lead time in weeks or
    even months to procure, rack and stack, provision the physical machine, and have
    the application installed, which impacts business growth.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性、灵活性和市场响应时间**：采购、安装、配置物理机器，并安装应用程序的时间通常需要几周甚至几个月，这会影响业务增长。'
- en: '**The total cost of ownership** (**TCO**) **versus innovation**: The procurement,
    integration, operations, and life cycle of physical servers, along with underutilized
    resources with limited prototyping due to high costs and lead time, slows down
    the organization’s innovation capabilities.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥有总成本**（**TCO**）**与创新**：物理服务器的采购、集成、运维和生命周期管理，加上由于高成本和长交付周期而导致的资源低利用和有限的原型开发，减缓了组织的创新能力。'
- en: Then, in the early 2000s, virtualization or *hypervisors* became available for
    commoditized open systems. A hypervisor is a piece of software that’s merged into
    the operating system, installed on bare metal, that allows the IT department to
    create virtual machines. With this, operations teams were able to create and tailor
    these virtual machines to the application’s precise requirements with the ability
    to adapt the compute resources during the application’s life cycle and their usage
    by the business. Thanks to proper resource management and isolation, multiple
    virtual machines could run on a single server without having noisy neighbors causing
    potential service degradations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在2000年代初，虚拟化或*虚拟机监控程序*开始在商品化的开放系统中得到应用。虚拟机监控程序是一种集成到操作系统中的软件，安装在裸金属服务器上，允许IT部门创建虚拟机。通过这一技术，运维团队能够根据应用程序的具体需求创建和定制这些虚拟机，并在应用生命周期中根据业务需求调整计算资源。得益于合理的资源管理和隔离，多个虚拟机可以在单一服务器上运行，而不会因邻近虚拟机的影响导致潜在的服务降级。
- en: 'This model provided tremendous optimizations that helped accelerate the digitalization
    of services and introduce a new market aside from the traditional data center
    business – cloud computing. However, the virtualization model created a new set
    of challenges:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这一模型提供了巨大的优化，帮助加速了服务的数字化，并引入了一个除了传统数据中心业务外的新市场——云计算。然而，虚拟化模型也带来了新的挑战：
- en: The never-ending increase of virtual machines thanks to continuous innovation.
    This exponential growth of assets amplifies the operational burden to maintain
    and secure operating systems, libraries, and applications.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机的数量由于持续创新而不断增加。这种资产的指数级增长加剧了维护和保障操作系统、库和应用程序的运营负担。
- en: The increasing need for automation to perform daily **Create, Read, Update,
    and Delete** (**CRUD**) operations at a large scale involving complex infrastructure
    and security components.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大规模复杂基础设施和安全组件进行日常**创建、读取、更新和删除**（**CRUD**）操作的自动化需求日益增加。
- en: The need for a well-thought governance that’s enforced to address the life cycle,
    security, and business continuity for thousands of services to support the business
    continuity of the organization’s critical applications.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个经过深思熟虑的治理框架来强制执行，以解决数千个服务的生命周期、安全性和业务连续性，从而支持组织关键应用程序的业务连续性。
- en: Finally, containers made their way as the next layer of optimization. Although
    the construct of containers was not new, as with virtualization, it required a
    major player to invest in the commoditized open systems to organically make it
    the next (r)evolution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，容器作为下一层优化方式崭露头角。尽管容器的构建并不新颖，与虚拟化一样，它需要一个重要的参与者在商品化的开放系统上进行投资，使其有机地成为下一次（r）革命。
- en: 'Let’s think about a container as a lightweight virtual machine but without
    the need for a full operating system, which reduces the overall footprint and
    operational burden related to the software development life cycle and security
    management. Instead, multiple applications, as containers, share the underlying
    physical host from a software and hardware level without the overhead of the hypervisor
    benefiting from nearly machine-native performance. The container provides you
    with the following benefits:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把容器看作是一种轻量级的虚拟机，但不需要完整的操作系统，从而减少了与软件开发生命周期和安全管理相关的整体资源消耗和运营负担。相反，多个应用程序作为容器共享底层物理主机，无需虚拟化管理程序的开销，并且能够获得接近本机性能的好处。容器为您提供以下优点：
- en: A well-defined standard by the OCI ([https://opencontainers.org](https://opencontainers.org))
    to ease with building, (re)distributing, and deploying containers to any platform
    that’s compliant with the specifications of the OCI
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCI（[https://opencontainers.org](https://opencontainers.org)）提供了一个明确定义的标准，便于在任何符合OCI规范的平台上构建、（重新）分发和部署容器。
- en: A highly efficient, predictable, and immutable medium that’s application-centric
    and only includes the necessary libraries and the application runtime
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种高度高效、可预测且不可变的介质，应用程序中心化，只包含必要的库和应用程序运行时
- en: Application portability thanks to an infrastructure and platform-agnostic solution
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于基础设施和平台无关的解决方案，实现了应用程序的可移植性
- en: An organic separation of concerns between the developers and platform engineers
    as there is no need to access the physical or virtual host operating system to
    develop, build, test, and deploy applications
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员和平台工程师之间有机的关注点分离，因为不需要访问物理或虚拟主机操作系统就能开发、构建、测试和部署应用程序
- en: Embracing an automation-first approach and DevOps practices to address the infrastructure,
    application, and security management
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采纳自动化优先的方法和DevOps实践，来处理基础设施、应用程序和安全管理
- en: 'Not mentioning a few challenges would be wrong, so here are some:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不提及一些挑战，那就是不对的，以下是一些挑战：
- en: Most IT organizations have difficulties embracing a new paradigm from both an
    architectural and management perspective
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数IT组织在架构和管理方面都难以接受这一新范式
- en: Considering the organic serparation of concerns between the developers and platform
    engineers as a support to silos
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到开发人员和平台工程师之间的有机关注点分离，以支持各自的孤岛结构
- en: There’s an overhype around microservices, which leads to potential suboptimal
    application architecture with no performance optimization but added complexity
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于微服务的炒作过头了，这可能导致潜在的次优应用架构，既没有性能优化，又增加了复杂性
- en: 'The following diagram shows the bottom-up stack, which shows the potential
    application density per physical server with their respective deployment type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了自下而上的堆栈，显示了每台物理服务器上按各自部署类型划分的潜在应用密度：
- en: '![Figure 1.1 – Layer comparison between bare metal, virtual machines, and containers](img/B20970_01_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 裸机、虚拟机和容器之间的层次比较](img/B20970_01_01.jpg)'
- en: Figure 1.1 – Layer comparison between bare metal, virtual machines, and containers
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 裸机、虚拟机和容器之间的层次比较
- en: 'We’ve already cited a series of benefits, and yet, we should emphasize additional
    ones that help with rapid prototyping, faster deployment, easy live functional
    testing, and so on:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经列出了许多好处，但仍应强调一些额外的好处，这些好处有助于快速原型制作、更快部署、轻松的实时功能测试等：
- en: A smaller code base to maintain and enrich per microservice with easier rollout/rollback
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务的代码基础较小，便于维护和扩展，同时支持更容易的上线/回滚操作
- en: The capability to run in a degraded mode when one of the microservices fails
    but not the others
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其中一个微服务失败而其他微服务仍正常运行时，具备在降级模式下运行的能力
- en: The ability to troubleshoot misbehaving microservices without impacting the
    entire application
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不影响整个应用程序的情况下，能够故障排除行为不正常的微服务
- en: It’s faster to recover from failure as only the related microservice must be
    rescheduled
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障恢复速度更快，因为只需要重新调度相关的微服务
- en: Granular compute resource allocation and scalability
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细粒度计算资源分配和可扩展性
- en: Not only do microservices help decouple large monolithic applications but they
    also introduce new design patterns to accelerate innovation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务不仅帮助解耦大型单体应用，还引入了新的设计模式以加速创新。
- en: 'This sounds fantastic, doesn’t it? It does, but we still have a major missing
    element here: container runtimes such as Docker or Podman do not provide any resiliency
    in case of failures. To do so, a container runtime requires an additional software
    layer providing the applications with high availability capabilities. Managing
    hundreds of microservices at scale demands a robust and highly resilient orchestrator
    to ensure the business continuity of the applications while guaranteeing a high
    level of automation and abstraction toward the underlying infrastructure. This
    will lead to frictionless build, deploy, and run operations, improving the day-to-day
    responsibilities of the IT staff involved with the workloads that are deployed
    on the application platforms.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很棒，不是吗？确实如此，但我们这里仍然缺少一个关键要素：像 Docker 或 Podman 这样的容器运行时在出现故障时并不提供任何容错能力。为了实现这一点，容器运行时需要一个额外的软件层，提供高可用性能力来支持应用程序。大规模管理数百个微服务需要一个强大且高度可靠的调度器，以确保应用程序的业务连续性，同时保证对底层基础设施的高度自动化和抽象。这将实现无摩擦的构建、部署和运行操作，改善
    IT 员工日常处理部署在应用平台上的工作负载的责任。
- en: This is a big ask and a challenge that many IT departments are facing and trying
    to solve, even more so with legacy patterns. The answer to this complex equation
    is Kubernetes, a container platform or, as we should call it, an application platform.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大挑战，许多 IT 部门都在面对并尝试解决这个问题，尤其是在传统模式下。解决这个复杂问题的答案是 Kubernetes，一个容器平台，或者我们应该称之为应用平台。
- en: Kubernetes overview
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 概述
- en: 'There are no better words to describe what Kubernetes is all about than the
    words from the Kubernetes project maintainers: “*Containers are a good way to
    bundle and run your applications. In a production environment, you need to manage
    the containers that run the applications and ensure that there is no downtime.
    For example, if a container goes down, another container needs to start. Wouldn’t
    it be easier if this behavior was handled by* *a system?*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比 Kubernetes 项目维护者的话更能描述 Kubernetes 的本质了：“*容器是打包和运行应用程序的好方法。在生产环境中，你需要管理运行应用程序的容器，确保没有停机。例如，如果一个容器出现故障，另一个容器需要启动。如果这种行为由*
    *一个系统来处理，岂不是更容易？*”
- en: '*That’s how Kubernetes comes to the rescue! Kubernetes provides you with a
    framework to run distributed systems resiliently. It takes care of scaling and
    failover for your application, provides deployment patterns, and* *more.*” ([https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do](https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do))'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*这就是 Kubernetes 来拯救的地方！Kubernetes 为你提供了一个框架，可以可靠地运行分布式系统。它负责应用程序的扩展和故障转移，提供部署模式，以及*
    *更多功能。*”（[https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do](https://kubernetes.io/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do)）'
- en: 'The same page lists the following benefits of Kubernetes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的同一页面列出以下Kubernetes的优势：
- en: Service discovery and load balancing
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现和负载平衡
- en: Storage orchestration
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储编排
- en: Automated rollouts and rollbacks
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化的部署和回滚
- en: Automatic bin packing
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动的装箱
- en: Self-healing
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自愈
- en: Secret and configuration management
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secret和配置管理
- en: While reading through this handbook, we will explore and practice all of these
    benefits while designing a production-grade Secrets management solution for critical
    workloads.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本手册时，我们将探索并实践所有这些优势，同时为关键工作负载设计生产级别的Secrets管理解决方案。
- en: Kubernetes design principles
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes的设计原则
- en: We have established the context regarding the evolution and adoption of containers
    with the need for Kubernetes to support our applications with resiliency, scalability,
    and deployment patterns in mind. But how is Kubernetes capable of such a frictionless
    experience?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了关于容器的演变和采用的背景，以及Kubernetes在考虑到我们的应用程序需要具备弹性、可伸缩性和部署模式的情况下的能力。但是，Kubernetes如何实现如此无摩擦的体验？
- en: 'Here is my attempt to answer this question based on having experience as a
    former cloud architect within the Red Hat Professional Services organization:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基于作为Red Hat专业服务组织中的前云架构师的经验，我尝试回答这个问题：
- en: From a workload perspective, every infrastructure requirement that an application
    will consume is simply defined in a declarative way without the need for there
    to be a domain specialist in networking, storage, security, and so on. The YAML
    manifest describing the desired state of `Pod`, `Service`, and `Deployment` objects
    is then handled by Kubernetes as a service broker for every specific vendor who
    has a Kubernetes integration. In other words, application teams can safely write
    a manifest that is agnostic of the environment and Kubernetes distribution on
    which they will deploy the workloads.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从工作负载的角度来看，应用程序将使用的每个基础设施需求都以声明方式简单定义，无需网络、存储、安全等领域专家介入。描述`Pod`、`Service`和`Deployment`对象期望状态的YAML清单然后由Kubernetes作为服务代理处理，供应商为每个具有Kubernetes集成的特定供应商编写一个与环境和Kubernetes发行版无关的清单。
- en: From an infrastructure perspective, every component of the stack has a corresponding
    Kubernetes API object. If not, the vendor can introduce their own with the standard
    Kubernetes API object called `CustomResourceDefinition`, also known as **CRD**.
    This guarantees a common standard, even when interacting with third-party software,
    hardware, or cloud vendors.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从基础设施的角度来看，堆栈的每个组件都有相应的Kubernetes API对象。如果没有，供应商可以通过标准的Kubernetes API对象`CustomResourceDefinition`（也称为**CRD**）引入自己的对象。这确保了一个共同的标准，即使与第三方软件、硬件或云供应商交互时也是如此。
- en: When Kubernetes receives a request with a valid object definition, the orchestrator
    will apply the related CRUD operation. In other words, Kubernetes introduces native
    automation and orchestration. The same principles should apply to every Kubernetes
    component running as a container so that they benefit from self-healing, resiliency,
    and scalability while being agnostic of the underlying software, hardware, or
    cloud provider.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当Kubernetes收到具有有效对象定义的请求时，编排器将应用相关的CRUD操作。换句话说，Kubernetes引入了本地自动化和编排。同样的原则应适用于作为容器运行的每个Kubernetes组件，以便它们从自愈、弹性和可伸缩性中受益，同时不依赖于底层软件、硬件或云提供商。
- en: This approach supports the portability not only of containerized applications
    but of the entire application platform while reducing the need for technology
    domain specialists to be involved when deploying an application, maintaining the
    platform, and even enriching the Kubernetes project with new features or components.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅支持容器化应用程序的可移植性，还支持整个应用程序平台的可移植性，同时减少了在部署应用程序、维护平台甚至通过新功能或组件丰富Kubernetes项目时需要技术专家参与的需求。
- en: 'The concept of a YAML manifest to define a Kubernetes API object has been floating
    around for a while. It is time to look at a simple example that shows the desired
    state of a `Pod` object (a logical grouping for one or multiple containers):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义Kubernetes API对象的YAML清单的概念已经流行了一段时间。现在是时候看一个简单的例子，显示`Pod`对象（一个或多个容器的逻辑分组）的期望状态：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `Pod` object’s definition provides the necessary information for Kubernetes
    to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此`Pod`对象的定义为Kubernetes提供了以下必要信息：
- en: Define the desired state for a `Pod` object with the name `hello-app`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义具有名称`hello-app`的`Pod`对象的期望状态。
- en: Specify that there are `containers` and that one of them is called `hello-world`
    and uses a container image of `hello-path`. For this, we want version `0.1` to
    be pulled from a container registry.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定有`containers`，其中一个名为`hello-world`，并使用`hello-path`的容器镜像。为此，我们希望从容器注册表中拉取`0.1`版本。
- en: Accept incoming traffic to the `hello-world` application, using port `8080`
    at the container level.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受传入流量到`hello-world`应用程序，使用容器级别的`8080`端口。
- en: That’s it! This is our first `Pod` definition. It allows us to deploy a simple
    containerized application with no fuzz and zero knowledge of the underlying infrastructure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这是我们第一个`Pod`定义。它允许我们部署一个简单的容器化应用程序，无需复杂操作且对底层基础设施没有任何了解。
- en: Kubernetes architecture
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: 'There is not much magic behind this orchestration but the work of multiple
    components provides a fantastic level of resilience and abstraction, as well as
    a frictionless experience. The following diagram provides an overview of the components
    that run within a Kubernetes instance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后没有太多魔力，多个组件的工作提供了极好的弹性和抽象级别，并且带来顺畅的体验。以下图表概述了运行在 Kubernetes 实例中的组件：
- en: '![Figure 1.2 – Kubernetes components](img/B20970_01_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – Kubernetes 组件](img/B20970_01_02.jpg)'
- en: Figure 1.2 – Kubernetes components
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Kubernetes 组件
- en: 'A Kubernetes cluster can be divided into two logical groups – the control plane
    (some distributions refer to this as the master node) and the (worker) nodes.
    Let’s drill down into each logical group and discover their respective components:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 集群可以分为两个逻辑组——控制平面（一些发行版将其称为主节点）和（工作）节点。我们来深入了解每个逻辑组及其相应的组件：
- en: 'Control plane:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面：
- en: '`kube-apiserver`: This component is responsible for exposing the Kubernetes
    API and enabling CRUD operations regarding the object definitions and their state
    within `etcd`.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver`：该组件负责暴露 Kubernetes API，并启用有关对象定义及其在`etcd`中的状态的 CRUD 操作。'
- en: '`etcd`: This component is a key value store and serves as the asset management
    service. A corrupted `etcd` results in a full disaster scenario.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`：该组件是一个键值存储，并作为资产管理服务。如果`etcd`损坏，将导致完全灾难性的情况。'
- en: '`kube-scheduler`: This component tracks the desired state of `Pod` and will
    address any potential drift within the cluster. As an example, if a `Pod` object
    definition is created or modified, `kube-scheduler` will adjust its state so that
    the containers only run on a healthy node.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-scheduler`：该组件跟踪 `Pod` 的期望状态，并处理集群内可能的漂移。例如，如果创建或修改了 `Pod` 对象定义，`kube-scheduler`
    会调整其状态，确保容器仅在健康节点上运行。'
- en: '`kube-controller-manager`: This component runs a series of controllers that
    are responsible for handling the desired state of the nodes, jobs, endpoints,
    and service accounts. Controllers are reconciliation loops that track the difference
    between the desired and current state of an object and adjust the latter so that
    it matches the latest object definition.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-controller-manager`：该组件运行一系列控制器，负责处理节点、作业、端点和服务帐户的期望状态。控制器是协调循环，跟踪对象的期望状态与当前状态之间的差异，并调整后者以使其匹配最新的对象定义。'
- en: '`cloud-controller-manager` (*optional*): Similar to `kube-controller-manager`,
    this component, when deploying Kubernetes in the cloud, enriches the cluster with
    additional abstractions to interact with the related cloud provider services.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloud-controller-manager`（*可选*）：类似于 `kube-controller-manager`，当在云中部署 Kubernetes
    时，该组件通过增强集群与相关云提供商服务的交互，提供额外的抽象。'
- en: 'Nodes (and the control plane too!):'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点（控制平面也包括在内！）：
- en: '`kubelet`: This component interacts with `kube-apiserver` to verify and adjust
    the desired states of Pods bound to the node'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubelet`：该组件与`kube-apiserver`交互，以验证和调整绑定到节点的 Pod 的期望状态。'
- en: '`kubeproxy`: This component provides the basic network plumbing on each node
    while maintaining the networking rules to allow (or not) the internal and external
    network traffic to Pods'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubeproxy`：该组件在每个节点上提供基本的网络连接，同时维护网络规则，以允许（或不允许）内外部网络流量访问 Pod。'
- en: '`container runtime`: This component runs the containers'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container runtime`：该组件负责运行容器。'
- en: There are additional components that should be considered as add-ons due to
    their direct dependency on the Kubernetes distribution. These add-ons would be
    responsible for handling services such as DNS, logging, metrics, the user interface,
    and more.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些附加组件，应该作为附加项进行考虑，因为它们直接依赖于 Kubernetes 发行版。这些附加项负责处理诸如 DNS、日志记录、度量、用户界面等服务。
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: In a dev/test environment, a single node might be deployed to act both as a
    control plane and a worker node on which Pods will be scheduled. However, for
    resiliency purposes, a production-grade environment should consider a minimum
    of three control planes with dedicated worker nodes to improve resilience and
    separation of concerns, as well as dedicate compute resources for the applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发/测试环境中，可以部署单个节点作为同时充当控制平面和工作节点的控制平面。然而，出于弹性目的，生产级环境应考虑至少三个控制平面，带有专用的工作节点来提高弹性和关注点分离，以及为应用程序分配计算资源。
- en: Getting hands-on – from a local container to a Kubernetes Pod
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从本地容器到Kubernetes Pod的实际操作
- en: The main benefits of containers are their portability and being platform agnostic.
    Deploying the famous *Hello World* application within a container using Docker,
    Podman, or Kubernetes should not require us to modify the application code. I
    will even go a step further and say that we should not care about the underlying
    infrastructure. On the other hand, there would be a large umbrella of constraints
    to deal with when deploying an application with a bare metal or virtualization
    approach.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的主要优点是其可移植性和平台无关性。使用Docker、Podman或Kubernetes在容器中部署著名的*Hello World*应用程序不应该需要修改应用程序代码。我甚至会进一步说，我们不应关心底层基础设施。另一方面，使用裸金属或虚拟化方法部署应用程序时会有大量的约束要处理。
- en: 'Before we start, we assume that you have the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们假设您具备以下条件：
- en: All the technical requirements mentioned at the beginning of this chapter
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章开头提到的所有技术要求
- en: Access to this book’s GitHub repository ([https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook))
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问本书的GitHub存储库（[https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)）
- en: This example at hand; it is available in the `ch01/example01` folder
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此示例位于`ch01/example01`文件夹中；
- en: 'Let’s have a look at a simple example illustrating a basic software supply
    chain:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的示例，说明基本的软件供应链：
- en: '**Building the application binary**: The example is a simple Go application
    showcasing an HTTP service and console logging capabilities'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建应用程序二进制文件**：该示例是一个简单的Go应用程序，展示了HTTP服务和控制台日志功能'
- en: '**Building the container image, including the application binary**: The application
    will be built using a Golang toolset container image; a second small footprint
    container image will be used to carry the application binary'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建包含应用程序二进制文件的容器镜像**：将使用Golang工具集容器镜像构建应用程序；第二个小型容器镜像将用于携带应用程序二进制文件'
- en: '**Running the containerized application using Podman**: This first run will
    leverage the graphical interface of Podman Desktop to illustrate the rather simple
    process of running a container'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Podman运行容器化应用程序**：这是第一次运行，将利用Podman桌面的图形界面来说明运行容器的相当简单的过程'
- en: '`kubectl` command line to showcase how to process our first YAML manifest to
    create a Kubernetes `Pod` object'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl`命令行展示如何处理我们的第一个YAML清单以创建一个Kubernetes `Pod`对象
- en: Note that this example is agnostic of the CPU architecture on which the overall
    process will take place. This means that you can safely perform the same exercise
    on different CPU targets without the need to rewrite code or change any of the
    configuration files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个示例与整个过程将发生的CPU架构无关。这意味着您可以在不同的CPU目标上安全地执行相同的练习，而无需重写代码或更改任何配置文件。
- en: 'It is interesting to note that a container runtime such as Docker or Podman
    is used to build the application and the container image containing our application
    binary. This is done via a text file called a Dockerfile, which defines all the
    necessary steps to build our container image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，像Docker或Podman这样的容器运行时用于构建应用程序和包含应用程序二进制文件的容器镜像。这是通过一个称为Dockerfile的文本文件完成的，该文件定义了构建容器镜像所需的所有步骤：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Dockerfile build steps are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的构建步骤如下：
- en: Fetch the `go-toolset` image for the build.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`go-toolset`镜像用于构建。
- en: Get all the application content in that image.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有应用程序内容放入该镜像中。
- en: Run the Go build process.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Go构建过程。
- en: Fetch the `ubi-micro` image as the target container.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`ubi-micro`镜像作为目标容器。
- en: Set some container image metadata.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一些容器镜像元数据。
- en: Copy the binary from the build image to the target image.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二进制文件从构建镜像复制到目标镜像。
- en: Set a port exposure for the application. Here, this is `8080`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应用程序的端口暴露。这里是`8080`。
- en: Run the application binary.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序二进制文件。
- en: That’s it! Once the application has been built and the container image has been
    successfully created and pushed to the registry, the container image will be available
    in the localhost container registry, after which the container can be started
    using either Docker or Podman. This can be done through one simple command line
    with a few parameters, though you can leverage the Podman Desktop graphical interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一旦应用程序构建完成，容器镜像成功创建并推送到注册中心，容器镜像将可在本地容器注册中心使用，之后可以使用 Docker 或 Podman 启动容器。只需通过一个简单的命令行加上几个参数即可完成此操作，尽管你也可以利用
    Podman Desktop 图形界面。
- en: On the other hand, running this container on an application platform such as
    Kubernetes requires a different approach – that is, declaratively using a YAML
    manifest. An example was supplied earlier in this chapter and can be found in
    this book’s GitHub repository. This YAML manifest is submitted to `kube-apiserver`
    via a tool such as `kubectl`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在像 Kubernetes 这样的应用平台上运行容器需要不同的方法——也就是说，声明性地使用 YAML 清单。一个示例已在本章前面提供，并可以在本书的
    GitHub 仓库中找到。此 YAML 清单通过诸如 `kubectl` 之类的工具提交给 `kube-apiserver`。
- en: 'Here is a transactional overview of a Kubernetes `Pod` object’s creation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kubernetes `Pod` 对象创建的事务性概览：
- en: '![Figure 1.3 – Kubernetes Pod creation](img/B20970_01_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – Kubernetes Pod 创建](img/B20970_01_03.jpg)'
- en: Figure 1.3 – Kubernetes Pod creation
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – Kubernetes Pod 创建
- en: As we can see, the `etcd` record is continuously updated during the `Pod` object’s
    creation. The desired state is saved; the current status of every component involved
    in the process is also saved, which generates a sort of audit trail. Such a design
    allows for easier debugging when the desired outcome is not achieved.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`etcd` 记录在 `Pod` 对象创建期间持续更新。所需状态被保存；过程中的每个组件的当前状态也被保存，从而生成一种审计轨迹。这种设计使得当未达到预期结果时，调试变得更加容易。
- en: As soon as the `Pod` object is registered within `etcd`, all the Kubernetes
    components are on a mission to converge toward the desired state, regardless of
    potential issues such as network partitioning, node failure, and more. This is
    the difference between running containers on a single machine with a local container
    runtime such as Docker or Podman and orchestrating containers at scale with a
    container platform such as Kubernetes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Pod` 对象在 `etcd` 中注册，所有 Kubernetes 组件便会开始执行任务，向所需状态聚合，无论是否存在网络分区、节点故障等潜在问题。这就是在单台机器上使用本地容器运行时（如
    Docker 或 Podman）运行容器与使用像 Kubernetes 这样的容器平台进行大规模编排的区别。
- en: 'Here’s some food for thought:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些值得思考的内容：
- en: I wrote “*running the containerized applications*” and “*deploying the containerized
    application*” to illustrate the difference between a container runtime such as
    Docker or Podman running a containerized application and Kubernetes scheduling
    containers and orchestrating other resources such as networking, storage, Secrets,
    and more. Note that there is a Kubernetes object called `Deployment` that addresses
    release management and scalability capabilities. For more details, see [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我写了“*运行容器化应用程序*”和“*部署容器化应用程序*”来说明容器运行时（如 Docker 或 Podman）运行容器化应用程序与 Kubernetes
    调度容器并编排其他资源（如网络、存储、密钥等）之间的区别。请注意，Kubernetes 中有一个名为`Deployment`的对象，用于处理发布管理和可扩展性功能。更多细节请参见
    [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)。
- en: Performing such an exercise even in a non-production environment using virtual
    machines could take days, even weeks.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在非生产环境中使用虚拟机执行这样的操作，也可能需要几天甚至几周的时间。
- en: Developing applications using containers, for both monolithic or microservice
    application architecture, allows for a truly agile development cycle calling for
    everything to be continuous (development, integration, improvement, and deployment).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器开发应用程序，无论是单体架构还是微服务架构，都可以实现真正敏捷的开发周期，要求一切都必须是持续的（开发、集成、改进和部署）。
- en: Using YAML manifests to deploy applications will trigger an organic usage of
    Git repositories that will spark another practice – GitOps. In short, every desired
    state definition of an application and its infrastructure management lands in
    a Git repository, providing the *application* and *infrastructure* teams with
    a central point of configuration management, including, by default, authorization,
    peer review, and organization.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 YAML 清单部署应用程序将引发 Git 仓库的有机使用，进而激发另一种实践——GitOps。简而言之，应用程序及其基础设施管理的每一个期望状态定义都会存储在
    Git 仓库中，默认情况下为*应用程序*和*基础设施*团队提供了一个集中配置管理点，包括授权、同行评审和组织等功能。
- en: With that, we’ve transitioned from running the target application through a
    local container to running it through a Kubernetes Pod. By doing so, we acquired
    an understanding of how a Pod is created, which Kubernetes components are involved,
    the interactions that are involved, and more.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个过程，我们已经从通过本地容器运行目标应用程序过渡到通过 Kubernetes Pod 运行它。这样，我们掌握了如何创建 Pod，涉及到哪些 Kubernetes
    组件，以及其中的交互和更多内容。
- en: Secrets within Kubernetes
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 中的 Secrets
- en: 'In this section, we had a refresher on containers and Kubernetes, and we also
    proceeded with a hands-on example that helped us establish key concepts, such
    as the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们回顾了容器和 Kubernetes 的基础知识，并通过实际操作的例子帮助我们建立了关键概念，如下所示：
- en: The evolution of application deployment through times and technologies
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过时代与技术演变的应用部署
- en: Why containers and Kubernetes
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择容器和 Kubernetes
- en: The architecture and principles of Kubernetes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的架构和原则
- en: Building and running containers using Podman Desktop and Kubernetes
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Podman Desktop 和 Kubernetes 构建和运行容器
- en: With the knowledge we’ve acquired, we can start looking at the more advanced
    concept of Secrets within Kubernetes. We will dive into the details of how Secrets
    are stored on Kubernetes, how they are injected into a Pod, which is the smallest
    execution unit, and the security concerns that we have to tackle.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 借助我们已掌握的知识，我们可以开始深入了解 Kubernetes 中的 Secrets 这一更高级的概念。我们将探讨 Secrets 如何在 Kubernetes
    中存储，如何注入到最小执行单元——Pod 中，以及我们需要解决的安全问题。
- en: Secrets concepts
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets 概念
- en: Interestingly enough, during my time designing and deploying Red Hat OpenShift,
    this topic was always considered irrelevant to the customer and partner teams
    that I was working with. Reflecting, I concluded that this is linked to the legacy
    patterns we have been working with for the last two or three decades.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在我设计和部署 Red Hat OpenShift 的过程中，这个话题总是被我所合作的客户和合作伙伴团队认为与他们无关。经过反思，我得出结论，这与我们过去二三十年来使用的遗留模式有关。
- en: In a traditional environment, both with physical and virtual machines, there
    is a clear outcome from the separation of concerns principle. The infrastructure
    teams care about the infrastructure and the application teams care about applications.
    This includes managing Secrets such as credentials, tokens, license keys, certificates,
    and more. No one from the application teams will share credentials for a MySQL
    database with the infrastructure teams.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统环境中，无论是物理机器还是虚拟机器，关注点分离原则都会产生明确的结果。基础设施团队关注基础设施，应用团队关注应用程序。这包括管理诸如凭证、令牌、许可证密钥、证书等
    Secrets。应用团队的成员不会与基础设施团队共享 MySQL 数据库的凭证。
- en: 'When it comes to Kubernetes, these concerns are, by design, merged into a point
    of entry: the application platform. Despite the separation of concerns, the Kubernetes
    integration with external API-driven services requires credentials, tokens, or
    certificates to authenticate and trust themselves. These Secrets have to stay
    within the platform to ensure resiliency, scalability, and orchestration for both
    the cluster and applications.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，这些问题按设计合并为一个入口点：应用平台。尽管关注点有所分离，Kubernetes 与外部 API 驱动服务的集成仍需要凭证、令牌或证书来进行身份验证和信任。这些
    Secrets 必须保持在平台内部，以确保集群和应用的韧性、可扩展性和编排能力。
- en: When it comes to the container image’s design, Secrets cannot be hardcoded or
    included in the container image. By hardcoding Secrets, they become available
    to all internal and external stakeholders with access to the container image registry.
    If the container image is pushed to a public registry, which is common to ease
    with redistribution, it will make the Secrets available to an even wider audience.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器镜像设计中，Secrets 不能被硬编码或包含在容器镜像中。硬编码 Secrets 会让所有能够访问容器镜像注册表的内部和外部人员都能够获得这些敏感信息。如果容器镜像被推送到公共注册表（为了便于重新分发，通常会这么做），它将使
    Secrets 被更广泛的受众获取。
- en: 'This is the reason why Kubernetes has a Secrets management framework built
    into it with a dedicated API object called `Secret`. Here is an overview of what
    a `Secret` object definition would look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Kubernetes 内置 Secrets 管理框架的原因，提供了一个名为 `Secret` 的专用 API 对象。以下是 `Secret` 对象定义的大致概览：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s go through the manifest:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起看看清单：
- en: We informed Kubernetes that we wanted to create a `Secret` object
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们告知 Kubernetes 我们想要创建一个 `Secret` 对象。
- en: The name for this object is `mysecret` and we defined a type called `Opaque`,
    which means that we are defining the container of the `data` field ourselves
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个对象的名称是 `mysecret`，我们定义了一个名为 `Opaque` 的类型，这意味着我们自己定义了 `data` 字段的容器。
- en: The `data` field is composed of two key-value pairs
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 字段由两个键值对组成'
- en: Now, let’s have a closer look at these key-value pairs. What seems to be a random
    set of characters is data being encoded in `base64`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看这些键值对。看似随机的一组字符其实是经过 `base64` 编码的数据。
- en: Why `base64`? While we could assume the need to encrypt sensitive data such
    as credentials, the usage of `base64` is only to ease the processing that’s done
    through the command line, the network, and by `kube-apiserver` to avoid us processing
    a truncated payload due to special characters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 `base64`？虽然我们可以假设需要加密诸如凭证之类的敏感数据，但使用 `base64` 仅是为了简化通过命令行、网络和 `kube-apiserver`
    进行的处理，以避免由于特殊字符而导致有效负载被截断。
- en: These two entries can be decoded on every operating system or website offering
    a `base64` encoding/decoding tool. So, should we assume that `kube-apiserver`,
    when saving the payload within the `etcd` key store, will encrypt the data? Well,
    this handbook has already given you a good hint that it doesn’t!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个条目可以在每个操作系统或提供 `base64` 编码/解码工具的网站上解码。那么，我们是否可以假设在 `kube-apiserver` 将有效负载保存在
    `etcd` 密钥存储中时，会加密数据？嗯，本手册已经给出了一个明确的提示：不会！
- en: 'Another API object has a similar data field that can be used to share sensitive
    data with an application: `ConfigMap`. While `ConfigMap` was designed to carry
    out environment variables and application arguments, its usage has been rapidly
    adopted by developers to also include advanced application configuration, similar
    to a license key file. This object’s content could be leveraged by a malicious
    hacker to access containers, gain access to other workloads either inside or outside
    the platform, and even gain control of the Kubernetes cluster. As such, `ConfigMap`
    should be carefully handled, just like `Secret` objects. Here is an overview of
    a `ConfigMap` object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 API 对象有一个类似的数据字段，可以用来与应用程序共享敏感数据：`ConfigMap`。虽然 `ConfigMap` 最初设计用于存储环境变量和应用程序参数，但开发人员已经迅速将其用于包含类似于许可证密钥文件的高级应用程序配置。因此，这个对象的内容可能被恶意黑客利用，从而访问容器，获取平台内外其他工作负载的访问权限，甚至控制
    Kubernetes 集群。因此，`ConfigMap` 应该像 `Secret` 对象一样小心处理。以下是 `ConfigMap` 对象的概述：
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, there is a major difference between the `data` field of `Secret`
    and the `data` field of `ConfigMap` – the encoding part. The `data` field specification
    of `ConfigMap` expects UTF-8 strings while the `Secret` one expects key-value
    pairs with the value encoded in `base64`. This example shows a way to set an application
    to `dev` mode, thus enabling extra instrumentation for debugging purposes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Secret` 的 `data` 字段和 `ConfigMap` 的 `data` 字段有一个显著的区别——编码部分。`ConfigMap`
    的 `data` 字段规格要求 UTF-8 字符串，而 `Secret` 的要求是键值对，其中值需要用 `base64` 编码。这个示例展示了如何将应用程序设置为
    `dev` 模式，从而启用额外的调试工具。
- en: Storing Secrets on Kubernetes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上存储 Secrets
- en: 'Now is a good time for a second hands-on example so that we can understand
    the differences between Secrets and the other Kubernetes objects, such as `ConfigMap`.
    Before we start, we assume that you have the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行第二个实际操作示例的好时机，这样我们可以理解 `Secrets` 和其他 Kubernetes 对象（如 `ConfigMap`）之间的差异。在开始之前，我们假设你已经具备以下条件：
- en: All the technical requirements mentioned at the beginning of this chapter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章开头提到的所有技术要求
- en: 'Access to this book’s GitHub repository: [https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问本书的 GitHub 仓库：[https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)
- en: The example at hand; it is available in the `ch01/example02` folder
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前示例可在 `ch01/example02` 文件夹中找到
- en: 'Let’s have a look at what we are accomplishing with this example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看通过这个示例我们达成了什么：
- en: First, we are creating a `Secret` object using the provided YAML manifest, a
    secret definition similar to the one we created for `mysecret` earlier. We are
    also checking its status and how to recover its definition from Kubernetes. This
    is always handy when we want to recover the current state of an object so that
    we can create it again later. We are also decoding the `base64` payload to reveal
    the key-value pairs.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用提供的 YAML 清单创建一个 `Secret` 对象，类似于我们之前为 `mysecret` 创建的秘密定义。我们还检查它的状态以及如何从
    Kubernetes 恢复其定义。当我们想恢复对象的当前状态并稍后重新创建时，这非常有用。我们还解码了 `base64` 负载以揭示键值对。
- en: Then, we are recovering the YAML manifest from Kubernetes to show a very simple
    way to get back our `Secret` object and its sensitive data. In other words, if
    malicious hackers succeed in interacting with `kube-apiserver`, then they can
    extract some or all `Secret` objects from a Kubernetes cluster.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们从 Kubernetes 恢复 YAML 清单，展示了一种非常简单的方式来恢复我们的 `Secret` 对象及其敏感数据。换句话说，如果恶意黑客成功与
    `kube-apiserver` 交互，他们就可以从 Kubernetes 集群中提取部分或全部 `Secret` 对象。
- en: 'Next, we are creating a new `Secret` object from scratch by encoding the key-value
    pairs in `base64`, writing the YAML manifest, and pushing it via the command line.
    Here is a transactional overview of a Kubernetes `Secret` object’s creation:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从头开始创建一个新的 `Secret` 对象，通过将键值对编码为 `base64`，编写 YAML 清单，并通过命令行推送。以下是 Kubernetes
    `Secret` 对象创建的事务概述：
- en: '![Figure 1.4 – Secret creation](img/B20970_01_04.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – Secret 创建](img/B20970_01_04.jpg)'
- en: Figure 1.4 – Secret creation
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – Secret 创建
- en: 'The next step is to access the `Secret` payload from a `Pod` object. In this
    example, we are using a special type of container called `busybox` that provides
    a small footprint environment that’s ideal for performing testing/debugging. The
    `Pod` manifest includes the reference to our newly created `Secret` object and
    assigns the value to an environment variable that we will `echo` from `busybox`.
    This will appear within container logs. Here is a transactional overview of a
    Kubernetes `Pod` object being created, including the `Secret` object being injected:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从 `Pod` 对象中访问 `Secret` 负载。在这个示例中，我们使用了一种名为 `busybox` 的特殊类型容器，它提供了一个小巧的环境，非常适合进行测试/调试。`Pod`
    清单包括对我们新创建的 `Secret` 对象的引用，并将其值分配给一个环境变量，我们将从 `busybox` 中使用 `echo` 命令输出。这将出现在容器日志中。以下是一个
    Kubernetes `Pod` 对象创建的事务概述，其中包括注入的 `Secret` 对象：
- en: '![Figure 1.5 – Injecting Secret into Pod](img/B20970_01_05.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 将 Secret 注入 Pod](img/B20970_01_05.jpg)'
- en: Figure 1.5 – Injecting Secret into Pod
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 将 Secret 注入 Pod
- en: Note that the `kubelet` component will be responsible for decoding the `base64`
    payload. This is to ensure that the payload is transported between the different
    components and across the wire.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`kubelet` 组件将负责解码 `base64` 负载。这是为了确保负载能够在不同组件之间以及跨网络传输。
- en: Then, we access the `etcd` key store via its API. This shows that the data that’s
    retrieved via such a method is not encrypted nor `base64` encoded! At this stage,
    malicious hackers who have successfully breached the `etcd` Pod have full access
    to Kubernetes asset management and can control the entire destiny of the application
    platform up to a cloud provider account if it’s deployed in such a setup.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过其 API 访问 `etcd` 键存储。这表明通过这种方式检索的数据既没有加密也没有 `base64` 编码！此时，成功攻破 `etcd`
    Pod 的恶意黑客可以完全访问 Kubernetes 资产管理，并可以控制应用平台的整个命运，甚至是部署在云提供商账户中的平台。
- en: Finally, we are going one step further by extracting the `etcd` file locally
    and examining it to retrieve our last created `Secret` object. This seems to be
    a far-fetched scenario but think about filesystem access or backups taken of the
    Kubernetes cluster, which includes the `etcd` file. Even if the Kubernetes cluster
    is well-hardened with limited security exposure, malicious hackers who breach
    the storage and/or backup system(s) can retrieve all the `Secret` objects from
    such files.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们进一步通过提取本地 `etcd` 文件并进行检查，来获取我们最后创建的 `Secret` 对象。这看起来像是一个牵强的场景，但请想一想文件系统访问或备份中的
    Kubernetes 集群，这些备份包括了 `etcd` 文件。即使 Kubernetes 集群经过良好的加固，且安全暴露较少，恶意黑客如果攻破了存储和/或备份系统，依然可以从这些文件中恢复所有
    `Secret` 对象。
- en: Compared to the previous `Pod` creation workflow, we can establish the relatively
    low impact from a transaction perspective on the overall process. Note that our
    first example shows how to load the `Secret` key-value pairs as environment variables.
    However, other options also exist; we will be exploring their potential mitigations
    later in this book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 `Pod` 创建工作流相比，从交易的角度来看，我们可以确定其对整体过程的影响较小。请注意，我们的第一个示例展示了如何将 `Secret` 键值对作为环境变量加载。然而，其他选项也存在；我们将在本书后面探讨它们的潜在缓解措施。
- en: Important note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'Only the container that has the environment variable defined within its `Pod`
    specs will have access to the key-value pairs. However, containers running with
    `privileged: true` will have access to all Secrets from the node on which it runs,
    resulting in a major security exposure.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '只有在其 `Pod` 配置中定义了环境变量的容器才能访问这些键值对。然而，运行 `privileged: true` 的容器将能够访问它运行的节点上的所有
    Secrets，这会导致重大的安全暴露。'
- en: Why should we care?
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么要关注这个问题？
- en: While Kubernetes provides a frictionless experience for both the platform and
    application teams, it does not provide you with a hardened solution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 为平台和应用团队提供了顺畅的体验，但它并没有为你提供加固的解决方案。
- en: The first approach to tackle this security concern would be to leverage a vault
    solution (the likes of HashiCorp Vault, CyberArk Conjure, or Azure Key Vault).
    However, this would only secure the application side. We are still exposed to
    taking into account the usage of `ConfigMap` or multi-cluster services such as
    application interconnect, which involves leveraging mutual authentication with
    certificates generated and deployed within the application platform.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此安全问题的第一种方法是利用一个保险库解决方案（如 HashiCorp Vault、CyberArk Conjure 或 Azure Key Vault）。然而，这只会确保应用程序端的安全性。我们仍然需要考虑使用
    `ConfigMap` 或多集群服务，如应用程序互联，这涉及到使用证书进行相互认证，而这些证书是在应用平台内生成和部署的。
- en: 'So, let’s rethink the requirements into simple layers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们将需求重新思考成简单的层次结构：
- en: '`Secret` objects are created to allow internal components to interact with
    others (storage, networking, execution units, controllers, and so on). Third-party
    components being deployed later on to enrich the platform’s capabilities will
    follow the same model. These `Secret` objects should not be offloaded to a vault
    solution for resilience purposes. If there is any type of partitioning with the
    external Vault solution, the Kubernetes cluster will start collapsing, along with
    all the workloads.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Secret` 对象是为了让内部组件与其他组件（存储、网络、执行单元、控制器等）进行交互而创建的。后续部署的第三方组件以丰富平台的功能时，也会遵循相同的模型。这些
    `Secret` 对象不应为提高可用性而转移到保险库解决方案中。如果与外部 Vault 解决方案存在任何类型的分区，Kubernetes 集群将开始崩溃，所有工作负载也会随之崩溃。'
- en: '`ConfigMap` object, an encryption key for their volumes, TLS certificates,
    and so on.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigMap` 对象、其卷的加密密钥、TLS 证书等。'
- en: Similar to the observation about platform-related `Secret` objects, these should
    be stored within Kubernetes to ensure the scheduling, self-healing, and operability
    capabilities of the application platform.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与平台相关的 `Secret` 对象类似，这些对象应该存储在 Kubernetes 中，以确保应用平台的调度、自愈和可操作性。
- en: By design, Kubernetes will not become a storage system or an encrypted Vault
    to protect sensitive data. Instead, Kubernetes will provide the necessary framework
    to interconnect and leverage the expertise of third-party solutions addressing
    each domain’s specific needs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按照设计，Kubernetes 不会成为一个存储系统或加密的 Vault 来保护敏感数据。相反，Kubernetes 将提供必要的框架，以实现第三方解决方案之间的互联，并利用它们在各自领域的专业知识来解决特定需求。
- en: Considering these aspects, addressing the security concerns for Secrets Management
    in Kubernetes is not as simple as ticking a box.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些方面，解决 Kubernetes 中 Secrets 管理的安全问题并不像勾选一个框那么简单。
- en: Security exposures
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全暴露
- en: In this chapter, we have established the benefits of containerized applications
    running on Kubernetes but also the security challenges of Secrets Management on
    such application platforms.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已阐明了在 Kubernetes 上运行容器化应用的好处，但也暴露了此类应用平台上 Secrets 管理的安全挑战。
- en: 'Through our hands-on examples, we have acknowledged how unsafe our sensitive
    data is within `Secret` and `ConfigMap` objects. We can also list a series of
    security exposures to be exploited to compromise the application platform, including
    external services:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的实践示例，我们意识到我们在 `Secret` 和 `ConfigMap` 对象中的敏感数据是多么不安全。我们还可以列出一系列安全暴露点，这些点可能被利用来破坏应用平台，包括外部服务：
- en: '**kube-apiserver**: This is the main component of Kubernetes and malicious
    hackers can leverage this first point of entry to the application platform'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-apiserver**：这是 Kubernetes 的主要组件，恶意黑客可以利用这个应用平台的第一个入口点。'
- en: '`etcd` does not provide any encryption capabilities. The database file is a
    binary file that can be easily read.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd` 不提供任何加密功能。数据库文件是一个二进制文件，可以轻松读取。'
- en: '`kube-apiserver` component, `etcd` is an API-driven service and any access
    or network trace can expose the data.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver` 组件，`etcd` 是一个基于 API 的服务，任何访问或网络跟踪都可能暴露数据。'
- en: '`Pod` object means accessing the filesystem on which the database file is written.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pod` 对象意味着访问写入数据库文件的文件系统。'
- en: '`etcd` Pod has its filesystem hosted on a volume to provide persistent storage.
    This volume is attached to the node, and by accessing the node, the data can also
    be accessed through the attached volume.*   `etcd` file. Accessing the backup
    can expose the data.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd` Pod 的文件系统托管在一个卷上，以提供持久存储。该卷附加在节点上，通过访问该节点，可以通过附加的卷访问数据。*`etcd` 文件。访问备份可能会暴露数据。'
- en: There are various ways that Secrets can be exposed. For example, you can interact
    with Kubernetes components such as `kube-apiserver` and `etcd` to do this or go
    through a physical level such as direct node access or access to backups.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets 可能以多种方式暴露。例如，您可以与 Kubernetes 组件如 `kube-apiserver` 和 `etcd` 交互来实现，或者通过物理层面如直接节点访问或访问备份来实现。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced containers, Kubernetes, and Secrets. We provided
    an overview of the history so far, going through the concepts of bare metal, virtual
    machine, and container-based deployments. We had the opportunity to understand
    the benefits of containerization and introduce container orchestration engines.
    We learned more about Kubernetes and its components, which made it possible for
    us to run our first Kubernetes secret example and also have a deep dive into the
    Kubernetes components involved to facilitate secret usage. This helped us identify
    the security and robustness concerns that come with the usage of Kubernetes Secrets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了容器、Kubernetes 和 Secrets。我们回顾了迄今为止的历史，了解了裸机、虚拟机和基于容器的部署概念。我们有机会理解容器化的好处，并介绍了容器编排引擎。我们深入学习了
    Kubernetes 及其组件，这使得我们能够运行第一个 Kubernetes secret 示例，并深入探讨了参与其中的 Kubernetes 组件，从而便于
    Secret 的使用。这帮助我们识别了使用 Kubernetes Secrets 时所面临的安全性和健壮性问题。
- en: In the next chapter, we will focus on the different types of Kubernetes Secrets,
    their usages, and the cross-cutting concerns that Secrets come with, such as auditing
    and access permissions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点介绍 Kubernetes Secrets 的不同类型、它们的用途以及与 Secrets 一起出现的交叉问题，如审计和访问权限。
