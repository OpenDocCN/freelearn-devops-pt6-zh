- en: '*Chapter 4*: Managing Cluster Configuration with Ansible'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073), *Provisioning
    Kubernetes Clusters Using AWS and Terraform*, you learned how to create a Kubernetes
    infrastructure with Terraform and AWS, and you also learned how to develop infrastructure
    as code and provisioned your first production-like cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This was just the first step towards building operational and production-ready
    Kubernetes clusters. By now, you should have an up-and-running cluster with Terraform
    infrastructure modules to provision other similar clusters.
  prefs: []
  type: TYPE_NORMAL
- en: These clusters are still plain; they're not configured or optimized to run production
    workloads. To make these clusters fully operational, we simply need to deploy
    and configure the required Kubernetes services for them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will design and develop a configuration management solution
    that you can use to manage the configuration of Kubernetes clusters and their
    supporting services. This solution is automated and scalable, and it requires
    a minimum effort to maintain and operate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kubernetes configuration management challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a configuration management solution for Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a configuration management solution with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the solution to configure Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the tools that you installed in [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073),
    *Provisioning Kubernetes Clusters Using AWS and Terraform*, you will need to install
    the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`python3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pip3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtualenv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will go into the specifics of these tools' installation and configuration
    in the next section. If you already know how to do this, you can go ahead and
    set them up now.
  prefs: []
  type: TYPE_NORMAL
- en: You need to have an up-and-running Kubernetes cluster as per the instructions
    in [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073), *Provisioning
    Kubernetes Clusters Using AWS and Terraform*.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is located at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter04](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3cGtqjx](https://bit.ly/3cGtqjx)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`python3`, `pip3`, and `virtualenv` are the prerequisites to execute the Ansible
    configuration playbooks that we will develop in this chapter. If you do not have
    these tools installed on your system, you can follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following commands to install `python3`, `pip3`, and `virtualenv`
    on Ubuntu Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following commands to install `python3`, `pip3`, and `virtualenv`
    on Amazon Linux 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following commands to install `python3`, `pip3`, and `virtualenv`
    on macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following commands to install `python3`, `pip3`, and `virtualenv`
    on Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By installing `python3`, `pip3`, and `virtualenv`, you will be able to execute
    Ansible playbooks against your Kubernetes clusters. You will learn how to do that
    later in this chapter, but first, we need to go through the design details of
    our Kubernetes configuration management solution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014), *Introduction
    to Kubernetes Infrastructure and Production-Readiness*, you learned about the
    infrastructure design principles that we will follow in this book. I would like
    to start this chapter by highlighting the notable principles that influenced the
    configuration management solution and the technical decisions in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Everything as code**: In this chapter, we will keep our commitment to having
    everything in the infrastructure as code – cluster configuration is not an exception.
    You will use Ansible to achieve this goal by creating a configuration management
    solution for your Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: In the previous chapter, we used Terraform tool to automate
    infrastructure provisioning. We designed a solution around Terraform that can
    scale to serve a growing number of clusters without the need to scale up your
    infrastructure teams. Here, you will create a similar solution to manage the Kubernetes
    configuration while keeping it automated, scalable, and easy to operate and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Ansible fulfills this principle in many aspects as it is easy
    to learn and to use. It has a simple syntax compared to other configuration management
    tools. It uses YAML, which you do not need to learn a programming language to
    write. Moreover, it is agentless, which means you do not need a server to run
    it, as you can run Ansible from your computer. Also, it is modular, which enables
    separation of concerns and code reusability, which is similar to Terraform. So,
    they can easily live together and simplify the automation of the infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of Kubernetes is that every part of it is abstracted as an object
    that can be managed and configured declaratively with YAML or JSON through its
    API server. This makes Kubernetes configuration easier to manage as code. However,
    it is still challenging to manage this configuration when you have groups of clusters
    that run hundreds of add-ons and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a scenario where you manage a company''s infrastructure with Kubernetes,
    and you have multiple clusters for development, testing, and production. Add to
    them the cluster add-ons that run on the Kubernetes services layer as per the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Kubernetes infrastructure layers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_04_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Kubernetes infrastructure layers
  prefs: []
  type: TYPE_NORMAL
- en: This means that you can have *N* clusters with a growing number of add-ons and
    different environment types, such as development, QA, and production. If we put
    these together, we end up with a complex and redundant configuration to manage.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended way to manage clusters' configuration is through **Configuration
    as Code** (**CaC**). We will deploy these services and add-ons to the cluster
    and add their configuration manifests to the source code control. By adopting
    this pattern, you will be able to redeploy the same configuration in a seamless
    and automated fashion to your clusters. This solution appears to be easy when
    you start with a single cluster, but it will be difficult to maintain and scale
    when provisioning multiple clusters with different configuration values.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to an enhanced solution, which is configuration templating. Let's
    assume you have a group of clusters that serve product X, and these clusters have
    different configurations, such as different users' authentication and authorization,
    namespaces, resource quotas, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This solution uses Ansible templating and Jinja2\. You write the templates for
    the Kubernetes manifests once, and then Ansible substitutes the variables in these
    templates and generates the appropriate manifests for each target cluster. This
    solution is scalable and easy to maintain, and it fulfills the infrastructure
    design principles that we introduced in [*Chapter 1*](B16192_01_Final_PG_ePub.xhtml#_idTextAnchor014),
    *Introduction to Kubernetes Infrastructure and Production-Readiness*.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes configuration management workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After considering the preceding templating solution, our Kubernetes configuration
    management workflow looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create Ansible Jinja2 templates for the Kubernetes cluster services that you
    want to configure and deploy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the values of the variables and categorize them based on the environments
    and the cluster's group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provisioning the clusters with Terraform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the Terraform outputs to Ansible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Substitute the variables in the Ansible template with the corresponding values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Ansible to apply the Kubernetes manifests to the target clusters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next sections, we will implement this workflow with Ansible and Jinja2
    templates, then learn how to use it with a basic example.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we will use Ansible as the configuration management tool,
    and we will build around it our solution for Kubernetes configuration management.
    In this section, we are going to briefly discuss the reasoning behind this choice,
    and some Ansible key concepts. If you are willing to learn more about Ansible,
    you can use its official guide here: [https://www.ansible.com/resources/get-started](https://www.ansible.com/resources/get-started).'
  prefs: []
  type: TYPE_NORMAL
- en: Why Ansible?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to templating Kubernetes configuration, we have battle-tested
    tools. Most notable among them are Ansible and Helm, and both of them have pros
    and cons. But I am not here to run a full comparison between them. My decision
    is based on having used both tools in serving production environments, and also
    our specific use case here. When it comes to pure configuration management and
    templating, Ansible remains the strongest contender. While Helm supports templating,
    it remains more like a Kubernetes package manager than a full configuration management
    tool. This is why we decided to use Ansible to develop a configuration management
    solution for Kubernetes infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: What is Ansible?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible is an automation and **configuration management** (**CM**) tool. It
    can configure systems, deploy applications and containers, and provision cloud
    resources. It can orchestrate advanced tasks such as continuous deployments and
    rolling updates.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are not going to dig deep into Ansible's features and use cases.
    We believe that there are a lot of good books dedicated to this purpose; our main
    focus is on how to use Ansible to solve Kubernetes' CM problem in a simple and
    efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible key concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The CM solution that we will implement and use in this book is built with key
    Ansible concepts. I will not dive deep into these concepts; rather, I will provide
    brief details about them, as well as highlight how we will utilize each one of
    them in our CM framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inventory**: This is used by Ansible to group similar hosts into groups.
    This is accomplished by defining the inventory files with the addresses of the
    hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules**: This is how Ansible abstracts and groups a specific task to be
    reused against your host''s inventories; modules can even be made public and used
    by other Ansible users. In our solution, we will use one of the ready-made Kubernetes
    modules to execute configuration manifests against the clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tasks**: This is where we instruct Ansible about the steps that it should
    do; it could be installing a piece of software or provisioning a whole system.
    In our solution, we will create a separate task to configure each Kubernetes component
    and add-on on its own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playbooks**: These are the building blocks of Ansible. They are used to gather
    everything together and provide a sequence of instructions that involves other
    Ansible blocks, such as tasks, variables, and modules. They then instruct Ansible
    on how to configure the target system to reach the desired state. In our solution,
    we will use a playbook to hold the configuration tasks for all of the components
    and add-ons that are required by all clusters, and we will also have variables
    and selectors to enable cluster maintainers to switch specific add-ons on/off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables**: We will use variables to hold the values for the configuration
    that is used for each cluster add-on, and we will split these variables into groups
    that represent different clusters and environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Ansible uses Jinja2 templates to enable dynamic expressions
    using variables. This enables Ansible to generate new configuration files based
    on these templates during execution time. In our solution, we will define Kubernetes
    manifests as Ansible Jinja2 templates, and during configuration execution time,
    Ansible will be able to generate the correct Kubernetes manifests for each cluster
    based on the provided or predefined variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous Ansible concepts are essential to understanding how Ansible works.
    We will utilize each of them to develop the CM solution in the next section. You
    will learn about each concept and how to use it as you move forward in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we put the solution we designed in the previous section into action. We
    will start by developing the Ansible framework skeleton, which will consist of
    the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`group_vars`: This directory contains the manifest configuration files with
    variables'' default unless a cluster defines its own private variables in its
    own inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inventories`: This directory contains the configuration files with variables''
    values, which are specific to each cluster or cluster group, meaning that variables
    defined here override default variables defined under the `groups_vars` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tasks`: In this directory, we define a separate task for each cluster service
    and add-on that we need to deploy and configure; the task definition file is standard
    across tasks, as we will use Ansible''s k8s module and pass to it the YAML templates
    to deploy against the target cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: This directory contains the Kubernetes manifest YAMLs and configuration
    files for each Kubernetes object we need to manage, and these template files will
    have the required variables written in Jinja2 expressions format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cluster.yaml`: This is the main playbook that will be passed to Ansible to
    execute against the target cluster. It contains all the tasks that we need to
    invoke to configure the cluster objects and add-ons. The playbook also has tags
    for each task, and this enables the cluster maintainer to switch specific tasks
    on/off for each target cluster whenever needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After creating the Ansible skeleton for Kubernetes cluster configuration management,
    we will be able to grow it to handle more cluster services and deployments. The
    development workflow looks as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Write Kubernetes manifests in YAML format for the cluster add-ons that you want
    to deploy, then deploy them to a test cluster to ensure correctness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the Kubernetes manifests from YAML to Jinja2 templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a task file to invoke these templates and add this file under the Ansible
    `tasks` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the variable values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- For default variable values, under the `group_vars` directory, add the values
    of the variables you created in the template in an appropriate YAML file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- For cluster-specific variables, under the `inventories` directory, create
    a new directory with the name of the cluster or cluster group that you want to
    target, and then create its own `group_vars` directory, and create under that
    a YAML file to contain the variable values mapping.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Update the playbook file and add a step to invoke the targeted task. Then, associate
    to this task the appropriate tags and properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the hands-on exercise, we will configure `aws-auth` and create a Kubernetes
    namespace to illustrate how this Ansible solution works. In the coming chapters,
    we will use this solution to deploy more services and add-ons on top of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The ansible directory's structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ansible` directory is where all the Ansible source code resides in your
    infrastructure repository. As a best practice, I recommend having a dedicated
    infrastructure source code repository that contains all the infrastructure as
    code and configuration for your Kubernetes clusters and the rest of your infrastructure.
    The following is the proposed directory structure of the Ansible configuration
    that we will develop in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Ansible directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_04_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Ansible directory structure
  prefs: []
  type: TYPE_NORMAL
- en: You will learn in detail and with hands-on practices how to develop this solution
    and all of the configuration code under the `ansible` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Ansible templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will create two templates to learn how you can rewrite
    Kubernetes manifests into Ansible Jinja2 format.
  prefs: []
  type: TYPE_NORMAL
- en: The second template is for a Kubernetes namespace, which you will use to create
    new namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the aws-auth template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first template is for `aws-auth` ConfigMap, which you will use to define
    AWS IAM users and roles and then authenticate them to the cluster. You will learn
    in detail about `aws-auth` and how to use it for cluster access in [*Chapter 6*](B16192_06_Final_PG_ePub.xhtml#_idTextAnchor131),
    *Securing Kubernetes Effectively*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will create a Jinja2 template for the `aws-auth` ConfigMap. However, let''s
    first have a look at the default `aws-auth` ConfigMap without templating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code block creates an `aws-auth` ConfigMap with one role for the
    worker EC2\. But what if we need to add more roles and users? What if we need
    to use the same ConfigMap with different clusters and with different worker `aws-auth`
    ConfigMap for each cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code block for the `aws-auth` template defines a list of specific
    users and roles who can access the cluster. In the first part of the code, you
    define the Kubernetes `apiVersion`, the object type as `ConfigMap`, and the metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part of the code, you define the ConfigMap `data` section that
    includes the `for` loop with Jinja2 variables that can be substituted by Ansible
    during the execution time. You notice that we use a `for` loop so we can add multiple
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part of the code, you define another ConfigMap `data` section
    that includes the IAM roles. First, instead of adding each user''s data (name,
    ARN, and Kubernetes group), you define them inside a Jinja2 `for` loop with Jinja2
    variables that can be substituted by Ansible during execution. You notice that
    we use a `for` loop so we can add multiple roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous template authenticates IAM users and roles to any cluster, and
    you can even extend it more with different group types according to your needs.
    But the original concept remains the same, as you have a single template for the
    `aws-auth` ConfigMap that can work for any cluster and for any users and roles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes namespace template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next code block is for a Jinja2 template that generates a YAML for a Kubernetes
    namespace manifest. This template defines the basic namespace configuration, such
    as names, labels, and annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This template can create multiple namespaces as it reads a list of namespaces
    from the target cluster''s Ansible variables and generates the Kubernetes manifest
    YAMLs for each one of these namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous template is an example of how you can create your own templates
    for Kubernetes objects. I recommend going to the Ansible Jinja2 official documentation
    when you write these templates to get more ideas about the code blocks and how
    to use them: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Ansible variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned earlier in this chapter, the Ansible `group_vars` will contain
    the global configuration variables that you want to apply to all clusters unless
    you want to specify a different value for a specific cluster. In this section,
    you will define default variables for the admin user in the `aws-auth` ConfigMap
    and define a new namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the aws-auth variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet defines the default variables for a cluster''s configuration
    whenever the cluster does not have its own private variables. The first variable
    is `worker_iam_role_arn`. Ansible will get the value of `worker_iam_role_arn`
    from the Terraform outputs. The second variable is the clusters'' admin. You also
    add the ARN or the IAM user that is called `admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can extend the previous variables and add more roles and users to the cluster
    according to your needs. You will also learn in [*Chapter 6*](B16192_06_Final_PG_ePub.xhtml#_idTextAnchor131),
    *Securing Kubernetes Effectively*, about the Kubernetes **Role-Based Access Control**
    (**RBAC**) and access management best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'In Jinja2 templates, you define the variables between double braces, `{{ }}`.
    Please refer to Ansible templating documentation: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the default namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will add a single namespace to the `namespaces_list` variable. However,
    you can add more namespaces according to your needs. This is an illustration to
    show you how namespace configuration should work with Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you should have learned how to create default configuration
    variables for your clusters. It is a simple configuration mechanism but is very
    powerful and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Ansible inventories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all clusters are equal. In the previous section, you learned how to set
    default variables for your configuration. But what if you need to have different
    values for one of your clusters? Ansible inventories are the answer. In this section,
    you will create inventories to define local cluster variables that override the
    default variables.
  prefs: []
  type: TYPE_NORMAL
- en: Create Ansible's inventory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way that Ansible configures hosts (servers/VMs) is very simple. Usually,
    there is a host or group of hosts and you have configuration tasks that you want
    to apply against these hosts. But our solution is a different use case, as we
    will use the same concept but not against any remote hosts. This is because, in
    reality, we do not configure hosts – instead, we configure Kubernetes clusters.
    Ansible just needs to communicate with the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need is to set the Ansible `hosts` to target the `localhost`. Then
    in turn, `localhost` will use the `kube-server` API endpoint defined in `kubeconfig`
    to apply the intended configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you will notice in this previous code block, there is only the `localhost`
    value defined as the target host for Ansible. This `hosts` file should exist for
    each inventory that Ansible manages.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the aws-auth variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To override the `aws-auth` default variables defined in `group_vars`, you need
    to recreate the `aws-auth` template file under the `packtclusters` inventory with
    the new variables'' values. The next code block shows you how to override `aws-auth`.
    There are two IAM roles defined: the first role for workers and the second for
    the cluster administrator role. The second part of the code defines a different
    user other than the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous configuration template will replace the default one for `packtclusters`.
    You can do the same for any other template.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the namespaces variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To override the `namespaces` default variables defined in `group_vars`, you
    need to recreate the `namespaces` template file under the `packtclusters` inventory
    with the new variables'' values. In the next code block, there is a new variable
    that will override `default-namespace` with a new one called `packtclusters-namespace`.
    So, when you apply this configuration, `packtclusters` will have the new namespace
    instead of the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you have learned how to override Ansible's default variables
    to use different configuration values based on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Ansible tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second step after creating the Ansible templates is creating Ansible tasks.
    In this section, you will learn how to create Ansible tasks to deploy your configuration
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: The tasks will use the Ansible k8s module. This module accepts the templated
    Kubernetes YAMLs and then instructs Ansible to apply these tasks against the target
    cluster. Ansible can identify the target cluster from the current context in the
    `kubeconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Ansible''s k8s module from the official documentation:
    [https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html](https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the aws-auth task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following task instructs Ansible on how to generate and apply the `aws-auth`
    ConfigMap to the cluster. It takes the path to the template file as an input and
    applies it to the target cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next code block, you define the task specs, with properties such as `name`,
    the `kubeconfig` path, `state`, and whether to force applying the configuration
    to the cluster or not. Then, the task defines which Jinja2 template to load and
    substitutes its variables with the values from the `group_vars` or `inventory`
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that there is a `loop` directive if there are multiple Jinja2
    templates to be applied by the `k8s` module. The other important parameters are
    `retries`, which tells Ansible the number of retries until the task succeeds,
    and `delay`, which tells Ansible the time in seconds between each of these retries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous code for the `aws-auth` task will be invoked by an Ansible playbook
    that you will learn about later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the namespaces task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following Ansible task file is for creating the cluster namespaces. It takes
    the path to the namespaces object template file and applies it to the target cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code structure for the `namespaces` task is very similar to the previous
    `aws-auth` task, except it has a different name, and it reads a different Jinja2
    template file for `namespaces.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous code for the `namespaces` task will be invoked by an Ansible playbook
    that you will learn about later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the cluster's playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Ansible playbook is an Ansible file where you put all tasks in the order
    that you want Ansible to execute them in. The following cluster playbook is a
    simple and standard Ansible playbook, and it has three sections: the first section
    is to define the target hosts, the second section is to define any variables that
    you want the tasks to use the values of during execution, and the third section
    is the list of tasks that Ansible will execute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block defines the hosts and the connection type. In our
    solution, we will use `localhost` as the target host, as explained before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block defines the variables that are required during the
    execution of the tasks. The most notable ones are the physical path to the `kubeconfig`
    file and the base directory where the Kubernetes templates reside. These variables
    override any variables with similar names in the `group_vars` and `inventory`
    directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block defines the list of tasks that Ansible executes against
    the target cluster. You add new tasks to this list and assign meaningful tags
    to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By completing the development of the playbook, tasks, and all the configurations,
    you are ready to put all the Ansible pieces together apply the playbook and have
    Ansible configure your cluster. In the next section, you will use the `packtclusters-prod1`
    cluster, which you created in the previous chapter, to apply the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the cluster's Ansible playbook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next instructions will deploy the Ansible playbook, which will configure
    your cluster with the intended configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Terraform state and select the workspace by running the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve and configure the localhost `kubeconfig` with the target cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use Python `virtualenv` to install and execute Ansible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install Ansible and the prerequisite modules, `openshift`, `pyyaml`, and `requests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the Ansible playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the following output after successful execution:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Ansible execution output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16192_04_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.3 – Ansible execution output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following `kubectl` command to ensure that the cluster configuration
    is applied successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 4.4 – List of cluster namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16192_04_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – List of cluster namespaces
  prefs: []
  type: TYPE_NORMAL
- en: You applied the cluster playbook and tasks as per the previous instructions.
    In the following chapters, you will learn how to use the same configuration management
    solution to create other tasks to deploy and configure services on top of your
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the cluster's resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can follow the instructions in the *Destroying the network and cluster
    infrastructure* section of [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073),
    *Provisioning Kubernetes Clusters Using AWS and Terraform*, to destroy the Kubernetes
    cluster and its related AWS resources. Please be sure to destroy the resources
    in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Cluster `packtclusters` resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cluster VPC resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Terraform shared state resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing the previous steps, all of the cluster AWS resources should
    be destroyed successfully. You can still log in to the AWS web console and double-check
    the destruction of the resources to avoid any unwanted AWS charges.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Kubernetes configuration management challenges
    and how to scale your configuration management solution to manage multiple clusters
    and environments. We designed and developed a solution that is based on Ansible,
    and we went through practical hands-on examples to deploy this code.
  prefs: []
  type: TYPE_NORMAL
- en: We started by creating Ansible templates for Kubernetes objects and add-ons.
    Then, we developed the tasks and the playbook to execute the Ansible configuration
    in sequence against the targeted clusters.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced you to Ansible basic concepts. It showed you how to
    use the best practices of infrastructure and configuration as code, automation,
    and Ansible development.
  prefs: []
  type: TYPE_NORMAL
- en: This sets up the base for the coming chapters, where you will use this configuration
    management solution to configure and deploy clusters' add-ons and services where
    these add-ons are essential to reach production-readiness.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about Kubernetes networking and connectivity.
    The best practices of deploying and configuring Kubernetes network plugins, cluster
    DNS, ingresses, network policies, and service mesh will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ansible 2 for Configuration Management [Video]*: [https://www.packtpub.com/product/ansible-2-for-configuration-management-video/9781838826475](https://www.packtpub.com/product/ansible-2-for-configuration-management-video/9781838826475)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practical Ansible 2*: [https://www.packtpub.com/product/practical-ansible-2/9781789807462](https://www.packtpub.com/product/practical-ansible-2/9781789807462)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automation with Ansible Playbooks [Video]*:[https://www.packtpub.com/product/automation-with-ansible-playbooks-video/9781800206496](https://www.packtpub.com/product/automation-with-ansible-playbooks-video/9781800206496)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
