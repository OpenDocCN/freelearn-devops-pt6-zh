- en: Cluster Authentication, Authorization, and Container Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will discuss the basics of container security from the container
    runtime level to the host itself. We will discuss how to apply these concepts
    to workloads running in a Kubernetes cluster and some of the security concerns
    and practices that relate specifically to running your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic container security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container image security and continuous vulnerability scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes cluster security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of container security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container security is a deep subject area and in itself can fill its own book.
    Having said this, we will cover some of the high-level concerns and give you a
    starting point so that you can start thinking about this area.
  prefs: []
  type: TYPE_NORMAL
- en: In the *A brief overview of containers* section of Chapter 1*, Introduction
    to Kubernetes*, we looked at some of the core isolation features in the Linux
    kernel that enable container technology. Understanding the details of how containers
    work is the key to grasping the various security concerns in managing them.
  prefs: []
  type: TYPE_NORMAL
- en: A good paper to dive deeper is *NCC's Whitepaper*, *Understanding and Hardening
    Linux Containers*. In *section 7*, the paper explores the various attack vectors
    of concern for container deployments, which I will summarize.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping containers contained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most obvious features that is discussed in the paper we mentioned
    in the preceding section is that of escaping the isolation/virtualization of the
    container construct. Modern container implementations guard against using namespaces
    to isolate processes as well as allowing the control of Linux capabilities that
    are available to a container. Additionally, there is an increased move toward
    secure default configurations of the out-of-the-box container environment. For
    example, by default, Docker only enables a small set of capabilities. Networking
    is another avenue of escape and it can be challenging since there are a variety
    of network options that plug into most modern container setups.
  prefs: []
  type: TYPE_NORMAL
- en: The next area discussed in the paper is that of attacks between two containers.
    The *User* namespace model gives us added protection here by mapping the root
    user within the container to a lower-level user on the host machine. Networking
    is, of course, still an issue, and something that requires proper diligence and
    attention when selecting and implementing your container networking solution.
  prefs: []
  type: TYPE_NORMAL
- en: Attacks within the container itself are another vector and, as with previous
    concerns, namespaces and networking are key to protection here. Another aspect
    that is vital in this scenario is the application security itself. The code still
    needs to follow secure coding practices and the software should be kept up to
    date and patched regularly. Finally, the efficiency of container images has an
    added benefit of shrinking the attack surface. The images should be built with
    only the packages and software that's necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Resource exhaustion and orchestration security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the **denial-of-service** (**DoS**) attacks, we've seen in various
    other areas of computing that resource exhaustion is very much a pertinent concern
    in the container world. While cgroups provide some limitations on resource usage
    for things such as CPU, memory, and disk usage, there are still valid attack avenues
    for resource exhaustion. Tools such as Docker offer some starting defaults to
    the cgroups limitations, and Kubernetes also offers additional limits that can
    be placed on groups of containers running in the cluster. It's important to understand
    these defaults and to adjust for your deployments.
  prefs: []
  type: TYPE_NORMAL
- en: While the Linux kernel and the features that enable containers give us some
    form of isolation, they are fairly new to the Linux operating system. As such,
    they still contain their own bugs and vulnerabilities. The built-in mechanisms
    for capabilities and namespaces can and do have issues, and it is important to
    track these as part of your secure container operations.
  prefs: []
  type: TYPE_NORMAL
- en: The final area covered in the NCC paper is the attack of the container management
    layer itself. The Docker engine, image repositories, and orchestration tools are
    all significant vectors of attack and should be considered when developing your
    strategy. We'll look in more depth at how we can address the repositories and
    Kubernetes as an orchestration layer in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in knowing more about the specific security features of
    Docker's implementation, take a look here: [https://docs.docker.com/engine/security/security/](https://docs.docker.com/engine/security/security/).
  prefs: []
  type: TYPE_NORMAL
- en: Image repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vulnerability management is a critical component of any modern day IT operation.
    Zero-day vulnerabilities are on the rise and even those vulnerabilities with patches
    can be cumbersome to remediate. First, application owners must be made aware of
    their vulnerabilities and potential patches. Then, these patches must be integrated
    into systems and code, and often this requires additional deployments or maintenance
    windows. Even when there is visibility to vulnerabilities, there is often a lag
    in remediation, often taking large organizations several months to patch.
  prefs: []
  type: TYPE_NORMAL
- en: While containers greatly improve the process of updating applications and minimizing
    downtime, there still remains a challenge that's inherent in vulnerability management.
    Especially since an attacker only needs to expose one such vulnerability, making
    anything less than 100% of the systems patched is a risk of compromise.
  prefs: []
  type: TYPE_NORMAL
- en: What's needed is a faster feedback loop in addressing vulnerabilities. Continuous
    scanning and tying into the software deployment life cycle is key to speeding
    up the information and remediation of vulnerabilities. Luckily, this is exactly
    the approach that's being built into the latest container management and security
    tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous vulnerability scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One such open source project that has emerged in this space is **clair**. clair
    is an open source project for the static analysis of vulnerabilities in appc ([https://github.com/appc/spec](https://github.com/appc/spec))
    and Docker ([https://github.com/moby/moby/blob/master/image/spec/v1.md](https://github.com/moby/moby/blob/master/image/spec/v1.md))
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: You can visit clair at the following link: [https://github.com/coreos/clair](https://github.com/coreos/clair).
  prefs: []
  type: TYPE_NORMAL
- en: clair scans your code against **Common Vulnerabilities and Exploits** (**CVEs**).
    It can be integrated into your CI/CD pipeline and run as a response to new builds.
    If vulnerabilities are found, they can be taken as feedback into the pipeline,
    even stop deployment, and fail the build. This forces developers to be aware of
    and remediate vulnerabilities during their normal release process.
  prefs: []
  type: TYPE_NORMAL
- en: clair can be integrated with a number of container image repositories and CI/CD
    pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: clair can even be deployed on Kubernetes: [https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm](https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm).
  prefs: []
  type: TYPE_NORMAL
- en: clair is also used as the scanning mechanism in CoreOS's Quay image repository.
    Quay offers a number of enterprise features, including continuous vulnerability
    scanning ([https://quay.io/](https://quay.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: Both Docker Hub and Docker Cloud support security scanning. Again, containers
    that are pushed to the repository are automatically scanned against CVEs, and
    notifications of vulnerabilities are sent as a result of any findings. Additionally,
    binary analysis of the code is performed to match the signature of the components
    with that of known versions.
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of other scanning tools that can be used as well for scanning
    your image repositories, including OpenSCAP, Twistlock, Aqua Sec, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Image signing and verification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you are using a private image repository in-house or a public repository
    such as Docker Hub, it's important to know that you are only running the code
    that your developers have written. The potential for malicious code or man-in-the-middle
    attacks on downloads is an important factor in protecting your container images.
  prefs: []
  type: TYPE_NORMAL
- en: As such, both rkt and Docker support the ability to sign images and verify that
    the contents have not changed. Publishers can use keys to sign the images when
    they are pushed to the repositories, and users can verify the signature on the
    client side when downloading for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is from the rkt documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>"Before executing a remotely fetched ACI, rkt will verify it based on attached
    signatures generated by the ACI</q> creator."
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, visit the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md](https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md](https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md)[ ](https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is from the Docker documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>"Content trust gives you the ability to verify both the integrity and the
    publisher of all the data received from a registry over any channel. "</q>
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, visit[https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/).
    [](https://docs.docker.com/engine/security/trust/content_trust/) This is from
    the Docker Notary GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>"The Notary project comprises a server and a client for running and interacting
    with trusted collections."</q>
  prefs: []
  type: TYPE_NORMAL
- en: For more information, visit [https://github.com/docker/notary](https://github.com/docker/notary).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes cluster security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes has continued to add a number of security features in their latest
    releases and has a well-rounded set of control points that can be used in your
    cluster – everything from secure node communication to pod security and even the
    storage of sensitive configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: Secure API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During every API call, Kubernetes applies a number of security controls. This
    security life cycle is depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f03a474d-08ef-43ef-83a2-76af157b1860.png)'
  prefs: []
  type: TYPE_IMG
- en: API call life cycle
  prefs: []
  type: TYPE_NORMAL
- en: After secure TLS communication is established, the API server runs through authorization
    and authentication. Finally, an admission controller loop is applied to the request
    before it reaches the API server.
  prefs: []
  type: TYPE_NORMAL
- en: Secure node communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes supports the use of secure communication channels between the API
    server and any client, including the nodes themselves. Whether it's a GUI or command-line
    utility such as `kubectl`, we can use certificates to communicate with the API
    server. Hence, the API server is the central interaction point for any changes
    to the cluster and is a critical component to secure.
  prefs: []
  type: TYPE_NORMAL
- en: In deployments such as GCE, the `kubelet` on each node is deployed for secure
    communication by default. This setup uses TLS bootstrapping and the new certificates'
    API to establish a secure connection with the API server using TLS client certificates
    and a **Certificate Authority** (**CA**) cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization and authentication plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The plugin mechanisms for authentication and authorization in Kubernetes are
    still being developed. They have come a long way, but still have plugins in beta
    stages and enhancements in the works. There are also third-party providers that
    integrate with the features here, so bear that in mind when building your hardening
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is currently supported in the form of tokens, passwords, and
    certificates, with plans to add the plugin capability at a later stage. OpenID
    Connect tokens are supported and several third-party implementations, such as
    Dex from CoreOS and user account and authentication from Cloud Foundry, are available.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization already supports three modes. The **role-based access control** (**RBAC**)
    mode recently went to general availability in the 1.8 release and brings the standard
    role-based authentication model to Kubernetes. **Attribute-based access control**
    (**ABAC**) has long been supported and lets a user define privileges via attributes
    in a file.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a Webhook mechanism is supported, which allows for integration
    with third-party authorization via REST web service calls. Finally, we have the
    new node authorization method, which grants permissions to kubelets based on the
    pods they are scheduled to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about each area at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://kubernetes.io/docs/admin/authorization/](http://kubernetes.io/docs/admin/authorization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://kubernetes.io/docs/admin/authentication/](http://kubernetes.io/docs/admin/authentication/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/reference/access-authn-authz/node/](https://kubernetes.io/docs/reference/access-authn-authz/node/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admission controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes also provides a mechanism for integrating, with additional verification
    as a final step. This could be in the form of image scanning, signature checks,
    or anything that is able to respond in the specified fashion.
  prefs: []
  type: TYPE_NORMAL
- en: When an API call is made, the hook is called and that server can run its verification. Admission
    controllers can also be used to transform requests and add or alter the original
    request. Once the operations are run, a response is then sent back with a status
    that instructs Kubernetes to allow or deny the call.
  prefs: []
  type: TYPE_NORMAL
- en: This can be especially helpful for verifying or testing images, as we mentioned
    in the last section. The `ImagePolicyWebhook` plugin provides an admission controller
    that allows for integration with additional image inspection.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, visit the Using Admission Controller page in the following
    documentation: [https://kubernetes.io/docs/admin/admission-controllers/](https://kubernetes.io/docs/admin/admission-controllers/).
  prefs: []
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, Kubernetes has now made RBAC a central
    component to authorization within the cluster. Kubernetes offers two levels for
    this kind of control. First, there is a *ClusterRole*, which provides cluster-wide
    authorization to resources. This is handy for enforcing access control across
    multiple teams, products, or to cluster-wide resources such as the underlying
    cluster nodes. Second, we have a *Role*, which simply provides access to resources
    within a specific namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a role, you need a way to provide users with membership to that
    role. These are referred to as *Bindings*, and again we have *ClusterRoleBinding*
    and *RoleBinding*. As with the roles themselves, the former is meant for cluster-wide
    access and the latter is meant to apply within a specific namespace.
  prefs: []
  type: TYPE_NORMAL
- en: We will not dive into the details of RBAC in this book, but it is something
    you'll want to explore as you get ready for production grade deployments. The
    *PodSecurityPolicy* discussed in the next section typically utilizes Roles and
    RoleBindings to control which policies each user has access to.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, please refer to the documentation here: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
  prefs: []
  type: TYPE_NORMAL
- en: Pod security policies and context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the latest additions to the Kubernetes' security arsenal is that of pod
    security policies and contexts. These allow users to control users and groups
    for container processes and attached volumes, limit the use of host networks or
    namespaces, and even set the root filesystem to read-only. Additionally, we can
    limit the capabilities available and also set SELinux options for the labels that
    are applied to the containers in each pod.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to SELinux, Kubernetes also added beta support for using AppArmor
    with your pods by using annotations. For more information, refer to the following
    documentation page: [https://kubernetes.io/docs/admin/apparmor/](https://kubernetes.io/docs/admin/apparmor/).
  prefs: []
  type: TYPE_NORMAL
- en: 'PodSecurityPolicies are enforced using the admission controller we spoke of
    earlier in this book. By default, Kubernetes doesn''t enable PodSecurityPolicy,
    so if you have a GKE cluster running, you can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should see `'No resources found.'`, assuming you haven't enabled them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an example by using the Docker image from our previous chapters.
    If we use the following `run` command on a cluster with no PodSecurityPolicy applied,
    it will happily run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Follow this with `kubectl get pods` and in a minute or so we should see a pod
    starting with `myroottest` in the listings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and clean this up with the following code before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Enabling PodSecurityPolicies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s try this with a cluster that can utilize PodSecurityPolicies. If
    you are using GKE, it is quite easy to create a cluster with PodSecurityPolicy
    enabled. Note you will need the Beta APIs enabled for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you have an existing GKE cluster, you can enable it with a command similar
    to the preceding one. Simply replace the `create` keyword with `update`.
  prefs: []
  type: TYPE_NORMAL
- en: For clusters created with `kube-up`, like we saw in [Chapter 1](446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml),
    *Introduction to Kubernetes*, you'll need to enable the admission controller on
    the API server. Take a look here for more information: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have PodSecurityPolicy enabled, you can see the applied policies by
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/79bea3b7-c4ae-4451-b9d4-978f07e1cf44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GKE default pod security policies
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice a few predefined policies that GKE has already defined. You
    can explore the details and the YAML used to create these policies with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that PodSecurityPolicies work with the RBAC features
    of Kubernetes. There are a few default roles, role bindings, and namespaces that
    are defined by GKE. As such, we will see different behaviors based on how we interact
    with Kubernetes. For example, by using `kubectl` in a GCloud Shell, you may be
    sending commands as a cluster admin and therefore have access to all policies,
    including `gce.privileged`. However, using the `kubectl run` command, as we did
    previously, will invoke the pods through the kube-controller-manager, which will
    be restricted to the policies bound to its role. Thus, if you simply create a
    pod with `kubectl`, it will create it without an issue, but by using the `run`
    command, we will be restricted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sticking to our previous method of using `kubectl run`, let''s try the same
    deployment as the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we follow this with `kubectl get pods`, we won''t see any pods prefaced
    with `myroottest`. We can dig a bit deeper by describing our deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the name of the replica set listed in the output from the preceding
    command, we can then get the details on the failure. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the events at the bottom, you will see the following pod security policy
    validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/916c02b0-331a-4e10-a10c-097fb49138ed.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Replica set pod security policy validation error
  prefs: []
  type: TYPE_NORMAL
- en: Again, because the `run` command uses the controller manager and that role has
    no bindings that allow the use of the existing **PodSecurityPolicies**, we are
    unable to run any pods.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding that running containers securely is not merely the task of administrators
    adding constraints is important. The work must be done in collaboration with developers,
    who will properly create the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all of the possible parameters for PodSecurityPolicies in the
    source code, but I''ve created the following table for convenience. You can find
    more handy lookups like this on my new site, [http://www.kubesheets.com](http://www.kubesheets.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Type** | **Description** | **Required** |'
  prefs: []
  type: TYPE_TB
- en: '| `Privileged` | `bool` | Allows or disallows running a pod as privileged.
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `DefaultAddCapabilities` | `[]v1.Capaility` | This defines a default set
    of capabilities that are added to the container. If the pod specifies a capability
    drop that will override, then add it here. Values are strings of POSIX capabilities
    minus the leading `CAP_`. For example, `CAP_SETUID` would be `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `RequiredDropCapabilities` | `[]v1.Capaility` | This defines a set of capabilities
    that must be dropped from a container. The pod cannot specify any of these capabilities.Values
    are strings of POSIX capabilities minus the leading `CAP_`. For example, `CAP_SETUID`
    would be `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `AllowedCapabilities` | `[]v1.Capaility` | This defines a set of capabilities
    that are allowed and can be added to a container. The pod can specify any of these
    capabilities.Values are strings of POSIX capabilities minus the leading `CAP_`.
    For example, `CAP_SETUID` would be `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `Volumes` | `[]string` | This list defines which volumes can be used. Leave
    this empty for all types ([https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127](https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127)).
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `HostNetwork` | `bool` | This allows or disallows the pod to use the host
    network. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `HostPorts` | `[]HostPortRange` | This lets us restrict allowable host ports
    that can be exposed. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `HostPID` | `bool` | This allows or disallows the pod to use the host PID.
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `HostIPC` | `bool` | This allows or disallows the pod to use the host IPC.
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `SELinux` | `SELinuxStrategyOptions` | Set it to one of the strategy options,
    as defined here: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux).
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `RunAsUser` | `RunAsUserStrategyOptions` | Set it to one of the strategy
    options, as defined here: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups).
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `SupplementalGroups` | `SupplementalGroupsStrategyOptions` | Set it to one
    of the strategy options, as defined here: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups)
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `FSGroup` | `FSGroupStrategyOptions` | Set it to one of the strategy options,
    as defined here: [https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadOnlyRootFilesystem` | `bool` | Setting this to `true` will either deny
    the pod or force it to run with a read-only root filesystem. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `allowedHostPaths` | `[]AllowedHostPath` | This provides a whitelist of host
    paths that can be used at volumes. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `allowedFlexVolumes` | `[]AllowedFlexVolume` | This provides a whitelist
    of flex volumes that can be mounted. | No |'
  prefs: []
  type: TYPE_TB
- en: '| `allowPrivilegeEscalation` | `bool` | This governs where `setuid` can be
    used to change the user a process is running under. Its default is `true`.   |
    No |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultAllowPrivilegeEscalation` | `bool` | Sets the default for `allowPrivilegeEscalation`.
    | No |'
  prefs: []
  type: TYPE_TB
- en: Additional considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the features we just reviewed, Kubernetes has a number of other
    constructs that should be considered in your overall cluster hardening process.
    Earlier in this book, we looked at namespaces that provide a logical separation
    for multi-tenancy. While the namespaces themselves do not isolate the actual network
    traffic, some of the network plugins, such as Calico and Canal, provide additional
    capability for network policies. We also looked at quotas and limits that can
    be set for each namespace, which should be used to prevent a single tenant or
    project from consuming too many resources within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Securing sensitive application data (secrets)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, our application needs to hold sensitive information. This can be
    credentials or tokens to log in to a database or service. Storing this sensitive
    information in the image itself is something to be avoided. Here, Kubernetes provides
    us with a solution in the construct of secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets give us a way to store sensitive information without including plaintext
    versions in our resource definition files. Secrets can be mounted to the pods
    that need them and then accessed within the pod as files with the secret values
    as content. Alternatively, you can also expose the secrets via environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Given that Kubernetes still relies on plaintext etcd storage, you may want to
    explore integration with more mature secrets vaults, such as Vault from Hashicorp.
    There is even a GitHub project for integration: [https://github.com/Boostport/kubernetes-vault](https://github.com/Boostport/kubernetes-vault).
  prefs: []
  type: TYPE_NORMAL
- en: We can easily create a secret either with YAML or on the command line. Secrets
    do need to be base-64 encoded, but if we use the `kubectl` command line, this
    encoding is done for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then check for the secret with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have successfully created the secret, let''s make a pod that can
    use the secret. Secrets are consumed in pods by way of attached volumes. In the
    following `secret-pod.yaml` file, you''ll notice that we use `volumeMount` to
    mount the secret to a folder in our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create this pod with `kubectl create -f secret-pod.yaml`. Once created, we
    can get a bash shell in the pod with `kubectl exec` and then change directories
    to the `/etc/secret-phrases` folder that we set up in the pod definition. Listing
    this directory reveals a single file with the name of the secret that we created
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then display its contents, we should see the phrase we encoded previously,
    `Shh! Dont'' tell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Typically, this would be used for a username and password to a database or service, or
    any sensitive credentials and configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that secrets are still in their early stages, but they are a vital
    component for production operations. There are several improvements being planned
    for future releases. At the moment, secrets are still stored in plaintext in the
    etcd server. However, the secrets construct does allow us to control which pods
    can access it, and it stores the information on the tmpfs, but does not store
    it at rest for each pod. You can limit users with access to etcd and perform additional
    wipe procedures when you decommission servers, but you'll likely want more protection
    in place for a production-ready system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at basic container security and some essential
    areas of consideration. We also touched on basic image security and continuous
    vulnerability scanning. Later in this chapter, we looked at the overall security
    features of Kubernetes, including secrets for storing sensitive configuration
    data, secure API calls, and even setting up security policies and contexts for
    pods running on our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a solid starting point for securing your cluster and moving
    toward production. To that end, the next chapter will cover an overall strategy
    for moving toward production and will also look at some third-party vendors that
    offer tools to fill in the gaps and assist you on the way.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which component can be used as a central point for managing and prevent vulnerabilities
    from being released?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are three methods for authorization within a Kubernetes cluster?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which parameter of a PodSecurityPolicy disallows the running of privileged containers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you list all secrets that you have access to in a cluster?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-10pdf/](https://www.nccgroup.trust/us/our-research/understanding-and-hardening-linux-containers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14](https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145](https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
