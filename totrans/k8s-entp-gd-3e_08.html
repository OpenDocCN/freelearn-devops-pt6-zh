<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer154">
<h1 class="chapterNumber">8</h1>
<h1 class="chapterTitle" id="_idParaDest-295">Managing Secrets</h1>
<p class="normal">Everyone has secrets, and Kubernetes clusters are no <a id="_idIndexMarker812"/>different. <strong class="keyWord">Secrets</strong> can be used to store credentials for connecting to databases, private keys for encryption or authentication, or anything else that’s deemed confidential. In this chapter, we’ll explore why secret data has to be handled differently than other configuration data, how to model threats against your cluster’s secrets, and different ways to integrate external secret managers into your clusters.</p>
<p class="normal">In <em class="chapterRef">Chapter 6</em><em class="italic">, Integrating Authentication into Your Cluster</em>, we created some secrets for <strong class="keyWord">OpenUnison</strong>. These Secrets<a id="_idIndexMarker813"/> were simple Kubernetes objects and weren’t treated any differently then we’d treat other configuration data. This makes it difficult to follow common enterprise requirements for secret data, such as periodic rotation and tracking usage. It’s important to understand why enterprises generally have these requirements and how to implement them. It’s also important to be able to model threats from a realistic perspective and to avoid creating security holes by trying to make things more secure.</p>
<p class="normal">This chapter will walk through why you need to treat secret data different from other configuration data and provide you the tools you’ll need to determine your secrets management requirements and to build out your secrets management platform. We’ll cover:</p>
<ul>
<li class="bulletList">Examining the difference between Secrets and Configuration Data</li>
<li class="bulletList">Understanding Secrets Managers</li>
<li class="bulletList">Integrating Secrets into your Deployments</li>
</ul>
<h1 class="heading-1" id="_idParaDest-296">Technical Requirements</h1>
<p class="normal">This chapter has the following technical requirements:</p>
<ul>
<li class="bulletList">An Ubuntu 22.04+ server running Docker with a minimum of 4 GB of RAM, though 8 GB is suggested</li>
<li class="bulletList">Scripts from the <code class="inlineCode">chapter8</code> folder from the repo, which you can access by going to this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition"><span class="url">https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-297">Getting Help</h1>
<p class="normal">We do our best to test everything, but there are sometimes half a dozen systems or more in our integration labs. Given the fluid nature of technology, sometimes things that work in our environment don’t work in yours. Don’t worry, we’re here to help! Open an issue on our GitHub repo at <a href="https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues"><span class="url">https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues</span></a> and we’ll be happy to help you out!</p>
<h1 class="heading-1" id="_idParaDest-298">Examining the difference between Secrets and Configuration Data</h1>
<p class="normal">What makes a <code class="inlineCode">Secret</code> different than the configuration data stored in a <code class="inlineCode">ConfigMap</code> or a <strong class="keyWord">CRD</strong>? From a Kubernetes perspective, the only <a id="_idIndexMarker814"/>real difference is that both <code class="inlineCode">ConfigMaps</code> and CRDs <a id="_idIndexMarker815"/>are represented as text, where <a id="_idIndexMarker816"/>as a <code class="inlineCode">Secret</code> is represented as a <strong class="keyWord">base64</strong> encoded string, allowing secrets to contain binary data.</p>
<p class="normal">If you are new to base64, it is an encoding process, known for using a 64-character set that converts binary data into an ASCII character string. This provides a reliable method to send binary information during transmission as text, which is beneficial when direct binary support is unsupported or where the risk of data corruption in a plain text transmission is a concern, making it useful for transmitting images, audio, and binary files.</p>
<div class="note">
<p class="normal">There can be some confusion between the terms encoding and encryption. Encryption requires a key to decode, while encoding does not. While encoding might provide some obscurity to text, it doesn’t protect it. If you didn’t need a key to encode your data, it’s not encrypted.</p>
</div>
<p class="normal">Now, let’s look at a <code class="inlineCode">Secret</code> object:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-string">"2023-07-30T00:04:51Z"</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">orchestra-secrets-source</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">openunison</span>
  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">"2958"</span>
  <span class="hljs-attr">uid:</span> <span class="hljs-string">2236389e-e751-4030-8d51-96325d302815</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">AD_BIND_PASSWORD:</span> <span class="hljs-string">JHRhcnQxMjM=</span>
  <span class="hljs-attr">K8S_DB_SECRET:</span> <span class="hljs-string">VHloc...</span>
  <span class="hljs-attr">OU_JDBC_PASSWORD:</span> <span class="hljs-string">c3RhcnR0MTIz</span>
  <span class="hljs-attr">SMTP_PASSWORD:</span> <span class="hljs-string">c3RhcnQxMjM=</span>
  <span class="hljs-attr">unisonKeystorePassword:</span> <span class="hljs-string">R2VHV3...</span>
</code></pre>
<p class="normal">This looks very similar to a <code class="inlineCode">ConfigMap</code>, but <a id="_idIndexMarker817"/>there are two differences:</p>
<ul>
<li class="bulletList">The addition of the <code class="inlineCode">type</code> directive tells<a id="_idIndexMarker818"/> Kubernetes what kind of Secret this is.</li>
<li class="bulletList">All of the fields in the <code class="inlineCode">data</code> section are base64 encoded.</li>
</ul>
<p class="normal">The <code class="inlineCode">type</code> directive tells Kubernetes what kind of <code class="inlineCode">Secret</code> you’re creating. In this case, <code class="inlineCode">type</code> <code class="inlineCode">Opaque</code> means that there is no format to the <code class="inlineCode">Secret</code>'s <code class="inlineCode">data</code> section. This will likely be the most common <code class="inlineCode">type</code> you will see.</p>
<p class="normal">There are no requirements for the <code class="inlineCode">type</code> directive; you can specify whatever you want if you wish to provide your own value. That said, if you do provide one of Kubernetes’ pre-defined types, the cluster will validate that the format matches. You can find the list of pre-defined types in Kubernetes’ <code class="inlineCode">Secret</code> documentation: <a href="https://kubernetes.io/docs/concepts/configuration/secret/#secret-types"><span class="url">https://kubernetes.io/docs/concepts/configuration/secret/#secret-types</span></a></p>
<p class="normal">For instance, if you were to set the <code class="inlineCode">type</code> to <code class="inlineCode">kubernetes.io/tls</code> your <code class="inlineCode">Secret</code> must have a key called <code class="inlineCode">tls.crt</code> (i.e., a base64-encoded PEM encoded certificate) and a key called <code class="inlineCode">tls.key</code> (i.e., a base64 encoded PEM private key), otherwise the API server will fail to create your <code class="inlineCode">Secret</code> and give you an error. Here’s an example:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">kubectl create -f - &lt;&lt;</span><span class="hljs-con-string">EOF</span>
<span class="hljs-con-meta">heredoc&gt; </span><span class="hljs-con-string">apiVersion: v1</span>
kind: Secret
metadata:
  name: not-tls
  namespace: default
type: kubernetes.io/tls
data:
  AD_BIND_PASSWORD: JHRhcnQxMjM=
EOF
The Secret "not-tls" is invalid:
* data[tls.crt]: Required value * data[tls.key]: Required value
</code></pre>
<p class="normal">The base64 encoding of data is<a id="_idIndexMarker819"/> for a very simple reason, but is also the source<a id="_idIndexMarker820"/> of considerable confusion. Kubernetes <code class="inlineCode">Secret</code> data <em class="italic">must</em> be base64 encoded because secret data is often case sensitive or binary and so must be encoded to ensure that it survives the translation from YAML -JSON -binary storage.</p>
<p class="normal">It’s important to understand how YAML gets stored in the Kubernetes API server to understand why.</p>
<p class="normal">When we work with a YAML file, the text is represented in the file by a byte (or more). This YAML is then converted to JSON by <code class="inlineCode">kubectl</code> for interacting with the Kubernetes API. The JSON that is sent to the API server is then translated into a binary format when it is stored. The problem we run into with many text-based formats is that there are multiple ways to represent text-based data in a binary format.</p>
<p class="normal">For instance, <strong class="keyWord">UTF-8</strong>, which is one of the<a id="_idIndexMarker821"/> most common encodings, can use from one to four bytes to represent a certain <a id="_idIndexMarker822"/>character. <strong class="keyWord">UTF-16</strong> uses one to four 16-bit “code units”. <strong class="keyWord">ASCII</strong> can <a id="_idIndexMarker823"/>only encode the English alphabet, Arabic numerals, and common English punctuation. If the encoding from YAML – JSON - binary and back involves switches encoding types, data can be lost or corrupted.</p>
<p class="normal">Preserving binary data in text is where the base64 standard comes in. Base64 allows any data to be stored as ASCII text, which is a subset universally across different encoding types. This means that the base64-encoded data can be reliably transmitted across encoding types.</p>
<p class="normal">If you’re still skeptical of why base64 encoding your secret data is important, have you ever copied a file created on Windows to a Linux system and started seeing <code class="inlineCode">^M</code> in the text? That’s an additional risk of traversing systems: different systems represent new lines with different control characters. Base64 encoding your secret data means that the information in the YAML file is the same as what’s stored byte-for-byte.</p>
<p class="normal">One thing that’s incredibly important to understand is that base64 encoding is not encryption. There is no security benefit to encoding, it will not stop someone from snooping on your secrets.</p>
<p class="normal">Now that we know why <code class="inlineCode">Secret</code> <code class="inlineCode">data</code> is base64<a id="_idIndexMarker824"/> encoded, why are <code class="inlineCode">Secrets</code> their own objects? Why don’t we just<a id="_idIndexMarker825"/> base64 encode <code class="inlineCode">ConfigMaps</code>? The answer is to more easily use RBAC to restrict access. In the last chapter, we explored Kubernetes’ RBAC system for authorizing access to resources. In the chapter before that, we explored how Kubernetes creates <code class="inlineCode">ServiceAccount</code> tokens, which can be stored in <code class="inlineCode">Secret</code> objects. Combining the knowledge from these two chapters, we see how storing sensitive data in a <code class="inlineCode">ConfigMap</code> can generate unintended consequences when we consider the <code class="inlineCode">view</code> <code class="inlineCode">ClusterRole</code>, which is intended to give read-only access to a <code class="inlineCode">namespace</code>. This <code class="inlineCode">ClusterRole</code> does not include the <code class="inlineCode">Secret</code> type, so <code class="inlineCode">view</code> will allow you to read <code class="inlineCode">ConfigMaps</code>, view pod status, etc., but not read a <code class="inlineCode">Secret</code>. This is because a <code class="inlineCode">Secret</code> might contain a token for a <code class="inlineCode">ServiceAccount</code>, which is bound to a higher-privilege <code class="inlineCode">Role</code> or <code class="inlineCode">ClusterRole</code>, so a user with read-only access can escalate that access if we’re not careful. If secret data were stored in <code class="inlineCode">ConfigMaps</code>, RBAC would either need to support some way to exclude resources or enumerate specific <code class="inlineCode">ConfigMap</code> objects that should be allowed to be viewable by the <code class="inlineCode">view ClusterRole</code>, making it likely to not be used properly.</p>
<p class="normal">Now that we know what makes a <code class="inlineCode">Secret</code> different than other configuration objects, we will explore why you need to treat <code class="inlineCode">Secret</code> objects differently than <code class="inlineCode">ConfigMaps</code> and CRDs.</p>
<h2 class="heading-2" id="_idParaDest-299">Managing Secrets in an Enterprise</h2>
<p class="normal">The title of this book includes the word “enterprise,” and secret data management is a big area where this is important. Most <a id="_idIndexMarker826"/>enterprises have very specific rules <a id="_idIndexMarker827"/>around secrets management. Some of these rules involve being able to audit when a secret is used, and others require that secrets be rotated on a periodic basis. Following these rules is a process referred to as “compliance” and is often one of the largest cost drivers for any enterprise deployment.</p>
<p class="normal">Security and compliance are often grouped together, but they do not mean the same thing. It’s quite easy to build a 100% compliant system that makes your auditors happy, but will fail to secure your applications and data. That’s why it’s important to understand why you’re building certain features into your platforms. You need to ask yourself, are they satisfying<a id="_idIndexMarker828"/> compliance, security, or both?</p>
<p class="normal">In order to answer this question, you<a id="_idIndexMarker829"/> need to understand the threats to your data and systems. This process is <a id="_idIndexMarker830"/>referred to as <strong class="keyWord">threat modeling</strong>, and several books have been written on the topic. In this chapter, we’re going to build a very basic threat model for Kubernetes secrets based on where they are in the application’s deployment. We’ll start with secrets at rest.</p>
<h3 class="heading-3" id="_idParaDest-300">Threats to Secrets at Rest</h3>
<p class="normal">When a secret, such as a credential or a<a id="_idIndexMarker831"/> key, is in storage it is referred to being “at rest,” since data is not being moved. Nearly every compliance framework requires that secrets at rest be encrypted. This makes sense; why wouldn’t you encrypt your data at rest? In Kubernetes, you can configure <code class="inlineCode">etcd</code> to encrypt data at rest and you may think you’ve not only met a compliance requirement (often referred to as “checking the box”) but increased the security of your cluster! The truth is much more complicated.</p>
<p class="normal">Before we dive into how Kubernetes<a id="_idIndexMarker832"/> encrypts data at rest, let’s do a quick recap of how encryption works. All encryption involves three basic components:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Data</strong>: Either encrypted (cipher text) or decrypted (plain text).</li>
<li class="bulletList"><strong class="keyWord">Key</strong>:Used to encrypt your plain text to cipher text and to decrypt your cipher text to plain text.</li>
<li class="bulletList"><strong class="keyWord">Algorithm</strong>: Some process to combine the key and data to encrypt or decrypt it.</li>
</ul>
<p class="normal">Every encryption class or book will teach you that the key is always a secret while hiding the algorithm should never be relied upon for secrecy. This means that if an attacker knows you’re using AES-256, it really doesn’t matter because it’s the key that’s the secret.</p>
<p class="normal">What’s important here is that if you’re using encryption, you must have a key available to encrypt and decrypt the data. There is a great deal of nuance in how the different algorithms work, differences between block and stream ciphers, how keys are generated, etc. That nuance isn’t important to this discussion, no matter how fascinating it is. The fact that you need your key and data in the same place at the same time limits the security impact of encrypting data at rest because the security is only increased if the data and the key<a id="_idIndexMarker833"/> are separate.</p>
<p class="normal">With that sidebar in encryption completed, you might start to see the issue with encrypting data in Kubernetes’ database. Kubernetes does support encrypting data and we’re not going to cover it here because of the complexities, other than to describe it at a high level.</p>
<p class="normal">Kubernetes encryption works by configuring an <code class="inlineCode">EncryptionConfiguration</code> object that identifies what data is encrypted and with what keys. This object is accessible from the host running your API servers. Do you see the flaw with this? If someone has access to the cluster, they have the keys!</p>
<p class="normal">If your <code class="inlineCode">etcd</code> instances are run on different servers there’s some additional security, but does that benefit offset the risks involved when you need to decrypt and re-encrypt for key rotation? That’s a decision you need to make on your own.</p>
<p class="normal">Does encrypting your data at rest make your clusters less secure? Consider the “<strong class="keyWord">CIA triad</strong> of security” that’s most often used to describe the security requirements and impacts on a system. <strong class="keyWord">CIA</strong> stands for:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Confidentiality</strong>: Can we<a id="_idIndexMarker834"/> ensure we’re the only ones who have access to this data?</li>
<li class="bulletList"><strong class="keyWord">Integrity</strong>: How sure are we that the data hasn’t been tampered with?</li>
<li class="bulletList"><strong class="keyWord">Availability</strong>: Is the data available when we need it?</li>
</ul>
<p class="normal">Encrypting the data helps with the C+I portion of the CIA triad, assuming we can trust the keys (we’ll talk about that in a moment). If the key rotation requires downtime, or has a high risk of an outage, our “A” can be impacted.</p>
<div class="note">
<p class="normal">There’s an argument that encryption doesn’t provide data integrity assurances because encrypted data can be corrupted and <a id="_idIndexMarker835"/>you need signatures to validate data. <strong class="keyWord">Signatures</strong> are just a form of encryption with a private key that can be validated with a public key, so it’s all still encryption. If someone can tamper with encrypted data in a way that bypasses your keys, or using your keys, then the data can’t be trusted. This is why I include integrity as a benefit of encryption.</p>
</div>
<p class="normal">Speaking of the keys, maybe we don’t store the keys locally. Kubernetes does support external key management systems. We’ll dive into the details of how your cluster authenticates with a vault or <strong class="keyWord">KMS</strong> later in the chapter. For now, what’s important is that to make sure that generated authentication tokens are being given to the correct system, you need a local key to use for authenticating, leading to the same impact as having the decryption key local to your cluster: a local compromise means an attacker will have both the keys and the encrypted data at the same time and so can decrypt it.</p>
<p class="normal">So, you’ve gone through the process of encrypting data in your cluster and you’ve checked the box. Is your cluster <a id="_idIndexMarker836"/>secure? This is where security and compliance aren’t the same thing. If you’ve deployed this encrypted database onto a system with a single user account that’s shared across multiple users, you’ve created a new way to get attacked while thinking you’re secure! It’s important to note that most compliance frameworks still require some form of authorization management, but many vendors push this off to another system and often the answer is “we keep the keys in a vault,” creating a circular compliance issue. These complexities are what make securing Kubernetes and being compliant so difficult.</p>
<p class="normal">Having examined how we can approach encryption of Kubernetes’ data at rest, we’ll next explore threats to Kubernetes’ secrets in transit between systems.</p>
<h3 class="heading-3" id="_idParaDest-301">Threats to Secrets in Transit</h3>
<p class="normal">After spending time looking at the issues with encrypting data at rest you may think that the same issues apply to<a id="_idIndexMarker837"/> data in transit. The keys need to be in the same place as the data, so why bother?</p>
<p class="normal">It turns out this isn’t the case. Kubernetes and API driven certificate authorities like <strong class="keyWord">JetStack’s</strong> cert-manager make certificate<a id="_idIndexMarker838"/> management pretty much non-existent. We already deployed cert-manager in the authentication chapter with an internal certificate when we tested out pipeline authentication. We deployed cert-manager with a private key and a self-signed root certificate that is good for ten years. We trust that certificate throughout our cluster and configure our Ingress objects to use that internal CA to generate three-month certificates. A combination of NGINX and cert-manager make sure that we don’t ever think about renewing certificates.</p>
<p class="normal">For intracluster communications, you can use the same approach, or you can deploy a service mesh like Istio to generate certificates and provide TLS. We’ll dive into this later in the book.</p>
<p class="normal">From an availability standpoint, data in transit is much more ephemeral than data at rest. If there is a break in<a id="_idIndexMarker839"/> availability due to an expired certificate, there are technologies to perform retries that can be used to mitigate this risk.</p>
<p class="normal">The point is there’s no reason not to encrypt your data in transit. It’s true that the CA and private key are still in the cluster, so a compromised cluster leads to decryptable traffic, but the likelihood of availability going down due to key rotation is much reduced, making this a much easier decision.</p>
<p class="normal">If encrypting data in transit increases security, is it compliant? This is where we get the opposite of the “data at rest” scenario. From a technical perspective, a certificate authority is easy to build. Back before we had cert-manager or Kubernetes, I built a simple API-based CA for a customer that wanted to lock down APIs from a mobile app using Java and the <code class="inlineCode">openssl</code> command. Building a compliant CA is much harder. It often involves volumes of management and regulations. For this reason, while most large enterprises have an internal CA that could be used, you can’t use it from within Kubernetes. If your cluster doesn’t match all the rules of your CA, it invalidates the compliance of those rules and breaks your compliance.</p>
<p class="normal">The compromise that is often struck is for your ingress controller to have a wildcard certificate while an internal CA is used for communications within a cluster.</p>
<p class="normal">There is a strong argument that the increase in automation overcomes the introduced weakness of an in-cluster key for a CA, but as compliance is often a legal requirement those arguments generally fail. This is why it’s so important to understand the difference between security and compliance. In these two use cases we’ve shown how they conflict and why you need to understand those conflicts to make design choices.</p>
<p class="normal">Having walked through how to encrypt secret data in transit, the last scenario to explore is secrets when they’re used in your applications.</p>
<h3 class="heading-3" id="_idParaDest-302">Protecting Secrets in Your Applications</h3>
<p class="normal">Let’s walk through a potential, and all too <a id="_idIndexMarker840"/>common, scenario. You’ve built a “secure” cluster. Your secret data is all stored in a well-designed secrets manager. You’re following all the guidance on how to manage that data. Every connection is encrypted. Your application loads, gets a password, and connects to a database. It turns out that two years ago someone found a flaw in your parsing library that lets an attacker open a shell on your app and get access to that password and since you need to talk to that database they can connect and extract all the data!</p>
<p class="normal">What went wrong? Going back to<a id="_idIndexMarker841"/> the previous two scenarios, we established multiple times that you must have the secret in hand to use it. This means that if your application has a security flaw, it doesn’t matter how well designed your secrets management process is, it becomes the weakest link.</p>
<p class="normal">This doesn’t mean we should abandon secrets management. Supply chain security is its own focus and one we will cover later in this book. The point is that when you consider how to build your secrets management systems and processes, remember that your application is probably the easiest place to lose control and you must plan accordingly. For instance, adding additional layers that impact automation will not likely buy you additional security, but you may push your developers into spending time to work around your systems or drive up costs unnecessarily.</p>
<p class="normal">Now that we’ve walked through how secrets can be attacked, we can explore how secrets managers work and look at different strategies for managing secret data in your clusters.</p>
<h1 class="heading-1" id="_idParaDest-303">Understanding Secrets Managers</h1>
<p class="normal">We’ve covered what makes <code class="inlineCode">Secrets</code> special and how to approach secret data, now we need to talk about how to manage them. There are four ways <a id="_idIndexMarker842"/>most clusters manage <code class="inlineCode">Secrets</code>:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Kubernetes Secrets</strong>: Storing all <a id="_idIndexMarker843"/>secrets as <code class="inlineCode">Secret</code> objects without any kind of external management.</li>
<li class="bulletList"><strong class="keyWord">Sealed Secrets</strong>: Secret data is<a id="_idIndexMarker844"/> encrypted in files stored in Git.</li>
<li class="bulletList"><strong class="keyWord">External Secrets Manager</strong>: An <a id="_idIndexMarker845"/>external service, such as HashiCorp’s Vault or a cloud-based secrets manager, is used to store secrets for your cluster.</li>
<li class="bulletList"><strong class="keyWord">Hybrid</strong>: By syncing<a id="_idIndexMarker846"/> secret data from an external secrets manager into generic Kubernetes <code class="inlineCode">Secret</code> objects you get an approach that allows for the <code class="inlineCode">Secrets</code> API while still maintaining your source of truth about secret data outside of your cluster.</li>
</ul>
<p class="normal">Let’s walk through each approach to managing secrets.</p>
<h2 class="heading-2" id="_idParaDest-304">Storing Secrets as Secret Objects</h2>
<p class="normal">The first option seems like the easiest. Leveraging Kubernetes <code class="inlineCode">Secret</code> objects provides several benefits:</p>
<ul>
<li class="bulletList">There’s a standard API for accessing <code class="inlineCode">Secret</code> objects.</li>
<li class="bulletList">The API can be restricted via RBAC, mostly.</li>
<li class="bulletList">There are multiple<a id="_idIndexMarker847"/> ways for containers to access <code class="inlineCode">Secret</code> objects without having to make API calls.</li>
</ul>
<p class="normal">The last two points can be a double-edged sword. When Kubernetes was first created, one of the goals was to allow application <a id="_idIndexMarker848"/>developers to run a workload on Kubernetes without the application knowing anything about Kubernetes. This meant that having a standard <code class="inlineCode">Secret</code> API was less important than having an easy way for applications to access the secret data. To this end, Kubernetes made the easiest path to accessing secret data either mounting the secrets as virtual files in the container or setting them as environment variables. We’ll discuss the benefits and risks of both approaches later in this chapter. The impact of this design decision is that while you can limit who can access a <code class="inlineCode">Secret</code> via an API using RBAC, you can’t limit who can mount a <code class="inlineCode">Secret</code> into a pod within a <code class="inlineCode">Namespace</code>.</p>
<div class="note">
<p class="normal">This point been said previously in this book and will be repeated often. The <code class="inlineCode">Namespace</code> is the security boundary in Kubernetes. If you want to limit access to specific <code class="inlineCode">Secrets</code> within a <code class="inlineCode">Namespace</code>, it’s time to create a new <code class="inlineCode">Namespace</code>.</p>
</div>
<p class="normal">In April 2022, Mac Chaffee wrote a great blog post titled <em class="italic">Plain Kubernetes Secrets are fine</em> (<a href="https://www.macchaffee.com/blog/2022/k8s-secrets/"><span class="url">https://www.macchaffee.com/blog/2022/k8s-secrets/</span></a>) where he gave a great summary of why, from a security standpoint, it’s OK to use plain Kubernetes <code class="inlineCode">Secrets</code>. The blog post points out that you need to model the threats to your secret data before assuming a path forward for securing them. You may recognize many of the same arguments from this blog post in the previous section. Mac did a better job of articulating what I always thought to be true, and I really enjoyed his approach. The “too long, didn’t read” of the post is:</p>
<ul>
<li class="bulletList">Secret managers, like <strong class="keyWord">Vault</strong>, are rarely deployed in a way that adds any additional security over any other key/value database.</li>
<li class="bulletList">Encrypting secrets at rest doesn’t accomplish anything.</li>
<li class="bulletList">Your application is the most likely spot where you’ll lose a secret.</li>
</ul>
<p class="normal">If a Kubernetes <code class="inlineCode">Secret</code> is fine, why<a id="_idIndexMarker849"/> are we bothering with secrets managers at all? There are two reasons: compliance and <strong class="keyWord">GitOps</strong>.</p>
<p class="normal">From a compliance perspective, most <a id="_idIndexMarker850"/>compliance frameworks require that you not only know when secret data changes, but also when it’s used. For instance, <strong class="keyWord">NIST-800-53</strong> requires that you continuously monitor the usage of credentials (which makes up the bulk of <a id="_idIndexMarker851"/>secret data). While you could set up logging in Kubernetes to track this, it makes it much easier to audit by having it in a central location.</p>
<p class="normal">The next reason why we should evaluate a secrets <a id="_idIndexMarker852"/>manager is <strong class="keyWord">GitOps</strong>. In the last two chapters, we’re going to explore GitOps, a large part of which is storing our configuration in a Git repository. You should never, ever, EVER, <strong class="keyWord">EVER</strong>, <strong class="bold-italic" style="font-style: italic;">EVER</strong> store secret data in a Git repository either in plain text or as encrypted data. Git repositories are designed to be easily forked. Once forked, you’ve lost control of that repository. Going back to compliance, this is a big risk as you have no way of knowing if a developer forked your internal repository and accidentally pushed it to a public GitHub repository. There are other reasons why keeping secrets in Git should be considered an anti-pattern, but we’ll cover that when we talk about sealed secrets. Using a secrets manager allows us to externalize our secret data from our cluster, even though <code class="inlineCode">Secret</code> objects are most likely fine for most clusters.</p>
<p class="normal">Having looked at why regular Kubernetes <code class="inlineCode">Secrets</code> are usually fine from a security standpoint, let’s look at what sealed secrets are and why they’re an anti-pattern.</p>
<h3 class="heading-3" id="_idParaDest-305">Sealed Secrets</h3>
<p class="normal">If you are externalizing your Kubernets manifests<a id="_idIndexMarker853"/> into a Git repository, you may be tempted to store sensitive secret data there too. You don’t want anyone to get that data though, so you decide to encrypt it. Now, however, you need to decrypt it to get it back into your clusters. Bitnami (now owned by VMware) released <a id="_idIndexMarker854"/>a tool called <strong class="keyWord">Sealed Secrets</strong> (<a href="https://github.com/bitnami-labs/sealed-secrets"><span class="url">https://github.com/bitnami-labs/sealed-secrets</span></a>) that does just this. You install the operator into your cluster and when it sees a <code class="inlineCode">SealedSecret</code>, it decrypts it for you.</p>
<p class="normal">This seems like a simple and elegant solution for externalizing secret data securely. Unfortunately, its apparent simplicity is what leads to this solution being an anti-pattern.</p>
<p class="normal">The first issue with Sealed Secrets is that secret data is stored in Git. We pointed out in the previous section that this is a <a id="_idIndexMarker855"/>bad idea from a security perspective. One of the main goals of secrets management is being able to track the usage of secrets. It’s incredibly easy for a developer to push an internal repository to a public service like GitHub or GitLab. Take this simple command line:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">git remote set-url origin https://github.com/new-repository.git</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">git push</span>
</code></pre>
<p class="normal">So long as the user is signed into GitHub, your internal repo is now public! In theory you could limit access to public Git repositories, but that would probably be counterproductive. My general advice is never put something in Git that you wouldn’t want on GitHub. Once the code is on GitHub, or any other remote repository, you’ve lost all control.</p>
<p class="normal">Your first response to this issue of pushing to public repositories may be: “But it’s encrypted!” As a species, we’re bad<a id="_idIndexMarker856"/> at keeping secrets. As an industry, we’re very bad at protecting the keys used to encrypt secrets. If you’ve lost the repository, there’s a good chance you’ll also lose the keys.</p>
<blockquote class="packt_quote">
<p class="quote">Three may keep a secret, if two are dead – Benjamin Franklin</p>
</blockquote>
<p class="normal">This isn’t just true in the Kubernetes world, but really any technology. This is why it’s so important to plan for losing secrets and being able to quickly change them. If your Git repository with secrets, whether encrypted or not, were to be pushed outside of your enterprise, you’d want to:</p>
<ol>
<li class="numberedList" value="1">Go through all of the Sealed Secrets and generate new secret data (i.e. credentials).</li>
<li class="numberedList">Generate a new encryption key.</li>
<li class="numberedList">Re-encrypt and re-post all of the Sealed Secrets to Git.</li>
</ol>
<p class="normal">Depending on the size of your clusters and how well you manage your keys this could become a monumental task very quickly. It turns out a secret manager is pretty good at handling this failure mode.</p>
<p class="normal">In addition to being able to handle the failure mode of losing your repository, you need to account for losing the keys used to encrypt and decrypt your secrets. If you lose the key used to encrypt the secrets and lose the secrets…suffice it to say that you’re setting yourself up for a bad week, or what some call a <em class="italic">resume-building event</em>.</p>
<p class="normal">While Sealed Secrets appears to be a simple way to handle secrets management, they fail to account for failure in a <a id="_idIndexMarker857"/>way that would be acceptable in the aftermath of most breaches. While you wouldn’t want to store your secret data in Git, it is acceptable to store metadata about secrets in Git. We’ll see in the next section that secret managers can be integrated into your cluster using metadata that describes where to get secret data without having any secrets in the repository.</p>
<h3 class="heading-3" id="_idParaDest-306">External Secrets Managers</h3>
<p class="normal">In the last section we discussed <a id="_idIndexMarker858"/>why storing <code class="inlineCode">Secrets</code> in Git, whether encrypted or not, is an antipattern. We also discussed that you may want to externalize your secret data management to make compliance and <strong class="keyWord">GitOps</strong> easier. The most common approach to satisfying these requirements is a secrets manager.</p>
<p class="normal">Secrets managers are key/value databases that have some additional features not often found in generic key/value databases:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Authentication</strong>: Secrets managers can generally authenticate with multiple methods. The best solutions allow you to use either your Pod’s credentials directly or using a credential derived from it. This allows your secret manager to track which workloads are working with secret data and provide richer policies for managing access to that data.</li>
<li class="bulletList"><strong class="keyWord">Policies</strong>: Most secret managers provide a richer policy framework than generic databases. When combined with flexible authentication, options for the secrets manager can help lock down secrets to the workload while also tracking usage without an administrator getting involved with each onboarding.</li>
<li class="bulletList"><strong class="keyWord">Auditing</strong>: In addition to tracking changes, secrets managers track reads as well. This is a key compliance requirement.</li>
</ul>
<p class="normal">The authentication tools for secrets managers are important. It doesn’t really add much to your security or your compliance if you’re using a generic credential to access your secrets manager. Back in <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, we discussed how each pod gets a unique identity based on their <code class="inlineCode">ServiceAccount</code> and how that <code class="inlineCode">ServiceAccount</code> can be validated either by using the cluster’s OIDC discovery document or by submitting a <code class="inlineCode">TokenReview</code> to validate that the token is still valid. This token should be used when <a id="_idIndexMarker859"/>communicating with your secret manager. If you’re running on a cloud-managed Kubernetes, this can also be an identity supplied by your cloud. The point is, you’re using a local identity, not a static key. This local identity is what shows up in your audit logs, allowing your security team and auditors to know who is accessing secrets.</p>
<p class="normal">Finally, utilizing your <code class="inlineCode">Pod</code>'s identity to access your secrets manager makes onboarding and automation easier. We’ll look at multiple forms of multitenancy later in the book, which all have automation in common. Most secrets managers make it easier to design policies that allow for segmenting secrets access based on information in the authentication token, such as the <code class="inlineCode">namespace</code>. This means you don’t need to make API calls to your secrets manager whenever you onboard a new tenant.</p>
<p class="normal">There are several secrets managers available; every major cloud has its own offering and there are several open-source managers:</p>
<ul>
<li class="bulletList"><strong class="keyWord">HashiCorp Vault</strong>: <a href="https://github.com/hashicorp/vault"><span class="url">https://github.com/hashicorp/vault</span></a></li>
<li class="bulletList"><strong class="keyWord">CyberArk Conjur</strong>: <a href="https://github.com/cyberark/conjur"><span class="url">https://github.com/cyberark/conjur</span></a></li>
<li class="bulletList"><strong class="keyWord">VMware Tanzu Secrets Manager</strong>: <a href="https://github.com/vmware-tanzu/secrets-manager"><span class="url">https://github.com/vmware-tanzu/secrets-manager</span></a></li>
</ul>
<p class="normal">We don’t want you to have to sign up for a cloud service, so for the examples in this chapter (and whenever we need secrets for the rest of the book), we’ll use HashiCorp’s Vault.</p>
<div class="note">
<p class="normal">In August, 2023, HashiCorp announced a change of license for its projects, including <strong class="keyWord">Vault</strong>, from the <strong class="keyWord">Mozilla Public License</strong> (<strong class="keyWord">MPL</strong>) to the <strong class="keyWord">Business Source License </strong>(<strong class="keyWord">BUSL</strong>). While the BUSL is not an approved Open Source™ license from the Open Source Institute, it does allow for free use in both production and non-production environments. We decided to continue with Vault because even though the community around HashiCorp’s projects is making calls for forks or moves, enterprises have invested hundreds of thousands of dollars between software, people, and automation for Vault deployments. It’s still the most common secrets manager and likely will be for some time.</p>
</div>
<p class="normal">To deploy Vault, start with a fresh<a id="_idIndexMarker860"/> cluster and run the <code class="inlineCode">chapter8/vault/deploy_vault.sh</code> script:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter8/vault/</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">./deploy_vault.sh</span>
</code></pre>
<p class="normal">This script deploys vault into your cluster by:</p>
<ol>
<li class="numberedList" value="1">Deploying cert-manager with a self-signed CA for ingress certificates</li>
<li class="numberedList">Installing the <strong class="keyWord">Vault Helm chart</strong></li>
<li class="numberedList">Deploying Vault into the cluster with the UI and with <code class="inlineCode">ClusterIP</code> <code class="inlineCode">Service</code> objects</li>
<li class="numberedList">Retrieving the keys used to unseal the Vault database</li>
<li class="numberedList">Unsealing the Vault database</li>
<li class="numberedList">Deploying <code class="inlineCode">Ingress</code> objects you can access the UI and web services via NGINX</li>
</ol>
<p class="normal">Vault encrypts its data, so when you start the pod you need to “unseal” it so it can be managed. You can log in to your Vault instance by first retrieving the token from the <code class="inlineCode">~/unseal-keys.json</code> file generated by the deployment:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">jq -r </span><span class="hljs-con-string">'.root_token'</span><span class="language-bash"> &lt; ~/unseal-keys.json</span>
hvs.OFotf6LlPTI1bRhqNDMyYf7N
</code></pre>
<p class="normal">Next, use this token to log in to Vault by going to <a href="https://vault.apps.IP.nip.io"><span class="url">https://vault.apps.IP.nip.io</span></a>, where <code class="inlineCode">IP</code> is the IP address of your Kubernetes cluster with dashes instead of dots. For instance, our cluster is at <code class="inlineCode">192.168.2.82</code> so our Vault URL is <a href="https://vault.apps.192-168-2-82.nip.io/"><span class="url">https://vault.apps.192-168-2-82.nip.io/</span></a>.</p>
<p class="normal">We’re not going to dig too deeply into how Vault is configured outside of specific examples to illustrate how to integrate an external secrets manager into your cluster. If you want to go through all its options, the documentation is available online at <a href="https://developer.hashicorp.com/vault/docs"><span class="url">https://developer.hashicorp.com/vault/docs</span></a>. It’s also important to point out that this isn’t a production-capable deployment either, since it’s not highly available nor are there any processes built around starting and managing onboarding.</p>
<p class="normal">With our Vault deployed, the next step is to integrate Vault into our cluster. Earlier, we discussed that it’s important to use the <code class="inlineCode">Pod</code>'s identity to interact with your secrets manager. We’ll do that with Vault by configuring Vault to submit a <code class="inlineCode">TokenReview</code> to our cluster to validate that the token was issued by our cluster and that the pod that the identity is tied to is still running:</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" height="223" src="../Images/B21165_08_01.png" width="728"/></figure>
<p class="packt_figref">Figure 8.1: Vault integration with Kubernetes</p>
<p class="normal">The above diagram shows<a id="_idIndexMarker861"/> the flow:</p>
<ol>
<li class="numberedList" value="1">A pod makes a request to the Vault API using its <code class="inlineCode">ServiceAccount</code> token projected via the <code class="inlineCode">TokenRequest</code> API</li>
<li class="numberedList">Vault submits a <code class="inlineCode">TokenReview</code> request to the API server with the <code class="inlineCode">Pod's</code> token</li>
<li class="numberedList">The API server validates whether the token is still valid or not.</li>
</ol>
<p class="normal">Using the above process gives us the ability to validate a <code class="inlineCode">Pod's</code> token, getting confidence that the pod it’s assigned to is still valid. If an attacker were to exfiltrate a Pod’s token and attempt to use it after the Pod’s been destroyed, then <code class="inlineCode">TokenReview</code> will be rejected.</p>
<div class="note">
<p class="normal">In addition to using the <code class="inlineCode">TokenReview</code> API, Vault can be configured to use OIDC to validate tokens without a callback to the API server. We aren’t going down this route because we want Vault to validate that the pod associated with the token is still valid.</p>
</div>
<p class="normal">To integrate our Vault into our cluster, run <code class="inlineCode">chapter8/vault/vault_integrate_cluster.sh</code>:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter8/vault/</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">./vault_integrate_cluster.sh</span>
</code></pre>
<p class="normal">This script will integrate your Vault deployment with the KinD cluster by:</p>
<ol>
<li class="numberedList" value="1">Creating the <code class="inlineCode">vault-integration</code> <code class="inlineCode">namespace</code> and the <code class="inlineCode">vault-client ServiceAccount</code></li>
<li class="numberedList">Creating a <code class="inlineCode">ClusterRoleBinding</code> for the <code class="inlineCode">vault-client ServiceAccount</code> to the <code class="inlineCode">system:auth-delegator ClusterRole</code></li>
<li class="numberedList">Creating a token for the vault-client <code class="inlineCode">ServiceAccount</code> that’s good for about a year</li>
<li class="numberedList">Creating an <code class="inlineCode">Ingress</code> for our API server so that Vault can communicate with it</li>
<li class="numberedList">Creating a Vault Kubernetes authentication configuration with our cluster</li>
</ol>
<p class="normal">The Vault deployment is being treated as a stand-alone deployment, even though it’s running on our cluster because <a id="_idIndexMarker862"/>Vault is often run this way in enterprise deployments. Vault is a complex system that requires highly specialized knowledge to run, so it’s much easier to centralize Vault knowledge into a centralized team.</p>
<p class="normal">You might also notice that we’re creating a token for Vault to use to interact with your cluster that’s good for a year. This violates our goal of using short-lived tokens. This is a chicken-and-egg problem, because Vault needs to authenticate to Kubernetes in order to validate the token. The cluster could be configured to allow anonymous <code class="inlineCode">TokenReview</code> access, which would leave it opened to potential escalation attacks.</p>
<p class="normal">It would be great if Vault supported using its own OIDC tokens to talk to Kubernetes like a workload we defined in <em class="chapterRef">Chapter 6</em>, <em class="italic">Integrating Authentication into Your Cluster</em>, but that’s not a capability at this time.</p>
<p class="normal">We’ve covered what makes an external secrets manager different than other key/value stores and deployed HashiCorp’s vault. Vault’s been deployed and integrated into the cluster. You now have a foundation for working with externalized secrets and exploring the different ways to integrate that foundation into your cluster. Next, we’ll cover a hybrid approach between using an external secrets manager and native Kubernetes <code class="inlineCode">Secrets</code>.</p>
<h3 class="heading-3" id="_idParaDest-307">Using a Hybrid of External Secrets Management and Secret Objects</h3>
<p class="normal">So far, we have covered the<a id="_idIndexMarker863"/> use of generic Kubernetes <code class="inlineCode">Secret</code> objects, the antipattern of storing secret data in encrypted files in git, and finally using an external secrets manager. Since we’ve already established that plain Kubernetes <code class="inlineCode">Secrets</code> are likely not a substantial risk based on our threat model, but we prefer to externalize secrets into a tool like Vault, it would be great if we could use the Kubernetes <code class="inlineCode">Secrets</code> API to access secret data in external vaults.</p>
<p class="normal">The use of the <code class="inlineCode">Secret</code> API to access external secret data is unlikely to ever happen. However, we can synchronize secret data from our Vault into Kubernetes <code class="inlineCode">Secret</code> objects. This hybrid approach <a id="_idIndexMarker864"/> allows us to get the best of both approaches:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Centralized secret data</strong>: The source of truth for our secret data is our vault. The data in the <code class="inlineCode">Secret</code> object is a replica of that data.</li>
<li class="bulletList"><strong class="keyWord">Metadata can be stored in git</strong>: The metadata that’s used to describe where the secret data is stored is not itself secret. It can be stored in Git without the same adverse consequences of storing the actual secrets in Git.</li>
<li class="bulletList"><strong class="keyWord">Audit Data</strong>: The access audit logs can be configured in both the API server’s access logs and the vault’s access logs.</li>
</ul>
<p class="normal">There are multiple projects that support synchronizing secrets from a vault into Kubernetes. The two that come up the most are:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Kubernetes Secret Store CSI Driver</strong> <a href="https://secrets-store-csi-driver.sigs.k8s.io/introduction">(<span class="url">https://secrets-store-csi-driver.sigs.k8s.io/introduction</span></a>): The Secret Store CSI driver is a <strong class="keyWord">special interest group </strong>(<strong class="keyWord">SIG</strong>) in the <a id="_idIndexMarker865"/>Kubernetes project provides a storage driver for accessing secret stores such as Vault. It includes a synchronization engine that will generate generic <code class="inlineCode">Secret</code> objects. The main challenge of using this project is that before you can synchronize from a vault into a <code class="inlineCode">Secret</code>, you need to mount it a pod.</li>
<li class="bulletList"><strong class="keyWord">External Secrets Operator</strong> (<a href="https://external-secrets.io/latest/"><span class="url">https://external-secrets.io/latest/</span></a>): The External Secrets<a id="_idIndexMarker866"/> Operator project provides a direct synchronization of secret data into <code class="inlineCode">Secret</code> objects.</li>
</ul>
<p class="normal">This section will focus on using the <strong class="keyWord">External Secrets Operator</strong> project. We chose to use External Secrets Operator because it doesn’t require a pod to first mount the secret data before synchronizing it into a <code class="inlineCode">Secret</code>. First, deploy the synchronization operator:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter8/external-secrets</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">./install_external_secrets.sh</span>
</code></pre>
<p class="normal">The above script does several things:</p>
<ul>
<li class="bulletList">Deploys <strong class="keyWord">External Secrets Operator</strong></li>
<li class="bulletList">Creates a <code class="inlineCode">Namespace</code> to store the synchronized Secret object</li>
<li class="bulletList">Creates a <code class="inlineCode">ServiceAccount</code> to access Vault</li>
<li class="bulletList">Creates a secret password in Vault</li>
<li class="bulletList">Creates a policy in Vault to access the secret with the above <code class="inlineCode">ServiceAccount</code></li>
<li class="bulletList">Creates a <code class="inlineCode">ExternalSecret</code> object to tell the operator where and how to synchronize our secret data into our cluster</li>
</ul>
<p class="normal">There’s quite a bit going on<a id="_idIndexMarker867"/> here. The operator itself is deployed via a Helm chart. The <code class="inlineCode">namespace</code> where we keep the <code class="inlineCode">Secret</code> and its associated <code class="inlineCode">ServiceAccount</code> builds off of our Vault integration to allow pods to use a specific identity instead of using a static <code class="inlineCode">ServiceAccount's</code> token. After creating the <code class="inlineCode">Namespace</code> and <code class="inlineCode">ServiceAccount</code>, a Vault policy is created to allow the <code class="inlineCode">ServiceAccount</code> to read the secret data. Finally, a <code class="inlineCode">SecretStore</code> and <code class="inlineCode">ExternalSecret</code> object is created to tell the operator how to synchronize the secret data. Let’s take a look at these objects. First, we created the <code class="inlineCode">SecretStore</code> to tell the operator where the Vault is and how to access it:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">external-secrets.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">SecretStore</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">vault-backend</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ext-secret</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">provider:</span>
    <span class="hljs-attr">vault:</span>
      <span class="hljs-attr">server:</span> <span class="hljs-string">"https://vault.apps.192-168-2-82.nip.io"</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">"secret"</span>
      <span class="hljs-attr">version:</span> <span class="hljs-string">"v1"</span>
      <span class="hljs-attr">caProvider:</span>
        <span class="hljs-attr">type:</span> <span class="hljs-string">"ConfigMap"</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">"cacerts"</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">"tls.crt"</span>
        <span class="hljs-attr">namespace:</span> <span class="hljs-string">"my-ext-secret"</span>
      <span class="hljs-attr">auth:</span>
          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"kubernetes"</span>
          <span class="hljs-attr">serviceAccountRef:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">"ext-secret-vault"</span>
</code></pre>
<p class="normal">The first object, <code class="inlineCode">SecretStore</code>, tells <strong class="keyWord">External Secrets Operator</strong> where the secrets are stored and how to access them. In this case, we’re <a id="_idIndexMarker868"/>connecting to Vault using the URL <code class="inlineCode">https://vault.apps.192-168-2-82.nip.io</code> using the certificate stored in the <code class="inlineCode">cacerts</code> <code class="inlineCode">ConfigMap</code> to trust for TLS. The <code class="inlineCode">auth</code> section tells the operator how to authenticate, using a token for the <code class="inlineCode">ServiceAccount ext-secret-vault</code>. With the <code class="inlineCode">SecretStore</code> defined, the next step is to begin defining what <code class="inlineCode">Secret</code> objects need to be created.</p>
<p class="normal">In order to synchronize <a id="_idIndexMarker869"/>secret data into <code class="inlineCode">Secret</code> objects, there needs to be an <code class="inlineCode">ExternalSecret</code> object:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">external-secrets.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ExternalSecret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-external-secret</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ext-secret</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">refreshInterval:</span> <span class="hljs-string">1m</span>
  <span class="hljs-attr">secretStoreRef:</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">SecretStore</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">vault-backend</span>
  <span class="hljs-attr">target:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">secret-to-be-created</span>
    <span class="hljs-attr">creationPolicy:</span> <span class="hljs-string">Owner</span>
  <span class="hljs-attr">data:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">secretKey:</span> <span class="hljs-string">somepassword</span>
      <span class="hljs-attr">remoteRef:</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">/data/extsecret/config</span>
        <span class="hljs-attr">property:</span> <span class="hljs-string">some-password</span>
</code></pre>
<p class="normal">The <code class="inlineCode">ExternalSecret</code> object defines how to synchronize data from your vault into your cluster. Here, the data is being pulled from the <code class="inlineCode">SecretStore</code> that was created to communicate with the Vault deployment. This object tells <strong class="keyWord">External Secrets Operator</strong> to create the <code class="inlineCode">somepassword</code> key on the <code class="inlineCode">Secret secret-to-be-created</code> from the <code class="inlineCode">/data/extsecret/config</code> object in Vault, getting the value from the <code class="inlineCode">some-password</code> property.</p>
<p class="normal">To give some context, here’s the Vault configuration from the script:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">vault</span> <span class="hljs-string">kv</span> <span class="hljs-string">put</span> <span class="hljs-string">secret/data/extsecret/config</span> <span class="hljs-string">some-password=mysupersecretp@ssw0rd</span>
</code></pre>
<p class="normal">Once the synchronization process runs, we see that there’s now data from Vault in our <code class="inlineCode">Secret</code>:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">kubectl get secret secret-to-be-created -n my-ext-secret -o json | jq -r </span><span class="hljs-con-string">'.data.somepassword'</span><span class="language-bash"> | </span><span class="hljs-con-built_in">base64</span><span class="language-bash"> -d</span>
mysupersecretp@ssw0rd
</code></pre>
<p class="normal">Given the approach<a id="_idIndexMarker870"/> provided by the <strong class="keyWord">External Secrets Operator</strong> project, metadata for where and how to access <a id="_idIndexMarker871"/>secret data can be created and stored in a git repository without adverse security impacts. Clusters are able to access secrets using the well-defined <code class="inlineCode">Secrets</code> API while still getting the benefits of externalizing their secret data.</p>
<p class="normal">In the next section, we’re going to take the secret data that is now available in our cluster and look at how to consume that data from workloads.</p>
<h1 class="heading-1" id="_idParaDest-308">Integrating Secrets into Your Deployments</h1>
<p class="normal">So far, this chapter has been<a id="_idIndexMarker872"/> focused on how to store and manage secret data. We’ve covered different strategies for managing secrets with their associated risks and benefits. In this section, the focus will be on consuming that secret data in your workloads.</p>
<p class="normal">There are four ways that a workload can consume secret data:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Volume mounts</strong>: Similar to reading a file from a <code class="inlineCode">PersistentVolumeClaim</code>, secrets can be mounted to a pod and be accessed as a file. This approach can be used with both<a id="_idIndexMarker873"/> external secrets and with <code class="inlineCode">Secret</code> objects. This is generally the preferred approach when working with security teams. If a <code class="inlineCode">Secret</code> is updated while a pod is running, the volume will eventually get updated, though this can take some time based on your Kubernetes distribution.</li>
<li class="bulletList"><strong class="keyWord">Environment variables</strong>: Secret data can be injected into environment variables and consumed from the workload like any other environment variable. This is often referred to as “insecure” since it’s a common practice for application developers to dump environment variables for debugging purposes. It’s not an uncommon occurrence for debugging components to be accidently kept in production that are leaking environment variables. It’s better to avoid this approach if possible. It’s important to note that if a <code class="inlineCode">Secret</code> is updated while a pod is running, the environment variable in the running pod is not updated.</li>
<li class="bulletList"><strong class="keyWord">Secrets API</strong>: Kubernetes is an API and <code class="inlineCode">Secrets</code> can be accessed directly via the <code class="inlineCode">Secret</code> API. This approach provides more flexibility than either environment variables or volume mounts, but requires knowledge of how to call the API. If you need to be able to dynamically retrieve <code class="inlineCode">Secrets</code>, this is a good approach but is probably overkill for most applications.</li>
<li class="bulletList"><strong class="keyWord">Vault API</strong>: Every <a id="_idIndexMarker874"/>external vault provides an API. While we’re using tools like <strong class="keyWord">External Secrets Operator</strong> or a sidecar to interact with these APIs, there’s nothing stopping a developer from calling these APIs on <a id="_idIndexMarker875"/>their own. It would cut down on the external configuration, but at the cost of tightly binding your system to a particular project or vendor.</li>
</ul>
<p class="normal">Next, we’re going to walk through these options to see how they’re implemented.</p>
<h2 class="heading-2" id="_idParaDest-309">Volume Mounts</h2>
<p class="normal">The preferred way to add <code class="inlineCode">Secrets</code> to your workloads is to treat them as files and load them into your application. This<a id="_idIndexMarker876"/> approach has multiple advantages <a id="_idIndexMarker877"/>over the other approaches listed above:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Less likely to be leaked during debugging</strong>: There’s nothing that stops a developer from printing the contents of a file to the logs or an output stream, but a call to the <code class="inlineCode">env</code> command won’t automatically print out secret data.</li>
<li class="bulletList"><strong class="keyWord">Can be updated</strong>: When a file is updated, that update is reflected in your pod. The same is true for secret data that is mounted via a volume. If the application in your pod knows to look for updates, it will eventually get them.</li>
<li class="bulletList"><strong class="keyWord">Richer options</strong>: A configuration file mounted onto a volume can be more than name/value pairs. It can be full configuration files, simplifying management.</li>
</ul>
<p class="normal">Mounting a secret as a volume has been a feature of Kubernetes since <code class="inlineCode">Secrets</code> were available. In this section we’ll walk through mounting both generic Kubernetes <code class="inlineCode">Secret</code> objects and interacting with our<a id="_idIndexMarker878"/> Vault deployment directly using the <strong class="keyWord">Vault Sidecar</strong>.</p>
<h3 class="heading-3" id="_idParaDest-310">Using Kubernetes Secrets</h3>
<p class="normal">Mounting a Kubernetes <code class="inlineCode">Secret</code> as a<a id="_idIndexMarker879"/> volume into your pods is a matter of naming the <code class="inlineCode">Secret</code> in your spec. For instance, if you created the pod from <code class="inlineCode">chapter8/integration/volumes/volume-secrets.yaml</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">test-volume</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-volume-secrets</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ext-secret</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>
    <span class="hljs-attr">resources:</span> {}
    <span class="hljs-attr">command:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">sh</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">'cat /etc/secrets/somepassword'</span>
    <span class="hljs-attr">volumeMounts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mypassword</span>
      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/secrets</span>
  <span class="hljs-attr">volumes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mypassword</span>
    <span class="hljs-attr">secret:</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">secret-to-be-created</span>
  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span>
  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span>
</code></pre>
<p class="normal">It will generate the following log:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">kubectl logs test-volume-secrets -n my-ext-secret</span>
myN3wP@ssw0rd
</code></pre>
<p class="normal">This pod added the <code class="inlineCode">Secret</code> we synchronized from Vault directly to our pod. We can update that secret in Vault and see<a id="_idIndexMarker880"/> what happens to the mounted value in a longer-running pod. First, create the pod in <code class="inlineCode">chapter8/integration/volumes/volume-secrets-watch.yaml</code>:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter8/integration/volumes</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl create -f ./volume-secrets-watch.yaml</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl logs -f test-volumes-secrets-watch -n my-ext-secret</span>
Fri Sep 15 14:52:45 UTC 2023
myN3wP@ssw0rd
----------
Fri Sep 15 14:52:46 UTC 2023
myN3wP@ssw0rd
----------
Fri Sep 15 14:52:47 UTC 2023
myN3wP@ssw0rd
----------
</code></pre>
<p class="normal">Now that we’re watching our mounted volume, let’s update the secret in Vault:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">. ../../vault/vault_cli.sh</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">vault kv put secret/data/extsecret/config some-password=An0therPassw0rd</span>
Success! Data written to: secret/data/extsecret/config
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl get secret secret-to-be-created -n my-ext-secret -o json | jq -r </span><span class="hljs-con-string">'.data.somepassword'</span><span class="language-bash"> | </span><span class="hljs-con-built_in">base64</span><span class="language-bash"> -d</span>
An0therPassw0rd
</code></pre>
<p class="normal">It may take a minute or two, but the <code class="inlineCode">Secret</code> in our cluster gets synchronized. Next, let’s look at our running pod:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">kubectl logs -f test-volumes-secrets-watch -n my-ext-secret</span>
Fri Sep 15 14:52:45 UTC 2023
myN3wP@ssw0rd
----------
.
.
.
Fri Sep 15 14:56:33 UTC 2023
An0therPassw0rd
----------
Fri Sep 15 14:56:34 UTC 2023
An0therPassw0rd
----------
Fri Sep 15 14:56:35 UTC 2023
An0therPassw0rd
----------
</code></pre>
<p class="normal">We can see that the volume did get updated. So, if we do have a long running pod, we can watch mounted volumes to look for updates.</p>
<p class="normal">In this section, we<a id="_idIndexMarker881"/> integrated a <code class="inlineCode">Secret</code> directly into our pod. When using an external secrets vault, such as HashiCorp’s Vault, this requires synchronizing the <code class="inlineCode">Secret</code> using a tool like <strong class="keyWord">External Secrets Operator</strong>. Next, we’ll create a volume directly from Vault using Vault’s injector sidecar.</p>
<h3 class="heading-3" id="_idParaDest-311">Using Vault’s Sidecar Injector</h3>
<p class="normal">In the previous section, we integrated <a id="_idIndexMarker882"/>a generic Kubernetes <code class="inlineCode">Secret</code> into our pod. In this section, we’ll integrate directly with Vault using its injector <strong class="keyWord">sidecar</strong>.</p>
<div class="packt_tip">
<p class="normal">A <strong class="keyWord">sidecar</strong> is a special container that runs along with your primary workload to perform additional functions transparently<a id="_idIndexMarker883"/> and independently of your main workload. The sidecar pattern allows you to create containers that intercept network traffic, manage logs, or in the case of Vault, inject secrets. Starting in 1.28, sidecars moved from being a well-known pattern to becoming a first-class configuration option. This approach is still very new and has not yet been adopted by most implementations. You can learn more about the changes to sidecars in the Kubernetes blog at <a href="https://kubernetes.io/blog/2023/08/25/native-sidecar-containers/"><span class="url">https://kubernetes.io/blog/2023/08/25/native-sidecar-containers/</span></a>.</p>
</div>
<p class="normal">Vault’s <strong class="keyWord">sidecar injector</strong> has two primary<a id="_idIndexMarker884"/> components that let us inject secret data into our pods:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Injector Mutating Admission Controller</strong>: We’ll cover admission controllers in more detail in <em class="chapterRef">Chapter 11</em>, <em class="italic">Extending Security Using Open Policy Agent</em>. For now, what you need to know about this controller is that it looks for pods to be created with specific <code class="inlineCode">annotations</code> to configure the sidecar that interacts with the Vault service.</li>
<li class="bulletList"><strong class="keyWord">Sidecar</strong>: The sidecar does the work of interacting with our Vault deployment. You don’t need to configure the sidecar manually, the admission controller mutator will do that for you based on <code class="inlineCode">annotations</code>.</li>
</ul>
<p class="normal">First, let’s look at our pod that is getting secret data directly from Vault:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">watch-vault-volume</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-vault-vault-watch</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ext-secret</span>
  <span class="hljs-attr">annotations:</span>     <span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/agent-inject:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"true"</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/service:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"https://vault.apps.192-168-2-82.nip.io"</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/log-level:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">trace</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/role:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">extsecret</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/tls-skip-verify:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"true"</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/agent-inject-secret-myenv:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'secret/data/extsecret/config'</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/secret-volume-path-myenv:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'/etc/secrets'</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">vault.hashicorp.com/agent-inject-template-myenv:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">|</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          {{</strong><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">with</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">secret</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"secret/data/extsecret/config"</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">-</strong><strong class="hljs-slc">}}</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          </strong><strong class="hljs-string-slc">MY_SECRET_PASSWORD="{{</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">index</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">.Data</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"some-password"</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">}}"</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          {{</strong><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">end</strong><strong class="hljs-slc"> }}</strong></span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">ubuntu:22.04</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>
    <span class="hljs-attr">resources:</span> {}
    <span class="hljs-attr">command:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">bash</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">'while [[ 1 == 1 ]]; do date &amp;&amp; cat /etc/secrets/myenv &amp;&amp; echo "" &amp;&amp; echo "----------" &amp;&amp; sleep 1; done'</span>
  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span>
  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">serviceAccountName:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">ext-secret-vault</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">serviceAccount:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">ext-secret-vault</strong></span>
</code></pre>
<p class="normal">Let’s focus on the <a id="_idIndexMarker885"/>Vault connection<a id="_idIndexMarker886"/> options:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">vault.hashicorp.com/agent-inject:</span> <span class="hljs-string">"true"</span>
<span class="hljs-attr">vault.hashicorp.com/service:</span> <span class="hljs-string">"https://vault.apps.192-168-2-82.nip.io"</span> <span class="hljs-attr">vault.hashicorp.com/log-level:</span> <span class="hljs-string">trace</span>
<span class="hljs-attr">vault.hashicorp.com/role:</span> <span class="hljs-string">extsecret</span>
<span class="hljs-attr">vault.hashicorp.com/tls-skip-verify:</span> <span class="hljs-string">"true"</span>
</code></pre>
<p class="normal">The first <code class="inlineCode">annotation</code> tells the admission controller that we want to generate the sidecar configuration for this pod. The next <code class="inlineCode">annotation</code> tells Vault where the Vault service is. We then enable detailed<a id="_idIndexMarker887"/> logging and then set the role for <a id="_idIndexMarker888"/>authentication. This role in Vault was created in <code class="inlineCode">chapter8/external-secrets/install_external_secrets.sh</code> with the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">vault</span> <span class="hljs-string">write</span> <span class="hljs-string">auth/kubernetes/role/extsecret</span> <span class="hljs-string">\</span>
     <span class="hljs-string">bound_service_account_names=ext-secret-vault</span> <span class="hljs-string">\</span>
     <span class="hljs-string">bound_service_account_namespaces=my-ext-secret</span> <span class="hljs-string">\</span>
     <span class="hljs-string">policies=extsecret</span> <span class="hljs-string">\</span>
     <span class="hljs-string">ttl=24h</span>
</code></pre>
<p class="normal">The role maps our <code class="inlineCode">ServiceAccount</code> to an allowed policy. Finally, we tell the agent to skip TLS verification. In a production deployment, you don’t want to skip TLS verification. We could mount our CA certificate, and that’s what you’ll want to do in production.</p>
<p class="normal">Notice, we didn’t specify a key or a <code class="inlineCode">Secret</code> for authentication. That’s because we’re using our <code class="inlineCode">Pod's</code> own identity. The <code class="inlineCode">serviceAccount</code> and <code class="inlineCode">serviceAccountName</code> options on the pod dictate which identity is used. When we configured external secrets, we use the <code class="inlineCode">ext-secret-vault ServiceAccount</code>, so we reused that identity here.</p>
<p class="normal">Having defined how we talk to Vault, next let’s look at how we define our data:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">vault.hashicorp.com/agent-inject-secret-myenv:</span> <span class="hljs-string">'secret/data/extsecret/config'</span>
<span class="hljs-attr">vault.hashicorp.com/secret-volume-path-myenv:</span> <span class="hljs-string">'/etc/secrets'</span>
<span class="hljs-attr">vault.hashicorp.com/agent-inject-template-myenv:</span> <span class="hljs-string">|</span>
  {{<span class="hljs-bullet">-</span> <span class="hljs-string">with</span> <span class="hljs-string">secret</span> <span class="hljs-string">"secret/data/extsecret/config"</span> <span class="hljs-string">-</span>}}
  <span class="hljs-string">MY_SECRET_PASSWORD="{{</span> <span class="hljs-string">index</span> <span class="hljs-string">.Data</span> <span class="hljs-string">"some-password"</span> <span class="hljs-string">}}"</span>
  {{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
</code></pre>
<p class="normal">The first annotation says, “Create a configuration called <code class="inlineCode">myenv</code> that points to the Vault object <code class="inlineCode">/secret/data/extsecret/config</code>.” <code class="inlineCode">myenv</code> is like a variable that allows you to track configuration options across multiple <code class="inlineCode">annotations</code>. The next <code class="inlineCode">annotation</code> says that we want to place everything into the <code class="inlineCode">/etc/secrets/myenv</code> file. If we didn’t specify this annotation, the sidecar would have put the resulting <code class="inlineCode">myenv</code> file in the <code class="inlineCode">/vault/secrets</code> directory.</p>
<p class="normal">The final <code class="inlineCode">annotation</code> creates the content of the <code class="inlineCode">myenv</code> file. If the syntax looks like Helm, that’s because it uses the same<a id="_idIndexMarker889"/> template engine. Here, we’re creating a file with a name/value pair. This can be a configuration file template too.</p>
<p class="normal">Now that we’ve walked <a id="_idIndexMarker890"/>through the configuration, let’s create the object:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter8/integration/volumes</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">./create-vault.sh</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl logs -f test-vault-vault-watch -n my-ext-secret</span>
Defaulted container "test" out of: test, vault-agent, vault-agent-init (init)
Fri Sep 15 18:24:09 UTC 2023
MY_SECRET_PASSWORD="An0therPassw0rd"
----------
Fri Sep 15 18:24:10 UTC 2023
MY_SECRET_PASSWORD="An0therPassw0rd"
</code></pre>
<p class="normal">Our original workload is unaware of Vault, but is able to retrieve the secret data from the generated template. There are scenarios where Vault will refresh the template, but they’re Vault-specific configuration options that we’re not going to dive into.</p>
<p class="normal">The annotation-based injection of sidecars is a common pattern amongst secrets management integrations with Kubernetes. If you’re looking to integrate other external secrets management systems, this is a consistent approach to use.</p>
<p class="normal">We’ve looked at how to use volumes to bind secrets to workloads using both standard Kubernetes <code class="inlineCode">Secret</code> objects and our external Vault. Both approaches allow you to externalize your secrets. Next, we’ll look at how to inject secret data as environment variables.</p>
<h2 class="heading-2" id="_idParaDest-312">Environment Variables</h2>
<p class="normal">Using environment variables is the easiest way to consume any data. Every language and platform has a standard<a id="_idIndexMarker891"/> way to access an <a id="_idIndexMarker892"/>environment variable. The downside to this ease of access is that it’s common for developers to print out or dump all their environment variables for debugging. This means that the data could end up in a log, or even worse a debugging webpage that prints out environment variables. This mechanism will often be flagged by security teams, so it should be avoided if possible. That said, some workloads require<a id="_idIndexMarker893"/> environment variables, so let’s look at how to integrate both plain Kubernetes <code class="inlineCode">Secrets</code> and secrets from our external Vault into a pod.</p>
<h3 class="heading-3" id="_idParaDest-313">Using Kubernetes Secrets</h3>
<p class="normal">Kubernetes can plug a <code class="inlineCode">Secret</code> object’s data<a id="_idIndexMarker894"/> directly into an environment variable inside of the <code class="inlineCode">Pod</code> definition of the container. Here’s a simple example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">test</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-envvars-secrets</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ext-secret</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>
    <span class="hljs-attr">resources:</span> {}
    <span class="hljs-attr">command:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">env</span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-attr-slc">env:</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-attr-slc">name:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">MY_SECRET_PASSWORD</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">valueFrom:</strong></span>
<span class="code-highlight"><strong class="hljs-slc">        </strong><strong class="hljs-attr-slc">secretKeyRef:</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          </strong><strong class="hljs-attr-slc">name:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">secret-to-be-created</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          </strong><strong class="hljs-attr-slc">key:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">somepassword</strong></span>
  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span>
  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span>
</code></pre>
<p class="normal">Looking at <code class="inlineCode">.spec.containers[name=test].env</code>, you can see that we create an environment variable from an existing <code class="inlineCode">Secret</code>. The command of this container is simply the <code class="inlineCode">env</code> command, which prints out all the environment variables. To see this container in action, apply the YAML from the <code class="inlineCode">chapter8/integration/envvars/envars-secrets.yaml</code>:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter8/integration/envvars</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl create -f ./envars-secrets.yaml</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl logs -f -l run=</span><span class="hljs-con-built_in">test</span><span class="language-bash"> -n my-ext-secret</span>
<span class="code-highlight"><strong class="hljs-slc">MY_SECRET_PASSWORD=An0therPassw0rd</strong></span>
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_PROTO=tcp
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
HOME=/root
</code></pre>
<p class="normal">What happens if we update our <code class="inlineCode">Secret</code>? Kubernetes won’t update the environment variable. Let’s verify this point. First, create<a id="_idIndexMarker895"/> a pod that watches our environment variables:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span><span class="language-bash"> chapter8/integration/envvars</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl create -f ./envars-secrets-watch.yaml</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl logs -f -l run=watch-env -n my-ext-secret</span>
Fri Sep 15 12:43:30 UTC 2023
MY_SECRET_PASSWORD=An0therPassw0rd
Fri Sep 15 12:43:31 UTC 2023
MY_SECRET_PASSWORD=An0therPassw0rd
</code></pre>
<p class="normal">This pod will continuously echo the environment variable we created. Next, let’s update Vault:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">. ../../vault/vault_cli.sh</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">vault kv put secret/data/extsecret/config some-password=myN3wP@ssw0rd</span>
Success! Data written to: secret/data/extsecret/config
<span class="hljs-con-meta">$ </span><span class="language-bash">kubectl get secret secret-to-be-created -n my-ext-secret -o json | jq -r </span><span class="hljs-con-string">'.data.somepassword'</span><span class="language-bash"> | </span><span class="hljs-con-built_in">base64</span><span class="language-bash"> -d</span>
myN3wP@ssw0rd
</code></pre>
<p class="normal">It can take up to a minute for our new password to be synchronized into the <code class="inlineCode">Secret</code>. Wait until that synchronization is complete. Once synchronized, let’s watch our logs:</p>
<pre class="programlisting con"><code class="hljs-con">ubuntu@book-v3:~/Kubernetes-An-Enterprise-Guide-Third-Edition/chapter8/vault$ kubectl logs -f -l run=watch-env -n my-ext-secret
<span class="code-highlight"><strong class="hljs-slc">Fri Sep 15 12:48:41 UTC 2023</strong></span>
<span class="code-highlight"><strong class="hljs-slc">MY_SECRET_PASSWORD=An0therPassw0rd</strong></span>
<span class="code-highlight"><strong class="hljs-slc">Fri Sep 15 12:48:42 UTC 2023</strong></span>
<span class="code-highlight"><strong class="hljs-slc">MY_SECRET_PASSWORD=An0therPassw0rd</strong></span>
<span class="code-highlight"><strong class="hljs-slc">Fri Sep 15 12:48:43 UTC 2023</strong></span>
<span class="code-highlight"><strong class="hljs-slc">MY_SECRET_PASSWORD=An0therPassw0rd</strong></span>
</code></pre>
<p class="normal">The environment variables in the pod are not updated. You can continue to let this run, but it won’t change. You’ll need something to watch the <code class="inlineCode">Secret</code> and restart your workload if you want to support dynamic changes with environment variables.</p>
<p class="normal">Now that we’re able to<a id="_idIndexMarker896"/> incorporate a Kubernetes <code class="inlineCode">Secret</code> as an environment variable, next, we’ll work with the Vault sidecar to integrate that same variable into a pod.</p>
<h3 class="heading-3" id="_idParaDest-314">Using the Vault Sidecar</h3>
<p class="normal">The <strong class="keyWord">Vault sidecar</strong> doesn’t support injecting environment variables directly, because sidecar images can’t share <a id="_idIndexMarker897"/>environment variables. If your pod does require environment variables, you need to generate a file that has a script that exports those variables. Here’s an example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">run:</span> <span class="hljs-string">watch-vault-env</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">test-envvars-vault-watch</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-ext-secret</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">vault.hashicorp.com/agent-inject:</span> <span class="hljs-string">"true"</span>
    <span class="hljs-attr">vault.hashicorp.com/log-level:</span> <span class="hljs-string">trace</span>
    <span class="hljs-attr">vault.hashicorp.com/role:</span> <span class="hljs-string">extsecret</span>
    <span class="hljs-attr">vault.hashicorp.com/tls-skip-verify:</span> <span class="hljs-string">"true"</span>
    <span class="hljs-attr">vault.hashicorp.com/agent-inject-secret-myenv:</span> <span class="hljs-string">'secret/data/extsecret/config'</span>
    <span class="hljs-attr">vault.hashicorp.com/agent-inject-template-myenv:</span> <span class="hljs-string">|</span>
          {{<span class="hljs-bullet">-</span> <span class="hljs-string">with</span> <span class="hljs-string">secret</span> <span class="hljs-string">"secret/data/extsecret/config"</span> <span class="hljs-string">-</span>}}
            <span class="hljs-string">export</span> <span class="hljs-string">MY_SECRET_PASSWORD="{{</span> <span class="hljs-string">index</span> <span class="hljs-string">.Data</span> <span class="hljs-string">"some-password"</span> <span class="hljs-string">}}"</span>
          {{<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> }}
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">ubuntu:22.04</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>
    <span class="hljs-attr">resources:</span> {}
    <span class="hljs-attr">command:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">bash</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-bullet-slc">-</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'echo "sleeping 5 seconds"; sleep 5;source /vault/secrets/myenv ; env | grep MY_SECRET_PASSWORD'</strong></span>
  <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span>
  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span>
  <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">ext-secret-vault</span>
  <span class="hljs-attr">serviceAccount:</span> <span class="hljs-string">ext-secret-vault</span>
</code></pre>
<p class="normal">This pod definition looks almost identical to the volume-based Vault integration we created before. The main difference is that we are running a command in our container to generate the environment variables from the template we created in our annotations. While this approach will work, it means updating your manifests so that they are looking looking for a specific file. This<a id="_idIndexMarker898"/> approach breaks accepted patterns for manifest reusability and will make it difficult to use externally generated images.</p>
<p class="normal">The issues with trying to generate environment variables with an external secrets manager reinforces that this is an antipattern that should be avoided. Next, we’ll look at using the Kubernetes API directly for retrieving <code class="inlineCode">Secrets</code>.</p>
<h2 class="heading-2" id="_idParaDest-315">Using the Kubernetes Secrets API</h2>
<p class="normal">So far, we have focussed on abstractions for interacting with APIs so that our workloads do not need to know about the<a id="_idIndexMarker899"/> Kubernetes API. For<a id="_idIndexMarker900"/> most workloads, this makes sense as secret metadata is often static. For instance, your application may need to talk to a database whose credentials may change but the fact that you need credentials won’t. What if you need something more dynamic? If you’re building a system that services other systems, this might be the case. In this section, we’ll walk through why you would call the <code class="inlineCode">Secrets</code> API directly from your pod.</p>
<p class="normal">The first question you might be asking is “why?” With the multiple options for abstraction on top of the Kubernetes <code class="inlineCode">Secrets</code> API, why would you want to call the Kubernetes API directly? There have been some interesting trends that will likely make this more of a reality:</p>
<ul>
<li class="bulletList"><strong class="keyWord">More monoliths</strong>: In recent months there’s been a trend of re-examining if microservices are the right architecture for most systems. One of the most visible moves to monoliths was Amazon’s Prime Video <strong class="keyWord">Quality of Service </strong>(<strong class="keyWord">QoS</strong>) going from Lambda to a monolith. We discuss the trade-offs between these approaches when we talk about Istio in <em class="chapterRef">Chapter 17</em>, <em class="italic">Building and Deploying Applications on Istio</em>. If you were to build a monolith, you may need to provide more flexibility in how you access your <code class="inlineCode">Secrets</code>. Static metadata definitions may not be adequate.</li>
<li class="bulletList"><strong class="keyWord">Kubernetes as a data center API</strong>: It turns out that Kubernetes’ API is simple enough to be easily adapted to multiple use cases, yet powerful enough to be scaled out. A great example is <a id="_idIndexMarker901"/>the <strong class="keyWord">KubeVirt</strong> (<a href="https://kubevirt.io/"><span class="url">https://kubevirt.io/</span></a>) project that lets your<a id="_idIndexMarker902"/> Kubernetes cluster manage and <a id="_idIndexMarker903"/>deploy virtual machines. More workloads are using <strong class="keyWord">custom resource definitions</strong> (<strong class="keyWord">CRDs</strong>) to store configuration information, and since you’d never keep a secret in a CRD, you may need to<a id="_idIndexMarker904"/> interact with the <code class="inlineCode">Secrets</code> API to get access to your secret data.</li>
<li class="bulletList"><strong class="keyWord">Platform engineering</strong>: More teams are moving to the idea of creating an <strong class="keyWord">internal developer platform</strong> (<strong class="keyWord">IDP</strong>) that provides a one-stop-shop for self-service access to services such as<a id="_idIndexMarker905"/> Kubernetes. If your IDP is built on Kubernetes, you’ll likely need to interact with the <code class="inlineCode">Secrets</code> API.<div class="packt_tip">
<p class="normal">This book spends quite a bit of time on identity in Kubernetes and will often refer to IdPs. The case of the “d” is important<a id="_idIndexMarker906"/> because an <strong class="keyWord">IdP</strong> is<a id="_idIndexMarker907"/> an <strong class="keyWord">Identity Provider</strong>, while an <strong class="keyWord">IDP</strong> is an <strong class="keyWord">Internal Developer Portal</strong>.</p>
</div>
</li>
</ul>
<p class="normal">With these points in mind, you may find yourself needing to interact directly with the Kubernetes API to retrieve <code class="inlineCode">Secrets</code>. The good news is that you’re not really doing anything different for the <code class="inlineCode">Secrets</code> API than any other API. Most of the Kubernetes client SDKs even handle base64 decoding the data from <code class="inlineCode">Secret</code> objects.</p>
<p class="normal">Since this isn’t a programming book, and there are many ways to interact with the API, we’re not going to dive into any SDK specifics. We’re going to cover some specific guidance:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Use Your Pod’s Identity</strong>: Just like interacting with external vaults, use your Pod’s own identity when interacting with the API server. Don’t use a hardcoded Secret.</li>
<li class="bulletList"><strong class="keyWord">Use an SDK</strong>: This is good general advice. Yes, you can use the Kubernetes API via a direct RESTful call, but let the SDK do the work for you. It will make life easier and lead to fewer security issues (who hasn’t accidently logged a token while testing an HTTPS call? I mean, besides me).</li>
<li class="bulletList"><strong class="keyWord">Store Metadata in CRDs</strong>: Any situation where you’re going to describe a secret should be done in a CRD. This gives you the benefit of having a schema language that you can use to generate your own SDKs.</li>
</ul>
<p class="normal">While it is more difficult to<a id="_idIndexMarker908"/> interact with the <code class="inlineCode">Secrets</code> API than to use Kubernetes’ multiple abstractions for interacting with secrets, it does provide tremendous flexibility that is not available to the more<a id="_idIndexMarker909"/> common abstractions. Next, we’ll look at whether interacting directly with our vault’s API can provide the same benefits.</p>
<h2 class="heading-2" id="_idParaDest-316">Using the Vault API</h2>
<p class="normal">Every vault service has an API. That’s how the<a id="_idIndexMarker910"/> sidecars that integrate with them interact with their vaults so that they can inject secrets into<a id="_idIndexMarker911"/> your workloads. In the previous section, we walked through the advantages of directly calling the Kubernetes <code class="inlineCode">Secrets</code> API. Does the same logic apply to the Vault API? The reasoning for calling the Vault API, or any secrets management API, directly is the same as calling the <code class="inlineCode">Secrets</code> API.</p>
<p class="normal">What are the disadvantages of calling the Vault API directly? The main drawback is that you are now tightly binding your workload to a specific vendor or project. One of the benefits of the Kubernetes API is that it is relatively consistent across implementations. While this isn’t always true, at least for the <code class="inlineCode">Secret</code> API it is.</p>
<p class="normal">There is unfortunately no standard API for secrets, nor is there likely to ever be one. HashiCorp, AWS, Microsoft, Google, VMWare, etc. all have their own ideas as to how secrets should be managed and there isn’t much incentive to create a standard. There’s also no standard for integrating language bindings. For instance, the database world often has common standards for integrating into programming languages such as the JDBC standard in Java. It would be great for Kubernetes to make the <code class="inlineCode">Secrets</code> API pluggable, but that will never happen. The complexities at both the technical and non-technical levels are just too high for Kubernetes to own such an undertaking.</p>
<p class="normal">With that said, the same recommendations that were made for using the Kubernetes <code class="inlineCode">Secrets</code> API should be followed<a id="_idIndexMarker912"/> when integrating your workloads directly into the Vault API. Make sure that you’re using a language SDK and rely on your workload’s identity.</p>
<h1 class="heading-1" id="_idParaDest-317">Summary</h1>
<p class="normal">This chapter walked through multiple aspects of secrets management. We began by discussing the difference between secret data and more generic configuration data. We considered why Kubernetes stores and represents Secret objects as base64-encoded text, and why you shouldn’t store secret data in git. There was also a discussion on threat modelling secret data in Kubernetes clusters. Next, we then walked through various ways to store and manage secret data including Secret objects, external vaults, Sealed Secrets, and hybrid approaches. Finally, we walked through integrating your secrets into your workloads via volume mounts, environment variables, and directly with APIs.</p>
<p class="normal">Having finished this chapter, you should now have enough information and examples to build your own secrets management strategy for your clusters.</p>
<p class="normal">In the next chapter, we are going to begin focusing on multi-tenancy with virtual clusters.</p>
<h1 class="heading-1" id="_idParaDest-318">Questions</h1>
<ol>
<li class="numberedList" value="1">Compliance and security are the same thing.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
<li class="numberedList">Base64 is a type of encryption.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
<li class="numberedList">The best way to authenticate to an external vault is:<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Using a password</li>
<li class="alphabeticList level-2">Using your <code class="inlineCode">Pod's</code> identity</li>
<li class="alphabeticList level-2">Using a password that changes every 3 months</li>
</ol>
</li>
<li class="numberedList">Which integration type is automatically updated in a pod when a secret is updated?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">A <code class="inlineCode">Secret</code> with an environment variable</li>
<li class="alphabeticList level-2">An external vault with an environment variable</li>
<li class="alphabeticList level-2">An external vault with a volume</li>
<li class="alphabeticList level-2">A <code class="inlineCode">Secret</code> with a volume</li>
</ol>
</li>
<li class="numberedList">When discussing IT security, what does CIA stand for?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Confidentiality, Integrity, Availability</li>
<li class="alphabeticList level-2">Central Intelligence Agency</li>
<li class="alphabeticList level-2">Confidentiality, Interesting, Availability</li>
<li class="alphabeticList level-2">Culinary Institute of America</li>
</ol>
</li>
</ol>
<h1 class="heading-1" id="_idParaDest-319">Answers</h1>
<ol>
<li class="numberedList" value="1">b – False</li>
<li class="numberedList">b – False</li>
<li class="numberedList">c – Using your <code class="inlineCode">Pod's</code> identity</li>
<li class="numberedList">d – A <code class="inlineCode">Secret</code> with a volume</li>
<li class="numberedList">a – Confidentiality, Integrity, Availability</li>
</ol>
</div>
</div></body></html>