<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-41" class="chapter-number"><a id="_idTextAnchor043"/>2</h1>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor044"/>Instrumenting Applications and Infrastructure</h1>
			<p>The previous chapter introduced observability, with examples outside of the computing world to give you a generic understanding of the subject. In this chapter, we’ll build on those examples by providing a high-level overview of both application and infrastructure instrumentation. We will look at the data created by systems and how that fits into the different telemetry types and common protocols in use. We will also explore widely used libraries for popular programming languages that simplify instrumenting applications. To finish, we will cover more traditional telemetry collection from infrastructure components, operating systems, and network devices. This will give you insight into the components that are still in operation today that run applications and Kubernetes workloads. This chapter is aimed at readers of all technical abilities and no specific technologies are needed. An understanding of observability terminology (for example, logs, metrics, traces, and instrumentation) is helpful. It aims to provide an overview of the technology space and act as a valuable resource that you can quickly reference when you are working with your <span class="No-Break">observability solutions.</span></p>
			<p>In this chapter, we explore the following <span class="No-Break">introductory sections:</span></p>
			<ul>
				<li>Common <span class="No-Break">log formats</span></li>
				<li>Metrics protocols and <span class="No-Break">best practices</span></li>
				<li>Tracing protocols and <span class="No-Break">best practices</span></li>
				<li>Using libraries to <span class="No-Break">instrument efficiently</span></li>
				<li>Infrastructure <span class="No-Break">data technologies</span></li>
			</ul>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor045"/>Common log formats</h1>
			<p>Log files are a standard component <a id="_idIndexMarker123"/>of computer systems and an essential tool for software developers and operators – in our example, Diego and Ophelia, respectively. Logs support performance and capacity monitoring in infrastructure, bug detection in software, root cause analysis, user behavior tracking, and more. There is no perfect recipe<a id="_idIndexMarker124"/> for logs and as such, it does not matter what your logs look like, though following certain guidelines will help your future self when you need to analyze logs. In this section, we will learn about different log formats and how the data can be used. Log formats are the definition of what a log file looks like and should explain how the data can <span class="No-Break">be interpreted.</span></p>
			<p>Log formats usually identify if they are structured or unstructured, the data types used in them, and if any encoding or delimitation is being used. We’ll explore structure first and then look at example log formats in more detail in the <span class="No-Break">following sections.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor046"/>Structured, semi-structured, and unstructured logging</h2>
			<p>As mentioned previously, it does not matter what your logs look like and they can come in structured, semi-structured, or unstructured formats. However, when designing and building observability solutions, it’s important to understand the log formats you are working with. This ensures that you can ingest, parse, and store the data in a way that it can be used effectively. If you familiarized yourself with the personas in <a href="B18277_01.xhtml#_idTextAnchor018"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, you have an awareness of who they will be used by and for <span class="No-Break">what purpose.</span></p>
			<h3>Structured logging</h3>
			<p><strong class="bold">Structured logs</strong> have a predetermined message<a id="_idIndexMarker125"/> format that allows them to be treated as datasets<a id="_idIndexMarker126"/> rather than text. The idea of structured logging is to present data with a defined pattern that can be easily understood by humans and efficiently processed by machines. The log entries are often delimited with characters such as a comma, space, or hyphen. Data fields may also be joined using an equals sign or colon for key-value pairs, such as <strong class="source-inline">name=Diego</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">city=Berlin</strong></span><span class="No-Break">.</span></p>
			<p>Here is an example of a structured <span class="No-Break">log format:</span></p>
			<pre class="source-code">
{
"timestamp": "2023-04-25T12:15:03.006Z",
"message": "User Diego.Developer has logged in",
"log": {
"level": "info",
"file": "auth.py",
"line": 77
},
"user": {
"name": "diego.developer",
"id": 123
},
"event": {
"success": true
}
}</pre>			<p>An additional benefit of structured logging is that you can validate the conformation of the data to a schema with tools such as JSON schema. This opens up the possibility of making version control changes<a id="_idIndexMarker127"/> to the schema, which is where logs and event<a id="_idIndexMarker128"/> bus <span class="No-Break">technology overlap.</span></p>
			<h3>Semi-structured logging</h3>
			<p><strong class="bold">Semi-structured logs</strong> aim to bridge the gap between unstructured<a id="_idIndexMarker129"/> and structured and, as a result, can be quite<a id="_idIndexMarker130"/> complicated. They are designed to be easy for humans to read but also have a schema that makes it possible for machines to process them too. They have complex field and event separators and usually come with a defined pattern to aid with ingesting and parsing. Parsing is usually done using regular expressions or <span class="No-Break">other code.</span></p>
			<h3>Unstructured logging</h3>
			<p><strong class="bold">Unstructured logging</strong> typically refers to log entries that are presented<a id="_idIndexMarker131"/> in a textual format that can easily<a id="_idIndexMarker132"/> be read by humans but is difficult for machines to process. They are often color-coded with blank spaces to improve presentation and readability. It is this presentation that creates issues for machines to process the logs. Parsing and splitting the data correctly creates a disassociation between events and their identifying metadata. An unstructured log will require some custom parsing, requiring intimate knowledge of the data and often creating additional work for the engineer (<em class="italic">Ophelia</em>) when ingesting data. This also creates technical liability; the dependency on the log remaining the same restricts developers from changing logs or runs the risk of parsing and reporting on unstructured logs prone <span class="No-Break">to breaking.</span></p>
			<p>To aid the ability of machines to process unstructured logs, encapsulation prevents entries such as stack traces from splitting at an <span class="No-Break">inappropriate location.</span></p>
			<p>The following is an example of a multiline log, with a naive encapsulation that looks for line breaks; this will appear in logging systems as four <span class="No-Break">distinct events:</span></p>
			<pre class="console">
2023-04-25 12:15:03,006 INFO [SVR042] UserMembershipsIterable Found 4 children for 4 groups in 3 ms
Begin Transaction update record.
Process started.
Process completed.</pre>			<p>With encapsulation based on the timestamp at the start of the event, this will be stored correctly <span class="No-Break">for searching.</span></p>
			<p>In the following section, we will explore common log formats found in <span class="No-Break">today’s systems.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor047"/>Sample log formats</h2>
			<p>Many log formats have been used in computer systems. All of these formats have a common goal of presenting a standard structure or set of fields for recording important information about the activity of a computer system. The following table<a id="_idIndexMarker133"/> aims to provide easy reference for some of the more <span class="No-Break">notable ones:</span></p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Format</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Overview</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Common Event </strong><span class="No-Break"><strong class="bold">Format</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CEF</strong></span><span class="No-Break">)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>CEF is an open logging and auditing format from ArcSight that aims to provide a simple interface to record <span class="No-Break">security-related events.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">NCSA</strong> <strong class="bold">Common Log </strong><span class="No-Break"><strong class="bold">Format</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CLF</strong></span><span class="No-Break">)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The NCSA CLF is historically used on web servers to record information about requests made to the server. This format has been extended by the CLF to include additional information about the browser (user-agent) and <span class="No-Break">the referer.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">W3C Extended Log </strong><span class="No-Break"><strong class="bold">File Format</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>W3C Extended Log File Format is a log format commonly used by Windows Internet Information Services servers (<span class="No-Break">web servers).</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Windows </strong><span class="No-Break"><strong class="bold">Event Log</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Windows Event Log is the standard log format used by the Windows operating system. These logs record events that occur on the system and are categorized System, Application, Security, Setup, and <span class="No-Break">Forwarded events.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">JavaScript Object </strong><span class="No-Break"><strong class="bold">Notation</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JSON</strong></span><span class="No-Break">)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>JSON is an open standard file format that is very useful for easily parsing structured <span class="No-Break">log events.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Syslog</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Syslog is a standard that’s used across many hardware devices such as networking, compute, and storage, and is used by the Linux kernel <span class="No-Break">for logging.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Logfmt</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Logfmt does not have a defined standard but is a widely used form of human-readable <span class="No-Break">structured logging.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – Log format overview</p>
			<p>Let’s look at these formats in <span class="No-Break">greater detail.</span></p>
			<h3>CEF</h3>
			<p>Developed by ArcSight to fulfill the <strong class="bold">Security Information and Event Management</strong> (<strong class="bold">SIEM</strong>) use case, the CEF is a structured<a id="_idIndexMarker134"/> text-based<a id="_idIndexMarker135"/> log format. Using<a id="_idIndexMarker136"/> UTF-8 encoding, the format contains a prefix, a CEF header, and a body containing additional <span class="No-Break">enrichment data.</span></p>
			<p>The following table shows the log sections of the <span class="No-Break">CEF format:</span></p>
			<table id="table002-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Log Section</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Prefix</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It combines the event timestamp and <span class="No-Break">source hostname.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">CEF header</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It combines the following pieces <span class="No-Break">of metadata:</span></p>
							<ul>
								<li><span class="No-Break">Software version</span></li>
								<li><span class="No-Break">Vendor name</span></li>
								<li><span class="No-Break">Product name</span></li>
								<li><span class="No-Break">Product version</span></li>
								<li>Product event class <span class="No-Break">identification code</span></li>
								<li><span class="No-Break">Event name</span></li>
								<li><span class="No-Break">Event severity</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Body</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It contains a list of <span class="No-Break">key-value pairs</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2 – CEF format</p>
			<p>Here is an example CEF <span class="No-Break">log event:</span></p>
			<pre class="source-code">
CEF:0|Security Provider|Security Product|Version|123|User Authenticated|3|src=10.51.113.149 suser=diego target=diego msg=User authenticated from 1001:db7::5</pre>			<h3>NCSA CLF</h3>
			<p>As one of the oldest log formats<a id="_idIndexMarker137"/> used by web servers, the NCSA CLF<a id="_idIndexMarker138"/> has for a long time been the most common and well-known log formats. It has a fixed format text-based structure and therefore cannot be customized <span class="No-Break">at all.</span></p>
			<p>Here is the NCSA CLF <span class="No-Break">field list:</span></p>
			<ul>
				<li>Remote <span class="No-Break">host address</span></li>
				<li>Remote <span class="No-Break">log name</span></li>
				<li><span class="No-Break">Username</span></li>
				<li><span class="No-Break">Timestamp</span></li>
				<li>Request and <span class="No-Break">protocol version</span></li>
				<li>HTTP <span class="No-Break">status code</span></li>
				<li><span class="No-Break">Bytes sent</span></li>
			</ul>
			<p>Where data is missing from the log, a hyphen acts as a placeholder. Unsupported characters are replaced with the <strong class="source-inline">+</strong> <span class="No-Break">symbol.</span></p>
			<p>Here is an example NCSA <span class="No-Break">CLF log:</span></p>
			<pre class="source-code">
127.0.0.1 user-identifier diego [25/Apr/2023:12:15:03 -0000] "GET /apache_pb.gif HTTP/1.1" 200 2326</pre>			<h3>W3C Extended Log File Format</h3>
			<p>The Microsoft Internet Information Server<a id="_idIndexMarker139"/> log format known as W3C is a structured<a id="_idIndexMarker140"/> yet configurable format. Full control over the included fields ensures log files contain the most relevant data. Identification of the information or direction of flow is denoted using a string prefix: server (<em class="italic">S</em>), client (<em class="italic">C</em>), server to client (<em class="italic">SC</em>), and client to <span class="No-Break">server (</span><span class="No-Break"><em class="italic">CS</em></span><span class="No-Break">).</span></p>
			<p>Here is the W3C Extended Log File Format <span class="No-Break">field list:</span></p>
			<ul>
				<li><span class="No-Break">Timestamp</span></li>
				<li><span class="No-Break">Client IP</span></li>
				<li><span class="No-Break">Server IP</span></li>
				<li><span class="No-Break">URI-stem</span></li>
				<li>HTTP <span class="No-Break">status code</span></li>
				<li><span class="No-Break">Bytes sent</span></li>
				<li><span class="No-Break">Bytes received</span></li>
				<li><span class="No-Break">Time taken</span></li>
				<li><span class="No-Break">Version</span></li>
			</ul>
			<p>Here is an<a id="_idIndexMarker141"/> example<a id="_idIndexMarker142"/> <span class="No-Break">W3C log:</span></p>
			<pre class="source-code">
#Software: Internet Information Services 10.0
#Version: 1.0
#Date: 2023-04-25 12:15:03
#Fields: time c-ip cs-method cs-uri-stem sc-status cs-version
12:15:03 10.51.113.149 GET /home.htm 200 HTTP/1.0</pre>			<h3>Microsoft Windows Event Log</h3>
			<p>The Microsoft Windows operating system<a id="_idIndexMarker143"/> comes with a built-in complex<a id="_idIndexMarker144"/> structured logging system that captures data related to specific events on the operating system. There are four common Windows event log categories – system, application, security, and setup – and an additional special category for <span class="No-Break">forwarded events.</span></p>
			<p>Each event log is also one of five different types: information, warning, error, success audit, and failure audit. Windows Event Log is one of the most verbose log formats in use. It usually includes details such as timestamp, event ID, username, hostname, message, and category, making it invaluable in diagnosing problems. Windows event IDs are documented and searchable, so you can easily get detailed information regarding the log event; they are grouped<a id="_idIndexMarker145"/> into categories, narrowing down the area where the event occurred, which makes<a id="_idIndexMarker146"/> debugging <span class="No-Break">very accurate.</span></p>
			<p>Here is a trimmed example of Microsoft Windows <span class="No-Break">Event Log:</span></p>
			<pre class="source-code">
An account was successfully logged on.
Subject:
Security ID: SYSTEM
Account Name: DESKTOP-TMC369$
Account Domain: WORKGROUP
Logon ID: 0xE37
Logon Information:
New Logon:
Security ID: AD\DiegoDeveloper
Account Name: diego.developer@themelt.cafe
Account Domain: AD
Logon ID: 0xEC4093F
Network Information:
Workstation Name: DESKTOP-TMC369</pre>			<h3>JSON</h3>
			<p>As one of the newer<a id="_idIndexMarker147"/> yet most commonly used log formats<a id="_idIndexMarker148"/> today, JSON is a structured format constructed from multiple key-value pairs. Using JSON, data can be nested into different layers while keeping the format easy to read. Additionally, different data types can be represented, such as string, number, Boolean, null, object, <span class="No-Break">and array.</span></p>
			<p>Here is an example JSON <span class="No-Break">log file:</span></p>
			<pre class="source-code">
{
"timestamp": "2023-04-25T12:15:03.006Z",
"message": "User Diego.Developer has logged in",
"log": {
"level": "info",
"file": "auth.py",
"line": 77
},
"user": {
"name": "diego.developer",
"id": 123
},
"event": {
"success": true
}
}</pre>			<h3>Syslog</h3>
			<p>The go-to log format for many<a id="_idIndexMarker149"/> years and still widely used, Syslog is a defined standard<a id="_idIndexMarker150"/> for creating and transmitting logs. The <strong class="bold">Syslog transport protocol</strong> specifies how log transmission takes place, as well as the data format. The default network ports for the protocol are <strong class="source-inline">514</strong> and <strong class="source-inline">6514</strong>, with the latter being used <span class="No-Break">for encryption.</span></p>
			<p>The Syslog message format combines a standardized header and message holding the body of <span class="No-Break">the log.</span></p>
			<p>Here is an example <span class="No-Break">Syslog log:</span></p>
			<pre class="console">
Apr 25 12:15:03 server1 sshd[41458] : Failed password for  diego from 10.51.113.149 port 22 ssh2</pre>			<h3>Logfmt</h3>
			<p>Logfmt is a widely used log format<a id="_idIndexMarker151"/> that fits as human readable and structured so that computers and people can both read it. A Logfmt-formatted log line consists of any number of key-value pairs that can be easily parsed. As there are no standards, it is easy to extend and perfect for developers to simply<a id="_idIndexMarker152"/> add more key-value pairs to <span class="No-Break">the output.</span></p>
			<p>Here is an example <span class="No-Break">Logfmt log:</span></p>
			<pre class="console">
level=info method=GET path=/ host=myserver.me fwd="10.51.113.149" service=4ms status=200</pre>			<h1 id="_idParaDest-46"><a id="_idTextAnchor048"/>Exploring metric types and best practices</h1>
			<p>Metrics, along with logs, are an essential tool<a id="_idIndexMarker153"/> for software developers (<em class="italic">Diego</em>) and operators (<em class="italic">Ophelia</em>), providing them with indicators regarding the state of applications and systems. Resource usage data is great for monitoring a metric that captures numerical data over time. There are many different types of resources but some good examples would be CPU or RAM usage, the number of messages in a queue, and the number of received HTTP requests. Metrics are frequently generated and easily enriched with labels, attributes, or dimensions, making them efficient to search and ideal in determining if something is wrong, or different <span class="No-Break">from usual.</span></p>
			<p>A metric commonly<a id="_idIndexMarker154"/> has the <span class="No-Break">following fields:</span></p>
			<ul>
				<li><strong class="bold">Name</strong>: This uniquely identifies <span class="No-Break">the metric</span></li>
				<li><strong class="bold">Data point value(s)</strong>: The data that’s stored varies by <span class="No-Break">metric type</span></li>
				<li><strong class="bold">Dimensions</strong>: Additional enrichment labels or attributes that <span class="No-Break">support analysis</span></li>
			</ul>
			<p>Metrics capture the behavior of the data they represent. CPU usage would go up and down between 0% and 100% usage, whereas the number of received HTTP requests could increase indefinitely. In the following section, we will look at metric types, which allow us to capture the behavior of the metric <span class="No-Break">being collected.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor049"/>Metric types</h2>
			<p>Metrics vary in characteristics<a id="_idIndexMarker155"/> and structure. There are four common types of metrics, from simple single values to more <span class="No-Break">complex values:</span></p>
			<ul>
				<li><strong class="bold">Counter</strong>: This metric represents the last<a id="_idIndexMarker156"/> increment value. This could be the incremental change<a id="_idIndexMarker157"/> from the last recording or the total increment since the <span class="No-Break">recording started.</span><p class="list-inset">Here are some examples<a id="_idIndexMarker158"/> of <span class="No-Break">this metric:</span></p><ul><li>The number of <span class="No-Break">requests served</span></li><li><span class="No-Break">Tasks completed</span></li><li><span class="No-Break">Errors reported</span></li></ul><p class="list-inset">How the value is reset to zero depends on the protocol used to collect them, so it is important to factor this in for your use case. The StatsD implementation resets the counter every time the value is flushed, and Prometheus resets the counter when the application <span class="No-Break">process restarts.</span></p></li>
				<li><strong class="bold">Gauge</strong>: A gauge metric is a snapshot<a id="_idIndexMarker159"/> of state and can be used to take a measure<a id="_idIndexMarker160"/> of something reporting continuously. As such, it is usually made more useful by aggregating with sum, average, minimum, or maximum over a <span class="No-Break">certain period.</span><p class="list-inset">Here are some examples<a id="_idIndexMarker161"/> of <span class="No-Break">this metric:</span></p><ul><li><span class="No-Break">Temperature</span></li><li>Items <span class="No-Break">in queue</span></li><li>Disk <span class="No-Break">space used</span></li><li>Number of <span class="No-Break">concurrent requests</span></li></ul><p class="list-inset">Like counter, the definitions for gauge vary in implementation, so be sure to verify how the protocol you select will report <span class="No-Break">gauge metrics.</span></p></li>
				<li><strong class="bold">Histogram</strong>: A histogram metric represents the statistical<a id="_idIndexMarker162"/> distribution of a set of values<a id="_idIndexMarker163"/> returning, for example, min, max sum, and count data points. These are calculated by the agent, reported in a single time interval, and often counted in configurable buckets. They return the raw values; this differs from a summary, which returns the percentile values. Here are<a id="_idIndexMarker164"/> <span class="No-Break">some examples:</span><ul><li><span class="No-Break">Request durations</span></li><li><span class="No-Break">Response sizes</span></li></ul><p class="list-inset">In Prometheus, a histogram is made up of a count of the total measurements (<strong class="source-inline">_count</strong>), a sum of all the values of the measurements (<strong class="source-inline">_sum</strong>), and several buckets that have a count of events with a measure less than or equal (<strong class="source-inline">le</strong>) to a <span class="No-Break">defined value.</span></p><p class="list-inset">Definitions can vary in implementation – for example, Prometheus<a id="_idIndexMarker165"/> has a <strong class="source-inline">histogram_quantile</strong> function<a id="_idIndexMarker166"/> that can be used to calculate percentiles from <span class="No-Break">histogram metrics.</span></p></li>
				<li><strong class="bold">Summary</strong>: Similar to a histogram, a summary<a id="_idIndexMarker167"/> samples a set of values. While it provides<a id="_idIndexMarker168"/> sum and count, it also calculates percentiles over a sliding time window. These are usually a good option if you need to calculate accurate percentiles but cannot be sure what the range of the values will be. Some examples<a id="_idIndexMarker169"/> of this metric are <span class="No-Break">as follows:</span><ul><li><span class="No-Break">Request durations</span></li><li><span class="No-Break">Response sizes</span></li></ul><p class="list-inset">In Prometheus, a summary, like a histogram, is made up of the <strong class="source-inline">_count</strong> and <strong class="source-inline">_sum</strong> metrics and several groupings. Unlike a histogram, these groupings are a quantile, and the value represents the value of that quantile at the point in time for the measurement. For example, a quantile of 0.99 and a value of 3.2148 would indicate that 99% of the sampled data was smaller <span class="No-Break">than 3.2148.</span></p></li>
			</ul>
			<p>Again, definitions can vary in implementation, so work out what your goals are from your metrics to ensure the capabilities are supported by your choice of protocol. It’s useful to note that, in Prometheus, summary metrics<a id="_idIndexMarker170"/> have a significant drawback in modern systems as they cannot be aggregated over <span class="No-Break">multiple sources.</span></p>
			<p>There are some distinct differences between these metric types, as we will discuss in the <span class="No-Break">following section.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor050"/>Comparing metric types</h2>
			<p>The following table<a id="_idIndexMarker171"/> describes each type in general terms. When querying them, this provides a useful reference when approaching <span class="No-Break">metric adoption:</span></p>
			<table id="table003-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Consideration</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Counter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Gauge</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Histogram</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Summary</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Structure</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Simple</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Simple</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Complex</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Complex</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Can increase <span class="No-Break">and decrease</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Is <span class="No-Break">an approximation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Can <span class="No-Break">calculate percentiles</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Can use a <span class="No-Break">rate function</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Can be queried with the <strong class="source-inline">prometheus </strong><span class="No-Break"><strong class="source-inline">histogram_quantile</strong></span><span class="No-Break"> function</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Can be aggregated across <span class="No-Break">multiple series</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Yes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">No</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Table 2.3 – Comparison of metric types</p>
			<p>The following table provides a few reference examples<a id="_idIndexMarker172"/> of the type and <span class="No-Break">values expected:</span></p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Metric Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Data Field</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Counter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Last increment</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">15</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Gauge</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Last value</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">25.4</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" rowspan="9">
							<p><span class="No-Break"><strong class="bold">Histogram</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Min</span></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Max</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">100</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Count</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">10</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Interval</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">20</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">0-20</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">20-40</span></p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">40-60</span></p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">60-80</span></p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">80-100</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Summary</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Min</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">1.2ms</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">Max</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">4.23ms</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">Count</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">10</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">Sum</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Percentiles/Quantiles</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">P90</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">2.98ms</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">P95</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">3.76ms</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">P99</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">4.23ms</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.4 – Metric type example data</p>
			<p>Now that we’ve looked at the different types of metrics, let’s look at the different technologies used to <span class="No-Break">transmit metrics.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor051"/>Metric protocols</h2>
			<p><strong class="bold">Metric protocols</strong> are collections of tools and libraries for instrumenting<a id="_idIndexMarker173"/> applications, data formats to transmit, clients to collect data, and often storage and visualization tools. Some common protocols that are in use today are described in the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker174"/></span><span class="No-Break"> table:</span></p>
			<table id="table005" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Metric Protocol</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Features</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">StatsD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p> It supports <span class="No-Break">the following:</span></p>
							<ul>
								<li><span class="No-Break">Counters</span></li>
								<li><span class="No-Break">Gauges</span></li>
								<li><span class="No-Break">Timers</span></li>
								<li><span class="No-Break">Histograms</span></li>
								<li><span class="No-Break">Meters</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">DogStatsD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>DogStatsD implements the StatsD protocol and adds a few <span class="No-Break">Datadog-specific extensions:</span></p>
							<ul>
								<li>Histogram <span class="No-Break">metric type</span></li>
								<li><span class="No-Break">Service checks</span></li>
								<li><span class="No-Break">Events</span></li>
								<li><span class="No-Break">Tagging</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">OpenTelemetry </strong><span class="No-Break"><strong class="bold">Protocol</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">OTLP</strong></span><span class="No-Break">)</span></p>
						</td>
						<td class="No-Table-Style">
							<p> It supports <span class="No-Break">the following:</span></p>
							<ul>
								<li><span class="No-Break">Counters</span></li>
								<li><span class="No-Break">Gauges</span></li>
								<li><span class="No-Break">Histograms</span></li>
								<li>Summaries (<span class="No-Break">legacy support)</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Prometheus</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p> It supports <span class="No-Break">the following:</span></p>
							<ul>
								<li><span class="No-Break">Counters</span></li>
								<li><span class="No-Break">Gauges</span></li>
								<li><span class="No-Break">Cumulative histograms</span></li>
								<li><span class="No-Break">Summaries</span></li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.5 – Common metric protocols and their features</p>
			<p>Metrics are very powerful, but some pitfalls can catch people out. Some of these can lead to expensive mistakes. To avoid these pitfalls, let’s discuss some <span class="No-Break">best practices.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor052"/>Best practices for implementing metrics</h2>
			<p>Introducing metrics into your services<a id="_idIndexMarker175"/> is a very good way to gain a huge amount of visibility on how they behave in real situations. The following best practices are from our experience with metrics and will help you manage scope creep, cost, and linking metrics up <span class="No-Break">with traces:</span></p>
			<ul>
				<li><strong class="bold">Set your objectives</strong>: Work out what your objectives are from your metrics. We have already spoken about the variation in implementation between metric protocols – this can have a big impact if you are expecting to use a metric in a certain way and haven’t factored <span class="No-Break">in nuances.</span><p class="list-inset">This will<a id="_idIndexMarker176"/> also help you define <strong class="bold">service-level indicators</strong> (<strong class="bold">SLIs</strong>) and <strong class="bold">service-level objectives</strong> (<strong class="bold">SLOs</strong>), which will be useful<a id="_idIndexMarker177"/> in <a href="B18277_09.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Managing Incidents </em><span class="No-Break"><em class="italic">Using Alerts</em></span><span class="No-Break">.</span></p></li>
				<li><strong class="bold">Manage cardinality</strong>: Cardinality is generally defined as the number of unique elements in a set. High cardinality<a id="_idIndexMarker178"/> may provide richer, more useful data, but at the cost of monitoring performance impacts or increased storage costs. For example, if you dimension your metrics by server name, the sample could be small, maybe a few hundred metrics. If we compare this to dimensioning by user, which could be in the millions, the increase in the number of metrics produced is exponential. This increase has a direct impact on load <span class="No-Break">and storage.</span><p class="list-inset">Take time to understand the capabilities of the observability backend – things such as the billing framework, limitations, storage, <span class="No-Break">and performance.</span></p></li>
				<li><strong class="bold">Add context</strong>: The ability to correlate (establish a common identifier) metrics with traces has been introduced to Grafana and Open Telemetry recently with exemplars. They enable quick visualization and linking between a metric data point and a specific trace span, thus giving improved context and detail to <span class="No-Break">your data.</span></li>
			</ul>
			<p>As we just discussed, metrics capture<a id="_idIndexMarker179"/> numerical data from a single service; however, the systems that operate today may consist of multiple services. Distributed tracing is a way to gain visibility of the communications between services. Let’s take a look at tracing protocols and some best practices <span class="No-Break">regarding them.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>Tracing protocols and best practices</h1>
			<p><strong class="bold">Tracing</strong>, or as it is more commonly referred to, <strong class="bold">distributed tracing</strong>, tracks application requests as they<a id="_idIndexMarker180"/> are made between<a id="_idIndexMarker181"/> services of a system. It allows you to follow a single request through an entire system or look at the aggregate data over requests to better understand <span class="No-Break">distributed behavior.</span></p>
			<p>This capability provides software developers (<em class="italic">Diego</em>), operators (<em class="italic">Ophelia</em>), and service managers (<em class="italic">Steven</em>) with valuable tools that enable an understanding of the flow of logic that is essential for troubleshooting. Instrumenting your code by adding traces helps you easily pinpoint almost any issue or at least have a clear indicator of where the problem could be. <strong class="bold">Distributed tracing</strong> uses the concepts of spans and traces to capture this data. Let’s examine these in <span class="No-Break">more detail.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>Spans and traces</h2>
			<p>The <strong class="bold">trace record</strong> is the parent object that represents<a id="_idIndexMarker182"/> the data flow or execution path through<a id="_idIndexMarker183"/> the system being observed. Each <strong class="bold">trace</strong> will contain one or more <strong class="bold">span</strong> records that represent the logical<a id="_idIndexMarker184"/> operations. This relationship between traces and spans is illustrated in the following figure, in what can be thought of as a directed acyclic graph <span class="No-Break">of spans:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B18277_02_1.jpg" alt=" Figure 2.1 – Traces and spans"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 2.1 – Traces and spans</p>
			<p>A trace is pieced together from multiple spans and would usually report<a id="_idIndexMarker185"/> the <span class="No-Break">following information:</span></p>
			<ul>
				<li><strong class="bold">Identifier</strong>: Uniquely identifies <span class="No-Break">the trace</span></li>
				<li><strong class="bold">Name</strong>: Describes the overall work <span class="No-Break">being recorded</span></li>
				<li><strong class="bold">Timing details</strong>: Provides the start and end timestamps for the <span class="No-Break">complete trace</span></li>
			</ul>
			<p> A span commonly<a id="_idIndexMarker186"/> has the <span class="No-Break">following fields:</span></p>
			<ul>
				<li><strong class="bold">Trace identifier</strong>: Establishes the <span class="No-Break">trace relationship</span></li>
				<li><strong class="bold">Identifier</strong>: Uniquely identifies <span class="No-Break">the span</span></li>
				<li><strong class="bold">Parent span identifier</strong>: Establishes a <span class="No-Break">parent relationship</span></li>
				<li><strong class="bold">Name</strong>: Describes the work <span class="No-Break">being recorded</span></li>
				<li><strong class="bold">Timing details</strong>: Provides the start and <span class="No-Break">end</span><span class="No-Break"><a id="_idIndexMarker187"/></span><span class="No-Break"> timestamps</span></li>
			</ul>
			<p>A trace identifier will be automatically<a id="_idIndexMarker188"/> generated if one has not been received by the calling operation; each application will pass the trace ID along to <span class="No-Break">the next.</span></p>
			<p>The start and end timestamps for the operation help identify which stages are taking the most time. You can drill down to identify dependencies on other services and how they contribute to the overall <span class="No-Break">trace timings.</span></p>
			<p>Spans can often have additional fields<a id="_idIndexMarker189"/> that are specific to the protocol implemented. Investigating the options against your use case will help provide the right diagnostics for <span class="No-Break">your system.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor055"/>Tracing protocols</h2>
			<p>As with all technology, standards<a id="_idIndexMarker190"/> have taken a while to be formalized for tracing, and a few protocols have been implemented. Some common protocols<a id="_idIndexMarker191"/> that are in use today are described in the <span class="No-Break">following table:</span></p>
			<table id="table006" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Protocol Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Features</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">OTLP</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It supports <span class="No-Break">the following:</span></p>
							<ul>
								<li><span class="No-Break">Additional fields</span></li>
								<li>Span attributes (metadata about <span class="No-Break">the operation)</span></li>
								<li><span class="No-Break">Context propagation</span></li>
								<li>Span events (meaningful <span class="No-Break">point-in-time annotation)</span></li>
								<li>Span links (imply a causal relationship <span class="No-Break">between spans)</span></li>
								<li>Span kind (additional details supporting the assembly of <span class="No-Break">a trace)</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Zipkin</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It supports <span class="No-Break">the following:</span></p>
							<ul>
								<li><span class="No-Break">Additional fields</span></li>
								<li>Span tags (metadata about <span class="No-Break">the operation)</span></li>
								<li><span class="No-Break">Context propagation</span></li>
								<li>Span annotations (such as OTLP events and meaningful <span class="No-Break">point-in-time annotation)</span></li>
								<li>Span kind (additional details supporting the assembly of <span class="No-Break">a trace)</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Jaeger</span></p>
						</td>
						<td class="No-Table-Style">
							<p>It supports two formats – Jaeger Thrift and Jaeger Proto – with similar characteristics. Jaeger Proto has been discontinued in favor <span class="No-Break">of OTLP.</span></p>
							<p>It supports <span class="No-Break">the following:</span></p>
							<ul>
								<li><span class="No-Break">Additional fields</span></li>
								<li>Span tags (metadata about <span class="No-Break">the operation)</span></li>
								<li>Context propagation (Thrift only; Proto does not <span class="No-Break">support this)</span></li>
								<li>Span logs (meaningful <span class="No-Break">point-in-time annotation)</span></li>
								<li>Span references (imply a causal relationship <span class="No-Break">between spans)</span></li>
								<li>Span kind (similar to OTLP, this is stored as a special type of <span class="No-Break">span tag)</span></li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.6 – Distributed tracing protocols and features</p>
			<p>Implementing distributed tracing can be a daunting task, so let’s discuss some best practices that will help you avoid common mistakes <span class="No-Break">and issues.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor056"/>Best practices for setting up distributed tracing</h2>
			<p>So far, we have described<a id="_idIndexMarker192"/> how traces will help you with problem resolution. However, when producing traces, it’s worth considering the additional system visibility against cost and performance impacts. Let’s discuss some of the best practices that should be considered when implementing tracing on any application <span class="No-Break">or system.</span></p>
			<h3>Performance</h3>
			<p>The process of generating trace<a id="_idIndexMarker193"/> information can potentially incur a performance overhead at the application level. Mix this with the reduced level of control with auto-instrumentation and the problem <span class="No-Break">can increase.</span></p>
			<p>Here are some of the possible impacts <span class="No-Break">to consider:</span></p>
			<ul>
				<li><span class="No-Break">Increased latency</span></li>
				<li><span class="No-Break">Memory overhead</span></li>
				<li>Slower <span class="No-Break">startup time</span></li>
			</ul>
			<p>Some of the more recent observability agents have addressed a lot of the issues with configurable options. For example, the OpenTelemetry Collector offers a sampling configuration that will submit 0% to 100% of spans to the collection tool. This sampling implementation will also notify any downstream services that the parent sampled its span so that the full trace will <span class="No-Break">be collected.</span></p>
			<h3>Cost</h3>
			<p>Increased network and storage costs<a id="_idIndexMarker194"/> can become a factor and need factoring in as a limitation when designing your observability solution. However, this does depend on your observability backend and if you are doing additional processing or filtering when the data is <span class="No-Break">being transmitted.</span></p>
			<p>The mitigation practices<a id="_idIndexMarker195"/> are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sampling</strong>: Only sends a percentage <span class="No-Break">of traces</span></li>
				<li><strong class="bold">Filtering</strong>: Restricts which traces are transmitted <span class="No-Break">and stored</span></li>
				<li><strong class="bold">Retention</strong>: Sets optimal data <span class="No-Break">storage durations</span></li>
			</ul>
			<h3>Accuracy</h3>
			<p>To ensure one of the major benefits<a id="_idIndexMarker196"/> of tracing is implemented, it is important to ensure context propagation is working correctly. Without the relationships being established between the operations, spans will be broken across multiple traces. Validating and solving this problem will increase the usability and adoption of tracing for fast <span class="No-Break">issue resolution.</span></p>
			<p>With most code, libraries are used so that developers can focus on writing code that provides value to the organization. The modern libraries that are available will help you instrument quickly so that you can start using the data collected from your application. We’ll explore <span class="No-Break">this next.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor057"/>Using libraries to instrument efficiently</h1>
			<p>Instrumenting your application code<a id="_idIndexMarker197"/> to emit the telemetry of logs, metrics, and traces<a id="_idIndexMarker198"/> can be complex, time-consuming, and difficult to maintain. There are two main approaches to solving this problem – automatic instrumentation and manual instrumentation – with a wide selection of SDKs and libraries available to support them. Here is a brief overview <span class="No-Break">of them:</span></p>
			<ul>
				<li><strong class="bold">Automatic instrumentation</strong>: Automatic instrumentation<a id="_idIndexMarker199"/> is the simplest to implement but can lack the level of control that’s often required when building an observability platform. In a very short space of time, it will provide visibility into your application and help you start answering your observability questions. Without careful configuration and design, this will lead to other problems such as performance and cost issues, and, in the worst case, render the observability <span class="No-Break">platform useless.</span><p class="list-inset">The approach varies depending on the programming language; for example, code manipulation (during compilation or at runtime) is often used with Java, whereas monkey<a id="_idIndexMarker200"/> patching (updating behavior dynamically at runtime) is often used with Python <span class="No-Break">and JavaScript.</span></p></li>
				<li><strong class="bold">Manual instrumentation</strong>: Manual instrumentation can be quite complex, depending on the systems<a id="_idIndexMarker201"/> being instrumented. It requires an intimate knowledge of the application code, with the benefit of allowing you to specify exactly what telemetry you want. Additionally, you need to understand the observability API you are working with. Though SDKs and libraries have simplified this, a lot of work must be done to understand <span class="No-Break">the implementation.</span></li>
			</ul>
			<p>If you are interested in further reading about application instrumentation, there is an excellent section dedicated to the subject in Alex Boten’s book <em class="italic">Cloud-Native Observability with OpenTelemetry</em>, by <span class="No-Break">Packt Publishing.</span></p>
			<p>Now that we’ve seen<a id="_idIndexMarker202"/> how various<a id="_idIndexMarker203"/> libraries approach instrumentation, let’s look at some of the common libraries that are used in <span class="No-Break">different languages.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>Popular libraries for different programming languages</h2>
			<p>There have been many telemetry<a id="_idIndexMarker204"/> solutions, SDKs, and libraries over the years; however, in more recent history, there has been a concerted effort to align on supporting the OpenTelemetry standard. With its goal to provide a set of standardized vendor-agnostic SDKs, APIs, and tools for ingesting, transforming, and transporting data to an observability backend platform, there are obvious benefits. We will look at the OpenTelemetry libraries in this section to focus on where the most enhancements are currently. However, investigating what is appropriate for your use case is important. One drawback of this concerted development effort is that it creates a fast-changing landscape, so you have to pay attention to release stability and monitor for changes <span class="No-Break">and improvements.</span></p>
			<p>Here are some of the available<a id="_idIndexMarker205"/> <span class="No-Break">instrumentation libraries:</span></p>
			<table id="table007" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Language</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">SDKs </strong><span class="No-Break"><strong class="bold">and Libraries</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Notes</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">JavaScript</span></p>
						</td>
						<td class="No-Table-Style">
							<p>OpenTelemetry <span class="No-Break">JavaScript SDK</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Multiple resources and examples are available that cover Node.js and <span class="No-Break">browser implementations.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">JavaScript</span></p>
						</td>
						<td class="No-Table-Style">
							<p>OpenTelemetry <span class="No-Break">JavaScript Contrib</span></p>
						</td>
						<td class="No-Table-Style">
							<p>An additional repository for OpenTelemetry JavaScript contributions that are not part of the core repository and core distribution of the API and <span class="No-Break">the SDK.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Python</span></p>
						</td>
						<td class="No-Table-Style">
							<p>OpenTelemetry <span class="No-Break">Python SDK</span></p>
						</td>
						<td class="No-Table-Style">
							<p>At the time of writing, both traces and metrics are stable, with logs in an <span class="No-Break">experimental state.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Python</span></p>
						</td>
						<td class="No-Table-Style">
							<p>OpenTelemetry <span class="No-Break">Python Contrib</span></p>
						</td>
						<td class="No-Table-Style">
							<p>An additional repository for OpenTelemetry Python contributions. At the time of writing, Contrib libraries are in beta and <span class="No-Break">active development.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Java</span></p>
						</td>
						<td class="No-Table-Style">
							<p>OpenTelemetry <span class="No-Break">Java SDK</span></p>
						</td>
						<td class="No-Table-Style">
							<p>There is a long list of supported libraries and frameworks with good documentation to get <span class="No-Break">you started.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Java</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Spring Boot/Micrometer</span></p>
						</td>
						<td class="No-Table-Style">
							<p>As of Spring Boot 3, the default exporter for Micrometer <span class="No-Break">is OTLP.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.7 – Common libraries and SDKs for telemetry</p>
			<p>Applications are only one part of the computer systems we work with today. Our infrastructure components, such as switches, servers, Kubernetes clusters, and more, are just as important to observe. We’ll discuss how we can do this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>Infrastructure data technologies</h1>
			<p>So far in this chapter, we have focused<a id="_idIndexMarker206"/> on implementations that work well for cloud technologies and containerized platforms. Underneath all of the abstraction are physical components, the servers running the workloads, the network and security devices handling communications, and the power and cooling components that keep things running. These have not dramatically changed over time and neither has the telemetry reported by the logs and metrics. Let’s take a look at the common infrastructure components and standards used in <span class="No-Break">this area.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>Common infrastructure components</h2>
			<p>Infrastructure can largely be categorized<a id="_idIndexMarker207"/> into some broad categories, as we will discuss in the following sections. The types of data you can collect will differ on the category of <span class="No-Break">the component.</span></p>
			<h3>Compute or bare metal</h3>
			<p>Servers are often referred to as <strong class="bold">bare metal</strong> or compute; these are physical devices<a id="_idIndexMarker208"/> that are used for computation. Often, these systems would run<a id="_idIndexMarker209"/> virtualized operating systems that can collect server telemetry. Usually, you will run an agent on the operating system that scrapes metrics or reads log files and then transports them to a receiver. The data that’s obtained from server equipment can not only help in diagnosing and responding to issues but can help predict capacity problems that may arise in the future. Often, these devices can send data outside of any virtual operating system <span class="No-Break">as well.</span></p>
			<p>For instance, here are a few telemetry examples<a id="_idIndexMarker210"/> that can indicate if a system is close to capacity in <span class="No-Break">any area:</span></p>
			<ul>
				<li><span class="No-Break">System temperature</span></li>
				<li>CPU <span class="No-Break">utilization percent</span></li>
				<li>Overall disk space used <span class="No-Break">and remaining</span></li>
				<li>Memory usage<a id="_idIndexMarker211"/> and <span class="No-Break">free memory</span></li>
			</ul>
			<h3>Network devices</h3>
			<p>Network and security devices such as switches <a id="_idIndexMarker212"/>and firewalls come<a id="_idIndexMarker213"/> with the capability to send monitoring information via SNMP to a receiver. Firewalls can often send Syslog-formatted logs to a receiver. The telemetry provided helps diagnose issues with connectivity – for example, latency and throughput are difficult to investigate without information from <span class="No-Break">the hardware.</span></p>
			<p>Here are some <a id="_idIndexMarker214"/><span class="No-Break">telemetry examples:</span></p>
			<ul>
				<li><span class="No-Break">Latency</span></li>
				<li><span class="No-Break">Throughput</span></li>
				<li><span class="No-Break">Packet loss</span></li>
				<li><span class="No-Break">Bandwidth</span></li>
			</ul>
			<h3>Power components</h3>
			<p>The components<a id="_idIndexMarker215"/> that provide power or cooling are often built<a id="_idIndexMarker216"/> with the capability to emit telemetry over SNMP to a receiver. Some older components will implement the Modbus protocol and expose registers that can be read to obtain metrics. The telemetry reported at this level is simplistic but essential when you are operating your data center. If, for example, you are running on backup power, you need to react fast to protect the systems or trigger other <span class="No-Break">mitigation activities.</span></p>
			<p>Here are some <a id="_idIndexMarker217"/><span class="No-Break">telemetry examples:</span></p>
			<ul>
				<li>Power <span class="No-Break">supply state</span></li>
				<li>Backup power <span class="No-Break">supply state</span></li>
				<li><span class="No-Break">Voltage</span></li>
				<li><span class="No-Break">Wattage</span></li>
				<li><span class="No-Break">Current</span></li>
			</ul>
			<p>As infrastructure components have been used for many years, there are some agreed-upon standards for data structures and transmission. Let’s look at those original <span class="No-Break">standards now.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor061"/>Common standards for infrastructure components</h2>
			<p>There are a few well-established standards that are used by infrastructure components that you may need to monitor. These include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Syslog</strong>: Syslog has been around since<a id="_idIndexMarker218"/> the 1980s and is very common<a id="_idIndexMarker219"/> in infrastructure components. Created as part of the <strong class="bold">Sendmail project</strong> by Eric Allman, it was quickly adopted and became the standard logging <a id="_idIndexMarker220"/>solution on Unix-like platforms. It is very popular because of its ease of use. To use Syslog, you need a client available to receive the data, and each device needs to be configured to send data there. Common clients include RSyslog and Syslog-ng, and the OpenTelemetry Collector also supports <span class="No-Break">this protocol.</span><p class="list-inset">The Syslog message format provides a structured framework that has allowed organizations to provide vendor-specific extensions. Contributing to its success and longevity, most modern observability tooling providers still supply an interface to receive Syslog messages. The logs can then be accessed and analyzed alongside other system and <span class="No-Break">application telemetry.</span></p></li>
				<li><strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>): Forming part of the original Internet Protocol<a id="_idIndexMarker221"/> suite defined by the <strong class="bold">Internet Engineering Task Force</strong> (<strong class="bold">IETF</strong>), SNMP is commonly used in networking<a id="_idIndexMarker222"/> infrastructure. A lot of the protocol is not of interest<a id="_idIndexMarker223"/> for observability, but <strong class="bold">SNMP Traps</strong> allow devices to inform the manager<a id="_idIndexMarker224"/> about <span class="No-Break">significant events.</span><p class="list-inset">SNMP provides a common mechanism for network devices to relay management and, specifically in the context of this chapter, monitoring information within single and multi-vendor LAN or WAN environments. It is different from other telemetry receivers as it requires more specific knowledge of the devices on the network, and specific configurations for the metrics to be collected. Here are some examples<a id="_idIndexMarker225"/> of data that can be collected <span class="No-Break">from SNMP:</span></p><table id="table008" class="No-Table-Style _idGenTablePara-1"><colgroup><col/><col/></colgroup><tbody><tr class="No-Table-Style"><td class="No-Table-Style"><p><span class="No-Break"><strong class="bold">Data Type</strong></span></p></td><td class="No-Table-Style"><p><strong class="bold">Example </strong><span class="No-Break"><strong class="bold">Metrics Collected</strong></span></p></td></tr><tr class="No-Table-Style"><td class="No-Table-Style"><p><span class="No-Break">Network data</span></p></td><td class="No-Table-Style"><p><span class="No-Break">Processes</span></p><p><span class="No-Break">Uptime</span></p><p><span class="No-Break">Throughput</span></p></td></tr><tr class="No-Table-Style"><td class="No-Table-Style"><p><span class="No-Break">Device data</span></p></td><td class="No-Table-Style"><p><span class="No-Break">Memory usage</span></p><p><span class="No-Break">CPU usage</span></p><p><span class="No-Break">Temperature</span></p></td></tr></tbody></table></li>
			</ul>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Table 2.8 – Example SNMP Trap information</p>
			<p>You may encounter other formats out in the wide world of engineering. We have covered a lot of the common formats here and have hopefully given you an indication of the types of information you will need to help you work with telemetry in Grafana. Grafana will handle just about whatever you can throw at it. Knowing what’s important and preparing for that will help you when you’re building your visualizations and alerts on that data. Now, let’s quickly recap what we’ve covered in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor062"/>Summary</h1>
			<p>In this chapter, we explored the foundations that modern observability is built on. This will serve as easy reference and support for future chapters in this book and your own projects. First, we looked at the common log formats and their examples, which will assist us in <a href="B18277_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Looking at Logs with Grafana Loki</em>. Then, we took a closer look at metrics, their differing types, some example protocols, and best practices to consider when designing metric-based observability. What we covered here will help with <a href="B18277_05.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Monitoring with Metrics Using Grafana Mimir and Prometheus</em>. We then moved on to traces and spans, where we looked at current protocols and some best practices to consider when building an efficient and effective trace-based observability platform. This section lays the groundwork for <a href="B18277_06.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Tracing Technicalities with Grafana Tempo</em>. After looking at the telemetry of observability, we learned about application instrumentation, which we will see more of in <a href="B18277_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Setting Up a Learning Environment with Demo Applications</em>, and later chapters where we go into specifics with logs, metrics, and traces. Lastly, we considered some of the more traditional <span class="No-Break">infrastructure telemetry.</span></p>
			<p>With the overview of application and infrastructure instrumentation complete, we can now start playing with logs, metrics, and traces. In the next chapter, we will get our learning environment up <span class="No-Break">and running.</span></p>
		</div>
	</body></html>