- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Your Containers in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is probably the most important one in this book. Here, we are going
    to discuss the concept of **Pods**, which are the objects Kubernetes uses to launch
    your application containers. Pods are at the heart of Kubernetes and mastering
    them is essential.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Installing your First Kubernetes Cluster*, we said that the
    Kubernetes API defines a set of resources representing a computing unit. Pods
    are resources that are defined in the Kubernetes API that represent one or several
    containers. We never create containers directly with Kubernetes, but we always
    create Pods, which will be *converted* into containers on a compute node in our
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: At first, it can be a little difficult to understand the connection between
    Kubernetes Pods and containers, which is why we are going to explain what Pods
    are and why we use them rather than containers directly. A Kubernetes Pod can
    contain one or more application containers. In this chapter, however, we will
    focus on Kubernetes Pods that contain only one container. We will then have the
    opportunity to discover Pods that contain several containers in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will create, delete, and update Pods using the **BusyBox** image, which is
    a Linux-based image containing many utilities useful for running tests. We will
    also launch a Pod based on the NGINX container image to launch an HTTP server.
    We will explore how to access the default NGINX home page via a feature that `kubectl`
    exposes called port forwarding. It’s going to be useful to access and test the
    Pods running on your Kubernetes cluster from your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will discover how to label and annotate our Pods to make them easily
    accessible. This will help us organize our Kubernetes cluster so that it’s as
    clean as possible. Finally, we will discover two additional resources, which are
    **Jobs** and **CronJobs**. By the end of this chapter, you will be able to launch
    your first containers managed by Kubernetes, which is the first step in becoming
    a Kubernetes master!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain the notion of Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching your first Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labeling and annotating the Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching your first Job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching your first CronJob
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A properly configured Kubernetes cluster so that you can practice the commands
    shown as you read. Whether it’s a minikube, Kind, GKE, EKS, or AKS cluster is
    not important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working `kubectl` installation on your local machine. You can have more than
    one node if you want, but at least one `Ready` node is required to have a working
    Kubernetes setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain the notion of Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explain the concept of Pods from a theoretical point
    of view. Pods have certain peculiarities that must be understood if you wish to
    master them well.
  prefs: []
  type: TYPE_NORMAL
- en: What are Pods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to create, update, or delete a container through Kubernetes,
    you do so through a Pod. A Pod is a group of one or more containers that you want
    to launch on the same machine, in the same Linux namespace. That’s the first rule
    to understand about Pods: they can be made up of one or more containers but all
    the containers that belong to the same Pod will be launched on the same worker
    node. A Pod cannot and *won’t ever* span across multiple worker nodes: that’s
    an absolute rule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But why do we bother delegating the management of our containers to this intermediary
    resource? After all, Kubernetes could have a container resource that would just
    launch a single container. The reason is that containerization invites you to
    think in terms of Linux processes rather than in terms of virtual machines. You
    may already know about the biggest and most recurrent container anti-pattern,
    which consists of using containers as virtual machine replacements: in the past,
    you used to install and deploy all your processes on top of a virtual machine.
    But containers are no virtual machine replacements, and they are not meant to
    run multiple processes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Container technology invites you to follow one golden rule: *there should be
    a one-to-one relationship between a container and a Linux process*. That being
    said, modern applications are often made up of multiple processes, not just one,
    so in most cases, using only one container won’t suffice to run a full-featured
    microservice. This implies that the processes, and thus the containers, should
    be able to communicate with each other by sharing file systems, networking, and
    so on. That’s what Kubernetes Pods offer you: the ability to group your containers
    logically. All the containers/processes that make up an application should be
    grouped in the same Pod. That way, they’ll be launched together and benefit from
    all the features when it comes to facilitating inter-process and inter-container
    communications.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Containers and Pods'
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand this, imagine you have a working WordPress blog on a
    virtual machine and you want to convert that virtual machine into a WordPress
    Pod to deploy your blog on your Kubernetes cluster. WordPress is one of the most
    common pieces of software and is a perfect example to illustrate the need for
    Pods. This is because WordPress requires multiple processes to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'WordPress is a PHP application that requires both a web server and a PHP interpreter
    to work. Let’s list what Linux processes WordPress needs to work on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An NGINX HTTP server**: It’s a web application, so it needs an HTTP server
    running as a process to receive and serve server blog pages. NGINX is a good HTTP
    server that will do the job perfectly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The PHP-FastCGI-Process-Manager (FPM) interpreter**: It’s a blog engine written
    in PHP, so it needs a PHP interpreter to work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NGINX and PHP-FPM are two processes: they are two binaries that you need to
    launch separately, but they need to be able to work together. On a virtual machine,
    the job is simple: you just install NGINX and **PHP-FPM** on the virtual machine
    and have both of them communicate through Unix sockets. You can do this by telling
    NGINX that the Linux socket PHP-FPM is accessible thanks to the `/etc/nginx.config`
    configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the container world, things become harder because running these two processes
    in the same container is an anti-pattern: you have to run two containers, one
    for each process, and you must have them communicate with each other and share
    a common directory so that they can both access the application code. To solve
    this problem, you have to use the Docker networking layer to have the NGINX container
    be able to communicate with the PHP-FPM one. Then, you must use a volume mount
    to share the WordPress code between the two containers. You can do this with some
    Docker commands but imagine it now in production at scale, on multiple machines,
    on multiple environments, and so on. Achieving inter-process communication is
    possible with bare Docker, but that’s difficult to achieve at scale while keeping
    all the production-related requirements in mind. With tons of microservices to
    manage and spread on different machines, it would become a nightmare to manage
    all these Docker networks, volume mounts, and so on. As you can imagine, that’s
    the kind of problem the Kubernetes Pod resource solves. Pods are very useful because
    they wrap multiple containers and enable easy inter-process communication. The
    following are the core benefits Pods bring you:'
  prefs: []
  type: TYPE_NORMAL
- en: All the containers in the same Pod can reach each other through localhost as
    they share the same network namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the containers in the same Pod share the same port space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can attach a volume to a Pod, and then mount the volume to underlying containers,
    allowing them to share directories and file locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the benefits Kubernetes brings you, it would be super easy to provision
    your WordPress blog as you can create a Pod that will run two containers: NGINX
    and PHP-FPM. Since they both can access each other on localhost, having them communicate
    is super easy. You can then use a volume to expose WordPress’s code to both containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most complex applications will forcibly require several containers, so
    it’s a good idea to group them in the same Pod to have Kubernetes launch them
    together. Keep in mind that the Pod is here for only one reason: to ease inter-container
    (or inter-process) communications at scale.'
  prefs: []
  type: TYPE_NORMAL
- en: That being said, it is not uncommon at all to have Pods that are only made up
    of one container. But in any case, the Pod is the lowest level of abstraction
    provided by the Kubernetes APIs and the one you will interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, please note that a container that was launched manually on a machine
    managed by a Kubernetes cluster won’t be seen by Kubernetes as a container it
    manages. It becomes a kind of *orphan* container outside of the scope of the orchestrator.
    Kubernetes only manages the container it has launched through its Pod API.
  prefs: []
  type: TYPE_NORMAL
- en: Each Pod gets an IP address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers inside a single Pod are capable of communicating with each other
    through localhost, but Pods are also capable of communicating with each other.
    At launch time, each Pod gets a private IP address. Each Pod can communicate with
    any other Pod in the cluster by calling it through its IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses a flat network model that is implemented by a component called
    **Container Network Interface** (**CNI**). CNI acts as a standardized bridge between
    containerized applications and the underlying network infrastructure within Kubernetes
    clusters. This eliminates the need for custom networking configurations for each
    container, streamlining communication and data flow.
  prefs: []
  type: TYPE_NORMAL
- en: CNI leverages a flexible plugin-based architecture. These plugins, written in
    various languages, communicate with the container runtime using standard input/output.
    The plugin specification defines a clear interface for network configuration,
    IP address provisioning, and maintaining connections across multiple hosts. Container
    runtimes call upon these plugins, enabling dynamic management and updates to container
    networks within the Kubernetes environment. This approach ensures seamless and
    adaptable networking for your containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the high-level communication flow between Pods and
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Container and Pod communication'
  prefs: []
  type: TYPE_NORMAL
- en: How should you design your Pods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While understanding Pods is crucial, in the real world of Kubernetes, most
    teams leverage a more powerful construct: Deployment. Deployments provide a higher-level
    abstraction for managing Pods. They automate tasks like scaling and restarting
    Pods in case of failures, ensuring a more robust and manageable application experience.
    We’ll delve deeper into deployments in a moment, but for now, let’s explore the
    Pods API to solidify your understanding of these foundational building blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is the second golden rule about Pods: they are meant to be destroyed
    and recreated easily. Pods can be destroyed voluntarily or not. For example, if
    a given worker node running four Pods were to fail, each of the underlying containers
    would become inaccessible. Because of this, you should be able to destroy and
    recreate your Pods at will, without it affecting the stability of your application.
    The best way to achieve this is to respect two simple design rules when building
    your Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: A Pod should contain everything required to launch an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pod should store any kind of state outside of the Pod using external storage
    (PersistentVolume).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you start designing Pods on Kubernetes, it’s hard to know exactly what
    a Pod should and shouldn’t contain. It’s pretty straightforward to explain: a
    Pod has to contain an application or a microservice. Take the example of our WordPress
    Pod, which we mentioned earlier: the Pod should contain the NGINX and PHP-FPM
    containers, which are required to launch WordPress. If such a Pod were to fail,
    our WordPress would become inaccessible, but recreating the Pod would make WordPress
    accessible again because the Pod contains everything necessary to run WordPress.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, every modern application stores its state outside by utilizing
    external storage, database storage, such as Redis or MySQL, or by calling another
    microservice application to store the state. WordPress on its own does that too
    – it uses MySQL (or MariaDB) to store and retrieve your post. So, you’ll also
    have to run a MySQL container somewhere. Two solutions are possible here:'
  prefs: []
  type: TYPE_NORMAL
- en: You run the MySQL container as part of the WordPress Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You run the MySQL container as part of a dedicated MySQL Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both solutions can be used, but the second is preferred. It’s a good idea to
    decouple your application (here, this is WordPress, but tomorrow, it could be
    a microservice) from its database or logic layer by running them in two separate
    Pods. Remember that Pods are capable of communicating with each other. You can
    benefit from this by dedicating a Pod to running MySQL and giving its Pod IP address
    to your WordPress blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'By separating the database layer from the application, you improve the stability
    of the setup: the application Pod crashing will not affect the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, grouping the application layers in the same Pods would cause
    three problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Data durability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s why it is recommended to keep your application Pods stateless as much
    as possible, by storing their states in an independent Pod. By treating the data
    layer as a separate application with its own development and management life cycle,
    we can achieve a decoupled architecture. This separation allows for independent
    scaling, updates, and testing of the data layer without impacting the application
    code itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateful monolithic applications**'
  prefs: []
  type: TYPE_NORMAL
- en: Despite some niche possibilities, running fast-moving monolithic stateful workloads
    on Kubernetes in 2024 is generally discouraged due to the complexity of managing
    monolithic applications within containers, potential inefficiencies for frequent
    updates in fast-paced environments, and increased management overhead for persistent
    storage needs compared to traditional deployments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing Pods via an IP address**'
  prefs: []
  type: TYPE_NORMAL
- en: You can access Pods using their IP addresses; however, this is not the recommended
    method for interacting with running applications. In upcoming chapters, we will
    delve into the Service resource, which plays a crucial role in mapping IP addresses
    to Pods. Stay tuned for a detailed explanation of how Services enhance Pod accessibility
    and application communication.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s launch our first Pod. Creating a WordPress Pod would be too complex
    for now, so let’s start easy by launching some NGINX Pods and see how Kubernetes
    manages the container.
  prefs: []
  type: TYPE_NORMAL
- en: Launching your first Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explain how to create our first Pods in our Kubernetes
    cluster. Pods have certain peculiarities that must be understood to master them
    well.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to create a resource on your Kubernetes cluster at the moment;
    instead, we are simply going to explain what Pods are. In the next section, we’ll
    start building our first Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Pod with imperative syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to create a Pod based on the NGINX image. We
    need two parameters to create a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: The Pod’s name, which is arbitrarily defined by you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container images to build its underlying containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with almost everything on Kubernetes, you can create Pods using either of
    the two syntaxes available: the imperative syntax and the declarative syntax,
    which you have learned about in *Chapter 2*, *Kubernetes Architecture – from Container
    Images to Running Pods*. As a reminder, the imperative syntax is to run `kubectl`
    commands directly from a terminal, while with declarative syntax, you must write
    a YAML file containing the configuration information for your Pod, and then apply
    it with the `kubectl apply -f` command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Pod on your Kubernetes cluster, you have to use the `kubectl run`
    command. That’s the simplest and fastest way to get a Pod running on your Kubernetes
    cluster. Here is how the command can be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, the Pod’s name is set to `nginx-pod`. This name is important
    because it is a pointer to the Pod: when you need to run the `update` or `delete`
    command on this Pod, you’ll have to specify that name to tell Kubernetes which
    Pod the action should run on. The `--image` flag will be used to mention the container
    that this Pod will run. Once the Pod is created by the cluster, the status can
    be checked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Standing up a Pod isn’t instantaneous. Kubernetes might need to pull the container
    image from a registry if it’s not available locally and configure the Pod’s environment.
    To track this process in real time, use `kubectl get po -w`, which shows Pod information
    and refreshes automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you are telling Kubernetes to build a Pod based on the `nginx:latest`
    container image hosted on Docker Hub. This `nginx-pod` Pod contains only one container
    based on this `nginx:latest` image: you cannot specify multiple images here; this
    is a limitation of the imperative syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to build a Pod containing multiple containers built from several
    different container images, then you will have to go through the declarative syntax
    and write a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Tags versus digests – ensuring image consistency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While creating Pods, you might encounter references to tags and digests. Both
    are used to identify container images, but with a key difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tags**: Think of tags as human-readable names for image versions. They can
    be changed to point to different versions of the same image, potentially causing
    unexpected behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digests**: These are unique fingerprints of an image, ensuring you always
    reference the exact desired version. This is crucial for security and reproducibility,
    especially in light of potential software supply chain attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, instead of using `nginx:latest` `(tag)`, you might use `nginx@sha256:1445eb9c6dc5e9619346c836ef6fbd6a95092e4663f27dcfce116f051cdbd232`
    (digest). You can fetch the digest information for the container image from the
    registry itself or by using the `podman manifest inspect nginx:latest` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Fetching image digest from a container registry'
  prefs: []
  type: TYPE_NORMAL
- en: This guarantees you’re deploying the specific image version with the unique
    `abcd1234` hash. This practice is becoming increasingly important for secure and
    reliable deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Let us learn how to create Pods using YAML declarations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Pod with declarative syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a Pod with declarative syntax is simple too. You have to create a YAML
    file containing your Pod definition and apply it against your Kubernetes cluster
    using the `kubectl apply -f` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that Kubernetes cannot run two Pods with the same name in the same
    namespace (e.g., the `default` namespace in our case): the Pod’s name is the unique
    identifier and is used to identify the Pods within a namespace. You need to delete
    the existing Pod that you created in the previous step before you create a new
    Pod with the same name in the same namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the content of the `nginx-pod.yaml` file, which you can create on your
    local workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Try to read this file and understand its content. YAML files are only key-value
    pairs. The Pod’s name is `nginx-Pod`, and then we have an array of containers
    in the `spec:` part of the file containing only one container created from the
    `nginx:latest` image. The container itself is named `nginx-container`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `nginx-Pod.yaml` file has been saved, run the following command to
    create the Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If a Pod called `nginx-pod` already exists in your cluster, this command will
    fail. Try to edit the YAML file to update the Pod’s name and then apply it again.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces in Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you omit to specify a namespace during resource creation, it defaults to
    the default namespace. Stay tuned for *Chapter 6*, *Namespaces, Quotas, and Limits
    for Multi-Tenancy in Kubernetes*, where we’ll delve into the significance of Kubernetes
    namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Pod’s information and metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you should have a running Pod on your Kubernetes cluster. Here,
    we are going to try to read its information. At any time, we need to be able to
    retrieve and read information regarding the resources that were created on your
    Kubernetes cluster; this is especially true for Pods. Reading the Kubernetes cluster
    can be achieved using two `kubectl` commands: `kubectl get` and `kubectl describe`.
    Let’s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl get`: The `kubectl get` command is a list operation; you use this
    command to list a set of objects. Do you remember when we listed the nodes of
    your cluster after all the installation procedures described in the previous chapter?
    We did this using `kubectl get nodes`. The command works by requiring you to pass
    the object type you want to list. In our case, it’s going to be the `kubectl get
    pods` operation. In the upcoming chapters, we will discover other objects, such
    as `configmaps` and `secrets`. To list them, you’ll have to type `kubectl get
    configmaps`; the same goes for the other object types. For example, the `nginx-pod`
    can be listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`kubectl describe`: The `kubectl describe` command is quite different. It’s
    intended to retrieve a complete set of information for one specific object that’s
    been identified from both its kind and object name. You can retrieve the information
    of our previously created Pod by using `kubectl describe pods nginx-pod`. Calling
    this command will return a full set of information available about that specific
    Pod, such as its IP address. To see the details of `nginx-pod`, the following
    command can be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the preceding command output, you can read a lot of information, including
    the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pod name and namespace**: This identifies the specific Pod you requested
    information on (e.g., `nginx-pod`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container details**: This lists information about the containers within the
    Pod, including image name, resource requests/limits, and current state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod conditions**: This shows the current operational state of the Pod (e.g.,
    Running, Pending, CrashLoopBackOff).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**: This provides a history of relevant events related to the Pod’s
    life cycle, including creation, restarts, or errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s look at some more advanced options for listing and describing objects
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the objects in JSON or YAML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `-o` or `--output` option is one of the most useful options offered by
    the `kubectl` command line. This one has some benefits you must be aware of. This
    option allows you to customize the output of the `kubectl` command line. By default,
    the `kubectl get pods` command will return a list of the Pods in your Kubernetes
    cluster in a formatted way so that the end user can see it easily. You can also
    retrieve this information in JSON format or YAML format by using the `-o` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you know the Pod name, you can also get a specific Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can retrieve and export data from your Kubernetes cluster in a
    scripting-friendly format.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up your resource using the list operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use these flags to back up your Kubernetes resources. Imagine
    a situation where you created a Pod using the imperative way, so you don’t have
    the YAML declaration file stored on your computer. If the Pod fails, it’s going
    to be hard to recreate it. The `-o` option helps us retrieve the YAML declaration
    file of a resource that’s been created in Kubernetes, even if we created it using
    the imperative way. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, you have a YAML backup of the `nginx-pod` resource as it is running
    on your cluster. You can always compare the output file with the original YAML
    declaration and analyze the differences using the `diff` command or other utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are tools available to clean up the YAML and get a clean output of a usable
    declaration. For example, `kube-neat` is such a utility that will help to clean
    the unwanted information from the detailed output. Refer to [https://github.com/itaysk/kubectl-neat](https://github.com/itaysk/kubectl-neat)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: If something goes wrong, you’ll be able to recreate your Pod easily. Pay attention
    to the `nginx-pod` section of this command. To retrieve the YAML declaration,
    you need to specify which resource you are targeting. By redirecting the output
    of this command to a file, you get a nice way to retrieve and back up the configuration
    of the object inside your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Getting more information from the list operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s also worth mentioning the `-o` wide format, which is going to be very
    useful for you: using this option allows you to expand the default output to add
    more data. By using it on the `Pods` object, for example, you’ll get the name
    of the worker node where the Pod is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the `-o` option can take a lot of different parameters and
    that some of them are much more advanced, such as `jsonpath`, which allows you
    to directly execute sorting operations on top of a JSON body document to retrieve
    only specific information, just like the `jq` library you used previously if you
    have already written some bash scripts that deal with JSON parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a Pod from the outside world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you should have a Pod containing an NGINX HTTP server on your
    Kubernetes cluster. You should now be able to access it from your web browser.
    However, this is a bit complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, your Kubernetes cluster does not expose the Pod it runs to the
    outside world. For that, you will need to use another resource called a service,
    which we will cover in more detail in *Chapter 8*, *Exposing Your Pods with Services*.
    However, `kubectl` does offer a command for quickly accessing a running container
    on your cluster called `kubectl port-forward`. This is how you can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is quite easy to understand: we are telling `kubectl` to forward
    port `8080` on my local machine (the one running `kubectl`) to port `80` on the
    Pod identified by `pod/nginx-Pod`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubectl then outputs a message, telling you that it started to forward your
    local `8080` port to the `80` one of the Pod. If you get an error message, it’s
    probably because your local port `8080` is currently being used. Try to set a
    different port or simply remove the local port from the command to let `kubectl`
    choose a local port randomly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can launch your browser and try to reach the `http://localhost:<localport>`
    address, which in your case is `http://localhost:8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The NGINX default page running in a Pod and accessible on localhost,
    which indicates the port-forward command worked!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B22019_04_04.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: The NGINX default page running in a Pod and accessible on localhost,
    which indicates the port-forward command worked'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished the testing, use the *Ctrl + C* command to end the port
    forwarding task.
  prefs: []
  type: TYPE_NORMAL
- en: Entering a container inside a Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a Pod is launched, you can access the Pods it contains. Under Docker,
    the command to execute a command in a running container is called `docker exec`.
    Kubernetes copies this behavior via a command called `kubectl exec`. Use the following
    command to access our NGINX container inside `nginx-pod`, which we launched earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this command, you will be inside the NGINX container. You can
    do whatever you want here, just like with any other container. The preceding command
    assumes that the `bash` binary is installed in the container you are trying to
    access. Otherwise, the `sh` binary is generally installed on a lot of containers
    and might be used to access the container. Don’t be afraid to take a full binary
    path, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have finished testing, exit from the bash shell of the container using
    the `exit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'IMPORTANT: **Security and Non-Root Users in Containers**'
  prefs: []
  type: TYPE_NORMAL
- en: It’s generally recommended to run containers with a non-root user. You need
    to limit potential damage from vulnerabilities. If a vulnerability is exploited,
    a non-root user has less access to the system, reducing the impact. Also, follow
    the principle of least privilege, which grants only the necessary permissions
    for the container to function, minimizing its attack surface. We will explore
    the security context in *Chapter 18*, *Security in Kubernetes.*
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discover how to delete a Pod from a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting a Pod is super easy. You can do so using the `kubectl delete` command.
    You need to know the name of the Pod you want to delete. In our case, the Pod’s
    name is `nginx-pod`. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you do not know the name of the Pod, remember to run the `kubectl get pods`
    command to retrieve the list of the Pods and find the one you want to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also something you must know: if you have built your Pod with declarative
    syntax and you still have its YAML configuration file, you can delete your Pod
    without having to know the name of the container because it is contained in the
    YAML file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to delete the Pod using the declarative syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After you run this command, the Pod will be deleted in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all containers belonging to the Pod will be deleted. The container’s
    life cycle is bound to the life cycle of the Pod that launched it. If the Pod
    is deleted, the containers it manages will be deleted. Remember to always interact
    with the Pods and not with the containers directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have reviewed the most important aspects of Pod management, such
    as launching a Pod with the imperative or declarative syntax, deleting a Pod,
    and listing and describing them. Now, we will introduce one of the most important
    aspects of Pod management in Kubernetes: labeling and annotating.'
  prefs: []
  type: TYPE_NORMAL
- en: Labeling and annotating the Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now discuss another key concept of Kubernetes: labels and annotations.
    Labels are key-value pairs that you can attach to your Kubernetes objects. Labels
    are meant to tag your Kubernetes objects with key-value pairs defined by you.
    Once your Kubernetes objects have been labeled, you can build a custom query to
    retrieve specific Kubernetes objects based on the labels they hold. In this section,
    we are going to discover how to interact with labels through `kubectl` by assigning
    some labels to our Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: What are labels and why do we need them?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What label you define for your objects is up to you – there is no specific
    rule regarding this. These labels are attributes that will allow you to organize
    your objects in your Kubernetes cluster. To give you a very concrete example,
    you could attach a label called `environment = prod` to some of your Pods, and
    then use the `kubectl get pods` command to list all the Pods within that environment.
    So, you could list all the Pods that belong to your production environment in
    one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it can be achieved using the `--label` parameter, which can
    be shortened using its `-l` equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will list all the Pods holding a label called `environment` with
    a value of `production`. Of course, in our case, no Pods will be found since none
    of the ones we created earlier are holding this label. You’ll have to be very
    disciplined about labels and not forget to set them every time you create a Pod
    or another object, and that’s why we are introducing them quite early in this
    book: not only Pods but almost every object in Kubernetes can be labeled, and
    you should take advantage of this feature to keep your cluster resources organized
    and clean.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You use labels not only to organize your cluster but also to build relationships
    between your different Kubernetes objects: you will notice that some Kubernetes
    objects will read the labels that are carried by certain Pods and perform certain
    operations on them based on the labels they carry. If your Pods don’t have labels
    or they are misnamed or contain the wrong values, some of these mechanisms might
    not work as you expect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, using labels is completely arbitrary: there is no particular
    naming rule, nor any convention Kubernetes expects you to follow. Thus, it is
    your responsibility to use the labels as you wish and build your convention. If
    you are in charge of the governance of a Kubernetes cluster, you should enforce
    the usage of mandatory labels and build some monitoring rules to quickly identify
    non-labeled resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that labels are limited to 63 characters; they are intended to
    be short. Here are some label ideas you could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`environment` (`prod`, `dev`, `uat`, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stack` (`blue`, `green`, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tier` (`frontend` and `backend`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app_name` (`wordpress`, `magento`, `mysql`, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`team` (`business` and `developers`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels are not intended to be unique between objects. For example, perhaps you
    would like to list all the Pods that are part of the production environment. Here,
    several Pods with the same label key-value pair can exist in the cluster at the
    same time without posing any problem – it’s even recommended if you want your
    list query to work. For example, if you want to list all the resources that are
    part of the prod environment, a label environment such as `= prod` should be created
    on multiple resources. Now, let’s look at annotations, which are another way we
    can assign metadata to our Pods.
  prefs: []
  type: TYPE_NORMAL
- en: What are annotations and how do they differ from labels?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes also uses another type of metadata called **annotations**. Annotations
    are very similar to labels as they are also key-value pairs. However, annotations
    do not have the same use as labels. Labels are intended to identify resources
    and build relationships between them, while annotations are used to provide contextual
    information about the resource that they are defined on.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you create a Pod, you could add an annotation containing the
    email of the support team to contact if this app does not work. This information
    has its place in an annotation but has nothing to do with a label.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is highly recommended that you define labels wherever you can, you
    can omit annotations: they are less important to the operation of your cluster
    than labels. Be aware, however, that some Kubernetes objects or third-party applications
    often read annotations and use them as configuration. In this case, their usage
    of annotations will be explained explicitly in their documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to add and remove labels and annotations
    from Pods. We will also learn how to modify the labels of a Pod that already exists
    on a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the Pod based on the NGINX image that we used earlier. We will recreate
    it here with a label called `tier`, which will contain the `frontend` value. Here
    is the `kubectl` command to run for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a label can be assigned using the `--labels` parameter. You
    can also add multiple labels by using the `--labels` parameter and comma-separated
    values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `nginx` Pod will be created with two labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--labels` flag has a short version called `-l`. You can use this to make
    your command shorter and easier to read. Labels can be appended to a YAML Pod
    definition. Here is the same Pod, holding the two labels we created earlier, but
    this time, it’s been created with the declarative syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the file that was created at `~/labelled_pod.yaml`. The following
    `kubectl` command would create the Pod the same way as it was created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, running the command we used earlier should return at least one Pod
    – the one we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how we can list the labels attached to our Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Listing labels attached to a Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no dedicated command to list the labels attached to a Pod, but you
    can make the output of `kubectl get pods` a little bit more verbose. By using
    the `--show-labels` parameter, the output of the command will include the labels
    attached to the Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command does not run any kind of query based on the labels; instead, it
    displays the labels themselves as part of the output.
  prefs: []
  type: TYPE_NORMAL
- en: Adding or updating a label to/of a running Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve learned how to create Pods with labels, we’ll learn how to add
    labels to a running Pod. You can add, create, or modify the labels of a resource
    at any time using the `kubectl label` command. Here, we are going to add another
    label to our `nginx` Pod. This label will be called `stack` and will have a value
    of `blue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This command only works if the Pod has no label called `stack`. When the command
    is executed, it can only add a new tag and not update it. This command will update
    the Pod by adding a label called `stack` with a value of `blue`. Run the following
    command to see that the change was applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To update an existing label, you must append the `--overwrite` parameter to
    the preceding command. Let’s update the `stack=blue` label to make it `stack=green`;
    pay attention to the `overwrite` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the label should be updated. The `stack` label should now be equal to
    `green`. Run the following command to show the Pod and its labels again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Adding or updating labels using the `kubectl label` command might be dangerous.
    As we mentioned earlier, you’ll build relationships between different Kubernetes
    objects based on labels. By updating them, you might break some of these relationships
    and your resources might start to behave not as expected. That’s why it’s better
    to add labels when a Pod is created and keep your Kubernetes configuration immutable.
    It’s always better to destroy and recreate rather than update an already running
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we must do is learn how to delete a label attached to a running
    Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a label attached to a running Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like we added and updated the labels of a running Pod, we can also delete
    them. The command is a little bit trickier. Here, we are going to remove the label
    called `stack`, which we can do by adding a minus symbol (`-`) right after the
    label name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding that minus symbol at the end of the command might be quite strange,
    but running `kubectl get pods --show-labels` again should show that the `stack`
    label is now gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn about annotations in Kubernetes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes annotations are key-value pairs that you can attach to various Kubernetes
    objects such as Pods, Deployments, and Services. They allow you to add extra information
    to these objects without changing their core functionality. Unlike labels, which
    are used for identification and selection, annotations are designed to store additional
    data that can be used for human readability or by external tools. Annotations
    can include details such as configuration information or the creator’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s learn how to add annotations to a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply added the `tier:` `webserver` annotation, which can help us
    identify that this Pod is running an HTTP server. Just keep in mind that it’s
    a way to add additional metadata.
  prefs: []
  type: TYPE_NORMAL
- en: When you apply this new configuration, you can use the `kubectl replace -f`
    command to replace the existing Pod configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl replace` is a command used to update or replace existing Kubernetes
    resources using a manifest file. It offers a more forceful approach compared to
    `kubectl apply -f`. The `kubectl replace` command replaces the existing resource
    definition with the one specified in the manifest file. This essentially overwrites
    the existing resource configuration. Unlike `kubectl apply`, which might attempt
    to merge changes, `kubectl replace` aims for a complete replacement. This command
    can be helpful when you want to ensure a specific configuration for a resource,
    regardless of its current state. It’s also useful for situations where the resource
    definition might have become corrupted and needs to be replaced entirely.'
  prefs: []
  type: TYPE_NORMAL
- en: The name of an annotation can be prefixed by a DNS name. This is the case for
    Kubernetes components such as `kube-scheduler`, which must indicate to cluster
    users that this component is part of the Kubernetes core. The prefix can be omitted
    completely, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the annotations by using the `kubectl` `describe` Pod, `kubectl
    get po -o yaml`, or with the `jq` utility as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let us learn about Jobs in Kubernetes in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Launching your first Job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s discover another Kubernetes resource that is derived from Pods:
    the Job resource. In Kubernetes, a computing resource is a Pod, and everything
    else is just an intermediate resource that manipulates Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the case for the `Job` object, which is an object that will create one
    or multiple Pods to complete a specific computing task, such as running a Linux
    command.
  prefs: []
  type: TYPE_NORMAL
- en: What are Jobs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Job is another kind of resource that’s exposed by the Kubernetes API. In
    the end, a job will create one or multiple Pods to execute a command defined by
    you. That’s how jobs work: they launch Pods. You have to understand the relationship
    between the two: jobs are not independent of Pods, and they would be useless without
    Pods. In the end, the two things they are capable of are launching Pods and managing
    them. Jobs are meant to handle a certain task and then exit. Here are some examples
    of typical use cases for a Kubernetes Job:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking a backup of a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending an email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming some messages in a queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are tasks you do not want to run forever. You expect the Pods to be terminated
    once they have completed their task. This is where the Jobs resource will help
    you.
  prefs: []
  type: TYPE_NORMAL
- en: But why bother using another resource to execute a command? After all, we can
    create one or multiple Pods directly that will run our command and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is true. You can use a Pod based on a container image to run the command
    you want and that would work fine. However, jobs have mechanisms implemented at
    their level that allow them to manage Pods in a more advanced way. Here are some
    things that jobs are capable of:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Pods multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Pods multiple times in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrying to launch the Pods if they encountered any errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing a Pod after a specified number of seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another good point is that a job manages the labels of the Pods it will create
    so that you won’t have to manage the labels on those Pods directly.
  prefs: []
  type: TYPE_NORMAL
- en: All of this can be done without using jobs, but this would be very difficult
    to manage and that is the reason we have the Jobs resource in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a job with restartPolicy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since creating a job might require some advanced configurations, we are going
    to focus on declarative syntax here. This is how you can create a Kubernetes job
    through YAML. We are going to make things simple here; the job will just echo
    `Hello world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the `kind` resource, which tells Kubernetes that we need to
    create a job and not a Pod, as we did previously. Also, notice `apiVersion:`,
    which also differs from the one that’s used to create the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Job definition details and Pod template'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the job with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this job will create a Pod based on the `busybox` container
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will run the `echo 'Hello World'` command. Lastly, the `restartPolicy`
    option is set to `OnFailure`, which tells Kubernetes to restart the Pod or the
    container in case it fails. If the entire Pod fails, a new Pod will be relaunched.
    If the container fails (the memory limit has been reached or a non-zero exit code
    occurs), the individual container will be relaunched on the same node because
    the Pod will remain untouched, which means it’s still scheduled on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `restartPolicy` parameter can take two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Never`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnFailure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting it to `Never` will prevent the job from relaunching the Pods, even if
    it fails. When debugging a failing job, it’s a good idea to set `restartPolicy`
    to `Never` to help with debugging. Otherwise, new Pods might be recreated over
    and over, making your life harder when it comes to debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, there is little chance that our job was not successful since we
    only want to run a simple `Hello world`. To make sure that our job worked well,
    we can read the job logs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also retrieve the name of the Pod the job created using the `kubectl
    get pods` command. Then, we can use the `kubectl logs` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that our job has worked well since we can see the `Hello world`
    message displayed in the log of our Pod. However, what if it had failed? Well,
    this depends on `restartPolicy` – if it’s set to `Never`, then nothing would happen,
    and Kubernetes wouldn’t try to relaunch the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: However, if `restartPolicy` was set to `OnFailure`, Kubernetes would try to
    restart the job after 10 seconds and then double that time on each new failure.
    10 seconds, then 20 seconds, then 40 seconds, then 80 seconds, and so on. After
    6 minutes, Kubernetes would give up.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the job’s backoffLimit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the Kubernetes job will try to relaunch the failing Pod six times
    during the next six minutes after its failure. You can change this limitation
    by changing the `backoffLimit` option. Here is the updated YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This way, the job will only try to relaunch the Pods twice after its failure.
  prefs: []
  type: TYPE_NORMAL
- en: Running a task multiple times using completions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also instruct Kubernetes to launch a job multiple times using the `Job`
    object. You can do this by using the `completions` option to specify the number
    of times you want a command to be executed. The number of completions will create
    10 different Pods that will be launched one after the other in the following example.
    Once one Pod has finished, the next one will be started. Here is the updated YAML
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `completions` option was added here. Also, please notice that the `args`
    section was updated by us by adding the `sleep 3` option. Using this option will
    make the task sleep for three seconds before completing, giving us enough time
    to notice the next Pod being created. Once you’ve applied this configuration file
    to your Kubernetes cluster, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `watch` (`-w` or `–watch`) mechanism will update your `kubectl` output when
    something new arrives, such as the creation of the new Pods being managed by your
    Kubernetes. If you want to wait for the job to finish, you’ll see 10 Pods being
    created with a 3-second delay between each.
  prefs: []
  type: TYPE_NORMAL
- en: Running a task multiple times in parallel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `completions` option ensures that the Pods are created one after the other.
    You can also enforce parallel execution using the `parallelism` option. If you
    do that, you can get rid of the `completions` option. Kubernetes Jobs can leverage
    parallelism to significantly speed up execution. By running multiple Pods concurrently,
    you distribute workload across your cluster, leading to faster completion times
    and improved resource utilization, especially for large or complex tasks. Here
    is the updated YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Please notice that the `completions` option is now gone and that we replaced
    it with `parallelism`. The job will now launch five Pods at the same time and
    will have them run in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to terminate a Job automatically after
    a particular time period.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating a job after a specific amount of time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also decide to terminate a Pod after a specific amount of time. This
    can be very useful when you are running a job that is meant to consume a queue,
    for example. You could poll the messages for one minute and then automatically
    terminate the processes. You can do that using the `activeDeadlineSeconds` parameter.
    Here is the updated YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, the job will terminate after 60 seconds, no matter what happens. It’s
    a good idea to use this feature if you want to keep a process running for an exact
    amount of time and then terminate it.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if a job succeeds?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your job is completed, it will remain created in your Kubernetes cluster
    and will not be deleted automatically: that’s the default behavior. The reason
    for this is that you can read its logs a long time after its completion. However,
    keeping your jobs created on your Kubernetes cluster that way might not suit you.
    You can delete the jobs automatically, and the Pods they created, by using the
    `ttlSecondsAfterFinished` option. Here is the updated YAML file for implementing
    this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, the jobs are going to be deleted 30 seconds after their completion.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep in mind that the Pods that are created are bound to the life cycle of their
    parent. Deleting a job will result in deleting the Pods they manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by getting the name of the job you want to destroy. In our case, it’s
    `hello-world-job`. Otherwise, use the `kubectl get jobs` command to retrieve the
    correct name. Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to delete the jobs but not the Pods it created, you need to add
    the `--cascade=false` parameter to the `delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this command, you can get rid of all the jobs that will be kept on
    your Kubernetes cluster once they’ve been completed. Now, let’s move on to launching
    the first CronJob.
  prefs: []
  type: TYPE_NORMAL
- en: Launching your first CronJob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To close this first chapter on Pods, we will look at another Kubernetes resource
    called **CronJob**.
  prefs: []
  type: TYPE_NORMAL
- en: What are CronJobs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name **CronJob** can mean two different things and it is important that
    we do not get confused with these:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unix `cron` feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes `CronJob` resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historically, CronJobs are commands scheduled using the cron Unix feature, which
    is the most robust way to schedule the execution of a command in Unix systems.
    This idea was later taken up in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful because even though the two ideas are similar, they don’t work the
    same at all. On Unix and other derived systems such as Unix, you schedule commands
    by editing a file called `Crontab`, which is usually found in `/etc/crontab` or
    related paths. In the world of Kubernetes, things are different: you are not going
    to schedule the execution of commands but the execution of Job resources, which
    themselves will create Pod resources. Keep in mind that the `CronJob` object you’ll
    create will create Job objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it as a kind of wrapper around the Job resource: in Kubernetes, we
    call that a controller. `CronJob` can do everything the Job resource is capable
    of because it is nothing more than a wrapper around the Job resource, according
    to the `cron` expression specified.'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the Kubernetes `CronJob` resource is using the `cron`
    format inherited from Unix. So, if you have already written some CronJobs on a
    Linux system, mastering Kubernetes CronJobs will be super straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, why would you want to execute a Pod? The answer is simple; here
    are some concrete use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking database backups regularly every Sunday at 1 A.M.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing cached data every Monday at 4 P.M.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a queued email every 5 minutes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various maintenance operations to be executed regularly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use cases of Kubernetes CronJobs do not differ much from their Unix counterparts
    – they are used to answer the same need, but they do provide the massive benefit
    of allowing you to use your already configured Kubernetes cluster to schedule
    regular jobs using your container images and your already existing Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your first CronJob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to create your first `CronJob`. Let’s do this using declarative syntax.
    First, let’s create a `cronjob.yaml` file and place the following YAML content
    into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Before applying this file to the Kubernetes cluster, let’s start to explain
    it. There are two important things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `schedule` key, which lets you input the `cron` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jobTemplate` section, which is exactly what you would input in a job YAML
    manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explain these two keys quickly before applying the file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the schedule key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `schedule` key allows you to insert an expression in a `cron` format such
    as Linux. Let’s explain how these expressions work; if you already know these
    expressions, you can skip these explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A `cron` expression is made up of five entries separated by white space. From
    left to right, these entries correspond to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day of the month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day of the week
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each entry can be filled with an asterisk, which means *every*. You can also
    set several values for one entry by separating them with a `,`. You can also use
    a `–` to input a range of values. Let me show you some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: “`10 11 * * *`" means “At 11:10 every day of every month.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`10 11 * 12 *`" means “At 11:10 every day of December.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`10 11 * 12 1`" means “At 11:10 of every Monday of December.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`10 11 * * 1,2`" means “At 11:10 of every Monday and Tuesday of every month.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “`10 11 * 2-5 *`" means “At 11:10 every day from February to May.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples that should help you understand how cron works. Of course,
    you don’t have to memorize the syntax: most people help themselves with documentation
    or cron expression generators online such as crontab.cronhub.io and crontab.guru.
    If this is too complicated, feel free to use this kind of tool; it can help you
    confirm that your syntax is valid before you deploy the object to Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of the jobTemplate section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve been paying attention to the structure of the YAML file, you may have
    noticed that the `jobTemplate` key contains the definition of a Job object. When
    we use the `CronJob` object, we are simply delegating the creation of a Job object
    to the `CronJob` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: CronJob YAML architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the `CronJob` object is a resource that only manipulates another
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we will discover many objects that will allow us to create Pods so that
    we don’t have to do it ourselves. These special objects are called **controllers**:
    they manipulate other Kubernetes resources by obeying their own logic. Moreover,
    when you think about it, the Job object is itself a controller since, in the end,
    it only manipulates Pods by providing them with its own features, such as the
    possibility of running Pods in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: In a real context, you should always try to create Pods using these intermediate
    objects as they provide additional and more advanced management features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to remember this rule: the basic unit in Kubernetes is a Pod, but you can
    delegate the creation of Pods to many other objects. In the rest of this section,
    we will continue to discover *naked* Pods. Later, we will learn how to manage
    their creation and management via controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the CronJob execution deadline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For some reason, a `CronJob` may fail to execute. In this case, Kubernetes cannot
    execute the Job at the moment it is supposed to start. If jobs surpass their configured
    deadline, Kubernetes considers them unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: The optional `.spec.startingDeadlineSeconds` field establishes a deadline (in
    complete seconds) for initiating the Job in case it misses its scheduled time
    due to any reason. Once the deadline is missed, the Cronjob skips that specific
    instance of the Job, though future occurrences are still scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the history limits of jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the completion of a Cronjob, regardless of its success status, your Kubernetes
    cluster retains a history. The history setting can be configured at the `CronJob`
    level, allowing you to determine whether to preserve the history for each `CronJob`.
    If you choose to keep it, you can specify the number of entries to retain for
    both succeeded and failed jobs using the optional `.spec.successfulJobsHistoryLimit`
    and `.spec.failedJobsHistoryLimit` fields.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CronJob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you already have the YAML manifest file, creating a `CronJob` object is
    easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See the details in the preceding YAML sample.
  prefs: []
  type: TYPE_NORMAL
- en: '`successfulJobsHistoryLimit: 5`, instructs the `CronJob` controller to retain
    the 5 most recent successful job runs. Older successful jobs will be automatically
    deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the `CronJob` using the `kubectl apply -f` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the `CronJob` has been created on your Kubernetes cluster. It will
    launch a scheduled Pod, as configured in the YAML file; in this case, every minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you have configured `successfulJobsHistoryLimit: 5`, only the last 5
    jobs or Pods will be visible.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a CronJob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like any other Kubernetes resource, deleting a `CronJob` can be achieved through
    the `kubectl delete` command. Like before, if you have the YAML manifest, it’s
    easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: With that, the `CronJob` has been destroyed by your Kubernetes cluster. No scheduled
    jobs will be launched anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have come to the end of this chapter on Pods and how to create them; we
    hope you enjoyed it. You’ve learned how to use the most important objects in Kubernetes:
    Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The knowledge you’ve developed in this chapter is part of the essential basis
    for mastering Kubernetes: all you will do in Kubernetes is manipulate Pods, label
    them, and access them. But also remember, in the actual Kubernetes environment,
    you will not be creating or modifying resources directly, instead using other
    methods to deploy your application Pods and other resources. In addition, you
    saw that Kubernetes behaves like a traditional API, in that it executes CRUD operations
    to interact with the resources on the cluster. In this chapter, you learned how
    to launch containers on Kubernetes, how to access these containers using `kubectl`
    port forwarding, how to add labels and annotations to Pods, how to delete Pods,
    and how to launch and schedule jobs using the `CronJob` resource.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember this rule about container management: any container that will
    be launched in Kubernetes will be launched through the object. Mastering this
    object is like mastering most of Kubernetes: everything else will consist of automating
    things around the management of Pods, just like we did with the `CronJob` object;
    you have seen that the `CronJob` object only launches Job objects that launch
    Pods. If you’ve understood that some objects can manage others, but in the end,
    all containers are managed by Pods, then you’ve understood the philosophy behind
    Kubernetes, and it will be very easy for you to move forward with this orchestrator.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, we invite you to add labels and annotations to your Pods, even if you
    don’t see the need for them right away. Know that it is essential to label your
    objects well to keep a clean, structured, and well-organized cluster.
  prefs: []
  type: TYPE_NORMAL
- en: However, you still have a lot to discover when it comes to managing Pods because,
    so far, we have only seen Pods that are made up of only one Docker container.
    The greatest strength of Pods is that they allow you to manage multiple containers
    at the same time, and of course, to do things properly, there are several design
    patterns that we can follow to manage our Pods when they are made of several containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will learn how to manage Pods that are composed of
    several containers. While this will be very similar to the Pods we’ve seen so
    far, you’ll find that some little things are different and that some are worth
    knowing. First, you will learn how to launch multi-container Pods using `kubectl`
    (hint: `kubectl` will not work), and then how to get the containers to communicate
    with each other. After that, you will learn how to access a specific container
    in a multi-container Pod, as well as how to access logs from a specific container.
    Finally, you will learn how to share volumes between containers in the same Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: As you read the next chapter, you will learn about the rest of the fundamentals
    of Pods in Kubernetes. So, you’ll get an overview of Pods while we keep moving
    forward by discovering additional objects in Kubernetes that will be useful for
    deploying applications in our clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Managing Pods**: [https://kubernetes.io/docs/concepts/workloads/pods/](https://kubernetes.io/docs/concepts/workloads/pods/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes Jobs**: [https://kubernetes.io/docs/concepts/workloads/controllers/job/](https://kubernetes.io/docs/concepts/workloads/controllers/job/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Well-Known Labels, Annotations and Taints**: [https://kubernetes.io/docs/reference/labels-annotations-taints/](https://kubernetes.io/docs/reference/labels-annotations-taints/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes CronJob**: [https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
