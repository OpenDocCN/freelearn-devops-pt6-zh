<html><head></head><body>
		<div id="_idContainer127">
			<h1 id="_idParaDest-280"><em class="italic"><a id="_idTextAnchor280"/>Chapter 17</em>: Creating and Using Helm Charts</h1>
			<p>This chapter covers Helm, how Helm is used as a package manager for a Kubernetes cluster, and how it works. We then will be diving into creating a Helm chart from scratch, after which we'll be covering how to publish our new chart to a Kubernetes cluster. Finally, we'll cover taking a publicly available chart and customizing it to fit your needs.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>What is a Helm chart?</li>
				<li>How does Helm work?</li>
				<li>How do I create a Helm chart?</li>
				<li>Deploying a Helm chart</li>
				<li>Customizing a public Helm chart</li>
			</ul>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor281"/>What is a Helm chart?</h1>
			<p>Helm is a package management tool for Kubernetes deployments. Helm is similar to packagers <a id="_idIndexMarker1180"/>such as <strong class="bold">RPM Package Manager</strong> (<strong class="bold">RPM</strong>) for Red Hat/CentOS-based systems or <strong class="source-inline">deb</strong>/<strong class="source-inline">dpkg</strong> for Debian/Ubuntu-based systems. In that sense, a Helm chart is <a id="_idIndexMarker1181"/>a set of Kubernetes deployment files that have been packaged into a single templatized file. In this section, we will cover why we need Helm and how it works behind the scenes.</p>
			<p>One of the questions that come up a lot when people start working with Kubernetes and Rancher is this: <em class="italic">Why do we need Helm?</em> But to answer this question, we need to understand <a id="_idIndexMarker1182"/>how deployment was carried out before Helm, which was to have our developments as <strong class="bold">YAML Ain't Markup Language</strong> (<strong class="bold">YAML</strong>) files in a Git repository. This process works fine for static deployment whereby you repeatedly deploy the same thing —for example, if you are deploying <strong class="source-inline">ingress-nginx</strong> on all your clusters using the same settings, images, and so on. Having that as just a flat YAML file that you deploy using <strong class="source-inline">kubectl apply -f deployment.yaml</strong> may work fine.</p>
			<p>The issue that comes into play is this: what happens if one of your clusters is different? For example, you <a id="_idIndexMarker1183"/>have a <strong class="bold">Google Kubernetes Engine</strong> (<strong class="bold">GKE</strong>) cluster <a id="_idIndexMarker1184"/>and a <strong class="bold">Rancher Kubernetes Engine</strong> (<strong class="bold">RKE</strong>) cluster that might require different images; that is, GKE will use the public Docker Hub image, with your on-premises RKE cluster needing to come from a private registry. Without Helm, you are now going to need two different YAML files while also ensuring that they both stay in sync. Of course, you'll need more than two different deployment files in the real world, so managing these files and keeping them in sync can become a nightmare.</p>
			<p>Some people tried to solve this problem by writing scripts to find and replace values in deployments before deploying them—for example, your master deployment files might have their image <a id="_idIndexMarker1185"/>value being set to something such as <strong class="source-inline">ImageTagPlaceHolder</strong>. Then, the script would look for this value and replace it using the <strong class="source-inline">sed</strong> command, like so: <strong class="source-inline">sed 's/ImageTagPlaceHolder/my-private-registry/g`</strong>. This process works okay if you only update a couple of values, but the process starts breaking down once you need to do more complicated customizations. For example, an ingress for your <strong class="bold">development</strong> (<strong class="bold">dev</strong>) environment might not <a id="_idIndexMarker1186"/>have a <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) setup and might only have <strong class="source-inline">dev.example.com</strong> defined in the <strong class="source-inline">host</strong> section, but in your production environment, you'll need SSL certificate-defined, multiple hosts—that is, <strong class="source-inline">www.example.com</strong>, <strong class="source-inline">example.com</strong>, and so on. Doing this with Bash scripting becomes too crazy and, more importantly, error-prone.</p>
			<p>Helm addresses this issue by having you define your deployment files as YAML files but with variables and <strong class="source-inline">if</strong> statements. The point is that you don't hardcode something such as your image tag in your deployment files; instead, you set it as a variable (that is, the <strong class="source-inline">image</strong> tag). Then, at the time of deployment, you feed values for those variables, and Helm takes care of building the final YAML files and then publishing them to the cluster. At the same time, Helm gives us the ability to define <strong class="source-inline">if</strong> statements in our deployment file, allowing us to modify the deployment based on user and cluster input. We'll be covering how this works in the next section.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor282"/>How does Helm work?</h1>
			<p>I have found that the best way to understand how Helm works is to start by understanding <a id="_idIndexMarker1187"/>the directory structure, but first, we need to remember that most public Helm charts come as TGZ files, which is a compressed directory. Helm's first step is to download this file from a repository and decompress it into the directory structure shown in <em class="italic">Figure 17.1</em>. Note that we'll be covering more about public Helm charts later in this chapter under the <em class="italic">Customizing a public Helm chart</em> section, but in this section, we will cover what each of the four directories and files is for. We'll then tie them together and walk through how Helm uses them to deploy applications. </p>
			<p>You can view an example of a Helm chart directory structure here:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B18053_17_01.jpg" alt="Figure 17.1 – Helm chart directory structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.1 – Helm chart directory structure</p>
			<p><strong class="source-inline">Chart.yaml</strong> is a file that defines a chart as a whole, including the name of the chart, its version, a description, and more. You can find an example in <em class="italic">Figure 17.2</em> and at <a href="https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/hello-world/Chart.yaml">https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/hello-world/Chart.yaml</a>. As we can see, this file is mainly used to set the metadata for the chart, including the name of the chart, a description, keywords, sources, maintainers, and an icon. Rancher uses all this data to build its catalog page, which allows you to search by keyword and see icons for each chart in a repository. Rancher also expands this file using a set of annotations under the <strong class="source-inline">catalog.cattle.io</strong> path to add data such as <strong class="source-inline">catalog.cattle.io/certified: rancher</strong>, which tells the user that this is a certified <a id="_idIndexMarker1188"/>chart that is covered under Rancher's <strong class="bold">service-level agreement</strong> (<strong class="bold">SLA</strong>) and support. You can find an example of Rancher's monitoring chart at <a href="https://github.com/rancher/charts/blob/release-v2.6/charts/rancher-monitoring/100.1.2%2Bup19.0.3/Chart.yaml">https://github.com/rancher/charts/blob/release-v2.6/charts/rancher-monitoring/100.1.2%2Bup19.0.3/Chart.yaml</a>.</p>
			<p>Have a look at the <strong class="source-inline">Chart.yaml</strong> example shown here:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B18053_17_02.jpg" alt="Figure 17.2 – Chart.yaml example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.2 – Chart.yaml example</p>
			<p>The <strong class="source-inline">templates</strong> directory is one of the most critical parts of a Helm chart because this directory is where Helm stores all the template files for an application. It is important to note that all files <a id="_idIndexMarker1189"/>inside this directory should be YAML files. Mixing other files into this directory has been known to cause weird bugs in Helm. By default, this directory is flat, with each object type being its own file—for example, you might have a file called <strong class="source-inline">services.yaml</strong> that includes all service records that need to be created, and another file called <strong class="source-inline">ingress.yaml</strong>. </p>
			<p>It is important to note that resources in a file need to be separated by three hyphens (<strong class="source-inline">---</strong>) per the YAML standard. This is great for simple deployments with one or two resources per type, but having all your resources in a single file can be challenging to manage at scale because the Helm/<strong class="source-inline">kubectl</strong> errors you get will have a line number; still, that line number will not be the line file in the file but will be the line number for that section. For example, suppose you have 10 ingresses defined in a single file, making the total file around 100 lines. Suppose you have an issue with the third ingress on <em class="italic">line 2</em> of that section. Your error message is only going to say <strong class="source-inline">error located on line 2</strong>, but you won't know which line 2. Because of this, it is common to break up your template files into nested directories. </p>
			<p>For example, you might create a folder for each resource type and then create a file for each resource (please see <em class="italic">Figure 17.3</em> for an example). Another example is breaking our folders down by component—we might create a folder for our frontend application and then have all resources that have made up that component: deployment, service, service account, <strong class="bold">persistent volume claim</strong> (<strong class="bold">PVC</strong>), and so on (please see <em class="italic">Figure 17.4</em>). I prefer sorting <a id="_idIndexMarker1190"/>by component for any multi-tier application so that when I'm working on that component, everything for that component is in one spot. It also makes adding new components easy because I'll just clone that whole folder, then go into the folder and start running find and replace commands but scoped to the folder.</p>
			<p>In the following <a id="_idIndexMarker1191"/>example, you can see that in this Helm chart we are grouping by component type, meaning that all deployments are in the same folder together, the same with all ingresses, and so on:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B18053_17_03.jpg" alt="Figure 17.3 – Helm folder structure by resource type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.3 – Helm folder structure by resource type</p>
			<p>In the following example, you'll see that instead of grouping by <em class="italic">type</em>, we are grouping the different parts of the application. For example, we have the <strong class="source-inline">apiserver</strong> folder, which includes all resources that make up that component—that is, the deployment, ingress, and service. Then, we are repeating this process for each of these components of the application—that is, the frontend and the reporting service in this example. Personally, this is <a id="_idIndexMarker1192"/>how I build Helm charts as I find it much easier to read, along with making it much easier to copy a component from one application to another. For example, I might <a id="_idIndexMarker1193"/>reuse the frontend <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) in another application; so, by using this structure, I can simply copy the <strong class="source-inline">frontend</strong> folder into a new chart and start customizing it to fit the new application. The grouping-by-resource-type folder structure requires me to go into each folder and find all resources that make up that component. This process is, of course, error-prone as I might miss a resource. </p>
			<p>You can view the structure here:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B18053_17_04.jpg" alt="Figure 17.4 – Helm folder structure by component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.4 – Helm folder structure by component</p>
			<p>The file you will be using the most as an end user is <strong class="source-inline">values.yaml</strong>; this is because this file sets the default values for the chart. Of course, this can range from setting global values such as <a id="_idIndexMarker1194"/>the repository and the image pull policy to custom settings, such as setting database connection strings that will become a secret. We'll be covering this file more in the next section, but the key thing to understand is that this file is the configuration file for the chart, and therefore having good documentation inside this file is very important. Also, this file is designed to be customizable, meaning you can add your own sections and settings. For example, you might add a section for each component—that is, for <strong class="source-inline">frontend</strong>, <strong class="source-inline">apiserver</strong>, <strong class="source-inline">reporting</strong>, and so on, as illustrated in the following screenshot: </p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B18053_17_05.jpg" alt="Figure 17.5 – Helm custom values for each component&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.5 – Helm custom values for each component</p>
			<p>Finally, the last important directory is <strong class="source-inline">charts</strong>. This directory greatly expands Helm's abilities by allowing you to define dependencies for other charts. For example, if we go back to our <a id="_idIndexMarker1195"/>three-tier application and need a MySQL database as part of our deployment, we don't want to write and manage all the different resource files that a database running in Kubernetes might need when someone else has done all that work for us already. So, in the <strong class="source-inline">charts</strong> directory, we can add the official MySQL chart as a subfolder. This sub-folder is handled just like a normal Helm folder, meaning it has <strong class="source-inline">Chart.yaml</strong>, <strong class="source-inline">templates</strong>, <strong class="source-inline">values.yaml</strong>, and so on. You can, of course, define a dependency inside the <strong class="source-inline">Chart.yaml</strong> file using the <strong class="source-inline">helm dependency</strong> command, which handles downloading and updating subcharts in the <strong class="source-inline">charts</strong> directory, and this is the preferred method over manually merging changes from an external repository into your Helm chart, which—of course—is error-prone and time-consuming. </p>
			<p>It is important to remember that if you need to customize a chart outside the <strong class="source-inline">values.yaml</strong> file—that is, changing a template file to work around a bug—then the <strong class="source-inline">helm dependency</strong> command will overwrite your changes, so it is recommended in that case to download the chart into that folder manually.</p>
			<p>At this point, we understand <a id="_idIndexMarker1196"/>the different parts that make up a Helm chart. Now, it's time to walk through a deployment to understand how Helm works. This is what happens:</p>
			<ol>
				<li>Helm takes the <strong class="source-inline">values.yaml</strong> file and uses that as a base for its variables, at which point any command-line values using the <strong class="source-inline">--set</strong> option will overwrite those variables. The critical item here to understand is that any command-line setting overwrites anything with <strong class="source-inline">values.yaml</strong> and is only used for settings not set via the command-line options.</li>
				<li>Helm then starts processing the template files, replacing all variables with static values. As a part of this step, any <strong class="source-inline">if</strong> statements will be resolved.</li>
				<li>Helm resolves any flow controls, including <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> statements. This allows you to add/remove sections of your configuration files using <strong class="source-inline">if</strong> statements. For example, you might wrap your ingress configuration in an <strong class="source-inline">if</strong> statement, allowing you to disable and enable it via the <strong class="source-inline">values.yaml</strong> file. Note that for ingresses, this is very common in most public charts. The other most common <strong class="source-inline">if</strong> statement is <a id="_idIndexMarker1197"/>around Kubernetes versions as Kubernetes <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) versions and formatting have changed over time. So, with Helm, you can create <strong class="source-inline">if</strong> statements, such as the following: if the Kubernetes version is v1.19 or below, use this section; else, use this section. This allows your chart to support a wide range of Kubernetes versions. You can see an example of this in action by looking at Rancher's official chart template <a href="https://github.com/rancher/rancher/blob/release/v2.6/chart/templates/ingress.yaml">https://github.com/rancher/rancher/blob/release/v2.6/chart/templates/ingress.yaml</a> or by looking at the following screenshot. I would also recommend looking at Helm's official documentation, located at <a href="https://helm.sh/docs/chart_template_guide/control_structures/">https://helm.sh/docs/chart_template_guide/control_structures/</a>:</li>
			</ol>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B18053_17_06.jpg" alt="Figure 17.6 – Rancher server Helm chart ingress example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.6 – Rancher server Helm chart ingress example</p>
			<ol>
				<li value="4">Helm is ready to start making changes to your cluster, but it is important to note if you do an <a id="_idIndexMarker1198"/>air-gapped deployment, it will simply output all the YAML files into a directory. You can find an example of this kind of deployment in <a id="_idIndexMarker1199"/>the Rancher install documentation, located at <a href="https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/install-rancher/">https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/install-rancher/</a>. But if you are carrying out a standard install, Helm will start applying changes to the cluster in a set order, which can be found at <a href="https://github.com/helm/helm/blob/release-3.0/pkg/releaseutil/kind_sorter.go#L27">https://github.com/helm/helm/blob/release-3.0/pkg/releaseutil/kind_sorter.go#L27</a>. </li>
			</ol>
			<p>The vital part of understanding this step is to understand that Helm uses a set of ownership labels/annotations to know which objects are under the control of that Helm release. Helm automatically applies an <strong class="source-inline">app.kubernetes.io/managed-by:</strong> label and <strong class="source-inline">meta.helm.sh/release-name</strong> and <strong class="source-inline">meta.helm.sh/release-namespace</strong> annotations to every resource it creates. If these are missing or different from Helm's expectations, Helm will error out with an error message such as the one listed in the following screenshot. If you get this error, you have conflicts somewhere between charts—that is, two charts are trying to <em class="italic">own</em> the same object, which is not supported. To resolve this, you'll need to update the labels and annotations to the correct release to modify your charts to prevent future conflicts:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B18053_17_07.jpg" alt="Figure 17.7 – Helm ownership error message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.7 – Helm ownership error message</p>
			<ol>
				<li value="5">After Helm has run the equivalent of <strong class="source-inline">kubectl apply</strong>, your application should start. You can run a post-install hook that runs a job or creates a ConfigMap/Secret with most charts running a job that might ping their application in a loop until it comes online, at which point the job will complete successfully. You can <a id="_idIndexMarker1200"/>read more about this process in the official documentation at <a href="https://helm.sh/docs/topics/charts_hooks/">https://helm.sh/docs/topics/charts_hooks/</a>.</li>
			</ol>
			<p>Now that we <a id="_idIndexMarker1201"/>understand how an install works, the only other item is a Helm upgrade, which follows the same process but allows the object that already exists without erroring out. However, I usually recommend running Helm with the <strong class="source-inline">helm upgrade –i</strong> and <strong class="source-inline">--install</strong> flags, which allows you to use the same command to install and upgrade a Helm chart.</p>
			<p>At this point, we understand how a Helm chart works. In the next section, we are going to create a Helm chart, and in the section after that, we are going to deploy the chart.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor283"/>How do I create a Helm chart?</h1>
			<p>Helm makes <a id="_idIndexMarker1202"/>creating charts very easy by using the <strong class="source-inline">helm create mychart</strong> command.</p>
			<p>This command will create all base files needed to run a basic Helm chart. You can find an example output listed here:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B18053_17_08.jpg" alt="Figure 17.8 – helm create mychart command creates an example chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.8 – helm create mychart command creates an example chart</p>
			<p>By default, this command will create a directory with the same name as the chart. When adding a Helm chart to a Git repository, it is widespread to rename this directory just <strong class="source-inline">chart</strong>, or if this application will have multiple charts from the same repository, you'll want to create a <strong class="source-inline">charts</strong> directory and move your new chart into that directory, keeping the <a id="_idIndexMarker1203"/>name something easy to read/understand. This, of course, is a personal preference, with some teams choosing to move their Helm charts to their own repository.</p>
			<p>At this point, your job is to start moving your deployment files into the template files. This is where you need to set all your variables that look like <strong class="source-inline">{{ .Values.image.repository }}</strong>. This variable suggests starting with the root <strong class="source-inline">values</strong> file. Then, go to the <strong class="source-inline">image</strong> section and grab the value for the repository <strong class="source-inline">undertake</strong> section. You can, of course, hardcode these values in the template file, but it is highly recommended to limit hardcoding values whenever possible and have the values defined in your <strong class="source-inline">values.yaml</strong> file. This is a must for any public Helm charts as there will be someone who needs to customize these values for their environment, and hardcoding the values just makes it harder for them. This is one of the reasons that default template files have a lot of settings defined. For example, the <strong class="source-inline">nodeSelector</strong> and <strong class="source-inline">tolerations</strong> settings are set up, even though a good number of people will never use these settings.</p>
			<p>Of course, the default template files do not cover all the different types of resources, so you might need <a id="_idIndexMarker1204"/>to create your own. The process that I usually follow is to find a public chart with the resource type that I need, then simply copy and paste and modify it to suit my needs. Of course, as you create your chart, you'll need to test it, which is what we'll be covering in the next section.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor284"/>Deploying a Helm chart</h1>
			<p>As we covered in the last section, now that we have created our Helm chart, we need to deploy it to our cluster. This is done in two different ways, with the first one being a local chart <a id="_idIndexMarker1205"/>and the second one being a remote chart—both of which we'll be covering in this section.</p>
			<p>Before publishing it, we need to have the chart files downloaded for local Helm charts, which are commonly used while testing a new chart. You'll run a command such as <strong class="source-inline">helm upgrade --install mychart ./chart --namespace mynamespace -f ./chart/values.yaml</strong>. The important part of this command is the <strong class="source-inline">./chart/</strong> part, which tells Helm where the chart is located—in this example, it can be found in the <strong class="source-inline">./chart/</strong> directory. This, of course, should be the root directory of the chart—that is, where the <strong class="source-inline">chart.yaml</strong> file, <strong class="source-inline">values.yaml</strong> file, and so on are located. This kind <a id="_idIndexMarker1206"/>of install is also common for use in <strong class="bold">continuous integration/continuous deployment</strong> (<strong class="bold">CI/CD</strong>) pipelines where you want to use Helm to templatize your deployments but don't need to publish them for public/end-user consumption. An example of this is being used in the Drone pipeline shown in the following screenshot. As you can see, it is using an overwrite value of the Drone build number to set the image tag and pass the ingress host as a variable set at the pipeline level:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B18053_17_09.jpg" alt="Figure 17.9 – Helm install locally in a Drone pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.9 – Helm install locally in a Drone pipeline</p>
			<p>For example, consider <a id="_idIndexMarker1207"/>the Drone pipeline using the Helm command listed in <em class="italic">Figure 17.9</em>. For this step, I'm using a custom image that I have created called <strong class="source-inline">supporttools/kube-builder</strong>, which handles setting up <strong class="source-inline">kubeconfig</strong> and includes some standard tools such as <strong class="source-inline">kubectl</strong> and <strong class="source-inline">helm</strong>. You can see an illustration of this in the following screenshot:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B18053_17_10.jpg" alt="Figure 17.10 – kube-builder example Drone step&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.10 – kube-builder example Drone step</p>
			<p>You can find the complete example pipeline at <a href="https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/drone-pipeline-example">https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch17/drone-pipeline-example</a>.</p>
			<p>The other Helm deployment type is a remote chart. The main difference is the fact that you'll be pointing <a id="_idIndexMarker1208"/>Helm to a repository (Git or <strong class="bold">Hypertext Transfer Protocol Secure</strong> (<strong class="bold">HTTPS</strong>)) such as <a href="https://charts.bitnami.com/bitnami">https://charts.bitnami.com/bitnami</a> and telling Helm to download the chart files from the repository instead of using a local file. The rest of the process is the same as a local install. This process <a id="_idIndexMarker1209"/>is mainly used to deploy public charts such as Rancher Server charts, Prometheus charts, and so on. This has the benefit of pulling the latest charts and releases simply by running the <strong class="source-inline">helm repo update</strong> command. Now, in the next section, we'll be covering how to customize a public Helm chart.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor285"/>Customizing a public Helm chart</h1>
			<p>One of the tasks that everyone has to do someday when working with public Helm charts is to <a id="_idIndexMarker1210"/>customize them to add some feature or setting that you need, or—in a more likely scenario—fix a bug. For example, some public Helm charts don't include the required settings to support <strong class="bold">Pod Security Policy</strong> (<strong class="bold">PSP</strong>) as enterprises <a id="_idIndexMarker1211"/>and high-secure environments are mainly the only ones that use PSPs in the first place. It's something that some community members just don't test. There are, of course, many ways to make these kinds of changes to a public Helm chart.</p>
			<p>But the primary way that I recommend is to fork the GitHub repository, create a new branch, and apply any needed changes. In this example, you'll want to add a section in the deployment to configure the <strong class="source-inline">securityContext</strong> section of the deployment(s) files and <a id="_idIndexMarker1212"/>add the required <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) to assign a PSP to the required workload. Of course, it's recommended not to change the default behavior, so it's common to have <strong class="source-inline">rbac.enable=false</strong> and/or <strong class="source-inline">psp.enabled=false</strong> in the <strong class="source-inline">values.yaml</strong> file to allow users to enable and disable this feature as needed. Then, once you have made these changes, you'll <a id="_idIndexMarker1213"/>want to create a <strong class="bold">pull request</strong> (<strong class="bold">PR</strong>) to merge this into the upstream repository. But in the meantime, you can deploy using the Helm local install option.</p>
			<p>The idea is to give back to the open source community when the PR is merged. Switching back to the public chart is a simple edit to the Helm command by swapping out the local path of the repository name. Of course, make sure you are updating documentation and command examples as part of your PR request.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor286"/>Summary</h1>
			<p>This chapter went over what Helm is and how it takes template files along with a set of values to create final deployment files that Helm can publish to a cluster. We then dove into creating a Helm chart and some of the best practices for structuring your chart for ease of use. We then went over how to install our newly created chart and integrate this process into a Drone pipeline. We then covered the topic of public Helm charts and how to customize them.</p>
			<p>The next chapter will cover cluster resource management and capacity planning; as we all know, running <strong class="bold">development-operations</strong> (<strong class="bold">DevOps</strong>) workloads can quickly get out of control in terms of resource spending, and in the next chapter will cover how to monitor and control costs in Kubernetes.</p>
		</div>
	</body></html>