<html><head></head><body>
		<div id="_idContainer065">
			<h1 id="_idParaDest-75"><em class="italic"><a id="_idTextAnchor074"/>Chapter 5</em>: Exploring Infrastructure Platform Patterns</h1>
			<p>The success of running an infrastructure platform product with Crossplane depends on following a few principles and patterns as and when required. This chapter will explore some of these critical practices. We will also learn a few debugging skills while exploring the concepts. After learning the basics of the Crossplane in the last few chapters, this will be a place for learning advanced patterns that are key to building the state-of-the-art infrastructure platform for your organization. You will learn a few critical aspects of building robust XR APIs and debugging issues with ease.</p>
			<p>The topics covered in this chapter are as follows:</p>
			<ul>
				<li>Evolving the APIs</li>
				<li>Nested and multi-resource XRs</li>
				<li>XRD detailed</li>
				<li>Managing external software resources</li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Evolving the APIs</h1>
			<p>Crossplane is primarily an API-based infrastructure automation platform. Changes to the APIs are inevitable <a id="_idIndexMarker224"/>as the business requirements and technology landscape evolve. We can classify these changes into three different buckets:</p>
			<ul>
				<li>API implementation change</li>
				<li>Non-breaking API contract change</li>
				<li>Breaking API contract change</li>
			</ul>
			<p>Let’s start with the API implementation change.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>API implementation change</h2>
			<p>These changes are limited to the API implementation details without any changes to the contract. In other <a id="_idIndexMarker225"/>words, these are changes to Compositions YAML, a construct used by XR for API implementation. <strong class="source-inline">CompositionRevision</strong> is the Crossplane concept that will work with compositions to support such changes. If the <strong class="source-inline">--enable-composition-revisions</strong> flag is set while installing Crossplane, a <strong class="source-inline">CompositionRevision</strong> object is created with all the updates to composition. The name of the <strong class="source-inline">CompositionRevision</strong> object is autogenerated on every increment. The compositions are mutable objects that can change forever, but individual <strong class="source-inline">CompositionRevision</strong> is immutable. <strong class="source-inline">Composition</strong> and <strong class="source-inline">CompositionRevision</strong> are in one-to-many relationships. We will have only one <strong class="source-inline">CompositionRevision</strong> active at any given instance. The latest revision number will always be active, excluding the following scenario.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Each configuration state of the composition maps to a single <strong class="source-inline">CompositionRevision</strong>. Let’s say we are in revision 2 and changing the composition configuration the <a id="_idIndexMarker226"/>same as the first revision. A new revision is not created. Instead, revision 1 becomes active, making revision 2 inactive.</p>
			<p>In a Crossplane environment where the composition revision flag is enabled, we will have two attributes automatically added to every XR/Claim object by Crossplane. The following are attribute names and how they are used:</p>
			<ul>
				<li><strong class="source-inline">spec.compositionRevisionRef</strong>: This will hold the name of <strong class="source-inline">CompositionRevision</strong> with which the resources are created.</li>
				<li><strong class="source-inline">spec.compositionUpdatePolicy</strong>: This attribute will indicate whether the XR/Claim will automatically migrate to a new, available <strong class="source-inline">CompositionRevision</strong>. Manual and automatic are the two possible values, with automatic as the default value. If you would like to override the default behavior, add this attribute with a manual indicator in the XR/Claim configuration.</li>
			</ul>
			<p>The following diagram represents how <strong class="source-inline">Composition</strong> and <strong class="source-inline">CompositionRevision</strong> work together to evolve infrastructure API implementation continuously:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B17830_05_01.jpg" alt="Figure 5.1 – Evolving compositions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Evolving compositions</p>
			<p>To manually migrate the composition, update the <strong class="source-inline">spec.compositionRevisionRef</strong> configuration in the XR/Claim with the latest revision name. This specific design enables the separation of concerns between the platform API creator <a id="_idIndexMarker227"/>and consumers. Infrastructure API creators will update the compositions, and API consumers can choose their revision upgrade strategy. If you want a specific revision of composition to be used while creating an XR/Claim, explicitly mention the revision name under <strong class="source-inline">spec.compositionRevisionRef</strong>.</p>
			<p>Let’s look at some examples of such changes:</p>
			<ul>
				<li><strong class="bold">Bugfix</strong>: Let's say we mapped an incorrect attribute to the XRD status field. The scope of the correct mapping is limited to changes in the respective Composition patch section.</li>
				<li><strong class="bold">Policy changes without contract change</strong>: Adding a new infrastructure compliance policy to provide all new resources in a specific region.</li>
				<li><strong class="bold">Shared infrastructure</strong>: Moving toward a shared <strong class="bold">Virtual Private Cloud</strong> (<strong class="bold">VPC</strong>) instead of dynamically provisioning a new VPC for all new XR/Claim requests.</li>
			</ul>
			<p>The composition revision flag is not enabled by default. Use the <strong class="source-inline">--enable-composition-revisions</strong> argument with a Crossplane pod to enable composition revision. The following <a id="_idIndexMarker228"/>Helm command will set up/update the Crossplane environment with composition revision:</p>
			<pre class="source-code">#Enable Composition revision in an existing environment</pre>
			<pre class="source-code">helm upgrade crossplane –namespace crossplane-system crossplane-stable/crossplane –set args='{--enable-composition-revisions}' </pre>
			<pre class="source-code">#Enable Composition revision in a new Crossplane setup</pre>
			<pre class="source-code">helm install crossplane –namespace crossplane-system crossplane-stable/crossplane –set args='{--enable-composition-revisions}'</pre>
			<p>The following section will look at composition revision with an example.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Hands-on journey with composition revision</h2>
			<p>Let’s go through a <a id="_idIndexMarker229"/>hands-on journey to experience composition revision. The objectives of the exercise will be as follows:</p>
			<ul>
				<li>Building an XR API for GCP MySQL provisioning in a composition revision-enabled Crossplane environment</li>
				<li>Creating two MySQL instances with automated and manual composition revision policies</li>
				<li>Updating the Composition to change the calculation for database disk size</li>
				<li>Validating if the MySQL instance with automated revision policy automatically migrates to the latest composition revision</li>
				<li>Seeing that the MySQL instance with the manual revision policy does not migrate to the latest composition revision</li>
				<li>Finally, migrating the second MySQL instance manually to the latest composition revision</li>
			</ul>
			<p>Let’s use a simple XRD and composition to explore composition revision. The following is the XRD with just <a id="_idIndexMarker230"/>one parameter that takes the MySQL disk size:</p>
			<pre class="source-code">apiVersion: apiextensions.crossplane.io/v1</pre>
			<pre class="source-code">kind: CompositeResourceDefinition</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: xmysqls.composition-revision.imarunrk.com</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  group: composition-revision.imarunrk.com</pre>
			<pre class="source-code">  names:</pre>
			<pre class="source-code">    kind: XMySql</pre>
			<pre class="source-code">    plural: xmysqls</pre>
			<pre class="source-code">  claimNames:</pre>
			<pre class="source-code">    kind: MySql</pre>
			<pre class="source-code">    plural: mysqls</pre>
			<pre class="source-code">  versions:</pre>
			<pre class="source-code">  - name: v1</pre>
			<pre class="source-code">    served: true</pre>
			<pre class="source-code">    referenceable: true</pre>
			<pre class="source-code">    schema:</pre>
			<pre class="source-code">      openAPIV3Schema:</pre>
			<pre class="source-code">        type: object</pre>
			<pre class="source-code">        properties:</pre>
			<pre class="source-code">          spec:</pre>
			<pre class="source-code">            type: object</pre>
			<pre class="source-code">            properties:</pre>
			<pre class="source-code">              parameters:</pre>
			<pre class="source-code">                type: object</pre>
			<pre class="source-code">                properties:</pre>
			<pre class="source-code">                  size:</pre>
			<pre class="source-code">                    type: integer</pre>
			<pre class="source-code">                required:</pre>
			<pre class="source-code">                - size</pre>
			<pre class="source-code">            required:</pre>
			<pre class="source-code">            - parameters</pre>
			<p>The composition for the preceding XRD is as follows, which patches the <strong class="source-inline">size</strong> attribute from XR into <a id="_idIndexMarker231"/>the GCP CloudSQLInstance MR:</p>
			<pre class="source-code">apiVersion: apiextensions.crossplane.io/v1</pre>
			<pre class="source-code">kind: Composition</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: gcp-mysql</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  compositeTypeRef:</pre>
			<pre class="source-code">    apiVersion: composition-revision.imarunrk.com/v1</pre>
			<pre class="source-code">    kind: XMySql</pre>
			<pre class="source-code">  resources:</pre>
			<pre class="source-code">  - name: cloudsqlinstance</pre>
			<pre class="source-code">    base:</pre>
			<pre class="source-code">      apiVersion: database.gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">      kind: CloudSQLInstance</pre>
			<pre class="source-code">      spec:</pre>
			<pre class="source-code">        providerConfigRef:</pre>
			<pre class="source-code">          name: gcp-credentials-project-1</pre>
			<pre class="source-code">        forProvider:</pre>
			<pre class="source-code">          region: us-central1</pre>
			<pre class="source-code">          databaseVersion: MYSQL_5_7</pre>
			<pre class="source-code">          settings:</pre>
			<pre class="source-code">            tier: db-g1-small</pre>
			<pre class="source-code">            dataDiskSizeGb: 40</pre>
			<pre class="source-code">    patches:</pre>
			<pre class="source-code">    - type: FromCompositeFieldPath</pre>
			<pre class="source-code">      fromFieldPath: spec.parameters.size</pre>
			<pre class="source-code">      toFieldPath: spec.forProvider.settings.dataDiskSizeGb</pre>
			<p>Apply both the YAML to a target Crossplane cluster with composition revision enabled. You will see that <strong class="source-inline">CompositionRevision</strong> is created for the composition. Execute the following <a id="_idIndexMarker232"/>command to view all <strong class="source-inline">CompositionRevision</strong> for the given composition:</p>
			<pre class="source-code"># List of revisions for Composition named gcp-mysql</pre>
			<pre class="source-code">kubectl get compositionrevision -l crossplane.io/composition-name=gcp-mysql</pre>
			<p>Refer to the following screenshot with one revision object created for the <strong class="source-inline">gcp-mysql</strong> composition. Note that the <strong class="source-inline">current</strong> attribute is true for revision 1. It will change if we update the composition:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B17830_05_02.jpg" alt="Figure 5.2 – Composition Revision list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Composition Revision list</p>
			<p>Now, let’s provision two MySQL instances with the Claim API. An example of manual revision update policy configuration is as follows. The automated revision version of the YAML will be <a id="_idIndexMarker233"/>the same without the <strong class="source-inline">compositionUpdatePolicy</strong> parameter, which defaults to an automatic revision update:</p>
			<pre class="source-code">apiVersion: composition-revision.imarunrk.com/v1</pre>
			<pre class="source-code">kind: MySql</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  namespace: alpha</pre>
			<pre class="source-code">  name: mysql-db-manual</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  compositionUpdatePolicy: Manual</pre>
			<pre class="source-code">  compositionRef:</pre>
			<pre class="source-code">    name: gcp-mysql</pre>
			<pre class="source-code">  parameters:</pre>
			<pre class="source-code">    size: 10</pre>
			<p>You can refer to the following screenshot with two MySQL instances onboarded:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B17830_05_03.jpg" alt="Figure 5.3 – MySQL claims&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – MySQL claims</p>
			<p>Now, update the composition patch with a transform function to multiply the disk size by four before patching. The patches section of the updated composition will look like the following:</p>
			<pre class="source-code">patches:</pre>
			<pre class="source-code">    - type: FromCompositeFieldPath</pre>
			<pre class="source-code">      fromFieldPath: spec.parameters.size</pre>
			<pre class="source-code">      toFieldPath: spec.forProvider.settings.dataDiskSizeGb</pre>
			<pre class="source-code">      transforms:</pre>
			<pre class="source-code">      - type: math</pre>
			<pre class="source-code">        math:</pre>
			<pre class="source-code">          multiply: 4</pre>
			<p>After updating the composition, you will see two revisions. Only the latest revision will have the <strong class="source-inline">current</strong> flag of <strong class="source-inline">true</strong>. Also, we can notice that the MySQL provisioned with an automated revision <a id="_idIndexMarker234"/>update policy would have increased the storage. The following screenshot summarizes the output after applying the updated composition:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B17830_05_04.jpg" alt="Figure 5.4 – New Composition Revision&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – New Composition Revision</p>
			<p>Finally, we can manually upgrade the second MySQL instance by adding the <strong class="source-inline">spec.compositionRevisionRef</strong> attribute to the XR/Claim configuration. The field will hold the autogenerated composition revision name. The composition revision hands-on journey example is available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision</a>. In the following section, we will explore the ways to change the XR API contract.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>API contract changes</h2>
			<p>API implementation details are just one direction in which XR changes can evolve. The highly interoperable <a id="_idIndexMarker235"/>API contract between the XR creating and consuming teams also needs to change over time. Contract change can fall under two categories:</p>
			<ul>
				<li><strong class="bold">Non-breaking changes</strong>: The XR API will be backward-compatible, meaning that consumers <a id="_idIndexMarker236"/>are either not impacted by the change or can choose to adopt the new changes at their phase.</li>
				<li><strong class="bold">Breaking changes</strong>: The XR API will not be backward-compatible. A new API version must <a id="_idIndexMarker237"/>be introduced, and the old API version must be deprecated at an appropriate time. All old API users should be safely migrating to the new API version.</li>
			</ul>
			<p>Let’s delve into non-breaking changes.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Non-breaking changes</h2>
			<p>Adding one or more optional parameters to the XRD contract can be considered a non-breaking change. It is non-breaking because the old external resources provisioned can co-exist with the <a id="_idIndexMarker238"/>new schema as the new parameters are optional. Note <a id="_idIndexMarker239"/>that removing an existing optional parameter in the XRD is a breaking change as Crossplane upfront does not know how to reconcile existing provisioned resources. A simple way to think about this is that if Composition/CompositionRevision can handle the co-existence of old and newly provisioned resources, then the XRD contract change is non-breaking. A new optional parameter in the MySQL XR to choose the disk size is an example of a non-breaking change. The change will involve both a contract change and a composition revision. Let’s go through a hands-on journey to make the previous XR example. All the configuration YAML required for this journey is available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking</a>. Refer to the following screenshot of our hands-on journey:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B17830_05_05.jpg" alt="Figure 5.5 – Non-breaking contract change&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Non-breaking contract change</p>
			<p>The following are the steps to be performed throughout the hands-on journey to experiment with the non-breaking contract change:</p>
			<ol>
				<li>Create the <a id="_idIndexMarker240"/>first version of the XRD in the target cluster (<strong class="source-inline">xrd-v1.yaml</strong>). The <a id="_idIndexMarker241"/>schema has <strong class="source-inline">vm</strong> as a mandatory parameter.</li>
				<li>Create the first revision of the composition (<strong class="source-inline">Composition-V1.yaml</strong>). It will patch the <strong class="source-inline">vm</strong> value back into the <strong class="source-inline">MR-CloudSQLInstance</strong> tier attribute.</li>
				<li>Now, the MySQL resource can be provisioned with <strong class="source-inline">db-n1-standard-1</strong> as the tire in GCP (<strong class="source-inline">Claim-v1.yaml</strong>).</li>
				<li>Update and apply the XRD with an additional optional parameter, <strong class="source-inline">size</strong>, to specify the database disk size (<strong class="source-inline">xrd-v2.yaml</strong>).</li>
				<li>Update and apply the new composition (<strong class="source-inline">Composition-V2.yaml</strong>). It will patch the additional size parameter into the MR.</li>
				<li>Finally, create the second MySQL instance with a specific disk size and tire (<strong class="source-inline">Claim-v2.yaml</strong>).</li>
				<li>To validate whether the first MySQL instance can be sill updated, change the tier with an update YAML (<strong class="source-inline">Claim-v1-validate.yaml</strong>).</li>
			</ol>
			<p>We did <a id="_idIndexMarker242"/>not upgrade the API version when updating the contract. We <a id="_idIndexMarker243"/>will discuss this more in the upcoming section.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Version upgrade</h2>
			<p>In the previous section, we did not change the XRD version number from v1. Crossplane does not currently <a id="_idIndexMarker244"/>support XR version upgrades once a contract changes. API versioning without a contract change will be helpful in indicating API stability (alpha, beta, v1, and so on). We can just move from alpha to beta to a more stable version without changing the contract. The version upgrade is currently achieved by listing the old and new version definitions in the XRD. The <strong class="source-inline">versions</strong> array is the construct used for listing multiple versions. The two critical Boolean attributes under each version are <strong class="source-inline">served</strong> and <strong class="source-inline">referenceable</strong>. The <strong class="source-inline">referenceable</strong> flag will determine whether we can define a composition implementation for the given version. Only one version can have the referenceable flag set to <strong class="source-inline">true</strong>. This will be the version used by any new XR create/update event. A create/update event triggered by the old API version will still use the composition from the latest version, marked as referenceable. The <strong class="source-inline">served</strong> flag will indicate whether the given XR API version is in use. Some teams may still use the old version to consume the API. Switching off the <strong class="source-inline">served</strong> flag means that the given version is no longer available for clients. It will be the last step before removing the old version from the XR. </p>
			<p>Look at a sample XRD with three versions, alpha, beta, and v1, at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml</a>. This XRD has three versions. Version alpha will no longer be served, and beta will be served but cannot be referred for resource creation or update. The latest version, v1, will be the preferred version for any resource creation or updates.</p>
			<p>Kubernetes CRDs support multiple API versions both with and without an API contract change. When there is an API contract change, a conversion webhook is configured by the CRD author to support conversion between the versions. Conversions are required as CR objects will be stored in the etcd with both old and new contracts. XRD, the Crossplane equivalent <a id="_idIndexMarker245"/>to CRDs, does not take this approach. A conversion webhook involves programming. Taking that route will violate the no-code agenda of Crossplane when composing APIs. It’s important to note that the Crossplane community is actively working to build a configuration-based solution to support conversion and migration between versions.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Version upgrade with breaking changes</h2>
			<p>An alternative approach supports breaking contracts by introducing a new XR API parallel. This approach <a id="_idIndexMarker246"/>uses an external naming technique and deletion policy to handle breaking changes. With this pattern, we will migrate the resources to a new XR API and remove the old API once the migration is finished in its entirety. The steps to achieve such a version upgrade are as follows:</p>
			<ol>
				<li value="1">Create the v1 version of XRD. In the composition, define a standard nomenclature for naming the external resources (MRs). We should be able to reconstruct the names again in the new API. Generally, we can concatenate the XR and the composition name (<strong class="source-inline">&lt;XR&gt;+'-'+&lt;Composition&gt;</strong>). You can come up with a resource naming strategy that suits your environment. Maybe we can even use the namespace name to represent the product owner of the resource.</li>
				<li>Ensure that all the MRs in the composition have <strong class="source-inline">spec.deletionPolicy</strong> defined as <strong class="source-inline">Orphan</strong>.</li>
				<li>Let’s say we have a couple of consumers for the XR, and they have created a few external resources. Assume that we have a policy requirement that requires breaking changes to the API contract.</li>
				<li>To support the breaking change, delete all v1 versions of the XR. It will just delete the Crossplane references. The external resources are not deleted on account of the orphan deletion policy.</li>
				<li>Then, delete the v1 version of XRD and Composition.</li>
				<li>Finally, create the new v2 version of XRD with the same XR name. Update the composition to handle the recent breaking changes. Ensure that the new composition follows the same external resource name creation logic and maps to the new XRD version.</li>
				<li>Create the deleted XR objects again, pointing to the v2 version of the API. The new XR objects will reference the old orphaned external resources. Crossplane controllers will reconcile any attribute value change.</li>
			</ol>
			<p>Note that this type <a id="_idIndexMarker247"/>of migration to a new API version must be coordinated with all the XR-consuming teams. Once the migration is completed, the old API version will no longer be available. The following figure represents the migration process:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B17830_05_06.jpg" alt="Figure 5.6 – Version migration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Version migration</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It is always good to have a standard way of generating external resource names. In addition to version migration, a reproducible naming pattern can afford several other advantages. Using pre-provisioned resources for a shared or cached infrastructure is an example of using the standard external resource naming pattern. Migrating resources to a new Crossplane environment can be another example.</p>
			<p>It’s recommended to go through a hands-on journey of breaking API contract, with the sample <a id="_idIndexMarker248"/>configuration provided at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking</a>. Perform the following steps to go through the hands-on journey to handle breaking contract changes:</p>
			<ol>
				<li value="1">First, execute <strong class="source-inline">xrd-v1.yaml</strong>, <strong class="source-inline">Composition-V1.yaml</strong>, and <strong class="source-inline">Claim.yaml</strong>.</li>
				<li>It will create an XRD and a Composition with the database size as optional parameter and the VM as a mandatory parameter. The Claim will provision the database wih the specified size and VM. The provisioned resource will get a standard external resource name.</li>
				<li>Note that the <strong class="source-inline">claim.name</strong> label in <strong class="source-inline">Claim.yaml</strong> is used for constructing the external resource name in the composition section. It should be unique for every XR/Claim object to generate unique external resource names.</li>
				<li>Let’s now delete the v1 version of Claim, Composition, and XRD. When we delete the v1 claim, the external resource will not be deleted because the deletion policy is configured as an orphan.</li>
				<li>Finally, apply the v2 version of Claim, Composition, and XRD. In the v2 XRD, we have broken the contract by removing the mandatory parameter, <strong class="source-inline">vm</strong>. The new v2 claim (<strong class="source-inline">Claim-migrate.yaml</strong>) will not have the <strong class="source-inline">vm</strong> parameter. Note that both Composition and Claim will point to the v2 version XRD.</li>
				<li>Notice that the Crossplane will reclaim the orphaned resource and reconcile the virtual machine with the new default value provided in the Composition. We can validate that by looking into the GCP console or the Claim resource description.</li>
			</ol>
			<p>Refer to the following screenshot where the preceding example is tested:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B17830_05_07.jpg" alt="Figure 5.7 – XRD breaking changes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – XRD breaking changes</p>
			<p>Following is the code snippet relating to external resource name patching from the preceding Composition <a id="_idIndexMarker249"/>example. This must be present in both composition versions, and the name generated should be the same for both versions:</p>
			<pre class="source-code">- type: FromCompositeFieldPath</pre>
			<pre class="source-code">      fromFieldPath: metadata.name</pre>
			<pre class="source-code">      toFieldPath: metadata.annotations[crossplane.io/external-name]</pre>
			<pre class="source-code">      transforms:</pre>
			<pre class="source-code">      - type: string</pre>
			<pre class="source-code">        string:</pre>
			<pre class="source-code">          fmt: "%s-gcp-mysql-cloudsqlinstance"</pre>
			<p>Note that we have used a new transform type to format the string before we patch. With this, we <a id="_idIndexMarker250"/>conclude the different ways of evolving the XR APIs. We will dive into an interesting case in the following section to build one XR composing another XR.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Nested and multi-resource XRs</h1>
			<p>Every software product depends on more than one infrastructure resource. It is essential to build <a id="_idIndexMarker251"/>single infrastructure recipes in order for the product teams to consume <a id="_idIndexMarker252"/>with a unified experience. The orchestration of infrastructure dependencies should remain abstracted. Such recipes require multiple resources to be composed into a single XR. In all the examples hitherto, we have always composed a single GCP resource inside an XR. Let’s look at an XR sample where multiple GCP resources are composed into a single XR API. The following figure represents the resources and XR APIs that we are going to work with in the example:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B17830_05_08.jpg" alt="Figure 5.8 – Multi-resource nested XR&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Multi-resource nested XR</p>
			<p>In addition to multiple resource provisioning in a single XR, we also have a nested XR pattern in <em class="italic">Figure 5.8</em>. We are composing three resources within two XRs. The first XR composes two resources, and the second XR composes the first XR and a database resource. Let’s look at the details of each XR:</p>
			<ul>
				<li><strong class="bold">XR 1</strong>: We will compose a Google Kubernetes Engine cluster and a Google Cloud storage resource with this XR. The idea is to provide cloud storage to hold the application logs for future analysis. Note that this XR will not have a claim name in the XRD definition. It will <a id="_idIndexMarker253"/>be of a cluster scope and a private API for the platform <a id="_idIndexMarker254"/>team. Product teams with access only to a namespace will not use this API directly. This XR will expose the region and the autopilot configuration as parameters. The region will be propagated back into both the resources and the autopilot configuration is used for the Kubernetes provisioning.</li>
				<li><strong class="bold">XR/Claim 2</strong>: The second XR will compose the MySQL database, an MR, and the first XR to create a nested API. We will patch region parameters to the MySQL MR and propagate the same into the inner XR.</li>
			</ul>
			<p>All examples in this hands-on journey are available at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR</a>. </p>
			<p>Let’s first create the XRD and Composition for both the XRs. Apply <strong class="source-inline">xrd k8s.yaml</strong>, <strong class="source-inline">Composition k8s.yaml</strong>, <strong class="source-inline">xrd Application.yaml</strong>, and <strong class="source-inline">Composition Application.yaml</strong> to the Crossplane cluster. You will see that the <strong class="source-inline">ESTABLISHED</strong> flag is <strong class="source-inline">True</strong> for both the XRDs. This indicates that the Crossplane has started a new controller to reconcile the established XR. The <strong class="source-inline">OFFERED</strong> flag will be <strong class="source-inline">True</strong> for the application XR and <strong class="source-inline">False</strong> for the Kubernetes XR. This indicates that the Crossplane has started a new controller to reconcile the established Claim only for the application XR. It is false for the Kubernetes XR because we don’t have the respective claim. Refer to the following screenshot regarding XRD creation:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B17830_05_09.jpg" alt="Figure 5.9 – Nested XR-XRD and Composition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Nested XR-XRD and Composition</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Similar to creating an XR API with multiple resources from a single cloud provider, we can also mix and match resources from multiple clouds. We just have to add the resources concerned with respective ProviderConfig clouds.</p>
			<p>It’s now time to create an application Claim resource. Apply Claim <strong class="source-inline">Application.yaml</strong> to the <a id="_idIndexMarker255"/>Crossplane cluster. You will see that a <strong class="source-inline">CloudSQLInstance</strong> instance, a cluster, and <a id="_idIndexMarker256"/>a bucket resource have been provisioned. Refer to the following screenshot where the resources are provisioned successfully:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B17830_05_10.jpg" alt="Figure 5.10 – Resource provisioning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Resource provisioning</p>
			<p>If you would like to explore each resource in detail, use the Resource references. Execute <strong class="source-inline">kubectl describe application my-application -n alpha</strong> to see the details of the claim. It will refer to the <strong class="source-inline">XApplication</strong> XR object. If we look at the details of the <strong class="source-inline">XApplication</strong> object, it will hold the reference to the <strong class="source-inline">CloudSQLInstance</strong> MR and <strong class="source-inline">XGCPCluster</strong> XR. Similarly, we can go on till you reach the last MR. This is beneficial for debugging activities. Sometimes you may see that the resources are not getting ready. In those instances, explore each nested resource and refer to the events section to ascertain what is happening. An example of referring nested resources from the resource description is as follows:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B17830_05_11.jpg" alt="Figure 5.11 – Nested resource reference example 1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Nested resource reference example 1</p>
			<p>The preceding screenshot <a id="_idIndexMarker257"/>represented the Application claim description <a id="_idIndexMarker258"/>referring to the <strong class="source-inline">XApplication</strong> XR resource. The following screenshot represents the <strong class="source-inline">XApplication</strong> XR description referring to the <strong class="source-inline">XGCPCluster</strong> XR instance and <strong class="source-inline">CloudSQLInstance</strong> MR:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B17830_05_12.jpg" alt="Figure 5.12 – Nested resource reference example 2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Nested resource reference example 2</p>
			<p>The following is an example event that tells us that we have provided the wrong region as a parameter:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B17830_05_13.jpg" alt="Figure 5.13 – Resource description with an error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Resource description with an error</p>
			<p class="callout-heading">Important</p>
			<p class="callout">We need to follow many more patterns when we compose multiple resources to give a unified experience for product teams. The preceding example is a simple example to start the topic. We will see more on this in the upcoming chapters.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>PatchSets</h2>
			<p>If you look at the composition in the preceding example, you can see that we have used a new pattern called <strong class="bold">PatchSets</strong>. If you find yourself repeating the same patch operation again <a id="_idIndexMarker259"/>and again under each resource, then PatchSets is the way to go. Here, we define the patch operation as a static function and include it under the required resource sections. The following is an example of the <strong class="source-inline">patchSets</strong> function definition to patch a region:</p>
			<pre class="source-code">patchSets:</pre>
			<pre class="source-code">  - name: region</pre>
			<pre class="source-code">    patches:</pre>
			<pre class="source-code">    - type: FromCompositeFieldPath</pre>
			<pre class="source-code">      fromFieldPath: spec.parameters.region</pre>
			<pre class="source-code">      toFieldPath: spec.forProvider.region</pre>
			<p>We can define multiple <strong class="source-inline">patchSet</strong> functions. To include a specific patch set function within a given resource, use the following code snippet:</p>
			<pre class="source-code">patches:</pre>
			<pre class="source-code">    - type: PatchSet</pre>
			<pre class="source-code">      patchSetName: region</pre>
			<p>We will see more nested <a id="_idIndexMarker260"/>and multi-resource XR examples in the upcoming chapters. In the following section, we will look at detailed configuration options for defining the XRD schema.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>XRD detailed</h1>
			<p>While looking at <strong class="bold">Composite Resource Definition</strong> (<strong class="bold">XRD</strong>) in the previous chapter, we touched on limited configuration <a id="_idIndexMarker261"/>options required to learn the basics of XR. It’s now time to look at more detailed configuration options to build clean and robust XR APIs. A significant part of the details we will look at are about openAPIV3Schema, which is used to define the input and output of the XR API. The following are the topics we will cover in this section:</p>
			<ul>
				<li>Naming the versions</li>
				<li>The openAPIV3Schema structure</li>
				<li>The additional parameter of an attribute </li>
				<li>Printer columns</li>
			</ul>
			<p>Let’s start with the <em class="italic">Naming the versions section</em>.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Naming the versions</h2>
			<p>The version name of our XRD cannot have any random string. It has a specific validation inherited from the <a id="_idIndexMarker262"/>CRDs and standard Kubernetes APIs. The string can contain only lowercase alphanumeric characters and <strong class="source-inline">-</strong>. Also, it must always start with an alphabetic character and end with an alphanumeric character, which means that <strong class="source-inline">-</strong> cannot be the start or ending character. Also, a number cannot be the starting character. Some valid versions are <strong class="source-inline">my-version</strong>, <strong class="source-inline">version-1</strong>, <strong class="source-inline">abc-version1</strong>, and <strong class="source-inline">v1</strong>. While we can have many permutations and combinations for naming a version, some standard practices are followed across CRDs. Following the same with XRDs will enable API consumers to understand the stability of the API. The version string starts with <strong class="source-inline">v</strong> followed by a number with these standards (v1, v2). This is then optionally followed by either <strong class="source-inline">alpha</strong> or <strong class="source-inline">beta</strong>, depending on the API’s stability. Generally, the <strong class="source-inline">alpha</strong> string represents the lowest stability (<strong class="source-inline">v5alpha</strong>), while <strong class="source-inline">beta</strong> is the next stability level (<strong class="source-inline">v3beta</strong>). If both texts are missing, the XR is ready for production use. An optional number can follow the optional <strong class="source-inline">alpha</strong>/<strong class="source-inline">beta</strong> text representing the incremental releases (<strong class="source-inline">v2alpha1</strong>, <strong class="source-inline">v2alpha2</strong>, and so on).</p>
			<p>If you have an invalid version string provided with the XRD, you will see that the XRD will not get configured properly. The <strong class="source-inline">ESTABLISHED</strong> flag will not be set to <strong class="source-inline">True</strong>. You apply the <strong class="source-inline">– xrd\ invalid\ version\ test.yaml</strong> file from the <strong class="source-inline">samples</strong> folder to see what happens when you have an incorrect version number. Refer to the following screenshot:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B17830_05_14.jpg" alt="Figure 5.14 – Invalid version XRD&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Invalid version XRD</p>
			<p>Also, you will be <a id="_idIndexMarker263"/>able to see the following error logs in the Crossplane pod in the crossplane-system namespace:</p>
			<pre class="source-code">2022-01-15T20:06:46.217Z     ERROR     crossplane.controller-runtime.manager.controller.defined/compositeresourcedefinition.apiextensions.crossplane.io     Reconciler error     {"reconciler group": "apiextensions.crossplane.io", "reconciler kind": "CompositeResourceDefinition", "name": "xbuckets.version-test.imarunrk.com", "namespace": "", "error": "cannot apply rendered composite resource CustomResourceDefinition: cannot create object: CustomResourceDefinition.apiextensions.k8s.io \"xbuckets.version-test.imarunrk.com\" is invalid: [spec.versions[0].name: Invalid value: \"v1.0\": a DNS-1035 label must consist of lower case alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character (e.g. 'my-name', or 'abc-123', regex used for validation is '[a-z]([-a-z0-9]*[a-z0-9])?'), spec.version: Invalid value: \"v1.0\": a DNS-1035 label must consist of lower case alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character (e.g. 'my-name', or 'abc-123', regex used for validation is '[a-z]([-a-z0-9]*[a-z0-9])?')]"}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">When we troubleshoot an issue with Crossplane, logs from the Crossplane pod can help. Enable debugging mode by adding an argument, <strong class="source-inline">--debug</strong>, to the Crossplane pod. Similarly, we can even look at the provider’s container logs.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>The openAPIV3Schema structure</h2>
			<p>The specification <a id="_idIndexMarker264"/>of the XR API is defined using <strong class="source-inline">openAPIV3Schema</strong>. Every configuration element in the XRD under this section represents the input and output of the XR API:</p>
			<pre class="source-code">versions:</pre>
			<pre class="source-code">  - name: v1alpha</pre>
			<pre class="source-code">    schema:</pre>
			<pre class="source-code">      openAPIV3Schema:</pre>
			<pre class="source-code">      # Input and output definition for the XR</pre>
			<p>Generally, we configure the <strong class="source-inline">openAPIV3Schema</strong> section with two objects, <strong class="source-inline">spec</strong> and <strong class="source-inline">status</strong>. The <strong class="source-inline">spec</strong> object represents the API input, while the <strong class="source-inline">status</strong> object represents the response. We can skip defining the <strong class="source-inline">status</strong> section in XRD if we don’t have any custom requirements. Crossplane would inject the standard status fields into the XR/Claim. Refer to the following code snippet representing the <strong class="source-inline">openAPIV3Schema</strong> configuration template for the XR API input and output:</p>
			<pre class="source-code">openAPIV3Schema:</pre>
			<pre class="source-code">  type: object</pre>
			<pre class="source-code">  properties:</pre>
			<pre class="source-code">    # spec – the API input configuration</pre>
			<pre class="source-code">    spec:</pre>
			<pre class="source-code">      type: object</pre>
			<pre class="source-code">      properties:</pre>
			<pre class="source-code">        ............. configuration continues </pre>
			<pre class="source-code">     # status – the API output configuration </pre>
			<pre class="source-code">     status:</pre>
			<pre class="source-code">       type: object</pre>
			<pre class="source-code">       properties:</pre>
			<pre class="source-code">         ............. configuration continues</pre>
			<p>The schema configuration is all about a mix of <strong class="source-inline">-</strong> attributes, their types, and properties. An <strong class="source-inline">attribute</strong> type of <strong class="source-inline">object</strong> will hold a list of properties. For example, the root attribute <strong class="source-inline">openAPIV3Schema:</strong> is of the <strong class="source-inline">object</strong> type followed by a list of properties (<strong class="source-inline">spec</strong> and <strong class="source-inline">status</strong>). A list of properties is nothing but a list of attributes. Suppose the attribute <a id="_idIndexMarker265"/>type is primitive, such as <strong class="source-inline">string</strong> or <strong class="source-inline">integer</strong>. Such an attribute will be the end node. The object-properties recursion can continue in as much depth as we require. Refer to the following code snippet:</p>
			<pre class="source-code"># The root attribute openAPIV3Schema of type object</pre>
			<pre class="source-code">openAPIV3Schema:</pre>
			<pre class="source-code">  type: object</pre>
			<pre class="source-code">  # spec/status - attributes (properties) of openAPIV3Schema</pre>
			<pre class="source-code">  properties:</pre>
			<pre class="source-code">    # spec – the XR input</pre>
			<pre class="source-code">    spec:</pre>
			<pre class="source-code">      type: object</pre>
			<pre class="source-code">      properties:</pre>
			<pre class="source-code">        # parameters - again an object with attributes list</pre>
			<pre class="source-code">        parameters:</pre>
			<pre class="source-code">          type: object</pre>
			<pre class="source-code">          properties:</pre>
			<pre class="source-code">            # region – string primitive  - node ends</pre>
			<pre class="source-code">            region:</pre>
			<pre class="source-code">            type: string</pre>
			<pre class="source-code">    # status – API output configuration</pre>
			<pre class="source-code">    # The exact structure of configuration as before</pre>
			<pre class="source-code">    # Attributes, their types, and properties</pre>
			<pre class="source-code">    status:</pre>
			<pre class="source-code">      type: object</pre>
			<pre class="source-code">            properties:</pre>
			<pre class="source-code">              zone:</pre>
			<pre class="source-code">                description: DB zone.</pre>
			<pre class="source-code">                type: string   </pre>
			<p>In the following <a id="_idIndexMarker266"/>section, we can look at a few additional valuable configuration options along with the basic <strong class="source-inline">openAPIV3Schema</strong> configuration.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>The additional parameter of an attribute</h2>
			<p>The attribute node can <a id="_idIndexMarker267"/>configure a few other critical configurations that API developers will use daily. Following are some of the frequently used configurations:</p>
			<ul>
				<li><strong class="bold">Description</strong> is a string that will help us provide valuable information for the API consumers about the attribute. It can hold information about the use of the parameter, possible values we can configure, and validation requirements.</li>
				<li><strong class="bold">Required</strong> is an attribute representing the list of mandatory inputs that are required from the user for the API.</li>
				<li><strong class="bold">Default</strong> is an attribute that provides a default value if the user does not input a value.</li>
				<li><strong class="bold">Enum</strong> can configure the list of possible values for a given attribute.</li>
			</ul>
			<p>In addition <a id="_idIndexMarker268"/>to these fields, there is a list of validation-related configurations including <strong class="source-inline">minimum</strong>, <strong class="source-inline">maximum</strong>, <strong class="source-inline">pattern</strong>, <strong class="source-inline">maxLength</strong>, and <strong class="source-inline">minLength</strong>. Refer to the following sample configuration:</p>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  type: object</pre>
			<pre class="source-code">  description: API input specification </pre>
			<pre class="source-code">  properties:</pre>
			<pre class="source-code">    parameters:</pre>
			<pre class="source-code">      type: object</pre>
			<pre class="source-code">      description: Parameter's to configure the resource</pre>
			<pre class="source-code">      properties:</pre>
			<pre class="source-code">        size:</pre>
			<pre class="source-code">          type: integer</pre>
			<pre class="source-code">          description: Disk size of the database</pre>
			<pre class="source-code">          default: 20</pre>
			<pre class="source-code">          minimum: 10</pre>
			<pre class="source-code">          maximum: 100</pre>
			<pre class="source-code">        vm:</pre>
			<pre class="source-code">          type: string</pre>
			<pre class="source-code">          description: Size of the virtual machine.</pre>
			<pre class="source-code">        enum:</pre>
			<pre class="source-code">        - small</pre>
			<pre class="source-code">        - medium</pre>
			<pre class="source-code">        - large</pre>
			<pre class="source-code">      required:</pre>
			<pre class="source-code">      - size</pre>
			<pre class="source-code">  required:</pre>
			<pre class="source-code">  - parameters</pre>
			<p>To explore <a id="_idIndexMarker269"/>more detailed possibilities, visit <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject">https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We can use the description field to announce the parameter deprecation information. This technique can be helpful in delaying breaking changes to a contract by making a mandatory field optional with a deprecation message.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Printer columns</h2>
			<p>We can use the printer columns to add what <strong class="source-inline">kubectl</strong> will display when we get the resource list. We <a id="_idIndexMarker270"/>should provide a name, data type, and JSON path mapping to the attribute we wish to display for each column. Optionally, we may also provide a description. Refer to the following sample configuration:</p>
			<pre class="source-code">additionalPrinterColumns:</pre>
			<pre class="source-code">- name: Zone</pre>
			<pre class="source-code">  type: string</pre>
			<pre class="source-code">  description: </pre>
			<pre class="source-code">  jsonPath: .spec.zone</pre>
			<pre class="source-code">- name: Age</pre>
			<pre class="source-code">  type: date</pre>
			<pre class="source-code">  jsonPath: .metadata.creationTimestamp</pre>
			<p>The printer column configuration remains parallel to the schema configuration.</p>
			<p>This concludes our discussion of detailed XRD configuration. We have covered most of the <a id="_idIndexMarker271"/>configuration required for day-to-day <a id="_idIndexMarker272"/>work, but there are endless possibilities. It will add value by reading up on CRD at <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/</a>.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Managing external software resources</h1>
			<p>We have always talked about managing external infrastructure resources using Crossplane <a id="_idIndexMarker273"/>from the beginning of this book. However, it does not always have to be just an infrastructure resource. We could even manage external software applications from Crossplane. For a software application to be able to work best with the Crossplane ecosystem, it must have the following qualities:</p>
			<ul>
				<li>We should have well-defined and stable APIs to perform CRUD operations.</li>
				<li>The API should have a high-fidelity design with filters to control granular application configuration.</li>
			</ul>
			<p>It’s time to look at an example. Think about deploying an application in Kubernetes using Helm. Helm can package any application and provide a well-defined CRUD API to deploy, read, update, and uninstall. Above all, we can create granular control over the application configuration with parameters. We have a helm Crossplane provider already available and used extensively by the community. The idea of managing external applications from a Crossplane control plane can enable a new world of unifying application and infrastructure automation. The following section will cover the unifying aspect in more detail.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Unifying the automation</h2>
			<p>Managing external software resources with Crossplane is the crossroad for unifying infrastructure and application DevOps. We could package software and infrastructure dependencies <a id="_idIndexMarker274"/>into a single XRs. Such a complete package of applications and infrastructure introduces numerous advantages, some of which are listed here:</p>
			<ul>
				<li>The approach will unify the tooling and skills required for application and infrastructure automation.</li>
				<li>More importantly, the entire stack will enjoy the advantages of the Kubernetes operating model.</li>
				<li>Integrating vendor software into an enterprise ecosystem will become quicker and more standardized. Software vendors can quickly build packages that fit into different ecosystems. Currently, software vendors must custom-build for the individual cloud provider marketplace. This approach can assist in building a universal vendor software marketplace.</li>
				<li>We can easily apply the audit process to comply with any compliance standards. Previously, this would have been complicated as software and its infrastructure dependencies are spread about.</li>
			</ul>
			<p>The following figure represents a unified XR API:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B17830_05_15.jpg" alt="Figure 5.15 – Unified XR&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – Unified XR</p>
			<p class="callout-heading">Important</p>
			<p class="callout">In a later chapter, we can go through a hands-on journey to experience building an XR API covering both applications and infrastructure dependencies.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Summary</h1>
			<p>I hope it’s been fun to read this chapter and go through the hands-on journey. It covered different patterns that are useful in our day-to-day work when adopting Crossplane. We covered different ways to evolve our XR APIs, detailed XR configurations, how to manage application resources, and nested and multi-resource XRs. There are more patterns to be covered.</p>
			<p>The next chapter will discuss more advanced Crossplane methods and their respective hands-on journeys.</p>
		</div>
	</body></html>