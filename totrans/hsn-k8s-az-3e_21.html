<html><head></head><body>
		<div>
			<div id="_idContainer490" class="Content">
			</div>
		</div>
		<div id="_idContainer491" class="Content">
			<h1 id="_idParaDest-170">15. <a id="_idTextAnchor175"/>Continuous integration and continuous deployment for AKS</h1>
		</div>
		<div id="_idContainer524" class="Content">
			<p>DevOps is the union of people, processes, and tools to deliver software faster, more frequently, and more reliably. Within the DevOps culture are the practices of <strong class="bold">continuous integration and continuous deployment</strong> (<strong class="bold">CI/CD</strong>). CI/CD is a set of practices, implemented through one or more tools, to automatically test, build, and deliver software.</p>
			<p>The CI phase refers to the practice of continuously testing and building software. The outcome of the CI phase is a deployable artifact. That artifact could be many things; for instance, for a Java application it would be a <strong class="inline">JAR</strong> file, and in the case of a container-based application it would be a container image.</p>
			<p>The CD phase refers to the practice of continuously releasing software. During the CD phase, the artifact that was generated during CI is deployed to multiple environments, typically going from test to QA to staging to production.</p>
			<p>Multiple tools exist to implement CI/CD. GitHub Actions is one such tool. GitHub Actions is a workflow automation system built into GitHub. With GitHub Actions, you can build, test, and deploy applications written in any language to a variety of platforms. It also allows you to build container images and deploy applications to a Kubernetes cluster, which you'll do in this chapter.</p>
			<p>Specifically, this chapter will cover the following topics:</p>
			<ul>
				<li>CI/CD process for containers and Kubernetes</li>
				<li>Setting up Azure and GitHub</li>
				<li>Setting up a CI pipeline</li>
				<li>Setting up a CD pipeline</li>
			</ul>
			<p>Let's start by exploring the CI/CD lifecycle for containers and Kubernetes.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor176"/>CI/CD process for containers and Kubernetes</h2>
			<p>Before you start building a pipeline, it's good to understand the typical CI/CD process for containers and Kubernetes. In this section, the high-level process shown in <em class="italics">Figure 15.1 </em>will be explored in more depth. For a more detailed exploration on CI/CD and DevOps for Kubernetes, you are encouraged to explore the following free online eBook by Microsoft: <a href="">https://docs.microsoft.com/dotnet/architecture/containerized-lifecycle/</a>.</p>
			<div>
				<div id="_idContainer492" class="IMG---Figure">
					<img src="image/B17338_15_01.jpg" alt="A representation of the container and Kubernetes CI/CD process"/>
				</div>
			</div>
			<p class="figure">F<a id="_idTextAnchor177"/>igure 15.1: Container and Kubernetes CI/CD process</p>
			<p>The process starts with somebody making code changes. Code changes could mean application code changes, changes to the Dockerfile used to build the container, or changes to the Kubernetes YAML files used to deploy the application on a cluster.</p>
			<p>Once code changes are complete, those changes are committed to a source control system. Typically, this is a Git repository, but other systems, such as Subversion (SVN), also exist. In a Git repository, you would usually have multiple branches of your code. Branches enable multiple individuals and teams to work on the same code base in parallel without interfering with each other. Once the work done on a branch is complete, it is merged with the main (or master) branch. Once a branch is merged, the changes from that branch are shared with others using that code base.</p>
			<h4>Note</h4>
			<p class="callout">Branches are a powerful functionality of the Git source control system. There are multiple ways to manage how you use branches in a code base. Please refer to the chapter on branches in Scott Chacon and Ben Straub's <em class="italics">Pro Git</em> (Apress, 2014) for a more in-depth exploration of this topic: <a href="">https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell</a>.</p>
			<p>After code is pushed into source control, either in the main branch or a feature branch, a CI pipeline can be triggered. In a container-based application, this means that the code is built into a container image, that image is tested, and if tests succeed, it is pushed to a container registry. Depending on the branch, you could include different steps and different tests. For example, on feature branches you might only build and test the container to verify the code works but not push it to a registry, while on the main branch you might build and test the container and push it to a container registry.</p>
			<p>Finally, a CD pipeline can be triggered to deploy or update your application on Kubernetes. Typically, in a CD pipeline, the deployment moves through different stages. You can deploy your updated application first to a staging environment, where you can run both automated and manual tests on the application before moving it to production.</p>
			<p>Now that you've got an understanding of the CI/CD process for containers and Kubernetes, you can start building the example part of this chapter. Let's start with setting up Azure and GitHub to do this.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor178"/>Setting up Azure and GitHub</h2>
			<p>In this section, you'll set up the basic infrastructure you'll use to create and run the pipeline that you will build. To host your container images, you need a container registry. You could use a number of container registries, but here you'll create an Azure Container Registry instance because it is well integrated with <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>). After creating the container registry, you will need to link that container registry to your AKS cluster and create a new service principal, and then you'll need to set up a GitHub repository to run the example part of this chapter. Execute the following seven steps to complete this activity:</p>
			<ol>
				<li>To start, create a new container registry. In the Azure search bar, look for <strong class="inline">container registry</strong> and click on <span class="P---Screen-Text">Container registries</span>, as shown in <em class="italics">Figure 15.2:</em><div id="_idContainer493" class="IMG---Figure"><img src="image/B17338_15_02.jpg" alt="Searching for container registry in the Azure search bar"/></div><p class="figure">Figure 15.2: Navigating to the Container registry service through the Azure portal</p></li>
				<li>Click the <span class="P---Screen-Text">Create</span> button at the top to create a new registry. To organize the resources in this chapter together, create a new resource group. To do this, click on <span class="P---Screen-Text">Create new</span> to create a new resource group and call it <strong class="inline">rg-pipelines</strong>, as shown in <em class="italics">Figure 15.3:</em><div id="_idContainer494" class="IMG---Figure"><img src="image/B17338_15_03.jpg" alt="Clicking the Create new button to create a new resource group"/></div><p class="figure">Fig<a id="_idTextAnchor179"/>ure 15.3: Creating a new resource group</p><p>Provide the details required to create the registry. The registry name needs to be globally unique, so consider adding your initials to the registry name. It is recommended to create the registry in the same location as your cluster. To optimize the spend for the demo, you can change the SKU to <span class="P---Screen-Text">Basic</span>. Select the <span class="P---Screen-Text">Review + Create</span> button at the bottom to create the registry, as shown in <em class="italics">Figure 15.4:</em></p><div id="_idContainer495" class="IMG---Figure"><img src="image/B17338_15_04.jpg" alt="Clicking the Review + create button to create a new container registry"/></div><p class="figure">Figure 15.4: Creating a new container registry</p><p>In the resulting pane, click the <span class="P---Screen-Text">Create</span> button to create the registry.</p></li>
				<li>When your registry is created, open Cloud Shell so that you can configure your AKS cluster to get access to your container registry. Use the following command to give AKS permissions on your registry:<p class="snippet">az aks update -n handsonaks \</p><p class="snippet">-g rg-handsonaks --attach-acr &lt;acrName&gt;</p><p>This will return an output similar to <em class="italics">Figure 15.5</em>, which has been cropped to show only the top part of the output:</p><div id="_idContainer496" class="IMG---Figure"><img src="image/B17338_15_05.jpg" alt="Configuring the AKS cluster to get access to the container registry"/></div><p class="figure">Figure 15.5: Allowing AKS cluster to access the container registry</p></li>
				<li>Next, you'll need to create a service principal that will be used by GitHub Actions to connect to your subscription. You can create this service principal using the following command:<p class="snippet">az ad sp create-for-rbac --name "cicd-pipeline" \</p><p class="snippet">--sdk-auth --role contributor</p><p>You will need the full output JSON of this command, as highlighted in <em class="italics">Figure 15.6</em>, later in GitHub. Copy this output:</p><div id="_idContainer497" class="IMG---Figure"><img src="image/B17338_15_06.jpg" alt="Creating a new service principal"/></div><p class="figure">Figure<a id="_idTextAnchor180"/> 15.6: Creating a new service principal</p></li>
				<li>This completes the Azure part of the setup. Next, you'll need to log in to GitHub, fork the repo that comes with this book, and configure a secret in this repo. If you do not yet have a GitHub account, please create one via <a href="">https://github.com/join</a>. If you already have an account, please sign in using <a href="">https://github.com/login</a>.</li>
				<li>Once you are logged in to GitHub, browse to the repository associated with this book at <a href="">https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure-third-edition</a>. Create a fork of this repo in your account by clicking on the <span class="P---Screen-Text">Fork</span> button in the top-right corner of the screen, as shown in <em class="italics">Figure 15.7:</em><div id="_idContainer498" class="IMG---Figure"><img src="image/B17338_15_07.jpg" alt="Forking the GitHub repo"/></div><p class="figure">Figure <a id="_idTextAnchor181"/>15.7: Forking the GitHub repository</p><p>Forking the repo will create a copy of the repository in your own GitHub account. This will allow you to make changes to the repository, as you will do as you build the pipeline in this chapter.</p></li>
				<li>Forking the repository takes a couple of seconds. Once you have the fork in your own account, you'll need to configure the Azure secret in this repo. Start by clicking on <span class="P---Screen-Text">Settings</span> in the top-right corner of your repo, as shown in <em class="italics">Figure 15.8:</em></li>
			</ol>
			<div>
				<div id="_idContainer499" class="IMG---Figure">
					<img src="image/B17338_15_08.jpg" alt="Clicking on the Settings button in the GitHub repo"/>
				</div>
			</div>
			<p class="figure">Figure 15.8: Clicking on settings in the GitHub repository</p>
			<p>This will take you to the setting of your repo. On the left-hand side, click on <span class="P---Screen-Text">Secrets</span>, and on the resulting screen click on the <span class="P---Screen-Text">New repository secret</span> button at the top, as shown in <em class="italics">Figure 15.9:</em></p>
			<div>
				<div id="_idContainer500" class="IMG---Figure">
					<img src="image/B17338_15_09.jpg" alt="Creating a new repository secret"/>
				</div>
			</div>
			<p class="figure">Figure 15<a id="_idTextAnchor182"/>.9: Creating a new repository secret</p>
			<p>This will take you to the screen to create the new secret. Call this secret <strong class="inline">AZURE_CREDENTIALS</strong>, and as the value for the secret, paste in the output from the CLI command you issued in <em class="italics">step 4</em> of this section, as shown in <em class="italics">Figure 15.10:</em></p>
			<div>
				<div id="_idContainer501" class="IMG---Figure">
					<img src="image/B17338_15_10.jpg" alt="Setting the value for the new secret"/>
				</div>
			</div>
			<p class="figure">Figure 15.<a id="_idTextAnchor183"/>10: Setting of the value of the new secret</p>
			<p>Finally, click on <span class="P---Screen-Text">Add secret</span> at the bottom of this screen to save the secret.</p>
			<p>Now you have set up Azure and GitHub to start building your pipeline. You have created a service principal that GitHub will use to interact with Azure, and you created a container registry that your CI pipeline can push images to and that AKS can pull images from. Let's now build a CI pipeline.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor184"/>Setting up a CI pipeline</h2>
			<p>You are now ready to build a CI pipeline. As part of the demonstration in this section, you will build an <strong class="inline">nginx</strong> container with a small custom webpage loaded in it. After the container is built, you will push the <strong class="inline">nginx</strong> container to the container registry you created in the previous section. You will build the CI pipeline gradually over the next 13 steps:</p>
			<ol>
				<li value="1">To start, open the forked GitHub repo and open the folder for <strong class="inline">Chapter 15</strong>. In that folder, you will find a couple of files, including <strong class="inline">Dockerfile</strong> and <strong class="inline">index.html</strong>. These files are used to build the custom container. Throughout the example, you will make changes to <strong class="inline">index.html</strong> to trigger changes in the GitHub action. Let's have a look at the contents of <strong class="inline">index.html</strong>:<p class="snippet">1   &lt;html&gt;</p><p class="snippet">2   &lt;head&gt;</p><p class="snippet">3       &lt;title&gt;Version 1&lt;/title&gt;</p><p class="snippet">4   &lt;/head&gt;</p><p class="snippet">5   &lt;body&gt;</p><p class="snippet">6       &lt;h1&gt;Version 1&lt;/h1&gt;</p><p class="snippet">7   &lt;/body&gt;</p><p class="snippet">8   &lt;/html&gt;</p><p>This is a simple HTML file, with a title and a header both saying <strong class="inline">Version 1</strong>. In the <em class="italics">Setting up a CD pipeline</em> section, you'll be asked to increment the version.</p><p>Next, you were also provided with a Dockerfile. The contents of that file are as follows:</p><p class="snippet">1   FROM nginx:1.19.7-alpine</p><p class="snippet">2   COPY index.html /usr/share/nginx/html/index.html</p><p>This Dockerfile starts from an <strong class="inline">nginx-alpine</strong> base image. Nginx is a popular open-source web server, and Alpine is a lightweight operating system often used for container images. In the second line, you copy the local <strong class="inline">index.html</strong> file into the container, into the location where <strong class="inline">nginx</strong> loads webpages from.</p><p>Now that you have an understanding of the application itself, you're ready to start building the CI pipeline. For your reference, the full definition of the CI pipeline is provided as <strong class="inline">pipeline-ci.yaml</strong> in the code files with this chapter, but you'll be instructed to build this pipeline step by step in what follows.</p></li>
				<li>Let's start by creating a GitHub Actions workflow. At the top of the screen in GitHub, click on <span class="P---Screen-Text">Actions</span> and then click on the <span class="P---Screen-Text">set up a workflow yourself</span> link, as shown in <em class="italics">Figure 15.11:</em><div id="_idContainer502" class="IMG---Figure"><img src="image/B17338_15_11.jpg" alt="Clicking the Set up a workflow yourself button to create a new GitHub action"/></div><p class="figure">Figure 15.1<a id="_idTextAnchor185"/>1: Creating a new GitHub action</p></li>
				<li>This will take you to a code editor that is part of GitHub. First, change the name of the pipeline file to <strong class="inline">pipeline.yaml</strong> and change the name on <em class="italics">line 3</em> to <strong class="inline">pipeline</strong>, as shown in <em class="italics">Figure 15.12:</em><div id="_idContainer503" class="IMG---Figure"><img src="image/B17338_15_12.jpg" alt="Changing the name of the pipeline"/></div><p class="figure">Figure 15.12<a id="_idTextAnchor186"/>: Changing the name of the pipeline</p></li>
				<li>Next, you'll focus on the triggers of the workflow. In this demonstration, you'll only work with the main branch. However, you do not want the workflow to run for every code change. You only want it to run when changes are made to either the pipeline definition or the code in the <strong class="inline">Chapter 15</strong> folder. To achieve this, you can set up the following code to control the workflow trigger:<p class="snippet">4   # Controls when the action will run. </p><p class="snippet">5   on:</p><p class="snippet">6     # Triggers the workflow on push or pull request events but only for the main branch</p><p class="snippet">7     push:</p><p class="snippet">8       branches: [ main ]</p><p class="snippet">9       paths: </p><p class="snippet">10      - Chapter15/**</p><p class="snippet">11      - .github/workflows/pipeline.yaml  </p><p class="snippet">12    # Allows you to run this workflow manually from the Actions tab</p><p class="snippet">13    workflow_dispatch:</p><p>What this code configures is the following:</p><ul><li><strong class="bold">Line 8</strong>: Configures which branches will trigger this workflow. Specifically, in this case, this indicates that the workflow is triggered by pushing code to the main branch.</li><li><strong class="bold">Line 9-11</strong>: This configures a path filter. Any changes in the <strong class="inline">Chapter15</strong> directory as well as changes to the <strong class="inline">pipeline.yaml</strong> file in the <strong class="inline">.github/workflows/</strong> directory will trigger the workflow to run.</li><li><strong class="bold">Line 13</strong>: This configures the workflow in such a way that it can be triggered manually as well. This means that you can trigger the workflow to run without making a code change.</li></ul><p>You can also configure reusable variables in a GitHub Actions workflow. The following code block configures the container registry name you will use in multiple steps in the GitHub action:</p><p class="snippet">14  # Env to set reusable variables</p><p class="snippet">15  env:</p><p class="snippet">16    ACRNAME: &lt;acr-name&gt;</p><p>Here, you are setting the <strong class="inline">ACRNAME</strong> variable to the name of the container registry you created. By using variables, you avoid having to configure the same value in multiple places.</p><p>That explains how the pipeline is triggered and how you can configure variables; let's now look at what will run in the pipeline.</p></li>
				<li>Before we define the commands that are executed in the pipeline, let's explore the structure of a GitHub Actions workflow, as shown in <em class="italics">Figure 15.13:</em></li>
			</ol>
			<div>
				<div id="_idContainer504" class="IMG---Figure">
					<img src="image/B17338_15_13.jpg" alt="A representation of the GitHub action structure"/>
				</div>
			</div>
			<p class="figure">Figure 15.13:<a id="_idTextAnchor187"/> GitHub Actions workflow</p>
			<p>A GitHub Actions workflow is made up of multiple jobs. A job can then have multiple steps in it. Jobs run in parallel by default but can be configured to run sequentially. The steps in a job will be run sequentially. A step in a job will contain the actual commands that will be run as part of the pipeline. An example of a step would be building a container image. There are multiple ways to run commands in a workflow: you can either run direct shell commands as you would on a regular terminal, or you can run prebuilt actions from the GitHub community.</p>
			<p>The jobs and steps are run on what is called a runner. By default, workflows are run on hosted runners. These hosted runners run on infrastructure set up and managed by GitHub. Optionally, you can run the jobs and steps on a self-hosted runner. This gives you the ability to have more configuration capabilities on the runner, for instance, to allow you to use special hardware or have specific software installed. Self-hosted runners can be physical, virtual, in a container, on-premises, or in a cloud.</p>
			<p>In this section, you will run workflow steps from the community as well as shell commands. For an overview of actions available from the community, please refer to the GitHub marketplace at <a href="">https://github.com/marketplace?type=actions</a>.</p>
			<p>In the CI pipeline you are building, you'll need to execute the following steps:</p>
			<ol>
				<li value="1">Get the GitHub repo on the action runner, also called a check-out of your repository.</li>
				<li>Log in to the Azure CLI.</li>
				<li>Log in to Azure Container Registry.</li>
				<li>Build a container image and push this container image to Azure Container Registry.</li>
			</ol>
			<p>Let's build the pipeline step by step.</p>
			<ol>
				<li value="1">Before you build the actual steps in the pipeline, you'll need to configure the jobs and the configuration of your job. Specifically, for this example, you can use the following configuration:<p class="snippet">18  jobs:</p><p class="snippet">19    # This workflow contains a single job called "CI"</p><p class="snippet">20    CI:</p><p class="snippet">21      # The type of runner that the job will run on</p><p class="snippet">22      runs-on: ubuntu-latest</p><p>You are configuring the following:</p><ul><li><strong class="bold">Line 20</strong>: You are creating a single job called <strong class="inline">CI</strong> for now. You'll add the CD job later.</li><li><strong class="bold">Line 22</strong>: This indicates that you'll run this job on a machine of type <strong class="inline">ubuntu-latest</strong>.</li></ul><p>This configures the GitHub runner for the steps. Let's now start building the individual steps.</p></li>
				<li>The first step will be checking out the Git repo. This means that the code in the repo gets loaded by the runner. This can be achieved using the following lines of code:<p class="snippet">25      steps:</p><p class="snippet">26        # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</p><p class="snippet">27        - name: Git checkout</p><p class="snippet">28          uses: actions/checkout@v2</p><p>The first line represented here (<em class="italics">line 25</em>) is what opens the <strong class="inline">steps</strong> block and all the following steps. The first step is called <strong class="inline">Git checkout</strong> (<em class="italics">line 27</em>) and simply refers to a prebuilt action called <strong class="inline">actions/checkout@v2</strong>. The <strong class="inline">@v2</strong> means that you are using the second version of this action.</p></li>
				<li>Next, you will need to log in to the Azure CLI and then use the Azure CLI to log in to the Azure Container Registry. To do so, you'll make use of an action from the marketplace. You can find items in the marketplace by using the search bar at the right side of your screen, as shown in <em class="italics">Figure 15.14:</em><div id="_idContainer505" class="IMG---Figure"><img src="image/B17338_15_14.jpg" alt="Searching for the Azure Login action in the GitHub Marketplace"/></div><p class="figure">Figure 15.14: Searching for the Azure Login action</p><p>For this demonstration, you will use the Azure Login action. Click on the <span class="P---Screen-Text">Azure Login</span> action to get a screen with more information, as shown in <em class="italics">Figure 15.15:</em></p><div id="_idContainer506" class="IMG---Figure"><img src="image/B17338_15_15.jpg" alt="Additional information and somesample code for the Azure Login action"/></div><p class="figure">Figure 15.15: More details about the Azure Login action</p><p>This shows you more information on how to use that action and gives you sample code that you can copy and paste into the workflow editor.</p><p>To log in to the Azure CLI and Azure Container Registry, you can use the following code:</p><p class="snippet">30        - name: az CLI login</p><p class="snippet">31          uses: azure/login@v1</p><p class="snippet">32          with:</p><p class="snippet">33            creds: ${{ secrets.AZURE_CREDENTIALS }}</p><p class="snippet">34</p><p class="snippet">35        - name: ACR login</p><p class="snippet">36          run: az acr login -n $ACRNAME</p><p>The first step logs in to the Azure CLI on the GitHub Actions runner. To log in to the Azure CLI, it uses the secret you configured in the previous section. The second job executes an Azure CLI command to log in to Azure Container Registry. It uses the variable you configured on <em class="italics">lines 14-15</em>. It executes the <strong class="inline">login</strong> command as a regular shell command. In the next step, you'll push the image to this container registry.</p></li>
				<li>Next, you build the container image. There are multiple ways to do this, and you'll use <strong class="inline">docker/build-push-action</strong> in this example:<p class="snippet">39        - name: Build and push image</p><p class="snippet">40          uses: docker/build-push-action@v2</p><p class="snippet">41          with:</p><p class="snippet">42            context: ./Chapter15</p><p class="snippet">43            push: true</p><p class="snippet">44            tags: ${{ env.ACRNAME }}.azurecr.io/website/website:${{ github.run_number }}</p><p>This step will build your container image and push it to the registry. You configure the context to run within the <strong class="inline">Chapter15</strong> folder, so the reference in the Dockerfile to the <strong class="inline">index.html</strong> page remains valid. It will tag that image with the name of your container registry, and as a version number for the container image, it will use the run number of the GitHub action. To get the run number of the workflow, you are using one of the default environment variables that GitHub configures. For a full list, please refer to the GitHub documentation: <a href="">https://docs.github.com/actions/reference/environment-variables</a>.</p><h4>Note</h4><p class="callout">In this example, you are using the workflow run number as the version for your container image. Tagging container images is important since the tag version indicates the version of the container. There are multiple other strategies as well to version your container images.</p><p class="callout">One strategy that is discouraged is to tag container images with the latest tag and use that tag in your Kubernetes deployments. The <strong class="inline">latest</strong> tag is the default tag that Docker will add to images if no tag is supplied. The problem with the <strong class="inline">latest</strong> tag is that if the image with the <strong class="inline">latest</strong> tag in your container registry changes, Kubernetes will not pick up this change directly. On nodes that have a local copy of the image with the <strong class="inline">latest</strong> tag, Kubernetes will not pull the new image until a timeout expires; however, nodes that don't have a copy of the image will pull the updated version when they need to run a pod with this image. This can cause you to have different versions running in a single deployment, which should be avoided.</p></li>
				<li>You are now ready to save and run this GitHub Actions workflow. You can save the workflow configuration file by clicking on the <span class="P---Screen-Text">Start Commit</span> button and then confirming by clicking <span class="P---Screen-Text">Commit new file</span>, as shown in <em class="italics">Figure 15.16:</em><div id="_idContainer507" class="IMG---Figure"><img src="image/B17338_15_16.jpg" alt="Saving the action configuration file"/></div><p class="figure">Figure 15.16: Sa<a id="_idTextAnchor188"/>ving the action configuration file</p></li>
				<li>Once the file has been saved, the workflow will be triggered to run. To follow the logs of the workflow run, you can click on <span class="P---Screen-Text">Actions</span> at the top of the screen. This should show you a screen similar to <em class="italics">Figure 15.17:</em><div id="_idContainer508" class="IMG---Figure"><img src="image/B17338_15_17.jpg" alt="Viewing the Actions run history"/></div><p class="figure">Figure 15.17: Get<a id="_idTextAnchor189"/>ting the actions run history</p><p>Click on the top entry to get more details of your workflow run. This will bring you to a screen similar to <em class="italics">Figure 15.18:</em></p><div id="_idContainer509" class="IMG---Figure"><img src="image/B17338_15_18.jpg" alt="A detailed view of the action run"/></div><p class="figure">Figure 15.18: Deta<a id="_idTextAnchor190"/>il screen of the action run</p><p>This shows you your workflow detail and shows you that you had a single job in your workflow. Click on <span class="P---Screen-Text">CI</span> to get the logs of that job. This will show you a screen similar to <em class="italics">Figure 15.19:</em></p><div id="_idContainer510" class="IMG---Figure"><img src="image/B17338_15_19.jpg" alt="Viewing logs of the CI job"/></div><p class="figure">Figure 15.19: Logs <a id="_idTextAnchor191"/>of the CI job</p><p>On this screen, you can see the output logs of each step in your workflow. You can expand the logs of each step by clicking on the arrow icon in front of that step.</p></li>
				<li>In this example, you built a container image and pushed that to a container registry on Azure. Let's verify this image was indeed pushed to the registry. For this, go back to the Azure portal and, in the search bar, look for <strong class="inline">container registry</strong>, as shown in <em class="italics">Figure 15.20:</em><div id="_idContainer511" class="IMG---Figure"><img src="image/B17338_15_20.jpg" alt="Searching for container registry using the Azure search bar"/></div><p class="figure">Figure 15.20: Navigating to the Container registries service through the Azure portal</p><p>In the resulting screen, click on the registry you created earlier. Now, click on <span class="P---Screen-Text">Repositories</span> on the left-hand side, which should show you the <strong class="inline">website/website</strong> repository, as shown in <em class="italics">Figure 15.21:</em></p><div id="_idContainer512" class="IMG---Figure"><img src="image/B17338_15_21.jpg" alt="Viewing the website/website repository in the container registry"/></div><p class="figure">Figure 15.21: Showing<a id="_idTextAnchor192"/> the website/website repository in the container registry</p></li>
				<li>If you click on the <strong class="inline">website/website</strong> repository link, you should see the image tags for your container image, as shown in <em class="italics">Figure 15.22:</em></li>
			</ol>
			<div>
				<div id="_idContainer513" class="IMG---Figure">
					<img src="image/B17338_15_22.jpg" alt="Viewing the image tags for the container image"/>
				</div>
			</div>
			<p class="figure">Figure 15.22: Image tags for the container image</p>
			<p>If you compare the output of <em class="italics">Figure 15.18</em> and <em class="italics">Figure 15.22</em>, you will see that the run number of the action is also the tag on the image. In your case, that run number and tag will likely be <span class="P---Screen-Text">1</span>.</p>
			<p>You have now built a rudimentary CI pipeline. When the code in the <strong class="inline">Chapter 15</strong> folder is changed, the pipeline will run and build a new container image that will be pushed to the container registry. In the next section, you will add a CD job to your pipeline to also deploy the image to a deployment in Kubernetes.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor193"/>Setting up a CD pipeline</h2>
			<p>You already have a pipeline with a CI job that will build a new container image. In this section, you'll add a CD job to that pipeline that will deploy the updated container image to a deployment in Kubernetes.</p>
			<p>To simplify the application deployment, a Helm Chart for the application has been provided in the <strong class="inline">website</strong> folder inside <strong class="inline">Chapter 15</strong>. You can deploy the application by deploying the Helm Chart. By deploying using a Helm Chart, you can override the Helm values using the command line. You've done this in <em class="italics">Chapter 12, Connecting an app to an Azure database</em>, when you configured WordPress to use an external database.</p>
			<p>In this CD job you will need to execute the following steps:</p>
			<ol>
				<li value="1">Check out the code.</li>
				<li>Get AKS credentials.</li>
				<li>Set up the application.</li>
				<li>(Optional) Get the service's public IP.</li>
			</ol>
			<p>Let's start building the CD pipeline. For your reference, the full CI and CD pipeline has been provided in the <strong class="inline">pipeline-cicd.yaml</strong> file:</p>
			<ol>
				<li value="1">To add the CD job to the pipeline, you'll need to edit the <strong class="inline">pipeline.yaml</strong> file. To do this, from within your forked repository, click on <span class="P---Screen-Text">Code</span> at the top of the screen and go to the <strong class="inline">.github/workflows</strong> folder. In that folder, click on the <strong class="inline">pipeline.yaml</strong> file. Once that file is open, click on the pen icon in the top right, as highlighted in <em class="italics">Figure 15.23:</em><div id="_idContainer514" class="IMG---Figure"><img src="image/B17338_15_23.jpg" alt="Clicking on the pen icon to edit the pipeline.yaml file"/></div><p class="figure">Figure 15.23: Editing the pipeline.yaml file</p></li>
				<li>In the file, at the bottom, start by adding the following lines to define the CD job:<p class="snippet">46    CD:</p><p class="snippet">47      runs-on: ubuntu-latest</p><p class="snippet">48      needs: CI</p><p class="snippet">49      steps:</p><p>In this code block, you are creating the CD job. This will again run on an <strong class="inline">ubuntu-latest</strong> runner. On <em class="italics">line 48</em>, you are defining that this job has a dependency on the CI job. This means that this job will only start after the CI job finishes, and it will only run if the CI job finishes successfully. Finally, <em class="italics">line 49</em> opens the <strong class="inline">steps</strong> block, which you will fill in next.</p></li>
				<li>The first step will be a Git checkout. This will use the same step you use in the CI job as well:<p class="snippet">50        - name: Git checkout</p><p class="snippet">51          uses: actions/checkout@v2</p></li>
				<li>Next, you'll need to log in to the Azure CLI and get the AKS credentials. You could do this by using the same approach as you did in the CI job, meaning you could do an Azure CLI login and then run the <strong class="inline">az aks get-credentials</strong> command on the runner. However, there is a single GitHub action that can achieve this for AKS:<p class="snippet">53        - name: Azure Kubernetes set context</p><p class="snippet">54          uses: Azure/aks-set-context@v1</p><p class="snippet">55          with:</p><p class="snippet">56            creds: ${{ secrets.AZURE_CREDENTIALS }}</p><p class="snippet">57            resource-group: rg-handsonaks</p><p class="snippet">58            cluster-name: handsonaks</p><p>This step uses the <strong class="inline">Azure/aks-set-context</strong> action from Microsoft. You configure it with the Azure credentials secrets you created, and then define the resource group and cluster name you want to use. This will configure the GitHub action runner to use those AKS credentials.</p></li>
				<li>You can now create the application on the cluster. As mentioned in the introduction of this section, you will deploy the application using the Helm Chart created in the <strong class="inline">website</strong> folder for this chapter. To deploy this Helm Chart on your cluster, you can use the following code:<p class="snippet">60        - name: Helm upgrade</p><p class="snippet">61          run: |</p><p class="snippet">62            helm upgrade website Chapter15/website --install \</p><p class="snippet">63              --set image.repository=$ACRNAME.azurecr.io/website/website \</p><p class="snippet">64              --set image.tag=${{ github.run_number }}</p><p>This code block executes a <strong class="inline">Helm upgrade</strong> command. The first argument (<strong class="inline">website</strong>) refers to the name of the Helm release. The second argument (<strong class="inline">Chapter15/website</strong>) refers to the location of the Helm Chart. The <strong class="inline">--install</strong> parameter configures Helm in such a way that if the chart isn't installed yet, it will be installed. This will be the case the first time you run this action.</p><p>In the following two lines, you set Helm values. You set the image repository to the <strong class="inline">website/website</strong> repo in your container registry, and you set the tag to the run number of the action. This is the same value you are using in the CI step to tag the image.</p></li>
				<li>Finally, there is one optional step you can include in your workflow. This is getting the public IP address of the service that will be created to serve your website. This is optional because you could get this IP address using <strong class="inline">kubectl</strong> in Azure Cloud Shell, but it has been provided for your convenience:<p class="snippet">66        - name: Get service IP</p><p class="snippet">67          run: |</p><p class="snippet">68            PUBLICIP=""</p><p class="snippet">69            while [ -z $PUBLICIP ]; do</p><p class="snippet">70              echo "Waiting for public IP..."</p><p class="snippet">71              PUBLICIP=$(kubectl get service website -o jsonpath='{.status.loadBalancer.ingress[0].ip}')</p><p class="snippet">72              [ -z "$PUBLICIP" ] &amp;&amp; sleep 10</p><p class="snippet">73            done</p><p class="snippet">74            echo $PUBLICIP</p><p>This code block will run a small Bash script. While the public IP hasn't been set, it will keep getting the public IP from the service using <strong class="inline">kubectl</strong>. Once the public IP has been set, the public IP will be shown in the GitHub Actions log.</p></li>
				<li>You are now ready to save the updated pipeline and run it for the first time. To save the pipeline, click on the <span class="P---Screen-Text">Start commit</span> button at the top right of the screen and click on <span class="P---Screen-Text">Commit changes</span> in the pop-up window, as shown in <em class="italics">Figure 15.24:</em><div id="_idContainer515" class="IMG---Figure"><img src="image/B17338_15_24.jpg" alt="Saving the updated pipeline"/></div><p class="figure">Figure 15.24: Pipeline workflow</p></li>
				<li>Once you have committed the changes to GitHub, the workflow will be triggered to run. To follow the deployment, click on <span class="P---Screen-Text">Actions</span> at the top of the screen. Click on the top entry here to see the details of the run. Initially, the output will look similar to <em class="italics">Figure 15.25:</em><div id="_idContainer516" class="IMG---Figure"><img src="image/B17338_15_25.jpg" alt="A detailed output of the action run while the action is running"/></div><p class="figure">Figure 15.25: Detailed ou<a id="_idTextAnchor194"/>tput of the action run while the action is running</p><p>As you can see, you now have access to two jobs in this workflow run, the CI job and the CD job. While the CI job is running, the CD job's logs won't be available. Once the CI job finishes successfully, you'll be able to access the logs of the CD job. Wait for a couple of seconds until the screen looks like <em class="italics">Figure 15.26</em>, which indicates that the workflow successfully finished:</p><div id="_idContainer517" class="IMG---Figure"><img src="image/B17338_15_26.jpg" alt="A detailed output of the action run after both jobs are finished"/></div><p class="figure">Figure 15.26: Detailed out<a id="_idTextAnchor195"/>put of the action run after both jobs finished</p></li>
				<li>Now, click on the CD job to see the logs of this job. Click on the arrow next to <span class="P---Screen-Text">Get service IP</span> to see the public IP of the service that got created, as shown in <em class="italics">Figure 15.27:</em><div id="_idContainer518" class="IMG---Figure"><img src="image/B17338_15_27.jpg" alt="Logs of the CD job showing the public IP address of the service"/></div><p class="figure">Figure 15.27: Logs of the CD job showing the public IP address of the service</p><p>Open a new tab in your web browser to visit your website. You should see an output similar to <em class="italics">Figure 15.28:</em></p><div id="_idContainer519" class="IMG---Figure"><img src="image/B17338_15_28.jpg" alt="Website running version 1"/></div><p class="figure">Figure 15.28: Website runnin<a id="_idTextAnchor196"/>g version 1</p></li>
				<li>Let's now test the end-to-end pipeline by making a change to the <strong class="inline">index.html</strong> file. To do this, in GitHub, click on <span class="P---Screen-Text">Code</span> at the top of the screen, open <strong class="inline">Chapter15</strong>, and click on the <strong class="inline">index.html</strong> file. In the resulting window, click on the pen icon in the top right, as shown in <em class="italics">Figure 15.29:</em><div id="_idContainer520" class="IMG---Figure"><img src="image/B17338_15_29.jpg" alt="Clicking on the pen icon to edit the index.html file"/></div><p class="figure">Figure 15.29: Clicking on the<a id="_idTextAnchor197"/> pen icon to edit the index.html file</p></li>
				<li>You can now edit the file. Change the version of the website to <strong class="inline">version 2</strong> (or any other changes you might want to make), and then scroll to the bottom of the screen to save the changes. Click on the <span class="P---Screen-Text">Commit changes</span> button to commit the changes to GitHub, as shown in <em class="italics">Figure 15.30:</em><div id="_idContainer521" class="IMG---Figure"><img src="image/B17338_15_30.jpg" alt="Saving the changes to the index.html file"/></div><p class="figure">Figure 15.30: Saving the chang<a id="_idTextAnchor198"/>es to the index.html file</p></li>
				<li>This will trigger the workflow to be run. It will run through both the CI and CD jobs. This means that a new container will be built, with an updated <strong class="inline">index.html</strong> file. You can follow the status of the workflow run as you've done before, by clicking on <span class="P---Screen-Text">Actions</span> at the top of the screen and clicking on the top run. Wait until the job has finished, as shown in <em class="italics">Figure 15.31:</em><div id="_idContainer522" class="IMG---Figure"><img src="image/B17338_15_31.jpg" alt="Action run after updating index.html"/></div><p class="figure">Figure 15.31: Action run after updating index.html</p></li>
				<li>If you now browse back to the IP address you got as an output of <em class="italics">step 9</em>, you should see the updated webpage showing you <span class="P---Screen-Text">Version 2</span>, as shown in <em class="italics">Figure 15.32:</em></li>
			</ol>
			<div>
				<div id="_idContainer523" class="IMG---Figure">
					<img src="image/B17338_15_32.jpg" alt="The webpage has been updated to version 2"/>
				</div>
			</div>
			<p class="figure">Figure 15.32: The web page has b<a id="_idTextAnchor199"/>een updated to version 2</p>
			<p>This has shown you that the pipeline executed successfully and has brought your code changes to production.</p>
			<h4>Note</h4>
			<p class="callout">In this example, you updated the production version of your website directly, without any approvals. GitHub Actions also allows you to configure manual approvals in case you want to test changes before promoting them to production. To configure manual approvals, you can use the environments functionality in GitHub Actions. For more information, please refer to <a href="">https://docs.github.com/en/actions/reference/environments</a>.</p>
			<p>This concludes this example of CI and CD using GitHub Actions. Let's make sure to clean up the resource you created for this chapter. In Cloud Shell, execute the following commands:</p>
			<p class="snippet">helm uninstall website</p>
			<p class="snippet">az group delete -n rg-pipelines --yes</p>
			<p>Since this also marks the end of the examples in this book, you can now also delete the cluster itself if you do not need it anymore. If you wish to do so, you can use the following command to delete the cluster:</p>
			<p class="snippet">az group delete -n rg-handsonaks --yes</p>
			<p>This way, you ensure you aren't paying for the resources if you're no longer using them after you've finished the examples in this book.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor200"/>Summary</h2>
			<p>You have now successfully created a CI/CD pipeline for your Kubernetes cluster. CI is the process of frequently building and testing software, whereas CD is the practice of regularly deploying software.</p>
			<p>In this chapter, you used GitHub Actions as a platform to build a CI/CD pipeline. You started by building the CI pipeline. In that pipeline, you built a container image and pushed it to the container registry.</p>
			<p>Finally, you also added a CD pipeline to deploy that container image to your Kubernetes cluster. You were able to verify that by making code changes to a webpage, the pipeline was triggered and code changes were pushed to your cluster.</p>
			<p>The CI/CD pipeline you built in this chapter is a starter pipeline that lays the foundation for a more robust CI/CD pipeline that you can use to deploy applications to production. You should consider adding more tests to the pipeline and also integrate it with different branches before using it in production.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor201"/>Final thoughts</h2>
			<p>This chapter also concludes this book. During the course of this book, you've learned how to work with AKS through a series of hands-on examples.</p>
			<p>The book started by covering the basics; you learned about containers and Kubernetes and you created an AKS cluster.</p>
			<p>The next section focused on application deployment on AKS. You learned different ways of deploying applications to AKS, how to scale applications, how to debug failures, and how to secure services using HTTPS.</p>
			<p>The next sections focused on security in AKS. You learned about role-based access control in Kubernetes and how you can integrate AKS with Azure Active Directory. Then, you learned about pod identities, and pod identities were used in a couple of follow-up chapters. After that, you learned how to securely store secrets in AKS, and then we focused on network security.</p>
			<p>The final section of this book focused on a number of advanced integrations of AKS with other services. You deployed an Azure database through the Kubernetes API and integrated it with a WordPress application on your cluster. You then explored how to monitor configuration and remediate threats on your cluster using Azure Security Center. You then deployed Azure functions on your cluster and scaled them using KEDA. In this final chapter, you configured a CI/CD pipeline to automatically deploy an application to Kubernetes based on code changes.</p>
			<p>If you've successfully completed all the examples provided in this book, you should now be ready to build and run applications at scale on top of AKS.</p>
		</div>
	</body></html>