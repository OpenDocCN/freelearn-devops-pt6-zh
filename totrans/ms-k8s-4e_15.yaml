- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dig deep into the guts of Kubernetes. We will start
    with the Kubernetes API and learn how to work with Kubernetes programmatically
    via direct access to the API, the controller-runtime Go library, and automating
    kubectl. Then, we’ll look into extending the Kubernetes API with custom resources.
    The last part is all about the various plugins Kubernetes supports. Many aspects
    of Kubernetes operation are modular and designed for extension. We will examine
    the API aggregation layer and several types of plugins, such as custom schedulers,
    authorization, admission control, custom metrics, and volumes. Finally, we’ll
    look into extending kubectl and adding your own commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The covered topics are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Kubernetes API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the Kubernetes API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Kubernetes and kubectl plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes API is comprehensive and encompasses the entire functionality
    of Kubernetes. As you may expect, it is huge. But it is designed very well using
    best practices, and it is consistent. If you understand the basic principles,
    you can discover everything you need to know. We covered the Kubernetes API itself
    in *Chapter 1*, *Understanding Kubernetes Architecture*. If you need a refresher,
    go and take a look. In this section, we’re going to dive deeper and learn how
    to access and work with the Kubernetes API. But, first let’s look at OpenAPI,
    which is the formal foundation that gives structure to the entire Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OpenAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAPI (formerly Swagger) is an open standard that defines a language- and
    framework-agnostic way to describe RESTful APIs. It provides a standardized, machine-readable
    format for describing APIs, including their endpoints, parameters, request and
    response bodies, authentication, and other metadata.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Kubernetes, OpenAPI is used to define and document the API
    surface of a Kubernetes cluster. OpenAPI is used in Kubernetes to provide a standardized
    way to document and define the API objects that can be used to configure and manage
    the cluster. The Kubernetes API is based on a declarative model, where users define
    the desired state of their resources using YAML or JSON manifests. These manifests
    follow the OpenAPI schema, which defines the structure and properties of each
    resource. Kubernetes uses the OpenAPI schema to validate manifests, provide auto-completion
    and documentation in API clients, and generate API reference documentation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of using OpenAPI in Kubernetes is that it enables code
    generation for client libraries. This allows developers to interact with the Kubernetes
    API using their programming language of choice and generated client libraries,
    which provide a native and type-safe way to interact with the API.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, OpenAPI allows tools like kubectl to provide autocompletion and
    validation for Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI also enables automated documentation generation for the Kubernetes API.
    With the OpenAPI schema, Kubernetes can automatically generate API reference documentation,
    which serves as a comprehensive and up-to-date resource for understanding the
    Kubernetes API and its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has had stable support for OpenAPI v3 since Kubernetes 1.27.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://www.openapis.org](https://www.openapis.org) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In order to work with the Kubernetes API locally, we need to set up a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simplify access, you can use kubectl to set up a proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can access the API server on `http://localhost:8080` and it will reach
    the same Kubernetes API server that kubectl is configured for.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Kubernetes API directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes API is highly discoverable. You can just browse to the URL of
    the API server at `http://localhost:8080` and get a nice JSON document that describes
    all the available operations under the `paths` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a partial list due to space constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can drill down any one of the paths. For example, to discover the endpoint
    for the `default` namespace, I first called the `/api` endpoint, then discovered
    `/api/v1`, which told me there was `/api/v1/namespaces`, which pointed me to `/api/v1/namespaces/default`.
    Here is the response from the `/api/v1/namespaces/default` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can explore the Kubernetes API from the command line using tools like cURL
    or even kubectl itself, but sometimes using a GUI application is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Using Postman to explore the Kubernetes API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Postman ([https://www.getpostman.com](https://www.getpostman.com)) is a very
    polished application for working with RESTful APIs. If you lean more to the GUI
    side, you may find it extremely useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the available endpoints under the batch v1 API
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: The available endpoints under the batch v1 API group'
  prefs: []
  type: TYPE_NORMAL
- en: Postman has a lot of options, and it organizes the information in a very pleasing
    way. Give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the output with HTTPie and jq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The output from the API can be too verbose sometimes. Often, you’re interested
    just in one value out of a huge chunk of a JSON response. For example, if you
    want to get the names of all running services, you can hit the `/api/v1/services`
    endpoint. The response, however, includes a lot of additional information that
    is irrelevant. Here is a very partial subset of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The complete output is 193 lines long! Let’s see how to use HTTPie and jq to
    gain full control over the output and show only the names of the services. I prefer
    HTTPie([https://httpie.org/](https://httpie.org/)) over cURL for interacting with
    REST APIs on the command line. The jq ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    command-line JSON processor is great for slicing and dicing JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the full output, you can see that the service name is in the `metadata`
    section of each item in the `items` array. The jq expression that will select
    just the name is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the full command and output on a fresh kind cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the Kubernetes API via the Python client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exploring the API interactively using HTTPie and jq is great, but the real power
    of APIs comes when you consume and integrate them with other software. The Kubernetes
    Incubator project provides a full-fledged and very well-documented Python client
    library. It is available at [https://github.com/kubernetes-incubator/client-python](https://github.com/kubernetes-incubator/client-python).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure you have Python installed ([https://wiki.python.org/moin/BeginnersGuide/Download](https://wiki.python.org/moin/BeginnersGuide/Download)).
    Then install the Kubernetes package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To start talking to a Kubernetes cluster, you need to connect to it. Start
    an interactive Python session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python client can read your kubectl config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can connect directly to an already running proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `client` module provides methods to get access to different group
    versions, such as `CoreV1Api`.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the CoreV1Api group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s dive in and understand the `CoreV1Api` group. The Python object has 407
    public attributes!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We ignore the attributes that start with double underscores because those are
    special class/instance methods unrelated to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pick ten random methods and see what they look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Very interesting. The attributes begin with a verb such as `replace`, `list`,
    or `create`. Many of them have a notion of a namespace and many have a `with_http_info`
    suffix. To understand this better, let’s count how many verbs exist and how many
    attributes use each verb (where the verb is the first token before the underscore):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can drill further and look at the interactive help for a specific attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We see that the API is vast, which makes sense because it represents the entire
    Kubernetes API. We also learned how to discover groups of related methods and
    how to get detailed information on specific methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can poke around yourself and learn more about the API. Let’s look at some
    common operations, such as listing, creating, and watching objects.
  prefs: []
  type: TYPE_NORMAL
- en: Listing objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can list different kinds of objects. The method names start with `list_`.
    Here is an example listing all namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create an object, you need to pass a `body` parameter to the `create` method.
    The `body` must be a Python dictionary that is equivalent to a YAML configuration
    manifest you would use with kubectl. The easiest way to do it is to actually use
    a YAML manifest and then use the Python YAML module (not part of the standard
    library and must be installed separately) to read the YAML file and load it into
    a dictionary. For example, to create an `nginx-deployment` with 3 replicas, we
    can use this YAML manifest (`nginx-deployment.yaml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the `yaml` Python module, type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the following Python program (`create_nginx_deployment.py`) will create
    the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run it and check the deployment was actually created using kubectl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Watching objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Watching objects is an advanced capability. It is implemented using a separate
    `watch` module. Here is an example of watching 10 namespace events and printing
    them to the screen (`watch_demo.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that only 5 events were printed (one for each namespace) and the program
    continues to watch for more events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create and delete some namespaces in a separate terminal window, so the
    program can end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can of course react to events and perform a useful action when an event
    happens (e.g., automatically deploy a workload in each new namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pod via the Kubernetes API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The API can be used for creating, updating, and deleting resources too. Unlike
    working with kubectl, the API requires specifying the manifests in JSON and not
    YAML syntax (although every JSON document is also valid YAML). Here is a JSON
    pod definition (`nginx-pod.json`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will create the pod via the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To verify it worked, let’s extract the name and status of the current pods.
    The endpoint is `/api/v1/namespaces/default/pods`.
  prefs: []
  type: TYPE_NORMAL
- en: The jq expression is `items[].metadata.name,.items[].status.phase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full command and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Controlling Kubernetes using Go and controller-runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is cool and easy to work with, but for production-level tools, controllers,
    and operators, I prefer to use Go, and in particular the controller-runtime project.
    The controller-runtime is the standard Go client to use to access the Kubernetes
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Using controller-runtime via go-k8s
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The controller-runtime project is a set of Go libraries that can fully query
    and manipulate Kubernetes in a very efficient manner (e.g., advanced caching to
    avoid overwhelming the API server).
  prefs: []
  type: TYPE_NORMAL
- en: Working directly with controller-runtime is not easy. There are many interlocking
    pieces and different ways to accomplish things.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://pkg.go.dev/sigs.k8s.io/controller-runtime](https://pkg.go.dev/sigs.k8s.io/controller-runtime).
  prefs: []
  type: TYPE_NORMAL
- en: I created a little open-source project called `go-k8s` that encapsulates some
    of the complexity and helps with using a subset of the controller-runtime functionality
    with less hassle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check it out here: [https://github.com/the-gigi/go-k8s/tree/main/pkg/client](https://github.com/the-gigi/go-k8s/tree/main/pkg/client).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the go-k8s project has other libraries, but we will focus on the client
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The go-k8s client package supports two types of clients: `Clientset` and `DynamicClient`.
    The `Clientset` client supports working with well-known kinds, but explicitly
    specifying the API version, kind, and operation as method names. For example,
    listing all pods using `Clientset` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns a pod list and an error. The error is `nil` if everything is OK.
    The pod list is of struct type `PodList`, which is defined here: [https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, you can find all the Kubernetes API types in the same file. The
    API is very nested, for example, a `PodList`, as you may expect, is a list of
    `Pod` objects. Each `Pod` object has `TypeMeta`, `ObjectMeta`, `PodSpec`, and
    `PodStatus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, this means that when you make a call through the `Clientset`,
    you get back a strongly typed nested object that is very easy to work with. For
    example, if we want to check if a pod has a label called `app` and its value,
    we can do it in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the label doesn’t exist, `ok` will be false. If it does exist, then its value
    will be available in the `app` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at `DynamicClient`. Here, you get the ultimate flexibility and
    the ability to work with well-known types as well as custom types. In particular,
    if you want to create arbitrary resources, the dynamic client can operate in a
    generic way on any Kubernetes type.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with the dynamic client, you always get back a generic object of type
    `Unstructured`, defined here: [https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41](https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is really a very thin wrapper around the generic Golang type `map[string]interface{}`.
    It has a single field called `Object` of type `map[string]interface{}`. This means
    that the object you get back is a map of field names to arbitrary other objects
    (represented as `interface{}`). To drill down the hierarchy, we have to perform
    typecasting, which means taking an `interface{}` value and casting it explicitly
    to its actual type. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, `x` is a variable of type `int` with a value of 5 that can be used as an
    integer. The original `i` variable can’t be used as an integer because its type
    is the generic `interface{}` even if it contains an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the objects returned from the dynamic client, we have to keep
    typecasting an `interface{}` to a `map[string]interface{}` until we get to the
    field we are interested in. To get to the `app` label of our pod, we need to follow
    this path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is extremely tiresome and error-prone. Luckily, there is a better way.
    The Kubernetes `apimachinery/runtime` package provides a conversion function that
    can take an unstructured object and convert it into a known type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The controller-runtime is very powerful, but it can be tedious to deal with
    all the types. One way to “cheat” is to use kubectl, which actually uses the controller-runtime
    under the covers. This is especially easy using Python and its dynamic typing.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking kubectl programmatically from Python and Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don’t want to deal with the REST API directly or client libraries, you
    have another option. Kubectl is used mostly as an interactive command-line tool,
    but nothing is stopping you from automating it and invoking it through scripts
    and programs. There are some benefits to using kubectl as your Kubernetes API
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to find examples for any usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to experiment on the command line to find the right combination of commands
    and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl supports output in JSON or YAML for quick parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication is built in via kubectl configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python subprocess to run kubectl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s use Python first, so you can compare using the official Python client
    to rolling your own. Python has a module called `subprocess` that can run external
    processes such as kubectl and capture the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Python 3 example running kubectl on its own and displaying the beginning
    of the usage output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Kubectl controls the Kubernetes cluster manager.
  prefs: []
  type: TYPE_NORMAL
- en: Find more information at [https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `check_output()` function captures the output as a bytes array, which needs
    to be decoded into `utf-8` to be displayed properly. We can generalize it a little
    bit and create a convenience function called `k()` in the `k.py` file. It accepts
    any number of arguments it feeds to kubectl, and then decodes the output and returns
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use it to list all the running pods in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nice for display, but kubectl already does that. The real power comes
    when you use the structured output options with the `-o` flag. Then the result
    can be converted automatically into a Python object. Here is a modified version
    of the `k()` function that accepts a Boolean `use_json` keyword argument (defaults
    to `False`), and if `True`, adds `-o json` and then parses the JSON output to
    a Python object (dictionary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'That returns a full-fledged API object, which can be navigated and drilled
    down just like when accessing the REST API directly or using the official Python
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see how to delete the deployment and wait until all the pods are gone.
    The kubectl `delete` command doesn’t accept the `-o json` option (although it
    has `-o name`), so let’s leave out `use_json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Python is great, but what if you prefer Go for automating kubectl? No worries,
    I have just the package for you. The `kugo` package provides a simple Go API to
    automate kubectl. You can find the code here: [https://github.com/the-gigi/kugo](https://github.com/the-gigi/kugo).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides 3 functions: `Run()`, `Get()`, and `Exec()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Run()` function is your Swiss Army knife. It can run any kubectl command
    as is. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is super convenient because you can interactively compose the exact command
    and parameters you need using kubectl and then, once you’ve figured out everything,
    you can literally take the same command and pass it to `kuge.Run()` in your Go
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Get()` function is a smart wrapper around `kubectl get`. It accepts a
    `GetRequest` parameter and provides several amenities: it supports field selectors,
    fetching by label, and different output types. Here is an example of fetching
    all namespaces by name using a custom kube config file and custom kube context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Exec()` function is a wrapper around `kubectl exec` and lets
    you execute commands on a running pod/container. It accepts an `ExecRequest` that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the code of the Exec() function. It is pretty straightforward.
    It does basic validation that required fields like `Command` and `Target` were
    provided and then it builds a kubectl argument list starting with the `exec` command
    and finally calls the `Run()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, that we have accessed Kubernetes programmatically via its REST API, client
    libraries, and by controlling kubectl, it’s time to learn how to extend Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is an extremely flexible platform. It was designed from the get-go
    for extensibility and as it evolved, more parts of Kubernetes were opened up,
    exposed through robust interfaces, and could be replaced by alternative implementations.
    I would venture to say that the exponential adoption of Kubernetes across the
    board by start-ups, large companies, infrastructure providers, and cloud providers
    is a direct result of Kubernetes providing a lot of capabilities out of the box,
    but allowing easy integration with other actors. In this section, we will cover
    many of the available extension points, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: User-defined types (custom resources)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API access extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduler extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s understand the various ways you can extend Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kubernetes extension points and patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes is made of multiple components: the API server, etcd state store,
    controller manager, kube-proxy, kubelet, and container runtime. You can deeply
    extend and customize each and every one of these components, as well as adding
    your own custom components that watch and react to events, handle new requests,
    and modify everything about incoming requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows some of the available extension points and how
    they are connected to various Kubernetes components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Available extension points'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to extend Kubernetes with plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Kubernetes with plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kubernetes defines several interfaces that allow it to interact with a wide
    variety of plugins from infrastructure providers. We discussed some of these interfaces
    and plugins in detail in previous chapters. We will just list them here for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container networking interface** (**CNI**) – the CNI supports a large number
    of networking solutions for connecting nodes and containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container storage interface** (**CSI**) – the CSI supports a large number
    of storage options for Kubernetes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device plugins – allows nodes to discover new node resources beyond CPU and
    memory (e.g., a GPU)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Kubernetes with the cloud controller manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes needs to be deployed eventually on some nodes and use some storage
    and networking resources. Initially, Kubernetes supported only Google Cloud Platform
    and AWS. Other cloud providers had to customize multiple Kubernetes core components
    (Kubelet, the Kubernetes controller manager, and the Kubernetes API server) in
    order to integrate with Kubernetes. The Kubernetes developers identified it as
    a problem for adoption and created the **cloud controller manager** (**CCM**).
    The CCM cleanly defines the interaction between Kubernetes and the infrastructure
    layer it is deployed on. Now, cloud providers just provide an implementation of
    the CCM tailored to their infrastructure, and they can utilize upstream Kubernetes
    without costly and error-prone modification to the Kubernetes code. All the Kubernetes
    components interact with the CCM via the predefined interfaces and Kubernetes
    is blissfully unaware of which cloud (or no cloud) it is running on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates the interaction between Kubernetes and a
    cloud provider via the CCM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Interaction between Kubernetes and a cloud provider via the CCM'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about the CCM, check out this concise article I wrote
    a few years ago: [https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198](https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198).'
  prefs: []
  type: TYPE_NORMAL
- en: Extending Kubernetes with webhooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Plugins run in the cluster, but in some cases, a better extensibility pattern
    is to delegate some functions to an out-of-cluster service. This is very common
    in the area of access control where companies and organizations may already have
    a centralized solution for identity and access control. In those cases, the webhook
    extensibility pattern is useful. The idea is that you can configure Kubernetes
    with an endpoint (webhook). Kubernetes will call the endpoint where you can implement
    your own custom functionality and Kubernetes will take action based on the response.
    We saw this pattern when we discussed authentication, authorization, and dynamic
    admission control in *Chapter 4*, *Securing Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes defines the expected payloads for each webhook. The webhook implementation
    must adhere to them in order to successfully interact with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Kubernetes with controllers and operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The controller pattern is where you write a program that can run inside the
    cluster or outside the cluster, watch for events, and respond to them. The conceptual
    model for a controller is to reconcile the current state of the cluster (the parts
    the controller is interested in) with the desired state. A common practice for
    controllers is to read the `Spec` of an object, take some actions, and update
    its `Status`. A lot of the core logic of Kubernetes is implemented by a large
    set of controllers managed by the controller manager, but there is nothing stopping
    us from deploying our own controllers to the cluster or running controllers that
    access the API server remotely.
  prefs: []
  type: TYPE_NORMAL
- en: The operator pattern is another flavor of the controller pattern. Think of an
    operator as a controller that also has its own set of custom resources, which
    represents an application it manages. The goal of operators is to manage the lifecycle
    of an application that is deployed in the cluster or some out-of-cluster infrastructure.
    Check out [https://operatorhub.io](https://operatorhub.io) for examples of existing
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to build your own controllers, I recommend starting with Kubebuilder
    ([https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)).
    It is an open project maintained by the Kubernetes API Machinery SIG and has support
    for defining multiple custom APIs using CRDs, and scaffolds out the controller
    code to watch these resources. You will implement your controller in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are multiple other frameworks for writing controllers and operators
    with different approaches and using other programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: The Operator Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kopf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kube-rs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KubeOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KUDO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metacontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check them out before you make your decision.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Kubernetes scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes’ primary job, in one sentence, is to schedule pods on nodes. Scheduling
    is at the heart of what Kubernetes does, and it does it very well. The Kubernetes
    scheduler can be configured in very advanced ways (daemon sets, taints, tolerations,
    etc.). But still, the Kubernetes developers recognize that there may be extraordinary
    circumstances where you may want to control the core scheduling algorithm. It
    is possible to replace the core Kubernetes scheduler with your own scheduler or
    run another scheduler side by side with the built-in scheduler to control the
    scheduling of a subset of the pods. We will see how to do that later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Kubernetes with custom container runtimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kubernetes originally supported only Docker as a container runtime. The Docker
    support was embedded into the core Kubernetes codebase. Later, dedicated support
    for rkt was added. The Kubernetes developers saw the light and introduced the
    **container runtime interface** (**CRI**), a gRPC interface that enables any container
    runtime that implements it to communicate with the kubelet. Eventually, the hard-coded
    support for Docker and rkt was phased out and now the kubelet talks to the container
    runtime only through the CRI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Kubelet talking to the container runtime through the CRI'
  prefs: []
  type: TYPE_NORMAL
- en: Since the introduction of the CRI, the number of container runtimes that work
    with Kubernetes has exploded.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered multiple ways to extend different aspects of Kubernetes. Let’s
    turn our attention to the major concept of custom resources, which allow you to
    extend the Kubernetes API itself.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing custom resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the primary ways to extend Kubernetes is to define new types of resources
    called custom resources. What can you do with custom resources? Plenty. You can
    use them to manage, through the Kubernetes API, resources that live outside the
    Kubernetes cluster but that your pods communicate with. By adding those external
    resources as custom resources, you get a full picture of your system, and you
    benefit from many Kubernetes API features such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom CRUD REST endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic integration with generic Kubernetes tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other use cases for custom resources are metadata for custom controllers and
    automation programs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in and see what custom resources are all about.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to play nice with the Kubernetes API server, custom resources must
    conform to some basic requirements. Similar to built-in API objects, they must
    have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`: `apiextensions.k8s.io/v1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`: Standard Kubernetes object metadata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind`: `CustomResourceDefinition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec`: Describes how the resource appears in the API and tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: Indicates the current status of the CRD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spec` has an internal structure that includes fields like `group`, `names`,
    `scope`, `validation`, and `version`. The `status` includes the fields `acceptedNames`
    and `Conditions`. In the next section, I’ll show you an example that clarifies
    the meaning of these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Developing custom resource definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You develop your custom resources using custom resource definitions, AKA CRDs.
    The intention is for CRDs to integrate smoothly with Kubernetes, its API, and
    tooling. That means you need to provide a lot of information. Here is an example
    for a custom resource called Candy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The Candy CRD has several interesting parts. The metadata has a fully qualified
    name, which should be unique since CRDs are cluster-scoped. The spec has a `versions`
    section, which can contain multiple versions with a schema for each version that
    specifies the field of the custom resource. The schema follows the OpenAPI v3
    specification ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject)).
    The `scope` field could be either `Namespaced` or `Cluster`. If the scope is `Namespaced`,
    then the custom resources you create from the CRD will exist only in the namespace
    they were created in, whereas cluster-scoped custom resources are available in
    any namespace. Finally, the `names` section refers to the names of the custom
    resource (not the name of the CRD from the `metadata` section). The `names` section
    has `plural`, `singular`, `kind`, and `shortNames` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, that the metadata name is returned. It is common to use a plural name.
    Now, let’s verify we can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an API endpoint for managing this new resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Integrating custom resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the `CustomResourceDefinition` object has been created, you can create
    custom resources of that resource kind – `Candy` in this case (candy becomes CamelCase
    Candy). Custom resources must respect the schema of the CRD. In the following
    example, the `flavor` field is set on the `Candy` object with the name `chocolate`.
    The `apiVersion` field is derived from the CRD `spec` group and `versions` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that the spec must contain the `flavor` field from the schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, kubectl can operate on Candy objects just like it works on built-in
    objects. Resource names are case-insensitive when using kubectl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also view the raw JSON data using the standard `-o json` flag. Let’s
    use the short name `cn` this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with unknown fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The schema in the spec was introduced with the `apiextensions.k8s.io/v1` version
    of CRDs that became stable in Kubernetes 1.17\. With `apiextensions.k8s.io/v1beta`,
    a schema wasn’t required so arbitrary fields were the way to go. If you just try
    to change the version of your CRD from v1beta to v1, you’re in for a rude awakening.
    Kubernetes will let you update the CRD, but when you try to create a custom resource
    later with unknown fields, it will fail.
  prefs: []
  type: TYPE_NORMAL
- en: You must define a schema for all your CRDs. If you must deal with custom resources
    that may have additional unknown fields, you can turn validation off, but the
    additional fields will be stripped off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `Candy` resource that has an extra field, `texture`, not specified
    in the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to create it with validation, it will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if we turn validation off, then all is well, except that only the `flavor`
    field will be present and the `texture` field will not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it can be useful to keep unknown fields. CRDs can support unknown
    fields by adding a special field to the schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delete the current Candy CRD and replace it with a CRD that supports
    unknown fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The new CRD has the `x-kubernetes-preserve-unknown-fields` field set to `true`
    in the `spec` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create our gummy bear again WITH validation and check that the unknown
    `texture` field is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Finalizing custom resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom resources support finalizers just like standard API objects. A finalizer
    is a mechanism where objects are not deleted immediately but have to wait for
    special controllers that run in the background and watch for deletion requests.
    The controller may perform any necessary cleanup options and then remove its finalizer
    from the target object. There may be multiple finalizers on an object. Kubernetes
    will wait until all finalizers have been removed and only then delete the object.
    The finalizers in the metadata are just arbitrary strings that their corresponding
    controller can identify. Kubernetes doesn’t know what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'It just waits patiently for all the finalizers to be removed before deleting
    the object. Here is an example with a `Candy` object that has two finalizers:
    `eat-me` and `drink-me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Adding custom printer columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, when you list custom resources with kubectl, you get only the name
    and the age of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'But the CRD schema allows you to add your own columns. Let’s add the flavor
    and the age as printable columns to our `Candy` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can apply it, add our candies again, and list them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Understanding API server aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRDs are great when all you need is some CRUD operations on your own types.
    You can just piggyback on the Kubernetes API server, which will store your objects
    and provide API support and integration with tooling like kubectl. If you need
    more power, you can run controllers that watch for your custom resources and perform
    some operations when they are created, updated, or deleted. The Kubebuilder ([https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder))
    project is a great framework for building Kubernetes APIs on top of CRDs with
    your own controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'But CRDs have limitations. If you need more advanced features and customization,
    you can use API server aggregation and write your own API server, which the Kubernetes
    API server will delegate to. Your API server will use the same API machinery as
    the Kubernetes API server itself. Some advanced capabilities are available only
    through the aggregation layer:'
  prefs: []
  type: TYPE_NORMAL
- en: Make your API server adopt different storage APIs rather than etcd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend long-running subresources/endpoints like WebSocket for your own resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate your API server with any other external systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the storage of your objects (custom resources are always stored in etcd)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom operations beyond CRUD (e.g., exec or scale)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use protocol buffer payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing an extension API server is a non-trivial effort. If you decide you
    need all that power, there are a couple of good starting points. You can look
    at the sample API server for inspiration ([https://github.com/kubernetes/sample-apiserver](https://github.com/kubernetes/sample-apiserver)).
    You may want to check out the `apiserver-builder-alpha` project ([https://github.com/kubernetes-sigs/apiserver-builder-alpha](https://github.com/kubernetes-sigs/apiserver-builder-alpha)).
    It takes care of a lot of the necessary boilerplate code. The API builder provides
    the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap complete type definitions, controllers, and tests as well as documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extension control plane you can run on a local cluster or on an actual remote
    cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your generated controllers will be able to watch and update API objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add resources (including sub-resources)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values you can override if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also a walkthrough here: [https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/](https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/).'
  prefs: []
  type: TYPE_NORMAL
- en: Building Kubernetes-like control planes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if you want to use the Kubernetes model to manage other things and not
    just pods? It turns out that this is a very desirable capability. There is a project
    with a lot of momentum that provides it: [https://github.com/kcp-dev/kcp](https://github.com/kcp-dev/kcp).'
  prefs: []
  type: TYPE_NORMAL
- en: kcp also ventures into multi-cluster management.
  prefs: []
  type: TYPE_NORMAL
- en: What does kcp bring to the table?
  prefs: []
  type: TYPE_NORMAL
- en: It is a control plane for multiple conceptual clusters called workspaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables external API service providers to integrate with the central control
    plane using multi-tenant operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can consume APIs easily in their workspaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling workloads flexibly to physical clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move workloads transparently between compatible physical clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can deploy their workloads while taking advantage of capabilities such
    as geographic replication and cross-cloud replication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered different ways to extend Kubernetes by adding controllers and
    aggregated API servers. Let’s take a look at another mode of extending Kubernetes,
    by writing plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Kubernetes plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dive into the guts of Kubernetes and learn how to take
    advantage of its famous flexibility and extensibility. We will learn about different
    aspects that can be customized via plugins and how to implement such plugins and
    integrate them with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes is all about orchestrating containerized workloads. The most fundamental
    responsibility is to schedule pods to run on cluster nodes. Before we can write
    our own scheduler, we need to understand how scheduling works in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the design of the Kubernetes scheduler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kubernetes scheduler has a very simple role – when a new pod needs to be
    created, assign it to a target node. That’s it. The Kubelet on the target node
    will take it from there and instruct the container runtime on the node to run
    the pod’s containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes scheduler implements the Controller pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Watch for pending pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the proper node for the pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the node’s spec by setting the `nodeName` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only complicated part is selecting the target node. This process involves
    multiple steps split into two cycles:'
  prefs: []
  type: TYPE_NORMAL
- en: The scheduling cycle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The binding cycle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While scheduling cycles are executed sequentially, binding cycles can be executed
    in parallel. If the target pod is considered unschedulable or an internal error
    occurs, the cycle will be terminated, and the pod will be placed back in the queue
    to be retried at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheduler is implemented using an extensible scheduler framework. The framework
    defines multiple extension points that you can plug into to affect the scheduling
    process. The following diagram shows the overall process and the extension points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18998_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: The workflow of the Kubernetes scheduler'
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler takes a tremendous amount of information and configuration into
    account. Filtering removes nodes that don’t satisfy one of the hard constraints
    from the candidate list. Ranking nodes assigns a score to each of the remaining
    nodes and chooses the best node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the factors the scheduler evaluates when filtering nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the ports requested by the pod are available on the node, ensuring
    the required network connectivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the pod is scheduled on a node whose hostname matches the specified
    node preference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the availability of requested resources (CPU and memory) on the node
    to meet the pod’s requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match the node’s labels with the pod’s node selector or node affinity to ensure
    proper scheduling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm that the node supports the requested volume types, considering any failure
    zone restrictions for storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate the node’s capacity to accommodate the pod’s volume requests, accounting
    for existing mounted volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the node’s health by checking for indicators such as memory pressure
    or PID pressure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate the pod’s tolerations to determine compatibility with the node’s taints,
    enabling or restricting scheduling accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the nodes have been filtered, the scheduler will score the modes based
    on the following policies (which you can configure):'
  prefs: []
  type: TYPE_NORMAL
- en: Distribute pods across hosts while considering pods belonging to the same Service,
    StatefulSet, or ReplicaSet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give priority to inter-pod affinity, which means favoring pods that have an
    affinity or preference for running on the same node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the “Least requested” priority, which favors nodes with fewer requested
    resources. This policy aims to distribute pods across all nodes in the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the “Most requested” priority, which favors nodes with the highest requested
    resources. This policy tends to pack pods into a smaller set of nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the “Requested to capacity ratio” priority, which calculates a priority
    based on the ratio of requested resources to the node’s capacity. It uses a default
    resource scoring function shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritize nodes with balanced resource allocation, favoring nodes with balanced
    resource usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the “Node prefer avoid pods” priority, which prioritizes nodes based
    on the node annotation `scheduler.alpha.kubernetes.io/preferAvoidPods`. This annotation
    is used to indicate that two different pods should not run on the same node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply node affinity priority, giving preference to nodes based on the node affinity
    scheduling preferences specified in `PreferredDuringSchedulingIgnoredDuringExecution`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider taint toleration priority, preparing a priority list for all nodes
    based on the number of intolerable taints on each node. This policy adjusts a
    node’s rank, taking taints into account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give priority to nodes that already have the container images required by the
    pod using the “Image locality” priority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritize spreading pods backing a service across different nodes with the
    “Service spreading” priority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply pod anti-affinity, which means avoiding running pods on nodes that already
    have similar pods based on anti-affinity rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the “Equal priority map,” where all nodes have the same weight and there
    are no favorites or biases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out [https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/](https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the default scheduler is very sophisticated and can be configured
    in a very fine-grained way to accommodate most of your needs. But, under some
    circumstances, it might not be the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, in large clusters with many nodes (hundreds or thousands), every
    time a pod is scheduled, all the nodes need to go through this rigorous and heavyweight
    procedure of filtering and scoring. Now, consider a situation where you need to
    schedule a large number of pods at once (e.g., training machine learning models).
    This can put a lot of pressure on your cluster and lead to performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes can make the filtering and scoring process more lightweight by allowing
    you to filter and score only some of the pods, but still, you may want better
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Kubernetes allows you to influence the scheduling process in several
    ways. Those ways include:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct scheduling of pods to nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the scheduler with your own scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the scheduler with additional filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding another scheduler that runs side by side with the default scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s review various methods you can use to influence pod scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling pods manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Guess what? We can just tell Kubernetes where to place our pod when we create
    the pod. All it takes is to specify a node name in the pod’s spec and the scheduler
    will ignore it. If you think about the loosely coupled nature of the controller
    pattern, it all makes sense. The scheduler is watching for pending pods that DON’T
    have a node name assigned yet. If you are passing the node name yourself, then
    the Kubelet on the target node, which watches for pending pods that DO have a
    node name, will just go ahead and make sure to create a new pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the nodes of our k3d cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: some-pod-manual-scheduling'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: some-container'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: registry.k8s.io/pause:3.8'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'nodeName: k3d-k3s-default-agent-1'
  prefs: []
  type: TYPE_NORMAL
- en: 'schedulerName: no-such-scheduler'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: $ k create -f some-pod-manual-scheduling.yaml
  prefs: []
  type: TYPE_NORMAL
- en: pod/some-pod-manual-scheduling created
  prefs: []
  type: TYPE_NORMAL
- en: $ k get po some-pod-manual-scheduling -o wide
  prefs: []
  type: TYPE_NORMAL
- en: NAME                         READY   STATUS    RESTARTS   AGE   IP            NODE                      NOMINATED
    NODE   READINESS GATES
  prefs: []
  type: TYPE_NORMAL
- en: some-pod-manual-scheduling   1/1     Running   0          26s   10.42.2.213   k3d-k3s-default-agent-1   <none>           <none>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: from kubernetes import client, config, watch
  prefs: []
  type: TYPE_NORMAL
- en: 'def schedule_pod(cli, name):'
  prefs: []
  type: TYPE_NORMAL
- en: target = client.V1ObjectReference()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: target.kind = 'Node'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: target.apiVersion = 'v1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: target.name = 'k3d-k3s-default-agent-0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: meta = client.V1ObjectMeta()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: meta.name = name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: body = client.V1Binding(metadata=meta, target=target)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return cli.create_namespaced_binding('default', body)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: config.load_kube_config()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cli = client.CoreV1Api()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: w = watch.Watch()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for event in w.stream(cli.list_namespaced_pod, ''default''):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: o = event['object']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if o.status.phase != ''Pending'' or o.spec.scheduler_name != ''custom-scheduler'':'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: schedule_pod(cli, o.metadata.name)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'if o.status.phase != ''Pending'' or o.spec.scheduler_name != ''custom-scheduler'':'
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Pod'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: some-pod-with-custom-scheduler'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: some-container'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'image: registry.k8s.io/pause:3.8'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'schedulerName: custom-scheduler'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: $ k create -f some-pod-with-custom-scheduler.yaml
  prefs: []
  type: TYPE_NORMAL
- en: pod/some-pod-with-custom-scheduler created
  prefs: []
  type: TYPE_NORMAL
- en: $ k get po
  prefs: []
  type: TYPE_NORMAL
- en: NAME                             READY   STATUS    RESTARTS   AGE
  prefs: []
  type: TYPE_NORMAL
- en: some-pod-manual-scheduling       1/1     Running   0          9m33s
  prefs: []
  type: TYPE_NORMAL
- en: some-pod-with-custom-scheduler   0/1     Pending   0          14s
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: python custom_scheduler.py
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for pending pods...
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheduling pod: some-pod-with-custom-scheduler'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: $ k get po -o wide
  prefs: []
  type: TYPE_NORMAL
- en: NAME                             READY   STATUS    RESTARTS   AGE    IP            NODE                      NOMINATED
    NODE   READINESS GATES
  prefs: []
  type: TYPE_NORMAL
- en: some-pod-manual-scheduling       1/1     Running   0          4h5m   10.42.2.213   k3d-k3s-default-agent-1   <none>           <none>
  prefs: []
  type: TYPE_NORMAL
- en: some-pod-with-custom-scheduler   1/1     Running   0          87s    10.42.0.125   k3d-k3s-default-agent-0   <none>           <none>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: $ k krew
  prefs: []
  type: TYPE_NORMAL
- en: krew is the kubectl plugin manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can invoke krew through kubectl: "kubectl krew [command]..."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage:'
  prefs: []
  type: TYPE_NORMAL
- en: kubectl krew [command]
  prefs: []
  type: TYPE_NORMAL
- en: 'Available Commands:'
  prefs: []
  type: TYPE_NORMAL
- en: completion  generate the autocompletion script for the specified shell
  prefs: []
  type: TYPE_NORMAL
- en: help        Help about any command
  prefs: []
  type: TYPE_NORMAL
- en: index       Manage custom plugin indexes
  prefs: []
  type: TYPE_NORMAL
- en: info        Show information about an available plugin
  prefs: []
  type: TYPE_NORMAL
- en: install     Install kubectl plugins
  prefs: []
  type: TYPE_NORMAL
- en: list        List installed kubectl plugins
  prefs: []
  type: TYPE_NORMAL
- en: search      Discover kubectl plugins
  prefs: []
  type: TYPE_NORMAL
- en: uninstall   Uninstall plugins
  prefs: []
  type: TYPE_NORMAL
- en: update      Update the local copy of the plugin index
  prefs: []
  type: TYPE_NORMAL
- en: upgrade     Upgrade installed plugins to newer versions
  prefs: []
  type: TYPE_NORMAL
- en: version     Show krew version and diagnostics
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags:'
  prefs: []
  type: TYPE_NORMAL
- en: -h, --help      help for krew
  prefs: []
  type: TYPE_NORMAL
- en: -v, --v Level   number for the log level verbosity
  prefs: []
  type: TYPE_NORMAL
- en: Use "kubectl krew [command] --help" for more information about a command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: $ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-001-nodepool001         116d
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-001-nodepool002         116d
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-002-nodepool001         139d
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-002-nodepool002         139d
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-002-nodepool003         139d
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: $ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io
    -o custom-columns=NAME:.metadata.name,SKU:.spec.sku,VERSION:.status.version,NODES:.status.replicas
  prefs: []
  type: TYPE_NORMAL
- en: NAME                                    SKU                 VERSION   NODES
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-001-nodepool001   Standard_D4s_v4     1.23.8    10
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-001-nodepool002   Standard_D8s_v4     1.23.8    20
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-002-nodepool001   Standard_D16s_v4    1.23.8    30
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-002-nodepool002   Standard_D8ads_v5   1.23.8    40
  prefs: []
  type: TYPE_NORMAL
- en: aks-centralus-cluster-002-nodepool003   Standard_D8ads_v5   1.23.8    50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: $ k npa get
  prefs: []
  type: TYPE_NORMAL
- en: 'Error: exec format error'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: $ k get npa
  prefs: []
  type: TYPE_NORMAL
- en: 'error: the server doesn''t have a resource type "npa"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '- --authentication-token-webhook-config-file=<authentication config file>'
  prefs: []
  type: TYPE_NORMAL
- en: '- --authentication-token-webhook-cache-ttl (how long to cache auth decisions,
    default to 2 minutes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes API version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: kind of the API object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'kind: Config'
  prefs: []
  type: TYPE_NORMAL
- en: clusters refers to the remote service.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: name-of-remote-authn-service'
  prefs: []
  type: TYPE_NORMAL
- en: 'cluster:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'certificate-authority: /path/to/ca.pem         # CA for verifying the remote
    service.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'server: https://authn.example.com/authenticate # URL of remote service to query.
    Must use ''https''.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: users refers to the API server's webhook configuration.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'users:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: name-of-api-server'
  prefs: []
  type: TYPE_NORMAL
- en: 'user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'client-certificate: /path/to/cert.pem # cert for the webhook plugin to use'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'client-key: /path/to/key.pem          # key matching the cert'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: kubeconfig files require a context. Provide one for the API server.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'current-context: webhook'
  prefs: []
  type: TYPE_NORMAL
- en: 'contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '- context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'cluster: name-of-remote-authn-service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'user: name-of-api-sever'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: webhook'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "authentication.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "TokenReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"spec": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"token": "<bearer token from original request headers>"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "authentication.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "TokenReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"status": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"authenticated": true,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"user": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"username": "gigi@gg.com",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"uid": "42",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"groups": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"developers",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '],'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"extra": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"extrafield1": ['
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"extravalue1",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"extravalue2"'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "authentication.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "TokenReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"status": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"authenticated": false'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: --authorization-webhook-config-file=<configuration filename>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "authorization.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "SubjectAccessReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"spec": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"resourceAttributes": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"namespace": "awesome-namespace",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"verb": "get",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"group": "awesome.example.org",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"resource": "pods"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"user": "gigi@gg.com",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"group": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"group1",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"group2"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "authorization.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "SubjectAccessReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"status": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"allowed": true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "authorization.k8s.io/v1beta1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "SubjectAccessReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"status": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"allowed": false,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"reason": "user does not have read access to the namespace"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "authorization.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "SubjectAccessReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"spec": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"nonResourceAttributes": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"path": "/logs",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"verb": "get"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"user": "gigi@gg.com",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"group": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"group1",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"group2"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: $ k auth can-i create deployments
  prefs: []
  type: TYPE_NORMAL
- en: 'yes'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: $ k auth can-i create deployments --as default
  prefs: []
  type: TYPE_NORMAL
- en: 'no'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'apiVersion: admissionregistration.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ValidatingWebhookConfiguration'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'webhooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: admission-webhook.example.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- operations: ["CREATE", "UPDATE"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroups: ["apps"]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'apiVersions: ["v1", "v1beta1"]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resources: ["deployments", "replicasets"]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'scope: "Namespaced"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "admission.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "AdmissionReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"request": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"uid": "705ab4f5-6393-11e8-b7cc-42010a800002",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"kind": {"group":"autoscaling","version":"v1","kind":"Scale"},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"resource": {"group":"apps","version":"v1","resource":"deployments"},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"subResource": "scale",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"requestKind": {"group":"autoscaling","version":"v1","kind":"Scale"},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"requestResource": {"group":"apps","version":"v1","resource":"deployments"},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"requestSubResource": "scale",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"name": "cool-deployment",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"namespace": "cool-namespace",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"operation": "UPDATE",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"userInfo": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"username": "admin",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"uid": "014fbff9a07c",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"groups": ["system:authenticated","my-admin-group"],'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"extra": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"some-key":["some-value1", "some-value2"]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"object": {"apiVersion":"autoscaling/v1","kind":"Scale",...},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"oldObject": {"apiVersion":"autoscaling/v1","kind":"Scale",...},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"options": {"apiVersion":"meta.k8s.io/v1","kind":"UpdateOptions",...},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"dryRun": false'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "admission.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "AdmissionReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"response": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"uid": "<value from request.uid>",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"allowed": true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"apiVersion": "admission.k8s.io/v1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"kind": "AdmissionReview",'
  prefs: []
  type: TYPE_NORMAL
- en: '"response": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"uid": "<value from request.uid>",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"allowed": false,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"status": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"code": 403,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"message": "You cannot do this because I say so!!!!"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: type CustomMetricsProvider interface {
  prefs: []
  type: TYPE_NORMAL
- en: // GetRootScopedMetricByName fetches a particular metric for a particular root-scoped
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GetRootScopedMetricByName(groupResource schema.GroupResource, name string, metricName
    string) (*custom_metrics.MetricValue, error)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // GetRootScopedMetricByName fetches a particular metric for a set of root-scoped
    objects
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // matching the given label selector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GetRootScopedMetricBySelector(groupResource schema.GroupResource, selector labels.Selector,
    metricName string) (*custom_metrics.MetricValueList, error)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // GetNamespacedMetricByName fetches a particular metric for a particular namespaced
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GetNamespacedMetricByName(groupResource schema.GroupResource, namespace string,
    name string, metricName string) (*custom_metrics.MetricValue, error)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // GetNamespacedMetricByName fetches a particular metric for a set of namespaced
    objects
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // matching the given label selector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GetNamespacedMetricBySelector(groupResource schema.GroupResource, namespace
    string, selector labels.Selector, metricName string) (*custom_metrics.MetricValueList,
    error)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ListAllMetrics provides a list of all available metrics at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // the current time. Note that this is not allowed to return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // an error, so it is recommended that implementors cache and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // periodically update this list, instead of querying every time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ListAllMetrics() []CustomMetricInfo
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: service Controller {
  prefs: []
  type: TYPE_NORMAL
- en: rpc CreateVolume (CreateVolumeRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (CreateVolumeResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rpc DeleteVolume (DeleteVolumeRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (DeleteVolumeResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rpc ControllerPublishVolume (ControllerPublishVolumeRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (ControllerPublishVolumeResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (ControllerUnpublishVolumeResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (ValidateVolumeCapabilitiesResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rpc ListVolumes (ListVolumesRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (ListVolumesResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rpc GetCapacity (GetCapacityRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (GetCapacityResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)
  prefs: []
  type: TYPE_NORMAL
- en: returns (ControllerGetCapabilitiesResponse) {}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This is not a trivial undertaking and typically only storage solution providers
    should implement CSI plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The additional extension points of custom metrics and custom storage solutions
    demonstrate the commitment of Kubernetes to being truly extensible and allowing
    its users to customize almost every aspect of its operation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered three major topics: working with the Kubernetes
    API, extending the Kubernetes API, and writing Kubernetes plugins. The Kubernetes
    API supports the OpenAPI spec and is a great example of REST API design that follows
    all current best practices. It is very consistent, well organized, and well documented.
    Yet it is a big API and not easy to understand. You can access the API directly
    via REST over HTTP, using client libraries including the official Python client,
    and even by invoking kubectl programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Kubernetes API may involve defining your own custom resources,
    writing controllers/operators, and optionally extending the API server itself
    via API aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins and webhooks are a foundation of Kubernetes design. Kubernetes was always
    meant to be extended by users to accommodate any needs. We looked at various plugins,
    such as custom schedulers, kubectl plugins, and access control webhooks. It is
    very cool that Kubernetes provides such a seamless experience for writing, registering,
    and integrating all those plugins.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at custom metrics and even how to extend Kubernetes with custom
    storage options.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be well aware of all the major mechanisms to extend,
    customize, and control Kubernetes via API access, custom resources, controllers,
    operators, and custom plugins. You are in a great position to take advantage of
    these capabilities to augment the existing functionality of Kubernetes and adapt
    it to your needs and your systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at governing Kubernetes via policy engines.
    This will continue the theme of extending Kubernetes as policy engines are dynamic
    admission controllers on steroids. We will cover what governance is all about,
    review existing policy engines, and dive deep into Kyverno, which is the best
    policy engine for Kubernetes in my opinion.
  prefs: []
  type: TYPE_NORMAL
