- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application Scheduling and Lifecycle Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes how to use Kubernetes deployments to deploy pods, scale
    pods, perform rolling updates and rollbacks, carry out resource management, and
    use ConfigMaps to configure pods using `kubectl` commands and YAML definitions.
    This chapter covers 15% of the CKA exam content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Kubernetes workloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and managing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing rolling updates and rollbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workload scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we need to make sure your local machine meets the following
    technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of Kubernetes workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes orchestrates your workloads to achieve the desired status – a containerized
    workload with applications running on Kubernetes, including stateless, stateful,
    and data-processing applications. In terms of cloud-native applications, there’s
    an interesting white paper that introduced the notion of cloud-native applications
    and design patterns thoroughly, which you can check out here if you’re interested:
    [https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper](https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper).'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental building blocks of any containerized workload up and running
    in the Kubernetes cluster are called Kubernetes API primitives or Kubernetes objects.
    They are the API resource types defined in Kubernetes, including pods, ReplicaSets,
    DaemonSets, StatefulSets, Job and CronJob objects, and Deployments, among others
    mentioned in [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*.
  prefs: []
  type: TYPE_NORMAL
- en: The CKA exam covers some of the main Kubernetes objects such as Pods, Deployments,
    ReplicaSets, and DaemonSets while working with Kubernetes clusters and we’ll dive
    into further detail in the following section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please make sure your local machine meets the required technical requirements
    before diving into the practice.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative management versus declarative management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways to communicate with API servers in Kubernetes – mainly,
    they can be categorized as either imperative management or declarative management.
    You will need to use both `kubectl` and YAML definitions to manage Kubernetes
    objects. The `kubectl` utilities can support all the management techniques for
    managing Kubernetes objects, as Kubernetes is intended to be a desired state manager.
    After executing a `kubectl` command, as a result, it moves the current workload
    running in Kubernetes from its actual state to the desired state, which is defined
    in the command-line parameters or YAML-defined specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Time management is the key to success in the CKA exam. Getting familiar with
    `kubectl` commands will help you save a lot of time when it comes to a new deployment.
    A good understanding of YAML definition will help you update the configurations
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The smallest deployable unit in Kubernetes is a pod. The pod contains the actual
    application workload – it could be one or multiple containers. A pod in Kubernetes
    has a defined lifecycle. We’ll cover the following topic about pods:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding health probing for pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a multi-container pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding an init container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a static pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at the pod first. You can create a pod using an imperative
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of running a pod named `ngin-pod` with the image as `nginx`
    and the image tag as `alpine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output is returned as `created`, as follows, to indicate that
    your pod has been created successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the process, you will see pod has the `ContainerCreating` status, indicating
    that the container is being created, and you can use `kubectl` to describe a pod
    command to see what’s going on. The following command is what we can use to check
    the pod’s current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the `describe` command, you will see the events – this is
    helpful information for you to use to check whether anything is going wrong during
    your deployment. We will explore troubleshooting pods further in [*Chapter 8*](B18201_08.xhtml#_idTextAnchor293),
    *Monitoring and Logging Kubernetes Clusters and Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The pod events ](img/Figure_4.01_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The pod events
  prefs: []
  type: TYPE_NORMAL
- en: 'The same pod can be YAML-defined, as follows, which will give you the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to deploy a YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can run a BusyBox image with a single command, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also deploy a `nginx` image and then export the YAML definition by
    using the `-o yaml` flag :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, a sample `yaml` file will be exported to your local
    PC – you can edit this `yaml` file to make changes locally if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding liveness, readiness, and startup probes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To explore the health status of the pods further, let’s talk about health probes.
    Probes allow you to know how Kubernetes determines the states of your containers.
    Let’s have look at each of them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Liveness probes** indicate whether the container is running properly, as
    they govern when the cluster will decide to restart the container automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readiness probes** indicate whether the container is ready to accept requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubelet` before they get on their feet. Once configured, they disable liveness
    and readiness checkers until they’re complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll have a look at these in more detail in [*Chapter 8*](B18201_08.xhtml#_idTextAnchor293)*,*
    *Monitoring and Logging Kubernetes Clusters and Applications*. You can find further
    details about health probes at the following link: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a multi-container pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multi-container pods are simply pods with more than one container working together
    as a single unit. When it comes to multiple containers residing in a pod, a container
    interacts with another in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared networking**: When two containers are running on the same host when
    they are in the same pod, they can access each other by simply using *localhost*.
    All the listening ports are accessible to other containers in the pod, even if
    they’re not exposed outside the pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 4.2* shows how multiple containers in the same pod share a local network
    with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A multi-container pod’s shared network  ](img/Figure_4.02_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A multi-container pod’s shared network
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared storage volumes**: We can mount the same volume to two different containers
    so that they can both interact with the same data – it is possible to have one
    container write data to the volume and the other container read that data from
    the same volume. Some volumes even allow concurrent reading and writing. We’ll
    dive deeper into how storage works for multi-container pods in [*Chapter 5*](B18201_05.xhtml#_idTextAnchor149),
    *Demystifying Kubernetes Storage*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 4.3* shows how multiple containers in the same pod share local storage
    with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – A multi-container pod’s shared storage volume ](img/Figure_4.03_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – A multi-container pod’s shared storage volume
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how to create multiple containers in a pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In general, it is good to have a one-to-one relationship between a container
    and a pod, which follows the principles of building microservices by keeping each
    module independent. The real world is sometimes more complicated than it may seem,
    let’s take a look at multi-container pods.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding an init container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An init container is configured in a pod to execute before the container host
    starts. It is specified inside an `initContainers` section, as in the following
    example. You can configure multiple init containers too, which will allow each
    init container to complete one at a time in sequential order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case that any of the init containers fail to complete, Kubernetes will
    restart the pod repeatedly until the init container succeeds. To learn more about
    init containers, visit the following link: [https://kubernetes.io/docs/concepts/workloads/pods/init-containers/](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a static Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the captain of a worker node, the `kubelet` agent can manage a node independently,
    and it can create pods. The pods that are managed directly by the `kubelet` daemon
    and bound to a specific node are called static pods. As opposed to pods that are
    managed by the Kubernetes master, static pods are watched by the `kubelet` agent,
    and it restarts in the case of failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to configure `kubelet` so that it reads the pod definition files is
    to add a YAML specification under the following directory where the static pod
    information is stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`kubelet` checks this directory periodically. This path can be configured in
    `kubelet.service`.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Job and CronJob objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Completed` status.'
  prefs: []
  type: TYPE_NORMAL
- en: Jobs can be used to reliably execute a workload until it completes. The Job
    will create one or more pods. When the Job is finished, the containers will exit
    and the pods will enter the `Completed` status. An example use of Jobs is when
    we want to run a particular workload and make sure that it runs once and succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a Job with a YAML description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `backoffLimit` parameter means that, if it fails `4` times, this is the
    limit. All the Job does the same as it is while creating a pod under the hood.
    Although a normal pod is constantly running, when a Job is complete, it goes into
    the `Completed` status. This means that the container is no longer running, so
    the pod still exists, but the container is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to deploy a YAML definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can run the following command to check the Job’s status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the Job is still running, you can see the `Running` status. When the Job
    is finished, you can see that it is complete from the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Job is complete ](img/Figure_4.04_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The Job is complete
  prefs: []
  type: TYPE_NORMAL
- en: '**CronJobs**, based on the capability of a Job, add value by allowing users
    to execute Jobs on a schedule. Users can use cron expressions to define a particular
    schedule as per their requirements. The following is an example of a CronJob YAML
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to deploy a YAML definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the following command to check the cron job’s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The cron job shown as complete ](img/Figure_4.05_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The cron job shown as complete
  prefs: []
  type: TYPE_NORMAL
- en: 'This cron job creates a few pods name `hello`, so we will use the following
    command to check the log of the Job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The completed cron job pods  ](img/Figure_4.06_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The completed cron job pods
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the logs of these pods with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the cron job has been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The logs showing how the cron job was completed ](img/Figure_4.07_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The logs showing how the cron job was completed
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to delete cron jobs, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will see the following output indicating that your cron job has been
    deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'CronJobs were promoted to general availability in Kubernetes v1.21\. You can
    find a great article about running automated tasks using a CronJob here: [https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs](https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs).'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and managing applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections of this chapter will take you through practical exercises
    with concrete examples that you would encounter in your real CKA exam, including
    how to deploy and scale applications, perform rolling updates and rollbacks for
    those applications, manage and govern the resource consumption for these applications,
    and configure them.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying applications can be achieved in various ways, such as deploying a
    pod with `kubectl` or a YAML definition, as we did in the *The basics of Kubernetes
    workloads* section of this chapter. Now, we’ll take a look at a more effective
    way of using Deployments. In this section, let’s get into how to deploy and scale
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Deployment is a convenient way to define the desired state deployment – it
    provides us with a better way of upgrading the underlying instances seamlessly
    using rolling updates, undoing changes, and pausing and resuming changes as required.
    For example, things such as deploying a ReplicaSet with a certain number of replicas
    are easy to roll out and roll back, and more effective. The following figure depicts
    how a Deployment looks conceptually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – A Deployment ](img/Figure_4.08_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – A Deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployments provide a way to define a desired state for the replica pod. You
    can use a YAML definition as follows to define a Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following attributes are important to help you understand the preceding
    YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spec.replicas` gives us the number of replica pods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.template` is the template pod descriptor that defines the pods that will
    be created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.selector` is the deployment that will manage all pods whose labels match
    this selector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a Deployment using the following `kubectl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, you will then get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `kubectl get deploy` to query all the Deployments in the current
    namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following Deployment status in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – kubectl getting the Deployments ](img/Figure_4.09_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – kubectl getting the Deployments
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know the name of a Deployment, you can use the following command to
    get that Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – kubectl getting a Deployment by name ](img/Figure_4.10_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – kubectl getting a Deployment by name
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command allows you to get the details of the Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will help you understand the configurations in the Deployment,
    where you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – kubectl describing a Deployment ](img/Figure_4.11_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – kubectl describing a Deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command allows you to live-edit the Deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is a magical one that will allow you to *live-edit* a
    Deployment. The following is the sample output and you can edit it live – it works
    similarly to when you create a pod using the `vim` editor. You can live-edit the
    Deployment here, and then save and quit using `wq!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – kubectl describing a Deployment for live-editing ](img/Figure_4.12_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – kubectl describing a Deployment for live-editing
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can also delete Deployments if you don’t need them anymore with the
    `kubectl delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that the Deployment has been deleted successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the deletion of the Deployment, the objects defined in that Deployment
    are also deleted, as they share the same lifecycle. In our third example, the
    deployed `nginx` pods are deleted, as we delete the `kubeserve` Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Deployments allows you to manage your application in a more effective
    way, update it as an entity easier, and roll it back to its previous versions.
    In the next section, we’ll have a look at rolling updates and rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Performing rolling updates and rollbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rolling updates provide a way to update a Deployment to a newer version more
    effectively and efficiently. This way, you can update Kubernetes objects such
    as replicas and pods gradually with nearly zero downtime. In a nutshell, you may
    consider either using the `kubectl set image` command or going straight to updating
    a YAML manifest file. In this section, we will introduce `kubectl set image`,
    as it is very effective and handy to use in your actual CKA exam.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling updates with kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From here, we’ll go through the steps of rolling updates with `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can spin up a new Deployment, `kubeserve`, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use `kubectl` to update the container image as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`--record flag` records information about the updates so that it can be rolled
    back later. You can either use `--record flag` or `--record=true flag`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding command, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `kubectl describe` command to double-check whether your container
    image has updated successfully by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output should be similar to the following, in *Figure 4.14*, where you
    can see that the image is set to `nginx:1.18.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – kubectl describing kubeserve after updating the image ](img/Figure_4.13_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – kubectl describing kubeserve after updating the image
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl describe deploy` command comes in very handy when we are trying
    to check key information such as the container image, ports, and deployment-related
    events. This is also the case in the actual CKA exam – make sure you master the
    shortcut of this command, `k describe deploy`, which will help you work more effectively
    in the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Rollback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rollback allows us to revert to a previous state and a Deployment makes this
    super easy to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following `kubectl rollout` command to quickly recover if you
    need to perform a rollback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you use the `kubectl describe deploy kubeserve` command, you will see
    the following output indicating that the image has been rolled back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14 – kubectl describing kubeserve after a rollback ](img/Figure_4.14_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – kubectl describing kubeserve after a rollback
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may be very curious as to whether we can keep a track of the history
    of our Deployments. You can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – kubectl describing kubeserve ](img/Figure_4.15_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – kubectl describing kubeserve
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that you want to go back to a specific revision, you can use the
    `--to-revision` flag. You can see in *Figure 4.16* that we have revision `2` available
    thanks to using the `--record` flag when setting the image version. The following
    command is an example of undoing a Deployment and reverting to revision `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you use the `kubectl describe deploy kubeserve` command, you will see
    the following output indicating that the image has been rolled back to revision
    `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – kubectl describing kubeserve ](img/Figure_4.16_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – kubectl describing kubeserve
  prefs: []
  type: TYPE_NORMAL
- en: Deployments not only make the rolling update and rollback process much easier
    but also help us scale up and down with ease – we’ll take a look at how to scale
    applications, as well as all the viable options when doing so, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our application becomes popular, in order to handle increasingly on-demand
    requests, we need to spin up multiple instances of applications to satisfy the
    workload requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a Deployment, scaling is achieved by changing the number of replicas.
    Here, you can scale a Deployment using the `kubectl scale` command to make this
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the `kubectl get pods` command now, you will see that some more
    copies of the pods are spinning up, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – kubectl getting the pods and showing more copies of them ](img/Figure_4.17_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – kubectl getting the pods and showing more copies of them
  prefs: []
  type: TYPE_NORMAL
- en: Aside from manually scaling the Deployments with the `kubectl scale` command,
    we also have another way of scaling a Deployment and its ReplicaSets, which is
    **HorizontalPodAutoscaler** (**HPA**). Let’s take a look at the ReplicaSets first.
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ReplicaSets help pods achieve higher availability since users can define a certain
    number of replicas using a ReplicaSet. The main capability of a ReplicaSet is
    to make sure the cluster keeps the exact number of replicas running in the Kubernetes
    cluster. If any of them were to fail, new ones would be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the YAML definition of a ReplicaSet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `matchLabels` selector simply matches the labels specified under it to
    the labels on the pods. To check your ReplicaSet, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will see the output indicating the number of `DESIRED` *replica*
    counts and how many of them are in a `READY` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – The kubectl get rs command showing the state of the ReplicaSet
    ](img/Figure_4.18_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – The kubectl get rs command showing the state of the ReplicaSet
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the ReplicaSet is deployed, update the number of ReplicaSets by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can specify it in a YAML definition with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you want to check whether the number of ReplicaSets has increased,
    you can use the `kubectl get rs` command again and you will be able to see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – kubectl getting the ReplicaSets  ](img/Figure_4.19_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – kubectl getting the ReplicaSets
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that you want to delete a ReplicaSet, you can use the `kubectl
    delete` command – in this case, we can use it to delete a ReplicaSet named `frontend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Using ReplicaSets directly is not the only way to scale the applications. Let’s
    take a look at the alternative next, HPA.
  prefs: []
  type: TYPE_NORMAL
- en: HPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To update a workload resource such as a Deployment or a StatefulSet, we can
    also use HPA – this is a Kubernetes API primitive that scales the workloads automatically
    based on your demands. *Figure 4.18* explains how HPA works in the context of
    application scaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – HPA ](img/Figure_4.20_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – HPA
  prefs: []
  type: TYPE_NORMAL
- en: From the previous diagram, we can see that HPA is configured to fetch metrics
    provided by a metrics server based on the CPU and memory usage. These metrics
    are fetched from `kubelet` by the metrics server, which then exposes them to the
    API server using a metrics API. HPA scales the Deployment by increasing or decreasing
    the count of replicas, which is managed underneath by a ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: As on-demand resource requests increase, HPA scales out the Deployment and the
    number of replicas increases. Conversely, when the resource requests decrease,
    the number of replicas decreases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an HPA, you can use the `kubectl autoscale deployment` command with
    the following flags for the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cpu-percent` indicates the average CPU utilization usage across all pods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` provides the minimum number of replicas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` provides the maximum number of replicas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use the following command to create an HPA with a CPU utilization usage
    of 50% and ensure a minimum of `3` copies and a maximum of up to `10` copies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To check how many HPAs we currently have in the default namespace, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The output would look as follows
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Getting the HPAs in the default namespace ](img/Figure_4.21_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Getting the HPAs in the default namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the following YAML definition to deploy an HPA, which will
    help you achieve the same goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case that you want to delete an HPA, use a `kubectl delete` command.
    Here, we can delete an HPA named `kubeserve` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Another concept that we will cover is DaemonSets, which come in handier in real
    life, particularly in scenarios where at least one replica of the pod needs to
    be evenly distributed across the worker nodes. Let’s get right into it.
  prefs: []
  type: TYPE_NORMAL
- en: DaemonSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have learned about how ReplicaSets and Deployments help us ensure that multiple
    copies of our applications are up and running across various worker nodes. DaemonSets
    create a couple of copies of a pod, meanwhile making sure that at least one copy
    of the pod is evenly on each node in the Kubernetes cluster, as shown in *Figure
    4.23*.
  prefs: []
  type: TYPE_NORMAL
- en: If a new node is added to the cluster, a replica of that pod is automatically
    assigned to that node. Similarly, when a node is removed, the pod is automatically
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – DaemonSets ](img/Figure_4.22_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – DaemonSets
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a DaemonSet using the following YAML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have created this DaemonSet in a namespace called `kube-system`
    this time – this is a namespace usually reserved for Kubernetes objects created
    by the Kubernetes system. We’ll get to talking about the namespace in a heartbeat.
    For now, you can check that the DaemonSet has been created using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can simplify the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Checking out the DaemonSets in the kube-system namespace ](img/Figure_4.23_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Checking out the DaemonSets in the kube-system namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget to check the details of the DaemonSets by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – kubectl describing the DaemonSets ](img/Figure_4.24_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – kubectl describing the DaemonSets
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you want to delete a DaemonSet, use the `kubectl delete` command. Here,
    we can delete a DaemonSet named `fluentd` in the `kube-system` namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The main use case of DaemonSets is to use them as a monitoring agent or a logs
    collector on every node, or in other cases, to run a cluster storage daemon across
    all the worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: With DaemonSets, you don’t have to worry about removing or adding new nodes
    that will impact the monitoring agents on these nodes. A real-life use case, such
    as `fluentd`, requires an agent to be deployed on each node in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Workload scheduling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the workload scheduling and how it works with the Kubernetes scheduler
    will be useful in your daily life as a Kubernetes Administrator. Kubernetes allows
    you to define node affinity rules, taints, and tolerations with the good use of
    labels, selectors, and annotations leading your way. Let’s first start with the
    notion of namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thinking about the separation of the workloads, namespaces come in handy. A
    namespace is a logical separation of all the namespaced objects deployed in a
    single Kubernetes cluster. Deployments, Services, and Secrets are all namespaced.
    Otherwise, some Kubernetes objects are cluster-wide, such as Nodes, StorageClass,
    and PersistentVolume. The name of a resource has to be unique within a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get all namespaces using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the output gets all the namespace currently in our Kubernetes
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – kubectl getting the namespaces ](img/Figure_4.25_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – kubectl getting the namespaces
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define a pod or any namespaced Kubernetes object, you can specify
    the namespace in the YAML definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you create that pod and specify the namespace that the pod belongs to, you
    can add the `-n` flag when querying this pod using the `kubectl get pods` command.
    The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if the pod has been created in that namespace, you can use the following
    command to check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case that the pods are not in the default namespace, you don’t have
    to specify the namespace option anymore. In the following example, you want to
    set a namespace named `dev`, and then use the `kubectl get` command without the
    `-n` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then simply run the following command without the namespace option
    to list the pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Understanding namespaces will further help you when you need to define the namespace-scoped
    permissions where Kubernetes objects are grouped. We’ll elaborate on this further
    in [*Chapter 6*](B18201_06.xhtml#_idTextAnchor192), *Securing Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: Labels, node selectors, and annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Labels, selectors, and annotations are useful notions when it comes to workload
    scheduling. Labels are key-value pairs attached to Kubernetes objects that can
    be listed in the `metadata.labels` section of an object descriptor. Selectors
    are used for identifying and selecting a group of objects using their labels.
    See the following examples of some quality-based selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to inequality, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example involves chaining multiple selectors together using a
    comma-delimited list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign a pod to nodes, we can use node selectors. You can specify a map
    of key-value pairs in the `PodSpec` field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start by labeling the worker nodes using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to show the label of worker nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Getting the node labels ](img/Figure_4.26_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 – Getting the node labels
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can add the node selector in the YAML definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can attach annotations to objects using the `metadata.annotations` section,
    as with the following configuration file that has the annotation `imageregistry:
    "http://hub.docker.com/"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Annotations are similar to labels and they can be used to store custom metadata
    about objects.
  prefs: []
  type: TYPE_NORMAL
- en: Node affinity and anti-affinity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node affinity and anti-affinity are simply ways to help pods be assigned to
    the right node. Compare this to `nodeSelector`, which is designed for assigning
    a pod directly to the worker nodes. The following is an example of node affinity
    and anti-affinity in the YAML specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: With particular labels, node affinity and anti-affinity allow us to create matching
    rules with logic and operations.
  prefs: []
  type: TYPE_NORMAL
- en: Taints and tolerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from node affinity and anti-affinity, we can also assign taints on the
    node and tolerations on the pods by tainting the nodes and ensuring that no pods
    will be scheduled to that node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to taint a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding definition can be translated into a pod YAML definition file
    to achieve the same outcome as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to un-taint a node, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We have learned how to taint certain nodes when you want to evict workloads
    from a node in this section. Now, let’s look at resource management.
  prefs: []
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes allows us to specify the resource requirements of a container in
    the pod specification, which basically refers to how many resources a container
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: '`kube-scheduler` uses the resource request information that you specify for
    a container in a pod to decide on which worker node to schedule the pod. It’s
    up to `kubelet` to enforce these resource limits when you specify them for the
    containers in the pod so that the running container goes beyond a set limit, as
    well as reserves at least the requested amount of a system resource for a container
    to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It usually gives us the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources.limits.cpu` is the resource limit set on CPU usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.limits.memory` is the resource limit set on memory usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.requests.cpu` is the minimum CPU usage requested to allow your application
    to be up and running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.requests.memory` is the minimum memory usage requested to allow
    your application to be up and running. In the case that a container exceeds its
    memory request, the worker node that it runs on becomes short on overall memory
    at the same time, and the pod that the container belongs to is likely to be evicted
    too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.limits.ephemeral-storage` is the limit on ephemeral storage resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.limits.hugepages-<size>` is the limit on the allocation and consumption
    of pre-allocated huge pages by any applications in a pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A resource request refers to the amount of resources that are necessary to
    run a container, and what they do is govern on which worker node the containers
    will actually be scheduled. So, when Kubernetes is getting ready to run a particular
    pod, it’s going to choose a worker node based on the resource requests of that
    pod’s containers. Kubernetes will use these values to ensure that it chooses a
    node that actually has enough resources available to run that pod. A pod will
    only run on a node that has enough available resources to run the pod’s containers.
    The following is a YAML example of defining `resource request` and `limits`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `kubectl describe node` command to check the allocation resources
    of that node to see whether your requests or limits definitions correspond to
    what is needed in the current circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – kubectl describing the node resources ](img/Figure_4.27_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27 – kubectl describing the node resources
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `kubectl top` command in the case that you have a metrics server
    installed in your cluster to check the actual resource usage of the node or pod.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring an application is a simple and straightforward experience thanks
    to ConfigMaps and Secrets. Let’s take a look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ConfigMaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A ConfigMap is simply a Kubernetes object that stores configuration data in
    key-value pairs. This configuration data can then be used to configure the software
    running in a container by configuring a pod to consume ConfigMaps using environment
    variables, command-line arguments, or mounting a volume with configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a YAML definition to define `configmap` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check `configmap` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – kubectl getting configmap ](img/Figure_4.28_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – kubectl getting configmap
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the binary data of `configmap` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – The configmap binary data ](img/Figure_4.29_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – The configmap binary data
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have `configmap` ready, here’s how to configure the pod to consume
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a pod that can use the `configmap` data by using environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the following command to check the `configmap` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – The configmap mounted value ](img/Figure_4.30_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30 – The configmap mounted value
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a pod to use `configmap` data via a volume. The following is
    an example of a YAML definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the `kubectl logs` command to check the pod for the mounted data
    value, or use the following command to check the `configmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – The configmap mounted value ](img/Figure_4.31_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31 – The configmap mounted value
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that you want to delete a `configmap`, use the `kubectl delete`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have shown how we can work with ConfigMaps in Kubernetes. Once you
    feel comfortable with ConfigMaps, you’ll find a lot of similarities when it comes
    to working with Secrets. Next, we will have a look at how to work with Kubernetes
    Secrets so that they can be consumed by your application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Kubernetes Secret is an object containing sensitive data such as a password,
    an API token, or a key, which is passed to a pod rather than stored in a `PodSpec`
    field or in the container itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a YAML definition to define `configmap` as the following with
    base64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the Secrets by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – kubectl getting Secrets ](img/Figure_4.32_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32 – kubectl getting Secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the Secret, you may want to attach the Secret to an application.
    That’s where you need to create a pod to consume the Secret by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a pod to consume the Secret using environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also consume a Secret as a volume, as shown here – you will define
    a `secret-volume` and then mount the `secret-volume` to the `/etc/secret-volume`
    path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to delete a Secret, use the `kubectl delete` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you delete a Secret, make sure to update the `PodSpec` field for
    your application to avoid exceptions. You can do this by creating a new Secret,
    then attaching it to your pod, or updating your application so it doesn’t need
    the Secret anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Manifest management with kustomize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from Kubernetes 1.14, customization files became available to facilitate
    smoother Kubernetes management. It supports the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Generation of YAML definitions from other resources, such as generating a Kubernetes
    Secret and its YAML definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common configuration across multiple YAML definitions, such as adding namespace
    for a group of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing and customizing a collection of YAML definitions, such as setting
    resource requests and limits for multiple Kubernetes objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be achieved using a central file called `Kustomization.yaml`. You
    can use the following command to view the resources found in the directory that
    are contained in a customization file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then apply those resources by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take Secret generation as an example and generate a Secret manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will be able to see that you have two files created after executing
    the previous steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check out the content of the `customization.yaml` file, you
    can use `cat customization.yaml` and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use the `kubectl apply` command to deploy the pod with the Secret
    mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Kustomize is a good way to customize your application configuration and now
    that it is built into `kubectl apply -k`, you can gain a greater understanding
    of the use cases of Kustomize by visiting the official documentation site: [https://kubectl.docs.kubernetes.io/guides/](https://kubectl.docs.kubernetes.io/guides/).'
  prefs: []
  type: TYPE_NORMAL
- en: Common package management and templating with Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helm is a management tool for managing packages of pre-configured Kubernetes
    objects in the form of charts – we call these Helm charts. Helm charts allow users
    to install and manage Kubernetes applications more reproducibly and effectively.
    Furthermore, you can find popular Helm charts from the community or share your
    own applications with the Helm community at this link: [https://artifacthub.io/packages/search](https://artifacthub.io/packages/search).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard file structure of a chart is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Charts` – (the folder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chart.yaml #` – A .`yaml` file that contains the information about the chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.lock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requirements.yaml` – an optional file that lists the dependencies for a chart
    (the dependencies are actually packaged in the `Charts` folder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates` – a directory of templates that combine with values to generate
    Kubernetes manifest files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values.yaml` – contains the default configuration values for the chart (this
    is where Helm grabs the values for the manifest template that contains the reference
    values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To query the Helm charts that have been deployed, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to search for a chart, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete a Helm chart that has been deployed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you install a chart, a new release is created. So, one chart can be
    installed multiple times into the same cluster. Each can be independently managed
    and upgraded. To upgrade a release to a specified version of a chart or update
    the chart values, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'To roll back to a specific version, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Helm charts help you manage, install, and upgrade Kubernetes-native applications.
    You can learn more about Helm by visiting their official documentation website:
    [https://helm.sh/docs/](https://helm.sh/docs/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered one of the most common tasks for both Kubernetes
    Administrators and Developers – application scheduling and managing the application
    lifecycle. Even though this chapter covers about 15% of the content of the CKA
    exam, working with Kubernetes objects is one of the most important daily tasks
    as a Kubernetes Administrator. Ensure that you practice enough and master the
    shortcuts of the `kubectl` commands before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about Kubernetes storage. The content and the
    questions covered in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application
    Scheduling and Lifecycle Management* and [*Chapter 5*](B18201_05.xhtml#_idTextAnchor149),
    *Demystifying Kubernetes Storage* are considered very high-value and less time-consuming
    within the scheme of the actual CKA exam. Stay tuned and keep learning!
  prefs: []
  type: TYPE_NORMAL
- en: Mock CKA scenario-based practice test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have two virtual machines, `master-0` and `worker-0`. Please complete the
    following mock scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH into the `worker-0` node and provision a new pod called `ngnix` with a single
    container, `nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0` and then scale `nginx` to 5 copies.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0`, set a ConfigMap with a username and password, and then attach
    a new pod to BusyBox.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0` and create a `nginx` pod with an init container called `busybox`.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0`, create a `nginx` pod, and then a `busybox` container in the
    same pod.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where can I find out about Helm charts?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to Helm’s official documentation to learn more about Helm: [https://helm.sh/docs/howto/charts_tips_and_tricks/](https://helm.sh/docs/howto/charts_tips_and_tricks/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Where can I find out about Kustomize?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to Helm’s official documentation to learn more about Kustomize: [https://kubectl.docs.kubernetes.io/references/kustomize/](https://kubectl.docs.kubernetes.io/references/kustomize/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is the recommended official Kubernetes article about init containers?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking this article, *Init Containers*: [https://kubernetes.io/docs/concepts/workloads/pods/init-containers/](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is your recommended Kubernetes official article for ConfigMaps?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking an article, *ConfigMaps*: [https://kubernetes.io/docs/concepts/configuration/configmap/](https://kubernetes.io/docs/concepts/configuration/configmap/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is your recommended official Kubernetes article for resource management?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I recommend bookmarking this article, *Resource Management for Pods and Containers*:
    [https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/).'
  prefs: []
  type: TYPE_NORMAL
