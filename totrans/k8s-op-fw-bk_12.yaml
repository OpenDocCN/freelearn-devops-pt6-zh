- en: '*Chapter 9*: Diving into FAQs and Future Trends'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Operator Framework** covers a lot of different topics, many of which
    have been discussed in this book. In this chapter, we will not discuss any new
    topics. Rather, we will revisit all of the main points that have been covered
    since the start of the book in short, digestible FAQ-style headings. It is the
    intent of these FAQs to provide a brief reference and refresher to everything
    that was covered during the course of this book. This should be a good, quick
    reminder of various topics in the event you are studying for an interview, certification
    exam, or just trying to remember an overview of a certain point that was made.
    The outline for these FAQs will fall under the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: FAQs about the Operator Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FAQs about Operator design, **CustomResourceDefinitions** (**CRDs**), and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FAQs about the Operator SDK and coding controller logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FAQs about OperatorHub and the Operator Lifecycle Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future trends in the Operator Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These sections are roughly in the order that they appeared in the book, so reading
    this chapter in order will jog your memory and solidify your understanding of
    the topics as they were originally presented.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs about the Operator Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These topics include an overview of the Operator Framework, its basic components,
    and the general vocabulary of Operator design. The topics from this section are
    from [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introducing the Operator
    Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: What is an Operator?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Operator is a type of Kubernetes controller. Operators are designed to automate
    the management of Kubernetes applications and cluster components. They do this
    by continuously working to reconcile the current state of the cluster with the
    desired state, as defined by a user or administrator.
  prefs: []
  type: TYPE_NORMAL
- en: What benefit do Operators provide to a Kubernetes cluster?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators provide an idiomatic way for developers to encode automated cluster
    and application management logic into a controller. Operators also offer ways
    to expose the settings for this automation to non-developer users (for example,
    cluster administrators or customers). This automation frees up engineering and
    DevOps resources for many tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How are Operators different from other Kubernetes controllers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators are very similar to any other **Kubernetes** controller. Some examples
    of built-in controllers in Kubernetes include the **scheduler**, the API server,
    and the controller manager (which itself manages other controllers). These native
    controllers all handle the automated execution of core cluster functionality,
    such as placing Pods onto Nodes and maintaining Deployment replica counts. This
    is all part of the continuous state reconciliation pattern that Operators also
    exhibit.
  prefs: []
  type: TYPE_NORMAL
- en: However, while they are functionally similar, Operators are defined by conceptual
    and semantic conventions that differentiate them from standard controllers. These
    include the development libraries, tools, deployment methods, and distribution
    channels that comprise the Operator Framework.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Operator Framework?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operator Framework is a set of development and deployment tools and patterns
    that define and support the standard processes for building an Operator. In broad
    terms, these include code libraries and scaffolding tools (the Operator SDK),
    a component for installing, running, and upgrading Operators (the **Operator Lifecycle
    Manager** (**OLM**)), and a centralized index for distributing Operators among
    the Kubernetes community (OperatorHub).
  prefs: []
  type: TYPE_NORMAL
- en: What is an Operand?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Operand is the component or resources that are managed by an Operator.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main components of the Operator Framework?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main components of the Operator Framework are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Operator SDK** – A set of common libraries and command-line tools for
    building an Operator from scratch. This includes wrappers for tools such as **Kubebuilder**,
    which are designed for generating code used in Kubernetes controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The OLM** – A component designed to install, run, and upgrade (or downgrade)
    Operators in a Kubernetes cluster. Operator developers write (or generate) files
    that describe the Operator''s relevant metadata in a way that the OLM can automate
    the Operator''s deployment. The OLM also serves as an in-cluster catalog of installed
    Operators and can ensure that there are no conflicting APIs between installed
    Operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OperatorHub** – A centralized index of freely available Operators backed
    by an open source GitHub repository. Developers can submit Operators to [https://operatorhub.io/](https://operatorhub.io/)
    for them to be indexed and searchable by users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's talk about programming languages Operators can be written in.
  prefs: []
  type: TYPE_NORMAL
- en: What programming languages can Operators be written in?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technically, an Operator can be written in any language that supports the necessary
    clients and API calls needed in order to interact with a Kubernetes cluster. But,
    the Operator SDK supports writing Operators in `operator-sdk` command-line tool,
    but these Operators are ultimately limited in their capability. In this book,
    we covered the code needed to write an Operator in Go, which offers far more functionality
    as defined by the Operator Capability Model.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Operator Capability Model?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Capability Model is a rubric for measuring the functionality an Operator
    provides and informing users of that functionality level. It defines five incremental
    levels of functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level I – Basic Install**: Operators that are able to install an Operand,
    exposing configuration options for that installation if applicable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Level II – Seamless Upgrades**: Operators that can upgrade themselves and
    their Operand without disrupting function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Level III – Full Lifecycle**: Operators that can handle creation and/or restoration
    of Operand backups, failover scenarios for failure recovery, more complex configuration
    options, and scale Operands automatically'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Level IV – Deep Insights**: Operators that report metrics on themselves or
    their Operand'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Level V – Auto Pilot**: Operators that handle complex automated tasks including
    auto-scaling (creating more replicas of an Operand or deleting replicas, as needed),
    auto-healing (detecting and recovering from failure scenarios without intervention
    based on automated reporting such as metrics or alerts), auto-tuning (reallocating
    Operand Pods to better-suited Nodes), or abnormality detection (detecting when
    Operand performance does not align with usual application health)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These were some of the most fundamental topics covered in the first chapter.
    The next sections in this book built upon these to dive deeper into Operator design
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs about Operator design, CRDs, and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These questions cover information about an Operator's design, including approaches
    to developing an Operator and how Operators can function within a Kubernetes cluster.
    The topics in this section were introduced in [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032),
    *Understanding How Operators Interact with Kubernetes*, and [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*.
  prefs: []
  type: TYPE_NORMAL
- en: How does an Operator interact with Kubernetes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators interact with Kubernetes through event-triggered continuous monitoring
    of the cluster's state, wherein the Operator attempts to reconcile the current
    state with the desired state as specified by a user. From a technical standpoint,
    it does so through a standard set of Kubernetes client libraries that allow it
    to list, get, watch, create, and update Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: What cluster resources does an Operator act on?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Operator can act on any resource that is accessible through the Kubernetes
    API (and that the Operator has cluster permissions to access). This includes native
    Kubernetes resources (such as Pods, ReplicaSets, Deployments, Volumes, and Services)
    and **custom resources** (**CRs**) provided by third-party APIs or CRDs.
  prefs: []
  type: TYPE_NORMAL
- en: What is a CRD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CRD is a native Kubernetes API type that allows developers to extend the Kubernetes
    API with CR types that look and behave exactly like native Kubernetes API resources.
    Operator developers can create a CRD that defines their Operator's API type (for
    example, `customresourcedefinitions/MyOperator`) and this CRD then provides the
    template for creating CR objects that fit the definition of that type (for example,
    `MyOperators/foo`).
  prefs: []
  type: TYPE_NORMAL
- en: How is a CRD different from a CR object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CR object is the individual representation of an object that is based on the
    CRD template. In programming terms, it is the difference between an abstract type
    and an object instantiation of that type. CR objects are the API objects that
    users interact with to set Operator settings, for example with commands such as
    `kubectl get MyOperators/foo`.
  prefs: []
  type: TYPE_NORMAL
- en: What Kubernetes namespaces do Operators run within?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators can either be `namespaced` or `cluster-scoped`. Namespaced Operators
    run within an individual namespace, which allows multiple copies of the same Operator
    to be installed in a cluster. Cluster-scoped Operators run at the cluster-wide
    level, managing resources in multiple namespaces. The scope of an Operator is
    largely determined by the namespace scope defined in its CRD and the **role-based
    access control** (**RBAC**) policies assigned to the Operator's service.
  prefs: []
  type: TYPE_NORMAL
- en: How do users interact with an Operator?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Users first interact with an Operator by installing it. This can be either from
    an index such as OperatorHub or by installing directly from your organization's
    website or GitHub page. Operators can usually be installed with a single `kubectl
    create` command, especially when installed via the OLM.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, users will mainly interact with an Operator by creating a CR
    object that is a representation of its CRD. This CR object will expose API fields
    designed for tweaking the various settings associated with the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: How can you plan for changes early in an Operator's lifecycle?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with many software projects, thoughtful design allows for much easier growth
    as the project evolves. In the context of Operators, this means thinking early
    on about how the Operator (and more importantly, its Operand) may change over
    time. Upstream APIs and third-party dependencies may have support cycles that
    differ from your organization's own, so minimizing exposure to these dependencies
    can be very beneficial in reducing the work required later on. To this end, it
    can be helpful to start small with an Operator's design and build on that functionality
    as needed. This is part of the idea behind the Capability Model, with each level
    effectively building on the previous.
  prefs: []
  type: TYPE_NORMAL
- en: How does an Operator's API relate to its CRD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API that an Operator provides is the code definition of its CRD. When writing
    an API with the Operator SDK in Go, that API is generated into a CRD using the
    tools provided by the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: What are the conventions for an Operator API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operator API conventions generally follow the same upstream Kubernetes conventions
    as for native API objects. The most important of these is that the Operator object
    contains two fields, `spec` and `status`, which provide the backbone for the cluster-state-reconciliation
    loop that Operators run on. `spec` is the user input section of the Operator object,
    while `status` reports the current functioning conditions of the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: What is a structural CRD schema?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A structural CRD schema is an object definition that enforces known fields in
    cluster memory. Kubernetes requires CRDs to define a structural schema, which
    can be generated with tools provided by the Operator SDK. They provide security
    advantages and are often complex, owing to the recommendation that they are generated
    rather than hand-written.
  prefs: []
  type: TYPE_NORMAL
- en: What is OpenAPI v3 validation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAPI v3 validation is a format for providing field type and format validation
    upon the creation or modification of an object. Field validation is defined in
    the Go code for the CRD's API types. This validation is in the form of comments
    (for example, `//+kubebuilder:validation…`). These comments are generated into
    a validation schema when the Operator CRD is generated.
  prefs: []
  type: TYPE_NORMAL
- en: What is Kubebuilder?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubebuilder is an open source project that provides a tool for generating Kubernetes
    APIs and controllers. Many of the commands in the Operator SDK are wrappers for
    underlying Kubebuilder commands. This is good to know for debugging and support
    when troubleshooting Operator SDK issues.
  prefs: []
  type: TYPE_NORMAL
- en: What is a reconciliation loop?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **reconciliation loop**, or **control loop**, is the main logic function
    of an Operator. It is conceptually the continuous cycle of checks an Operator
    performs to ensure that the actual cluster state matches the desired state. In
    reality, this is usually not done as a continuous loop but rather as an event-triggered
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: What is the main function of an Operator's reconciliation loop?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operator's reconciliation loop is its core logic, during which the Operator
    evaluates the current state of the cluster, compares that to the desired state,
    and, if necessary, performs the required actions to reconcile the state of the
    cluster to match the desired state. This could mean updating a Deployment or tuning
    workload constraints to react to changing states.
  prefs: []
  type: TYPE_NORMAL
- en: What are the two kinds of event triggering?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event triggering generally falls into two categories: **level-triggered** and
    **edge-triggered**. Operators are designed following the level-based triggering
    approach, in which a triggering event does not contain all of the context of the
    cluster state. Rather, the Operator must receive only enough information from
    the event to understand the relevant cluster state itself. By rebuilding this
    information each time, the Operator ensures that no state information is lost
    due to delays or dropped events. This is in contrast to edge-triggered events
    (reconciliation activated only by the incoming action of an event), which can
    result in information loss and are not suitable for large distributed systems
    such as Kubernetes. These terms stem from electronic circuit design.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a ClusterServiceVersion (CSV)?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `ClusterServiceVersion` is a CRD provided by the Operator Framework that contains
    metadata describing a single version of an Operator. The `ClusterServiceVersion`
    CRD is provided by the OLM, which is the primary consumer of Operator CSVs. OperatorHub
    also uses the Operator CSV to present information to users about an Operator.
  prefs: []
  type: TYPE_NORMAL
- en: How can Operators handle upgrades and downgrades?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operator versions are defined by their release version, image tag, and CSV metadata.
    The CSV in particular provides the concept of upgrade channels, which allow a
    developer to define subscription pathways for upgrade and downgrade versions.
    The OLM then knows how to transition installed Operators between versions thanks
    to this metadata. Operator API versions are defined in the Operator's CRD, which
    can contain information about multiple versions. This allows developers to ship
    an Operator release that supports multiple API versions simultaneously, enabling
    users to transition between versions within a single release.
  prefs: []
  type: TYPE_NORMAL
- en: How can Operators report failures?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators have several ways to report issues. These include standard runtime
    logs, metrics and telemetry, status conditions, and Kubernetes events.
  prefs: []
  type: TYPE_NORMAL
- en: What are status conditions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Status conditions are an Operator's ability to use an upstream Kubernetes API
    type (`v1.Condition`) that quickly informs a user about various failure (or success)
    states via an Operator's `status` field in its CRD.
  prefs: []
  type: TYPE_NORMAL
- en: What are Kubernetes events?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Events are Kubernetes API objects that can be aggregated, monitored, and filtered
    by native Kubernetes tools such as `kubectl`. Their definition is richer than
    that of status conditions, allowing for more advanced information reporting to
    users.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs about the Operator SDK and coding controller logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topics in this section focus on the technical development of an Operator
    with the Operator SDK. This includes generating an Operator project's initial
    boilerplate code, filling out the code with custom reconciliation logic, and expanding
    that code with more advanced features. These topics were introduced in [*Chapter
    4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing an Operator with the Operator
    SDK*, and [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an
    Operator – Advanced Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Operator SDK?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operator SDK is a software development kit that provides code libraries
    and tools to quickly scaffold and build an Operator. It is mainly used through
    the `operator-sdk` binary, which provides commands to initialize projects, create
    boilerplate APIs and controllers, generate code, and build and deploy Operators
    in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: How can operator-sdk scaffold a boilerplate Operator project?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first command to create an Operator SDK project is `operator-sdk init`.
    This command accepts additional flags to provide some project information (such
    as the code repository location of the project) that will later populate variables
    used when creating other aspects of the Operator (such as the API and controllers).
  prefs: []
  type: TYPE_NORMAL
- en: What does a boilerplate Operator project contain?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A boilerplate Operator project (that is, one that has just been created with
    `operator-sdk init` and no other changes) contains only a `main.go` file with
    some basic standard code, a `Dockerfile` file for building a container image,
    a `Makefile` file, which provides more commands to build and deploy an Operator,
    and some additional directories of config files and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: How can you create an API with operator-sdk?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `operator-sdk create api` command initializes a template API file structure
    to be filled in by the developer. It accepts additional flags to define the API
    version and the Operator's resource name, and can even create the boilerplate
    controller for the Operator to handle the API object.
  prefs: []
  type: TYPE_NORMAL
- en: What does a basic Operator API created with operator-sdk look like?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The empty template API created by `operator-sdk create api` contains a basic
    definition for the Operator's `config` object. This object comprises upstream
    metadata types (containing fields such as `namespace` and `name`) as well as two
    sub-objects, representing the `spec` and `status` fields of the Operator's CRD.
  prefs: []
  type: TYPE_NORMAL
- en: What other code is generated by operator-sdk?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with the boilerplate template code, which is meant to be modified by the
    developer, the `operator-sdk` command also generates `deepcopy` and other code
    that is used by Kubernetes clients but should not be modified. Therefore, it's
    important to regularly re-run the code generators provided by `operator-sdk` to
    ensure this auto-generated code stays up to date.
  prefs: []
  type: TYPE_NORMAL
- en: What do Kubebuilder markers do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubebuilder markers are specially formatted code comments placed on API object
    fields, types, and packages. They define field validation settings (such as type,
    length, and pattern) and other options that control the Operator's CRD generation.
    They allow such options to be configured in a location that makes them very clear,
    right next to the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: How does the Operator SDK generate Operator resource manifests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operator SDK generates the relevant resource manifests (including the Operator's
    CRD, as well as other required resources such as `make manifests` command. This
    command is defined in the standard `Makefile` file in a basic Operator project,
    and it invokes the `controller-gen` binary (part of the Kubebuilder toolset) to
    do the generation.
  prefs: []
  type: TYPE_NORMAL
- en: How else can you customize generated Operator manifests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generated Operator manifests can be customized beyond what is done by default
    with the `controller-gen` tool. This program is the underlying component responsible
    for much of the generated resource files, and running it manually offers access
    to additional commands and flags.
  prefs: []
  type: TYPE_NORMAL
- en: What are go-bindata and go:embed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`go-bindata` and `go:embed` are two ways to compile raw files into Go code.
    The former is a package that can be imported into projects as a library, while
    the latter is a native Go compiler directive. Both are useful options for making
    Operator-related resources (such as an Operand Deployment YAML file) accessible
    in the code and readable for other users.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the basic structure of a control/reconciliation loop?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For most Operators, the basic structure of a control loop follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the desired configuration of the Operator/cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assess the current state of the cluster, with the information available to the
    Operator, and compare this to the desired configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If needed, take action to transition the current cluster state toward the desired
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At each of these steps, Operators should also implement error checking and status
    reporting branches to report any failures to the user (for example, if the Operator
    is unable to find its own configuration, it should obviously not proceed).
  prefs: []
  type: TYPE_NORMAL
- en: How does a control loop function access Operator config settings?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main control loop function (`Reconcile()` in Operator SDK projects) accesses
    the Operator's config settings through its CR object. This requires that the user
    has created an instance of the CR object in the cluster (as defined by the CRD).
    Since CR objects are accessible through the Kubernetes API, the Operator is able
    to use Kubernetes clients and functions such as `Get()` to retrieve its config.
    In the Operator SDK, these clients are automatically populated and passed to the
    `Reconcile()` function, ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: What information does a status condition report?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `v1.Condition` object contains fields describing the status: `type` (a short
    name for the status), `status` (a Boolean value indicating the status), and `reason`
    (a longer description providing more information to the user). It also contains
    timestamp information regarding the last transition timestamp of the status.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the two basic kinds of metrics?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Metrics fall into roughly two categories: **service metrics** and **core metrics**.
    Service metrics are metrics that have been defined as custom for a specific component
    (or service), while core metrics are common metrics published by all services
    (such as CPU and memory usage).'
  prefs: []
  type: TYPE_NORMAL
- en: How can metrics be collected?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Core metrics can be collected using the `metrics-server` component ([https://github.com/kubernetes-sigs/metrics-server](https://github.com/kubernetes-sigs/metrics-server)).
    Service metrics can be collected by any metrics aggregation tool, such as Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: What are RED metrics?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Rate, errors, and duration** (**RED**) is an acronym describing the best
    practices for defining new metrics. It is recommended that the three key kinds
    of metrics for a service should include rate, errors, and duration. This means
    reporting the number of requests per period, the number of failed attempts, and
    the latency for a request, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: What is leader election?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leader election is the concept of running multiple copies of an application,
    with one copy (the leader) working at a time. This provides high availability
    for the application because if one replica fails, there are others ready to take
    its place. This concept applies to Operators, because it may be necessary to ensure
    Operator uptime in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: What are the two main strategies for leader election?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leader election can be implemented as either leader-with-lease or leader-for-life.
    The leader-with-lease approach is the default strategy for Operator SDK projects,
    and in it, the current leader makes periodic attempts to renew its status. This
    allows leader transitions to happen quickly, should they need to occur. In leader-for-life
    approaches, the leader only relinquishes its status when it is deleted. This makes
    recovery slower, but more definitive.
  prefs: []
  type: TYPE_NORMAL
- en: What are health and ready checks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Health and ready checks are watchdog endpoints that allow an application to
    indicate when it is healthy (that is, running smoothly) and ready (that is, actively
    prepared to serve requests). The Operator SDK provides basic health and ready
    checks with a boilerplate project, but these can easily be extended to accommodate
    custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs about OperatorHub and the OLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These questions relate to the building, shipping, and deployment of Operators.
    Topics covered include installing Operators with the OLM and submitting Operators
    to OperatorHub. These topics come from [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090),
    *Building and Deploying Your Operator*, and [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*.
  prefs: []
  type: TYPE_NORMAL
- en: What are the different ways to compile an Operator?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like many cloud-native applications, an Operator can be compiled either as a
    local binary or built into a container image suitable for deploying directly onto
    a Kubernetes cluster. The Operator SDK provides commands to do both.
  prefs: []
  type: TYPE_NORMAL
- en: How does a basic Operator SDK project build a container image?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Operator SDK provides `Makefile` targets to build a Docker image with `make
    docker-build`. By default, this copies the main Operator source code (specifically,
    the main controller and API) along with its `assets` directory to the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: How can an Operator be deployed in a Kubernetes cluster?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators can be deployed manually once the Docker image has been built, similar
    to how any other application is deployed in a Kubernetes cluster. The Operator
    SDK simplifies this with the `make deploy` command. Operators can also be installed
    with the OLM.
  prefs: []
  type: TYPE_NORMAL
- en: What is the OLM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OLM is a component provided by the Operator Framework to manage the installation,
    running, and upgrade/downgrade of Operators in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: What benefit does running an Operator with the OLM provide?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OLM provides a convenient tool to install Operators (as opposed to methods
    such as manually deploying the Operator image), as well as monitor the Operator
    status in a cluster. It can ensure that an Operator does not create any conflicts
    with other Operators. It can also handle upgrades and downgrades of Operators
    in the cluster. Finally, it makes the list of installed Operators in the cluster
    available to users.
  prefs: []
  type: TYPE_NORMAL
- en: How do you install the OLM in a cluster?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OLM can be installed with the `operator-sdk` binary by running `operator-sdk
    olm install`.
  prefs: []
  type: TYPE_NORMAL
- en: What does the operator-sdk olm status command show?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running `operator-sdk olm status` (after installing OLM in the cluster) shows
    the OLM's health by listing its required resources (including the CRDs it installs,
    its RoleBindings, Deployment, and namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: What is an Operator bundle?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bundle is a format for packaging an Operator's manifests and **ClusterServiceVersion**
    (**CSV**).
  prefs: []
  type: TYPE_NORMAL
- en: How do you generate a bundle?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Operator SDK, a bundle can be generated by running `make bundle`. This
    command is interactive and will ask for information about the Operator and your
    organization, which will then be compiled into the Operator's metadata in the
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: What is a bundle image?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bundle image is a container image that holds the information from the Operator's
    bundle. The image is used to deploy an Operator in a cluster, based on the underlying
    metadata.
  prefs: []
  type: TYPE_NORMAL
- en: How do you build a bundle image?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bundle image can be built with the Operator SDK by running `make bundle-build`.
    This builds the basic Docker image that holds the bundle information.
  prefs: []
  type: TYPE_NORMAL
- en: How do you deploy a bundle with the OLM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `operator-sdk run bundle` command deploys a bundle image into a cluster
    with the OLM. This command takes an additional argument, which is the location
    of the bundle image in a container registry, for example, `operator-sdk run bundle
    docker.io/myreg/myoperator-bundle:v0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: What is OperatorHub?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OperatorHub is a centralized index of published Operators from various developers
    and organizations. Its website is [https://operatorhub.io](https://operatorhub.io).
    For each Operator, it provides information about the Operator and developer as
    well as installation guides and links to support resources and source code. It
    does this by parsing information from the Operator's bundle (mainly from the Operator
    CSV).
  prefs: []
  type: TYPE_NORMAL
- en: How do you install an Operator from OperatorHub?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each Operator''s page on OperatorHub includes a link to installation instructions.
    These instructions include a series of simple commands, usually using `kubectl
    create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Screenshot of OperatorHub installation instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B18147.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Screenshot of OperatorHub installation instructions
  prefs: []
  type: TYPE_NORMAL
- en: How do you submit an Operator to OperatorHub?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Listing an Operator on OperatorHub involves creating a **pull request** (**PR**)
    to the GitHub repository, which serves as the backend index powering OperatorHub.
    The requirements include submitting a valid CSV file in a directory structure
    that is easily copied from the output of the Operator SDK bundle generation commands.
    Automated tests check that all requirements for submission have been met and merge
    the submission PR, with the Operator being listed on [https://operatorhub.io](https://operatorhub.io)
    soon after.
  prefs: []
  type: TYPE_NORMAL
- en: Future trends in the Operator Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section refers to the future maintenance of your own Operator, as well
    as the alignment with ongoing work in the upstream Kubernetes community and how
    that relates to third-party Operator development. These topics are from [*Chapter
    8*](B18147_08_ePub.xhtml#_idTextAnchor126), *Preparing for Ongoing Maintenance
    of Your Operator*.
  prefs: []
  type: TYPE_NORMAL
- en: How do you release a new version of an Operator?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Releasing a new version of an Operator is mostly dependent on your organization's
    release methods regarding timing and delivery infrastructure. But, the Operator
    Framework provides ways to denote your Operator's version in the form of the version
    field in the Operator's CSV (which is shown on OperatorHub), new API versions,
    and release channels.
  prefs: []
  type: TYPE_NORMAL
- en: When is it appropriate to add a new API version?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common time to add a new API version is when you are introducing a
    breaking change to the existing API. It can also be appropriate to increase the
    API's version as an indicator of its stability level (for example, promoting a
    `v1alpha1` API to `v1beta1` or `v1`). It is most important to follow the support
    timelines you have chosen to establish (or the Kubernetes timeline, if you have
    chosen to adopt those as a template) when replacing an old API version with a
    new one.
  prefs: []
  type: TYPE_NORMAL
- en: How do you add a new API version?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new API can be added with the `operator-sdk create api` command. This command
    scaffolds the empty Go files just as when creating the Operator's initial API
    in a project. Once these files are filled out with the new API types, the corresponding
    generated code, CRD, and other manifests can be updated with the `make generate`
    and `make manifests` commands.
  prefs: []
  type: TYPE_NORMAL
- en: What is an API conversion?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An API conversion refers to an Operator's ability to transcribe API objects
    between incompatible versions of the same API. Conversion code in an Operator
    allows it to support multiple versions of its API within the same release. This
    is usually done by developers writing manual conversion logic to ensure that the
    incompatible fields between the two APIs can translate back and forth (round-trip)
    without losing any data. The biggest benefit of this is allowing users to transition
    from a deprecated API to a newer version seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: How do you convert between two versions of an API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing a new API, consider how the existing information in an older
    version can be accurately translated to the new version and back. Then, you can
    convert between two versions of an API by implementing a conversion webhook in
    your Operator's code.
  prefs: []
  type: TYPE_NORMAL
- en: What is a conversion webhook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A conversion webhook is an endpoint that is exposed in your Operator's Pod that
    accepts requests from the API server to encode and decode API objects between
    different versions.
  prefs: []
  type: TYPE_NORMAL
- en: How do you add a conversion webhook to an Operator?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A conversion webhook consists of two Go interfaces that must be implemented
    for the API object types that are being converted. These are the `Convertible`
    and `Hub` interfaces from `sigs.k8s.io/controller-runtime/pkg/conversion`. Most
    importantly, the `Convertible` interface requires two functions, `ConvertTo()`
    and `ConvertFrom()`, which are where a developer manually writes the logic to
    translate fields between the two objects. Then, the webhook manifests that expose
    the relevant endpoint can be created with the `operator-sdk create webhook` command.
    These manifests are then enabled by uncommenting the webhook references within
    the project's `Kustomization` files.
  prefs: []
  type: TYPE_NORMAL
- en: What is kube-storage-version-migrator?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**kube-storage-version-migrator** is a tool that allows Kubernetes users to
    manually convert their existing stored API objects to a new API version. This
    can be useful to help progress updates between Operator versions where a new API
    changes the storage version of the Operator''s CRD object.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you update an Operator's CSV?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Operator's CSV holds information about the Operator, including its current
    version. To increase the Operator's version, the CSV should first be updated to
    indicate the previous version of the Operator with the `replaces` field. In other
    words, this tells tools such as the OLM which version precedes the new version
    so that it can upgrade to the right version. Then, the `VERSION` variable in the
    Operator project's `Makefile` should be updated to the new version number (for
    example, `0.0.2`). The new CSV is generated with the `make bundle` and `make bundle-build`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: What are upgrade channels?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upgrade channels are a way to offer different distribution upgrade pathways.
    For example, an Operator's CSV can define `alpha` and `stable` channels. Users
    can then choose to subscribe to either channel to get updated versions at the
    cadence and stability level they desire.
  prefs: []
  type: TYPE_NORMAL
- en: How do you publish a new version on OperatorHub?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OperatorHub hosts Operator information in bundles on GitHub. Each Operator has
    its own unique directory, with every different version of that Operator as its
    own subdirectory. These subdirectories each hold the bundle information (such
    as its CSV) for that version.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Kubernetes deprecation policy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes deprecation policy defines the API version support guidelines
    for core Kubernetes components. This provides downstream and third-party developers
    (as well as users) with a guaranteed timeline for support based on an API's stability.
    It is also a good template for other projects that are not strictly beholden to
    the policy but wish to align with the upstream Kubernetes policy for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: How can API elements be removed in the Kubernetes deprecation policy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Kubernetes deprecation policy, API elements can only be removed by incrementing
    the API version. In other words, if an Operator is following the Kubernetes deprecation
    policy, then it cannot remove a CRD field from the current API. It must, instead,
    create a new API version that does not have the field.
  prefs: []
  type: TYPE_NORMAL
- en: How long are API versions generally supported?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The support timeline for an API version in the Kubernetes deprecation policy
    depends on its stability level (alpha, beta, or GA). Alpha APIs have no guaranteed
    timeline and can be changed at any time. Beta APIs are supported for 9 months
    or three releases (whichever is longer). Graduated GA APIs cannot be removed,
    but they can be marked as deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: How long is the Kubernetes release cycle?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes release cycle for a minor version is about 15 weeks long and
    contains several milestone dates, including Enhancements Freeze, Code Freeze,
    and Retrospective.
  prefs: []
  type: TYPE_NORMAL
- en: What is Enhancements Freeze?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enhancements Freeze is the point during the release cycle at which **Kubernetes
    Enhancements** (**KEPs**) must be implementable and committed to the release or
    officially delayed to at least the next release.
  prefs: []
  type: TYPE_NORMAL
- en: What is Code Freeze?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At Code Freeze, all significant code changes must be merged into the current
    release or otherwise obtain an exception for a reasonable extension.
  prefs: []
  type: TYPE_NORMAL
- en: What is Retrospective?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retrospective is a series of meetings leading up to and following the Kubernetes
    release in which community members reflect on the successful areas of the release
    and pinpoint processes that can use improvement.
  prefs: []
  type: TYPE_NORMAL
- en: How do Kubernetes community standards apply to Operator development?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operator developers have no requirement to adhere to the Kubernetes community
    standards or participate in upstream development. However, an awareness of how
    the Kubernetes project functions is helpful to Operator developers because it
    offers guidelines for feature support, and Operators are very often dependent
    on certain Kubernetes features. These standards also provide a template for an
    Operator's own development processes that can be presented to the Operator's users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are obviously too many topics to cover in a discussion about the Operator
    Framework to distill them all into a single chapter of bite-sized trivia. But,
    to serve as a refresher (or crash course), the goal of this chapter was to recap
    the most important points that were already discussed, in a way that briefly explains
    them all, start to finish. For a deeper dive into any of these topics, the chapters
    they originated from have been provided as a resource. There are also any one
    of the many fantastic references that have been listed throughout this book to
    give support and further reading on all of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will examine real-world Operators that have been developed
    in the open source community. By doing so, we have the opportunity to relate each
    of the previous topics to a concrete example and compare the similarities and
    differences between what was done with the samples provided in this book and a
    real Operator.
  prefs: []
  type: TYPE_NORMAL
