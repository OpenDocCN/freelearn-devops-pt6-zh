- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting Security and Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this book, we have talked about Kubernetes architecture, the application
    life cycle, security, and networking. I hope that since this is the last chapter,
    we can follow on from [*Chapter 9*](B18201_09.xhtml#_idTextAnchor340), *Troubleshooting
    Cluster Components and Applications*, to talk about security and networking troubleshooting.
    This chapter provides the general troubleshooting approaches for troubleshooting
    errors caused by RBAC restrictions or networking settings. We have touched upon
    how to enable Kubernetes RBAC in [*Chapter 6*](B18201_06.xhtml#_idTextAnchor192),
    *Securing Kubernetes*, and upon working with Kubernetes DNS in [*Chapter 7*](B18201_07.xhtml#_idTextAnchor235),
    *Demystifying Kubernetes Networking*. Be sure to go back to these chapters and
    review the important concepts before diving into this chapter. We’re going to
    cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting RBAC failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we need to make sure your local machine meets the following
    technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you’re on Linux, we’re demonstrating examples with a `minikube` cluster
    – check out [*Chapter 2*](B18201_02.xhtml#_idTextAnchor035), *Installing and Configuring
    Kubernetes Clusters*. Make sure that your test environment meets the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A compatible Linux host. We recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that your host machine has at least 2 GB of RAM, 2 CPU cores, and
    about 20 GB of free disk space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case you’re on Windows 10 or Windows 11, make note of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend updating Docker Desktop to the latest version and creating a local
    `docker-desktop` Kubernetes cluster. Refer to this article to understand how to
    set up a local Kubernetes cluster with Docker Desktop: [https://docs.docker.com/desktop/kubernetes/.](https://docs.docker.com/desktop/kubernetes/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also recommend using **Windows Subsystem for Linux 2** (**WSL 2**) to test
    the environment – refer to this article to see how to install WSL 2 ([https://docs.microsoft.com/en-us/windows/wsl/install](https://docs.microsoft.com/en-us/windows/wsl/install))
    and the following article to see how to set up the Docker Desktop WSL 2 backend
    ([https://docs.docker.com/desktop/windows/wsl/](https://docs.docker.com/desktop/windows/wsl/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting RBAC failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting any issues related to Kubernetes security seems a bit contradictory.
    As a matter of fact, most of the security layers of Kubernetes involve working
    with tooling that helps secure the 4C layers of Kubernetes, which involves security
    scanning, managing, and protection. To learn more about the 4C layers, please
    refer to [*Chapter 6*](B18201_06.xhtml#_idTextAnchor192), *Securing Kubernetes*.
    When it comes to troubleshooting security, the CKA exam is most often about the
    Kubernetes RBAC issue. Therefore, we’ll focus on showing an example of troubleshooting
    RBAC failures in Kubernetes in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating a minikube cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This part is not covered by the CKA exam, but you may encounter this if you’re
    trying to deploy the `minikube` cluster by yourself following the instructions
    in [*Chapter 2*](B18201_02.xhtml#_idTextAnchor035), *Installing and Configuring
    the Kubernetes Cluster*. You will need to apply what we discussed in that chapter
    of the book whenever you’re trying to install a new `minikube` cluster in a virgin
    Linux VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have installed the `minikube` tools, you can start to spin up your
    local cluster using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You may see the following error in your output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The drivers are not healthy ](img/Figure_10.1_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The drivers are not healthy
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first instinct is to choose the correct drive and use the `sudo` command,
    as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you may see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The service account per namespace ](img/Figure_10.2_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The service account per namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output was because of the Docker root privileges issue. The best
    practice is to manage Docker as a non-root user to avoid this issue. In order
    to achieve this, we need to add a user to a group called `docker`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `docker` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add your user to the group called `docker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From here you need to log in again or restart the Docker server so that your
    group membership is re-evaluated. However, we should activate the changes to the
    group by using the following command when we’re on the Linux OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next time, when you log in, use the following command if you want Docker
    to start on boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding steps, you should be able to start `minikube` with the
    Docker driver by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `minikube start` command has created a `minikube` cluster successfully
    if you are able to see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Starting the minikube cluster successfully ](img/Figure_10.3_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Starting the minikube cluster successfully
  prefs: []
  type: TYPE_NORMAL
- en: Although this section is not covered in the CKA exam, it’s highly recommended
    to get familiar with it in case you’re stuck when creating a `minikube` cluster.
    Once you get your `minikube` cluster up and running, we can get into managing
    a `minikube` cluster and troubleshooting RBAC as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a minikube cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to managing a `minikube` cluster, we learned in [*Chapter 6*](B18201_06.xhtml#_idTextAnchor192),
    *Securing Kubernetes*, that we need to set `apiserver --authorization-mode` to
    `RBAC` in order to enable Kubernetes RBAC, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that our current context uses our default `minikube` and then use
    the following commands to create a new deployment in a specific namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding two commands create a namespace called `app`, and a new deployment
    called `rbac-nginx` within the `app` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a new role called `rbac-user` in a namespace called `app` by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to create rolebinding to bind this role to the subjects, as is
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As `rbac-user` only has to list and get permissions for pods, let’s try to
    use this profile for user impersonation to delete the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can learn more about user impersonation from the official documentation
    here: [https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve the issue, we could update the role for `rbac-user` in the YAML
    definition, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the `kubectl auth reconcile` command to create or update a YAML
    manifest file containing RBAC objects. Check the official documentation for more
    information ([https://kubernetes.io/docs/reference/access-authn-authz/rbac/#kubectl-auth-reconcile](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#kubectl-auth-reconcile)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The RBAC issue applies in the use case where different dev teams are sharing
    the cluster resources – as a Kubernetes administrator, you’re likely to access
    the cluster with full permission. Understanding this part will help you better
    govern the permissions among the dev team members for a better standard of security
    and compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18201_07.xhtml#_idTextAnchor235), *Demystifying Kubernetes
    Networking*, we learned that the Kubernetes DNS server creates DNS records (A/AAAA,
    SRV, and PTR records) for services and pods in Kubernetes. Those efforts allow
    you to contact Services with consistent DNS names in place of the IP addresses.
    The Kubernetes DNS server does this by scheduling a few copies of DNS pods and
    services on the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, let’s talk about how to troubleshoot the Kubernetes
    DNS service.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting a Kubernetes DNS server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To troubleshoot the networking of Kubernetes, we start by checking the status
    of the DNS server. Using `minikube` as a local cluster this time, we use the following
    command to check whether the DNS server is up and running on your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that the CoreDNS is up and running in
    our current `minikube` cluster. We can also do this by using the `kubectl get
    deploy core-dns -n kube-system` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get further details, we check out the CoreDNS deployment settings by using
    the `kubectl describe` command, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The minikube CoreDNS configurations ](img/Figure_10.4_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The minikube CoreDNS configurations
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said, the Kubernetes DNS service creates DNS records for services, so
    you contact services with a consistent DNS fully qualified hostnames instead of
    IP addresses. As it is located in the `kube-system` namespace, we can check it
    out by using the following command for our `minikube` cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows, which gives us the cluster IP of `kube-dns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To troubleshoot issues with the DNS server, we can use the `kubectl logs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `kubectl logs` command shows the logs for a `coredns` pod named
    `coredns-64897985d-brqfl` and the output is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The minikube CoreDNS logs ](img/Figure_10.5_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The minikube CoreDNS logs
  prefs: []
  type: TYPE_NORMAL
- en: The output shows whether the DNS server is up or not, and will log abnormal
    events if any exist. Once we know that the DNS server is up, we can take a look
    at how to troubleshoot the services deployed in the Kubernetes cluster in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting a service in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To troubleshoot a service, let’s first deploy a new deployment called `svc-nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that it has been created successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now take a look at exposing a service for the `svc-nginx` deployment.
    We’re using the following command to expose the `NodePort` service of the `nginx`
    pod on port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows that it has been exposed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned from [*Chapter 7*](B18201_07.xhtml#_idTextAnchor235), *Demystifying
    Kubernetes Networking*, we know that we can expect the `nginx-svc` service to
    follow the general service DNS name pattern, which would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s take a look at the services currently in the `app` namespace of
    our Kubernetes cluster by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – A nginx-svc service in the Kubernetes app namespace  ](img/Figure_10.6_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – A nginx-svc service in the Kubernetes app namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding output, we can get a closer look at `nginx-svc` by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – A closer look at the nginx-svc service ](img/Figure_10.7_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – A closer look at the nginx-svc service
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command shows that the IP address of the `nginx-svc` service
    is `10.101.34.154`, so let’s use the `nslookup` command to check out its DNS name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command creates a `busybox` pod in the default namespace. As by
    default, pods in the Kubernetes cluster can talk to each other, we could use a
    `sandbox` pod to test the connectivity to a different namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Returning back the DNS name for nginx-svc  ](img/Figure_10.8_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Returning back the DNS name for nginx-svc
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test the connectivity by using a pod in the same namespace as
    `nginx-svc`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the preceding output, we can see the DNS name for `nginx-svc` is `nginx-svc.app.svc.cluster.local`.
    Now, let’s get the DNS record of the `nginx-svc` service from the `app` namespace
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see that the output is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s test out the connectivity of the `nginx-svc` service. We can use
    the `nginx-beta` deployment to see what’s coming back using `curl`. The complete
    command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Returning the nginx main page  ](img/Figure_10.9_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Returning the nginx main page
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot with 200 responses proves that the connectivity between
    the `nginx-beta` pod and the `nginx-svc` Service is OK, and that we managed to
    use `curl` on the main page of `nginx` with the DNS name of the `nginx` service.
  prefs: []
  type: TYPE_NORMAL
- en: The approach that we discussed in this section works well when we want to quickly
    test the connectivity within the same namespace or to a different namespace. The
    latter would also work in a scenario where the network policy is deployed to restrict
    the connectivity between pods in different namespaces. Now, in the following section,
    let’s take a look at how to get a shell to debug the Kubernetes networking in
    case we need a longer session.
  prefs: []
  type: TYPE_NORMAL
- en: Get a shell for troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the same scenario with the `svc-nginx` deployment in the `app` namespace,
    now let’s use the interactive shell to troubleshoot the networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we find the IP address of `nginx-svc`, `10.101.34.154`, let’s use the
    `nslookup` command to check out its DNS name – use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re now getting into the interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this interactive shell, we log in as root, and we can use `nslookup` or
    another valid command to troubleshoot the networking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – An interactive shell in BusyBox ](img/Figure_10.10_B18201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – An interactive shell in BusyBox
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a handful of commands available in BusyBox, though `curl` isn’t one
    of them. So, let’s now get an `nginx` image with `curl` available. To know what
    the shell commands available in BusyBox are, refer to the following page: [https://hub.docker.com/_/busybox](https://hub.docker.com/_/busybox).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following command to get to the interactive shell of the `nginx`
    pod and find the `nginx` pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it will come back with the full name of the pod that the `svc-nginx`
    deployment created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use the `kubectl exec` command to get the interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will get you the interactive shell access, and then we
    can use the same `curl` command to test the connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique comes in extremely handy in a case where a pod has one or more
    containers. Refer to this article to get more tips: [https://kubernetes.io/docs/tasks/debug/debug-application/get-shell-running-container/](https://kubernetes.io/docs/tasks/debug/debug-application/get-shell-running-container/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered troubleshooting networking – the commands presented
    in this section are references that you can leverage in your real-life debugging
    session. Go back and practice a few times, make sure you get a proper understanding,
    and it will pay off.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered the approaches and use cases for Kubernetes RBAC and
    networking troubleshooting. Together with [*Chapter 8*](B18201_08.xhtml#_idTextAnchor293),
    *Monitoring and Logging Kubernetes Clusters and Applications*, and [*Chapter 9*](B18201_09.xhtml#_idTextAnchor340)*,
    Troubleshooting Cluster Components and Applications*, that covers 30% of the CKA
    content.
  prefs: []
  type: TYPE_NORMAL
- en: To get the most out of this chapter, go back and refer to [*Chapter 6*](B18201_06.xhtml#_idTextAnchor192),
    *Securing Kubernetes*, especially the section on how to enable Kubernetes RBAC,
    and to [*Chapter 7*](B18201_07.xhtml#_idTextAnchor235), *Demystifying Kubernetes*,
    to refresh how to work with Kubernetes DNS. Knowing how to work with Kubernetes
    DNS will help you lay the foundations for understanding other important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you check out the *FAQs* section in all the chapters for further
    references, as well as reading all the recommended documentation and articles.
    A good understanding of these materials will help you become more confident in
    your daily job as a Kubernetes administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Where can I find a comprehensive guide to troubleshooting the Kubernetes services?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the updated documentation within the official Kubernetes documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/tasks/debug/debug-application/debug-service/](https://kubernetes.io/docs/tasks/debug/debug-application/debug-service/)'
  prefs: []
  type: TYPE_NORMAL
- en: Also highly recommended is focusing on this chapter together with [*Chapter
    9*](B18201_09.xhtml#_idTextAnchor340), *Troubleshooting Cluster Components and
    Applications*, as a complementary resource. This will help you gather a full view
    of the Kubernetes troubleshooting story.
  prefs: []
  type: TYPE_NORMAL
- en: '*Where can I find a comprehensive guide to Kubernetes networking?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18201_07.xhtml#_idTextAnchor235) of this book, *Demystifying
    Kubernetes Networking*, touches upon most of the Kubernetes networking concepts,
    as well as troubleshooting examples – together with this chapter, this will help
    you work confidently on questions that could appear in the actual CKA exam. You
    can also bookmark the following article from the official Kubernetes documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/concepts/cluster-administration/networking/](https://kubernetes.io/docs/concepts/cluster-administration/networking/)'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix - Mock CKA scenario-based practice test resolutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B18201_02.xhtml#_idTextAnchor035) – Installing and Configuring
    Kubernetes Clusters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have two virtual machines: `master-0` and `worker-0`. Please complete the
    following mock scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install the latest version of `kubeadm` , then create a basic kubeadm cluster
    on the `master-0` node, and get the node information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `apt package index`, add a Google Cloud public signing key, and
    set up the Kubernetes apt repository by running the following instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by updating the apt package index, then install `kubelet` and `kubeadm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, if you haven’t installed `kubectl` yet, you can also install
    `kubelet`, `kubeadm`, and `kubectl` in one go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to pin the version of the utilities you’re installing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the `kubeadm init` command to initialize the control-plane like
    a regular user, and gain sudo privileges from your master node machine by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After your Kubernetes control-plane is initialized successfully, you can execute
    the following commands to configure `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Scenario 2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0` and join it to the `master-0` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to join the worker nodes to the Kubernetes
    cluster. This command can be used repeatedly each time you have new worker nodes
    to join with the token that you acquired from the output of the `kubeadm` control-plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 3 (optional)**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up a local minikube cluster, and schedule your first workload called `hello
    Packt`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Check out the *Installing and configuring Kubernetes cluster* section in [*Chapter
    2*](B18201_02.xhtml#_idTextAnchor035), to set up a single node minikube cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly run an app on the cluster called `helloPackt` using `busybox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[*Chapter 3*](B18201_03.xhtml#_idTextAnchor059) – Maintaining Kubernetes Clusters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have two virtual machines: `master-0` and `worker-0`. Please complete the
    following mock scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to the `master-0` node, check the current `kubeadm` version, and upgrade
    to the latest `kubeadm` version. Check the current `kubectl` version, and upgrade
    to the latest `kubectl` version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by checking the current version with the following commands once we’re
    in the master node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the latest available versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Upgrade the `kubeadm` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if your cluster can be upgraded, and the available versions that your
    cluster can be upgraded to by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to upgrade the `kubeadm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0` node, check the current `kubeadm` version, and upgrade to
    the latest `kubeadm` version. Check the current `kubelet` version, and upgrade
    to the latest `kubelet` version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by checking the current version with the following commands once we’re
    in the master node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Check what the latest versions available are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Upgrade the `kubelet` (which also upgrades the local `kubelet` configuration)
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Cordon the node so that we drain the workloads of preparing the node for maintenance
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Upgrade the `kubeadm` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if your cluster can be upgraded and the available versions that your
    cluster can be upgraded to by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to upgrade the `kubeadm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the `kubelet` for the changes to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can uncordon the worker node and it will return the node that is
    now shown as `uncordoned`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to the `master-0` node, and backup the `etcd` store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check the endpoint status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to backup `etcd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to the `master-0` node, and restore the `etcd` store to the previous backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore the `etcd` from a previous backup operation using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[*Chapter 4*](B18201_04.xhtml#_idTextAnchor080) – Application scheduling and
    lifecycle management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have two virtual machines: `master-0` and `worker-0`, please complete the
    following mock scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to the `worker-0` node, and provision a new pod called `ngnix` with a single
    container nginx.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0`, and then scale the `nginx` to 5 copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0`, set a `configMap` with a username and password, then attach
    a new pod with a busybox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a yaml definition called `packt-cm.yaml` to define `ConfigMap` as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy the yaml manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the `configMap` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have `configMap` ready, create a yaml definition file to config the
    pod to consume the `configMap` as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to verify the `configMap` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0`, and create a nginx pod with an `initContainer` called `busybox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a yaml definition called `packt-pod.yaml` shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy the yaml manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH to `worker-0`, and create a nginx pod and then a busybox container in the
    same pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a yaml definition called `packt-pod.yaml` shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy the yaml manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[*Chapter 5*](B18201_05.xhtml#_idTextAnchor149) – Demystifying Kubernetes Storage'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have two virtual machines: `master-0` and `worker-0`. Please complete the
    following mock scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new PV called `packt-data-pv` with a storage of 2GB, and two persistent
    volume claims (PVCs) requiring 1GB local storage each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a yaml definition called `packt-data-pv.yaml` for persistent volume
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy the yaml manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a yaml definition called `packt-data-pvc1.yaml` for persistent volume
    claim as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a yaml definition called `packt-data-pvc2.yaml` for persistent volume
    claim as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy the yaml manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Provision a new pod called `packt-storage-pod`, and assign an available PV to
    this pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a yaml definition called `packt-data-pod.yaml` shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy the yaml manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to see if the pod is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[*Chapter 6*](B18201_06.xhtml#_idTextAnchor192) – Securing Kubernetes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have two virtual machines: `master-0` and `worker-0`, please complete the
    following mock scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new service account named `packt-sa` in a new namespace called `packt-ns`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create a new service account in the targeting
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Role named `packt-role` and bind it with the RoleBinding `packt-rolebinding`.
    Map the `packt-sa` service account with `list` and `get` permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create a cluster role in the targeting namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to create a Role binding in the targeting namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve the same result, you can create a yamldefinition called `packt-role.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another yaml definition called `packt-pods-binding.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy the yaml manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the Role using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the rolebindings by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new pod named packt-pod with the `image busybox:1.28` in the namespace
    packt-ns. Expose port `80`. Then assign the service account `packt-sa` to the
    pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create a deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Export the deployment information in yaml specification form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the yaml specification to reference the service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Check out the *Implementing Kubernetes RBAC* section in [*Chapter 6*](B18201_06.xhtml#_idTextAnchor192)*,
    Securing Kubernetes* to get further information about how to implement RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18201_07.xhtml#_idTextAnchor235) – Demystifying Kubernetes networking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have two virtual machines: `master-0` and `worker-0`. Please complete the
    following mock scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploy a new deployment nginx with the latest image of nginx for 2 replicas,
    in a namespace called `packt-app`. The container is exposed on port `80`. Create
    a service type ClusterIP within the same namespace. Deploy a sandbox-nginx pod
    and make a call using `curl` to verify the connectivity to the nginx service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create nginx deployment in the targeting namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to expose nginx deployment with a ClusterIP service
    in the targeting namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to get the internal IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to get the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy a `sandbox-nginx` pod in the targeting
    namespace using your endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expose the nginx deployment with the NodePort service type; the container is
    exposed on port `80`. Use the test-nginx pod to make a call using `curl` to verify
    the connectivity to the nginx service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to create nginx deployment in the targeting namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to get the internal IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to get the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to deploy a test-nginx pod in the targeting namespace
    using your endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make a call using `wget` or `curl` from the machine within the same network
    with that node, to verify the connectivity with the nginx NodePort service through
    the correct port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call from `worker-2` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `wget` as the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the sandbox-nginx pod to `nslookup` the IP address of nginx NodePort service.
    See what is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the sandbox-nginx pod to `nslookup` the DNS domain hostname of nginx NodePort
    service. See what is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Scenario 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the sandbox-nginx pod to `nslookup` the DNS domain hostname of nginx pod.
    See what is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[*Chapter 8*](B18201_08.xhtml#_idTextAnchor293) – Monitoring and logging Kubernetes
    Clusters and Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have two virtual machines: `master-0` and `worker-0`. Please complete the
    following mock scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List all the available pods in your current cluster and find what the most CPU-consuming
    pods are. Write the name to the `max-cpu.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
