- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Creating and Implementing Updates on a Multi-Node Raspberry Pi Kubernetes Clusters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多节点树莓派Kubernetes集群中创建和实施更新
- en: Companies are embracing digital transformation, Industry 4.0, industrial automation,
    smart manufacturing, and all the advanced use cases that these initiatives provide,
    as we saw in the previous chapter. As a result, the importance of Kubernetes,
    edge, and cloud collaboration to drive intelligent business decisions is becoming
    clear. Kubernetes is steadily becoming the go-to platform for edge computing and
    extends the benefits of cloud-native technologies to the edge, allowing for the
    flexible and automated management of applications that span a disaggregated cloud
    environment. In this and the following chapters, we will be looking at implementation
    aspects of common edge computing applications using the MicroK8s Kubernetes platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，公司正在拥抱数字化转型、工业4.0、工业自动化、智能制造以及这些举措所带来的所有先进应用场景。因此，Kubernetes、边缘计算和云计算的协同作用，推动智能商业决策的重要性变得越来越明显。Kubernetes正稳步成为边缘计算的首选平台，并将云原生技术的优势扩展到边缘，从而实现跨分散云环境的应用灵活和自动化管理。在本章及随后的章节中，我们将探讨使用MicroK8s
    Kubernetes平台实现常见边缘计算应用的各个方面。
- en: 'Reiterating the points that we discussed in the previous chapter, **Canonical
    MicroK8s** ([https://microk8s.io/](https://microk8s.io/)) is a powerful, **Cloud
    Native Computing Foundation** (**CNCF**)-certified Kubernetes distribution. Here
    are some of the key reasons why it has become a powerful enterprise computing
    platform:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 重申我们在上一章讨论的要点，**Canonical MicroK8s**（[https://microk8s.io/](https://microk8s.io/)）是一个功能强大的、**Cloud
    Native Computing Foundation**（**CNCF**）认证的Kubernetes发行版。以下是它成为一个强大企业计算平台的一些关键原因：
- en: '**Delivered as a snap package**: These are application packages for desktop,
    cloud, and even **Internet of Things** (**IoT**) devices that are simple to install,
    secured with auto-updates, and can be deployed on any Linux distributions that
    support snaps.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以Snap包形式交付**：这些是适用于桌面、云，甚至**物联网**（**IoT**）设备的应用包，安装简单，自动更新且安全，并且可以部署在任何支持Snap的Linux发行版上。'
- en: '**Strict confinement**: This ensures complete isolation from the underlying
    **operating system** (**OS**) as well as a highly secure Kubernetes environment
    fit for production.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严格限制**：这确保了与底层**操作系统**（**OS**）的完全隔离，并提供一个高度安全的Kubernetes生产环境。'
- en: '**Production-grade add-ons**: Add-ons such as Istio, Knative, CoreDNS, Prometheus,
    Jaeger, Linkerd, Cilium, and Helm are available. They are straightforward to set
    up, requiring only a few lines of commands. For better **artificial intelligence**
    (**AI**) and **machine learning** (**ML**) capabilities, Kubeflow is also available
    as an add-on to MicroK8s.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产级附加组件**：如Istio、Knative、CoreDNS、Prometheus、Jaeger、Linkerd、Cilium和Helm等附加组件均可用。这些附加组件易于设置，仅需几行命令。为了更好的**人工智能**（**AI**）和**机器学习**（**ML**）能力，Kubeflow也可以作为MicroK8s的附加组件提供。'
- en: '**Automatic, autonomous, and self-healing high availability (HA)**: For clusters
    of three or more Nodes, MicroK8s automatically activates HA. With no administrative
    intervention, MicroK8s provides resilient and self-healing HA.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化、自治、自愈的高可用性（HA）**：对于三个或更多节点的集群，MicroK8s会自动启用高可用性。无需管理员干预，MicroK8s提供具有弹性和自愈能力的高可用性。'
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Creating a MicroK8s multi-node cluster using a Raspberry Pi
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用树莓派创建一个MicroK8s多节点集群
- en: Deploying a sample containerized application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个示例容器化应用程序
- en: Performing rolling updates to the application with a new software version
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新软件版本执行滚动更新
- en: Scaling the application deployment
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展应用部署
- en: Guidelines on multi-node cluster configuration
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多节点集群配置指南
- en: Container life cycle management
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器生命周期管理
- en: Deploying and sharing HA applications
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和共享高可用性应用
- en: Creating a MicroK8s multi-node cluster using a Raspberry Pi
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用树莓派创建一个MicroK8s多节点集群
- en: 'Before we delve into the steps on how to create a MicroK8s multi-node cluster,
    let''s recap the key concepts of Kubernetes that we covered earlier, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解如何创建MicroK8s多节点集群的步骤之前，让我们回顾一下之前所讨论的Kubernetes关键概念，如下所示：
- en: 'A **Kubernetes cluster** (like the one shown in *Figure 5.1*) would have the
    following two types of resources:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**Kubernetes集群**（如*图5.1*所示）将包含以下两种类型的资源：
- en: a. A **control plane** that controls the cluster
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个**控制平面**，用于控制集群
- en: b. **Nodes**—the worker Nodes that run applications
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: b. **节点**—运行应用程序的工作节点
- en: All actions in the cluster are coordinated by the control plane, including scheduling
    applications, maintaining the intended state of applications, scaling applications,
    and rolling out new updates, among other things. Each node can be a **virtual
    machine** (**VM**) or a physical computer that serves as a worker machine in a
    cluster.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集群中的所有操作由控制平面协调，包括调度应用程序、保持应用程序的预期状态、扩展应用程序和发布新更新等。每个节点可以是**虚拟机**（**VM**）或作为集群中工作机器的物理计算机。
- en: 'A **Kubernetes control plane** is a collection of three processes: an **application
    programming interface (API) server**, a **controller manager**, and a **scheduler**.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Kubernetes控制平面**是由三个进程组成的：**应用程序编程接口（API）服务器**、**控制器管理器**和**调度器**。'
- en: Each individual non-control plane node on the cluster has a **kubelet** process
    that takes care of the communication with the Kubernetes control plane, the **kube-proxy**
    process for all network communications, and a **container runtime** such as Docker.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集群中每个非控制平面节点都有一个**kubelet**进程，负责与Kubernetes控制平面通信，**kube-proxy**进程负责所有网络通信，并且有一个如Docker的**容器运行时**。
- en: The control plane issues a command to start the application containers when
    any applications need to be deployed on Kubernetes. Containers are scheduled to
    run on the cluster's Nodes by the control plane.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当需要在Kubernetes上部署应用程序时，控制平面会发出命令启动应用程序容器。容器由控制平面调度到集群的节点上运行。
- en: The Nodes communicate with the control plane using the Kubernetes API, which
    the control plane exposes.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点通过控制平面暴露的Kubernetes API与控制平面进行通信。
- en: 'A typical Kubernetes architecture, system, and abstractions are shown in the
    following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图所示的是典型的Kubernetes架构、系统和抽象：
- en: '![Figure 5.1 – Kubernetes system and abstractions ](img/Figure_5.1_B18115.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Kubernetes 系统和抽象](img/Figure_5.1_B18115.jpg)'
- en: Figure 5.1 – Kubernetes system and abstractions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Kubernetes 系统和抽象
- en: Now that we are clear on the Kubernetes architecture, system, and abstractions,
    we will delve into the steps of creating a Kubernetes Raspberry Pi multi-node
    cluster.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚了Kubernetes架构、系统和抽象，接下来我们将深入了解创建Kubernetes Raspberry Pi多节点集群的步骤。
- en: What we are trying to achieve
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们要实现的目标
- en: 'We''ll list down the steps that we''re seeking to accomplish in this section.
    Prepare Raspberry Pi 4 boards for MicroK8s installation by doing the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将列出我们要实现的步骤。通过以下步骤为MicroK8s安装准备Raspberry Pi 4板：
- en: Installing and configuring MicroK8s on each of the boards
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个板上安装和配置MicroK8s
- en: Adding Nodes to the cluster
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向集群中添加节点
- en: Joining multiple deployments to form a two-node cluster (one control plane node/one
    worker node)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多个部署合并形成一个两节点集群（一个控制平面节点/一个工作节点）
- en: 'The Raspberry Pi cluster that we will build in this step is depicted in the
    following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这一步构建的Raspberry Pi集群如以下图所示：
- en: '![Figure 5.2 – What we are trying to achieve ](img/Figure_5.2_B18115.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 我们要实现的目标](img/Figure_5.2_B18115.jpg)'
- en: Figure 5.2 – What we are trying to achieve
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 我们要实现的目标
- en: Now that we know what we want to do, let's look at the requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道要做什么，让我们来看一下要求。
- en: 'Before you begin, here are the prerequisites for building a Raspberry Pi Kubernetes
    cluster:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，以下是构建Raspberry Pi Kubernetes集群的先决条件：
- en: A microSD card (4 **gigabytes** (**GB**) minimum; 8 GB recommended)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张microSD卡（最低4 **GB**；推荐8 GB）
- en: A computer with a microSD card drive
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台带有microSD卡驱动器的计算机
- en: A Raspberry Pi 2, 3, or 4 (one or more)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Raspberry Pi 2、3或4（一个或多个）
- en: A **micro-Universal Serial Bus** (**micro-USB**) power cable (USB-C for the
    Pi 4)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根**微型通用串行总线**（**micro-USB**）电源线（Pi 4使用USB-C）
- en: A Wi-Fi network or an Ethernet cable with an internet connection
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张连接互联网的Wi-Fi网络或以太网电缆
- en: (Optional) A monitor with a **High-Definition Multimedia Interface** (**HDMI**)
    interface
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）带有**高清多媒体接口**（**HDMI**）接口的显示器
- en: (Optional) An HDMI cable for the Pi 2 and 3 and a micro-HDMI cable for the Pi
    4
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）Pi 2 和 3 的 HDMI 电缆，以及 Pi 4 的微 HDMI 电缆
- en: (Optional) A USB keyboard
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）USB键盘
- en: Now that we've established the requirements, we'll go on to the step-by-step
    instructions on how to complete the process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经明确了要求，接下来将按照步骤说明完成整个过程。
- en: '**Step 1a**: **Installing OS image onto SD card**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1a**：**将操作系统镜像安装到SD卡**'
- en: 'The first step is to install an OS image onto the microSD card. To do that,
    we will be using the **Raspberry Pi Imager tool**, as shown in the following screenshot,
    to install an OS image to a microSD card that can then be used with Raspberry
    Pi:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将操作系统镜像安装到microSD卡中。为此，我们将使用**Raspberry Pi Imager工具**，如下面的截图所示，将操作系统镜像安装到microSD卡，然后可以用在Raspberry
    Pi上：
- en: '![Figure 5.3 – Raspberry Pi Imager ](img/Figure_5.3_B18115.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – Raspberry Pi Imager](img/Figure_5.3_B18115.jpg)'
- en: Figure 5.3 – Raspberry Pi Imager
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – Raspberry Pi Imager
- en: Download and install **Raspberry Pi Imager** from the Raspberry Pi website on
    a computer equipped with a **Secure Digital** (**SD**) card reader. Run Raspberry
    Pi Imager with the microSD card you'll be using and open the **CHOOSE OS** menu.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从Raspberry Pi网站下载并安装**Raspberry Pi Imager**，在配备**Secure Digital**（**SD**）卡读卡器的计算机上运行Raspberry
    Pi Imager，插入您将使用的microSD卡，并打开**选择操作系统（CHOOSE OS）**菜单。
- en: 'Choose **Other general purpose OS** from the options listed, as illustrated
    in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从列出的选项中选择**其他通用操作系统（Other general purpose OS）**，如下图所示：
- en: '![Figure 5.4 – Raspberry Pi Imager OS options ](img/Figure_5.4_B18115.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – Raspberry Pi Imager操作系统选项](img/Figure_5.4_B18115.jpg)'
- en: Figure 5.4 – Raspberry Pi Imager OS options
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – Raspberry Pi Imager操作系统选项
- en: 'Choose any of the **Ubuntu Server** 64-bit versions that work with Raspberry
    Pi 2, 3, 3+, and 4 from the options listed, as illustrated in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从列出的选项中选择任何适用于Raspberry Pi 2、3、3+和4的**Ubuntu Server** 64位版本，如下图所示：
- en: '![Figure 5.5 – Choosing any Ubuntu Server version that works with Raspberry
    Pi Imager 2/3/4 ](img/Figure_5.5_B18115.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 选择适用于Raspberry Pi Imager 2/3/4的任何Ubuntu Server版本](img/Figure_5.5_B18115.jpg)'
- en: Figure 5.5 – Choosing any Ubuntu Server version that works with Raspberry Pi
    Imager 2/3/4
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 选择适用于Raspberry Pi Imager 2/3/4的任何Ubuntu Server版本
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MicroK8s is only available for 64-bit Ubuntu images.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MicroK8s仅适用于64位Ubuntu镜像。
- en: Open the **SD Card** menu after selecting an image. Choose the microSD card
    that you've inserted. Click **WRITE** to start the operation and Raspberry Pi
    Imager will wipe your microSD card data. You will be prompted to confirm this
    procedure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 选择镜像后，打开**SD卡**菜单。选择您插入的microSD卡。点击**写入（WRITE）**开始操作，Raspberry Pi Imager将清除您的microSD卡数据。系统会提示您确认此过程。
- en: 'The process is illustrated in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程如下面的截图所示：
- en: '![Figure 5.6 – Raspberry Pi Imager write operation ](img/Figure_5.6_B18115.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – Raspberry Pi Imager写入操作](img/Figure_5.6_B18115.jpg)'
- en: Figure 5.6 – Raspberry Pi Imager write operation
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – Raspberry Pi Imager写入操作
- en: 'Post confirmation, Raspberry Pi Imager will start flashing OS images to the
    microSD card. It will take a while to finish. The message that displays once finished
    is illustrated in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 确认后，Raspberry Pi Imager将开始将操作系统镜像写入microSD卡。完成需要一些时间。完成后显示的消息如下图所示：
- en: '![Figure 5.7 – Raspberry Pi Imager: write operation completed ](img/Figure_5.7_B18115.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – Raspberry Pi Imager：写入操作完成](img/Figure_5.7_B18115.jpg)'
- en: 'Figure 5.7 – Raspberry Pi Imager: write operation completed'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – Raspberry Pi Imager：写入操作完成
- en: Once finished, continue with the configuration of Wi-Fi access, remote access,
    control groups, and hostname settings.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，继续配置Wi-Fi访问、远程访问、控制组和主机名设置。
- en: Configuring Wi-Fi access settings
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Wi-Fi访问设置
- en: 'Open a file manager—as shown in the following screenshot—while the SD card
    is still inserted in your laptop, and look for the `system-boot` partition on
    the card. It holds the initial configuration files that are loaded during the
    first boot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件管理器——如下面的截图所示——在SD卡仍然插入笔记本电脑时，查找卡上的`system-boot`分区。该分区包含在第一次启动时加载的初始配置文件：
- en: '![Figure 5.8 – Configuring Wi-Fi access settings ](img/Figure_5.8_B18115.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 配置Wi-Fi访问设置](img/Figure_5.8_B18115.jpg)'
- en: Figure 5.8 – Configuring Wi-Fi access settings
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 配置Wi-Fi访问设置
- en: 'Modify the `network-config` file to include your Wi-Fi credentials. Here is
    an example of Wi-Fi configuration:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`network-config`文件，加入您的Wi-Fi凭证。以下是Wi-Fi配置的示例：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've finished configuring Wi-Fi access and are ready to go on to the next step.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了Wi-Fi访问的配置，并准备进入下一步。
- en: '**Step 1b**: **Configuring remote access settings**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1b**：**配置远程访问设置**'
- en: By default, the `system-boot` partition on the card and create an empty file
    named `ssh` without a file extension. During the boot process, it will automatically
    prepare and set up SSH on your Raspberry Pi if it detects this file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，卡上的 `system-boot` 分区创建一个名为 `ssh` 的空文件，且没有文件扩展名。在启动过程中，如果检测到此文件，它将自动准备并设置树莓派上的
    SSH。
- en: We've finished configuring remote access and are ready to go on to the next
    step of configuring control groups.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了远程访问配置，准备进入下一步的控制组配置。
- en: '**Step 1c**: **Configuring control group settings**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1c**：**配置控制组设置**'
- en: By default, control groups are disabled. Control groups (abbreviated as **cgroups**)
    are a Linux kernel feature that limits, accounts for, and isolates the resource
    usage (**central processing unit** (**CPU**), memory, disk **input/output** (**I/O**),
    network, and so on) of a collection of processes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制组被禁用。控制组（缩写为**cgroups**）是一个 Linux 内核特性，用于限制、统计和隔离一组进程的资源使用情况（**中央处理单元**（**CPU**）、内存、磁盘
    **输入/输出**（**I/O**）、网络等）。
- en: 'Open the configuration file located at `/boot/firmware/cmdline.txt` on the
    card and add the following options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于卡上的配置文件 `/boot/firmware/cmdline.txt`，并添加以下选项：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A full line would look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的命令行应该像这样：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the file, extract the card from your laptop, and insert it into the Raspberry
    Pi. Before powering the Pi, connect an HDMI screen and a USB keyboard. Power on
    the Pi, and you will be able to see the boot process on the screen. It typically
    takes less than 2 minutes to complete the booting process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，从笔记本中取出卡片，并将其插入树莓派。在为树莓派供电之前，连接一个 HDMI 屏幕和一个 USB 键盘。打开树莓派电源，你将能够在屏幕上看到启动过程。通常启动过程会在
    2 分钟内完成。
- en: 'Once the boot is finished, connect to your Raspberry Pi using any SSH client
    (for example, `putty`), and continue the following configuration:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 启动完成后，使用任何 SSH 客户端（例如 `putty`）连接到你的树莓派，并继续以下配置：
- en: '![Figure 5.9 – PuTTY SSH client ](img/Figure_5.10_B18115.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – PuTTY SSH 客户端](img/Figure_5.10_B18115.jpg)'
- en: Figure 5.9 – PuTTY SSH client
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – PuTTY SSH 客户端
- en: 'Type in the IP address of the Raspberry Pi and click **Open** to connect. On
    the first connect, you will be asked to confirm the connection: click **Accept**
    to confirm.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输入树莓派的 IP 地址并点击 **Open** 进行连接。首次连接时，系统会要求你确认连接：点击 **Accept** 确认。
- en: On the login page, type `ubuntu` as both the username and the password. Ubuntu
    will ask you to change your password to something else. After that, use the `ssh`
    command and the new password to reconnect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录页面，输入 `ubuntu` 作为用户名和密码。Ubuntu 会要求你将密码更改为其他内容。之后，使用 `ssh` 命令和新密码重新连接。
- en: '*Success! You are now connected to Ubuntu Server running on your Raspberry
    Pi.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*成功！你现在已连接到运行在树莓派上的 Ubuntu Server*。'
- en: We've finished configuring most of the settings and are ready to go on to the
    next step of hostname configuration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了大部分设置，准备进入下一步的主机名配置。
- en: '**Step 1d**: **Configuring hostname**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1d**：**配置主机名**'
- en: For Ubuntu OS, by default, the hostname would be `ubuntu`, but since we need
    different hostnames to be identified in the cluster, we would need to change this
    based on our needs. For the cluster we are creating, I'm going to name one of
    the Nodes `controlplane` and the others `WorkerXX`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ubuntu 操作系统，默认情况下，主机名为 `ubuntu`，但由于我们需要在集群中识别不同的主机名，因此需要根据需要进行更改。对于我们正在创建的集群，我将把一个节点命名为
    `controlplane`，其他的命名为 `WorkerXX`。
- en: Follow the next steps to change the hostname.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤更改主机名。
- en: 'From the `putty` shell, enter the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `putty` Shell 中，输入以下命令：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Modify the hostname and exit the `nano` editor using *Ctrl* + *X*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 修改主机名并使用 *Ctrl* + *X* 退出 `nano` 编辑器。
- en: Type `sudo reboot` for changes to take effect.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `sudo reboot` 以使更改生效。
- en: '*Congratulations! You have now completed all the configurations for your Raspberry
    Pi*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*恭喜！你现在已经完成了树莓派的所有配置*。'
- en: '*Steps 1a* to *1d* must be repeated for all the Raspberry Pis in the cluster.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1a* 到 *1d* 必须为集群中的所有树莓派重复执行。'
- en: 'Post successful boot, ensure your packages are updated to the latest version,
    and run the following commands:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 系统启动成功后，确保你的包已更新到最新版本，并运行以下命令：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've finished configuring all the settings for all the Raspberry Pis on the
    cluster and are ready to go on to the next step of installation and configuration
    of MicroK8s.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了集群中所有树莓派的设置，并准备进入下一步的 MicroK8s 安装和配置。
- en: Installing and configuring MicroK8s
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 MicroK8s
- en: 'SSH into your control plane node and install the MicroK8s snap, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 连接到控制平面节点并安装 MicroK8s snap，如下所示：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following command execution output confirms that the MicroK8s snap has
    been installed successfully:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出确认 MicroK8s snap 已成功安装：
- en: '![Figure 5.10 – MicroK8s snap installation successful ](img/Figure_5.11_B18115.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – MicroK8s snap 安装成功](img/Figure_5.11_B18115.jpg)'
- en: Figure 5.10 – MicroK8s snap installation successful
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – MicroK8s snap 安装成功
- en: 'Now that we have installed the MicroK8s snap, type the `microk8s status` command
    to verify its running state, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 MicroK8s snap，输入 `microk8s status` 命令以验证其运行状态，如下所示：
- en: '![Figure 5.11 – Verifying whether MicroK8s is running ](img/Figure_5.12_B18115.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 验证 MicroK8s 是否正在运行](img/Figure_5.12_B18115.jpg)'
- en: Figure 5.11 – Verifying whether MicroK8s is running
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 验证 MicroK8s 是否正在运行
- en: 'As indicated in the preceding command execution output, join the user in the
    MicroK8s group and gain access to a `.kube` caching directory using the following
    set of commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的命令执行输出所示，使用以下一组命令将用户加入 MicroK8s 组并访问 `.kube` 缓存目录：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Retype the `microk8s status` command to verify whether it''s running. The following
    command execution output confirms that MicroK8s is running successfully:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重新输入 `microk8s status` 命令以验证它是否正在运行。以下命令执行输出确认 MicroK8s 正在成功运行：
- en: '![Figure 5.12 – MicroK8s is running ](img/Figure_5.13_B18115.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – MicroK8s 正在运行](img/Figure_5.13_B18115.jpg)'
- en: Figure 5.12 – MicroK8s is running
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – MicroK8s 正在运行
- en: 'Now that we have installed MicroK8s, the next step is to create a `kubectl`
    alias with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已安装了 MicroK8s，接下来的步骤是使用以下命令创建一个 `kubectl` 别名：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following command execution output confirms that an alias has been added
    successfully:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出确认别名已成功添加：
- en: '![Figure 5.13 – kubectl alias successfully added ](img/Figure_5.14_B18115.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – kubectl 别名已成功添加](img/Figure_5.14_B18115.jpg)'
- en: Figure 5.13 – kubectl alias successfully added
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – kubectl 别名已成功添加
- en: 'If the installation has been successful, you should then see the following
    output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，你应该会看到以下输出：
- en: '![Figure 5.14 – Verifying whether the node is in a Ready state ](img/Figure_5.15_B18115.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 验证节点是否处于 Ready 状态](img/Figure_5.15_B18115.jpg)'
- en: Figure 5.14 – Verifying whether the node is in a Ready state
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 验证节点是否处于 Ready 状态
- en: Repeat the MicroK8s installation process on the other Nodes as well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他节点上也重复进行 MicroK8s 安装过程。
- en: 'Here is the command execution output of the MicroK8s installation on the worker
    node:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 worker 节点上 MicroK8s 安装的命令执行输出：
- en: '![Figure 5.15 – MicroK8s snap installation on worker1 node successful ](img/Figure_5.16_B18115.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – MicroK8s snap 在 worker1 节点安装成功](img/Figure_5.16_B18115.jpg)'
- en: Figure 5.15 – MicroK8s snap installation on worker1 node successful
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – MicroK8s snap 在 worker1 节点安装成功
- en: 'The following command execution output confirms that MicroK8s is running successfully
    on the worker node as well:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出确认 MicroK8s 在 worker 节点上也成功运行：
- en: '![Figure 5.16 – Verifying whether MicroK8s is running ](img/Figure_5.17_B18115.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 验证 MicroK8s 是否正在运行](img/Figure_5.17_B18115.jpg)'
- en: Figure 5.16 – Verifying whether MicroK8s is running
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 验证 MicroK8s 是否正在运行
- en: 'Now that MicroK8s is running, the next step is to check whether the `kubectl
    get Nodes` command displays the node in a `Ready` state, as indicated in the following
    command execution output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 MicroK8s 正在运行，接下来的步骤是检查 `kubectl get Nodes` 命令是否显示节点处于 `Ready` 状态，正如以下命令执行输出所示：
- en: '![Figure 5.17 – Verifying whether the node is in a Ready state ](img/Figure_5.18_B18115.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 验证节点是否处于 Ready 状态](img/Figure_5.18_B18115.jpg)'
- en: Figure 5.17 – Verifying whether the node is in a Ready state
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 验证节点是否处于 Ready 状态
- en: 'We have completed the installation of MicroK8s on all boards. The next step
    is to add a worker node to the control plane node. Open the `putty` shell to the
    control plane node and run the following command to generate a connection string:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在所有节点上完成了 MicroK8s 的安装。接下来的步骤是将 worker 节点添加到控制平面节点。打开 `putty` shell 连接到控制平面节点，并运行以下命令生成连接字符串：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following command execution output validates that the command was successfully
    executed and provides instructions for the connection string:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出验证命令已成功执行，并提供连接字符串的说明：
- en: '![Figure 5.18 – Generating connection string for adding Nodes ](img/Figure_5.19_B18115.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 生成连接字符串以添加节点](img/Figure_5.19_B18115.jpg)'
- en: Figure 5.18 – Generating connection string for adding Nodes
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 生成添加节点的连接字符串
- en: As indicated by the preceding command execution output, a connection string
    is generated in the form of `<control plane_ip>:<port>/<token>`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的命令执行输出所示，生成了格式为 `<control plane_ip>:<port>/<token>` 的连接字符串。
- en: Adding the worker node
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加工作节点
- en: 'We now have the connection string to join with the control plane node. Open
    the `putty` shell to the worker node and run the `join` command to add it to the
    cluster, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了连接字符串，可以与控制平面节点进行连接。打开 `putty` 终端到工作节点，并运行 `join` 命令将其加入集群，如下所示：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The command was successfully executed, and the node has joined the cluster,
    as shown in the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 命令已成功执行，节点已加入集群，如下所示的输出所示：
- en: '![Figure 5.19 – Adding worker1 node to the cluster ](img/Figure_5.20_B18115.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19 – 将 worker1 节点添加到集群](img/Figure_5.20_B18115.jpg)'
- en: Figure 5.19 – Adding worker1 node to the cluster
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 将 worker1 节点添加到集群
- en: As indicated by the preceding command execution output, you should be able to
    see the new node in a few seconds on the control plane.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的命令执行输出所示，您应该能在几秒钟内在控制平面看到新节点。
- en: 'Use the following command to verify whether the new node has been added to
    the cluster:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证新节点是否已添加到集群：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following command execution output shows that `controlplane` and `worker1`
    are part of the cluster:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出显示，`controlplane` 和 `worker1` 是集群的一部分：
- en: '![Figure 5.20 – Cluster is ready; controlplane and worker1 are part of the
    cluster ](img/Figure_5.21_B18115.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20 – 集群已准备好；controlplane 和 worker1 是集群的一部分](img/Figure_5.21_B18115.jpg)'
- en: Figure 5.20 – Cluster is ready; controlplane and worker1 are part of the cluster
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 集群已准备好；controlplane 和 worker1 是集群的一部分
- en: 'The completed cluster should resemble the one as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的集群应类似于这里所示的：
- en: '![Figure 5.21 – Our cluster is ready ](img/Figure_5.22_B18115.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21 – 我们的集群已准备就绪](img/Figure_5.22_B18115.jpg)'
- en: Figure 5.21 – Our cluster is ready
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 我们的集群已准备就绪
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to remove a node from the cluster, run the following command on
    the control plane: `sudo microk8s remove-node <node name>`. Alternatively, you
    can leave the cluster from the worker node by running `sudo microk8s.leave`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从集群中移除一个节点，可以在控制平面运行以下命令：`sudo microk8s remove-node <node name>`。或者，您可以通过在工作节点运行
    `sudo microk8s.leave` 来离开集群。
- en: At this point, you have a fully functional multi-node Kubernetes cluster. To
    summarize, we have installed MicroK8s on the Raspberry Pi boards and joined multiple
    deployments to form the cluster. We've seen how to add Nodes to the cluster as
    well. In the next section, we are going to deploy a sample application on the
    MicroK8s cluster we just created.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经拥有一个完全功能的多节点 Kubernetes 集群。总结一下，我们已经在 Raspberry Pi 板上安装了 MicroK8s，并将多个部署加入到集群中。我们还展示了如何向集群添加节点。接下来的部分，我们将把一个示例应用程序部署到刚刚创建的
    MicroK8s 集群中。
- en: Deploying a sample containerized application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署示例容器化应用程序
- en: 'In this section, we will be deploying the following nginx deployment from the
    Kubernetes examples repository on our multi-node MicroK8s cluster setup:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将部署来自 Kubernetes 示例仓库的以下 nginx 部署到我们的多节点 MicroK8s 集群：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following command will deploy the previous sample application deployment:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将部署前面提到的示例应用程序：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following command execution output indicates that there is no error in
    the deployment, and in the next step, we can verify this using the `describe`
    command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明部署没有错误，接下来的步骤我们可以使用 `describe` 命令来验证：
- en: '![Figure 5.22 – Sample application deployment ](img/Figure_5.23_B18115.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22 – 示例应用程序部署](img/Figure_5.23_B18115.jpg)'
- en: Figure 5.22 – Sample application deployment
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 示例应用程序部署
- en: 'The following command execution output displays information about the deployment:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出显示有关部署的信息：
- en: '![Figure 5.23 – Describing sample application deployment ](img/Figure_5.24_B18115.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23 – 描述示例应用程序部署](img/Figure_5.24_B18115.jpg)'
- en: Figure 5.23 – Describing sample application deployment
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 描述示例应用程序部署
- en: 'Check the pods'' status to verify whether the application has been deployed
    and running, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Pods 的状态，以验证应用程序是否已经部署并运行，如下所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following command execution output indicates that pods have been created
    and that their status is `Running`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明 Pods 已创建并且其状态为 `Running`：
- en: '![Figure 5.24 – Checking whether pods are in a Running status ](img/Figure_5.25_B18115.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24 – 检查 Pods 是否处于运行状态](img/Figure_5.25_B18115.jpg)'
- en: Figure 5.24 – Checking whether pods are in a Running status
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24 – 检查 Pods 是否处于 Running 状态
- en: 'Let''s also check where the pods are running using the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也使用以下命令检查 Pods 的运行位置：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following command execution output indicates that pods are equally distributed
    between the Nodes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明 Pods 在节点之间均匀分布：
- en: '![Figure 5.25 – Checking whether pods are equally distributed  ](img/Figure_5.26_B18115.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25 – 检查 Pods 是否均匀分布](img/Figure_5.26_B18115.jpg)'
- en: Figure 5.25 – Checking whether pods are equally distributed
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25 – 检查 Pods 是否均匀分布
- en: 'Great! We have just deployed our sample application deployment on the Raspberry
    Pi multi-node cluster. Here is what Kubernetes has done for us:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！我们刚刚在树莓派多节点集群上部署了我们的示例应用程序。以下是 Kubernetes 为我们完成的操作：
- en: Looked for a suitable node on which to run an instance of the application (we
    have two available Nodes) and scheduled the application to run on that node based
    on `podAntiAffinity` rules.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找一个合适的节点来运行应用程序实例（我们有两个可用节点），并根据 `podAntiAffinity` 规则调度应用程序在该节点上运行。
- en: '`podAntiAffinity` rules limit the pod deployments on which Nodes the pod can
    be scheduled based on labels from other pods currently operating on the node.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podAntiAffinity` 规则限制 Pod 可以调度到的节点，这些节点是基于其他 Pods 当前在该节点上运行的标签进行选择的。'
- en: Configured the cluster to reschedule the instance on a new node when needed.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置集群在需要时将实例重新调度到新的节点。
- en: Pod topology spread constraints can also be used to regulate how pods are distributed
    among failure domains such as regions, zones, Nodes, and other user-defined topology
    domains in your cluster. This can aid in achieving HA and resource-use efficiency.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 拓扑分布约束也可用于调节 Pods 在故障域（如区域、可用区、节点和集群中其他用户定义的拓扑域）中的分布。这有助于实现高可用性（HA）和资源使用效率。
- en: To summarize, we built a Kubernetes Raspberry Pi cluster and used it to deploy
    a sample application. In the next step, we'll perform rolling updates to the application
    we've just deployed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们构建了一个 Kubernetes 树莓派集群，并利用它部署了一个示例应用程序。在接下来的步骤中，我们将对刚刚部署的应用程序执行滚动更新。
- en: Performing rolling updates to the application with a new software version
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行应用程序的滚动更新，使用新版本的软件。
- en: The rolling updates feature of Kubernetes allows Deployments to be updated with
    zero downtime. It handles the upgrading of pods' instances with new ones in an
    incremental manner, and new pods would be scheduled on Nodes that have resources
    available.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的滚动更新功能允许部署在零停机的情况下进行更新。它以增量的方式处理 Pods 实例的升级，并且新的 Pods 会调度到具有可用资源的节点上。
- en: 'Some key features of rolling updates are listed here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是滚动更新的一些关键特性：
- en: Transferring an application from one environment to another (via container image
    updates).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序从一个环境转移到另一个环境（通过容器镜像更新）。
- en: Rollback to a prior version of the application.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚到先前版本的应用程序。
- en: With minimal downtime, **continuous integration** and **continuous delivery**
    (**CI/CD**) of applications are achievable.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过最小的停机时间，**持续集成**和**持续交付**（**CI/CD**）的应用程序是可以实现的。
- en: We are going to reuse the same example of the nginx sample deployment that we
    used earlier. We can update the same deployment by applying the following new
    YAML file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新使用之前使用过的 nginx 示例部署。我们可以通过应用以下新的 YAML 文件来更新相同的部署。
- en: 'This YAML file specifies that the deployment should be updated to use the `nginx
    1.16.1` container image instead of `nginx.1.14.2`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该 YAML 文件指定将部署更新为使用 `nginx 1.16.1` 容器镜像，而不是 `nginx 1.14.2`：
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following command will deploy the preceding updated application deployment
    that uses the `nginx 1.16.1` image instead of the `nginx 1.14.2` image:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将部署之前更新的应用程序部署，使用 `nginx 1.16.1` 镜像，而不是 `nginx 1.14.2` 镜像：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following output after the execution of the previous command confirms that
    there is no error in the deployment, and in the next steps, we can verify the
    recreation of pods with new names and delete the old pods:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 执行之前命令后的以下输出确认部署没有错误，接下来我们可以验证 Pod 是否已重新创建并具有新名称，并删除旧的 Pods：
- en: '![Figure 5.26 – Update to sample application deployment ](img/Figure_5.27_B18115.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.26 – 更新示例应用程序部署](img/Figure_5.27_B18115.jpg)'
- en: Figure 5.26 – Update to sample application deployment
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 更新示例应用程序部署
- en: 'The following command execution output indicates that pods have been recreated
    and that their status is `Running`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明 Pod 已重新创建，且其状态为 `Running`：
- en: '![Figure 5.27 – New pods of updated deployment ](img/Figure_5.28_B18115.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.27 – 更新部署的新Pods](img/Figure_5.28_B18115.jpg)'
- en: Figure 5.27 – New pods of updated deployment
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 更新部署的新Pods
- en: 'Here is how a rolling update works (refer to *Figure 5.29*):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是滚动更新的工作原理（参见*图 5.29*）：
- en: Using the revised configuration, it creates a new deployment.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用修订后的配置，它会创建一个新的部署。
- en: Increases/decreases the number of replicas on the new and old controllers until
    the correct number is attained.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加/减少新旧控制器上的副本数，直到达到正确的数量。
- en: Finally, the original deployment and associated pods will be deleted.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，原始部署及相关Pods将被删除。
- en: 'Here is a diagram of rolling updates'' functionality:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是滚动更新功能的示意图：
- en: '![Figure 5.28 – Rolling updates to the sample application ](img/Figure_5.29_B18115.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.28 – 示例应用程序的滚动更新](img/Figure_5.29_B18115.jpg)'
- en: Figure 5.28 – Rolling updates to the sample application
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28 – 示例应用程序的滚动更新
- en: 'There are two additional options when utilizing the `RollingUpdate` approach
    to fine-tune the update process, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`RollingUpdate`方法来微调更新过程时，还有两个额外的选项，如下所示：
- en: '`maxSurge`: During an update, the maximum number of pods that can be created
    is greater than the desired number of pods.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxSurge`：在更新过程中，最多可以创建的Pods数量大于所需的Pods数量。'
- en: '`maxUnavailable`: The number of pods that may become unavailable during the
    upgrade procedure.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxUnavailable`：在升级过程中可能变得不可用的Pods数量。'
- en: We've set `maxSurge` to `0` and `maxUnavailable` to `1` in the sample application
    deployment, indicating that the maximum number of new pods that can be generated
    at a time is 0 and the maximum number of old pods that can be destroyed at a time
    is `1`. This strategy indicates that as new pods are created, old pods will be
    destroyed one by one.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例应用程序部署中将`maxSurge`设置为`0`，`maxUnavailable`设置为`1`，这表示一次最多可以生成的新Pods数量是0，而一次最多可以销毁的旧Pods数量是`1`。这种策略表明，随着新Pods的创建，旧Pods会被一个接一个地销毁。
- en: Depending on your goal, there are various sorts of deployment tactics you might
    want to use. For example, you may need to deploy modifications to a specific environment
    for more testing, or to a group of users/customers, or you may wish to do user
    testing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的目标，可能需要使用不同的部署策略。例如，您可能需要将更改部署到特定的环境中进行更多测试，或部署到一组用户/客户，或者您可能希望进行用户测试。
- en: 'Various Kubernetes deployment strategies are outlined here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里概述了各种Kubernetes部署策略：
- en: '**Recreate**: In this very simple deployment strategy, all old pods are killed
    at the same time and replaced with new ones.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重建**：在这种非常简单的部署策略中，所有旧Pods会同时被销毁，并被新的Pods替换。'
- en: '**Blue/green deployments**: In a blue/green deployment strategy, the old (green)
    and new (blue) versions of the application are deployed at the same time. When
    both are launched, consumers may only access the green deployment; the blue deployment
    is available to your **quality assurance** (**QA**) team for test automation on
    a different service or via direct port forwarding.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**：在蓝绿部署策略中，旧版本（绿色）和新版本（蓝色）的应用程序同时部署。当两者都启动时，消费者可能只能访问绿色部署；蓝色部署则可以供**质量保证**（**QA**）团队在不同服务或通过直接端口转发进行测试自动化。'
- en: '**Canary deployments**: Canary deployments are like blue/green deployments,
    except they are more controlled and use a *progressive delivery* phased-in technique.
    Canary encompasses a variety of methods, including dark launches and A/B testing.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金丝雀部署**：金丝雀部署类似于蓝绿部署，只是它更受控制，并采用*渐进交付*的分阶段技术。金丝雀部署包括多种方法，包括暗启动和A/B测试。'
- en: '**Dark deployments or A/B deployments**: Another variation on a canary deployment
    is a dark deployment. The distinction between dark and canary deployments is that
    dark deployments deal with features on the frontend rather than the backend, as
    canaries do.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暗部署或A/B部署**：一种变体的金丝雀部署是暗部署。暗部署与金丝雀部署的区别在于，暗部署处理的是前端功能，而金丝雀部署则处理的是后端功能。'
- en: To summarize, we've launched a sample application as well as performed rolling
    updates on the one we've already deployed. We will concentrate on how to scale
    the application in the following section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经启动了一个示例应用程序，并对已部署的应用程序执行了滚动更新。接下来的部分，我们将专注于如何扩展应用程序。
- en: Scaling the application deployment
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序部署
- en: Changing the number of replicas in a Deployment allows scaling the deployments.
    When a Deployment is scaled out, new pods will be created and scheduled to Nodes
    with available resources. The number of pods will be scaled up to the new target
    state. Autoscaling pods is also supported by Kubernetes. It is also possible to
    scale to zero, which will terminate all pods in a given Deployment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 Deployment 中的副本数量可以实现部署的扩展。当 Deployment 扩展时，新的 pods 将被创建并调度到具有可用资源的节点。pods
    的数量将扩展到新的目标状态。Kubernetes 也支持自动扩展 pods。也可以扩展到零，即终止给定 Deployment 中的所有 pods。
- en: Running many instances of an application needs a method for distributing traffic
    among them. A built-in load balancer in a `Services` object distributes network
    traffic across all pods in an exposed Deployment. Endpoints will be used to continuously
    monitor the operating pods, ensuring that traffic is only directed to those that
    are available.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行多个应用实例需要一种方法来在它们之间分配流量。在`Services`对象中内建的负载均衡器将网络流量分配到所有暴露的 Deployment 中的 pods。端点将用于持续监控运行中的
    pods，确保流量只会被导向那些可用的 pods。
- en: 'We''ll use a new YAML file to increase the number of pods in the Deployment
    in the following example. The replicas are set to `4` in this YAML file, indicating
    that the Deployment should include four pods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中使用一个新的 YAML 文件来增加 Deployment 中的 pods 数量。在这个 YAML 文件中，副本数设置为`4`，意味着
    Deployment 应包括四个 pods：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following command will deploy the preceding updated application deployment:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将部署前面更新过的应用部署：
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following command output shows that the command was successfully run and
    that the Deployment has been configured:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令输出表明命令已成功运行，并且 Deployment 已配置完成：
- en: '![Figure 5.29 – Scaling sample application deployment ](img/Figure_5.30_B18115.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.29 – 扩展示例应用部署](img/Figure_5.30_B18115.jpg)'
- en: Figure 5.29 – Scaling sample application deployment
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 – 扩展示例应用部署
- en: 'The following command execution output confirms that there is no error in the
    deployment, and in the next steps, we can verify that the Deployment has four
    pods:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出确认部署没有错误，接下来的步骤中，我们可以验证该 Deployment 已包含四个 pods：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following command output shows that the command was successfully run and
    the deployment has created new pods and scheduled to Nodes with available resources:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令输出表明命令已成功运行，且部署已创建新的 pods 并调度到具有可用资源的节点：
- en: '![Figure 5.30 – New pods have been created post scaling ](img/Figure_5.31_B18115.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.30 – 扩展后创建了新的 pods](img/Figure_5.31_B18115.jpg)'
- en: Figure 5.30 – New pods have been created post scaling
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 – 扩展后创建了新的 pods
- en: 'Here is a diagram of scaling functionality:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个扩展功能的示意图：
- en: '![Figure 5.31 – Application deployment scaling ](img/Figure_5.32_B18115.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.31 – 应用部署扩展](img/Figure_5.32_B18115.jpg)'
- en: Figure 5.31 – Application deployment scaling
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 应用部署扩展
- en: 'Another option is to use the command line (without editing the YAML file).
    Let''s say we want to increase the number of nginx deployments to five. To do
    so, run the `kubectl scale` command, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用命令行（不编辑 YAML 文件）。假设我们想将 nginx 部署的数量增加到五个。为此，运行`kubectl scale`命令，如下所示：
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Those pods can also be scaled down in the same way they were scaled up. You
    can alter `replicas:` in the YAML file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 pods 也可以像扩展时一样缩减。你可以在 YAML 文件中修改 `replicas:` 设置。
- en: 'And with the `kubectl` command, you could scale down from `5` to `4`, like
    so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl`命令，你还可以将副本数从`5`缩减到`4`，如下所示：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To view how the pods are distributed across the Nodes, use the following command
    to check:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 pods 如何在节点间分布，使用以下命令进行检查：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following command execution output indicates that there are two pods running
    on the control plane node and two of them are running on `worker1`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明控制平面节点上运行着两个 pods，而在`worker1`上也有两个 pods 正在运行：
- en: '![Figure 5.32 – Pod distribution across Nodes ](img/Figure_5.33_B18115.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.32 – Pod 在节点间的分布](img/Figure_5.33_B18115.jpg)'
- en: Figure 5.32 – Pod distribution across Nodes
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32 – Pod 在节点间的分布
- en: In this chapter, we have demonstrated how to get MicroK8s functionality on a
    Raspberry Pi and have joined multiple Pis to form a production-grade Kubernetes
    cluster. MicroK8s is being presently employed in a range of contexts, ranging
    from a single-node installation on a developer's desktop to the support of compute-intensive
    AI and ML workloads.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何在 Raspberry Pi 上获得 MicroK8s 的功能，并将多个 Pi 加入形成一个生产级的 Kubernetes 集群。目前，MicroK8s
    被广泛应用于各种场景，从开发者桌面上的单节点安装到支持计算密集型 AI 和 ML 工作负载的部署。
- en: MicroK8s is well suited for the edge, IoT, and appliances because of its minimal-resource
    footprint and support for both **Advanced RISC Machine** (**ARM**) and Intel architectures.
    On Raspberry Pis, MicroK8s is a common choice. We will be looking at implementation
    aspects of common edge computing applications in the upcoming chapters. In the
    next section, we will touch upon some best practices for implementing Kubernetes
    for your production-grade Kubernetes cluster.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: MicroK8s 非常适合边缘计算、物联网和设备，因为它占用资源少，并且支持 **高级 RISC 机器**（**ARM**）和英特尔架构。在 Raspberry
    Pi 上，MicroK8s 是常见的选择。我们将在接下来的章节中探讨常见边缘计算应用的实施方面。在下一节中，我们将讨论一些为你的生产级 Kubernetes
    集群实施 Kubernetes 的最佳实践。
- en: Guidelines on multi-node cluster configuration
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多节点集群配置指南
- en: In this section, we will go through some best practices for creating a scalable,
    secure, and highly optimized Kubernetes cluster model.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些创建可扩展、安全且高度优化的 Kubernetes 集群模型的最佳实践。
- en: Cluster-level configuration/settings
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群级别的配置/设置
- en: 'You can define levels of abstraction, such as pods and services, with Kubernetes
    so that you don''t have to worry about where your applications are running or
    whether they have enough resources to run efficiently. However, you must monitor
    your applications, the containers that run them, and even Kubernetes itself to
    maintain optimal performance. In this section, we will cover some best practices
    to follow for setting up and operating your Kubernetes clusters. These are outlined
    here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Kubernetes 中定义抽象层次，例如 pods 和 services，这样你就不必担心应用程序运行的位置或它们是否有足够的资源高效运行。然而，你必须监控你的应用程序、运行它们的容器，甚至是
    Kubernetes 本身，以维持最佳性能。在本节中，我们将介绍一些设置和操作 Kubernetes 集群的最佳实践。具体如下：
- en: '**Use the latest version**: Kubernetes offers new features, bug patches, and
    platform upgrades with its regular version updates. You should always utilize
    the most recent Kubernetes version on your cluster as a rule of thumb.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用最新版本**：Kubernetes 会通过定期版本更新提供新功能、修复漏洞和平台升级。作为一个基本原则，你应该始终在集群中使用最新的 Kubernetes
    版本。'
- en: When multiple teams are attempting to use the same cluster resources at the
    same time, namespaces can be used to achieve team-level isolation. Using Namespaces
    effectively allows you to construct numerous logical cluster divisions, enabling
    you to allocate different virtual resources to different teams.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个团队尝试同时使用相同的集群资源时，可以使用命名空间来实现团队级别的隔离。有效使用命名空间允许你构建多个逻辑集群划分，使你能够将不同的虚拟资源分配给不同的团队。
- en: Use smaller container images whenever possible to speed up your builds. Due
    to a smaller attack surface, smaller images are likewise less vulnerable to attack
    vectors.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用较小的容器镜像以加速构建过程。由于较小的攻击面，较小的镜像也更不容易受到攻击向量的影响。
- en: The `kube-bench` is one of the tools that examine whether Kubernetes is deployed
    securely using the checks provided in the *CIS Kubernetes Benchmark*.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-bench` 是其中一款工具，用于检查 Kubernetes 是否使用 *CIS Kubernetes 基准* 中提供的检查项安全部署。'
- en: Alpha and beta Kubernetes features are still in development and may contain
    flaws or problems that lead to security flaws. Always weigh the benefits of an
    alpha or beta feature against the danger posed to your security posture. When
    in doubt, turn off any features that you don't utilize.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha 和 beta 版本的 Kubernetes 功能仍在开发中，可能包含缺陷或问题，从而导致安全漏洞。在使用 alpha 或 beta 功能时，务必权衡其带来的好处与对安全性的潜在威胁。如果有疑问，关闭任何你不使用的功能。
- en: Use an OpenID Connect authentication mechanism for your Kubernetes cluster and
    other development tools using **single sign-on** (**SSO**), such as Google Identity.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你的 Kubernetes 集群以及其他使用**单点登录**（**SSO**）的开发工具，使用 OpenID Connect 认证机制，例如 Google
    Identity。
- en: Review retention and archival strategy for logs—ideally, 30-45 days of historical
    logs should be retained.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查日志的保留和归档策略——理想情况下，应保留 30-45 天的历史日志。
- en: 'Logs should be collected from all Nodes, control planes, and auditing:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应收集所有节点、控制平面和审计的日志：
- en: a. Nodes (kubelet, container runtime)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: a. 节点（kubelet，容器运行时）
- en: b. Control plane (API server, scheduler, controller manager)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: b. 控制平面（API 服务器、调度器、控制器管理器）
- en: c. Kubernetes auditing (all requests to the API server)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: c. Kubernetes 审计（所有请求到 API 服务器）
- en: Use a log aggregation tool such as the **Amazon Web Services** (**AWS**) CloudWatch,
    **Elasticsearch, Fluentd, and Kibana** (**EFK**) stack, Datadog, Sumo Logic, Sysdig,
    **Google Cloud Platform** (**GCP**) Stackdriver, or Azure Monitor.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志聚合工具，如**Amazon Web Services**（**AWS**）CloudWatch，**Elasticsearch, Fluentd
    和 Kibana**（**EFK**）堆栈，Datadog，Sumo Logic，Sysdig，**Google Cloud Platform**（**GCP**）Stackdriver
    或 Azure Monitor。
- en: Control plane components should be monitored to assist in any discovery of issues/threats
    within the cluster and reduce latency. It's better to use automatic monitoring
    tools rather than manually managing alerts.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该监控控制平面组件，以帮助发现集群中的问题/威胁，并减少延迟。最好使用自动监控工具，而不是手动管理警报。
- en: To summarize, we have covered some of the best practices that need to be followed
    for setting up and operating your Kubernetes clusters. In the next section, we
    will look at best practices related to container life cycle management.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们已经覆盖了设置和操作 Kubernetes 集群时需要遵循的一些最佳实践。在下一节中，我们将讨论与容器生命周期管理相关的最佳实践。
- en: Container life cycle management
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器生命周期管理
- en: 'Kubernetes and the Kubernetes architecture effectively automate the life cycle
    management of application containers, but they can be difficult to set up and
    administer. In this section, we will check on best practices and how to implement
    them in your clusters quickly and easily:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 及其架构有效地自动化了应用容器的生命周期管理，但它们的设置和管理可能较为复杂。在本节中，我们将查看最佳实践及如何快速、轻松地在集群中实现它们：
- en: 'Containers with no limits might cause resource conflict with other containers
    and inefficient computational resource consumption. Use `ResourceQuota` and `LimitRange`
    for restricting resource utilization:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有资源限制的容器可能会导致与其他容器的资源冲突，并且计算资源使用效率低下。使用 `ResourceQuota` 和 `LimitRange` 来限制资源利用：
- en: a. You can use `ResourceQuotas` to set a limit on the total amount of resources
    consumed by all containers in a Namespace. Other Kubernetes objects, such as the
    number of pods in the current namespace, can also have quotas imposed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: a. 你可以使用 `ResourceQuotas` 来设置所有容器在某个命名空间中消耗的资源总量的限制。其他 Kubernetes 对象（如当前命名空间中的
    Pod 数量）也可以设置配额。
- en: b. If you're concerned that someone might use your cluster to produce a large
    number of ConfigMaps, you can use `LimitRange` to prevent this.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果你担心某人可能会利用你的集群生成大量 ConfigMap，可以使用 `LimitRange` 来防止这种情况发生。
- en: Use Kubernetes *pod security policies* for enforcing security configurations—for
    example, to access the host filesystem.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 的*Pod 安全策略*来强制执行安全配置——例如，访问主机文件系统。
- en: While there are some circumstances where privileged containers are required,
    allowing your containers to do so is, in general, a security concern. If there
    are no specific use cases, disable privileged containers.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然在某些情况下可能需要特权容器，但允许容器拥有特权通常是一个安全隐患。如果没有特定的使用场景，禁用特权容器。
- en: Go for rootless containers. If a user succeeds to break out of a container-based
    application running as root, they may be able to use the same root user to get
    access to the host.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择无根容器。如果用户成功突破以 root 身份运行的容器化应用，他们可能能够使用相同的 root 用户访问主机。
- en: To avoid escalating privileges using `setuid` or `setgid` binaries, run your
    container with privilege escalation disabled.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免通过 `setuid` 或 `setgid` 二进制文件提升权限，运行容器时应禁用特权升级。
- en: Enable **network policies** so that it establishes firewalls between the pods
    on your cluster.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用**网络策略**，以便在你的集群中的 Pod 之间建立防火墙。
- en: Use tools such as **Open Policy Agent** (**OPA**) to apply policies, such as
    using only approved base images that can be deployed in your cluster.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**开放策略代理**（**OPA**）等工具应用策略，例如，仅使用批准的基础镜像，这些镜像可以在你的集群中部署。
- en: To recap, we've gone through some best practices for automating container life
    cycle management. We'll look at the guidelines for deploying and sharing HA applications
    with Kubernetes in the next section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们已经讨论了一些容器生命周期管理的最佳实践。接下来的章节将讨论如何在 Kubernetes 中部署和共享高可用（HA）应用程序的指南。
- en: Deploying and sharing HA applications
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和共享高可用（HA）应用
- en: 'As you may be aware, deploying a basic application in Kubernetes is a piece
    of cake. Trying to make your application as available and fault-tolerant as feasible,
    on the other hand, implies a slew of challenges. In this section, we list some
    of the guidelines for deploying and sharing HA applications in Kubernetes, as
    follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，在 Kubernetes 中部署一个基础应用程序是轻而易举的。然而，尽可能使你的应用程序具有高可用性和容错性则意味着面临许多挑战。在本节中，我们列出了在
    Kubernetes 中部署和共享高可用应用程序的一些指南，如下所示：
- en: All containers should have `readiness probes` set up. The kubelet agent assumes
    that the application is ready to receive traffic as soon as the container starts
    if you don't set the readiness probe.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有容器应设置`就绪探针`。如果没有设置就绪探针，kubelet 代理会假设应用程序在容器启动时已经准备好接收流量。
- en: '*Liveness and readiness* probes shouldn''t point to the same endpoint because
    when the application indicates that it is not ready or live, the kubelet agent
    detaches and deletes the container from the service.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存活性和就绪性*探针不应指向相同的端点，因为当应用程序表示不准备好或不存活时，kubelet 代理会将容器从服务中断开并删除。'
- en: Running many or more than one instance of your pods ensures that eliminating
    a single pod will not result in downtime. Also, consider using a Deployment, DaemonSet,
    ReplicaSet, or StatefulSet to deploy your pod instead of running pods individually.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个或多个实例的 pod 可以确保删除单个 pod 时不会导致停机。同时，考虑使用 Deployment、DaemonSet、ReplicaSet
    或 StatefulSet 来部署 pod，而不是单独运行 pod。
- en: '*Anti-affinity rules* should be applied to your Deployments so that pods are
    distributed over all Nodes in your cluster.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在你的部署中应用*反亲和规则*，以确保 pod 在集群中的所有节点上分布。
- en: You can set a *pod disruption budget* to safeguard Deployments against unforeseen
    events that could bring down many pods at the same time. If the final state for
    that Deployment results in fewer than five pods, Kubernetes will prevent the drain
    event.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以设置一个*Pod 中断预算*，以保护部署免受可能导致多个 pod 同时宕机的不可预见事件。如果该部署的最终状态导致 pod 数量少于五个，Kubernetes
    将防止发生驱逐事件。
- en: Use the resources property of `containerSpec` to specify resource constraints
    that limit how much CPU and memory your containers can consume. These settings
    are taken into consideration by the scheduler to determine which node is most
    suited for the current pod.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`containerSpec`的资源属性来指定资源限制，限制容器可使用的 CPU 和内存量。这些设置会被调度程序考虑，以确定哪个节点最适合当前的 pod。
- en: All resources should have technical, business, and security labels defined.
    They should be applied to all resources in your cluster, including pods, services,
    Ingress manifests, and endpoints.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有资源都应定义技术、业务和安全标签。它们应应用于集群中的所有资源，包括 pod、服务、Ingress 清单和端点。
- en: Containers should not store any state in their local filesystem. Any persistent
    data should instead be saved in a central location outside of the pods—for instance,
    in a clustered PersistentVolume, or—even better—in a storage system outside of
    your cluster.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器不应将任何状态存储在本地文件系统中。任何持久化数据应保存到 pod 之外的中央位置，例如，集群化的 PersistentVolume，或者更好的是，在集群外的存储系统中。
- en: ConfigMaps should be used to manage all configurations outside of the application
    code. ConfigMaps should only be used to save non-sensitive settings. For sensitive
    information, use a secret resource (such as credentials). Instead of being passed
    in as environment variables, secret resources should be mounted as volumes in
    containers. To summarize, we have looked at best practices for creating a scalable,
    secure, and highly optimized Kubernetes cluster model.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 应该用于管理所有不在应用程序代码中的配置。ConfigMap 只应用于保存非敏感的设置。对于敏感信息，应该使用密钥资源（例如凭证）。敏感资源不应作为环境变量传递，而应该作为卷挂载到容器中。总之，我们已经看过创建一个可扩展、安全且高度优化的
    Kubernetes 集群模型的最佳实践。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to set up a MicroK8s Raspberry Pi multi-node
    cluster, deployed a sample application, and executed rolling updates on the deployed
    application. We also discovered ways to scale the deployed application. We also
    found that, while Kubernetes allows us to define levels of abstraction such as
    pods and services to help with application deployments, we must monitor the applications,
    containers, clusters, and Kubernetes itself to ensure optimal performance. In
    this context, we learned about several recommended practices for building a scalable,
    secure, and highly optimized Kubernetes cluster model.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何设置一个MicroK8s Raspberry Pi多节点集群，部署了一个示例应用程序，并对已部署的应用程序执行了滚动更新。我们还发现了扩展已部署应用程序的方法。我们还了解到，尽管Kubernetes允许我们定义诸如pod和service等抽象层级来帮助应用程序部署，但我们必须监控应用程序、容器、集群以及Kubernetes本身，以确保最佳性能。在此背景下，我们学习了构建一个可扩展、安全且高度优化的Kubernetes集群模型的几项推荐实践。
- en: In the next chapter, we will look at how to configure container network connectivity
    for your Kubernetes cluster.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何配置Kubernetes集群的容器网络连接。
