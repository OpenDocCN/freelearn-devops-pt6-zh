- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Realizing Full-Stack Visibility with VMware Aria Operations for Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现VMware Aria Operations for Applications的全栈可视化
- en: In the last chapter, we learned how we can use Tanzu Mission Control to manage
    hundreds of Kubernetes clusters for their lifecycle management, policy control,
    and data protection. Tanzu Mission Control is a single point of control for all
    these concerns for Kubernetes. In this chapter, we will talk about a central point
    of visibility for your cloud-native apps running in containers, along with all
    other supporting layers and systems around them. Knowing the vital health status
    of your systems is a very old and essential concept in the world of information
    technology that is known as *monitoring*. It is also known as telemetry. The tools
    we used for years to monitor traditional monolithic applications would not yield
    the required results when it comes to monitoring microservices running on different
    clusters, platforms, and clouds. With microservices, the world is very distributed.
    Typically, microservices run in containers, and containers are ephemeral – they
    quickly come and go. In that scenario, the continuity of a microservice’s context
    becomes very important, as they could be running in a different container after
    a few minutes, unlike traditional apps that would not leave their virtual and
    physical host for years. Adding more to this complexity of running microservices,
    they have to deal with substantial cardinality, including the larger apps they
    belong to, the environments they are deployed to, and the node, cluster, availability
    zone, and regions they are deployed to, among other things. We need a different
    approach to monitor them, as they run differently. To some extent, deploying apps
    in containers is like sending a spacecraft on a Mars mission. We don’t know where
    the container will physically end up – we can only rely on the health vitals that
    it emits at a regular frequency and course-correct if required. Traditional monitoring
    tools would not have helped in these conditions. When we have millions of transactions,
    thousands of containers, hundreds of nodes, and tens of data centers, we need
    powerful observability. VMware Aria Operations for Applications (formerly known
    as Tanzu Observability by Wavefront) is the tool in the Tanzu portfolio that addresses
    this need for modern application management.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Tanzu Mission Control来管理数百个Kubernetes集群，进行生命周期管理、策略控制和数据保护。Tanzu
    Mission Control是Kubernetes所有这些问题的单一控制点。在本章中，我们将讨论一个集中可视化的视角，用于监控在容器中运行的云原生应用，以及它们周围的所有支持层和系统。了解系统的关键健康状态是信息技术领域中的一个非常古老且基本的概念，被称为*监控*。它也被称为遥测。在监控传统的单体应用时，我们使用的工具多年来并不能为在不同集群、平台和云环境中运行的微服务提供所需的结果。随着微服务的出现，世界变得非常分布式。通常，微服务运行在容器中，而容器是短暂的——它们很快就会出现又消失。在这种情况下，微服务的上下文的连续性变得非常重要，因为它们可能会在几分钟后运行在不同的容器中，而传统应用则不会离开它们的虚拟和物理主机多年。更复杂的是，微服务还需要处理大量的基数问题，包括它们所属的更大应用、它们部署的环境，以及它们部署的节点、集群、可用区和区域等。在监控微服务时，我们需要一种不同的方法，因为它们的运行方式不同。某种程度上，将应用部署到容器中就像将航天器送往火星任务一样。我们无法知道容器最终会物理地停留在哪里——我们只能依赖它以固定频率发出的健康数据，并在需要时进行调整。在这些条件下，传统的监控工具是无法提供帮助的。当我们面临数百万次交易、成千上万的容器、数百个节点和数十个数据中心时，我们需要强大的可观察性。VMware
    Aria Operations for Applications（前身为Wavefront的Tanzu Observability）是Tanzu产品组合中专门解决现代应用管理这一需求的工具。
- en: 'In May 2017, VMware acquired Wavefront, a privately held company in Palo Alto,
    California. The power of Wavefront comes from its ability to ingest millions of
    metrics and other data points coming from hundreds of locations in real time and
    render point-in-time charts and alerts for correlated visibility. Later, Wavefront
    became a part of the Tanzu portfolio to add an essential piece of the puzzle to
    the mix – observability. Hence, any reference to Wavefront in this chapter or
    the standard product documentation refers to VMware Aria Operations for Applications.
    For brevity, we will refer to it as *Aria* in this chapter and will cover it in
    detail with the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年5月，VMware 收购了位于加利福尼亚州帕洛阿尔托的私人公司 Wavefront。Wavefront 的强大之处在于其能够实时处理来自数百个位置的数百万个指标和其他数据点，并渲染出具有时间点的图表和警报，以便进行关联性可见性。后来，Wavefront
    成为了 Tanzu 产品组合的一部分，为这一组合增添了一个至关重要的拼图——可观察性。因此，本章或标准产品文档中对 Wavefront 的任何引用都指的是
    VMware Aria Operations for Applications。为了简洁起见，本章中我们将其简称为 *Aria*，并将通过以下主题详细介绍：
- en: '**Why Aria?** – covering various features and capabilities of this tool'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为什么选择 Aria？** – 涵盖该工具的各种功能和能力'
- en: '**Unboxing Aria** – covering key concepts, components, and the common deployment
    architecture of the tool'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解锁 Aria** – 涵盖该工具的关键概念、组件及常见的部署架构'
- en: '**Getting started with Aria** – covering the integration of a Kubernetes cluster
    and an application with the tool'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始使用 Aria** – 涵盖将 Kubernetes 集群和应用程序与该工具集成的内容'
- en: '**Working with charts and dashboards** – covering a high-level understanding
    of building charts and creating new dashboards with the tool'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用图表和仪表板** – 涵盖构建图表和使用该工具创建新仪表板的高级理解'
- en: '**Working with alerts** – covering the details of how to create, manage, and
    observe alerts with the tool'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用警报** – 涵盖如何使用该工具创建、管理和观察警报的详细内容'
- en: There are several other facets of Aria that we have to skip to keep the chapter
    at an acceptable length. Aria is a very powerful tool that can perform various
    operations around observability and **application performance management** (**APM**),
    but considering the broader scope of the book, we will only cover the details
    related to microservices, containers, and Kubernetes monitoring. With that understanding,
    let’s begin our journey of observability.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于篇幅限制，我们必须跳过 Aria 的其他一些方面，以保持章节的合理长度。Aria 是一个非常强大的工具，能够执行与可观察性和**应用性能管理**（**APM**）相关的各种操作，但考虑到本书的广泛内容，我们只会覆盖与微服务、容器和
    Kubernetes 监控相关的细节。在此基础上，让我们开始可观察性的旅程。
- en: Why Aria?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Aria？
- en: Aria is an observability tool rather than a monitoring tool. A monitoring tool
    can tell you that an application is running slowly, but an observability tool
    can help you find the root cause for the application being slow. This is because
    it allows you to correlate the health indicators coming from all the surrounding
    components that could impact an application’s performance. It could be an issue
    at the **operating system** (**OS**) layer or a slow-running query in a database.
    The main strength of an observability tool is its ability to ingest data points
    from all possible systems and layers and for all different health indicators that
    could make a significant event. It then allows you to find the needle in the haystack
    by reducing the noise of irrelevant data by applying correlation formulas to the
    collected data. An observability tool can help you identify abnormal traffic patterns,
    latencies, error rates, and many more attributes, based on historical data patterns.
    For example, the average request rate per second for an application during the
    midnight hours would be different from that during the day generally. Hence, an
    observability tool could alert you if it saw an abnormal request rate for an application
    depending on the timeframe. The abilities of these tools help identify anomalies
    long before they become too-late, expensive discoveries.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Aria 是一个可观察性工具，而不是一个监控工具。监控工具可以告诉你一个应用程序运行缓慢，但可观察性工具可以帮助你找到应用程序变慢的根本原因。这是因为它允许你将来自所有可能影响应用程序性能的周边组件的健康指标进行关联。问题可能出在**操作系统**（**OS**）层，或者是数据库中的慢查询。可观察性工具的主要优势在于它能够从所有可能的系统和层次中摄取数据点，并收集所有不同的健康指标，这些指标可能会引发重大事件。然后，它通过应用关联公式到收集到的数据，减少无关数据的噪音，帮助你在信息海洋中找到针。可观察性工具可以帮助你识别异常的流量模式、延迟、错误率以及更多其他属性，这些都基于历史数据模式。例如，一个应用程序在午夜时段的平均请求率通常与白天的请求率不同。因此，如果在特定时间段内，应用程序的请求率异常，可观察性工具可以发出警报。这些工具的能力有助于在问题变得无法挽回和代价昂贵之前，早早发现异常。
- en: With the rise of microservices and containerized platforms, *observability*
    has become a buzzword in recent times. There are various open source and commercial
    solutions available on the market offering somewhat similar capabilities in this
    space. Like other chapters, the idea of this section is not to compare Aria with
    any other observability tool, but to highlight what makes Aria a compelling choice
    with its own unique capabilities. Let’s look at some of the points in this regard
    to answer *Why Aria?*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务和容器化平台的兴起，*可观察性*近年来已经成为一个流行词。市场上有各种开源和商业解决方案，提供类似的功能。在这一章中，与其他章节一样，我们的目标不是将
    Aria 与任何其他可观察性工具进行比较，而是突出 Aria 作为一个有吸引力的选择，其独特的功能使其脱颖而出。让我们从几个方面来看，回答*为什么选择 Aria？*
- en: Integrating (almost) anything
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成（几乎）所有东西
- en: 'As discussed before, the power of observability depends on the data being ingested
    from various layers and the tools supporting critical business systems. For this,
    we may need to ingest metrics, events, histograms, and logs from many different
    systems. They could be various infrastructure platforms such as **Amazon Web Services**
    (**AWS**) or Azure public clouds; on-premises vSphere stacks; OSs such as Windows,
    Ubuntu, Photon, or RedHat; middleware layers such as the Tomcat server; Spring
    Boot- and NodeJS-like application frameworks; various caches; RDBMSes; NoSQL and
    queues as data sources; and several other components for alerting, containerization,
    visualization, end user analytics, and so on. To cater to this need, Aria supports
    over 250 integrations out of the box. These integrations are well documented to
    aid self-help configuration. Many popular integrations such as Kubernetes, popular
    public cloud services, and application frameworks come with canned sets of dashboards
    and alerts, facilitating the quick value realization of these integrations. With
    these out-of-the-box dashboards and alerts, users can see meaningful data within
    a few minutes of it starting to flow in. The following are the categories of the
    out-of-the-box integrations with Aria:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，观察性功能的强大取决于从各个层级摄取的数据以及支持关键业务系统的工具。为此，我们可能需要从许多不同的系统中摄取指标、事件、直方图和日志。这些系统可能是各种基础设施平台，如**亚马逊网络服务**（**AWS**）或Azure公共云；本地vSphere堆栈；操作系统，如Windows、Ubuntu、Photon或RedHat；中间件层，如Tomcat服务器；像Spring
    Boot和NodeJS这样的应用框架；各种缓存；关系型数据库（RDBMS）；NoSQL和队列作为数据源；以及用于警报、容器化、可视化、终端用户分析等的其他多个组件。为了满足这一需求，Aria支持超过250种即插即用的集成。这些集成有详细文档，帮助自助配置。许多流行的集成，如Kubernetes、流行的公共云服务和应用框架，附带有现成的仪表板和警报，便于快速实现这些集成的价值。通过这些即插即用的仪表板和警报，用户可以在数据开始流入的几分钟内看到有意义的数据。以下是Aria即插即用集成的类别：
- en: VMware products
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware产品
- en: Web application platforms such as .NET, Tomcat, and nginx
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用平台，如.NET、Tomcat和nginx
- en: Cloud services of AWS, Azure, and **Google Cloud** **Platform** (**GCP**)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务，如AWS、Azure和**谷歌云平台**（**GCP**）
- en: Data stores such as PostgreSQL, Redis, Cassandra, and Oracle
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储，如PostgreSQL、Redis、Cassandra和Oracle
- en: DevOps tools such as Jenkins, GitHub, Chef, Ansible, and Terraform
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps工具，如Jenkins、GitHub、Chef、Ansible和Terraform
- en: Messaging platforms such as RabbitMQ and Kafka
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息平台，如RabbitMQ和Kafka
- en: Monitoring tools such as AppDynamics, Dynatrace, and Prometheus
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控工具，如AppDynamics、Dynatrace和Prometheus
- en: OSs such as different flavors of Linux, Windows, and macOS
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统，如不同版本的Linux、Windows和macOS
- en: Application frameworks such as Spring Boot, Python, Go, and Java
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用框架，如Spring Boot、Python、Go和Java
- en: Alerting systems such as PagerDuty, ServiceNow, and Slack
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报系统，如PagerDuty、ServiceNow和Slack
- en: Authentication providers such as Okta, Google, and Microsoft Active Directory
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证提供商，如Okta、Google和Microsoft Active Directory
- en: This list is not comprehensive. There are various tools in each category beyond
    those listed here. On top of that, Aria has an extendable framework that allows
    you to pull in metrics and other health indicators from any system using its plugin-based
    model and a **software development kit** (**SDK**). As we will see later in the
    chapter, Aria can get metrics from most systems using an open source metrics collection
    agent named **Telegraf** ([https://github.com/influxdata/telegraf](https://github.com/influxdata/telegraf)).
    Telegraf has a long list of plugins that make it very extendable. For the data
    sources not available as integrations in Aria out of the box, we can create custom
    integrations with minimal effort. Additionally, in case an out-of-the-box plugin
    is not available to ingest data from the source, it can be custom-developed using
    the Aria SDK. Visit [https://docs.wavefront.com/wavefront_sdks.html](https://docs.wavefront.com/wavefront_sdks.html)
    for more details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不全面。每个类别中还有许多工具超出了这里列出的范围。除此之外，Aria还具有可扩展框架，允许你通过其基于插件的模型和**软件开发工具包**（**SDK**）从任何系统中拉取指标和其他健康指标。正如我们将在本章后面看到的，Aria可以通过一个名为**Telegraf**的开源指标收集代理（[https://github.com/influxdata/telegraf](https://github.com/influxdata/telegraf)）从大多数系统中获取指标。Telegraf有一长串插件，使其非常可扩展。对于Aria即插即用集成中没有的数据源，我们可以通过最小的努力创建自定义集成。此外，如果没有现成的插件来摄取数据，可以使用Aria
    SDK进行自定义开发。有关详细信息，请访问[https://docs.wavefront.com/wavefront_sdks.html](https://docs.wavefront.com/wavefront_sdks.html)。
- en: Getting full-stack visibility
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取全栈可见性
- en: Have you ever realized that when you ran an application in containers, how many
    different layers were below and around that application? An application is wrapped
    in a container. In Kubernetes, one or more containers are wrapped in a Pod. These
    Pods are a part of a Kubernetes node. A node is often a virtual machine that is
    running on top of a hypervisor such as vSphere. The hypervisor sits on top of
    physical hosts. These physical hosts are parts of some rack in a data center somewhere
    in the world. Additionally, the application could be using external services,
    such as other dependency apps, an application runtime such as the Tomcat server
    or Java Runtime Environment, a database, possibly a cache, a messaging queue such
    as RabbitMQ or Kafka, and many other supporting services. When we need to monitor
    an environment of many containers, monitoring all these layers below applications
    and their supporting services becomes crucial to quickly find out the root cause
    of failures and quickly address them. This is made possible when you have the
    ability to collect health vitals from all these sources and visualize them meaningfully
    or establish an alerting system using a single tool. **Site reliability engineering**
    (**SRE**) teams often struggle when there are different tools for monitoring different
    systems, such as a separate tool for application monitoring, a separate tool for
    Kubernetes monitoring, a separate tool for virtual infrastructure monitoring,
    and so on. When we have several monitoring tools to investigate during an outage
    situation, making sense of the health data available becomes very difficult and
    results in a loss of context. This happens because different tools use different
    methods of rendering the collected health data and the teams using them use different
    terms and language. In these conditions, a common way to filter the metrics collected
    for a specific timeframe and other conditions for all the sources potentially
    affected can quickly help corner an issue. This way, we can quickly point out
    that a slow-running application in a container is actually being slowed down by
    a high CPU host temperature condition.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经意识到，当你在容器中运行应用程序时，下面和周围有多少不同的层次？一个应用程序被封装在容器中。在 Kubernetes 中，一个或多个容器被封装在一个
    Pod 中。这些 Pod 是 Kubernetes 节点的一部分。一个节点通常是运行在虚拟机上的虚拟机，这些虚拟机通常基于一个如 vSphere 的虚拟化平台。虚拟化平台位于物理主机之上。这些物理主机是位于世界某地数据中心机架的一部分。此外，应用程序可能还会使用外部服务，如其他依赖应用程序、运行时环境（如
    Tomcat 服务器或 Java 运行时环境）、数据库、可能还有缓存、消息队列（如 RabbitMQ 或 Kafka），以及许多其他支持服务。当我们需要监控大量容器环境时，监控这些容器下方和其支持服务的所有层级变得至关重要，以便快速找出故障的根本原因并及时解决。当你能够从所有这些源收集健康数据并以有意义的方式进行可视化，或使用一个工具建立警报系统时，这变得可能。**站点可靠性工程**（**SRE**）团队通常面临的问题是，不同的系统使用不同的监控工具，例如应用程序监控使用一个工具，Kubernetes
    监控使用另一个工具，虚拟基础设施监控使用另一个工具，等等。当我们在故障排除期间需要使用多个监控工具时，理解可用的健康数据变得非常困难，导致失去上下文。这是因为不同的工具采用不同的方法呈现收集到的健康数据，而且使用这些工具的团队使用的术语和语言也不同。在这种情况下，使用一个通用的方式过滤所有源在特定时间范围内收集的指标，并根据其他条件快速帮助定位问题，可以迅速解决问题。这样，我们可以很快指出，容器中运行缓慢的应用程序实际上是由于主机
    CPU 温度过高而导致的性能下降。
- en: Since Aria can collect health data from almost any source, we can create custom
    dashboards for custom applications and display health vitals from all the surrounding
    components related to the application. This way, you can see the memory utilization
    of an application’s container and of the Kubernetes node on which the container
    is deployed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Aria 能够从几乎任何来源收集健康数据，我们可以为定制的应用程序创建定制的仪表板，并显示所有与应用程序相关的周边组件的健康数据。这样，你可以看到应用程序容器的内存使用情况，以及容器部署所在的
    Kubernetes 节点的内存使用情况。
- en: Ingesting high-volume data in real time
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时处理高容量数据
- en: Aria is a very powerful cloud-based SaaS streaming analytics platform that is
    highly scalable and efficient at collecting a very large amount of data. Because
    of its design, it can potentially support collecting over a million data points
    per second. Once this data is collected, we can see it live in its respective
    monitoring dashboards and it can be used to calculate any preconfigured alert
    conditions with Aria’s powerful query engine to pull ingested data in real time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Aria 是一个功能强大的基于云的 SaaS 流式分析平台，具有很高的可扩展性，并且能够高效地收集大量数据。由于其设计，它可能支持每秒收集超过一百万个数据点。一旦数据被收集，我们可以实时在其相应的监控仪表板中查看，并且可以使用
    Aria 强大的查询引擎在实时拉取摄取数据时计算任何预配置的告警条件。
- en: Retaining full-fidelity data for a long time
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长时间保留全保真数据
- en: As we discussed previously, Aria can ingest a very large volume of data – but
    additionally, it can also retain all metrics data for 18 months as of the time
    of writing. This is unlike other observability tools that either store this data
    for a shorter time period or with some level of aggregation applied to it to reduce
    the amount after a specific period. With the help of Aria’s full-fidelity metrics
    retention capability, we can compare a system’s performance and state for a past
    timeframe as long as 18 months. However, health data types such as histograms
    and span logs have a smaller retention period. We will discuss histograms and
    span logs later in the chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Aria 可以处理非常大量的数据——此外，它还可以在撰写本文时保留所有度量数据长达 18 个月。这与其他可观察性工具不同，后者要么将数据存储在较短的时间段内，要么对数据应用某种程度的聚合，以在特定时间段后减少数据量。借助
    Aria 的全保真度量数据保留能力，我们可以比较最多 18 个月的过去时段内系统的性能和状态。然而，健康数据类型（如直方图和跨度日志）有较短的保留期限。我们将在本章稍后讨论直方图和跨度日志。
- en: Writing powerful data extraction queries
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写强大的数据提取查询
- en: 'Ingesting a lot of data from various sources with a long retention period in
    a time-series database is of little use if we cannot pull it in the way we want
    with specific filters, aggregations, and correlations to other similar data points.
    Aria has a detailed query language that enables data extraction with all these
    abilities. These queries can incorporate a subset form of regular expressions
    (Regex), wildcard characters, aliases for simplified references, variables, relational
    operators, arithmetic operators, and several types of data manipulation functions.
    These functions can be categorized as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从多个来源摄取大量数据，并在时间序列数据库中保留较长时间段的数据，如果无法使用特定的筛选器、聚合和与其他类似数据点的关联来提取数据，那么这些数据几乎没有什么用处。Aria
    拥有一个详细的查询语言，使得可以具备所有这些能力的数据提取。这些查询可以包含正则表达式（Regex）的子集、通配符字符、简化引用的别名、变量、关系运算符、算术运算符以及几种类型的数据操作函数。以下是这些函数的分类：
- en: Aggregation functions such as sum, average, minimum, maximum, and many others
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合函数，如求和、平均值、最小值、最大值等
- en: Filtering and comparison functions such as between, top, bottom, random, and
    many more
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 筛选和比较函数，如区间、前几名、后几名、随机等
- en: Time operation functions such as rate, rate difference, year, month, day, and
    many more
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间操作函数，如速率、速率差异、年、月、日等
- en: Moving window functions for aggregated operations for a moving time window of
    data – for example, getting the average CPU usage of a host for the past hour
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动窗口函数，用于对移动时间窗口的数据执行聚合操作——例如，获取过去一小时内主机的平均 CPU 使用率
- en: Missing data functions to replace missing data values with specific values
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失数据函数，用于用特定值替换缺失的数据
- en: Conditional functions such as `if` blocks
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件函数，如 `if` 块
- en: Exponential and trigonometric functions such as getting square roots, exponential,
    sin, cos, and a few more
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数和三角函数，如求平方根、指数、正弦、余弦等
- en: Metadata functions temporarily renaming metrics and sources or creating a custom
    point tag on the time series of data values
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据函数，用于临时重命名度量和来源或在时间序列数据值上创建自定义标签
- en: String functions to manipulate string values
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串函数，用于操作字符串值
- en: Predictive analytical functions to predict certain values or find outliers
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测分析函数，用于预测某些值或发现异常值
- en: Histogram processing functions to manipulate ingested event data
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图处理函数，用于处理摄取的事件数据
- en: Event processing functions to manipulate ingested event data
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理函数，用于操作摄取的事件数据
- en: Distributed traces and spans functions to find and filter trace data sent by
    applications
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式追踪和跨度函数，用于查找和筛选应用程序发送的追踪数据
- en: '**Application performance index** (**Apdex**) score functions'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用性能指数**（**Apdex**）分数函数'
- en: What is an Apdex score?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Apdex分数？
- en: 'Apdex is an open standard intended to simplify reports on application performance.
    Apdex analyzes the perceived satisfaction of the application’s end user. It is
    not an APM tool. Apdex numerically scores the level of satisfaction of an end
    user based on the application responsiveness by calculating the degree to which
    user expectations compare to the performance on a fractional 0 (no users satisfied)
    to 1 (all users satisfied) scale. *Source: TechTarget.com*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Apdex是一个开放标准，旨在简化应用性能报告。Apdex分析应用程序最终用户的感知满意度。它不是一个APM工具。Apdex通过计算用户期望与性能的对比程度，在0（没有用户满意）到1（所有用户满意）的分数范围内，数字化地评分最终用户的满意度。*来源：TechTarget.com*
- en: Aria supports around 200 different functions cumulatively under these categories
    as a part of its query language, which provides a great level of flexibility to
    get what we want.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Aria在这些类别下累计支持约200种不同的函数，作为其查询语言的一部分，提供了极大的灵活性，帮助我们获取所需信息。
- en: Getting SaaS benefits
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取SaaS的好处
- en: Since Aria is a SaaS offering, we can quickly get started without heavy preparation.
    With a few steps of integration, we can start getting the value out of it – and
    like most other SaaS solutions, it also supports a *pay-as-you-go* billing model
    calculated in terms of **points per second** (**PPS**). To understand what PPS
    is, let’s review an example. Let’s say there are 6 containerized apps and each
    of them sends 10 different metrics every 60 seconds with a total of 60 metric
    data points per 60 seconds from both containers. The Kubernetes cluster where
    these containers are deployed sends 50 different metrics at a frequency of every
    10 seconds. That means we get 300 metric data points total ingested in 60 seconds
    for the cluster. Therefore, cumulatively, we have 360 data points from the cluster
    and the containers running on them in 60 seconds, so that means the data ingestion
    rate is 6 PPS (360/60). In this way, Aria calculates the total PPS applicable
    for the entire account, which is used for billing purposes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Aria是一个SaaS产品，我们可以在没有大量准备工作的情况下快速启动。通过几步集成，我们就能开始从中获得价值——像大多数其他SaaS解决方案一样，它也支持*按需计费*模型，费用以**每秒点数**（**PPS**）计算。为了理解PPS是什么，我们来看一个例子。假设有6个容器化应用，每个应用每60秒发送10个不同的指标，共计60个度量数据点来自这两个容器的每60秒。部署这些容器的Kubernetes集群每10秒发送50个不同的指标。这意味着我们在60秒内获取了300个度量数据点，总共摄取了这60秒的集群数据。因此，累计来看，来自集群和容器的数据点总数是360个数据点，也就是说数据摄取速率是6
    PPS（360/60）。这样，Aria会计算整个账户的总PPS，这将用于计费。
- en: With this, we have concluded our section explaining the potential reasons that
    make Aria a valuable tool in your toolkit when it comes to managing modern applications,
    especially running in containers. We saw how Aria helps you get full-stack visibility
    by bringing in various sources that can impact your applications. We also learned
    about its capacity to ingest a huge amount of data, retain it for a long time,
    and extract it with a comprehensive query language. In the next section, we will
    learn more about Aria including some concepts, terms, and its high-level deployment
    architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一部分，我们已经总结了为什么Aria在管理现代应用程序（尤其是在容器中运行的应用程序）时是一个宝贵工具的潜在原因。我们了解了Aria如何通过汇集可能影响应用程序的各种数据源，帮助你实现全栈可见性。我们还学习了它摄取大量数据的能力，长期保存数据，并通过全面的查询语言提取这些数据。在下一部分中，我们将进一步了解Aria，包括一些概念、术语以及其高层次的部署架构。
- en: Unboxing Aria
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解锁Aria
- en: After understanding the reasons why and the use cases for which Aria can be
    a valuable tool to comprehensively monitor your cloud-native applications, let’s
    now learn more about the tool to understand what different data formats it can
    capture, its deployment architecture, and the building blocks that comprise this
    distributed system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解Aria为何以及在何种使用场景下可以作为一个全面监控云原生应用的宝贵工具后，我们现在来更深入地了解该工具，了解它可以捕捉的不同数据格式、其部署架构以及组成该分布式系统的构建模块。
- en: Supported data formats in Aria
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aria支持的数据格式
- en: The following is the list of different data formats that Aria can ingest and
    then use to generate useful charts, dashboards, and alerts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Aria可以摄取并用于生成有用的图表、仪表板和警报的不同数据格式列表。
- en: Metrics
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指标
- en: 'A metric is a small text-based record that carries the state data of a source
    being monitored at a specific timestamp. It may optionally have other tags for
    additional metadata that can be used to build useful queries for joins and filters.
    The most common form of metrics is time-series-based. We use it to report things
    such as the amount of a server’s memory occupied at any given point in time:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 指标是一个基于文本的小记录，携带在特定时间戳下被监控源的状态数据。它还可以有其他标签作为附加元数据，用于构建有用的连接和筛选查询。最常见的指标形式是基于时间序列的。我们用它来报告服务器内存在任何给定时间点上的占用量：
- en: "![Figure 1\uFEFF0.1 – A time-series metrics chart example](img/B18145_10_01.jpg)"
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 一个时间序列指标图表示例](img/B18145_10_01.jpg)'
- en: Figure 10.1 – A time-series metrics chart example
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 一个时间序列指标图表示例
- en: '*Figure 10**.1* gives us a simple chart in Aria showing how time-series metrics
    data would look. In this case, the chart shows the CPU utilization of the nodes
    of a cluster named **kerrupt** for the given period.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.1* 向我们展示了一个简单的图表，展示了 Aria 中时间序列指标数据的显示方式。在此案例中，图表展示了一个名为**kerrupt**的集群节点在给定时间段内的
    CPU 使用情况。'
- en: 'A metric can contain a **gauge** value, which is the current value of the indicator
    for each point in time, such as the current available CPU for a server under observation.
    The values of the gauge metrics are not related to the previous values. A metric
    may also be of a **counter** type, which is an incremental value at any point
    in time, such as the number of orders placed since the counter was reset. Finally,
    a metric can also be of the **delta counter** type and report a subset value of
    a group of similar sources. For example, if you have multiple copies of a containerized
    application that processes orders, each copy of those application containers can
    report a delta value of the orders that it has processed. In these conditions,
    there is no way that one container can report the total value of the orders processed
    by all the copies of that application’s containers. In that case, Aria can group
    these delta counter values to produce a cumulative value of the total orders processed
    by the application. Learn more about metrics in Aria here: [https://docs.wavefront.com/metrics_managing.html](https://docs.wavefront.com/metrics_managing.html).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 指标可以包含**仪表**值，即每个时间点上指标的当前值，例如正在监视的服务器的当前可用 CPU。仪表指标的值与之前的值无关。指标还可以是**计数器**类型的，即在任何时间点上的增量值，例如自计数器重置以来的订单数量。最后，指标还可以是**增量计数器**类型，报告一组相似源的子集值。例如，如果你有多个容器化应用程序副本来处理订单，每个应用程序容器副本可以报告它处理的订单的增量值。在这种情况下，一个容器无法报告所有副本处理的订单的总值。在这种情况下，Aria
    可以将这些增量计数器值进行分组，生成该应用程序处理的所有订单的累计值。了解更多关于 Aria 中的指标，请参阅：[https://docs.wavefront.com/metrics_managing.html](https://docs.wavefront.com/metrics_managing.html)。
- en: Histograms
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直方图
- en: 'While Aria can receive a large number of data points per second as a whole
    system, it can only store one data point per second for a combination of a source
    and its metric name. For example, you have a load balancer in front of a very
    busy system, which receives hundreds of requests per second. In that case, if
    we send a metric value to be stored in Aria for each request, then Aria would
    be able to store only one value in its database for that metric and from that
    source. It can store multiple values in a second only if either the source or
    the metric name is different. In that case, if we want to report on the response
    time for each request, this is not possible because we can only store the response
    time of one request per second for the same source. In these cases, we can use
    histograms that show the distribution of data in a given period. In our example,
    we can report a histogram containing the distribution of requests based on their
    response times for a minute, an hour, or a day. *Figure 10**.2* shows how this
    kind of histogram would look:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Aria 可以接收系统整体每秒钟大量的数据点，但它每秒钟只能存储一个数据点，该数据点由源和其指标名称的组合决定。例如，你在一个非常繁忙的系统前面有一个负载均衡器，每秒接收数百个请求。在这种情况下，如果我们为每个请求发送一个指标值存储到
    Aria 中，那么 Aria 只能为该指标和源存储一个值。如果源或指标名称不同，它才可以在一秒内存储多个值。假如我们要报告每个请求的响应时间，这是不可能的，因为我们每秒只能存储一个请求的响应时间。对于这些情况，我们可以使用直方图，显示在给定时间段内数据的分布。在我们的例子中，我们可以报告一个包含基于响应时间分布的请求的直方图，时间范围可以是分钟、小时或一天。*图
    10.2* 显示了这种直方图的样子：
- en: "![Figure 1\uFEFF0.2 – A histogram example](img/B18145_10_02.jpg)"
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 直方图示例](img/B18145_10_02.jpg)'
- en: Figure 10.2 – A histogram example
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 直方图示例
- en: In *Figure 10**.2*, on the *y a*xis, we have the number of requests falling
    in one bracket. On the *x a*xis, we have the response time in milliseconds for
    the requests. Seeing this histogram, we can say that most of the requests fell
    between the range of 40 to 800 milliseconds in their response times. This way,
    we know what a normal acceptable range for the response time value is for these
    requests. Next time we see a greater number of requests falling within the higher
    response time bracket, we will know something is wrong there.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 10.2* 中，*y 轴*表示落在一个范围内的请求数量，*x 轴*表示这些请求的响应时间（单位为毫秒）。通过查看这个直方图，我们可以得出结论，大多数请求的响应时间落在
    40 到 800 毫秒之间。通过这种方式，我们可以知道这些请求的响应时间值的正常可接受范围。下次如果看到更多请求的响应时间落在较高的响应时间范围内，我们就会知道那里出现了问题。
- en: Events
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'In general terms, an *event* is something interesting that occurred in a system
    under observation. In the world of information technology, events can be a new
    application version rollout or an alert condition being triggered. Aria generates
    events automatically in cases of any alert being triggered. Additionally, it also
    allows you to manually create event records if required. We can see these events
    displayed in the applicable charts that are related to the event sources. For
    example, if we create an event indicating a new version of an application being
    pushed, we can clearly compare the difference in response time for the newer version
    compared to the older one, as its corresponding chart would display an event marker
    with these details of the application rollout. *Figure 10**.3* shows how Aria
    displays these events in applicable charts. As you can see, an event can also
    be a timeframe that may have a different start and a different end time:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，*事件*是指在被观察的系统中发生的某些有趣的事情。在信息技术的领域中，事件可能是一个新应用版本的发布，或者是一个警报条件被触发。Aria 会在任何警报被触发时自动生成事件。此外，如果需要，Aria
    还允许您手动创建事件记录。我们可以在与事件源相关的适用图表中看到这些事件的展示。例如，如果我们创建一个事件，表示应用程序的新版本被推送，我们可以清楚地比较新版本和旧版本在响应时间上的差异，因为其相应的图表会显示包含这些应用程序发布详情的事件标记。*图
    10.3* 显示了 Aria 如何在适用图表中展示这些事件。如您所见，事件也可以是一个时间段，可能具有不同的开始时间和结束时间：
- en: "![Figure 1\uFEFF0.3 – A chart showing events](img/B18145_10_03.jpg)"
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 显示事件的图表](img/B18145_10_03.jpg)'
- en: Figure 10.3 – A chart showing events
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 显示事件的图表
- en: As you can see, *Figure 10**.3* shows an event triggered by a warning level
    of the alert condition. The shaded part after the alert dot shows the duration
    when the alert condition is active, and the event was ongoing when the snapshot
    was taken. Ongoing events of this kind can be closed manually, closed when the
    alert condition gets resolved, or Aria closes them after 60 days.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，*图 10.3* 显示了由警报条件的警告级别触发的事件。警报点后的阴影部分显示了警报条件处于激活状态时的持续时间，而事件在快照拍摄时仍在进行中。这类持续的事件可以手动关闭，也可以在警报条件被解决时关闭，或者
    Aria 会在 60 天后自动关闭它们。
- en: Span logs
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨度日志
- en: 'At a very high level, span logs report the health of the communication channel
    between any two services in a distributed system. In the world of microservices,
    we commonly see a single user request traversing various sequential and parallel
    service calls involving many microservices and third-party systems. For example,
    in an e-commerce application, an order submission request by an end user could
    involve calls to a payment service, a payment method verification service, an
    order provisioning service, an inventory adjustment service, and a database before
    the end user gets a response. In this case, the request/response channel between
    any two microservices is called a **span**. **Span logs** can report how much
    time is taken for the request/response between any two microservices. For example,
    in this case, span logs can report the request/response duration between the order
    service and the payment service, the payment service and the payment verification
    service, and so on. When all these spans form a single request flow, it is called
    a **trace**. These are all concepts of distributed tracing, a very powerful way
    to monitor the health of microservices, especially when they are deployed in containers.
    Learn more about distributed tracing concepts here: [https://docs.wavefront.com/tracing_basics.html](https://docs.wavefront.com/tracing_basics.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，**span**日志报告了分布式系统中任意两个服务之间通信通道的健康状况。在微服务的世界里，我们通常会看到一个用户请求穿越多个顺序和并行的服务调用，涉及许多微服务和第三方系统。例如，在一个电子商务应用中，最终用户提交的订单请求可能涉及调用支付服务、支付方式验证服务、订单配置服务、库存调整服务和数据库，最终用户才能收到响应。在这种情况下，任何两个微服务之间的请求/响应通道称为**span**。**Span日志**可以报告任何两个微服务之间的请求/响应所花费的时间。例如，在这个案例中，span日志可以报告订单服务和支付服务之间的请求/响应时长，支付服务和支付验证服务之间的时长，等等。当所有这些span形成一个完整的请求流时，称之为**trace**。这些都是分布式追踪的概念，分布式追踪是一种非常强大的监控微服务健康状况的方法，特别是当它们部署在容器中时。了解更多关于分布式追踪的概念，点击这里：[https://docs.wavefront.com/tracing_basics.html](https://docs.wavefront.com/tracing_basics.html)。
- en: 'In order to provide distributed tracing for applications, Aria supports the
    **OpenTracing** ([https://opentracing.io/](https://opentracing.io/)) and **OpenTelemetry**
    ([https://opentelemetry.io/](https://opentelemetry.io/)) open source standards.
    However, OpenTracing is now an archived project, and it is recommended to use
    its better replacement – OpenTelemetry – a **Cloud Native Computing Foundation**
    (**CNCF**)-governed project. OpenTelemetry provides the tools, APIs, and SDKs
    required for applications written in different languages to publish span logs.
    Once applications send their span logs into Aria, we can get application maps
    like the one shown in *Figure 10**.4*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为应用提供分布式追踪，Aria支持**OpenTracing**（[https://opentracing.io/](https://opentracing.io/)）和**OpenTelemetry**（[https://opentelemetry.io/](https://opentelemetry.io/)）这两个开源标准。然而，OpenTracing现在已经成为一个归档项目，建议使用其更好的替代品——OpenTelemetry，它是一个由**Cloud
    Native Computing Foundation**（**CNCF**）治理的项目。OpenTelemetry提供了所需的工具、API和SDK，允许不同编程语言编写的应用程序发布span日志。一旦应用程序将其span日志发送到Aria，我们就可以得到像*图
    10.4*所示的应用地图：
- en: "![Figure 1\uFEFF0.4 – An application map example](img/B18145_10_04.jpg)"
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 一个应用地图示例](img/B18145_10_04.jpg)'
- en: Figure 10.4 – An application map example
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 一个应用地图示例
- en: '*Figure 10**.4* shows a distributed tracing map for an e-commerce application,
    where all the circles indicate the different services involved. Additionally,
    the arrows indicate the flow of requests from one service to another and the color
    of the arrows indicates the health of the systems in terms of the response time
    and error rate. Having proper span logs in Aria from all services involved can
    be very beneficial to uncover hidden performance issues in a matter of minutes.
    Learn more about other possible visualizations in Aria generated using span logs
    here: [https://docs.wavefront.com/tracing_basics.html](https://docs.wavefront.com/tracing_basics.html).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.4* 显示了一个电子商务应用的分布式追踪图，其中所有的圆圈表示不同的服务。箭头表示请求从一个服务流向另一个服务，箭头的颜色则表示系统的健康状况，具体反映了响应时间和错误率。Aria中来自所有相关服务的正确span日志，对于在几分钟内发现潜在的性能问题非常有帮助。了解更多关于Aria中使用span日志生成的其他可视化信息，点击这里：[https://docs.wavefront.com/tracing_basics.html](https://docs.wavefront.com/tracing_basics.html)。'
- en: With these four data types that Aria can ingest, including metrics, histograms,
    events, and span logs, we can get the required observability for our applications,
    their supporting systems, and the infrastructure they are running on. Let’s now
    understand a common deployment architecture pattern that allows these data points
    to be ingested in an Aria database on its SaaS cloud.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Aria可以摄取的这四种数据类型，包括指标、直方图、事件和跨度日志，我们能够获得所需的可观察性，涵盖我们的应用、它们的支持系统以及运行这些应用的基础设施。接下来，我们将理解一种常见的部署架构模式，它能够将这些数据点摄取到Aria数据库中，并部署在其SaaS云平台上。
- en: Data integration architecture of Aria
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aria的数据集成架构
- en: 'As discussed previously, Aria is a SaaS platform supported by two optional
    components – the collector agents and proxy service. *Figure 10**.5* shows a high-level
    diagram of different ways to ingest data into the system:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Aria是一个SaaS平台，支持两个可选组件——收集代理和代理服务。*图10.5*显示了不同数据摄取方式的高层次示意图：
- en: "![Figure 1\uFEFF0.5 – Data integration architecture of Aria](img/B18145_10_05.jpg)"
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – Aria的数据集成架构](img/B18145_10_05.jpg)'
- en: Figure 10.5 – Data integration architecture of Aria
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – Aria的数据集成架构
- en: Let’s understand the deployment architecture depicted in *Figure 10**.5*. This
    diagram has the following components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下*图10.5*所示的部署架构。该图包含以下几个组件。
- en: Data source
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据源
- en: 'The large circles shown on the left-hand side of the diagram are the sources
    from which the health data is collected. There could be the following types of
    sources, as shown in *Figure 10**.6*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图中左侧的大圆圈表示收集健康数据的来源。可能的来源类型如*图10.6*所示：
- en: '**Public clouds** – These are the major public cloud providers, including AWS,
    Azure, and GCP. We can configure the data flow from these cloud services using
    an account-level configuration on the Aria portal without requiring any collector
    agents on those clouds.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共云** – 这些是主要的公共云服务提供商，包括AWS、Azure和GCP。我们可以通过在Aria门户上进行账户级别配置，配置从这些云服务的流数据，而无需在这些云上配置任何收集代理。'
- en: '**Host** – This could be a hardware device, an OS, a network component, or
    anything that emits health data points, which we covered earlier. Generally, you
    cannot configure a customized endpoint for the metrics data with these components.
    They just *tweet* metrics. We need metrics collector agents for them as well that
    can then send the data to the Aria database.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机** – 这可以是硬件设备、操作系统、网络组件，或者任何发出健康数据点的东西，之前我们已经介绍过。通常，你无法为这些组件配置自定义的端点来收集指标数据。它们只是*发布*指标。我们还需要为这些组件配置指标收集代理，这些代理可以将数据发送到Aria数据库。'
- en: '**Software package** running on a host – These can be any software solution
    that is deployed on a host (server). It could be a MySQL database or a Jenkins
    server. We can collect their metrics using a collector agent that knows how to
    collect the data emitted by these software tools. We will revisit these agents
    later in this chapter.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机上运行的软件包** – 这些可以是部署在主机（服务器）上的任何软件解决方案。例如，它可能是MySQL数据库或Jenkins服务器。我们可以通过一个收集代理来收集这些软件工具发出的指标数据。稍后我们会在本章中重新讨论这些代理。'
- en: '**Custom app** codes – These can be any custom business application that sends
    custom business metrics, such as order counts or failed payments. This data can
    also include span logs for specific operations emitted by equipped applications.
    This data can be ingested into Aria from the application code using certain third-party
    libraries depending on the technology stack of the application. Micrometer ([https://micrometer.io/](https://micrometer.io/))
    is one such open source library that is widely used for custom metrics emissions
    from a Java-based application. Similarly, OpenTelemetry ([https://opentelemetry.io/](https://opentelemetry.io/))
    provides several libraries for various application technologies to emit metrics
    and span logs from custom applications.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义应用**代码 – 这些可以是任何发送自定义业务指标的业务应用，例如订单数量或失败的支付。这些数据还可以包括由配备应用发出的特定操作的跨度日志。通过应用代码，结合特定的第三方库（取决于应用的技术栈），这些数据可以被导入到Aria中。Micrometer（[https://micrometer.io/](https://micrometer.io/)）就是这样一个开源库，广泛用于Java应用中自定义指标的发射。类似地，OpenTelemetry（[https://opentelemetry.io/](https://opentelemetry.io/)）为各种应用技术提供了多个库，以便从自定义应用中发射指标和跨度日志。'
- en: '**Log files** – There are some systems that do not emit any telemetry data
    but just write them in local log files. We can also collect this data from log
    files using specific configurations in Wavefront Proxy. We will cover Wavefront
    Proxy shortly'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志文件** – 有些系统不会发布遥测数据，而是将数据写入本地日志文件。我们也可以通过在 Wavefront Proxy 中进行特定配置，从日志文件中收集这些数据。我们将很快介绍
    Wavefront Proxy。'
- en: These are all different types of sources from which we can collect telemetry
    data. While some sources can directly send data to the Aria system, for many sources,
    such as software running on servers such as databases, off-the-shelf solutions,
    or sources such as a host OS, collector agents need to gather this data and send
    it downstream. Let’s learn about them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们可以收集遥测数据的不同类型的源。虽然某些源可以直接将数据发送到 Aria 系统，但对于许多源，例如运行在服务器上的软件（如数据库）、现成解决方案，或者像主机操作系统这样的源，收集器代理需要先收集这些数据并将其发送到下游。让我们来了解一下它们。
- en: Collector agents
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集器代理
- en: As mentioned before, many sources just emit telemetry data without any knowledge
    of which system will collect them for processing. These sources often have a source
    endpoint at which they make this data available for collection. To collect this
    data from its source, filter it for the subsets not required, aggregate it when
    required, and convert it into a form that can be understood by a downstream telemetry
    visualization system such as Aria, we need a tool that can help with these requirements.
    The agents shown in *Figure 10**.6* next to the **Host** and **Software Package**
    components are there for this very same reason.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，许多源仅发布遥测数据，而不了解哪个系统将收集它们进行处理。这些源通常会在一个源端点提供数据，供收集使用。为了从源端收集这些数据，过滤掉不需要的子集，在必要时进行聚合，并将其转换为下游遥测可视化系统（如
    Aria）能够理解的形式，我们需要一个能够帮助实现这些需求的工具。下图中的代理（*图 10.6*）紧挨着**主机**和**软件包**组件，正是出于这个原因。
- en: Aria is a time-series database for ubiquitous observability that accepts data
    from different sources in a specific format that it understands. For this reason,
    Aria requires collector agents for sources that make their telemetry data available
    at a specific endpoint and require their consumers to pull it as and when required.
    While we can write custom programs that can perform this task, there is a very
    elegant out-of-the-box solution available that we can directly use as a collector
    agent – **Telegraf** ([https://github.com/influxdata/telegraf](https://github.com/influxdata/telegraf)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Aria 是一个用于普遍可观测性的时间序列数据库，它接受来自不同源的数据，并以特定的格式进行理解。因此，Aria 需要收集器代理来处理那些在特定端点提供遥测数据并需要消费者按需拉取数据的源。虽然我们可以编写自定义程序来执行此任务，但也有一个非常优雅的现成解决方案可以直接作为收集器代理使用——**Telegraf**（[https://github.com/influxdata/telegraf](https://github.com/influxdata/telegraf)）。
- en: 'Telegraf is a mature and flexible open source metrics collector agent tool
    that has a very extendable plugin-based architecture to support collecting, processing,
    and distributing telemetry data. Telegraf has the following types of plugins that
    make it a very popular and widely adopted tool:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Telegraf 是一个成熟且灵活的开源指标收集器代理工具，具有非常可扩展的基于插件的架构，支持收集、处理和分发遥测数据。Telegraf 有以下几种类型的插件，使其成为一个非常流行和广泛采用的工具：
- en: '**Input** – These plugins allow you to collect data from different source types.
    Each source has a specific plugin associated with it that can be used to collect
    its telemetry data.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入** – 这些插件允许你从不同的源类型收集数据。每个源都有一个特定的插件与之关联，能够用来收集其遥测数据。'
- en: '**Processor** – These plugins allow you to modify and filter collected data.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器** – 这些插件允许你修改和过滤收集到的数据。'
- en: '**Aggregator** – These plugins allow to aggregate data before it is sent to
    a source to reduce the volume.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合器** – 这些插件在数据发送到源之前允许进行聚合，以减少数据量。'
- en: '**Output** – These plugins are used to send data to a specific output destination.
    In our case, it is Wavefront Proxy, which we will cover next.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出** – 这些插件用于将数据发送到特定的输出目的地。在我们的案例中，目标是 Wavefront Proxy，接下来我们会详细介绍。'
- en: Aria can accept telemetry data via an HTTP API endpoint. Hence, a data source
    can always use that to ingest data in Aria. However, for sources that only make
    their health data available for collection, we need the help of tools such as
    Telegraf to fill the gap for sure – but rather than sending such data directly
    to the Aria database, it is recommended to send them via Wavefront Proxy. Let’s
    learn about Wavefront Proxy next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Aria 可以通过 HTTP API 端点接收遥测数据。因此，数据源始终可以通过此方式将数据导入 Aria。然而，对于仅提供健康数据供收集的数据源，我们需要像
    Telegraf 这样的工具来填补这个空白——但建议不要直接将这些数据发送到 Aria 数据库，而是通过 Wavefront Proxy 进行传输。接下来，我们将了解
    Wavefront Proxy。
- en: Wavefront Proxy
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Wavefront Proxy
- en: 'Wavefront Proxy is an open source tool ([https://github.com/wavefrontHQ/wavefront-proxy](https://github.com/wavefrontHQ/wavefront-proxy))
    written in Java that sits between a collector (and sometimes between the source
    directly) and the Aria database on the cloud. Although using Wavefront Proxy is
    not mandatory, it is a very useful component in Aria architecture. As a reason,
    VMware actively maintains this project. Architecturally, Wavefront is placed closer
    to the data sources. As shown in *Figure 10**.6*, several sources can share a
    single Wavefront Proxy, which could be deployed on the same host, data center,
    or private network boundary as the sources. The following are the reasons to consider
    using Wavefront Proxy, rather than sending telemetry data directly to the Aria
    database using its API endpoint:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Wavefront Proxy 是一个开源工具（[https://github.com/wavefrontHQ/wavefront-proxy](https://github.com/wavefrontHQ/wavefront-proxy)），用
    Java 编写，位于收集器（有时直接位于源与 Aria 数据库之间）与云中的 Aria 数据库之间。虽然使用 Wavefront Proxy 不是强制性的，但它是
    Aria 架构中非常有用的组件。出于这个原因，VMware 积极维护此项目。在架构上，Wavefront 靠近数据源。正如 *图 10.6* 所示，多个源可以共享一个
    Wavefront Proxy，Wavefront Proxy 可以部署在与源相同的主机、数据中心或私有网络边界上。以下是考虑使用 Wavefront Proxy
    而不是通过其 API 端点直接将遥测数据发送到 Aria 数据库的原因：
- en: Wavefront Proxy provides a layer of data protection with the ability to cache
    data in memory in case the link between the source and Aria data endpoint goes
    down, which works via the internet.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront Proxy 提供了一层数据保护，能够在源与 Aria 数据端点之间的连接中断时，将数据缓存到内存中，这一功能通过互联网实现。
- en: Wavefront Proxy batches data for the optimal use of the network bandwidth and
    an optimized transmission speed.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront Proxy 批量处理数据，以实现网络带宽的最佳利用和优化的传输速度。
- en: Wavefront Proxy provides a way to enrich data by adding more tags (key-value
    pairs) to each data record it processes. These tags can be used to fetch the details
    required for monitoring. An example of these tags could be `env=prod`, defining
    the data record as belonging to a production environment. Later, we can use this
    tag to build a chart showing only production environment data.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront Proxy 提供了一种通过向其处理的每个数据记录添加更多标签（键值对）来丰富数据的方法。这些标签可用于获取监控所需的详细信息。例如，这些标签之一可能是
    `env=prod`，定义该数据记录属于生产环境。之后，我们可以使用此标签来构建仅显示生产环境数据的图表。
- en: Wavefront Proxy allows us to massage data to modify the content if required.
    One such use case could be to hide the specific IP addresses of the sensitive
    systems to maintain the privacy of the network layout. In general, having the
    IP address of a source in its telemetry record is a useful detail that can be
    used to filter data in the same way. However, an organization may need to hide
    IP addresses as per their policy for data going into an Aria database that resides
    in a public cloud space. For this, Wavefront Proxy allows us to carry out pattern-based
    replacement in data records. This way, we can replace an IP address such as `10.1.0.2`
    with either `10.*.*.2` or `*.*.*.*` or `******`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront Proxy 允许我们修改数据内容（如有必要）。一个使用案例可能是隐藏敏感系统的特定 IP 地址，以保持网络布局的隐私。通常，在遥测记录中包含源的
    IP 地址是一个有用的细节，可以用来以相同的方式过滤数据。然而，组织可能需要根据其政策隐藏 IP 地址，以便将数据发送到位于公共云空间中的 Aria 数据库。为此，Wavefront
    Proxy 允许我们在数据记录中执行基于模式的替换。这样，我们可以将 `10.1.0.2` 这样的 IP 地址替换为 `10.*.*.2` 或 `*.*.*.*`
    或 `******`。
- en: Wavefront Proxy provides the last centralized gate that opens to the Aria service
    endpoint. If all sources send their telemetry data via the same instance of Wavefront
    Proxy, we can use that as the final checkpoint to apply common data filters and
    enrichment policies applicable to all sources.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront Proxy 提供了最后一个中央网关，打开通向 Aria 服务端点的大门。如果所有源都通过同一个 Wavefront Proxy 实例发送遥测数据，我们可以将其作为最终的检查点，应用适用于所有源的通用数据过滤和丰富策略。
- en: Since Wavefront Proxy is the last gate for the internal telemetry data before
    it reaches the Aria service endpoint, we only need to open the firewall from Wavefront
    Proxy to the Aria service over the internet. All internal sources can send their
    data to Wavefront Proxy over the private network. This reduces the network attack
    surface.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Wavefront Proxy是内部遥测数据到达Aria服务端点之前的最后一道关卡，因此我们只需在Wavefront Proxy与Aria服务之间通过互联网打开防火墙。所有内部数据源可以通过私有网络将数据发送到Wavefront
    Proxy。这有助于减少网络攻击面。
- en: In addition to the preceding benefits, there is one more that is worth a mention
    here. Very large organizations have several data centers, either in a private
    or public cloud space. At this scale, it is not advisable to have just one instance
    of Wavefront Proxy between all the sources deployed across public and private
    network spaces. As mentioned before, we should try to keep the Wavefront Proxy
    setup as close as possible to its sources so that we can take advantage of its
    data reliability and enrichment capabilities. Hence, we generally end up with
    multiple instances of Wavefront Proxy deployed that send data to the Aria SaaS
    endpoint. This kind of setup could be difficult to maintain down the line, as
    we need to maintain configuration parity between these Wavefront Proxy implementations.
    To ease this situation, we can create Wavefront Proxy chaining, where all distributed
    instances of Wavefront Proxy send their data to a centralized instance of Wavefront
    Proxy instead of directly sending the data to the Aria service endpoint. This
    way we can keep all source-specific configurations in remote Wavefront Proxy instances
    and all common configurations in the central instance of Wavefront Proxy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述的好处之外，还有一点值得在这里提及。大型组织通常有多个数据中心，可能分布在私有或公有云环境中。在这种规模下，将所有来源数据部署在公共和私有网络空间之间仅依靠一个Wavefront
    Proxy实例是不太合适的。如前所述，我们应尽量将Wavefront Proxy的设置保持尽可能接近其数据源，这样可以利用其数据可靠性和数据丰富功能。因此，通常情况下，我们会部署多个Wavefront
    Proxy实例，它们将数据发送到Aria SaaS端点。由于需要在这些Wavefront Proxy实例之间保持配置一致性，这种设置可能会在后期维护中变得困难。为了解决这个问题，我们可以创建Wavefront
    Proxy链，将所有分布式的Wavefront Proxy实例的数据发送到一个集中式的Wavefront Proxy实例，而不是直接将数据发送到Aria服务端点。通过这种方式，我们可以将所有源特定的配置保存在远程的Wavefront
    Proxy实例中，而将所有通用配置保存在集中式的Wavefront Proxy实例中。
- en: 'For more details about various deployment patterns and other details of Wavefront
    Proxy, visit this page: [https://docs.wavefront.com/proxies.html](https://docs.wavefront.com/proxies.html).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Wavefront Proxy的各种部署模式及其他细节，请访问此页面：[https://docs.wavefront.com/proxies.html](https://docs.wavefront.com/proxies.html)。
- en: The Wavefront service
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Wavefront服务
- en: In *Figure 10**.5*, the right-hand element captioned **Tanzu Observability Service**
    is nothing but the Aria SaaS platform deployed on the AWS cloud (as of the time
    of writing). This is also the component that we have been referring to as the
    Aria service endpoint. The Aria service is made of a large collection of components,
    including a portal, API endpoints, a time-series database, various data processors,
    alert engines, and several other components. We will cover working with the Aria
    portal for various operations in upcoming sections of this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.5*中，右侧的元素标注为**Tanzu Observability Service**，实际上就是部署在AWS云上的Aria SaaS平台（截至本文撰写时）。这也是我们一直提到的Aria服务端点。Aria服务由大量组件组成，包括门户、API端点、时间序列数据库、各种数据处理器、警报引擎及其他多个组件。我们将在本章接下来的部分中介绍如何在Aria门户上进行各种操作。
- en: With this, we have concluded our section on unboxing Aria. In this section,
    we saw that Aria can ingest metrics, events, histograms, and span logs to provide
    full-stack observability. Additionally, we learned about the common deployment
    architecture of Aria. There, we learned that Aria can ingest data from various
    sources, including public cloud platforms, different hosts and their OSs, and
    different software running on those hosts, including platforms such as Kubernetes,
    custom applications, and log files. Then, we learned about the collector agents’
    role and Telegraf being one of the most popular collector agents. Then, we checked
    out the role and benefits of using Wavefront Proxy in the data path. Let’s now
    see how to get started with Aria and integrate our first Kubernetes cluster with
    an Aria service account for monitoring.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经完成了关于解锁Aria的部分。在这一节中，我们看到Aria能够摄取指标、事件、直方图和跨度日志，提供全栈可观察性。此外，我们了解了Aria的常见部署架构。在此，我们了解到Aria可以从多个来源摄取数据，包括公共云平台、不同的主机及其操作系统，以及运行在这些主机上的各种软件，包括Kubernetes等平台、定制应用程序和日志文件。然后，我们了解了收集器代理的角色，Telegraf是最流行的收集器代理之一。接着，我们了解了Wavefront
    Proxy在数据路径中的角色和好处。接下来，让我们看看如何开始使用Aria，并将第一个Kubernetes集群与Aria服务账户集成进行监控。
- en: Getting started with Aria
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Aria
- en: 'In this section, we will learn about the following topics:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习以下内容：
- en: Setting up a trial account for Aria (unless you have an existing account)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Aria设置试用账户（如果你没有现有账户的话）
- en: Integrating a Kubernetes cluster with the account for monitoring
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Kubernetes集群与账户集成进行监控
- en: Accessing the default dashboards for the integrated Kubernetes cluster
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问集成的Kubernetes集群的默认仪表板
- en: Accessing the default alerts for various Kubernetes cluster conditions
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问各种Kubernetes集群条件的默认警报
- en: 'Here are the prerequisites to follow along with the outlined steps in this
    section and upcoming sections:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本节及后续章节中所需遵循的前提条件：
- en: A Kubernetes cluster with admin-level `kubectl` access
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有管理员级别`kubectl`访问权限的Kubernetes集群
- en: A workstation with `kubectl` and the `helm` CLI, access to the targeted Kubernetes
    cluster, and a web browser
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安装了`kubectl`和`helm`命令行工具、能够访问目标Kubernetes集群并具备浏览器的工作站
- en: A valid email address
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的电子邮件地址
- en: As you can see, the prerequisites are very straightforward. Let’s start by integrating
    a Kubernetes cluster with an Aria service account.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前提条件非常简单。让我们从将Kubernetes集群与Aria服务账户集成开始。
- en: Setting up a trial account
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置试用账户
- en: 'This section is optional if you already have an existing Aria service account
    that you would like to use. Otherwise, take the following steps to get started
    with a trial account of Aria without any obligations:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有现有的Aria服务账户并希望使用它，那么本节是可选的。否则，请按照以下步骤使用Aria的试用账户开始，无任何义务：
- en: Go to the [https://tanzu.vmware.com/observability](https://tanzu.vmware.com/observability)
    page.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://tanzu.vmware.com/observability](https://tanzu.vmware.com/observability)页面。
- en: 'Click on the **START FREE TRIAL** button as shown in the following screenshot:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始免费试用**按钮，如下图所示：
- en: "![Figure 1\uFEFF0.6 – Aria website](img/B18145_10_06.jpg)"
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.6 – Aria网站](img/B18145_10_06.jpg)"
- en: Figure 10.6 – Aria website
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – Aria网站
- en: 'Submit the trial account setup details as shown in the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交试用账户设置详情，如下图所示：
- en: "![Figure 1\uFEFF0.7 – Submitting the trial account setup details](img/B18145_10_07.jpg)"
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.7 – 提交试用账户设置详情](img/B18145_10_07.jpg)"
- en: Figure 10.7 – Submitting the trial account setup details
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 提交试用账户设置详情
- en: 'Configure a password for the account:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为账户配置密码：
- en: "![Figure 1\uFEFF0.8 – Configuring a trial account password](img/B18145_10_08.jpg)"
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.8 – 配置试用账户密码](img/B18145_10_08.jpg)"
- en: Figure 10.8 – Configuring a trial account password
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 配置试用账户密码
- en: 'Load the landing page as shown in the following screenshot:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载如下图所示的登录页面：
- en: "![Figure 1\uFEFF0.9 – Aria landing page on the first login](img/B18145_10_09.jpg)"
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.9 – 第一次登录时的Aria登录页面](img/B18145_10_09.jpg)"
- en: Figure 10.9 – Aria landing page on the first login
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 第一次登录时的Aria登录页面
- en: That is all. We successfully created a trial account for Aria in a few minutes
    with all its features accessible. Let’s now use this account to integrate a Kubernetes
    cluster for monitoring.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了。我们成功地在几分钟内创建了一个具有所有功能可用的Aria试用账户。现在让我们使用这个账户来集成一个Kubernetes集群进行监控。
- en: Integrating a Kubernetes cluster for monitoring
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Kubernetes集群集成到监控中
- en: 'We will use the Aria trial account created in the previous subsection to link
    an existing Kubernetes cluster to it for monitoring. Follow these steps to perform
    the integration procedure:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在前一小节中创建的 Aria 试用账户，将现有的 Kubernetes 集群与其连接以进行监控。请按照以下步骤执行集成过程：
- en: 'Click on the Kubernetes logo as highlighted in the following screenshot from
    the landing (**Get Started**) page of Aria:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击以下截图中展示的 Kubernetes 图标，该图标位于 Aria 的登录页面（**开始使用**）：
- en: "![Figure 1\uFEFF0.10 – Starting Kubernetes cluster integration](img/B18145_10_10.jpg)"
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.10 – 启动 Kubernetes 集群集成](img/B18145_10_10.jpg)"
- en: Figure 10.10 – Starting Kubernetes cluster integration
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 启动 Kubernetes 集群集成
- en: For existing non-trial accounts
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有的非试用账户
- en: You may use your existing account to do this. If you have previously accessed
    the account, based on your account configuration, you may see a different landing
    page than what is shown in the previous screenshot. In that case, go to the **Integrations**
    menu on the top navigation bar and click on **Kubernetes** from the featured group
    of integrations. On the Kubernetes integration page, go to the **Setup** tab and
    click the **ADD INTEGRATION** button to follow along.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用现有的账户来完成此操作。如果您之前访问过该账户，根据您的账户配置，您可能会看到与前面截图不同的登录页面。在这种情况下，请前往顶部导航栏中的**集成**菜单，然后点击**Kubernetes**集成组中的**Kubernetes**。在
    Kubernetes 集成页面中，前往**设置**选项卡，并点击**添加集成**按钮继续操作。
- en: 'Select the middle tile with the **Install in Kubernetes Cluster** option to
    load the setup instruction page. The setup procedure for a Tanzu Kubernetes cluster
    is pretty similar except for a few additional configurations. However, the procedure
    to integrate an OpenShift cluster is very different, but we are not covering that
    in this book:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择中间的图块，点击**在 Kubernetes 集群中安装**选项以加载设置说明页面。Tanzu Kubernetes 集群的设置过程与此非常相似，除了少数附加配置。然而，集成
    OpenShift 集群的过程非常不同，但本书不涉及此部分内容：
- en: "![Figure 1\uFEFF0.11 – Selecting the Kubernetes type for the integration](img/B18145_10_11.jpg)"
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.11 – 选择用于集成的 Kubernetes 类型](img/B18145_10_11.jpg)"
- en: Figure 10.11 – Selecting the Kubernetes type for the integration
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 选择用于集成的 Kubernetes 类型
- en: 'Follow the set of instructions given on the page to install a deployment of
    Wavefront Proxy and the metrics collector for Kubernetes provided by Aria. This
    is a quick and easy way to get started. However, it is always possible to perform
    various fine-grained configurations provided by the collector as well as Wavefront
    Proxy for a production-grade integration. Follow this documentation link to learn
    more about this: [https://docs.wavefront.com/kubernetes.html#kubernetes-manual-install](https://docs.wavefront.com/kubernetes.html#kubernetes-manual-install):'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照页面上提供的说明安装由 Aria 提供的 Wavefront Proxy 和 Kubernetes 的指标收集器。这是一种快速且简单的入门方式。然而，您始终可以执行由收集器以及
    Wavefront Proxy 提供的各种精细配置，以实现生产级集成。请参考此文档链接以了解更多：[https://docs.wavefront.com/kubernetes.html#kubernetes-manual-install](https://docs.wavefront.com/kubernetes.html#kubernetes-manual-install)：
- en: "![Figure 1\uFEFF0.12 – Kubernetes integration instructions](img/B18145_10_12.jpg)"
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.12 – Kubernetes 集成说明](img/B18145_10_12.jpg)"
- en: Figure 10.12 – Kubernetes integration instructions
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – Kubernetes 集成说明
- en: 'After running the command in *step 3*, we can see the following output. Notice
    the last line providing the URL to examine the cluster integration on the Aria
    portal:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行*第 3 步*中的命令后，我们可以看到以下输出。请注意最后一行提供了用于查看集群集成的 Aria 门户 URL：
- en: '[PRE0]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Check out the deployment of Wavefront Proxy and Wavefront collector Pods in
    the `wavefront` namespace of the targeted cluster. As you can see, there are two
    collectors, one for each Kubernetes node, and one Wavefront Proxy Pod:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查目标集群中 `wavefront` 命名空间下的 Wavefront Proxy 和 Wavefront collector Pods 部署。如图所示，集群中有两个收集器，每个
    Kubernetes 节点对应一个，以及一个 Wavefront Proxy Pod：
- en: '[PRE14]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Examine the Kubernetes integration status using the URL given in the output
    of the command described in *step 4*. You will see a page as shown in the following
    screenshot:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在*第 4 步*中命令输出中给出的 URL 检查 Kubernetes 集成状态。您将看到如下截图所示的页面：
- en: "![Figure 1\uFEFF0.13 – Kubernetes cluster summary dashboard](img/B18145_10_13.jpg)"
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.13 – Kubernetes 集群摘要仪表盘](img/B18145_10_13.jpg)"
- en: Figure 10.13 – Kubernetes cluster summary dashboard
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – Kubernetes 集群摘要仪表盘
- en: As you can see, the Aria account has been successfully integrated with an existing
    Kubernetes cluster. We can add as many clusters as required this way to centrally
    monitor them from a single window. Then, we can filter a specific cluster if required
    by its name using the dropdown labeled **cluster,** as shown in the previous screenshot’s
    top-left corner. The dashboard shown in the previous screenshot is one of the
    many out-of-the-box dashboards in Aria for Kubernetes integration. We can access
    some of them from this dashboard with a drill-down approach. Let’s check out the
    other out-of-the-box Kubernetes dashboards.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Aria 账户已成功集成到现有的 Kubernetes 集群中。我们可以按需添加任意数量的集群，并通过一个窗口集中监控它们。然后，如果需要，您可以通过使用名为**集群**的下拉菜单按名称筛选特定集群，正如前一截图左上角所示。前面截图中显示的仪表盘是
    Aria 提供的 Kubernetes 集成的许多现成仪表盘之一。我们可以通过钻取方式从此仪表盘访问其中的一些。让我们看看其他现成的 Kubernetes
    仪表盘。
- en: Accessing the default Kubernetes dashboards
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问默认的 Kubernetes 仪表盘
- en: 'In this section, we will access some additional Kubernetes dashboards that
    come by default with Aria. These dashboards immediately start showing data after
    a successful Kubernetes cluster integration. Let’s start with the first dashboard
    – **Kubernetes Summary** – that we opened in the previous section. From there,
    we will access various other dashboards:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将访问一些默认随 Aria 提供的附加 Kubernetes 仪表盘。这些仪表盘在成功集成 Kubernetes 集群后会立即开始显示数据。让我们从第一个仪表盘——**Kubernetes
    概览**——开始，该仪表盘在前一节中已打开。从那里，我们将访问其他各种仪表盘：
- en: 'To drill down to the **Kubernetes Cluster** dashboard from the **Kubernetes
    Summary** dashboard, click on the cluster name as highlighted in the following
    screenshot’s bottom-left corner:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从**Kubernetes 概览**仪表盘钻取到**Kubernetes 集群**仪表盘，请单击以下截图中左下角突出显示的集群名称：
- en: "![Figure 1\uFEFF0.14 – Drilling down to the Kubernetes cluster dashboard](img/B18145_10_14.jpg)"
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.14 – 钻取到 Kubernetes 集群仪表盘](img/B18145_10_14.jpg)"
- en: Figure 10.14 – Drilling down to the Kubernetes cluster dashboard
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 钻取到 Kubernetes 集群仪表盘
- en: 'You should see the following dashboard showing a more detailed view of the
    Kubernetes cluster. Then, click on the **Nodes** link as highlighted in the screenshot
    to open the **Kubernetes Nodes** dashboard for a detailed view of the nodes of
    that cluster. Additionally, you can find very valuable insights on all these dashboards
    when you scroll down their pages:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下仪表盘，展示了 Kubernetes 集群的更详细视图。然后，单击截图中突出显示的**节点**链接，打开**Kubernetes 节点**仪表盘，查看该集群节点的详细视图。此外，您可以在这些仪表盘的页面上滚动时找到非常有价值的见解：
- en: "![Figure 1\uFEFF0.15 – Kubernetes \uFEFFClusters dashboard](img/B18145_10_15.jpg)"
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.15 – Kubernetes 集群仪表盘](img/B18145_10_15.jpg)"
- en: Figure 10.15 – Kubernetes Clusters dashboard
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – Kubernetes 集群仪表盘
- en: 'The following screenshot shows the **Kubernetes Nodes** dashboard, which contains
    a detailed view of the nodes of the cluster to which we are drilling down. You
    can select a specific node of the cluster using the **node** dropdown as highlighted
    in the following screenshot. Additionally, you may open the **Kubernetes Pods**
    dashboard by clicking on the **Pods** link as highlighted:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下图显示了**Kubernetes 节点**仪表盘，它包含了我们正在钻取的集群节点的详细视图。您可以使用**节点**下拉菜单选择集群的特定节点，如下图所示。此外，您还可以通过单击**Pods**链接来打开**Kubernetes
    Pods**仪表盘，如下图所示：
- en: "![Figure 1\uFEFF0.16 – Kubernetes nodes dashboard](img/B18145_10_16.jpg)"
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.16 – Kubernetes 节点仪表盘](img/B18145_10_16.jpg)"
- en: Figure 10.16 – Kubernetes nodes dashboard
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – Kubernetes 节点仪表盘
- en: 'Upon clicking on the **Pods** link on the **Kubernetes Nodes** dashboard, we
    get to the **Kubernetes Pods** dashboard, as shown in the following screenshot.
    As also shown in the screenshot, you can group these Pods by several criteria.
    These groupings are very useful when we have hundreds of Pods running in a cluster.
    Additionally, we can also drill down to the **Kubernetes Containers** dashboard
    from this page as we have seen in the previous points:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Kubernetes 节点**仪表盘上的**Pods**链接后，我们进入**Kubernetes Pods**仪表盘，如下图所示。如图所示，您可以根据多个标准对这些
    Pods 进行分组。当我们在集群中运行数百个 Pods 时，这些分组非常有用。此外，我们还可以从此页面钻取到**Kubernetes 容器**仪表盘，正如我们在前面的部分中所见：
- en: "![Figure\uFEFF 1\uFEFF0.17 – Kubernetes Pods dashboard](img/B18145_10_17.jpg)"
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.17 – Kubernetes Pods 仪表盘](img/B18145_10_17.jpg)"
- en: Figure 10.17 – Kubernetes Pods dashboard
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – Kubernetes Pods 仪表盘
- en: 'In addition to all these dashboards, there are several out-of-the-box Kubernetes
    dashboards we can access using the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些仪表板外，我们还可以通过以下步骤访问多个开箱即用的 Kubernetes 仪表板：
- en: 'Click on the **Integrations** menu of the top navigation bar as shown in the
    following screenshot:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如下截图所示的顶部导航栏中的**集成**菜单：
- en: "![Figure 1\uFEFF0.18 – Opening the Integrations page](img/B18145_10_18.jpg)"
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 打开集成页面](img/B18145_10_18.jpg)'
- en: Figure 10.18 – Opening the Integrations page
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 打开集成页面
- en: 'Click on the **Kubernetes** tile as shown in the following screenshot:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如下截图所示的**Kubernetes**图块：
- en: "![Figure 1\uFEFF0.19 – Opening the Kubernetes integration tile](img/B18145_10_19.jpg)"
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – 打开 Kubernetes 集成图块](img/B18145_10_19.jpg)'
- en: Figure 10.19 – Opening the Kubernetes integration tile
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 打开 Kubernetes 集成图块
- en: 'Click on the **Dashboards** tab as highlighted in the following screenshot:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如下截图中高亮显示的**仪表板**标签：
- en: "![Figure 1\uFEFF0.20 – Opening the Kubernetes dashboard page](img/B18145_10_20.jpg)"
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – 打开 Kubernetes 仪表板页面](img/B18145_10_20.jpg)'
- en: Figure 10.20 – Opening the Kubernetes dashboard page
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 打开 Kubernetes 仪表板页面
- en: 'The following screenshot shows all the default dashboards in Aria for Kubernetes
    monitoring:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图展示了 Aria 为 Kubernetes 监控提供的所有默认仪表板：
- en: "![Figure 1\uFEFF0.21 – Default Kubernetes dashboards](img/B18145_10_21.jpg)"
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21 – 默认 Kubernetes 仪表板](img/B18145_10_21.jpg)'
- en: Figure 10.21 – Default Kubernetes dashboards
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – 默认 Kubernetes 仪表板
- en: All these out-of-the-box dashboards show useful insights using the metrics collected
    from all integrated Kubernetes clusters with an Aria account, although Aria also
    allows you to clone these dashboards and customize them to address any specific
    monitoring requirements. We can add new charts and new drill-downs, modify existing
    visualizations, rearrange different tiles, and make several other customizations
    to these default dashboards.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些开箱即用的仪表板都使用从所有集成的 Kubernetes 集群中收集的度量数据，结合 Aria 账户提供了有用的洞察，尽管 Aria 还允许你克隆这些仪表板并自定义它们，以满足任何特定的监控需求。我们可以添加新的图表和下钻功能，修改现有的可视化，重新排列不同的图块，并对这些默认仪表板进行其他多种自定义。
- en: However, dashboards are useful only when someone explicitly and carefully observes
    them to find abnormalities. People generally open them to find anomalies after
    an issue is reported. This is a reactive analysis of an issue that has already
    occurred, but we use these sophisticated tools to catch issues well in advance,
    in a proactive manner, before our customers feel the pain. For that reason, we
    have to configure alerts in these tools that notify us as soon as any abnormality
    in any health condition is observed by the monitoring system. Aria has a powerful
    alerting capability for the very same reason – and like Aria has a default set
    of ready-to-use dashboards for Kubernetes, it also comes with a set of predefined
    alert configurations for proactive Kubernetes monitoring. Let’s learn about them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仪表板只有在有人明确而仔细地观察时才能发挥作用，帮助发现异常。人们通常在报告问题后才会打开仪表板查找异常。这是一种对已发生问题的反应性分析，但我们使用这些复杂的工具，以主动的方式提前捕捉问题，防止客户感受到痛苦。因此，我们必须在这些工具中配置警报，一旦监控系统发现任何健康状态的异常，立刻通知我们。正是由于这个原因，Aria
    拥有强大的警报功能——就像 Aria 为 Kubernetes 提供了一组开箱即用的默认仪表板一样，它还配备了一组预定义的警报配置，用于主动的 Kubernetes
    监控。让我们来了解一下它们。
- en: Accessing default Kubernetes alerts
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问默认 Kubernetes 警报
- en: 'In the previous section, we explored the default dashboards that come with
    Aria for Kubernetes integration. The same is the case for a set of useful alerts
    that are supplied with Aria for Kubernetes. These alerts are configured with opinionated
    criteria. Aria allows you to customize them for various reasons. The following
    steps show how to access and configure the out-of-the-box alerts for Kubernetes
    cluster monitoring:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了 Aria 为 Kubernetes 集成提供的默认仪表板。对于 Kubernetes，Aria 还提供了一套有用的警报。这些警报是根据既定标准配置的，Aria
    允许你出于不同的原因进行自定义。以下步骤展示了如何访问和配置 Kubernetes 集群监控的开箱即用警报：
- en: 'Click on the **Alerts** tab as shown in the following screenshot:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击如下截图所示的**警报**标签：
- en: "![Figure 1\uFEFF0.22 – Opening the Kubernetes Alerts page](img/B18145_10_22.jpg)"
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – 打开 Kubernetes 警报页面](img/B18145_10_22.jpg)'
- en: Figure 10.22 – Opening the Kubernetes Alerts page
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 打开 Kubernetes 警报页面
- en: 'The following page shows all the default alerts that come with Aria for Kubernetes:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下页面展示了 Aria 为 Kubernetes 提供的所有默认警报：
- en: "![Figure 1\uFEFF0.23 – Default Kubernetes alerts](img/B18145_10_23.jpg)"
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.23 – 默认 Kubernetes 警报](img/B18145_10_23.jpg)"
- en: Figure 10.23 – Default Kubernetes alerts
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 默认 Kubernetes 警报
- en: 'Like dashboards, all these alerts are fully customizable to change their firing
    conditions and delivery mediums, such as texts, emails, PagerDuty, ServiceNow,
    Slack, and many others. We will cover more about working with alerts later in
    the chapter. For now, let’s see how to get more details about existing alerts
    and their status to see whether there are any active conditions. For that, perform
    the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 和仪表盘一样，所有这些警报都可以完全自定义，修改其触发条件和传递方式，例如文本、电子邮件、PagerDuty、ServiceNow、Slack 等。我们将在本章稍后的部分深入讲解如何使用警报。现在，让我们来看一下如何获取现有警报的更多详细信息和其状态，以查看是否存在任何活动的条件。为此，请执行以下步骤：
- en: 'Click on the **All Alerts** option under the **Alerting** menu from the top
    navigation bar as shown in the following screenshot:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部导航栏中的**所有警报**选项，位于**警报**菜单下，如下截图所示：
- en: "![Figure 1\uFEFF0.24 – Opening the Alerting page](img/B18145_10_24.jpg)"
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.24 – 打开警报页面](img/B18145_10_24.jpg)"
- en: Figure 10.24 – Opening the Alerting page
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 – 打开警报页面
- en: 'You will see a page as shown in the following screenshot listing the current
    alert conditions that are already triggered for the configured threshold or under
    active monitoring:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个页面，如下截图所示，列出已触发当前警报条件的配置阈值或正在主动监控的警报：
- en: "![Figure 1\uFEFF0.25 – Alerts page](img/B18145_10_25.jpg)"
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.25 – 警报页面](img/B18145_10_25.jpg)"
- en: Figure 10.25 – Alerts page
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 – 警报页面
- en: This concludes our section on how to get started with Aria. We learned how to
    set up a trial account to get full access to the Aria platform. Then, we integrated
    an existing Kubernetes cluster with the Aria account with a simple three-step
    procedure. Then, we saw how to access some useful out-of-the-box dashboards that
    show insightful details for the cluster with an ability to drill down to get more
    details. Finally, we saw how to access the default set of alerts that are provided
    by Aria for Kubernetes integration.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容介绍了如何开始使用 Aria。我们学习了如何设置试用账户，以便全面访问 Aria 平台。然后，我们通过简单的三步流程将现有的 Kubernetes
    集群与 Aria 账户集成。接着，我们了解了如何访问一些现成的仪表盘，这些仪表盘提供了集群的详细信息，并能深入查看以获取更多细节。最后，我们了解了如何访问
    Aria 为 Kubernetes 集成提供的默认警报集。
- en: As we know, Aria is an observability tool. The main use case of that kind of
    tool is to proactively prevent disruptive failures from happening in the first
    place, and if a failure happens for any reason, finding out the root cause quickly
    and resolving it. Monitoring dashboards and alerts are the two main capabilities
    that play key roles for these reasons. Let’s learn about them by taking a deeper
    look, starting with dashboards and charts.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Aria 是一个可观察性工具。这类工具的主要使用案例是主动防止破坏性故障的发生，并且如果发生故障，能够快速找到根本原因并解决它。监控仪表盘和警报是这两个关键功能，对于实现这一目标至关重要。让我们通过深入了解仪表盘和图表，来学习更多相关内容。
- en: Working with charts and dashboards
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图表和仪表盘
- en: 'In this section, we will cover the following details on using charts and dashboards
    in Aria:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下有关在 Aria 中使用图表和仪表盘的详细信息：
- en: Creating new custom charts to visualize any data being sent to Aria
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的自定义图表以可视化发送到 Aria 的任何数据
- en: Creating new custom dashboards using canned or custom charts
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现成或自定义图表创建新的自定义仪表盘
- en: Customizing out-of-the-box dashboards
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义现成的仪表盘
- en: Let’s get started with the topics in this list.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始介绍此列表中的主题。
- en: Creating new custom charts
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的自定义图表
- en: When we configure integration with Aria as we did for a Kubernetes cluster,
    we can see several metrics getting pushed into Aria that are collected by the
    agents that we deploy on the hosts. As with a Kubernetes cluster, we can get telemetry
    data for any integration that we make. The number of metrics and the frequency
    at which they are ingested in Aria depends on the source and the configurations
    at the collector and Wavefront Proxy. However, once the metrics data is in the
    Aria database, it stays there for up to 18 months unless explicitly removed. We
    can then use that data anytime to build on-demand charts to gain insights into
    what is going on with a source’s health.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按照为 Kubernetes 集群配置 Aria 集成时，可以看到多个度量数据被推送到 Aria，这些数据是由我们部署在主机上的代理收集的。与 Kubernetes
    集群类似，我们可以获取任何集成的遥测数据。度量的数量以及它们被 Aria 接收的频率，取决于数据源和收集器及 Wavefront 代理的配置。然而，一旦度量数据进入
    Aria 数据库，它将在那里保存最长达 18 个月，除非明确删除。我们可以随时使用这些数据，构建按需图表，以深入了解源的健康状态。
- en: 'The following steps show how to build a chart using an available metric endpoint:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用现有的度量端点构建图表：
- en: 'Click on the **Dashboard** menu from the top navigation bar and select the
    **Create** **Chart** option:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部导航栏中的**仪表盘**菜单，并选择**创建** **图表**选项：
- en: "![Figure 1\uFEFF0.26 – Selecting the Create Chart option](img/B18145_10_26.jpg)"
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.26 – 选择创建图表选项](img/B18145_10_26.jpg)'
- en: Figure 10.26 – Selecting the Create Chart option
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26 – 选择创建图表选项
- en: 'On this page, you can directly write a query in either **Wavefront Query Language**
    (**WQL**) or **Prometheus Query Language** (**PROMQL**) structures if you have
    some knowledge of either of the query languages. If you do not know either of
    them, Aria allows you to generate a query in the background by selecting the correct
    values under the dropdowns named **Data**, **Filters**, and **Functions**. Additionally,
    Aria allows you to either select metrics from the available list or use the integrations
    you have in place. Since we have a Kubernetes cluster integrated, we can see Kubernetes
    as an option to build a chart for the Kubernetes integration in the following
    screenshot. Click on the **Data** dropdown and the **Kubernetes** tile as highlighted
    in the following screenshot:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面上，如果你了解**Wavefront 查询语言**（**WQL**）或**Prometheus 查询语言**（**PROMQL**），可以直接在相应的查询语言结构中编写查询。如果你不熟悉这些语言，Aria允许你通过选择**数据**、**过滤器**和**函数**下拉框中的正确值，在后台自动生成查询。此外，Aria还允许你从可用的列表中选择度量，或使用已配置的集成。由于我们已经集成了
    Kubernetes 集群，因此可以看到 Kubernetes 作为选项，在以下屏幕截图中为 Kubernetes 集成构建图表。点击**数据**下拉框，并选择下图中高亮显示的**Kubernetes**图标：
- en: "![Figure 1\uFEFF0.27 – Selecting Kubernetes integration](img/B18145_10_27.jpg)"
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.27 – 选择 Kubernetes 集成](img/B18145_10_27.jpg)'
- en: Figure 10.27 – Selecting Kubernetes integration
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27 – 选择 Kubernetes 集成
- en: 'Select the chart data points as shown in the following screenshot:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择图表数据点，如下图所示：
- en: "![Figure 1\uFEFF0.28 – Selecting data elements for the chart](img/B18145_10_28.jpg)"
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.28 – 选择用于图表的数据元素](img/B18145_10_28.jpg)'
- en: Figure 10.28 – Selecting data elements for the chart
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.28 – 选择用于图表的数据元素
- en: 'The following chart shows a live view of the CPU usage for all Pods belonging
    to all the namespaces in all the Kubernetes clusters that we have integrated with
    the Aria account. Hence, this chart would be very clumsy if there are several
    Kubernetes clusters with several Pods running in them. We may need to implement
    certain filters to make this chart more usable. In the context of this book, there
    should only be one Kubernetes cluster, which we integrated earlier in the book:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下图表显示了所有集成了 Aria 账户的 Kubernetes 集群中所有命名空间下所有 Pod 的实时 CPU 使用情况。因此，如果有多个 Kubernetes
    集群，且每个集群中有多个 Pod 运行时，这个图表会显得非常混乱。我们可能需要实现某些过滤器，以使此图表更具可用性。在本书的背景下，应该只有一个 Kubernetes
    集群，即我们在本书中早些时候集成的集群：
- en: "![Figure 1\uFEFF0.29 – A chart showing the CPU usage of all Pods in all Kubernetes\
    \ clusters](img/B18145_10_29.jpg)"
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.29 – 显示所有 Kubernetes 集群中所有 Pod 的 CPU 使用情况的图表](img/B18145_10_29.jpg)'
- en: Figure 10.29 – A chart showing the CPU usage of all Pods in all Kubernetes clusters
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.29 – 显示所有 Kubernetes 集群中所有 Pod 的 CPU 使用情况的图表
- en: 'Apply a filter to only see the Pods running in the **wavefront** namespace
    as shown in the following screenshot. This will show the CPU usage of the Wavefront
    Collector and Wavefront Proxy Pods that we deployed earlier during the Kubernetes
    cluster integration steps:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用筛选器，仅显示如以下截图所示的在 **wavefront** 命名空间中运行的 Pods。这将显示我们在 Kubernetes 集群集成步骤中之前部署的
    Wavefront Collector 和 Wavefront Proxy Pods 的 CPU 使用情况：
- en: "![Figure 1\uFEFF0.30 – Applying filters for a chart](img/B18145_10_30.jpg)"
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.30 – 为图表应用筛选器](img/B18145_10_30.jpg)'
- en: Figure 10.30 – Applying filters for a chart
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.30 – 为图表应用筛选器
- en: 'The following screenshot shows a chart only for the Pods under the **wavefront**
    namespace. We can add more filters by clicking on the **+** button near the **Filters**
    dropdown and applying data functions to further fine-tune the chart as per the
    requirements. Click on the **SAVE** button to save this chart for future use:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图仅显示 **wavefront** 命名空间下 Pods 的图表。我们可以通过点击 **Filters** 下拉菜单旁边的 **+** 按钮，添加更多筛选器，并根据需求应用数据函数来进一步调整图表。点击
    **SAVE** 按钮以保存此图表以供将来使用：
- en: "![Figure 1\uFEFF0.31 – A chart showing CPU usage of all Pods in the wavefront\
    \ namespace](img/B18145_10_31.jpg)"
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.31 – 显示所有 Pods 在 wavefront 命名空间中 CPU 使用情况的图表](img/B18145_10_31.jpg)'
- en: Figure 10.31 – A chart showing CPU usage of all Pods in the wavefront namespace
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.31 – 显示所有 Pods 在 wavefront 命名空间中 CPU 使用情况的图表
- en: 'Now, we have a chart showing some meaningful data on how a group of Pods belonging
    to a namespace behave in terms of their CPU utilization. We can do the following
    things with this chart:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个图表，展示了属于某个命名空间的一组 Pods 在 CPU 使用率方面的一些有意义的数据。我们可以使用此图表执行以下操作：
- en: Share it with someone to show them the same view of the data so we can talk
    in the same language when discussing any performance issues
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与他人分享图表，以便在讨论任何性能问题时，我们可以用相同的语言进行交流
- en: Add this chart to either a new or an existing custom dashboard for future use
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此图表添加到新的或现有的自定义仪表板中以供将来使用
- en: Go back in time to see historical performance data for the selected time duration
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回溯查看所选时间段内的历史性能数据
- en: Mark interesting events for future reference
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记有趣的事件以供将来参考
- en: Export the chart in either a PDF or CSV format
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图表导出为 PDF 或 CSV 格式
- en: Change the visualization of the chart to get it in other graphical formats such
    as bar chart, pie chart, tabular chart, and more
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改图表的可视化方式，以获取其他图形格式，例如柱状图、饼图、表格图等
- en: Add more data layers by adding more queries
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加更多查询来增加更多数据层
- en: The following subsection focuses on various user controls that can be applied
    to a chart in Aria.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节重点介绍可以在 Aria 中应用于图表的各种用户控件。
- en: Understanding chart manipulation controls
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解图表操作控件
- en: 'The following screenshot highlights various controls with a corresponding number
    as a reference:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图突出了各种控件，并以相应的数字作为参考：
- en: "![Figure 1\uFEFF0.32 – Chart controls](img/B18145_10_32.jpg)"
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.32 – 图表控件](img/B18145_10_32.jpg)'
- en: Figure 10.32 – Chart controls
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.32 – 图表控件
- en: 'The controls in the previous screenshot are described against those numbers
    in the following list:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中的控件在下面的列表中有对应的数字描述：
- en: These controls allow you to either watch the chart with live data that keeps
    refreshing after a few seconds or select a specific timeframe in the past to pull
    data for that duration only.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些控件允许你以实时数据查看图表，该数据会在几秒钟后自动刷新，或者选择过去的特定时间段仅拉取该时段的数据。
- en: 'These controls provide ways to add more details to the chart:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些控件提供了向图表添加更多细节的方式：
- en: '**Anomaly Detection** finds specific chart patterns that are deemed unusual
    based on past data using a few artificial intelligence algorithms.'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**异常检测** 使用一些人工智能算法，基于过去的数据，找到被认为异常的特定图表模式。'
- en: '**Compare** lets you visually compare historical data for the same set of sources
    to find any pattern changes.'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**比较** 让你直观地比较相同来源集的历史数据，以发现任何模式变化。'
- en: '**Timezone** lets you change the chart’s timeline for the selected time zone.
    By default, Aria uses the internet browser’s time zone.'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**时区** 让你为所选的时区更改图表的时间线。默认情况下，Aria 使用互联网浏览器的时区。'
- en: '**Sampling** lets you turn the usage of data sampling for chart generation
    in place of considering all the data points on or off.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**抽样** 让你选择是否启用数据抽样来生成图表，而不是考虑所有的数据点。'
- en: '**Filter** allows you to reduce the data points based on the tag values supplied
    without modifying the chart’s query statement.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**筛选器** 允许你根据提供的标签值减少数据点，而无需修改图表的查询语句。'
- en: 'These controls are used for the following reasons, listed from left to right:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些控件用于以下原因，从左到右列出：
- en: Generate a link to the chart that can be shared with others
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成可以与他人共享的图表链接
- en: Prepare the chart to be embedded in a web page
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备将图表嵌入网页中
- en: Show/hide the chart variables if used
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用，显示/隐藏图表变量
- en: Flag an event point on the chart with details that generates an event log record
    for future references
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表上标记事件点，记录详细信息，生成事件日志记录以供日后参考
- en: Export the chart as either a PDF or CSV file
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图表导出为 PDF 或 CSV 文件
- en: Save the chart in either a new or an existing dashboard
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图表保存在新的或现有的仪表板中
- en: These controls allow you to zoom in and out of the chart for the selected time
    window.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些控件允许您对选定的时间窗口进行图表缩放。
- en: This control allows you to change the visualization of the chart to display
    it in different formats such as pie, bar, table, single-value, and many more.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该控件允许您更改图表的可视化方式，将其显示为不同的格式，如饼图、条形图、表格、单值图等。
- en: 'The following list describes these tabs:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下列表描述了这些标签：
- en: The **Data** tab lets you work with queries to pull chart data
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据** 标签允许您与查询一起工作，以提取图表数据'
- en: The **Format** tab allows you to modify the chart’s visual details
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**格式** 标签允许您修改图表的视觉细节'
- en: The **Axis** tab allows you to modify the chart’s axis units
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轴** 标签允许您修改图表的轴单位'
- en: The **Legend** tab allows you to configure a data legend on the chart
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图例** 标签允许您在图表上配置数据图例'
- en: The **Drilldown Link** tab allows you to configure a link to another dashboard
    showing relevant data
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下钻链接** 标签允许您配置指向显示相关数据的其他仪表板的链接'
- en: The **Description** tab allows you to set a chart description that can be seen
    in a tooltip for the chart with mouse-hover
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述** 标签允许您设置图表描述，在鼠标悬停时可以在图表的工具提示中看到'
- en: The **Anomaly Detection** tab allows you to configure related settings for its
    sensitivity, display, and data sampling
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**异常检测** 标签允许您配置与其灵敏度、显示和数据采样相关的设置'
- en: The **Advanced** tab allows you to pull obsolete metrics and configure the chart’s
    timeline with respect to its parent dashboard.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高级** 标签允许您提取过时的指标，并根据其父仪表板配置图表的时间线。'
- en: This control allows you to name a chart data layer for the query.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该控件允许您为查询命名图表数据层。
- en: These controls allow you to toggle between WQL and PROMQL, and between the query
    graphical editor and the text editor.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些控件允许您在 WQL 和 PROMQL 之间切换，以及在查询图形编辑器和文本编辑器之间切换。
- en: 'This set of controls allows you to perform the following configurations from
    left to right:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这组控件允许您从左到右执行以下配置：
- en: See query execution statistics to determine the need for query optimization
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看查询执行统计信息，以确定是否需要优化查询
- en: Clone an existing query to create a new data layer for the chart
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆现有查询以创建图表的新数据层
- en: Delete the query and its respective visual data from the chart
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图表中删除查询及其相关的可视化数据
- en: Show or hide the query data in the chart without deleting the query
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不删除查询的情况下，显示或隐藏图表中的查询数据
- en: Various other options, including alert creation based on the query and chart
    formatting
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 各种其他选项，包括基于查询创建警报和图表格式化
- en: The **ADD QUERY** link allows you to add new data and its visualization layer
    to the chart.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加查询** 链接允许您将新数据及其可视化层添加到图表中。'
- en: All these chart controls play a key role in building meaningful dashboards.
    Let’s now learn how to work with dashboards in Aria.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些图表控件在构建有意义的仪表板中起着关键作用。现在让我们来学习如何在 Aria 中使用仪表板。
- en: Creating new custom dashboards
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的自定义仪表板
- en: As we have seen earlier in this chapter, for Kubernetes integration, Aria supplies
    a set of canned dashboards that are ready to use for the telemetry data coming
    from the respective integration source. However, Aria can ingest data from various
    integrated sources including applications, Kubernetes, a hypervisor of the virtual
    infrastructure layer, an OS, databases, and several others. In that case, the
    default dashboards for a particular integration would not provide a complete picture.
    For example, none of the default Kubernetes dashboards in Aria cover charts showing
    data coming from the OS or the hardware hosts on which the nodes are deployed.
    The default and integration-specific dashboards cannot assume that the data pertaining
    to another integration will always be present. For example, in this chapter, we
    have only one integration in place for a Kubernetes cluster. Hence, if a default
    dashboard expects metrics to come from the node OSs, then it would fail. In these
    cases, we need custom dashboards that can display correlated data from multiple
    sources. Dashboards that show data from different sources could significantly
    help get a broader view of the landscape and quickly find the root causes of issues.
    A slow-running query in a database could be the cause of a slow-responding application,
    so having the details of both the layers, the application and the database, on
    one dashboard could help find the issue quickly.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所看到的，对于Kubernetes集成，Aria提供了一组现成的仪表板，能够用于来自相应集成源的遥测数据。然而，Aria可以从各种集成源获取数据，包括应用程序、Kubernetes、虚拟基础设施层的虚拟机管理程序、操作系统、数据库等。在这种情况下，特定集成的默认仪表板可能无法提供完整的视图。例如，Aria中没有任何默认的Kubernetes仪表板能够展示来自操作系统或硬件主机（即节点部署所在的主机）的数据。默认仪表板和特定集成的仪表板不能假设与其他集成相关的数据总是会存在。例如，在本章中，我们只有一个针对Kubernetes集群的集成。因此，如果默认仪表板期望从节点操作系统获取度量数据，那么它就会失败。在这种情况下，我们需要能够显示来自多个数据源的相关数据的自定义仪表板。展示来自不同数据源的数据的仪表板，可以显著帮助我们更广泛地了解系统状况，并快速找到问题的根源。数据库中的慢查询可能是导致应用程序响应迟缓的原因，因此，在同一个仪表板上显示应用程序和数据库这两个层次的详细信息，可能有助于迅速找到问题。
- en: 'There are two ways we can build custom dashboards in Aria. First, we can build
    them using custom charts that can be added to a new or existing dashboard. Second,
    we can build custom dashboards using the different templates provided in Aria
    or add custom charts to it. Let’s use the chart we built in the previous section
    to create a new dashboard. The following steps describe this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在Aria中，我们可以通过两种方式创建自定义仪表板。首先，我们可以使用自定义图表来构建新仪表板或添加到现有的仪表板中。其次，我们可以使用Aria提供的不同模板来构建自定义仪表板，或者在其中添加自定义图表。让我们使用前一节中构建的图表来创建一个新仪表板。以下步骤描述了这一过程：
- en: 'Click on the **SAVE** button, followed by the **SAVE TO A NEW DASHBOARD** button,
    as highlighted in the following screenshot:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮，然后点击**保存到新仪表板**按钮，如下图所示：
- en: "![Figure 1\uFEFF0.33 – Creating a new dashboard from a custom chart](img/B18145_10_33.jpg)"
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.33 – 从自定义图表创建新仪表板](img/B18145_10_33.jpg)"
- en: Figure 10.33 – Creating a new dashboard from a custom chart
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.33 – 从自定义图表创建新仪表板
- en: 'Enter the name of the dashboard and click on the **CREATE** button:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入仪表板的名称并点击**创建**按钮：
- en: "![Figure 1\uFEFF0.34 – Naming and creating a dashboard](img/B18145_10_34.jpg)"
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.34 – 命名和创建仪表板](img/B18145_10_34.jpg)"
- en: Figure 10.34 – Naming and creating a dashboard
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.34 – 命名和创建仪表板
- en: 'The following screenshot shows the Aria dashboard editor where the custom chart
    is now added. We can add several custom or predefined charts from the out-of-the-box
    chart templates provided by Aria for the integrations it has:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了Aria仪表板编辑器，当前已添加了自定义图表。我们可以从Aria为其集成提供的现成图表模板中添加多个自定义或预定义的图表：
- en: "![Figure 1\uFEFF0.35 – Dashboard editor](img/B18145_10_35.jpg)"
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.35 – 仪表板编辑器](img/B18145_10_35.jpg)"
- en: Figure 10.35 – Dashboard editor
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.35 – 仪表板编辑器
- en: 'The following points explain the highlighted sections in the previous screenshot
    of the dashboard editor:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点解释了前面截图中仪表板编辑器中突出显示的部分：
- en: Variables allowing you to manipulate the data in the applicable charts of the
    dashboard. These variable values can be added to the chart queries.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量允许你操作仪表板中适用图表的数据。这些变量值可以添加到图表查询中。
- en: A section is a group of similar charts in a dashboard. We can use sections to
    either show/hide charts or jump from one section to another in a very big dashboard.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个部分是仪表板中类似图表的组合。我们可以使用部分来显示/隐藏图表或在非常大的仪表板中跳转到另一个部分。
- en: These section controls allow you to add, remove, or move the sections.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些部分控件允许您添加、移除或移动部分。
- en: These arrows allow you to resize the chart to add more than one chart in a single
    row for more consolidation of data in a row.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些箭头允许您调整图表的大小，以在单行中添加多个图表，以便在一行中更好地整合数据。
- en: All these tiles allow you to add more charts to this dashboard in a selected
    section. Here, we can also import some of the existing canned charts that are
    provided by Aria for integration.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些瓷砖允许您在选定的部分向此仪表板添加更多图表。在这里，我们还可以导入由 Aria 提供的一些现有的集成罐头图表。
- en: After seeing how to create a new dashboard from scratch, let’s now see how to
    customize an out-of-the-box dashboard provided by Aria.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何从头开始创建新仪表板后，现在让我们看看如何自定义 Aria 提供的现成仪表板。
- en: Customizing a default dashboard
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义默认仪表板
- en: 'Although the default dashboards provided in Aria for different integrations
    are designed thoughtfully, there could be a few things we may like to change in
    their look and feel. In Aria, we cannot directly update a default dashboard that
    comes out of the box, but we can clone it and create a custom copy. Then, we can
    update the custom copy of the default dashboard in whatever way we need. Let’s
    see how that can be done using the following steps:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Aria 提供的不同集成的默认仪表板设计得很周到，但在外观和感觉上可能会有一些我们想要更改的地方。在 Aria 中，我们不能直接更新开箱即用的默认仪表板，但我们可以克隆它并创建自定义副本。然后，我们可以根据需要更新默认仪表板的自定义副本。让我们看看如何使用以下步骤完成这一操作：
- en: 'Click on the **All Dashboards** menu under the main **Dashboards** menu in
    the top navigation bar as shown in the following screenshot:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部导航栏中主要**仪表板**菜单下的**所有仪表板**菜单，如下面的截图所示：
- en: "![Figure 1\uFEFF0.36 – Opening the Dashboards page](img/B18145_10_36.jpg)"
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.36 – 打开仪表板页面](img/B18145_10_36.jpg)"
- en: Figure 10.36 – Opening the Dashboards page
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.36 – 打开仪表板页面
- en: 'Click on the **Kubernetes** link from the left-hand navigation bar and then
    click on the **Kubernetes Clusters** dashboard as highlighted in the following
    screenshot:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧导航栏点击**Kubernetes**链接，然后点击下面突出显示的**Kubernetes 集群**仪表板：
- en: "![Figure 1\uFEFF0.37 – Opening the Kubernetes Clusters dashboard](img/B18145_10_37.jpg)"
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.37 – 打开 Kubernetes 集群仪表板](img/B18145_10_37.jpg)"
- en: Figure 10.37 – Opening the Kubernetes Clusters dashboard
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.37 – 打开 Kubernetes 集群仪表板
- en: 'The following screenshot shows the **Kubernetes Clusters** dashboard, which
    is one of the default dashboards that comes with Aria. All default dashboards
    are marked with the highlighted lock symbol. To clone the dashboard for customization,
    click on the highlighted dots menu on the right and select the **Clone** option:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下图显示了**Kubernetes 集群**仪表板，这是 Aria 自带的默认仪表板之一。所有默认仪表板都标有突出显示的锁定符号。要克隆以进行自定义的仪表板，请点击右侧的突出显示点菜单，然后选择**克隆**选项：
- en: "![Figure 1\uFEFF0.38 – Cloning a default dashboard](img/B18145_10_38.jpg)"
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.38 – 克隆默认仪表板](img/B18145_10_38.jpg)"
- en: Figure 10.38 – Cloning a default dashboard
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.38 – 克隆默认仪表板
- en: 'Give an appropriate name to the cloned copy of the dashboard and click on the
    **CLONE** button:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给克隆的仪表板副本命名，并点击**克隆**按钮：
- en: '![Figure 10.39 – Naming the cloned dashboard ](img/B18145_10_39.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.39 – 命名克隆仪表板](img/B18145_10_39.jpg)'
- en: Figure 10.39 – Naming the cloned dashboard
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.39 – 命名克隆仪表板
- en: 'You will see the same dashboard editor that we checked out earlier allowing
    you to make any changes to the dashboard, including but not limited to changing
    chart data queries, chart visualization, rearrangement of tiles, and adding new
    data visualizations:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到与之前检查过的相同的仪表板编辑器，允许您对仪表板进行任何更改，包括但不限于更改图表数据查询、图表可视化、瓷砖重新排列和添加新的数据可视化：
- en: "![Figure 1\uFEFF0.40 – Dashboard editor](img/B18145_10_40.jpg)"
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.40 – 仪表板编辑器](img/B18145_10_40.jpg)"
- en: Figure 10.40 – Dashboard editor
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.40 – 仪表板编辑器
- en: Once you make the required changes and save this dashboard, you can then mark
    it as a favorited dashboard and put it under the quick access menu. You can also
    define who can access the dashboard for viewing and editing purposes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进行必要的更改并保存此仪表板，您可以将其标记为收藏夹仪表板，并将其放入快速访问菜单下。您还可以定义谁可以访问该仪表板进行查看和编辑。
- en: With this, we have concluded working with charts and dashboards, with a very
    high-level overview of the capabilities. For more details about charts and the
    dashboard, refer to the official product documentation – [https://docs.wavefront.com/ui_charts.html](https://docs.wavefront.com/ui_charts.html)
    and [https://docs.wavefront.com/ui_dashboards.html](https://docs.wavefront.com/ui_dashboards.html).
    In the next and last section of the chapter, we will learn about working with
    alerts.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些内容，我们已完成对图表和仪表盘的操作，并对其功能进行了非常高层次的概述。有关图表和仪表盘的更多细节，请参阅官方产品文档 – [https://docs.wavefront.com/ui_charts.html](https://docs.wavefront.com/ui_charts.html)
    和 [https://docs.wavefront.com/ui_dashboards.html](https://docs.wavefront.com/ui_dashboards.html)。在本章的下一部分，也是最后一部分，我们将学习如何处理警报。
- en: Working with alerts
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理警报
- en: 'Any monitoring tool is not complete if it does not have a good alerting capability.
    Aria is also not an exception. It has a very powerful and highly configurable
    alerting engine that allows you to configure alerts with multiple thresholds,
    delivery based on those threshold levels, and several possible delivery methods,
    including but not limited to an email, a text, a Slack message, a Microsoft Teams
    message, a ServiceNow ticket, or a PagerDuty incident. Moreover, we can also configure
    triggering an automated process using a webhook that calls a remote API outside
    of the Aria boundary. There are so many useful things we can configure using Aria’s
    alerting features. Let’s learn more about alerts in this section, including the
    following things:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 任何监控工具如果没有良好的警报功能，都是不完整的。Aria 也不例外。它拥有一个功能强大且高度可配置的警报引擎，允许你配置具有多个阈值的警报、基于这些阈值级别的传递以及多种可能的传递方法，包括但不限于电子邮件、短信、Slack
    消息、Microsoft Teams 消息、ServiceNow 工单或 PagerDuty 事件。此外，我们还可以配置通过 webhook 触发自动化流程，调用
    Aria 边界之外的远程 API。通过 Aria 的警报功能，我们可以配置许多有用的功能。让我们在本节中了解更多有关警报的内容，包括以下内容：
- en: Creating alert targets to define who should get which alert using which delivery
    mechanism
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建警报目标，定义谁应接收哪些警报，并使用何种传递机制
- en: Defining a maintenance window to avoid obvious alerts
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义维护窗口以避免显而易见的警报
- en: Creating new alerts
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的警报
- en: Inspecting firing alerts
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查触发的警报
- en: Let’s get started with these topics.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这些主题开始。
- en: Creating alert targets
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建警报目标
- en: 'An alert target in Aria contains several details and provides very flexible
    ways to define the following things at a high level:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Aria 中的警报目标包含多个细节，并提供了非常灵活的方式来高层次地定义以下内容：
- en: When the notification should be delivered and when it should be held back
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时应该发送通知以及何时应暂停发送
- en: Using which medium the alert should be delivered
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用何种媒介传递警报
- en: Who should get the alert and under what conditions
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁应该接收警报以及在什么条件下接收
- en: What details the alert should contain and in what format
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报应包含哪些详细信息及其格式
- en: 'The following steps show how to create the most common email-based alert target
    in Aria:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何在 Aria 中创建最常见的基于电子邮件的警报目标：
- en: 'Open the **Alerting** menu from the top navigation bar and select **Alert Targets**:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部导航栏打开**警报**菜单，并选择**警报目标**：
- en: "![Figure 1\uFEFF0.41 – Opening the Alert Targets list page](img/B18145_10_41.jpg)"
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.41 – 打开警报目标列表页面](img/B18145_10_41.jpg)'
- en: Figure 10.41 – Opening the Alert Targets list page
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.41 – 打开警报目标列表页面
- en: 'Click on the **CREATE ALERT** **TARGET** button:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建警报目标**按钮：
- en: "![Figure 1\uFEFF0.42 – Creating a new alert target](img/B18145_10_42.jpg)"
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.42 – 创建新的警报目标](img/B18145_10_42.jpg)'
- en: Figure 10.42 – Creating a new alert target
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.42 – 创建新的警报目标
- en: 'Enter details in the form as depicted in the following screenshot:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单中输入如下截图所示的详细信息：
- en: "![Figure 1\uFEFF0.43 – Create Alert Target page](img/B18145_10_43.jpg)"
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.43 – 创建警报目标页面](img/B18145_10_43.jpg)'
- en: Figure 10.43 – Create Alert Target page
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.43 – 创建警报目标页面
- en: 'The following are the elements in the previous screenshot as per their numbers:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述截图中的元素，按其编号排列：
- en: This is the name of the alert target. Specify a unique name here.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是警报目标的名称。请在此指定一个唯一名称。
- en: This is the description of the alert target. Specify any understandable description.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是警报目标的描述。请指定任何可理解的描述。
- en: A set of **Triggers** defines when the alert notification should be delivered
    to its destination and when it should not be. For example, it allows you to configure
    if you would like to deliver an alert notification when the alert condition is
    resolved.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组**触发器**定义了何时应该将警报通知发送到目标，何时不应该。例如，它允许你配置在警报条件解决时是否希望发送警报通知。
- en: The **Type** dropdown allows you to select one of the main three types of alert
    notification – **Email**, **PagerDuty**, and **Webhook**.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类型** 下拉菜单允许你选择三种主要的警报通知类型之一——**电子邮件**、**PagerDuty** 和 **Webhook**。'
- en: The **Default Recipient** box allows you to specify a list of email addresses
    that should receive the email notification for this alert target. The email list
    specified here will get the notification for any dataset.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**默认收件人** 框允许你指定一组应该接收此警报目标电子邮件通知的电子邮件地址。这里指定的邮件列表将接收任何数据集的通知。'
- en: The **Routing** configuration allows you to deliver the same alert notification
    to additional destinations based on the defined keys and their values. Using this
    configuration, we can configure different application teams to be notified based
    on the application identifiers in the alert data.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路由** 配置允许你根据已定义的键和值将相同的警报通知发送到额外的目的地。通过此配置，我们可以根据警报数据中的应用标识符配置不同的应用团队进行通知。'
- en: These controls allow you to configure the details in the notification. When
    this pertains to an email notification, the details are the subject and the body
    of the email. We can configure these values using variables that carry the alert-specific
    custom data in the notification.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些控件允许你配置通知中的详细信息。当这涉及到电子邮件通知时，详细信息就是邮件的主题和正文。我们可以使用包含警报特定自定义数据的变量来配置这些值。
- en: 'We can see an alert target created as shown in the following screenshot:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到已创建的警报目标，如下图所示：
- en: "![Figure 1\uFEFF0.44 – Created alert target record](img/B18145_10_44.jpg)"
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.44 – 创建的警报目标记录](img/B18145_10_44.jpg)"
- en: Figure 10.44 – Created alert target record
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.44 – 创建的警报目标记录
- en: Now, as we have an alert target for the delivery of notifications for any generated
    alert, we can use this target to deliver alerts. We can use one alert target with
    more than one alert configuration – but before we learn how to create an alert
    with a button click, let’s first learn how to configure a maintenance window to
    avoid false-positive alerts during scheduled maintenance when alert monitoring.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经有了一个用于发送任何生成的警报通知的警报目标，我们可以利用这个目标来发送警报。我们可以使用一个警报目标配合多个警报配置——但在学习如何通过点击按钮创建警报之前，让我们先学习如何配置一个维护窗口，以便在计划的维护期间避免出现误报。
- en: Defining a maintenance window
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义维护窗口
- en: 'Getting a flood of alerts during a maintenance window for systems under observation
    is not good, as we already know that things may go down or perform abnormally
    during those activities. However, in the midst of false positives during a maintenance
    window, missing a real alert that needs attention would be worse. To prevent critical
    alerts from being buried under those non-critical alerts, Aria allows you to define
    a maintenance window where we can mark certain system health parameters to be
    ignored. In this case, we can take actual alerts seriously during scheduled activities.
    The following steps show how to configure a maintenance window in Aria:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护窗口期间，对于正在观察的系统收到大量警报并不是好事，因为我们已经知道，在这些活动期间，系统可能会出现故障或表现异常。然而，在维护窗口期间，如果错过了需要关注的真实警报，那将更糟。为了防止关键警报被那些非关键警报淹没，Aria
    允许你定义一个维护窗口，在该窗口内我们可以标记某些系统健康参数为忽略。这样，我们就可以在计划的活动期间认真对待实际的警报。以下步骤展示了如何在 Aria 中配置维护窗口：
- en: 'Click on the **Alerting** menu from the top navigation bar and select the **Maintenance
    Windows** option as shown in the following screenshot:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部导航栏点击 **警报设置** 菜单，并选择 **维护窗口** 选项，如下图所示：
- en: "![Figure 1\uFEFF0.45 – Opening the Maintenance Window list page](img/B18145_10_45.jpg)"
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.45 – 打开维护窗口列表页面](img/B18145_10_45.jpg)"
- en: Figure 10.45 – Opening the Maintenance Window list page
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.45 – 打开维护窗口列表页面
- en: 'Click on the **CREATE MAINTENANCE** **WINDOW** button:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建维护窗口** 按钮：
- en: "![Figure 1\uFEFF0.46 – CREATE MAINTENANCE WINDOW](img/B18145_10_46.jpg)"
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.46 – 创建维护窗口](img/B18145_10_46.jpg)"
- en: Figure 10.46 – CREATE MAINTENANCE WINDOW
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.46 – 创建维护窗口
- en: 'Enter the required details of the maintenance window to select the time and
    the characteristics of the systems for the maintenance window as depicted in the
    following screenshot:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入维护窗口的必要详细信息，以选择时间和系统特征，如下图所示：
- en: "![Figure 1\uFEFF0.47 – Entering maintenance window details](img/B18145_10_47.jpg)"
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: "![图 1\uFEFF0.47 – 输入维护窗口详细信息](img/B18145_10_47.jpg)"
- en: Figure 10.47 – Entering maintenance window details
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.47 – 输入维护窗口详细信息
- en: 'The following numbered points describe the corresponding number in the previous
    screenshot:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下编号点描述了上一截图中的对应编号：
- en: Enter a unique name for the maintenance window record
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入维护窗口记录的唯一名称
- en: Enter a description of the maintenance window’s purpose
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入维护窗口目的的描述
- en: Either select **Now** to start the maintenance window on demand or select the
    scheduled start and end time and date to define the window
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**立即**以按需启动维护窗口，或选择计划的开始和结束时间以及日期来定义窗口
- en: Enter the source-defining parameters to cover the alerts in this maintenance
    window
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入源定义参数，以覆盖此维护窗口中的警报
- en: Select either to mute/ignore the alerts with the criteria covered in the previous
    point and during the defined time window or select an alert target to divert the
    alerts there during the window
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择是静音/忽略具有先前提到的标准的警报并在定义的时间窗口内，还是选择一个警报目标，在该时间窗口内将警报转发到该目标
- en: 'Once the **SAVE** button is clicked, the maintenance window is created, as
    shown in the following screenshot:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击**保存**按钮，维护窗口就会创建，如下图所示：
- en: "![Figure 1\uFEFF0.48 – Created maintenance window record](img/B18145_10_48.jpg)"
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.48 – 已创建的维护窗口记录](img/B18145_10_48.jpg)'
- en: Figure 10.48 – Created maintenance window record
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.48 – 已创建的维护窗口记录
- en: Now, with the maintenance record created, let’s create a custom alert record.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，维护记录已创建，让我们创建一个自定义警报记录。
- en: Creating new alerts
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新警报
- en: 'In this section, we will learn how to create a new alert. There are three ways
    we can create alerts in Aria. One of them is to create an alert using the alert
    creation wizard from the main **Alerts** menu. The second one is to duplicate
    an alert and modify the required details. The last one is to create it using an
    existing chart, usually already there on a dashboard. While the first two ways
    are more obvious, let’s learn how to create an alert using the third way, from
    an existing chart, using the following steps:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建一个新的警报。我们可以通过三种方式在 Aria 中创建警报。其中一种是通过主**警报**菜单使用警报创建向导来创建警报。第二种方式是复制一个警报并修改所需的详细信息。最后一种方式是通过使用现有图表来创建警报，通常这些图表已经存在于仪表盘上。虽然前两种方法较为直观，让我们学习如何通过第三种方法从现有图表创建警报，具体步骤如下：
- en: 'Open the **All Dashboards** page under the **Dashboards** menu on the top navigation
    bar:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部导航栏的**仪表盘**菜单下，打开**所有仪表盘**页面：
- en: "![Figure 1\uFEFF0.49 – Opening the All Dashboards page](img/B18145_10_49.jpg)"
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.49 – 打开所有仪表盘页面](img/B18145_10_49.jpg)'
- en: Figure 10.49 – Opening the All Dashboards page
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.49 – 打开所有仪表盘页面
- en: 'Click on the **Kubernetes Clusters** dashboard from the list as shown in the
    following screenshot:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中点击**Kubernetes 集群**仪表盘，如下图所示：
- en: "![Figure 1\uFEFF0.50 – Opening the Kubernetes Clusters dashboard](img/B18145_10_50.jpg)"
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.50 – 打开 Kubernetes 集群仪表盘](img/B18145_10_50.jpg)'
- en: Figure 10.50 – Opening the Kubernetes Clusters dashboard
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.50 – 打开 Kubernetes 集群仪表盘
- en: 'Click on the pencil icon on the **Node Storage Utilization Avg** chart as highlighted
    in the following screenshot. The same method of creating an alert from a chart
    can be applied to all the charts on any dashboard:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Node Storage Utilization Avg**图表上的铅笔图标，如下图所示。通过图表创建警报的相同方法可以应用于任何仪表盘上的所有图表：
- en: "![Figure 1\uFEFF0.51 – Editing a chart](img/B18145_10_51.jpg)"
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.51 – 编辑图表](img/B18145_10_51.jpg)'
- en: Figure 10.51 – Editing a chart
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.51 – 编辑图表
- en: 'Click on the **Create Alert** link under the dots menu dropdown of the query
    as shown in the following screenshot:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询的点菜单下拉菜单中点击**创建警报**链接，如下图所示：
- en: "![Figure 1\uFEFF0.52 – Creating an alert from a chart editor](img/B18145_10_52.jpg)"
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.52 – 从图表编辑器创建警报](img/B18145_10_52.jpg)'
- en: Figure 10.52 – Creating an alert from a chart editor
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.52 – 从图表编辑器创建警报
- en: As you can see on the **Create Alert** page, the query to pull alert data is
    already populated using the chart’s query. This is a big help in getting the right
    alert configuration. Let’s set up the other alert details.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在**创建警报**页面，拉取警报数据的查询已经使用图表的查询进行了填充。这对正确配置警报非常有帮助。接下来，我们设置其他警报详细信息。
- en: 'Click the **NEXT** button on the query details page as shown in the following
    screenshot. Update the alert query if required:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询详情页面点击**下一步**按钮，如下图所示。如有需要，更新警报查询：
- en: "![Figure 1\uFEFF0.53 – Updating the alert query](img/B18145_10_53.jpg)"
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.53 – 更新警报查询](img/B18145_10_53.jpg)'
- en: Figure 10.53 – Updating the alert query
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.53 – 更新警报查询
- en: 'Configure the alert conditions with different threshold levels as shown in
    the following screenshot:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置带有不同阈值级别的警报条件，如以下截图所示：
- en: "![Figure 1\uFEFF0.54 – Configuring alert conditions](img/B18145_10_54.jpg)"
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.54 – 配置警报条件](img/B18145_10_54.jpg)'
- en: Figure 10.54 – Configuring alert conditions
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.54 – 配置警报条件
- en: 'The following points correspond to the numbers mentioned in the previous screenshot
    to describe the controls:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点对应于前述截图中提到的数字，用于描述控件：
- en: These are different alert threshold values. The alert will fire with the corresponding
    severity when a certain condition is met.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是不同的警报阈值。达到某个条件时，警报会触发，并根据条件的严重性进行响应。
- en: The trigger and resolve windows define the timelines to consider a condition
    as either the start of the alert or the end of it.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发和解决窗口定义了将条件视为警报开始或结束的时间线。
- en: The additional settings provide controls to define the frequency of alert checks.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 额外的设置提供了定义警报检查频率的控件。
- en: The **TEST CONDITION** button allows you to test whether an alert would have
    triggered based on the past data of the last 2 hours to validate the configuration.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TEST CONDITION**按钮允许您测试基于过去 2 小时的数据，验证配置是否会触发警报。'
- en: 'Select an alert target that has previously been created in the account. Note
    that the following screenshot only shows one target configured for the **SMOKE**
    level, which will be applicable for all the threshold levels above it, which are
    **WARN** and **SEVERE,** too. However, it is also possible to send the alert to
    different targets for all different threshold levels. Click on the **NEXT** button
    to move forward:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个之前在账户中创建的警报目标。请注意，以下截图只显示了为**SMOKE**级别配置的一个目标，这个目标也适用于高于该级别的所有阈值级别，即**WARN**和**SEVERE**。但是，也可以为所有不同的阈值级别发送警报到不同的目标。点击**NEXT**按钮继续：
- en: "![Figure 1\uFEFF0.55 – Configuring alert targets](img/B18145_10_55.jpg)"
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.55 – 配置警报目标](img/B18145_10_55.jpg)'
- en: Figure 10.55 – Configuring alert targets
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.55 – 配置警报目标
- en: 'Configure alert details that can be helpful for its triage as shown in the
    following screenshot. Click on the **NEXT** button after that to move forward:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置可能对警报分类有帮助的详细信息，如以下截图所示。之后点击**NEXT**按钮继续：
- en: "![Figure 1\uFEFF0.56 – Configuring alert troubleshooting details](img/B18145_10_56.jpg)"
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.56 – 配置警报排查详细信息](img/B18145_10_56.jpg)'
- en: Figure 10.56 – Configuring alert troubleshooting details
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.56 – 配置警报排查详细信息
- en: 'The following points describe the controls that are marked with numbers that
    correspond to the previous screenshot:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点描述了与前述截图中标记的数字对应的控件：
- en: In **Runbook**, we can provide an external URL that contains details on how
    to troubleshoot and resolve the alert condition
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Runbook**中，我们可以提供一个外部 URL，包含有关如何排查和解决警报条件的详细信息。
- en: Under **Triage Dashboard(s)**, we can add one or more dashboards that will be
    added to the alert details to provide the required details upfront.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Triage Dashboard(s)**下，我们可以添加一个或多个仪表板，这些仪表板将被添加到警报详细信息中，提前提供所需的细节。
- en: Under **Additional Information**, we can provide any arbitrary details that
    could be helpful for troubleshooting this alert.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Additional Information**下，我们可以提供任何有助于排查此警报的任意详细信息。
- en: 'Give the alert a name and, optionally, the related tag values to identify the
    sources impacted, and click on the **ACTIVATE** button to create the alert:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给警报命名，并可以选择相关的标签值，以标识受影响的源，点击**ACTIVATE**按钮创建警报：
- en: "![Figure 1\uFEFF0.57 – Activating the alert](img/B18145_10_57.jpg)"
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.57 – 激活警报](img/B18145_10_57.jpg)'
- en: Figure 10.57 – Activating the alert
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.57 – 激活警报
- en: 'Once activated, the alert can be seen under the **Alerts** page as shown in
    the following screenshot:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦激活，警报将在**Alerts**页面下显示，如以下截图所示：
- en: "![Figure 1\uFEFF0.58 – Newly created alert](img/B18145_10_58.jpg)"
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.58 – 新创建的警报](img/B18145_10_58.jpg)'
- en: Figure 10.58 – Newly created alert
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.58 – 新创建的警报
- en: 'This concludes the details on creating new alerts in Aria. Learn more about
    creating alerts in the official product documentation if required: [https://docs.wavefront.com/alerts_manage.html](https://docs.wavefront.com/alerts_manage.html).
    Let’s now see how to find a firing alert that has an active alert condition.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在 Aria 中创建新警报的详细步骤。如果需要更多信息，请参考官方产品文档，了解如何创建警报：[https://docs.wavefront.com/alerts_manage.html](https://docs.wavefront.com/alerts_manage.html)。接下来，让我们看看如何找到具有活跃警报条件的触发警报。
- en: Inspecting firing alerts
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查触发的警报
- en: 'In this section, we will see how to list currently active alerts that are firing
    with any threshold level configured. The following steps describe this process:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何列出当前触发的警报，这些警报具有已配置的任何阈值级别。以下步骤描述了此过程：
- en: 'Click on the **FIRING** state from the left-hand navigation bar, which will
    list all the alerts under that status, and click on the name of the firing alert
    as shown in the following screenshot:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧导航栏中的**FIRING**状态，这将列出该状态下的所有警报，并点击如下截图所示的触发警报名称：
- en: "![Figure 1\uFEFF0.59 – Viewing firing alert details](img/B18145_10_59.jpg)"
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.59 – 查看触发警报的详细信息](img/B18145_10_59.jpg)'
- en: Figure 10.59 – Viewing firing alert details
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.59 – 查看触发警报的详细信息
- en: 'The following screenshot shows a view of the page that contains the details
    of the firing alerts, including other possible related alert conditions, the chart
    showing the firing duration, the query used for the calculation, and many other
    things:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了包含触发警报详细信息的页面视图，包括其他可能相关的警报条件、显示触发持续时间的图表、用于计算的查询以及许多其他内容：
- en: "![Figure 1\uFEFF0.60 – Firing alert details](img/B18145_10_60.jpg)"
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.60 – 触发警报的详细信息](img/B18145_10_60.jpg)'
- en: Figure 10.60 – Firing alert details
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.60 – 触发警报的详细信息
- en: With this, we conclude the *Working with alerts* section of the chapter. In
    this section, we started with creating alert targets and learned how we can flexibly
    define different alert notification types and destinations based on their severity
    and other attributes of the system under observation. Then, we learned how to
    create a maintenance window to treat alerts differently during a specific time
    of scheduled activities that would potentially trigger a bunch of alerts otherwise.
    After that, we learned how to create an alert using an existing chart from an
    existing dashboard. The same knowledge can be applied even to creating a new alert
    from scratch. Lastly, we saw how Aria shows different details of the alerts that
    are currently firing.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们结束了本章的*警报操作*部分。在本节中，我们从创建警报目标开始，学习了如何根据警报的严重性及系统的其他属性灵活定义不同的警报通知类型和目标。接着，我们学习了如何创建维护窗口，以便在计划的活动期间以不同的方式处理警报，否则这些活动可能会触发大量警报。之后，我们学习了如何使用现有仪表板中的现有图表创建警报。同样的知识也适用于从头创建新的警报。最后，我们了解了
    Aria 如何显示当前触发的警报的不同详细信息。
- en: Summary
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we learned about a very important component of the Tanzu product
    portfolio, VMware Aria Operations for Applications by Wavefront. In the first
    section of the chapter, we gave various reasons explaining the importance of this
    tool in terms of the observability of modern containerized applications. In this
    section, we learned about different out-of-the-box integrations supported by Aria.
    We also discussed how Telegraf collectors and the Wavefront SDK make it possible
    to integrate almost any data source for observability. Additionally, we discussed
    other benefits of Aria, including the high-speed data collection and processing
    power, and the ability to collect different telemetry data types including metrics,
    events, histograms, and span logs. Then, we listed different categories of data
    processing functions that can be used with WQL, including data aggregation, filtering,
    time operations, moving-window aggregation, exponential, and trigonometric.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Tanzu 产品组合中的一个非常重要的组件——VMware Aria Operations for Applications by
    Wavefront。在本章的第一部分，我们提供了多个理由，解释了该工具在现代容器化应用程序可观察性中的重要性。在本节中，我们了解了 Aria 支持的不同开箱即用的集成。我们还讨论了
    Telegraf 收集器和 Wavefront SDK 如何使集成几乎任何数据源成为可能，以实现可观察性。此外，我们讨论了 Aria 的其他优点，包括高速数据收集和处理能力，以及收集不同类型遥测数据的能力，包括指标、事件、直方图和跨度日志。然后，我们列出了可以与
    WQL 一起使用的不同类别的数据处理功能，包括数据聚合、过滤、时间操作、移动窗口聚合、指数运算和三角运算。
- en: After that, we learned about various components of the solution. We explored
    metrics, histograms, span logs, and events. We then discussed the common deployment
    architecture of the solution and the details of various components with their
    roles. In that part, we discussed various ways to ingest data in Aria, different
    types of sources, collectors, Wavefront Proxy, and the Wavefront service, a SaaS
    platform. Later in the chapter, we learned how to open a trial account for Aria
    and integrate an existing Kubernetes cluster with the account. Then, we saw how
    to access a set of default dashboards for Kubernetes integration provided by Aria
    out of the box. Lastly, we learned about creating custom charts, dashboards, and
    alerts for the integrations in place.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，我们了解了该解决方案的各个组件。我们探索了度量标准、直方图、跨度日志和事件。接着，我们讨论了该解决方案的常见部署架构以及各个组件的详细信息和它们的角色。在那部分内容中，我们讨论了如何在
    Aria 中摄取数据的不同方式、不同类型的来源、采集器、Wavefront 代理以及 Wavefront 服务，一个SaaS平台。随后，我们学习了如何为 Aria
    开通试用账户，并将现有的 Kubernetes 集群与该账户进行集成。然后，我们看到如何访问 Aria 开箱即用的 Kubernetes 集成的默认仪表盘。最后，我们学习了如何为现有集成创建自定义图表、仪表盘和警报。
- en: Although it seems like we covered the solution in great depth, we just scratched
    the surface. There are still several more capabilities we could not cover in this
    chapter, as we only covered the details centered around Kubernetes monitoring.
    Besides the details covered here, Aria has a great set of capabilities for APM
    using the ingested span logs and application health metrics. We could not even
    cover topics such as derived metrics, delta counters, user permission configuration,
    and external logging solution integration because of the limited scope of this
    chapter.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来我们已经深入探讨了解决方案，但我们只触及了表面。由于本章的内容仅围绕 Kubernetes 监控展开，因此仍有许多功能未能涵盖。除了这里讨论的内容，Aria
    还提供了基于摄取的跨度日志和应用健康度指标的 APM 强大功能。我们甚至没有涉及到派生指标、增量计数器、用户权限配置以及外部日志解决方案集成等主题，因为本章的范围有限。
- en: In the next chapter, we will see how to securely connect various applications
    deployed in different Kubernetes clusters, even across different cloud infrastructures,
    using Tanzu Service Mesh.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用 Tanzu 服务网格安全地连接部署在不同 Kubernetes 集群中的各种应用，甚至跨越不同的云基础设施。
