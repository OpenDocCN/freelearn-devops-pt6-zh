- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Realizing Full-Stack Visibility with VMware Aria Operations for Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned how we can use Tanzu Mission Control to manage
    hundreds of Kubernetes clusters for their lifecycle management, policy control,
    and data protection. Tanzu Mission Control is a single point of control for all
    these concerns for Kubernetes. In this chapter, we will talk about a central point
    of visibility for your cloud-native apps running in containers, along with all
    other supporting layers and systems around them. Knowing the vital health status
    of your systems is a very old and essential concept in the world of information
    technology that is known as *monitoring*. It is also known as telemetry. The tools
    we used for years to monitor traditional monolithic applications would not yield
    the required results when it comes to monitoring microservices running on different
    clusters, platforms, and clouds. With microservices, the world is very distributed.
    Typically, microservices run in containers, and containers are ephemeral – they
    quickly come and go. In that scenario, the continuity of a microservice’s context
    becomes very important, as they could be running in a different container after
    a few minutes, unlike traditional apps that would not leave their virtual and
    physical host for years. Adding more to this complexity of running microservices,
    they have to deal with substantial cardinality, including the larger apps they
    belong to, the environments they are deployed to, and the node, cluster, availability
    zone, and regions they are deployed to, among other things. We need a different
    approach to monitor them, as they run differently. To some extent, deploying apps
    in containers is like sending a spacecraft on a Mars mission. We don’t know where
    the container will physically end up – we can only rely on the health vitals that
    it emits at a regular frequency and course-correct if required. Traditional monitoring
    tools would not have helped in these conditions. When we have millions of transactions,
    thousands of containers, hundreds of nodes, and tens of data centers, we need
    powerful observability. VMware Aria Operations for Applications (formerly known
    as Tanzu Observability by Wavefront) is the tool in the Tanzu portfolio that addresses
    this need for modern application management.
  prefs: []
  type: TYPE_NORMAL
- en: 'In May 2017, VMware acquired Wavefront, a privately held company in Palo Alto,
    California. The power of Wavefront comes from its ability to ingest millions of
    metrics and other data points coming from hundreds of locations in real time and
    render point-in-time charts and alerts for correlated visibility. Later, Wavefront
    became a part of the Tanzu portfolio to add an essential piece of the puzzle to
    the mix – observability. Hence, any reference to Wavefront in this chapter or
    the standard product documentation refers to VMware Aria Operations for Applications.
    For brevity, we will refer to it as *Aria* in this chapter and will cover it in
    detail with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Aria?** – covering various features and capabilities of this tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unboxing Aria** – covering key concepts, components, and the common deployment
    architecture of the tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getting started with Aria** – covering the integration of a Kubernetes cluster
    and an application with the tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with charts and dashboards** – covering a high-level understanding
    of building charts and creating new dashboards with the tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with alerts** – covering the details of how to create, manage, and
    observe alerts with the tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several other facets of Aria that we have to skip to keep the chapter
    at an acceptable length. Aria is a very powerful tool that can perform various
    operations around observability and **application performance management** (**APM**),
    but considering the broader scope of the book, we will only cover the details
    related to microservices, containers, and Kubernetes monitoring. With that understanding,
    let’s begin our journey of observability.
  prefs: []
  type: TYPE_NORMAL
- en: Why Aria?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aria is an observability tool rather than a monitoring tool. A monitoring tool
    can tell you that an application is running slowly, but an observability tool
    can help you find the root cause for the application being slow. This is because
    it allows you to correlate the health indicators coming from all the surrounding
    components that could impact an application’s performance. It could be an issue
    at the **operating system** (**OS**) layer or a slow-running query in a database.
    The main strength of an observability tool is its ability to ingest data points
    from all possible systems and layers and for all different health indicators that
    could make a significant event. It then allows you to find the needle in the haystack
    by reducing the noise of irrelevant data by applying correlation formulas to the
    collected data. An observability tool can help you identify abnormal traffic patterns,
    latencies, error rates, and many more attributes, based on historical data patterns.
    For example, the average request rate per second for an application during the
    midnight hours would be different from that during the day generally. Hence, an
    observability tool could alert you if it saw an abnormal request rate for an application
    depending on the timeframe. The abilities of these tools help identify anomalies
    long before they become too-late, expensive discoveries.
  prefs: []
  type: TYPE_NORMAL
- en: With the rise of microservices and containerized platforms, *observability*
    has become a buzzword in recent times. There are various open source and commercial
    solutions available on the market offering somewhat similar capabilities in this
    space. Like other chapters, the idea of this section is not to compare Aria with
    any other observability tool, but to highlight what makes Aria a compelling choice
    with its own unique capabilities. Let’s look at some of the points in this regard
    to answer *Why Aria?*
  prefs: []
  type: TYPE_NORMAL
- en: Integrating (almost) anything
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed before, the power of observability depends on the data being ingested
    from various layers and the tools supporting critical business systems. For this,
    we may need to ingest metrics, events, histograms, and logs from many different
    systems. They could be various infrastructure platforms such as **Amazon Web Services**
    (**AWS**) or Azure public clouds; on-premises vSphere stacks; OSs such as Windows,
    Ubuntu, Photon, or RedHat; middleware layers such as the Tomcat server; Spring
    Boot- and NodeJS-like application frameworks; various caches; RDBMSes; NoSQL and
    queues as data sources; and several other components for alerting, containerization,
    visualization, end user analytics, and so on. To cater to this need, Aria supports
    over 250 integrations out of the box. These integrations are well documented to
    aid self-help configuration. Many popular integrations such as Kubernetes, popular
    public cloud services, and application frameworks come with canned sets of dashboards
    and alerts, facilitating the quick value realization of these integrations. With
    these out-of-the-box dashboards and alerts, users can see meaningful data within
    a few minutes of it starting to flow in. The following are the categories of the
    out-of-the-box integrations with Aria:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application platforms such as .NET, Tomcat, and nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud services of AWS, Azure, and **Google Cloud** **Platform** (**GCP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data stores such as PostgreSQL, Redis, Cassandra, and Oracle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps tools such as Jenkins, GitHub, Chef, Ansible, and Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging platforms such as RabbitMQ and Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring tools such as AppDynamics, Dynatrace, and Prometheus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OSs such as different flavors of Linux, Windows, and macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application frameworks such as Spring Boot, Python, Go, and Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alerting systems such as PagerDuty, ServiceNow, and Slack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication providers such as Okta, Google, and Microsoft Active Directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is not comprehensive. There are various tools in each category beyond
    those listed here. On top of that, Aria has an extendable framework that allows
    you to pull in metrics and other health indicators from any system using its plugin-based
    model and a **software development kit** (**SDK**). As we will see later in the
    chapter, Aria can get metrics from most systems using an open source metrics collection
    agent named **Telegraf** ([https://github.com/influxdata/telegraf](https://github.com/influxdata/telegraf)).
    Telegraf has a long list of plugins that make it very extendable. For the data
    sources not available as integrations in Aria out of the box, we can create custom
    integrations with minimal effort. Additionally, in case an out-of-the-box plugin
    is not available to ingest data from the source, it can be custom-developed using
    the Aria SDK. Visit [https://docs.wavefront.com/wavefront_sdks.html](https://docs.wavefront.com/wavefront_sdks.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting full-stack visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever realized that when you ran an application in containers, how many
    different layers were below and around that application? An application is wrapped
    in a container. In Kubernetes, one or more containers are wrapped in a Pod. These
    Pods are a part of a Kubernetes node. A node is often a virtual machine that is
    running on top of a hypervisor such as vSphere. The hypervisor sits on top of
    physical hosts. These physical hosts are parts of some rack in a data center somewhere
    in the world. Additionally, the application could be using external services,
    such as other dependency apps, an application runtime such as the Tomcat server
    or Java Runtime Environment, a database, possibly a cache, a messaging queue such
    as RabbitMQ or Kafka, and many other supporting services. When we need to monitor
    an environment of many containers, monitoring all these layers below applications
    and their supporting services becomes crucial to quickly find out the root cause
    of failures and quickly address them. This is made possible when you have the
    ability to collect health vitals from all these sources and visualize them meaningfully
    or establish an alerting system using a single tool. **Site reliability engineering**
    (**SRE**) teams often struggle when there are different tools for monitoring different
    systems, such as a separate tool for application monitoring, a separate tool for
    Kubernetes monitoring, a separate tool for virtual infrastructure monitoring,
    and so on. When we have several monitoring tools to investigate during an outage
    situation, making sense of the health data available becomes very difficult and
    results in a loss of context. This happens because different tools use different
    methods of rendering the collected health data and the teams using them use different
    terms and language. In these conditions, a common way to filter the metrics collected
    for a specific timeframe and other conditions for all the sources potentially
    affected can quickly help corner an issue. This way, we can quickly point out
    that a slow-running application in a container is actually being slowed down by
    a high CPU host temperature condition.
  prefs: []
  type: TYPE_NORMAL
- en: Since Aria can collect health data from almost any source, we can create custom
    dashboards for custom applications and display health vitals from all the surrounding
    components related to the application. This way, you can see the memory utilization
    of an application’s container and of the Kubernetes node on which the container
    is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Ingesting high-volume data in real time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aria is a very powerful cloud-based SaaS streaming analytics platform that is
    highly scalable and efficient at collecting a very large amount of data. Because
    of its design, it can potentially support collecting over a million data points
    per second. Once this data is collected, we can see it live in its respective
    monitoring dashboards and it can be used to calculate any preconfigured alert
    conditions with Aria’s powerful query engine to pull ingested data in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Retaining full-fidelity data for a long time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed previously, Aria can ingest a very large volume of data – but
    additionally, it can also retain all metrics data for 18 months as of the time
    of writing. This is unlike other observability tools that either store this data
    for a shorter time period or with some level of aggregation applied to it to reduce
    the amount after a specific period. With the help of Aria’s full-fidelity metrics
    retention capability, we can compare a system’s performance and state for a past
    timeframe as long as 18 months. However, health data types such as histograms
    and span logs have a smaller retention period. We will discuss histograms and
    span logs later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing powerful data extraction queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ingesting a lot of data from various sources with a long retention period in
    a time-series database is of little use if we cannot pull it in the way we want
    with specific filters, aggregations, and correlations to other similar data points.
    Aria has a detailed query language that enables data extraction with all these
    abilities. These queries can incorporate a subset form of regular expressions
    (Regex), wildcard characters, aliases for simplified references, variables, relational
    operators, arithmetic operators, and several types of data manipulation functions.
    These functions can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation functions such as sum, average, minimum, maximum, and many others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and comparison functions such as between, top, bottom, random, and
    many more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time operation functions such as rate, rate difference, year, month, day, and
    many more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving window functions for aggregated operations for a moving time window of
    data – for example, getting the average CPU usage of a host for the past hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing data functions to replace missing data values with specific values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional functions such as `if` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exponential and trigonometric functions such as getting square roots, exponential,
    sin, cos, and a few more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata functions temporarily renaming metrics and sources or creating a custom
    point tag on the time series of data values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String functions to manipulate string values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictive analytical functions to predict certain values or find outliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Histogram processing functions to manipulate ingested event data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event processing functions to manipulate ingested event data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed traces and spans functions to find and filter trace data sent by
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application performance index** (**Apdex**) score functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an Apdex score?
  prefs: []
  type: TYPE_NORMAL
- en: 'Apdex is an open standard intended to simplify reports on application performance.
    Apdex analyzes the perceived satisfaction of the application’s end user. It is
    not an APM tool. Apdex numerically scores the level of satisfaction of an end
    user based on the application responsiveness by calculating the degree to which
    user expectations compare to the performance on a fractional 0 (no users satisfied)
    to 1 (all users satisfied) scale. *Source: TechTarget.com*'
  prefs: []
  type: TYPE_NORMAL
- en: Aria supports around 200 different functions cumulatively under these categories
    as a part of its query language, which provides a great level of flexibility to
    get what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Getting SaaS benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Aria is a SaaS offering, we can quickly get started without heavy preparation.
    With a few steps of integration, we can start getting the value out of it – and
    like most other SaaS solutions, it also supports a *pay-as-you-go* billing model
    calculated in terms of **points per second** (**PPS**). To understand what PPS
    is, let’s review an example. Let’s say there are 6 containerized apps and each
    of them sends 10 different metrics every 60 seconds with a total of 60 metric
    data points per 60 seconds from both containers. The Kubernetes cluster where
    these containers are deployed sends 50 different metrics at a frequency of every
    10 seconds. That means we get 300 metric data points total ingested in 60 seconds
    for the cluster. Therefore, cumulatively, we have 360 data points from the cluster
    and the containers running on them in 60 seconds, so that means the data ingestion
    rate is 6 PPS (360/60). In this way, Aria calculates the total PPS applicable
    for the entire account, which is used for billing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have concluded our section explaining the potential reasons that
    make Aria a valuable tool in your toolkit when it comes to managing modern applications,
    especially running in containers. We saw how Aria helps you get full-stack visibility
    by bringing in various sources that can impact your applications. We also learned
    about its capacity to ingest a huge amount of data, retain it for a long time,
    and extract it with a comprehensive query language. In the next section, we will
    learn more about Aria including some concepts, terms, and its high-level deployment
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Unboxing Aria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After understanding the reasons why and the use cases for which Aria can be
    a valuable tool to comprehensively monitor your cloud-native applications, let’s
    now learn more about the tool to understand what different data formats it can
    capture, its deployment architecture, and the building blocks that comprise this
    distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: Supported data formats in Aria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is the list of different data formats that Aria can ingest and
    then use to generate useful charts, dashboards, and alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A metric is a small text-based record that carries the state data of a source
    being monitored at a specific timestamp. It may optionally have other tags for
    additional metadata that can be used to build useful queries for joins and filters.
    The most common form of metrics is time-series-based. We use it to report things
    such as the amount of a server’s memory occupied at any given point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.1 – A time-series metrics chart example](img/B18145_10_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A time-series metrics chart example
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.1* gives us a simple chart in Aria showing how time-series metrics
    data would look. In this case, the chart shows the CPU utilization of the nodes
    of a cluster named **kerrupt** for the given period.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A metric can contain a **gauge** value, which is the current value of the indicator
    for each point in time, such as the current available CPU for a server under observation.
    The values of the gauge metrics are not related to the previous values. A metric
    may also be of a **counter** type, which is an incremental value at any point
    in time, such as the number of orders placed since the counter was reset. Finally,
    a metric can also be of the **delta counter** type and report a subset value of
    a group of similar sources. For example, if you have multiple copies of a containerized
    application that processes orders, each copy of those application containers can
    report a delta value of the orders that it has processed. In these conditions,
    there is no way that one container can report the total value of the orders processed
    by all the copies of that application’s containers. In that case, Aria can group
    these delta counter values to produce a cumulative value of the total orders processed
    by the application. Learn more about metrics in Aria here: [https://docs.wavefront.com/metrics_managing.html](https://docs.wavefront.com/metrics_managing.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While Aria can receive a large number of data points per second as a whole
    system, it can only store one data point per second for a combination of a source
    and its metric name. For example, you have a load balancer in front of a very
    busy system, which receives hundreds of requests per second. In that case, if
    we send a metric value to be stored in Aria for each request, then Aria would
    be able to store only one value in its database for that metric and from that
    source. It can store multiple values in a second only if either the source or
    the metric name is different. In that case, if we want to report on the response
    time for each request, this is not possible because we can only store the response
    time of one request per second for the same source. In these cases, we can use
    histograms that show the distribution of data in a given period. In our example,
    we can report a histogram containing the distribution of requests based on their
    response times for a minute, an hour, or a day. *Figure 10**.2* shows how this
    kind of histogram would look:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.2 – A histogram example](img/B18145_10_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – A histogram example
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10**.2*, on the *y a*xis, we have the number of requests falling
    in one bracket. On the *x a*xis, we have the response time in milliseconds for
    the requests. Seeing this histogram, we can say that most of the requests fell
    between the range of 40 to 800 milliseconds in their response times. This way,
    we know what a normal acceptable range for the response time value is for these
    requests. Next time we see a greater number of requests falling within the higher
    response time bracket, we will know something is wrong there.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general terms, an *event* is something interesting that occurred in a system
    under observation. In the world of information technology, events can be a new
    application version rollout or an alert condition being triggered. Aria generates
    events automatically in cases of any alert being triggered. Additionally, it also
    allows you to manually create event records if required. We can see these events
    displayed in the applicable charts that are related to the event sources. For
    example, if we create an event indicating a new version of an application being
    pushed, we can clearly compare the difference in response time for the newer version
    compared to the older one, as its corresponding chart would display an event marker
    with these details of the application rollout. *Figure 10**.3* shows how Aria
    displays these events in applicable charts. As you can see, an event can also
    be a timeframe that may have a different start and a different end time:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.3 – A chart showing events](img/B18145_10_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – A chart showing events
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, *Figure 10**.3* shows an event triggered by a warning level
    of the alert condition. The shaded part after the alert dot shows the duration
    when the alert condition is active, and the event was ongoing when the snapshot
    was taken. Ongoing events of this kind can be closed manually, closed when the
    alert condition gets resolved, or Aria closes them after 60 days.
  prefs: []
  type: TYPE_NORMAL
- en: Span logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At a very high level, span logs report the health of the communication channel
    between any two services in a distributed system. In the world of microservices,
    we commonly see a single user request traversing various sequential and parallel
    service calls involving many microservices and third-party systems. For example,
    in an e-commerce application, an order submission request by an end user could
    involve calls to a payment service, a payment method verification service, an
    order provisioning service, an inventory adjustment service, and a database before
    the end user gets a response. In this case, the request/response channel between
    any two microservices is called a **span**. **Span logs** can report how much
    time is taken for the request/response between any two microservices. For example,
    in this case, span logs can report the request/response duration between the order
    service and the payment service, the payment service and the payment verification
    service, and so on. When all these spans form a single request flow, it is called
    a **trace**. These are all concepts of distributed tracing, a very powerful way
    to monitor the health of microservices, especially when they are deployed in containers.
    Learn more about distributed tracing concepts here: [https://docs.wavefront.com/tracing_basics.html](https://docs.wavefront.com/tracing_basics.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to provide distributed tracing for applications, Aria supports the
    **OpenTracing** ([https://opentracing.io/](https://opentracing.io/)) and **OpenTelemetry**
    ([https://opentelemetry.io/](https://opentelemetry.io/)) open source standards.
    However, OpenTracing is now an archived project, and it is recommended to use
    its better replacement – OpenTelemetry – a **Cloud Native Computing Foundation**
    (**CNCF**)-governed project. OpenTelemetry provides the tools, APIs, and SDKs
    required for applications written in different languages to publish span logs.
    Once applications send their span logs into Aria, we can get application maps
    like the one shown in *Figure 10**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.4 – An application map example](img/B18145_10_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – An application map example
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.4* shows a distributed tracing map for an e-commerce application,
    where all the circles indicate the different services involved. Additionally,
    the arrows indicate the flow of requests from one service to another and the color
    of the arrows indicates the health of the systems in terms of the response time
    and error rate. Having proper span logs in Aria from all services involved can
    be very beneficial to uncover hidden performance issues in a matter of minutes.
    Learn more about other possible visualizations in Aria generated using span logs
    here: [https://docs.wavefront.com/tracing_basics.html](https://docs.wavefront.com/tracing_basics.html).'
  prefs: []
  type: TYPE_NORMAL
- en: With these four data types that Aria can ingest, including metrics, histograms,
    events, and span logs, we can get the required observability for our applications,
    their supporting systems, and the infrastructure they are running on. Let’s now
    understand a common deployment architecture pattern that allows these data points
    to be ingested in an Aria database on its SaaS cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Data integration architecture of Aria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed previously, Aria is a SaaS platform supported by two optional
    components – the collector agents and proxy service. *Figure 10**.5* shows a high-level
    diagram of different ways to ingest data into the system:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.5 – Data integration architecture of Aria](img/B18145_10_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Data integration architecture of Aria
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the deployment architecture depicted in *Figure 10**.5*. This
    diagram has the following components.
  prefs: []
  type: TYPE_NORMAL
- en: Data source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The large circles shown on the left-hand side of the diagram are the sources
    from which the health data is collected. There could be the following types of
    sources, as shown in *Figure 10**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public clouds** – These are the major public cloud providers, including AWS,
    Azure, and GCP. We can configure the data flow from these cloud services using
    an account-level configuration on the Aria portal without requiring any collector
    agents on those clouds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host** – This could be a hardware device, an OS, a network component, or
    anything that emits health data points, which we covered earlier. Generally, you
    cannot configure a customized endpoint for the metrics data with these components.
    They just *tweet* metrics. We need metrics collector agents for them as well that
    can then send the data to the Aria database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software package** running on a host – These can be any software solution
    that is deployed on a host (server). It could be a MySQL database or a Jenkins
    server. We can collect their metrics using a collector agent that knows how to
    collect the data emitted by these software tools. We will revisit these agents
    later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom app** codes – These can be any custom business application that sends
    custom business metrics, such as order counts or failed payments. This data can
    also include span logs for specific operations emitted by equipped applications.
    This data can be ingested into Aria from the application code using certain third-party
    libraries depending on the technology stack of the application. Micrometer ([https://micrometer.io/](https://micrometer.io/))
    is one such open source library that is widely used for custom metrics emissions
    from a Java-based application. Similarly, OpenTelemetry ([https://opentelemetry.io/](https://opentelemetry.io/))
    provides several libraries for various application technologies to emit metrics
    and span logs from custom applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log files** – There are some systems that do not emit any telemetry data
    but just write them in local log files. We can also collect this data from log
    files using specific configurations in Wavefront Proxy. We will cover Wavefront
    Proxy shortly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all different types of sources from which we can collect telemetry
    data. While some sources can directly send data to the Aria system, for many sources,
    such as software running on servers such as databases, off-the-shelf solutions,
    or sources such as a host OS, collector agents need to gather this data and send
    it downstream. Let’s learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: Collector agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned before, many sources just emit telemetry data without any knowledge
    of which system will collect them for processing. These sources often have a source
    endpoint at which they make this data available for collection. To collect this
    data from its source, filter it for the subsets not required, aggregate it when
    required, and convert it into a form that can be understood by a downstream telemetry
    visualization system such as Aria, we need a tool that can help with these requirements.
    The agents shown in *Figure 10**.6* next to the **Host** and **Software Package**
    components are there for this very same reason.
  prefs: []
  type: TYPE_NORMAL
- en: Aria is a time-series database for ubiquitous observability that accepts data
    from different sources in a specific format that it understands. For this reason,
    Aria requires collector agents for sources that make their telemetry data available
    at a specific endpoint and require their consumers to pull it as and when required.
    While we can write custom programs that can perform this task, there is a very
    elegant out-of-the-box solution available that we can directly use as a collector
    agent – **Telegraf** ([https://github.com/influxdata/telegraf](https://github.com/influxdata/telegraf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Telegraf is a mature and flexible open source metrics collector agent tool
    that has a very extendable plugin-based architecture to support collecting, processing,
    and distributing telemetry data. Telegraf has the following types of plugins that
    make it a very popular and widely adopted tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input** – These plugins allow you to collect data from different source types.
    Each source has a specific plugin associated with it that can be used to collect
    its telemetry data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processor** – These plugins allow you to modify and filter collected data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregator** – These plugins allow to aggregate data before it is sent to
    a source to reduce the volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output** – These plugins are used to send data to a specific output destination.
    In our case, it is Wavefront Proxy, which we will cover next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aria can accept telemetry data via an HTTP API endpoint. Hence, a data source
    can always use that to ingest data in Aria. However, for sources that only make
    their health data available for collection, we need the help of tools such as
    Telegraf to fill the gap for sure – but rather than sending such data directly
    to the Aria database, it is recommended to send them via Wavefront Proxy. Let’s
    learn about Wavefront Proxy next.
  prefs: []
  type: TYPE_NORMAL
- en: Wavefront Proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wavefront Proxy is an open source tool ([https://github.com/wavefrontHQ/wavefront-proxy](https://github.com/wavefrontHQ/wavefront-proxy))
    written in Java that sits between a collector (and sometimes between the source
    directly) and the Aria database on the cloud. Although using Wavefront Proxy is
    not mandatory, it is a very useful component in Aria architecture. As a reason,
    VMware actively maintains this project. Architecturally, Wavefront is placed closer
    to the data sources. As shown in *Figure 10**.6*, several sources can share a
    single Wavefront Proxy, which could be deployed on the same host, data center,
    or private network boundary as the sources. The following are the reasons to consider
    using Wavefront Proxy, rather than sending telemetry data directly to the Aria
    database using its API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Wavefront Proxy provides a layer of data protection with the ability to cache
    data in memory in case the link between the source and Aria data endpoint goes
    down, which works via the internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wavefront Proxy batches data for the optimal use of the network bandwidth and
    an optimized transmission speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wavefront Proxy provides a way to enrich data by adding more tags (key-value
    pairs) to each data record it processes. These tags can be used to fetch the details
    required for monitoring. An example of these tags could be `env=prod`, defining
    the data record as belonging to a production environment. Later, we can use this
    tag to build a chart showing only production environment data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wavefront Proxy allows us to massage data to modify the content if required.
    One such use case could be to hide the specific IP addresses of the sensitive
    systems to maintain the privacy of the network layout. In general, having the
    IP address of a source in its telemetry record is a useful detail that can be
    used to filter data in the same way. However, an organization may need to hide
    IP addresses as per their policy for data going into an Aria database that resides
    in a public cloud space. For this, Wavefront Proxy allows us to carry out pattern-based
    replacement in data records. This way, we can replace an IP address such as `10.1.0.2`
    with either `10.*.*.2` or `*.*.*.*` or `******`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wavefront Proxy provides the last centralized gate that opens to the Aria service
    endpoint. If all sources send their telemetry data via the same instance of Wavefront
    Proxy, we can use that as the final checkpoint to apply common data filters and
    enrichment policies applicable to all sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Wavefront Proxy is the last gate for the internal telemetry data before
    it reaches the Aria service endpoint, we only need to open the firewall from Wavefront
    Proxy to the Aria service over the internet. All internal sources can send their
    data to Wavefront Proxy over the private network. This reduces the network attack
    surface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the preceding benefits, there is one more that is worth a mention
    here. Very large organizations have several data centers, either in a private
    or public cloud space. At this scale, it is not advisable to have just one instance
    of Wavefront Proxy between all the sources deployed across public and private
    network spaces. As mentioned before, we should try to keep the Wavefront Proxy
    setup as close as possible to its sources so that we can take advantage of its
    data reliability and enrichment capabilities. Hence, we generally end up with
    multiple instances of Wavefront Proxy deployed that send data to the Aria SaaS
    endpoint. This kind of setup could be difficult to maintain down the line, as
    we need to maintain configuration parity between these Wavefront Proxy implementations.
    To ease this situation, we can create Wavefront Proxy chaining, where all distributed
    instances of Wavefront Proxy send their data to a centralized instance of Wavefront
    Proxy instead of directly sending the data to the Aria service endpoint. This
    way we can keep all source-specific configurations in remote Wavefront Proxy instances
    and all common configurations in the central instance of Wavefront Proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details about various deployment patterns and other details of Wavefront
    Proxy, visit this page: [https://docs.wavefront.com/proxies.html](https://docs.wavefront.com/proxies.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The Wavefront service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Figure 10**.5*, the right-hand element captioned **Tanzu Observability Service**
    is nothing but the Aria SaaS platform deployed on the AWS cloud (as of the time
    of writing). This is also the component that we have been referring to as the
    Aria service endpoint. The Aria service is made of a large collection of components,
    including a portal, API endpoints, a time-series database, various data processors,
    alert engines, and several other components. We will cover working with the Aria
    portal for various operations in upcoming sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have concluded our section on unboxing Aria. In this section,
    we saw that Aria can ingest metrics, events, histograms, and span logs to provide
    full-stack observability. Additionally, we learned about the common deployment
    architecture of Aria. There, we learned that Aria can ingest data from various
    sources, including public cloud platforms, different hosts and their OSs, and
    different software running on those hosts, including platforms such as Kubernetes,
    custom applications, and log files. Then, we learned about the collector agents’
    role and Telegraf being one of the most popular collector agents. Then, we checked
    out the role and benefits of using Wavefront Proxy in the data path. Let’s now
    see how to get started with Aria and integrate our first Kubernetes cluster with
    an Aria service account for monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Aria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a trial account for Aria (unless you have an existing account)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating a Kubernetes cluster with the account for monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the default dashboards for the integrated Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the default alerts for various Kubernetes cluster conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the prerequisites to follow along with the outlined steps in this
    section and upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster with admin-level `kubectl` access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A workstation with `kubectl` and the `helm` CLI, access to the targeted Kubernetes
    cluster, and a web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A valid email address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the prerequisites are very straightforward. Let’s start by integrating
    a Kubernetes cluster with an Aria service account.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a trial account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is optional if you already have an existing Aria service account
    that you would like to use. Otherwise, take the following steps to get started
    with a trial account of Aria without any obligations:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the [https://tanzu.vmware.com/observability](https://tanzu.vmware.com/observability)
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **START FREE TRIAL** button as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.6 – Aria website](img/B18145_10_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Aria website
  prefs: []
  type: TYPE_NORMAL
- en: 'Submit the trial account setup details as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.7 – Submitting the trial account setup details](img/B18145_10_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Submitting the trial account setup details
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure a password for the account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.8 – Configuring a trial account password](img/B18145_10_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Configuring a trial account password
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the landing page as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.9 – Aria landing page on the first login](img/B18145_10_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Aria landing page on the first login
  prefs: []
  type: TYPE_NORMAL
- en: That is all. We successfully created a trial account for Aria in a few minutes
    with all its features accessible. Let’s now use this account to integrate a Kubernetes
    cluster for monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a Kubernetes cluster for monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the Aria trial account created in the previous subsection to link
    an existing Kubernetes cluster to it for monitoring. Follow these steps to perform
    the integration procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Kubernetes logo as highlighted in the following screenshot from
    the landing (**Get Started**) page of Aria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.10 – Starting Kubernetes cluster integration](img/B18145_10_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Starting Kubernetes cluster integration
  prefs: []
  type: TYPE_NORMAL
- en: For existing non-trial accounts
  prefs: []
  type: TYPE_NORMAL
- en: You may use your existing account to do this. If you have previously accessed
    the account, based on your account configuration, you may see a different landing
    page than what is shown in the previous screenshot. In that case, go to the **Integrations**
    menu on the top navigation bar and click on **Kubernetes** from the featured group
    of integrations. On the Kubernetes integration page, go to the **Setup** tab and
    click the **ADD INTEGRATION** button to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the middle tile with the **Install in Kubernetes Cluster** option to
    load the setup instruction page. The setup procedure for a Tanzu Kubernetes cluster
    is pretty similar except for a few additional configurations. However, the procedure
    to integrate an OpenShift cluster is very different, but we are not covering that
    in this book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.11 – Selecting the Kubernetes type for the integration](img/B18145_10_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Selecting the Kubernetes type for the integration
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the set of instructions given on the page to install a deployment of
    Wavefront Proxy and the metrics collector for Kubernetes provided by Aria. This
    is a quick and easy way to get started. However, it is always possible to perform
    various fine-grained configurations provided by the collector as well as Wavefront
    Proxy for a production-grade integration. Follow this documentation link to learn
    more about this: [https://docs.wavefront.com/kubernetes.html#kubernetes-manual-install](https://docs.wavefront.com/kubernetes.html#kubernetes-manual-install):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.12 – Kubernetes integration instructions](img/B18145_10_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Kubernetes integration instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the command in *step 3*, we can see the following output. Notice
    the last line providing the URL to examine the cluster integration on the Aria
    portal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check out the deployment of Wavefront Proxy and Wavefront collector Pods in
    the `wavefront` namespace of the targeted cluster. As you can see, there are two
    collectors, one for each Kubernetes node, and one Wavefront Proxy Pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Examine the Kubernetes integration status using the URL given in the output
    of the command described in *step 4*. You will see a page as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.13 – Kubernetes cluster summary dashboard](img/B18145_10_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Kubernetes cluster summary dashboard
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Aria account has been successfully integrated with an existing
    Kubernetes cluster. We can add as many clusters as required this way to centrally
    monitor them from a single window. Then, we can filter a specific cluster if required
    by its name using the dropdown labeled **cluster,** as shown in the previous screenshot’s
    top-left corner. The dashboard shown in the previous screenshot is one of the
    many out-of-the-box dashboards in Aria for Kubernetes integration. We can access
    some of them from this dashboard with a drill-down approach. Let’s check out the
    other out-of-the-box Kubernetes dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the default Kubernetes dashboards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will access some additional Kubernetes dashboards that
    come by default with Aria. These dashboards immediately start showing data after
    a successful Kubernetes cluster integration. Let’s start with the first dashboard
    – **Kubernetes Summary** – that we opened in the previous section. From there,
    we will access various other dashboards:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To drill down to the **Kubernetes Cluster** dashboard from the **Kubernetes
    Summary** dashboard, click on the cluster name as highlighted in the following
    screenshot’s bottom-left corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.14 – Drilling down to the Kubernetes cluster dashboard](img/B18145_10_14.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Drilling down to the Kubernetes cluster dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following dashboard showing a more detailed view of the
    Kubernetes cluster. Then, click on the **Nodes** link as highlighted in the screenshot
    to open the **Kubernetes Nodes** dashboard for a detailed view of the nodes of
    that cluster. Additionally, you can find very valuable insights on all these dashboards
    when you scroll down their pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.15 – Kubernetes \uFEFFClusters dashboard](img/B18145_10_15.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Kubernetes Clusters dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Kubernetes Nodes** dashboard, which contains
    a detailed view of the nodes of the cluster to which we are drilling down. You
    can select a specific node of the cluster using the **node** dropdown as highlighted
    in the following screenshot. Additionally, you may open the **Kubernetes Pods**
    dashboard by clicking on the **Pods** link as highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.16 – Kubernetes nodes dashboard](img/B18145_10_16.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Kubernetes nodes dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking on the **Pods** link on the **Kubernetes Nodes** dashboard, we
    get to the **Kubernetes Pods** dashboard, as shown in the following screenshot.
    As also shown in the screenshot, you can group these Pods by several criteria.
    These groupings are very useful when we have hundreds of Pods running in a cluster.
    Additionally, we can also drill down to the **Kubernetes Containers** dashboard
    from this page as we have seen in the previous points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure\uFEFF 1\uFEFF0.17 – Kubernetes Pods dashboard](img/B18145_10_17.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Kubernetes Pods dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to all these dashboards, there are several out-of-the-box Kubernetes
    dashboards we can access using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Integrations** menu of the top navigation bar as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.18 – Opening the Integrations page](img/B18145_10_18.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Opening the Integrations page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Kubernetes** tile as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.19 – Opening the Kubernetes integration tile](img/B18145_10_19.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Opening the Kubernetes integration tile
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Dashboards** tab as highlighted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.20 – Opening the Kubernetes dashboard page](img/B18145_10_20.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – Opening the Kubernetes dashboard page
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows all the default dashboards in Aria for Kubernetes
    monitoring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.21 – Default Kubernetes dashboards](img/B18145_10_21.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Default Kubernetes dashboards
  prefs: []
  type: TYPE_NORMAL
- en: All these out-of-the-box dashboards show useful insights using the metrics collected
    from all integrated Kubernetes clusters with an Aria account, although Aria also
    allows you to clone these dashboards and customize them to address any specific
    monitoring requirements. We can add new charts and new drill-downs, modify existing
    visualizations, rearrange different tiles, and make several other customizations
    to these default dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: However, dashboards are useful only when someone explicitly and carefully observes
    them to find abnormalities. People generally open them to find anomalies after
    an issue is reported. This is a reactive analysis of an issue that has already
    occurred, but we use these sophisticated tools to catch issues well in advance,
    in a proactive manner, before our customers feel the pain. For that reason, we
    have to configure alerts in these tools that notify us as soon as any abnormality
    in any health condition is observed by the monitoring system. Aria has a powerful
    alerting capability for the very same reason – and like Aria has a default set
    of ready-to-use dashboards for Kubernetes, it also comes with a set of predefined
    alert configurations for proactive Kubernetes monitoring. Let’s learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing default Kubernetes alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we explored the default dashboards that come with
    Aria for Kubernetes integration. The same is the case for a set of useful alerts
    that are supplied with Aria for Kubernetes. These alerts are configured with opinionated
    criteria. Aria allows you to customize them for various reasons. The following
    steps show how to access and configure the out-of-the-box alerts for Kubernetes
    cluster monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Alerts** tab as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.22 – Opening the Kubernetes Alerts page](img/B18145_10_22.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Opening the Kubernetes Alerts page
  prefs: []
  type: TYPE_NORMAL
- en: 'The following page shows all the default alerts that come with Aria for Kubernetes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.23 – Default Kubernetes alerts](img/B18145_10_23.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Default Kubernetes alerts
  prefs: []
  type: TYPE_NORMAL
- en: 'Like dashboards, all these alerts are fully customizable to change their firing
    conditions and delivery mediums, such as texts, emails, PagerDuty, ServiceNow,
    Slack, and many others. We will cover more about working with alerts later in
    the chapter. For now, let’s see how to get more details about existing alerts
    and their status to see whether there are any active conditions. For that, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **All Alerts** option under the **Alerting** menu from the top
    navigation bar as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.24 – Opening the Alerting page](img/B18145_10_24.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Opening the Alerting page
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a page as shown in the following screenshot listing the current
    alert conditions that are already triggered for the configured threshold or under
    active monitoring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.25 – Alerts page](img/B18145_10_25.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – Alerts page
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our section on how to get started with Aria. We learned how to
    set up a trial account to get full access to the Aria platform. Then, we integrated
    an existing Kubernetes cluster with the Aria account with a simple three-step
    procedure. Then, we saw how to access some useful out-of-the-box dashboards that
    show insightful details for the cluster with an ability to drill down to get more
    details. Finally, we saw how to access the default set of alerts that are provided
    by Aria for Kubernetes integration.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, Aria is an observability tool. The main use case of that kind of
    tool is to proactively prevent disruptive failures from happening in the first
    place, and if a failure happens for any reason, finding out the root cause quickly
    and resolving it. Monitoring dashboards and alerts are the two main capabilities
    that play key roles for these reasons. Let’s learn about them by taking a deeper
    look, starting with dashboards and charts.
  prefs: []
  type: TYPE_NORMAL
- en: Working with charts and dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following details on using charts and dashboards
    in Aria:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating new custom charts to visualize any data being sent to Aria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new custom dashboards using canned or custom charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing out-of-the-box dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with the topics in this list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new custom charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we configure integration with Aria as we did for a Kubernetes cluster,
    we can see several metrics getting pushed into Aria that are collected by the
    agents that we deploy on the hosts. As with a Kubernetes cluster, we can get telemetry
    data for any integration that we make. The number of metrics and the frequency
    at which they are ingested in Aria depends on the source and the configurations
    at the collector and Wavefront Proxy. However, once the metrics data is in the
    Aria database, it stays there for up to 18 months unless explicitly removed. We
    can then use that data anytime to build on-demand charts to gain insights into
    what is going on with a source’s health.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show how to build a chart using an available metric endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Dashboard** menu from the top navigation bar and select the
    **Create** **Chart** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.26 – Selecting the Create Chart option](img/B18145_10_26.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26 – Selecting the Create Chart option
  prefs: []
  type: TYPE_NORMAL
- en: 'On this page, you can directly write a query in either **Wavefront Query Language**
    (**WQL**) or **Prometheus Query Language** (**PROMQL**) structures if you have
    some knowledge of either of the query languages. If you do not know either of
    them, Aria allows you to generate a query in the background by selecting the correct
    values under the dropdowns named **Data**, **Filters**, and **Functions**. Additionally,
    Aria allows you to either select metrics from the available list or use the integrations
    you have in place. Since we have a Kubernetes cluster integrated, we can see Kubernetes
    as an option to build a chart for the Kubernetes integration in the following
    screenshot. Click on the **Data** dropdown and the **Kubernetes** tile as highlighted
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.27 – Selecting Kubernetes integration](img/B18145_10_27.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27 – Selecting Kubernetes integration
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the chart data points as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.28 – Selecting data elements for the chart](img/B18145_10_28.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.28 – Selecting data elements for the chart
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chart shows a live view of the CPU usage for all Pods belonging
    to all the namespaces in all the Kubernetes clusters that we have integrated with
    the Aria account. Hence, this chart would be very clumsy if there are several
    Kubernetes clusters with several Pods running in them. We may need to implement
    certain filters to make this chart more usable. In the context of this book, there
    should only be one Kubernetes cluster, which we integrated earlier in the book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.29 – A chart showing the CPU usage of all Pods in all Kubernetes\
    \ clusters](img/B18145_10_29.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.29 – A chart showing the CPU usage of all Pods in all Kubernetes clusters
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply a filter to only see the Pods running in the **wavefront** namespace
    as shown in the following screenshot. This will show the CPU usage of the Wavefront
    Collector and Wavefront Proxy Pods that we deployed earlier during the Kubernetes
    cluster integration steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.30 – Applying filters for a chart](img/B18145_10_30.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.30 – Applying filters for a chart
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a chart only for the Pods under the **wavefront**
    namespace. We can add more filters by clicking on the **+** button near the **Filters**
    dropdown and applying data functions to further fine-tune the chart as per the
    requirements. Click on the **SAVE** button to save this chart for future use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.31 – A chart showing CPU usage of all Pods in the wavefront\
    \ namespace](img/B18145_10_31.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.31 – A chart showing CPU usage of all Pods in the wavefront namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a chart showing some meaningful data on how a group of Pods belonging
    to a namespace behave in terms of their CPU utilization. We can do the following
    things with this chart:'
  prefs: []
  type: TYPE_NORMAL
- en: Share it with someone to show them the same view of the data so we can talk
    in the same language when discussing any performance issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add this chart to either a new or an existing custom dashboard for future use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go back in time to see historical performance data for the selected time duration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark interesting events for future reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export the chart in either a PDF or CSV format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the visualization of the chart to get it in other graphical formats such
    as bar chart, pie chart, tabular chart, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add more data layers by adding more queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following subsection focuses on various user controls that can be applied
    to a chart in Aria.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding chart manipulation controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following screenshot highlights various controls with a corresponding number
    as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.32 – Chart controls](img/B18145_10_32.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.32 – Chart controls
  prefs: []
  type: TYPE_NORMAL
- en: 'The controls in the previous screenshot are described against those numbers
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: These controls allow you to either watch the chart with live data that keeps
    refreshing after a few seconds or select a specific timeframe in the past to pull
    data for that duration only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These controls provide ways to add more details to the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Anomaly Detection** finds specific chart patterns that are deemed unusual
    based on past data using a few artificial intelligence algorithms.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compare** lets you visually compare historical data for the same set of sources
    to find any pattern changes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Timezone** lets you change the chart’s timeline for the selected time zone.
    By default, Aria uses the internet browser’s time zone.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sampling** lets you turn the usage of data sampling for chart generation
    in place of considering all the data points on or off.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Filter** allows you to reduce the data points based on the tag values supplied
    without modifying the chart’s query statement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These controls are used for the following reasons, listed from left to right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a link to the chart that can be shared with others
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the chart to be embedded in a web page
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Show/hide the chart variables if used
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Flag an event point on the chart with details that generates an event log record
    for future references
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Export the chart as either a PDF or CSV file
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the chart in either a new or an existing dashboard
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: These controls allow you to zoom in and out of the chart for the selected time
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This control allows you to change the visualization of the chart to display
    it in different formats such as pie, bar, table, single-value, and many more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following list describes these tabs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Data** tab lets you work with queries to pull chart data
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Format** tab allows you to modify the chart’s visual details
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Axis** tab allows you to modify the chart’s axis units
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Legend** tab allows you to configure a data legend on the chart
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Drilldown Link** tab allows you to configure a link to another dashboard
    showing relevant data
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Description** tab allows you to set a chart description that can be seen
    in a tooltip for the chart with mouse-hover
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Anomaly Detection** tab allows you to configure related settings for its
    sensitivity, display, and data sampling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Advanced** tab allows you to pull obsolete metrics and configure the chart’s
    timeline with respect to its parent dashboard.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This control allows you to name a chart data layer for the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These controls allow you to toggle between WQL and PROMQL, and between the query
    graphical editor and the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This set of controls allows you to perform the following configurations from
    left to right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See query execution statistics to determine the need for query optimization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Clone an existing query to create a new data layer for the chart
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the query and its respective visual data from the chart
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Show or hide the query data in the chart without deleting the query
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Various other options, including alert creation based on the query and chart
    formatting
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **ADD QUERY** link allows you to add new data and its visualization layer
    to the chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these chart controls play a key role in building meaningful dashboards.
    Let’s now learn how to work with dashboards in Aria.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new custom dashboards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen earlier in this chapter, for Kubernetes integration, Aria supplies
    a set of canned dashboards that are ready to use for the telemetry data coming
    from the respective integration source. However, Aria can ingest data from various
    integrated sources including applications, Kubernetes, a hypervisor of the virtual
    infrastructure layer, an OS, databases, and several others. In that case, the
    default dashboards for a particular integration would not provide a complete picture.
    For example, none of the default Kubernetes dashboards in Aria cover charts showing
    data coming from the OS or the hardware hosts on which the nodes are deployed.
    The default and integration-specific dashboards cannot assume that the data pertaining
    to another integration will always be present. For example, in this chapter, we
    have only one integration in place for a Kubernetes cluster. Hence, if a default
    dashboard expects metrics to come from the node OSs, then it would fail. In these
    cases, we need custom dashboards that can display correlated data from multiple
    sources. Dashboards that show data from different sources could significantly
    help get a broader view of the landscape and quickly find the root causes of issues.
    A slow-running query in a database could be the cause of a slow-responding application,
    so having the details of both the layers, the application and the database, on
    one dashboard could help find the issue quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we can build custom dashboards in Aria. First, we can build
    them using custom charts that can be added to a new or existing dashboard. Second,
    we can build custom dashboards using the different templates provided in Aria
    or add custom charts to it. Let’s use the chart we built in the previous section
    to create a new dashboard. The following steps describe this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **SAVE** button, followed by the **SAVE TO A NEW DASHBOARD** button,
    as highlighted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.33 – Creating a new dashboard from a custom chart](img/B18145_10_33.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.33 – Creating a new dashboard from a custom chart
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the name of the dashboard and click on the **CREATE** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.34 – Naming and creating a dashboard](img/B18145_10_34.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.34 – Naming and creating a dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Aria dashboard editor where the custom chart
    is now added. We can add several custom or predefined charts from the out-of-the-box
    chart templates provided by Aria for the integrations it has:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.35 – Dashboard editor](img/B18145_10_35.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.35 – Dashboard editor
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points explain the highlighted sections in the previous screenshot
    of the dashboard editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables allowing you to manipulate the data in the applicable charts of the
    dashboard. These variable values can be added to the chart queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A section is a group of similar charts in a dashboard. We can use sections to
    either show/hide charts or jump from one section to another in a very big dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These section controls allow you to add, remove, or move the sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These arrows allow you to resize the chart to add more than one chart in a single
    row for more consolidation of data in a row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these tiles allow you to add more charts to this dashboard in a selected
    section. Here, we can also import some of the existing canned charts that are
    provided by Aria for integration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After seeing how to create a new dashboard from scratch, let’s now see how to
    customize an out-of-the-box dashboard provided by Aria.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing a default dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the default dashboards provided in Aria for different integrations
    are designed thoughtfully, there could be a few things we may like to change in
    their look and feel. In Aria, we cannot directly update a default dashboard that
    comes out of the box, but we can clone it and create a custom copy. Then, we can
    update the custom copy of the default dashboard in whatever way we need. Let’s
    see how that can be done using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **All Dashboards** menu under the main **Dashboards** menu in
    the top navigation bar as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.36 – Opening the Dashboards page](img/B18145_10_36.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.36 – Opening the Dashboards page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Kubernetes** link from the left-hand navigation bar and then
    click on the **Kubernetes Clusters** dashboard as highlighted in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.37 – Opening the Kubernetes Clusters dashboard](img/B18145_10_37.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.37 – Opening the Kubernetes Clusters dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Kubernetes Clusters** dashboard, which
    is one of the default dashboards that comes with Aria. All default dashboards
    are marked with the highlighted lock symbol. To clone the dashboard for customization,
    click on the highlighted dots menu on the right and select the **Clone** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.38 – Cloning a default dashboard](img/B18145_10_38.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.38 – Cloning a default dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Give an appropriate name to the cloned copy of the dashboard and click on the
    **CLONE** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.39 – Naming the cloned dashboard ](img/B18145_10_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.39 – Naming the cloned dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the same dashboard editor that we checked out earlier allowing
    you to make any changes to the dashboard, including but not limited to changing
    chart data queries, chart visualization, rearrangement of tiles, and adding new
    data visualizations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.40 – Dashboard editor](img/B18145_10_40.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.40 – Dashboard editor
  prefs: []
  type: TYPE_NORMAL
- en: Once you make the required changes and save this dashboard, you can then mark
    it as a favorited dashboard and put it under the quick access menu. You can also
    define who can access the dashboard for viewing and editing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have concluded working with charts and dashboards, with a very
    high-level overview of the capabilities. For more details about charts and the
    dashboard, refer to the official product documentation – [https://docs.wavefront.com/ui_charts.html](https://docs.wavefront.com/ui_charts.html)
    and [https://docs.wavefront.com/ui_dashboards.html](https://docs.wavefront.com/ui_dashboards.html).
    In the next and last section of the chapter, we will learn about working with
    alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Working with alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any monitoring tool is not complete if it does not have a good alerting capability.
    Aria is also not an exception. It has a very powerful and highly configurable
    alerting engine that allows you to configure alerts with multiple thresholds,
    delivery based on those threshold levels, and several possible delivery methods,
    including but not limited to an email, a text, a Slack message, a Microsoft Teams
    message, a ServiceNow ticket, or a PagerDuty incident. Moreover, we can also configure
    triggering an automated process using a webhook that calls a remote API outside
    of the Aria boundary. There are so many useful things we can configure using Aria’s
    alerting features. Let’s learn more about alerts in this section, including the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating alert targets to define who should get which alert using which delivery
    mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a maintenance window to avoid obvious alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting firing alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating alert targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alert target in Aria contains several details and provides very flexible
    ways to define the following things at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: When the notification should be delivered and when it should be held back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using which medium the alert should be delivered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who should get the alert and under what conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What details the alert should contain and in what format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps show how to create the most common email-based alert target
    in Aria:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Alerting** menu from the top navigation bar and select **Alert Targets**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.41 – Opening the Alert Targets list page](img/B18145_10_41.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.41 – Opening the Alert Targets list page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **CREATE ALERT** **TARGET** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.42 – Creating a new alert target](img/B18145_10_42.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.42 – Creating a new alert target
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter details in the form as depicted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.43 – Create Alert Target page](img/B18145_10_43.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.43 – Create Alert Target page
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the elements in the previous screenshot as per their numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the name of the alert target. Specify a unique name here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the description of the alert target. Specify any understandable description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A set of **Triggers** defines when the alert notification should be delivered
    to its destination and when it should not be. For example, it allows you to configure
    if you would like to deliver an alert notification when the alert condition is
    resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Type** dropdown allows you to select one of the main three types of alert
    notification – **Email**, **PagerDuty**, and **Webhook**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Default Recipient** box allows you to specify a list of email addresses
    that should receive the email notification for this alert target. The email list
    specified here will get the notification for any dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Routing** configuration allows you to deliver the same alert notification
    to additional destinations based on the defined keys and their values. Using this
    configuration, we can configure different application teams to be notified based
    on the application identifiers in the alert data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These controls allow you to configure the details in the notification. When
    this pertains to an email notification, the details are the subject and the body
    of the email. We can configure these values using variables that carry the alert-specific
    custom data in the notification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see an alert target created as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.44 – Created alert target record](img/B18145_10_44.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.44 – Created alert target record
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have an alert target for the delivery of notifications for any generated
    alert, we can use this target to deliver alerts. We can use one alert target with
    more than one alert configuration – but before we learn how to create an alert
    with a button click, let’s first learn how to configure a maintenance window to
    avoid false-positive alerts during scheduled maintenance when alert monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a maintenance window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting a flood of alerts during a maintenance window for systems under observation
    is not good, as we already know that things may go down or perform abnormally
    during those activities. However, in the midst of false positives during a maintenance
    window, missing a real alert that needs attention would be worse. To prevent critical
    alerts from being buried under those non-critical alerts, Aria allows you to define
    a maintenance window where we can mark certain system health parameters to be
    ignored. In this case, we can take actual alerts seriously during scheduled activities.
    The following steps show how to configure a maintenance window in Aria:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Alerting** menu from the top navigation bar and select the **Maintenance
    Windows** option as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.45 – Opening the Maintenance Window list page](img/B18145_10_45.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.45 – Opening the Maintenance Window list page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **CREATE MAINTENANCE** **WINDOW** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.46 – CREATE MAINTENANCE WINDOW](img/B18145_10_46.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.46 – CREATE MAINTENANCE WINDOW
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the required details of the maintenance window to select the time and
    the characteristics of the systems for the maintenance window as depicted in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.47 – Entering maintenance window details](img/B18145_10_47.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.47 – Entering maintenance window details
  prefs: []
  type: TYPE_NORMAL
- en: 'The following numbered points describe the corresponding number in the previous
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a unique name for the maintenance window record
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a description of the maintenance window’s purpose
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either select **Now** to start the maintenance window on demand or select the
    scheduled start and end time and date to define the window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the source-defining parameters to cover the alerts in this maintenance
    window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select either to mute/ignore the alerts with the criteria covered in the previous
    point and during the defined time window or select an alert target to divert the
    alerts there during the window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the **SAVE** button is clicked, the maintenance window is created, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.48 – Created maintenance window record](img/B18145_10_48.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.48 – Created maintenance window record
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the maintenance record created, let’s create a custom alert record.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to create a new alert. There are three ways
    we can create alerts in Aria. One of them is to create an alert using the alert
    creation wizard from the main **Alerts** menu. The second one is to duplicate
    an alert and modify the required details. The last one is to create it using an
    existing chart, usually already there on a dashboard. While the first two ways
    are more obvious, let’s learn how to create an alert using the third way, from
    an existing chart, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **All Dashboards** page under the **Dashboards** menu on the top navigation
    bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.49 – Opening the All Dashboards page](img/B18145_10_49.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.49 – Opening the All Dashboards page
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Kubernetes Clusters** dashboard from the list as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.50 – Opening the Kubernetes Clusters dashboard](img/B18145_10_50.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.50 – Opening the Kubernetes Clusters dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the pencil icon on the **Node Storage Utilization Avg** chart as highlighted
    in the following screenshot. The same method of creating an alert from a chart
    can be applied to all the charts on any dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.51 – Editing a chart](img/B18145_10_51.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.51 – Editing a chart
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Create Alert** link under the dots menu dropdown of the query
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.52 – Creating an alert from a chart editor](img/B18145_10_52.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.52 – Creating an alert from a chart editor
  prefs: []
  type: TYPE_NORMAL
- en: As you can see on the **Create Alert** page, the query to pull alert data is
    already populated using the chart’s query. This is a big help in getting the right
    alert configuration. Let’s set up the other alert details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **NEXT** button on the query details page as shown in the following
    screenshot. Update the alert query if required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.53 – Updating the alert query](img/B18145_10_53.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.53 – Updating the alert query
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the alert conditions with different threshold levels as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.54 – Configuring alert conditions](img/B18145_10_54.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.54 – Configuring alert conditions
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points correspond to the numbers mentioned in the previous screenshot
    to describe the controls:'
  prefs: []
  type: TYPE_NORMAL
- en: These are different alert threshold values. The alert will fire with the corresponding
    severity when a certain condition is met.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The trigger and resolve windows define the timelines to consider a condition
    as either the start of the alert or the end of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The additional settings provide controls to define the frequency of alert checks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **TEST CONDITION** button allows you to test whether an alert would have
    triggered based on the past data of the last 2 hours to validate the configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select an alert target that has previously been created in the account. Note
    that the following screenshot only shows one target configured for the **SMOKE**
    level, which will be applicable for all the threshold levels above it, which are
    **WARN** and **SEVERE,** too. However, it is also possible to send the alert to
    different targets for all different threshold levels. Click on the **NEXT** button
    to move forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.55 – Configuring alert targets](img/B18145_10_55.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.55 – Configuring alert targets
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure alert details that can be helpful for its triage as shown in the
    following screenshot. Click on the **NEXT** button after that to move forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.56 – Configuring alert troubleshooting details](img/B18145_10_56.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.56 – Configuring alert troubleshooting details
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points describe the controls that are marked with numbers that
    correspond to the previous screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Runbook**, we can provide an external URL that contains details on how
    to troubleshoot and resolve the alert condition
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Triage Dashboard(s)**, we can add one or more dashboards that will be
    added to the alert details to provide the required details upfront.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Additional Information**, we can provide any arbitrary details that
    could be helpful for troubleshooting this alert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the alert a name and, optionally, the related tag values to identify the
    sources impacted, and click on the **ACTIVATE** button to create the alert:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.57 – Activating the alert](img/B18145_10_57.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.57 – Activating the alert
  prefs: []
  type: TYPE_NORMAL
- en: 'Once activated, the alert can be seen under the **Alerts** page as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.58 – Newly created alert](img/B18145_10_58.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.58 – Newly created alert
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes the details on creating new alerts in Aria. Learn more about
    creating alerts in the official product documentation if required: [https://docs.wavefront.com/alerts_manage.html](https://docs.wavefront.com/alerts_manage.html).
    Let’s now see how to find a firing alert that has an active alert condition.'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting firing alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will see how to list currently active alerts that are firing
    with any threshold level configured. The following steps describe this process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **FIRING** state from the left-hand navigation bar, which will
    list all the alerts under that status, and click on the name of the firing alert
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.59 – Viewing firing alert details](img/B18145_10_59.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.59 – Viewing firing alert details
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a view of the page that contains the details
    of the firing alerts, including other possible related alert conditions, the chart
    showing the firing duration, the query used for the calculation, and many other
    things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1\uFEFF0.60 – Firing alert details](img/B18145_10_60.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.60 – Firing alert details
  prefs: []
  type: TYPE_NORMAL
- en: With this, we conclude the *Working with alerts* section of the chapter. In
    this section, we started with creating alert targets and learned how we can flexibly
    define different alert notification types and destinations based on their severity
    and other attributes of the system under observation. Then, we learned how to
    create a maintenance window to treat alerts differently during a specific time
    of scheduled activities that would potentially trigger a bunch of alerts otherwise.
    After that, we learned how to create an alert using an existing chart from an
    existing dashboard. The same knowledge can be applied even to creating a new alert
    from scratch. Lastly, we saw how Aria shows different details of the alerts that
    are currently firing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about a very important component of the Tanzu product
    portfolio, VMware Aria Operations for Applications by Wavefront. In the first
    section of the chapter, we gave various reasons explaining the importance of this
    tool in terms of the observability of modern containerized applications. In this
    section, we learned about different out-of-the-box integrations supported by Aria.
    We also discussed how Telegraf collectors and the Wavefront SDK make it possible
    to integrate almost any data source for observability. Additionally, we discussed
    other benefits of Aria, including the high-speed data collection and processing
    power, and the ability to collect different telemetry data types including metrics,
    events, histograms, and span logs. Then, we listed different categories of data
    processing functions that can be used with WQL, including data aggregation, filtering,
    time operations, moving-window aggregation, exponential, and trigonometric.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned about various components of the solution. We explored
    metrics, histograms, span logs, and events. We then discussed the common deployment
    architecture of the solution and the details of various components with their
    roles. In that part, we discussed various ways to ingest data in Aria, different
    types of sources, collectors, Wavefront Proxy, and the Wavefront service, a SaaS
    platform. Later in the chapter, we learned how to open a trial account for Aria
    and integrate an existing Kubernetes cluster with the account. Then, we saw how
    to access a set of default dashboards for Kubernetes integration provided by Aria
    out of the box. Lastly, we learned about creating custom charts, dashboards, and
    alerts for the integrations in place.
  prefs: []
  type: TYPE_NORMAL
- en: Although it seems like we covered the solution in great depth, we just scratched
    the surface. There are still several more capabilities we could not cover in this
    chapter, as we only covered the details centered around Kubernetes monitoring.
    Besides the details covered here, Aria has a great set of capabilities for APM
    using the ingested span logs and application health metrics. We could not even
    cover topics such as derived metrics, delta counters, user permission configuration,
    and external logging solution integration because of the limited scope of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to securely connect various applications
    deployed in different Kubernetes clusters, even across different cloud infrastructures,
    using Tanzu Service Mesh.
  prefs: []
  type: TYPE_NORMAL
