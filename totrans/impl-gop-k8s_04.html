<html><head></head><body>
		<div id="_idContainer056">
			<h1 class="chapter-number" id="_idParaDest-66"><a id="_idTextAnchor065"/>4</h1>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Kubernetes with GitOps Tools</h1>
			<p>Transitioning from the theoretical underpinnings of GitOps presented in the initial chapters, this chapter delves into the practical interplay between Kubernetes and GitOps tools, emphasizing their significance in modern cloud-native operations. Earlier discussions set the scene by introducing GitOps, examining its cloud-native applications, and integrating version control via Git <span class="No-Break">and GitHub.</span></p>
			<p>Here, we’ll narrow our focus to Kubernetes, engaging with prominent tools such as Helm, Kustomize, Argo CD, and Flux CD to deepen our understanding and <span class="No-Break">application insights.</span></p>
			<p>This chapter aims to build on previous insights, providing a comparative look at pivotal GitOps instruments while underscoring their distinct attributes and synergy with Kubernetes. By dissecting the functionalities and applications of these tools, you’ll be equipped with the acumen to make informed choices, align your GitOps strategies with specific needs, and enhance Kubernetes <span class="No-Break">deployment frameworks.</span></p>
			<p>In this chapter, we’ll focus on the following <span class="No-Break">key areas:</span></p>
			<ul>
				<li>Overview of popular <span class="No-Break">GitOps tools</span></li>
				<li>A deep dive into Helm <span class="No-Break">and Kustomize</span></li>
				<li>Argo CD integration <span class="No-Break">with Kubernetes</span></li>
				<li>Flux integration <span class="No-Break">with Kubernetes</span></li>
				<li>Comparing Argo CD <span class="No-Break">and Flux</span></li>
			</ul>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Technical requirements</h1>
			<p>To fully grasp and apply the content of this chapter, you must meet certain technical prerequisites. A foundational understanding of Kubernetes architecture and concepts, along with proficiency in using command-line interfaces, is essential. It is recommended that you also have prior experience with the GitOps tools discussed in previous chapters, such as Helm, Kustomize, Argo CD, and Flux. Access to a computer with internet connectivity is crucial for executing hands-on examples and integrating GitOps tools with <span class="No-Break">Kubernetes clusters.</span></p>
			<p>The relevant code and resource files for this chapter can be found in the <strong class="source-inline">Chapter04</strong> folder of this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes"><span class="No-Break">https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Overview of popular GitOps tools</h1>
			<p>In this section, we’ll delve<a id="_idIndexMarker244"/> into a curated selection of pivotal tools that epitomize the GitOps methodology, each serving a unique role in orchestrating, managing, and deploying infrastructure and applications. This<a id="_idIndexMarker245"/> includes <strong class="bold">Terraform</strong> for IaC, <strong class="bold">Argo CD</strong> and <strong class="bold">Flux</strong> for <a id="_idIndexMarker246"/>continuous delivery within Kubernetes<a id="_idIndexMarker247"/> environments, and <strong class="bold">Helm</strong> and <strong class="bold">Kustomize</strong> for package management <a id="_idIndexMarker248"/>and <a id="_idIndexMarker249"/>application configuration. These tools collectively facilitate a more streamlined, secure, and scalable approach to system management, embodying the core principles of GitOps. By understanding the functionality and strategic application of each tool, you can leverage the full potential of GitOps to enhance operational efficiency and deployment precision in <span class="No-Break">cloud-native environments:</span></p>
			<ul>
				<li><strong class="bold">Terraform</strong>: Terraform (<a href="https://www.terraform.io/">https://www.terraform.io/</a>) is an open source IaC software tool <a id="_idIndexMarker250"/>created by HashiCorp. It allows users to define and <a id="_idIndexMarker251"/>provision data center infrastructure using a high-level configuration language known as <strong class="bold">HashiCorp Configuration Language</strong> (<strong class="bold">HCL</strong>), or<a id="_idIndexMarker252"/> optionally JSON. Terraform manages external resources (such as public cloud infrastructure, private cloud <a id="_idIndexMarker253"/>infrastructure, network appliances, <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>), and more) with a “declarative” approach, proposing a model for what the intended end state should look like rather than the steps to get there. This approach enables developers and infrastructure teams to collaborate and manage the IT infrastructure through code, ensuring consistency <span class="No-Break">and accountability.</span></li>
				<li><strong class="bold">Argo CD</strong>: Argo CD (<a href="https://argo-cd.readthedocs.io/en/stable/">https://argo-cd.readthedocs.io/en/stable/</a>) is a declarative, GitOps CD tool for Kubernetes. It automates the process of deploying <a id="_idIndexMarker254"/>applications to specified target environments within Kubernetes clusters, ensuring that the live state is always in sync with the configurations stored in Git repositories. Argo CD follows GitOps’ principles, treating Git repositories as the source of truth for defining the desired application state, thereby simplifying the deployment process and enhancing security and traceability. It provides a graphical user interface for visualizing the status of applications, their version control history, and the differences between the deployed and <span class="No-Break">desired states.</span></li>
				<li><strong class="bold">Flux</strong>: Flux (<a href="https://fluxcd.io/">https://fluxcd.io/</a>) is another tool that embodies GitOps’ principles and is <a id="_idIndexMarker255"/>designed to automate the process of deploying to Kubernetes. It ensures that the state of a cluster matches the configurations stored in a Git repository. Flux continuously monitors the repository and automatically applies any new changes to the target environment. This enables developers to manage and deploy their applications by simply updating their Git repositories. Flux supports complex deployment strategies, including canary and blue-green deployments, and integrates with Kubernetes to ensure that the actual state of live systems is always represented accurately <span class="No-Break">in code.</span></li>
				<li><strong class="bold">Helm</strong>: Helm (<a href="https://helm.sh/">https://helm.sh/</a>), a<a id="_idIndexMarker256"/> Kubernetes package manager, streamlines the deployment process by enabling developers and operators to effortlessly package, configure, and deploy applications and services on Kubernetes clusters. It employs a packaging format known as charts – collections of files that detail a set of related Kubernetes resources. These charts allow you to define, install, and upgrade complex Kubernetes applications, making updates and rollbacks simpler and thus enhancing the <span class="No-Break">deployment procedure.</span></li>
				<li><strong class="bold">Kustomize</strong>: Kustomize (<a href="https://kustomize.io/">https://kustomize.io/</a>) introduces a template-free way to customize<a id="_idIndexMarker257"/> application configurations that can be applied across different environments. It is a standalone tool for customizing Kubernetes objects through a file called <strong class="source-inline">kustomization.yaml</strong>, allowing resource files, patches, and other settings to be declared without altering the original YAML files. This approach simplifies how distinct configurations for each environment (development, staging, production, and so on) can be managed without<a id="_idIndexMarker258"/> requiring multiple copies of the <span class="No-Break">resource files.</span></li>
			</ul>
			<p>In the upcoming sections, we will delve into each tool while covering <span class="No-Break">practical examples.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>A deep dive into Helm and Kustomize</h1>
			<p>This section delves into the nuanced world of Helm and Kustomize, aiming to provide an in-depth exploration of these powerful Kubernetes tools. By guiding you through the setup processes, practical project examples, and the integration of these tools with GitOps workflows, we endeavor to impart a solid foundation and advanced insights for effectively managing and deploying applications in <span class="No-Break">cloud-native environments.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Helm</h2>
			<p>Within the<a id="_idIndexMarker259"/> sphere of managing resources for Kubernetes, Helm stands out as a pivotal instrument that’s designed to enhance and simplify the orchestration process, setting itself apart from similar tools. As a blend between a management utility and a templating engine, Helm generates artifacts that can not only be deployed but also shared and capable of version control, establishing itself as a comprehensive package manager for <span class="No-Break">Kubernetes environments.</span></p>
			<p>By leveraging the <strong class="bold">Go</strong> template language in YAML configurations, Helm streamlines the setup and administration of Kubernetes applications. Helm starts by generating and deploying a Helm project into a Kubernetes cluster. A distinctive feature of Helm is its utilization of <strong class="bold">charts</strong>, setting it apart from tools such as Kustomize. These charts, acting as bundled artifacts, compile all necessary components, including any dependencies, facilitating their widespread distribution <span class="No-Break">and reusability.</span></p>
			<p>Furthermore, Helm tackles the challenges associated with the mutable nature of application settings, particularly within <a id="_idIndexMarker260"/>Kubernetes <strong class="bold">ConfigMaps</strong>. It recognizes that mere alterations to ConfigMaps may not trigger automatic updates to applications. To combat this, Helm introduces methods to activate rolling updates following changes in ConfigMaps, thus ensuring continuous application performance and enhanced management efficiency. This detail-oriented approach highlights the effectiveness of Helm when it comes to governance and updating <span class="No-Break">Kubernetes deployments.</span></p>
			<p class="callout-heading">ConfigMaps</p>
			<p class="callout">ConfigMaps in<a id="_idIndexMarker261"/> Kubernetes serves as a mechanism to store non-confidential data in key-value pairs, which can then be utilized by Pods and other system components. They are designed to separate configuration artifacts from image content to keep containerized applications portable. This enables users to change the configuration without having to rebuild the Docker images, and without exposing sensitive data when the configuration data is not encrypted. ConfigMaps can be used to store fine-grained values such as individual properties or coarse-grained information such as entire configuration files or JSON blobs. This functionality is particularly useful for applications that need to be configured at runtime, making it easier to deploy the same application in different environments without changing the <span class="No-Break">application code.</span></p>
			<p>Adding to its <a id="_idIndexMarker262"/>capabilities, Helm is recognized as an optimal package manager for Kubernetes since it aligns with GitOps methodologies. It serves as an efficient method for bundling and distributing collections of YAML files through Helm charts and enables their dissemination via a Helm repository. This streamlines the management process, offering a solution to the otherwise labor-intensive and monotonous task of handling Kubernetes manifests, illustrating why Helm is considered an invaluable tool in the <span class="No-Break">Kubernetes ecosystem.</span></p>
			<h3>Helm setup</h3>
			<p>Setting up <a id="_idIndexMarker263"/>Helm is generally an easy task. Typically, it involves fetching a script and executing it, as <span class="No-Break">shown here:</span></p>
			<pre class="console">
$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
$ chmod 700 get_helm.sh
$ ./get_helm.sh</pre>			<p>Alternatively, you can execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</pre>			<p>A detailed <a id="_idIndexMarker264"/>step-by-step guide on how to install Helm is beyond the scope of this chapter. More information about Helm and instructions for its installation can be found <span class="No-Break">here: </span><span class="No-Break">https://helm.sh/docs/intro/install/</span><span class="No-Break">.</span></p>
			<p>Type the following command to verify that Helm has been <span class="No-Break">installed correctly:</span></p>
			<pre class="console">
$ helm version</pre>			<p>The expected output should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
version.BuildInfo{Version:"v3.14.2", GitCommit:"c309b6f0ff63856811846ce18f3bdc93d2b4d54b", GitTreeState:"clean", GoVersion:"go1.21.7"}</pre>			<p>Congratulations! Helm is correctly installed and you are ready to create your first <span class="No-Break">Helm project.</span></p>
			<h3>Our first Helm project</h3>
			<p>First, we <a id="_idIndexMarker265"/>need to create a <a id="_idIndexMarker266"/>new <strong class="bold">Helm chart</strong> (or just <strong class="bold">chart</strong>). Helm charts are packages composed of YAML files that specify the resources needed to run an application, tool, or service inside a Kubernetes cluster. To create the Helm project, we need to enter the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ helm create gitops-k8s-deployments-helm</pre>			<p>This command creates a new directory called <strong class="source-inline">gitops-k8s-deployments-helm</strong> containing the scaffold of the project. With this Helm’s directory layout has been created. It should look <span class="No-Break">like this:</span></p>
			<pre class="console">
chart.yaml  charts  templates  values.yaml</pre>			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li><strong class="source-inline">chart.yaml</strong>: This is the descriptor and contains metadata related to the <span class="No-Break">Helm chart</span></li>
				<li><strong class="source-inline">templates</strong>: This directory contains all the template files that are used for installing the Helm chart. Additionally, the <strong class="source-inline">tests</strong> folder within the <strong class="source-inline">templates</strong> directory of a Helm chart repository contains test files that Helm uses to verify <span class="No-Break">the chart.</span></li>
				<li><strong class="source-inline">values.yaml</strong>: This contains the default values for the current <span class="No-Break">Helm chart</span></li>
			</ul>
			<p>Customization of<a id="_idIndexMarker267"/> the <strong class="bold">Helm chart</strong> passes through the edits of the files under the <strong class="source-inline">templates</strong> subdirectory. The content of the <strong class="source-inline">deployment.yaml</strong> file is available in this book’s GitHub repository. At this point, we are ready to view a local preview of the <a id="_idIndexMarker268"/>Helm chart. We can do this by entering the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ helm template .\gitops-k8s-deployments-helm\</pre>			<p>The following is an extract of the <span class="No-Break">expected output:</span></p>
			<pre class="source-code">
---
# Source: gitops-k8s-deployments-helm/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: <strong class="bold">release-name-gitops-k8s-deployments-helm</strong>
  labels:
    helm.sh/chart: gitops-k8s-deployments-helm-0.1.0
    app.kubernetes.io/name: gitops-k8s-deployments-helm
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "1.16.0"
    app.kubernetes.io/managed-by: Helm
spec:
  type: <strong class="bold">ClusterIP</strong>
  ports:
    - port: <strong class="bold">80</strong>
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: gitops-k8s-deployments-helm
    app.kubernetes.io/instance: release-name
---</pre>			<p>Here, the<a id="_idIndexMarker269"/> values for <strong class="source-inline">name</strong>, <strong class="source-inline">type</strong>, <strong class="source-inline">port</strong>, and others are taken from the <strong class="source-inline">values.yaml</strong> file. If possible, override them using the <strong class="source-inline">--set</strong> parameter in the Helm command. For instance, we can override the port value to <strong class="source-inline">8080</strong> <span class="No-Break">like so:</span></p>
			<pre class="console">
$ helm template --set service.port=8080 .</pre>			<p>Using the local Kubernetes cluster, <strong class="source-inline">up&amp;running</strong> (see <span class="No-Break"><em class="italic">Chapter 2</em></span>), we are now able to install our chart and upgrade it. Instead of using the default namespaces, we want to use the <span class="No-Break"><strong class="source-inline">gitops-kubernetes</strong></span><span class="No-Break"> one:</span></p>
			<pre class="console">
$ helm install gitops-k8s-deployments-helm --namespace gitops-kubernetes .</pre>			<p>The output of this command should be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
NAME: gitops-k8s-deployments-helm
LAST DEPLOYED: Sat Mar 2 12:23:21 2024
NAMESPACE: gitops-kubernetes
STATUS: deployed
REVISION: 1
NOTES:
…</pre>			<p>We can list the installed Helm charts using the <strong class="source-inline">helm </strong><span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ helm list --namespace gitops-kubernetes</pre>			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
NAME                            NAMESPACE               REVISION        UPDATED                                 STATUS          CHART                                   APP VERSION
gitops-k8s-deployments-helm     gitops-kubernetes       1               2024-03-02 12:23:21.29488893 +0100 CET  deployed        gitops-k8s-deployments-helm-0.1.0       1.16.0</pre>			<p>We can<a id="_idIndexMarker270"/> retrieve the running Pods with the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ kubectl get pods --namespace gitops-kubernetes</pre>			<p>Here’s the <span class="No-Break">expected output:</span></p>
			<pre class="source-code">
NAME                                            READY   STATUS    RESTARTS       AGE
first-cd-pipeline-deployment-5b85cfd665-wlzq4   1/1     Running   3 (106m ago)   48d
gitops-k8s-deployments-helm-7464b9b75d-mh4xx    1/1     Running   0              4m41s</pre>			<p>We can grab history information about the installed Helm chart using the <span class="No-Break"><strong class="source-inline">history</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ helm history gitops-k8s-deployments-helm --namespace gitops-kubernetes</pre>			<p>At this point, we can imagine upgrading the image (or just the tag) of the images used by our deployment from <strong class="source-inline">nginx</strong> to <strong class="source-inline">nginxdemos/hello</strong>, as specified by the <span class="No-Break"><strong class="source-inline">values.yaml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
image:
  repository: nginxdemos/hello</pre>			<p>We need to change the <strong class="source-inline">appVersion</strong> value in the <strong class="source-inline">chart.yaml</strong> file (for instance, from <strong class="source-inline">1.16.0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">2.0.0</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
appVersion: "2.0.0"</pre>			<p>At this point, we can <a id="_idIndexMarker271"/>upgrade our deployment using the <strong class="source-inline">helm </strong><span class="No-Break"><strong class="source-inline">upgrade</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ helm upgrade gitops-k8s-deployments-helm --namespace gitops-kubernetes .</pre>			<p>We can grab useful information with the <span class="No-Break"><strong class="source-inline">history</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
1               Sat Mar  2 12:23:21 2024        superseded      gitops-k8s-deployments-helm-0.1.0       <strong class="bold">1.16.0          </strong>Install complete
2               Sat Mar  2 12:37:42 2024        deployed        gitops-k8s-deployments-helm-0.2.0       <strong class="bold">2.0.0           Upgrade complete</strong></pre>			<p>To remove the deployment, we can use the <strong class="source-inline">helm </strong><span class="No-Break"><strong class="source-inline">uninstall</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ helm uninstall gitops-k8s-deployments-helm --namespace gitops-kubernetes</pre>			<h3>Integrating Helm charts with GitOps</h3>
			<p>We<a id="_idIndexMarker272"/> can effortlessly integrate Helm charts with Git and GitOps practices to establish a single source of truth for our application’s desired state. This integration is fundamental for modern DevOps workflows as it leverages the versioning capabilities of Git alongside the automated, declarative nature of GitOps. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
git init
git add .
git commit -m "Initial commit of gitops-k8s-deployments-helm."
git remote add origin &lt;your-repository-url&gt;
git push -u origin master</pre>			<p>Now that we have a good understanding of Helm and how it works, it’s time to move on to the next section, which is dedicated to another important <span class="No-Break">tool: Kustomize.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Kustomize</h2>
			<p>Kustomize <a id="_idIndexMarker273"/>is a standalone tool that’s designed to customize Kubernetes configurations. It’s part of Kubernetes itself and was introduced as a feature within <strong class="bold">kubectl</strong> in version 1.14. Kustomize introduces a <strong class="bold">template-free</strong> way to customize application configuration. This differs significantly from other configuration management tools, which rely on templates or scripting. It enables users to declare configuration changes through files that Kubernetes can understand without altering the original YAML files. This method avoids the pitfalls of templating languages and maintains the declarative nature of <span class="No-Break">Kubernetes objects.</span></p>
			<p>Kustomize works by using a file called <strong class="source-inline">kustomization.yaml</strong>, which contains customization instructions. These instructions can include adding labels and annotations, changing the number of replicas, altering container images, and more. Users can build an overlay structure with Kustomize, where a base configuration can serve as a foundation, and overlays can modify this base for specific environments, such as development, staging, <span class="No-Break">or production.</span></p>
			<p>In a GitOps workflow, Kustomize helps manage and apply different configurations for different environments by maintaining them in separate directories within a Git repository. Kustomize enables your team to update base files for core components without disrupting customizations specific to your use case. Additionally, using patch overlays offers the advantage of adding layers to your configuration settings. This allows for easier isolation when troubleshooting or layering configurations from the most general to the most specific. For example, <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em> illustrates how to integrate Kustomize and Helm within a <strong class="bold">continuous deployment</strong> (<span class="No-Break"><strong class="bold">CD</strong></span><span class="No-Break">) pipeline.</span></p>
			<p>Kustomize uses a layered approach to configuration management to <span class="No-Break">facilitate reuse:</span></p>
			<ul>
				<li><strong class="bold">Base layer</strong>: Defines the most widely <span class="No-Break">used resources</span></li>
				<li><strong class="bold">Patch layers</strong>: Tailors resources to specific <span class="No-Break">use cases:</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 4.1 – Example of Kustomize and Helm placed in a CD pipeline" src="image/B22100_04_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Example of Kustomize and Helm placed in a CD pipeline</p>
			<p>When changes <a id="_idIndexMarker274"/>are committed to the repository, a GitOps tool such as <strong class="bold">Argo CD</strong> or <strong class="bold">Flux</strong>, both of which will be covered in the <em class="italic">Argo CD integration with Kubernetes</em> and <em class="italic">Flux integration with Kubernetes</em> sections of this chapter, respectively, can automatically apply the changes to the appropriate Kubernetes clusters based on the Kustomize configurations. This approach enhances automation, improves traceability, and ensures consistency <span class="No-Break">across environments.</span></p>
			<h3>Kustomize setup</h3>
			<p>As previously <a id="_idIndexMarker275"/>mentioned for Helm, setting up Kustomize is an easy task. Execute the following script to detect the corresponding operating system and install the <span class="No-Break">necessary libraries:</span></p>
			<pre class="console">
$ curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash</pre>			<p>For a detailed step-by-step guide on installing Kustomize, please refer to the Kustomize section at Kustomize | SIG <span class="No-Break">CLI (kubernetes.io</span><span class="No-Break"><span class="P---URL">)</span></span><span class="No-Break">.</span></p>
			<p>As a standard step to verify the correctness of the Kustomize setup, you can type the following command in <span class="No-Break">a Terminal:</span></p>
			<pre class="console">
$ kustomize version</pre>			<p>The expected output should resemble <span class="No-Break">the following:</span></p>
			<pre class="source-code">
v5.3.0</pre>			<h3>A Kustomize example for Kubernetes deployment</h3>
			<p><strong class="bold">Kustomize</strong> is a <a id="_idIndexMarker276"/>tool for customizing Kubernetes configurations. It lets you maintain configuration changes separately from the base configuration files, which is particularly useful for keeping track of environment-specific changes without duplication. Let’s dive into a step-by-step example of deploying an application on Kubernetes using GitOps and Kustomize, bringing all the elements together for a <span class="No-Break">cohesive process:</span></p>
			<ol>
				<li>The first step is creating the base configuration where we will add the default Kubernetes <span class="No-Break">resource files:</span><pre class="source-code">
<strong class="bold">$ mkdir gitops-k8s-deployments-kustomize/base</strong></pre></li>				<li>Inside the <strong class="source-inline">base</strong> directory, we need to create a Kubernetes deployment file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">deployment.yaml</strong></span><span class="No-Break">:</span><pre class="source-code">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gitops-k8s-kustomize
  labels:
    app: gitops-k8s-kustomize
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gitops-k8s-kustomize
  template:
    metadata:
      labels:
        app: gitops-k8s-kustomize
    spec:
      containers:
      - name: gitops-k8s-kustomize
        image: k8s.gcr.io/echoserver:1.10
        ports:
        - containerPort: 8080</pre></li>				<li>In the<a id="_idIndexMarker277"/> same base directory, we need to create another Kubernetes service file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">service.yaml</strong></span><span class="No-Break">:</span><pre class="source-code">
apiVersion: v1
kind: Service
metadata:
  name: gitops-k8s-kustomize
spec:
  selector:
    app: gitops-k8s-kustomize
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080</pre></li>				<li>Lastly, within the base directory, create a <strong class="source-inline">kustomization.yaml</strong> file that references your <span class="No-Break">Kubernetes resources:</span><pre class="source-code">
resources:
  - deployment.yaml
  - service.yaml</pre></li>				<li>Now, we need to create the overlay configuration so that we can maintain <strong class="source-inline">patches</strong> separately from the base configuration. You might have different environments, such as <strong class="source-inline">development</strong>, <strong class="source-inline">staging</strong>, and <strong class="source-inline">production</strong>. For instance, we can create an overlay directory and subdirectory for the development environment <span class="No-Break">like so:</span><pre class="source-code">
<strong class="bold">$ mkdir -p overlays/development</strong></pre></li>				<li>Inside<a id="_idIndexMarker278"/> the <strong class="source-inline">overlays/development</strong> directory, create a <strong class="source-inline">kustomization.yaml</strong> file to specify <strong class="source-inline">namespace</strong>, <strong class="source-inline">patches</strong>, and any other <span class="No-Break">environment-specific changes:</span><pre class="source-code">
namespace: gitops-k8s-kustomize-dev
resources:
  - ../../base
patches:
  - path: ./patches/deployment_patch.yaml</pre></li>				<li>Also, in the <strong class="source-inline">overlays/<a id="_idTextAnchor072"/>development</strong> directory, inside the <strong class="source-inline">patches</strong> subdirectory, create a <strong class="source-inline">deployment_patch.yaml</strong> file to update the image or any other properties specific to the development environment. In this case, we are increasing the number of replicas <span class="No-Break">in development:</span><pre class="source-code">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gitops-k8s-kustomize
  labels:
    environment: development
spec:
  replicas: 2  #<strong class="bold"> Increase the number of replicas in development.</strong></pre></li>				<li>At this point, navigate to your overlay directory and use Kustomize to build the final configuration. Then, you can apply it to your Kubernetes cluster. To build the overlay configuration, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ kustomize build overlays/development</strong></pre></li>				<li>Before<a id="_idIndexMarker279"/> applying the configuration to our local cluster, we need to create the <span class="No-Break">proper namespace:</span><pre class="source-code">
<strong class="bold">$ kubectl create namespace gitops-k8s-kustomize-dev</strong></pre></li>				<li>At this point, we can apply the configuration by entering the <span class="No-Break">proper command:</span><pre class="source-code">
<strong class="bold">$ kustomize build overlays/development | kubectl apply -f -</strong></pre></li>				<li>The expectation is to have three replicas running in the specified namespace. We can confirm this by using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ kubectl get pods --namespace gitops-k8s-kustomize-dev</strong></pre><p class="list-inset">This will produce an output similar to <span class="No-Break">the following:</span></p><pre class="source-code">NAME                     READY   STATUS    RESTARTS   AGE
gitops-k8s-kustomize-…   1/1     Running   0          114s
gitops-k8s-kustomize-…   1/1     Running   0          114s</pre></li>				<li>If we want to deploy to a <strong class="source-inline">staging</strong> namespace using three replicas, we need to create an <strong class="source-inline">overlays/staging</strong> folder and add a <strong class="source-inline">kustomization.yaml</strong> file with the <span class="No-Break">following content:</span><pre class="source-code">
namespace: gitops-k8s-kustomize-stg
resources:
  - ../../base
patches:
  - path: ./patches/deployment_patch.yaml</pre></li>				<li>The<a id="_idIndexMarker280"/> content of the <strong class="source-inline">deployment_path.yaml</strong> file will be <span class="No-Break">as follows:</span><pre class="source-code">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gitops-k8s-kustomize
  labels:
    environment: staging
spec:
  replicas: 3  # Increase the number of replicas in staging.</pre></li>				<li>As before, to apply the configuration to our local cluster, we need to create the <span class="No-Break">proper namespace:</span><pre class="source-code">
<strong class="bold">$ kubectl create namespace gitops-k8s-kustomize-stg</strong></pre></li>				<li>At this point, we can apply the configuration by entering the <span class="No-Break">proper command:</span><pre class="source-code">
<strong class="bold">$ kustomize build overlays/staging | kubectl apply -f -</strong></pre></li>				<li>The expectation is to have three replicas running in the specified namespace. We can confirm that using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">$ kubectl get pods --namespace gitops-k8s-kustomize-stg</strong></pre><p class="list-inset">This will produce an output similar to <span class="No-Break">the following:</span></p><pre class="source-code">NAME                     READY   STATUS    RESTARTS   AGE
gitops-k8s-kustomize-…   1/1     Running   0          14s
gitops-k8s-kustomize-…   1/1     Running   0          14s
gitops-k8s-kustomize-…   1/1     Running   0          14s</pre></li>			</ol>
			<h3>Integrating Kustomize with GitOps</h3>
			<p>As <a id="_idIndexMarker281"/>we did for Helm charts, we can effortlessly integrate Kustomize with Git and GitOps practices to establish a single source of truth for our application’s desired state. This integration is fundamental for modern DevOps workflows as it leverages the versioning capabilities of Git alongside the automated, declarative nature <span class="No-Break">of GitOps:</span></p>
			<pre class="source-code">
git init
git add .
git commit -m "Initial commit of gitops-k8s-deployments-kustomize."
git remote add origin &lt;your-repository-url&gt;
git push -u origin master</pre>			<h3>Helm versus Kustomize – configuration tools compared</h3>
			<p>Kustomize <a id="_idIndexMarker282"/>and Helm are both powerful tools that can be used for managing Kubernetes configurations, but they approach configuration management differently and serve slightly different purposes within the <span class="No-Break">Kubernetes ecosystem.</span></p>
			<p><strong class="bold">Helm</strong> is often <a id="_idIndexMarker283"/>described as a package manager for Kubernetes. It uses a packaging format called charts, which are collections of files that describe a related set of Kubernetes resources. Helm charts are templates that can be dynamically configured through the use of values that are passed at runtime. This feature allows complex applications and their dependencies to be deployed using a single command, making Helm particularly suitable for managing packaged applications and sharing them across a wide user base. Helm also supports versioning, which means you can manage and track releases of your applications, roll back to previous versions, and manage application deployment in a <span class="No-Break">structured manner.</span></p>
			<p><strong class="bold">Kustomize</strong>, on<a id="_idIndexMarker284"/> the other hand, introduces a template-free way of customizing Kubernetes applications. It uses a base and overlay model where the base <a id="_idIndexMarker285"/>configuration can be overridden or extended by overlays without altering the original files. This approach is particularly powerful for maintaining slight variations of the same application (for example, across different environments, such as staging and production) without duplicating effort. Kustomize has been integrated directly into kubectl since Kubernetes v1.14, allowing users to apply configurations using the <strong class="source-inline">kubectl apply -k</strong> command. Unlike Helm, Kustomize does not manage packages or dependencies; it focuses purely on <span class="No-Break">configuration customization.</span></p>
			<p>In summary, while both Helm and Kustomize enhance Kubernetes’ native capabilities, they cater to different aspects of application deployment and management. Helm is ideal for defining, installing, and upgrading complex Kubernetes applications as discrete packages, while Kustomize excels at customizing and managing the configurations of these applications across various environments without the need to maintain separate files for each environment. Choosing between them – or using them in tandem – depends on your specific needs and the complexity of your <span class="No-Break">deployment scenarios.</span></p>
			<p>Having explored Helm and Kustomize, we’ll now transition to discussing two other significant tools in the DevOps landscape: Argo CD <span class="No-Break">and Flux.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Argo CD integration with Kubernetes</h1>
			<p>Argo CD is a prominent<a id="_idIndexMarker286"/> GitOps tool that’s designed for Kubernetes and enables automated, CD by syncing application definitions, configurations, and environments directly from a Git repository. This section aims to shed more light on the architecture of Argo CD and its synchronization mechanism. Argo CD follows a <span class="No-Break">client-server architecture:</span></p>
			<ul>
				<li><strong class="bold">Argo CD API server</strong>: The <a id="_idIndexMarker287"/>core service that provides the primary API for Argo CD, it handles user requests and performs application state analyses <span class="No-Break">and reporting.</span></li>
				<li><strong class="bold">Repository server</strong>: This <a id="_idIndexMarker288"/>service is responsible for fetching repository contents and returning manifest files. It understands various configuration management tools, such as Helm, Kustomize, Jsonnet, and others, enabling Argo CD to work with multiple types <span class="No-Break">of manifests.</span></li>
				<li><strong class="bold">Application controller</strong>: This<a id="_idIndexMarker289"/> is the key component that continuously monitors application definitions and configurations in the Git repository. It compares the current state of the cluster with the desired state defined in Git and applies any necessary changes to align <span class="No-Break">the two.</span></li>
				<li><strong class="bold">Argo CD UI and CLI</strong>: The <a id="_idIndexMarker290"/>services provide a visual interface and command-line tooling for users to manage applications, view their states, and perform <span class="No-Break">various operations.</span></li>
				<li><strong class="bold">Dex server</strong>: An<a id="_idIndexMarker291"/> optional component for integrating with external identity providers <span class="No-Break">for authentication.</span></li>
			</ul>
			<p>Argo CD employs a declarative approach to ensure the desired application state defined in a Git repository matches the actual state deployed in the Kubernetes cluster. Here’s how the<a id="_idIndexMarker292"/> synchronization <span class="No-Break">process works:</span></p>
			<ul>
				<li><strong class="bold">Monitoring</strong>: Argo CD continuously monitors the specified Git repository for changes to the application definitions <span class="No-Break">and configurations.</span></li>
				<li><strong class="bold">Comparison</strong>: When changes are detected, Argo CD compares the new desired state defined in Git with the current state of the <span class="No-Break">Kubernetes cluster.</span></li>
				<li><strong class="bold">Convergence</strong>: If discrepancies are found, Argo CD undertakes actions to reconcile the differences. This could involve creating, updating, or deleting Kubernetes resources to ensure the cluster’s state aligns with the configuration specified in the <span class="No-Break">Git repository.</span></li>
				<li><strong class="bold">Self-healing</strong>: If the cluster state deviates from the Git-defined state due to manual changes or other factors, Argo CD automatically corrects these deviations to <span class="No-Break">maintain consistency.</span></li>
				<li><strong class="bold">Manual or automatic sync</strong>: Users can configure Argo CD to synchronize changes either automatically as they occur in the Git repository or require manual intervention for synchronization, providing flexibility based on the team’s workflow <span class="No-Break">and policies.</span></li>
			</ul>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Argo CD setup</h2>
			<p>Setting up and<a id="_idIndexMarker293"/> configuring Argo CD is beyond the scope of this book. For comprehensive and detailed instructions on how to set up Argo CD, we highly recommend visiting the Argo CD website at <a href="https://argo-cd.readthedocs.io/en/stable/getting_started/">https://argo-cd.readthedocs.io/en/stable/getting_started/</a>. There, you will find the most up-to-date documentation, including step-by-step guides, troubleshooting tips, and best practices specifically designed to facilitate a smooth setup process. For the remainder of this chapter, we will assume that Argo CD has been successfully installed <span class="No-Break">and configured.</span></p>
			<p>If Argo CD has been correctly set up on your local laptop, should be possible to navigate the Argo CD UI, which is normally available at <a href="https://localhost:8080">https://localhost:8080</a>, as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 4.2 – Argo CD UI" src="image/B22100_04_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Argo CD UI</p>
			<h3>Deploying to Kubernetes with Argo CD</h3>
			<p>When deploying to Kubernetes with Argo CD, a crucial step is to create an Argo CD application, which<a id="_idIndexMarker294"/> is fundamental to the GitOps-driven deployment strategy. This object connects the version-controlled repository, housing the Kubernetes manifests, to the actual state of applications operating within the Kubernetes cluster, whether local or remote. By establishing an Argo CD application, we dictate to Argo CD what to deploy, the deployment target, and the method of synchronizing the live state with the desired state outlined in the Git repository. To demonstrate the effectiveness of this deployment approach, we will introduce a straightforward application, as detailed in the <span class="No-Break">upcoming section.</span></p>
			<h4>The My City Weather app</h4>
			<p>The<a id="_idIndexMarker295"/> weather app we are deploying provides simulated temperature forecasts and weather updates while utilizing a CSV file as its data source. By deploying on Kubernetes with Argo CD, we can adopt GitOps principles for streamlined, error-free updates, ensuring that our application consistently aligns with the most recent configurations and code changes maintained in the <span class="No-Break">Git repository.</span></p>
			<p>Follow these <a id="_idIndexMarker296"/>steps to deploy the weather app on Kubernetes via <span class="No-Break">Argo CD:</span></p>
			<ol>
				<li><strong class="bold">Create a new GitHub repository</strong>: The first step is to create a new GitHub repository or use an existing one. I suggest that you start from scratch with a new one, as detailed in the <em class="italic">GitHub Flow</em> section in <a href="B22100_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. In the upcoming section, we will refer to the <span class="No-Break"><strong class="source-inline">gitops-k8s-deployments-book-weather-app</strong></span><span class="No-Break"> repository.</span></li>
				<li><strong class="bold">Populate the GitHub repository</strong>: The second step is populating the repository we created in <em class="italic">Step 1</em> with the files located in the <strong class="source-inline">Chapter_4/argocd_gitops</strong> directory of the repository accompanying <span class="No-Break">this book.</span><p class="list-inset">The outcome should resemble what’s depicted in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.3</em>. The <strong class="source-inline">src</strong> folder will contain the necessary files to construct a chart, which will display temperatures retrieved from a CSV file that is deployed alongside the application to the end user. The deployment folder will contain the Kubernetes manifest files (such as <strong class="source-inline">deployment.yaml</strong> and <strong class="source-inline">service.yaml</strong>) that are used to ensure synchronization between the Argo CD application’s state and the repository’s state. Additionally, the <strong class="source-inline">.github/workflows</strong> directory will house the definitions of the CI/CD pipeline used by GitHub Actions. This pipeline is responsible for building and pushing a new Docker image to a container registry each time changes are committed to the GitHub repository, thereby automating<a id="_idIndexMarker297"/> the deployment process and ensuring that updates are seamlessly reflected in the live application. To complete this section, you need to have a valid Docker Hub account, as mentioned in the <em class="italic">Publishing the image to a container registry</em> section in <span class="No-Break"><em class="italic">Chapter 2</em></span><span class="No-Break">:</span></p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 4.3 – The new GitHub repository is now populated with Kubernetes manifest files and application files" src="image/B22100_04_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The new GitHub repository is now populated with Kubernetes manifest files and application files</p>
			<ol>
				<li value="3"><strong class="bold">Deployment status</strong>: By clicking on the <strong class="bold">Actions</strong> tab of our repository, we should be able to see at least one completed workflow, as illustrated in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 4.4 – Our completed the build and push pipeline" src="image/B22100_04_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Our completed the build and push pipeline</p>
			<ol>
				<li value="4"><strong class="bold">Argo CD application</strong>: At this <a id="_idIndexMarker298"/>point, we are ready to define the Argo CD application. As usual, we must define a YAML file containing the definition of the application we want to deploy via Argo CD. Let’s create a file named <strong class="source-inline">argco_cd_deployment.yaml</strong> (the name isn’t important) with the <span class="No-Break">following content:</span><pre class="source-code">
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  <strong class="bold">name</strong>: my-city-weahter-app
  <strong class="bold">namespace</strong>: argocd
spec:
  <strong class="bold">destination</strong>:
    namespace: <strong class="bold">gitops-kubernetes</strong>
    server: https://kubernetes.default.svc
  <strong class="bold">project</strong>: default
  source:
    <strong class="bold">repoURL</strong>: https://github.com/[USERNAME]/[REPOSITORY].git
    <strong class="bold">path</strong>: deployment
    <strong class="bold">targetRevision</strong>: main</pre><p class="list-inset">In this context, <strong class="source-inline">name</strong> defines the name of the Argo CD’s application, <strong class="source-inline">namespace</strong> defines where Argo CD is installed, and <strong class="source-inline">destination</strong> specifies the target Kubernetes cluster and namespace (in our case, <strong class="source-inline">gitops-kubernetes</strong>). The <strong class="source-inline">project</strong> parameter indicates that the application should be installed within Argo CD’s default project. The <strong class="source-inline">repoURL</strong> parameter denotes the repository where the Kubernetes manifest YAML files are located, <strong class="source-inline">path</strong> specifies where <a id="_idIndexMarker299"/>to look for these manifests, and <strong class="source-inline">targetRevision</strong> identifies the repository branch to be <span class="No-Break">checked out.</span></p><p class="list-inset">To create the defined application in Argo CD, enter the <span class="No-Break">following command:</span></p><pre class="source-code"><strong class="bold">$ kubectl apply -f argocd-deployment.yaml</strong></pre><p class="list-inset">The expected output is <span class="No-Break">shown here:</span></p><pre class="source-code">application.argoproj.io/my-city-weahter-app created</pre><p class="list-inset">The crucial field to observe, as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.5</em>, is <strong class="bold">Status</strong>, which is labeled as <strong class="bold">OutOfSync</strong>. This status indicates that although the application has been registered, there is a <strong class="bold">mismatch</strong> between its current state (in this case, the application has not been deployed yet) and the information in the Git repository (which contains the application’s <span class="No-Break">deployment files):</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="" role="presentation" src="image/B22100_04_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The new Argo CD application has been successfully added to the default project</p>
			<p class="list-inset">Click the <strong class="bold">Sync</strong> button<a id="_idIndexMarker300"/> to start the synchronization process. After a few seconds, <strong class="bold">Status</strong> should be <strong class="bold">Synced</strong>, as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="" role="presentation" src="image/B22100_04_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The Argo CD application has been successfully synchronized with the repository</p>
			<p class="list-inset">Clicking on the <strong class="source-inline">my-city-weather</strong> app provides additional details about the Argo CD application, as illustrated in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="" role="presentation" src="image/B22100_04_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Graphical view of the resources deployed by Argo CD to the Kubernetes cluster</p>
			<ol>
				<li value="5"><strong class="bold">Modify the application</strong>: Make changes to your application’s code or Kubernetes<a id="_idIndexMarker301"/> manifests and push these changes to your GitHub repository. For instance, we can change the number of replicas in the <strong class="source-inline">deployment\deployment.yaml</strong> file from <strong class="source-inline">1</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">:</span><pre class="source-code">
spec:
  <strong class="bold">replicas</strong>: <strong class="bold">2</strong>
  selector:
    matchLabels:</pre><p class="list-inset">This change will trigger the proper action and a new run of the build-and-push pipeline will be performed, as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="" role="presentation" src="image/B22100_04_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Executing a new run of the defined pipeline</p>
			<p class="list-inset">Now, observe<a id="_idIndexMarker302"/> how Argo CD detects that the live state (current deployment in Kubernetes) is out of sync with the desired state (the latest changes in your Git repository), as shown in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="" role="presentation" src="image/B22100_04_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Argo CD’s status changes to OutOfSync after modifying the number of replicas</p>
			<ol>
				<li value="6"><strong class="bold">Sync Argo CD</strong>: Use the Argo CD UI or CLI to synchronize the changes, updating your Kubernetes deployment so that it matches the latest state defined in your <span class="No-Break">GitHub repository.</span></li>
			</ol>
			<p>Congratulations<a id="_idIndexMarker303"/> on successfully navigating Argo CD! You’ve made significant strides in mastering GitOps principles and applying them effectively in a Kubernetes environment. As we transition from Argo CD, we’ll embark on exploring another pivotal GitOps tool: Flux. The next section will guide you through the fundamentals of Flux, offering you another perspective on automated deployment strategies within Kubernetes. Let’s continue our journey into the world of GitOps with an in-depth look at Flux and its <span class="No-Break">unique features.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Flux integration with Kubernetes</h1>
			<p>Flux is a <a id="_idIndexMarker304"/>powerful, open source tool that automates the deployment of applications within Kubernetes, embodying the principles of GitOps. As a next-generation deployment solution, Flux continuously monitors your Git repositories for changes and <a id="_idIndexMarker305"/>automatically applies those changes to your Kubernetes clusters, ensuring that the state of your deployments always matches the source of truth in your version control system. This approach not only simplifies deployment workflows but also enhances security, traceability, and reliability across your infrastructure. In this section, we will dive into how Flux can transform your deployment strategy, making your operations more efficient and aligned with modern <span class="No-Break">DevOps practices.</span></p>
			<p>Flux consists of several key components that work together to monitor, pull, and apply configurations from a Git repository to a <span class="No-Break">Kubernetes cluster:</span></p>
			<ul>
				<li><strong class="bold">Flux daemon (Fluxd)</strong>: This<a id="_idIndexMarker306"/> is the core component that continuously monitors the configured Git repository. It checks for new commits to branches, tags, or specific paths and applies the changes to the Kubernetes cluster. It acts as the agent that ensures the desired state from the repository is accurately reflected in <span class="No-Break">the cluster.</span></li>
				<li><strong class="bold">Source controller</strong>: This component acquires source materials from repositories (such as Git) and detects if there are any changes. It ensures that the latest configurations are always used <span class="No-Break">for deployments.</span></li>
				<li><strong class="bold">Kustomize controller (for Flux v2)</strong>: Applies Kustomize configurations, allowing raw Kubernetes manifests to be customized without the need to alter the original <span class="No-Break">YAML files.</span></li>
				<li><strong class="bold">Helm controller (for Flux v2)</strong>: Provides declarative management for Helm chart releases. This component allows Flux to manage Helm chart dependencies directly <span class="No-Break">from Git.</span></li>
				<li><strong class="bold">Git repository</strong>: This is where the Kubernetes resource files (such as YAML manifests, Kustomize configurations, or Helm charts) are stored. Flux relies on this repository as the single source of truth for the state of resources in the <span class="No-Break">Kubernetes cluster.</span></li>
				<li><strong class="bold">Synchronization</strong>: Flux <a id="_idIndexMarker307"/>continuously synchronizes the configuration from the Git repository with the Kubernetes cluster. If it detects any discrepancies between the configuration in Git and the current state of the cluster, it updates the cluster so that it matches the desired state defined <span class="No-Break">in Git.</span></li>
				<li><strong class="bold">Automation and rollback</strong>: Flux supports automated deployments and rollbacks. If a new configuration is detected in the Git repository, Flux automatically applies it to the Kubernetes cluster. Similarly, if a configuration change leads to an error, Flux can revert to the previous stable version, aligning with the rollback capabilities <span class="No-Break">of Git.</span></li>
				<li><strong class="bold">Security and secrets management</strong>: Flux provides mechanisms to handle secrets securely and supports integration with Kubernetes secrets management tools. This ensures that sensitive information is not exposed in the <span class="No-Break">Git repository.</span></li>
				<li><strong class="bold">Observability and notifications</strong>: Flux can be configured to send notifications (for example, via Slack, email, or other messaging platforms) about the status of deployments and sync operations. Additionally, it provides observability features for monitoring the health and performance of the <span class="No-Break">GitOps pipeline.</span></li>
			</ul>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Flux setup</h2>
			<p>Setting<a id="_idIndexMarker308"/> up and configuring Flux is beyond the scope of this book. For comprehensive and detailed instructions on how to set up Flux, we highly recommend <a id="_idIndexMarker309"/>visiting the Flux website at <a href="https://fluxcd.io/flux/installation/">https://fluxcd.io/flux/installation/</a>. There, you will find the most up-to-date documentation, including step-by-step guides, troubleshooting tips, and best practices specifically designed to facilitate a smooth <span class="No-Break">setup process.</span></p>
			<p>You can enter the following command to check you have everything you need to <span class="No-Break">run Flux:</span></p>
			<pre class="source-code">
<strong class="bold">$ flux check --pre</strong></pre>			<p>Before continuing, note the output of the previous command must resemble <span class="No-Break">the following:</span></p>
			<pre class="source-code">
► checking prerequisites
✔ Kubernetes 1.28.5+k3s1 &gt;=1.26.0-0
✔ prerequisites checks passed</pre>			<p>In the upcoming section, we will refer to the same weather app described in the <em class="italic">The My City Weather app</em> section of <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Deploying to Kubernetes with Flux</h2>
			<p>First, we <a id="_idIndexMarker310"/>need to export our GitHub credentials (username and <span class="No-Break">access token):</span></p>
			<pre class="source-code">
export GITHUB_TOKEN=ghp_jlFEXvI…
export GITHUB_USER=[GITHUB_USERNAME]</pre>			<p class="callout-heading">GitHub personal access token (PAT)</p>
			<p class="callout">A GitHub <strong class="bold">PAT</strong> is a<a id="_idIndexMarker311"/> secure way to provide authentication to your GitHub account without the need to use a password. This token acts as a key, granting access to GitHub services through the API, command-line tools, and other third-party applications. This token can be customized with varying scopes of access, from read-only to full repository control, depending on what tasks need to be performed. This flexibility makes PATs particularly useful for automation, scripting, and integrating with third-party services or CI/CD pipelines, ensuring that operations that require GitHub access can be executed securely and efficiently. It’s essential to keep your PATs confidential and treat them with the same level of security as your password to prevent unauthorized access to your <span class="No-Break">GitHub account.</span></p>
			<p>After installing Flux, you <a id="_idIndexMarker312"/>need to bootstrap it to your repository. This connects your Kubernetes cluster to the repository and sets up the necessary components for <span class="No-Break">continuous synchronization:</span></p>
			<pre class="source-code">
flux bootstrap github \
--owner=[GITHUB_USERNAME]\
--repository=gitops-k8s-deployments-book-weather-app \
--path= ./deployment/base
--personal</pre>			<p>The output should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
► connecting to github.com
► cloning branch "main" from Git repository "https://github.com/[GITHUB_USERNAME]/gitops-k8s-deployments-book-weather-app.git"
✔ cloned repository
► generating component manifests
✔ generated component manifests
…
► pushing sync manifests to "https://github.com/[GITHUB_USERNAME]/gitops-k8s-deployments-book-weather-app.git"
► applying sync manifests
✔ reconciled sync configuration
✔ waiting for GitRepository "flux-system/flux-system" to be reconciled
✔ GitRepository reconciled successfully</pre>			<p>By executing the following command, we can verify how the resources of the <strong class="source-inline">flux-system</strong> namespace have been deployed within the <span class="No-Break">respective namespace:</span></p>
			<pre class="source-code">
<strong class="bold">$ kubectl get all -n flux-system</strong></pre>			<p>Now, we need <a id="_idIndexMarker313"/>to create a file in the repository that outlines how Flux should apply the manifests. If you bootstrapped Flux with a path such as <strong class="source-inline">./deployment/base</strong>, you should place the <strong class="source-inline">kustomization.yaml</strong> file inside the <span class="No-Break">deployment directory:</span></p>
			<pre class="source-code">
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - base</pre>			<p>Commit and sync the changes with a comment like <strong class="source-inline">Define Flux Kustomization</strong>. After a few minutes, Flux should start synchronizing the repository’s state with the local Kubernetes cluster. We can check the status of the synchronization by running the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">$ flux get kustomizations</strong></pre>			<p>Once everything is up and running, any changes you make to the Kubernetes manifests in your GitHub repository will be automatically applied to your cluster. Try changing the number of replicas in your <strong class="source-inline">deployment.yaml</strong> file, commit them, and push the changes. Flux will detect the update and apply the change to <span class="No-Break">your cluster.</span></p>
			<p>By following these steps, you have successfully connected your weather app, which is in a GitHub repository, to<a id="_idIndexMarker314"/> your Kubernetes cluster using Flux, achieving a <span class="No-Break">GitOps workflow.</span></p>
			<p>Now that we’ve learned how to deploy to Kubernetes with Flux, we’ll compare Argo CD and Flux. This comparison will shed light on their distinctive capabilities and how each tool positions itself within the Kubernetes <span class="No-Break">deployment ecosystem.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Comparing Argo CD and Flux</h1>
			<p>The following table<a id="_idIndexMarker315"/> compares Argo CD and Flux, two leading GitOps CD tools that are used in the Kubernetes ecosystem that have been introduced in depth in this <a id="_idIndexMarker316"/>chapter. Both tools are designed to automate the deployment process by syncing your Kubernetes cluster state with configurations stored in a Git repository, enabling a declarative approach to infrastructure management. This table outlines key features and differences between Argo CD and Flux to help you understand their capabilities, installation processes, synchronization mechanisms, and other critical aspects, all of which should help you select the right tool for <span class="No-Break">your needs:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Feature</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Argo CD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Flux</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Project Maturity</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Mature, <span class="No-Break">widely adopted</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Mature, <span class="No-Break">widely adopted</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Installation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Custom resource definitions</strong> (<strong class="bold">CRDs</strong>) and a <span class="No-Break">dedicated namespace</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Uses Helm or manifests <span class="No-Break">for installation</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Configuration</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Declarative setup through <span class="No-Break">YAML files</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Declarative setup through <span class="No-Break">YAML files</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Sync Mechanism</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Pull-based from <span class="No-Break">Git repository</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Pull-based from <span class="No-Break">Git repository</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Sync Frequency</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Configurable, default every <span class="No-Break">3 minutes</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Configurable, can be set as low as a <span class="No-Break">few seconds</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Auto-Sync</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Supported, can automatically apply changes <span class="No-Break">from Git</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Supported, can automatically apply changes <span class="No-Break">from Git</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Secret Management</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Integrates with external secret <span class="No-Break">management tools</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Has built-in secret management via <span class="No-Break">Mozilla SOPS</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Customization</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Highly customizable through plugins <span class="No-Break">and hooks</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Extensive customization with Kustomize <span class="No-Break">and Helm</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">User Interface</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Provides a web-based UI for monitoring <span class="No-Break">and management</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Primarily a command line with an optional web <span class="No-Break">UI component</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Multi-Tenancy</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Supported through <span class="No-Break">namespaced installations</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Supported using <span class="No-Break">multiple instances</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Community <span class="No-Break">and Support</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Large community, <span class="No-Break">active development</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Large community, <span class="No-Break">active development</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Rollback Features</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Supports automatic and <span class="No-Break">manual rollbacks</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Supports rollbacks, typically managed <span class="No-Break">through Git</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1 – Argo CD versus Flux – key differences in Kubernetes deployment</p>
			<p>This<a id="_idIndexMarker317"/> section concludes our exploration of the most popular tools that are used in the context of GitOps and Kubernetes. We’ve delved into the intricacies<a id="_idIndexMarker318"/> of various tools that facilitate the GitOps workflow, emphasizing their roles, features, and how they integrate within the Kubernetes ecosystem. By understanding these tools, we equip ourselves with the knowledge necessary to implement efficient, automated, and scalable DevOps practices in <span class="No-Break">cloud-native environments.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Summary</h1>
			<p>This chapter transitioned from theoretical aspects of GitOps to practical applications within Kubernetes by focusing on tools such as Helm, Kustomize, Argo CD, and Flux. It provided a comparative analysis of these tools, highlighting their unique features and how they complement Kubernetes deployments. This chapter was designed for those with foundational Kubernetes knowledge and covered technical prerequisites, how to integrate GitOps tools with Kubernetes clusters, and practical examples for real-world application. Additionally, it offered step-by-step guides for deploying applications using Argo CD and Flux, emphasizing GitOps methodologies for efficient and secure <span class="No-Break">application management.</span></p>
			<p>As we conclude this chapter on orchestrating and managing Kubernetes environments, our exploration transitions to the next frontier: diving into advanced Git repository strategies, service catalog construction, and the scalability of GitOps through ApplicationSet generators. These topics will further refine our understanding of efficient operations and the multifaceted approach required for successful multitenancy and <span class="No-Break">cloud-native scalability.</span></p>
		</div>
	

		<div class="Content" id="_idContainer057">
			<h1 id="_idParaDest-80" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor080"/>Part 2: Harnessing Advanced Orchestrations, Culture, and Control in GitOps Practices</h1>
			<p>In this part, you will delve into advanced GitOps practices. You will learn about scaling GitOps across multiple clusters, architectural designs for efficient operational control, and the cultural transformation required to embrace GitOps fully within IT organizations. This section emphasizes not only the technical implementation but also the strategic and cultural shifts needed to support and sustain GitOps at an enterprise level, providing a holistic view of GitOps adoption <span class="No-Break">and integration.</span></p>
			<p>This part includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B22100_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, GitOps at Scale and Multitenancy</li>
				<li><a href="B22100_06.xhtml#_idTextAnchor109"><em class="italic">Chapter 6</em></a>, GitOps Architectural Designs and Operational Control</li>
				<li><a href="B22100_07.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, Cultural Transformation in IT for Embracing GitOps</li>
			</ul>
		</div>
		<div>
			<div id="_idContainer058">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer059">
			</div>
		</div>
	</body></html>