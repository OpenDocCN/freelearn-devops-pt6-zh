- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Building and Deploying Applications on Istio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Istio上构建和部署应用程序
- en: 'In the previous chapter, we deployed Istio and Kiali into our cluster. We also
    deployed an example application to see how the pieces fit together. In this chapter,
    we’re going to look at what it takes to build applications that will run on Istio.
    We’ll start by examining the differences between microservices and monolithic
    applications. Then, we’ll deploy a monolithic application on Istio and move on
    to building microservices that will run on Istio. This chapter will cover the
    following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将Istio和Kiali部署到了我们的集群中。我们还部署了一个示例应用程序，以查看各个部分如何组合。在本章中，我们将探讨构建能够在Istio上运行的应用程序所需要的内容。我们将从比较微服务和单体应用程序的区别开始。然后，我们将在Istio上部署一个单体应用程序，接着构建在Istio上运行的微服务。本章将涵盖以下主要内容：
- en: Comparing microservices and monoliths
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与单体架构的比较
- en: Deploying a monolith
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署单体应用
- en: Building a microservice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建微服务
- en: Do I need an API gateway?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要API网关？
- en: Once you have completed this chapter, you’ll have a practical understanding
    of the difference between a monolith and a microservice, along with the information
    you’ll need to determine which one is best for you, and you will also have deployed
    a secured microservice in Istio.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将实际理解单体应用与微服务之间的区别，并掌握决定选择哪种架构的相关信息，你还将成功地在Istio中部署一个安全的微服务。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the examples in this chapter, you’ll need:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的示例，你需要：
- en: A running cluster with Istio deployed, as outlined in *Chapter 16*, *An Introduction
    to Istio*.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已部署Istio的运行集群，如*第16章*《Istio简介》中所述。
- en: Scripts from this book’s GitHub repository.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自本书GitHub仓库的脚本。
- en: 'You can access the code for this chapter by going to this book’s GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter17](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter17).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问本书的GitHub仓库来获取本章的代码：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter17](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter17)。
- en: Comparing microservices and monoliths
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与单体架构的比较
- en: Before we dive too deeply into code, we should spend some time discussing the
    differences between microservices and monolithic architecture. The microservices
    versus monolithic architecture debate is as old as computing itself (and the theory
    is probably even older). Understanding how these two approaches relate to each
    other and your problem set will help you decide which one to use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应花一些时间讨论微服务和单体架构的区别。微服务与单体架构的争论几乎与计算机本身的历史一样久远（而且这一理论可能更久远）。理解这两种方法如何相互关联以及与问题集的关系，将帮助你决定使用哪种方法。
- en: My history with microservices versus monolithic architecture
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我与微服务与单体架构的历史
- en: Before we get into the microservices versus monoliths discussion, I wanted to
    share my own history. I doubt it’s unique, but it does frame my outlook on the
    discussion and adds some context to the recommendations in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论微服务与单体架构之前，我想分享一下我自己的历史。我怀疑这并不独特，但它确实为我对这一讨论的看法提供了框架，并为本章中的建议提供了一些背景。
- en: 'My introduction to this discussion was when I was a computer science student
    in college and had started using Linux and open source. One of my favorite books,
    *Open Sources: Voices from the Open Source Revolution*, had an appendix on the
    debate between Andrew Tanenbaum and Linus Torvalds on microkernels versus monolithic
    kernels. Tanenbaum was the inventor of Minix, and a proponent of a minimalist
    kernel, with most of the functionality in user space. Linux, instead, uses a monolithic
    kernel design, where much more is done in the kernel. If you’ve ever run `modprobe`
    to load a driver, you’re interacting with the kernel! The entire thread is available
    at [https://www.oreilly.com/openbook/opensources/book/appa.xhtml](https://www.oreilly.com/openbook/opensources/book/appa.xhtml).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触这个讨论是当我还是一名计算机科学专业的大学生，并开始使用Linux和开源软件时。我最喜欢的书之一，《开放源代码：开源革命的声音》，书中附录讨论了Andrew
    Tanenbaum与Linus Torvalds关于微内核与单体内核的争论。Tanenbaum是Minix的发明者，他支持简约内核，大多数功能在用户空间中完成。而Linux则使用单体内核设计，更多的功能是在内核中完成的。如果你曾经运行过`modprobe`来加载驱动程序，那么你就是在与内核交互！完整的讨论可以在[https://www.oreilly.com/openbook/opensources/book/appa.xhtml](https://www.oreilly.com/openbook/opensources/book/appa.xhtml)查看。
- en: Linus’ core argument was that a well-managed monolith was much easier to maintain
    than a microkernel.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Linus的核心论点是，管理良好的单体架构比微内核更容易维护。
- en: Tanenbaum instead pointed to the idea that microkernels were easier to port
    and that most “modern” kernels were microkernels. Windows (at the time, Windows
    NT) is probably the most prevalent microkernel today. As a software developer,
    I’m constantly trying to find the smallest unit I can build. The microkernel architecture
    really appealed to that aspect of my talents.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Tanenbaum则指出，微内核更容易移植，而且大多数“现代”内核都是微内核。Windows（当时是Windows NT）今天可能是最普遍的微内核。作为软件开发者，我一直在努力找到我可以构建的最小单元。微内核架构真的很吸引我这一方面的才能。
- en: At the same time, I was starting my career in IT, primarily as a Windows developer
    in the data management and analysis space. I spent most of my time working with
    **ASP** (**Active Server Pages**, Microsoft’s version of PHP), Visual Basic, and
    SQL Server. I tried to convince my bosses that we should move off of a monolithic
    application design to use **MTS** (**Microsoft Transaction Server**). MTS was
    my first exposure to what we would call today a distributed application. My bosses
    and mentors all pointed out that our costs, and so our customers’ costs, would
    go through the roof if we injected the additional infrastructure for no benefit
    other than a cleaner code base. There was nothing we were working on that couldn’t
    be accomplished with our tightly bound trio of ASP, Visual Basic, and SQL Server
    at a much lower cost.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我开始了我的IT职业生涯，主要作为数据管理和分析领域的Windows开发人员。我大部分时间都在使用**ASP**（**Active Server
    Pages**，微软版的PHP）、Visual Basic和SQL Server。我试图说服我的老板，我们应该从单体应用设计转向使用**MTS**（**Microsoft
    Transaction Server**）。MTS是我第一次接触到今天我们所称的分布式应用。我的老板和导师们都指出，如果我们为了更干净的代码库而注入额外的基础设施，那我们的成本，进而客户的成本，将会飙升。没有什么我们在做的事情是不能用我们紧密结合的ASP、Visual
    Basic和SQL Server三者组合以更低成本完成的。
- en: I later moved from data management to identity management. I also switched from
    Microsoft to Java. One of my first projects was to deploy an identity management
    vendor’s product that was built using a distributed architecture. At the time,
    I thought it was great, until I started trying to debug issues and trace down
    problems across dozens of log files. I quickly started using another vendor’s
    product that was built as a monolith. Deployments were slow, as they required
    a full recompile, but otherwise, management was much easier, and it scaled every
    bit as well. We found that a distributed architecture didn’t help because identity
    management was done by such a centralized team that having a monolith didn’t impact
    productivity or management. The benefits of distributing implementation just didn’t
    outweigh the additional complexity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我从数据管理转到了身份管理。我也从微软技术转向了Java。我的第一个项目之一是部署一个基于分布式架构构建的身份管理厂商的产品。当时，我认为这很好，直到我开始尝试调试问题并在数十个日志文件中追踪问题。我很快开始使用另一家厂商的产品，它是一个单体架构。尽管部署速度较慢，因为需要完全重新编译，但除此之外，管理要容易得多，而且它的扩展性也同样很好。我们发现，分布式架构并没有带来帮助，因为身份管理是由一个高度集中的团队完成的，采用单体架构并不会影响生产力或管理。将实现分布的好处并不足以抵消额外的复杂性。
- en: Fast forward to the founding of Tremolo Security. This was in 2010, so it was
    before Kubernetes and Istio came along. At the time, virtual appliances were all
    the rage! We decided OpenUnison would take the monolithic approach because we
    wanted to make it easier to deploy and upgrade. In *Chapter 6*, *Integrating Authentication
    into Your Cluster*, we deployed OpenUnison with some Helm charts to layer on different
    configurations. How much harder would it have been had there been an authentication
    service to install, a directory service, a just-in-time provisioning service,
    etc.? It made for a much simpler deployment having one system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到Tremolo Security的成立。那是在2010年，也就是Kubernetes和Istio出现之前。那时，虚拟设备正风靡一时！我们决定OpenUnison采用单体架构，因为我们希望简化部署和升级。在*第六章*，*将身份认证集成到集群中*，我们使用一些Helm图表部署了OpenUnison，以便在不同配置上叠加。假如有一个身份认证服务需要安装，一个目录服务，一个即时配置服务等等，难度会增加多少呢？有一个系统来部署，简化了部署过程。
- en: With all that said, it’s not that I’m anti-microservice—I’m not! When used correctly,
    it’s an incredibly powerful architecture used by many of the world’s largest companies.
    I’ve learned through the years that if it’s not the right architecture for your
    system, it will considerably impact your ability to deliver. Now that I’ve filled
    you in on my own journey through architectures, let’s take a deeper look at the
    differences between microservices and monoliths.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，并不是说我反对微服务——我并不反对！当正确使用时，它是一种非常强大的架构，许多世界上最大的公司都在使用它。多年来我学到的是，如果它不是你的系统的合适架构，它会显著影响你的交付能力。现在我已经跟你分享了我在架构方面的历程，让我们更深入地了解微服务和单体架构之间的区别。
- en: Comparing architectures in an application
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较应用中的架构
- en: First, let’s talk about what these two architecture approaches each do in a
    common example application, a storefront.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈这两种架构方法在一个常见示例应用——店面中的作用。
- en: Monolithic application design
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单体应用设计
- en: 'Let’s say you have an online store. Your store will likely need a product lookup
    service, a shopping cart, a payment system, and a shipping system. This is a vast
    oversimplification of a storefront application, but the point of the discussion
    is how to break up development and not how to build a storefront. There are two
    ways you could approach building this application. The first is you could build
    a monolithic application where all the code for each service is stored and managed
    in the same tree. Your application infrastructure would probably look something
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个在线商店。你的商店可能需要一个产品查找服务、一个购物车、一个支付系统和一个运输系统。这是一个对店面应用的极度简化，但讨论的重点是如何拆分开发，而不是如何构建一个店面。你可以通过两种方式来构建这个应用。第一种是构建一个单体应用，其中每个服务的所有代码都存储并管理在同一个树结构中。你的应用架构可能看起来像这样：
- en: '![A diagram of a storefront application  Description automatically generated](img/B21165_17_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![店面应用的示意图  描述自动生成](img/B21165_17_01.png)'
- en: 'Figure 17.1: Monolithic application architecture'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：单体应用架构
- en: In our application, we have a single system with multiple modules. Depending
    on your programming language of choice, these could be classes, structs, or other
    forms of code module. A central application manages the user’s interaction with
    this code. This would likely be a web frontend with the modules being server-side
    code, written up as web services or a post/response-style app.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们有一个单一的系统，包含多个模块。根据你选择的编程语言，这些模块可能是类、结构体或其他形式的代码模块。一个中央应用程序管理用户与这些代码的交互。这通常是一个网页前端，模块则是服务器端代码，编写为
    Web 服务或请求/响应风格的应用。
- en: Yes, web services can be used in a monolith! These modules likely need to store
    data, usually in some kind of a database. Whether it’s a relational database,
    a document database, or a series of databases isn’t really important.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Web 服务可以在单体架构中使用！这些模块通常需要存储数据，通常是某种形式的数据库。无论是关系型数据库、文档型数据库，还是一系列数据库，其实并不重要。
- en: 'The biggest advantage to this monolithic architecture is it’s relatively simple
    to manage and have the systems interact with each other. If the user wants to
    do a product search, the storefront will likely just execute some code like the
    following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单体架构最大的优势是它相对容易管理，且系统之间可以互相交互。如果用户想进行产品搜索，店面可能只需执行以下类似的代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The application code only needs to know the interface of the services it’s going
    to call. There’s no need to “authenticate” that call from the application controller
    to the product directory module. There’s no concern with creating rate-limiting
    systems or trying to work out which version of the service to use. Everything
    is tightly bound. If you make an update to any system, you know pretty quickly
    if you broke an interface, since you’re likely using a development tool that will
    tell you when module interfaces break. Finally, deployment is usually pretty simple.
    You upload your code to a deployment service (or create a container… this is a
    Kubernetes book!).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码只需要知道它将要调用的服务的接口。无需“验证”从应用控制器到产品目录模块的调用。也无需担心创建速率限制系统或试图弄清楚使用哪个版本的服务。一切都紧密绑定。如果你对任何系统进行了更新，你很快就会知道是否破坏了接口，因为你可能使用了一个开发工具，当模块接口出现问题时，它会告诉你。最后，部署通常也非常简单。你只需要将代码上传到部署服务（或者创建容器……毕竟这是一本
    Kubernetes 书！）。
- en: What happens if you need to have one developer update your ordering system while
    another developer updates your payment system? They each have their own copies
    of the code that need to be merged. After merging, the changes from both branches
    need to be reconciled before deployment. This may be fine for a small system,
    but as your storefront grows, this can become cumbersome to the point of being
    unmanageable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个开发者更新订单系统，而另一个开发者更新支付系统怎么办？他们各自有自己的代码副本，必须合并。在合并之后，两个分支的更改需要在部署之前进行对账。这对于一个小系统可能没问题，但随着你的商店前端不断扩展，这可能会变得繁琐，甚至无法管理。
- en: Another potential issue is, what if there’s a better language or system to build
    one of these services in than the overall application? I’ve been on multiple projects
    over the years where Java was a great choice for certain components, but C# had
    better APIs for others. Maybe one service team was built around Python and another
    on Ruby. Standardization is all well and good, but you wouldn’t use the butt end
    of a screwdriver to drive in a nail for the sake of standardization, would you?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的问题是，如果有比整个应用程序更合适的语言或系统来构建其中的某个服务怎么办？多年来，我参与了多个项目，在一些组件上 Java 是一个不错的选择，而在其他组件上
    C# 提供了更好的 API。也许一个服务团队是基于 Python 构建的，另一个则是基于 Ruby 的。标准化本是好事，但为了标准化，你不会用螺丝刀的尾端来钉钉子吧？
- en: This argument doesn’t pertain to frontend versus backend. An application with
    a JavaScript frontend and a Golang backend can still be a monolithic application.
    Both the Kubernetes Dashboard and Kiali are examples of monolithic applications
    built on service APIs across different languages. Both have HTML and JavaScript
    frontends, while their backend APIs are written in Golang.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点与前端和后端无关。一个具有 JavaScript 前端和 Golang 后端的应用程序仍然可以是一个单体应用程序。Kubernetes Dashboard
    和 Kiali 都是构建在跨语言服务 API 上的单体应用程序示例。它们都有 HTML 和 JavaScript 前端，而后端 API 则是用 Golang
    编写的。
- en: Microservices design
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务设计
- en: 'What if we broke these modules up into services? Instead of having one single
    source tree, we would break our application up into individual services like the
    following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些模块拆分成服务会怎样？我们不再有一个单一的源代码树，而是将应用程序拆分成如下所示的独立服务：
- en: '![A diagram of a storefront application  Description automatically generated](img/B21165_17_02.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一个商店应用程序的图示  描述自动生成](img/B21165_17_02.png)'
- en: 'Figure 17.2: Simple microservices architecture'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2：简单的微服务架构
- en: 'This doesn’t look that much more complex. Instead of a big box, there’s a bunch
    of lines. Let’s zoom in on the call from our frontend to our product lookup service:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不复杂。与其说是一个大框框，不如说是一堆线条。让我们放大看一下前端到产品查询服务的调用：
- en: '![A picture containing text, screenshot, diagram, design  Description automatically
    generated](img/B21165_17_03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![一张包含文本、截图、图表、设计的图片  描述自动生成](img/B21165_17_03.png)'
- en: 'Figure 17.3: Service call architecture'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3：服务调用架构
- en: It’s no longer a simple function or method call. Now, our storefront controller
    needs to determine where to send the service call, and this will likely change
    in each environment. It also needs to inject some kind of authentication token,
    since you wouldn’t want just anyone calling your services. Since the remote service
    no longer has a local code representation, you’ll either need to build the call
    manually or use a schema language to describe your product listing service, combining
    it with a client binding. Once the call is made, the service needs to validate
    the call’s schema and apply security rules for authentication and authorization.
    Once the response is packaged and sent back to our storefront controller, the
    controller needs to validate the schema of the response. If there’s a failure,
    it needs to decide if it’s going to retry or not.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这不再是一个简单的函数或方法调用了。现在，我们的商店控制器需要确定将服务调用发送到哪里，这可能会在每个环境中有所不同。它还需要注入某种认证令牌，因为你不希望任何人都能调用你的服务。由于远程服务不再有本地代码表示，你要么需要手动构建调用，要么使用架构语言来描述你的产品列表服务，并将其与客户端绑定结合起来。一旦调用发出，服务需要验证调用的架构，并应用认证和授权的安全规则。响应被打包并发送回商店控制器后，控制器需要验证响应的架构。如果失败，它需要决定是否重试。
- en: Combine all this additional complexity with version management. Which version
    of the product lookup service should our storefront use? Are other services tightly
    coupled together? There are several benefits to the microservices approach, as
    we discussed earlier, in terms of version and deployment management. These advantages
    come with the cost of additional complexity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些额外的复杂性与版本管理结合起来。我们的前端应该使用哪个版本的产品查找服务？其他服务是否紧密耦合在一起？正如我们之前讨论的，微服务方法在版本和部署管理方面有几个好处。这些优势伴随着额外复杂性的代价。
- en: Choosing between monoliths and microservices
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择单体架构还是微服务
- en: Which of these two approaches is right for you? That really depends. What does
    your team look like? What are your management needs? Do you need the flexibility
    that comes from microservices or will a monolith’s simpler design make for an
    easier-to-manage system?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法哪种适合你？这实际上取决于你的团队是什么样的？你的管理需求是什么？你是否需要微服务带来的灵活性，还是单体架构更简单的设计能够让系统更容易管理？
- en: One of the major benefits of a microservice architecture is that you can have
    multiple teams working on their own code without having to share the same source
    repository. Before assuming that breaking the services into their own source repositories
    will benefit your team, how closely tied are the services? If there are numerous
    interdependencies, then your microservices are really just a distributed monolith,
    and you may not get the benefits of different repositories. It may be easier to
    manage branches and merge them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个主要优点是，你可以让多个团队在自己的代码上工作，而无需共享同一个源代码仓库。在假设将服务拆分到各自的源代码仓库对你的团队有益之前，这些服务的耦合程度如何？如果服务之间有大量的相互依赖，那么你的微服务其实就是一个分布式的单体架构，你可能无法享受到不同仓库带来的好处。管理分支并将它们合并可能会更容易。
- en: Also, will your services need to be called by other systems? Look at the cluster
    we built in the last chapter. Kiali has its own services, but they’re not likely
    to be used by other applications. Jaeger and Prometheus, however, do have services
    that are used by Kiali, even if those systems have their own frontends too. In
    addition to these services, Kiali uses the Kubernetes API. All these components
    are deployed separately and are managed separately. They need to be upgraded on
    their own, monitored, and so on. This can be a management headache because each
    system is independently managed and maintained. That said, it wouldn’t make any
    sense for the Kiali team to re-implement Prometheus and Jaeger in their own project.
    It also wouldn’t make sense to just import the entire source tree for these projects
    and be forced to keep them up to date.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的服务是否需要被其他系统调用？回顾我们在上一章构建的集群，Kiali 有自己的服务，但这些服务不太可能被其他应用程序使用。然而，Jaeger 和
    Prometheus 确实有被 Kiali 使用的服务，即使这些系统也有自己的前端。除了这些服务，Kiali 还使用了 Kubernetes API。所有这些组件都是单独部署和管理的，需要独立升级、监控等。这可能会带来管理上的头痛，因为每个系统都是独立管理和维护的。话虽如此，Kiali
    团队重新实现 Prometheus 和 Jaeger 并没有任何意义。将这些项目的整个源代码导入并强迫保持更新也没有意义。
- en: Using Istio to help manage microservices
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Istio 来帮助管理微服务
- en: We’ve spent quite a bit of time talking about microservices and monoliths without
    talking about Istio. Earlier in this chapter, *Figure 17.3* pointed out decisions
    that were needed by our microservice before we could get to calling our code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经花了相当多的时间讨论微服务和单体架构，但却没有提到 Istio。在本章前面，*图 17.3* 指出了在我们调用代码之前，微服务所需要做出的决策。
- en: These should look familiar because we covered objects from Istio that service
    most of these needs in the last chapter! Istio can remove our need to write code
    to authenticate and authorize clients, discover where services are running, and
    manage traffic routing. Throughout the rest of this chapter, we’re going to walk
    through building a small application off of a microservice, using Istio to leverage
    these common services without having to build them into our code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该很熟悉，因为我们在上一章已经讨论了 Istio 中的对象，它们可以满足大部分需求！Istio 可以消除我们编写代码来进行客户端身份验证和授权、发现服务运行位置以及管理流量路由的需求。在本章的其余部分，我们将通过构建一个小型应用程序来演示如何利用微服务，并使用
    Istio 来利用这些常见服务，而无需将它们构建到我们的代码中。
- en: So far, we’ve looked at the differences between monoliths and microservices,
    and how those differences interact with Istio at a conceptual level. Next, we’ll
    see how a monolith is deployed into Istio.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了单体应用和微服务之间的区别，以及这些区别如何在概念上与Istio进行交互。接下来，我们将看到如何将单体应用部署到Istio中。
- en: Deploying a monolith
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署单体应用
- en: This chapter is about microservices, so why are we starting with deploying monoliths
    in Istio? The first answer is, because we can! There’s no reason to not get the
    benefits of Istio’s built-in capabilities when working with monoliths in your
    cluster. Even though it’s not a “microservice,” it’s still good to be able to
    trace through application requests, manage deployments, and so on. The second
    answer is, because we need to. Our microservice will need to know which user in
    our enterprise is calling it. To do that, Istio will need a JWT to validate. We’ll
    use OpenUnison to generate JWTs first so that we can call our service manually,
    and then so we can authenticate users from a frontend and allow it to call our
    service securely.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容是关于微服务的，那么为什么我们从在Istio中部署单体应用开始呢？第一个答案是，因为我们可以！在集群中使用单体应用时，完全没有理由不享受Istio内置功能的好处。即使它不是“微服务”，但能够追踪应用请求、管理部署等依然很有用。第二个答案是，因为我们需要这么做。我们的微服务需要知道在我们的企业中是哪个用户在调用它。为了做到这一点，Istio需要一个JWT来验证。我们将首先使用OpenUnison生成JWT，以便我们可以手动调用服务，然后我们可以从前端进行用户身份验证，并确保安全地调用我们的服务。
- en: 'Starting with your cluster from *Chapter 16*, we’re now going to deploy OpenUnison.
    Go to the `chapter17/openunison-istio` directory and run `deploy_openunison_istio.sh`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第16章*开始，我们现在要部署OpenUnison。进入`chapter17/openunison-istio`目录，并运行`deploy_openunison_istio.sh`：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is going to take a while to run. This script does a few things:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一段时间来运行。这个脚本做了几件事：
- en: Deploys `cert-manager` with our enterprise CA.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的企业CA部署`cert-manager`。
- en: Deploys all of the OpenUnison components (including our testing Active Directory)
    for impersonation, so we don’t need to worry about updating the API server for
    SSO to work.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署所有OpenUnison组件（包括我们的测试Active Directory）用于模拟，因此我们不需要担心更新API服务器以使SSO工作。
- en: 'Labels the `openunison` namespace with `istio-injection: enabled`. This tells
    Istio to enable sidecar injection for all pods. You can do this manually by running
    `kubectl label ns openunison istio-injection=enabled`.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '给`openunison`命名空间打上`istio-injection: enabled`标签。这告诉Istio为所有Pod启用sidecar注入。你可以通过运行`kubectl
    label ns openunison istio-injection=enabled`手动完成此操作。'
- en: Creates all of our Istio objects for us (we’ll go into the details of these
    next).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们创建所有的Istio对象（接下来我们将详细介绍这些对象）。
- en: Creates an `ou-tls-certificate` Certificate in the the `istio-system` namespace.
    Again, we’ll dive into the details as to why in the next section.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`istio-system`命名空间中创建一个`ou-tls-certificate`证书。再次说明，为什么要这么做我们将在下一节详细探讨。
- en: Once the script is run, we’re able to now log in to our monolith! Just like
    in *Chapter 6*, *Integrating Authentication into Your Cluster*, go to `https://k8sou.apps.XX-XX-XX-XX.nip.io/`
    to log in, where `XX-XX-XX-XX` is your host’s IP address.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本运行完毕，我们现在可以登录到我们的单体应用了！就像在*第6章*中提到的，*将身份验证集成到集群中*，访问`https://k8sou.apps.XX-XX-XX-XX.nip.io/`进行登录，其中`XX-XX-XX-XX`是你主机的IP地址。
- en: For instance, my host runs on `192.168.2.114`, so my URL is `https://k8sou.apps.192-168-2-114.nip.io/`.
    Again, as in *Chapter 6*, the username is `mmosley` and the password is `start123`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我的主机的IP地址是`192.168.2.114`，因此我的URL是`https://k8sou.apps.192-168-2-114.nip.io/`。同样，正如在*第6章*中提到的，用户名是`mmosley`，密码是`start123`。
- en: Now that our monolith is deployed, let’s walk through the Istio-specific configuration
    as it relates to our deployment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的单体应用已经部署好了，让我们一步一步地了解与部署相关的Istio特定配置。
- en: Exposing our monolith outside our cluster
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的单体应用暴露到集群外部
- en: 'Our OpenUnison is running, so let’s look at the objects that expose it to our
    network. There are two main objects that do this work: `Gateway` and `VirtualService`.
    These objects were created when we installed OpenUnison. How these objects are
    configured was described in *Chapter 16*, *An Introduction to Istio*. Then, we’ll
    look at running instances to show how they grant access. First, let’s look at
    the important parts of our gateways. There are two. The first one, `openunison-gateway-orchestra`,
    handles access to the OpenUnison portal and the Kubernetes Dashboard:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的OpenUnison已经在运行，让我们来看看将它暴露到网络中的对象。完成这项工作的有两个主要对象：`Gateway`和`VirtualService`。这些对象是在我们安装OpenUnison时创建的。如何配置这些对象已经在*第16章*，*Istio简介*中描述过。接下来，我们将查看正在运行的实例，展示它们如何授予访问权限。首先，让我们来看一下网关的关键部分。有两个网关，第一个是`openunison-gateway-orchestra`，它负责访问OpenUnison门户和Kubernetes仪表板：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `selector` tells Istio which `ingress-ingressgateway` pod to work with.
    The default gateway deployed to `istio-system` has the label `istio: ingressgateway`,
    which will match this one. You could run multiple gateways, using this section
    to determine which one you want to expose your service to. This is useful if you
    have multiple networks with different traffic or if you want to separate traffic
    between applications on a cluster.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector`告诉Istio要与哪个`ingress-ingressgateway` pod进行交互。部署到`istio-system`的默认网关具有标签`istio:
    ingressgateway`，它将与这个网关匹配。你可以运行多个网关，使用这个部分来确定你希望将服务暴露给哪一个。如果你有多个网络并且流量不同，或者你想要在集群中分隔应用之间的流量，这将非常有用。'
- en: The first entry in the `servers` list tells Istio that if a request comes on
    HTTP to port `80` for either of our hosts, then we want Istio to send a redirect
    to the HTTPS port. This is a good security practice, so folks, don’t try to bypass
    HTTPS. The second entry in `servers` tells Istio to accept HTTPS connections on
    port `443`, using the certificate in the `Secret` named `ou-tls-certificate`.
    This `Secret` must be a TLS `Secret` and be in the same namespace as the pod running
    the ingress gateway. For our cluster, this means that `ou-tls-certificate` *MUST*
    be in the `istio-system` namespace. That’s why our deployment script created the
    wild card certificate in the `istio-system` namespace. This is different from
    using an `Ingress` object with NGINX, where you keep the TLS `Secret` in the same
    namespace as your `Ingress` object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`servers`列表中的第一个条目告诉Istio，如果请求通过HTTP进入端口`80`，并且目标是我们的任一主机，那么我们希望Istio将请求重定向到HTTPS端口。这是一种良好的安全实践，因此大家不要试图绕过HTTPS。`servers`中的第二个条目告诉Istio接受端口`443`上的HTTPS连接，并使用名为`ou-tls-certificate`的`Secret`中的证书。这个`Secret`必须是TLS类型的`Secret`，并且必须与运行入口网关的pod位于同一命名空间。对于我们的集群，这意味着`ou-tls-certificate`*必须*位于`istio-system`命名空间中。这就是为什么我们的部署脚本在`istio-system`命名空间中创建了通配符证书。这与使用NGINX的`Ingress`对象不同，后者将TLS
    `Secret`保留在与`Ingress`对象相同的命名空间中。'
- en: If you don’t include your `Secret` in the correct namespace, it can be difficult
    to debug. The first thing you’ll notice is that when you try to connect to your
    host, your browser will report that the connection has been reset. This is because
    Istio doesn’t have a certificate to serve. Kiali won’t tell you there’s a configuration
    issue, but looking at the `istiod` pod in `istio-system`'s logs, you’ll find `failed
    to fetch key and certificate for kubernetes://secret-name`, where `secret-name`
    is the name of your `Secret`. Once you copy your `Secret` into the correct namespace,
    your app will start working on HTTPS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有将你的`Secret`放在正确的命名空间中，可能会很难调试。你首先会注意到，当你尝试连接到主机时，浏览器会报告连接已被重置。这是因为Istio没有证书可以提供。Kiali不会告诉你有配置问题，但通过查看`istio-system`中`istiod`
    pod的日志，你会发现`failed to fetch key and certificate for kubernetes://secret-name`，其中`secret-name`是你的`Secret`的名称。一旦你将`Secret`复制到正确的命名空间中，应用程序就会开始在HTTPS上工作。
- en: 'The second Gateway, `openunison-api-gateway-orchestra`, is used to expose OpenUnison
    directly via HTTPS for the API server host. This bypasses most of Istio’s built-in
    functionality, so it’s not something we’ll want to do unless needed. The important
    difference in this Gateway versus our other Gateway is how we configure TLS:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个网关是`openunison-api-gateway-orchestra`，用于通过HTTPS直接暴露OpenUnison的API服务器主机。这绕过了Istio的内建功能，因此除非有必要，否则我们不希望这样做。这个网关与我们的另一个网关的主要区别在于我们如何配置TLS：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use `PASSTHROUGH` as the `mode` instead of `SIMPLE`. This tells Istio to
    not bother trying to decrypt the HTTPS request and, instead, send it downstream.
    We have to do this for the Kubernetes API calls because Envoy doesn’t support
    the SPDY protocol used by kubectl for `exec`, `cp`, and `port-forward`, so we
    need to bypass it. This, of course, means that we lose much of Istio’s capabilities,
    so it’s not something we want to do if we can avoid it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`PASSTHROUGH`作为`mode`，而不是`SIMPLE`。这告诉Istio不要费力去解密HTTPS请求，而是直接将其下游传送。我们必须为Kubernetes
    API调用这样做，因为Envoy不支持kubectl用于`exec`、`cp`和`port-forward`的SPDY协议，因此我们需要绕过它。当然，这也意味着我们失去了Istio的许多功能，所以如果能避免，最好不要这样做。
- en: 'While the `Gateway` objects tell Istio how to listen for connections, the `VirtualService`
    objects tell Istio where to send the traffic to. Just like with the `Gateway`
    objects, there are two `VirtualService` objects. The first object handles traffic
    for both the OpenUnison portal and the Kubernetes Dashboard. Here are the important
    parts:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gateway`对象告诉Istio如何监听连接，而`VirtualService`对象则告诉Istio将流量发送到哪里。就像`Gateway`对象一样，这里有两个`VirtualService`对象。第一个对象处理OpenUnison门户和Kubernetes仪表盘的流量。以下是其中的重要部分：'
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `gateways` section tells Istio which `Gateway` objects to link this to.
    You could, in theory, have multiple Gateways as sources for traffic. The `hosts`
    section tells Istio which hostnames to apply this configuration to, with the `match`
    section telling Istio what conditions to match requests on. This section can provide
    quite a bit of power for routing microservices, but for monoliths, just `/` is
    usually good enough.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`gateways`部分告诉Istio要将这个配置链接到哪些`Gateway`对象。理论上，你可以有多个Gateway作为流量的来源。`hosts`部分告诉Istio将此配置应用于哪些主机名，而`match`部分则告诉Istio要根据什么条件匹配请求。对于微服务路由，这部分可以提供很大的灵活性，但对于单体应用，通常`/`就足够了。'
- en: Finally, the `route` section tells Istio where to send the traffic. `destination.host`
    is the name of the `Service` you want to send the traffic to. We’re sending all
    traffic to port `80` (sort of).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`route`部分告诉Istio将流量发送到哪里。`destination.host`是你想要发送流量的`Service`名称。我们将所有流量发送到端口`80`（大致如此）。
- en: The NGINX `Ingress` version of this configuration sent all traffic to OpenUnison’s
    HTTPS port (`8443`). This meant that all data was encrypted over the wire from
    the user’s browser, all the way to the OpenUnison pod. We’re not doing that here
    because we’re going to rely on mTLS from Istio’s sidecar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置的NGINX `Ingress`版本将所有流量发送到OpenUnison的HTTPS端口（`8443`）。这意味着所有数据都会在用户浏览器和OpenUnison
    Pod之间的网络传输中被加密。我们在这里并没有这样做，因为我们将依赖Istio的sidecar来进行mTLS。
- en: Even though we’re sending traffic to port `80` using HTTP, the traffic will
    be encrypted from when it leaves the `ingressgateway` pod until it arrives at
    the sidecar on our OpenUnison pod that intercepts all of OpenUnison’s inbound
    network connections. There’s no need to configure TLS explicitly!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们通过HTTP将流量发送到端口`80`，从流量离开`ingressgateway` Pod直到到达OpenUnison Pod上的sidecar并拦截所有OpenUnison的入站网络连接之前，这些流量都会被加密。无需显式配置TLS！
- en: 'Now that we’re routing traffic from our network to OpenUnison, let’s tackle
    a common requirement of monolithic applications: sticky sessions.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将流量从我们的网络路由到OpenUnison，接下来我们来处理单体应用程序中的一个常见需求：粘性会话。
- en: Configuring sticky sessions
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置粘性会话
- en: Most monolithic applications require sticky sessions. Enabling sticky sessions
    means that every request in a session is sent to the same pod. This is generally
    not needed in microservices because each API call is distinct. Web applications
    that users interact with generally need to manage state, usually via cookies.
    However, those cookies don’t generally store all of the session’s state because
    they would get too big and would likely have sensitive information. Instead, most
    web applications use a cookie that points to a session that’s saved on the server,
    usually in memory. While there are ways to make sure that this session is available
    to any instance of the application in a highly available way, it’s not very common
    to do so. These systems are expensive to maintain and are generally not worth
    the work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenUnison is no different than most other web applications and needs to make
    sure that sessions are sticky to the pod they originated from. To tell Istio how
    we want sessions to be managed, we use `DestinationRule`. The `DestinationRule`
    objects tell Istio what to do about traffic routed to a host by a `VirtualService`.
    Here are the important parts of ours:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `host` in the rule refers to the target (`Service`) of the traffic, not
    the hostname in the original URL. `spec.trafficPolicy.loadBalancer.consistentHash`
    tells Istio how we want to manage stickiness. Most monolithic applications will
    want to use cookies. `ttl` is set to `0s`, so the cookie is considered a “session
    cookie.” This means that when the browser is closed, the cookie disappears from
    its cookie jar.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: You should avoid cookies with specific times to live. These cookies are persisted
    by the browser and can be treated as a security risk by your enterprise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: With OpenUnison up and running and understanding how Istio is integrated, let’s
    take a look at what Kiali will tell us about our monolith.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Kiali and OpenUnison
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s integrate OpenUnison and Kiali. Kiali, like any other cluster
    management system, should be configured to require access. Kiali, just like the
    Kubernetes Dashboard, can integrate with Impersonation so that Kiali will interact
    with the API server, using the user’s own permissions. Doing this is pretty straight
    forward. We created a script in the `chapter17/kiali` folder called `integrate-kiali-openunison.sh`
    that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the old Gateways and VirtualServices for Kiali, Prometheus, Jaeger,
    and Grafana.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates Grafana to accept a header for SSO from OpenUnison.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates the Kiali Helm chart to use `header` for `auth.strategy` and restarts
    Kiali to pick up the changes.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redeploys OpenUnison with Kiali, Prometheus, Jaeger, and Grafana integrated
    for SSO.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The integration works the same way as the dashboard, but if you’re interested
    in the details, you can read about them at [https://openunison.github.io/applications/kiali/](https://openunison.github.io/applications/kiali/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'With the integration completed, let’s see what Kiali can tell us about our
    monolith. First, log in to OpenUnison. You’ll see new badges on the portal screen:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, logo, company name  Description automatically
    generated](img/B21165_17_04.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: OpenUnison portal with the Kiali, Prometheus, Grafana, and Jaeger
    badges'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on the **Kiali** badge to open Kiali, then click on **Graphs**,
    and choose the **openunison** namespace. You’ll see a graph similar to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21165_17_05.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: OpenUnison graph in Kiali'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: You can now view the connections between OpenUnison, `apacheds`, and other containers
    the same way you would with a microservice! Speaking of which, now that we’ve
    learned how to integrate a monolith into Istio, let’s build a microservice and
    learn how it integrates with Istio.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Building a microservice
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We spent quite a bit of time talking about monoliths. First, we discussed which
    is the best approach for you, then we spent some time showing how to deploy a
    monolith into Istio to get from it many of the benefits that microservices do.
    Now, let’s dive into building and deploying a microservice. Our microservice will
    be pretty simple. The goal is to show how a microservice is built and integrated
    into an application, rather than how to build a full-fledged application based
    on microservices. Our book is focused on enterprise, so we’re going to focus on
    a service that:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Requires authentication from a specific user
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires authorization for a specific user based on a group membership or attribute
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does something very *important*
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates some log data about what happened
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is common in enterprise applications and the services they’re built on.
    Most enterprises need to be able to associate actions, or decisions, with a particular
    person in an organization. If an order is placed, who placed it? If a case is
    closed, who closed it? If a check is cut, who cut it? There are of course many
    instances where a user isn’t responsible for an action. Sometimes, it’s another
    service that is automated. A batch service that pulls in data to create a warehouse
    isn’t associated with a particular person. That is an **interactive** service,
    meaning that an end user is expected to interact with it, so we’re going to assume
    that the user is a person in the enterprise.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Once you know who is going to use the service, you’ll then need to know if the
    user is authorized to do so. In the previous paragraph, we identified that you
    need to know “who cut the check.” Another important question is, “Are they allowed
    to cut the check?” You really don’t want just anybody in your organization sending
    out checks, do you? Identifying who is authorized to perform an action could be
    the subject of multiple books, so to keep things simple, we’ll make our authorization
    decisions based on group membership, at least at a high level.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Having identified the user and authorized them, the next step is to do something
    *important*. It’s an enterprise, filled with important things that need doing!
    Since writing a check is something that we can all relate to and represents many
    of the challenges enterprise services face, we’re going to stick with this as
    our example. We’re going to write a check service that will let us send out checks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Finally, having done something *important*, we need to make a record of it.
    We need to track who called our service, and once the service does the important
    parts, we need to make sure we record it somewhere. This can be recorded in a
    database or another service, or even sent to standard-out so that it can be collected
    by a log aggregator, like the OpenSearch we deployed in *Chapter 15*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Having identified all the things that our service will do, the next step is
    to identify which part of our infrastructure will be responsible for each decision
    and action. For our service:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **Component** | **Description** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| User Authentication | OpenUnison | Our OpenUnison instance will authenticate
    users to our “Active Directory” |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| Service Routing | Istio | How we will expose our service to the world |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| Service Authentication | Istio | The `RequestAuthentication` object will
    describe how to validate the user for our service |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| Service Coarse Grained Authorization | Istio | `AuthorizationPolicy` will
    make sure users are members of a specific group to call our service |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| Fine-Grained Authorization, or Entitlements | Service | Our service will
    determine which payees you’re able to write checks for |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| Writing a Check | Service | The point of writing this service! |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| Log who Wrote the Check and to whom it was Sent | Service | Write this data
    to standard-out |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| Log Aggregation | Kubernetes | In production – a tool like OpenSearch |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: 'Table 17.1: Service responsibilities'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build each of these components, layer by layer, in the following sections.
    Before we get into the service itself, we need to say hello to the world.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Hello World
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first service will be a simple Hello World service that will serve as the
    starting point for our check-writing service. Our service is built on Python using
    Flask. We’re using this because it’s pretty simple to use and deploy. Go to `chapter17/hello-world`
    and run the `deploy_helloworld.sh` script. This will create our `Namespace`, `Deployment`,
    `Service`, and `Istio` objects. Look at the code in the `service-source ConfigMap`.
    This is the main body of our code and the framework on which we will build our
    check service. The code itself doesn’t do much:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code accepts all requests to `/` and runs our function called `hello()`,
    which sends a simple response. We’re embedding our code as a `ConfigMap` for the
    sake of simplicity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve read all the previous chapters, you’ll notice that we’re violating
    some cardinal rules with this container from a security standpoint. It’s a Docker
    Hub container running as root. That’s OK for now. We didn’t want to get bogged
    down in the build processes for this chapter. In *Chapter 19**, Building a Developer
    Portal*, we’ll walk through using GitLab workflows to build out a more secure
    version of the container for this service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our service is deployed, we can test it out by using `curl`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code isn’t terribly exciting, but next, we’ll add some security to our
    service.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Integrating authentication into our service
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 16*, *An Introduction to Istio*, we introduced the `RequestAuthentication`
    object. Now, we will use this object to enforce authentication. We want to make
    sure that in order to access our service, you must have a valid JWT. In the previous
    example, we just called our service directly. Now, we want to only get a response
    if a valid JWT is embedded in the request. We need to make sure to pair our `RequestAuthentication`
    with an `AuthorizationPolicy` that forces Istio to require a JWT; otherwise, Istio
    will only reject JWTs that don’t conform to our `RequestAuthentication` but allow
    requests that have no JWT at all.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Even before we configure our objects, we need to get a JWT from somewhere.
    We’re going to use OpenUnison. To work with our API, let’s deploy the pipeline
    token generation chart we deployed in *Chapter 6**, Integrating Authentication
    into Your Cluster*. Go to the `chapter6/pipelines` directory and run the Helm
    chart:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will give us a way to easily generate a JWT from our internal Active Directory.
    Next, we’ll deploy the actual policy objects. Go into the `chapter17/authentication`
    directory and run `deploy-auth.sh`. It will look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we created a `Secret` called `cacerts` to store our enterprise CA certificate
    and restart `istiod`. This will allow `istiod` to communicate with OpenUnison
    to pull `jwks` signature verification keys. Next, two objects are created. The
    first is the `RequestAuthentication` object and then a simple `AuthorizationPolicy`.
    First, we will walk through `RequestAuthentication`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This object first specifies how the JWT needs to be formatted in order to be
    accepted. We’re cheating here a bit by just leveraging our Kubernetes JWT. Let’s
    compare this object to our JWT:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `aud` claim in our JWT lines up with the audiences in our `RequestAuthentication`.
    The `iss` claim lines up with `issuer` in our `RequestAuthentication`. If either
    of these claims doesn’t match, then Istio will return a `401` HTTP error code
    to tell you that the request is unauthorized.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specify `outputPayloadToHeader: User-Info` to tell Istio to pass the
    user info to the downstream service as a base64-encoded JSON header, with the
    name `User-Info`. This header can be used by our service to identify who called
    it. We’ll get into the details of this when we get into entitlement authorization.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `jwksUri` section specifies the URL that contains the RSA
    public keys used to verify the JWT. This can be obtained by first going to the
    issuer’s OIDC discovery URL and getting the URL from the `jwks` claim.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the `RequestAuthentication` object will tell Istio
    what form the JWT needs to take, but not what data about the user needs to be
    present. We’ll cover that next, in the authorization section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of authorization, we want to make sure to enforce the requirement
    for a JWT, so we will create this very simple `AuthorizationPolicy`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `from` section says that there must be a `requestPrincipal`. This tells
    Istio there must be a user (and in this case, anonymous is not a user). `requestPrincipal`
    comes from JWTs and represents users. There is also a `principal` configuration,
    but this represents the service calling our URL, which in this case would be `ingressgateway`.
    This tells Istio that a user must be authenticated via a JWT.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'With our policy in place, we can now test it. First, with no user:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see that the request was denied with a `403` HTTP code. We received
    `403` because Istio was expecting a JWT but there wasn’t one. Next, let’s generate
    a valid token the same way we did in *Chapter 6**, Integrating Authentication
    into Your Cluster*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we have success! Our hello world service now requires proper authentication.
    Next, we’ll update our authorization to require a specific group from Active Directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing access to our service
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve built a service and made sure users have a valid JWT from our
    identity provider before they can access it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to apply what’s often referred to as “coarse-grained” authorization.
    This is application- or service-level access. It says, “You are generally able
    to use this service,” but it doesn’t say you’re able to perform the action you
    wish to take. For our check-writing service, you may be authorized to write a
    check, but there are likely more controls that limit who you can write a check
    for. If you’re responsible for the **Enterprise Resource Planning** (**ERP**)
    system in your enterprise, you probably shouldn’t be able to write checks for
    the facility vendors. We’ll get into how your service can manage these business-level
    decisions in the next section, but for now, we’ll focus on the service-level authorization.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out we have everything we need. Earlier, we looked at our `mmosley`
    user’s JWT, which had multiple claims. One such claim was the `groups` claim.
    We used this claim in *Chapter 6*, *Integrating Authentication into Your Cluster*,
    and *Chapter 7*, *RBAC Policies and Auditing*, to manage access to our cluster.
    In a similar fashion, we’ll manage who can access our service based on our membership
    of a particular group. First, we’ll delete our existing policy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the policy disabled, you can now access your service without a JWT. Next,
    we’ll create a policy that requires you to be a member of the group `cn=group2,ou=Groups,DC=domain,DC=com`
    in our Active Directory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the below policy (in `chapter17/coursed-grained-authorization/coursed-grained-az.yaml`):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This policy tells Istio that only users with a claim called `groups` that have
    the value `cn=group2,ou=Groups,DC=domain,DC=com` are able to access this service.
    With this policy deployed, you’ll see that you can still access the service as
    `mmosley`, and trying to access the service anonymously still fails. Next, try
    accessing the service as `jjackson`, with the same password:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We’re not able to access this service as `jjackson`. If we look at `jjackson`''s
    `id_token`, we can see why:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Looking at the claims, `jjackson` isn’t a member of the group `cn=group2,ou=Groups,DC=domain,DC=com`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re able to tell Istio how to limit access to our service to valid
    users, the next step is to tell our service who the user is. We’ll then use this
    information to look up authorization data, log actions, and act on the user’s
    behalf.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Telling your service who’s using it
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing a service that does anything involving a user, the first thing
    you need to determine is, “Who is trying to use my service?” So far, we have told
    Istio how to determine who the user is, but how do we propagate that information
    down to our service? Our `RequestAuthentication` included the configuration option
    `outputPayloadToHeader: User-Info`, which injects the claims from our user’s authentication
    token as base64-encoded JSON into the HTTP request’s headers. This information
    can be pulled from that header and used by your service to look up additional
    authorization data.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view this header with a service we built, called `/headers`. This service
    will just give us back all the headers that are passed to our service. Let’s take
    a look:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are several headers here. The one we care about is `User-Info`. This
    is the name of the header we specified in our `RequestAuthentication` object.
    If we decode from base64, we’ll get some JSON:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have all the same claims as if we had decoded the token ourselves. What we
    don’t have is the JWT. This is important from a security standpoint. Our service
    can’t leak a token it doesn’t possess.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to determine who the user is, let’s integrate that into
    a simple `who-am-i` service that just tells us who the user is. First, let’s look
    at our code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is pretty basic. We’re getting the header from our request. Next, we decode
    it from base64, and finally, we get the JSON and add it to a return. If this were
    a more complex service, this is where we might query a database to determine what
    entitlements our user has.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to not requiring that our code knows how to verify the JWT, this
    also makes it easier for us to develop our code in isolation from Istio. Open
    a shell in your `run-service` pod and try accessing this service directly with
    any user:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We were able to call our service without having to know anything about Istio,
    JWTs, or cryptography! Everything was offloaded to Istio so that we could focus
    on our service. While this does make for easier development, what are the impacts
    on security if there’s a way to inject any information we want into our service?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this directly from a namespace that doesn’t have the Istio sidecar:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `RequestAuthentication` and `AuthorizationPolicy` stop the request. While
    we’re not running the sidecar, our service is, and it redirects all traffic to
    Istio where our policies will be enforced. What about if we try to inject our
    own `User-Info` header from a valid request?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once again, our attempt to override who the user is outside of a valid JWT has
    been foiled by Istio. We’ve shown how Istio injects a user’s identity into our
    service; now, we need to know how to authorize a user’s entitlements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing user entitlements
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve managed to add quite a bit of functionality to our service without
    having to write any code. We added token-based authentication and coarse-grained
    authorization. We know who the user is and have determined that, at the service
    level, they are authorized to call our service. Next, we need to decide if the
    user is allowed to do the specific action they’re trying to do. This is often
    called fine-grained authorization or entitlements. In this section, we’ll walk
    through multiple approaches you can take, discussing how you should choose an
    approach.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing in service
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike coarse-grained authorizations and authentication, entitlements are generally
    not managed at the service mesh layer. That’s not to say it’s impossible. We’ll
    talk about ways you can do this in the service mesh, but in general, it’s not
    the best approach. Authorizations are generally tied to business data that’s usually
    locked up in a database. Sometimes, that database is a generic relational database,
    like MySQL or SQL Server, but it could really be anything. Since the data used
    to make the authorization decision is often owned by the service owner, not the
    cluster owner, it’s generally easier and more secure to make entitlement decisions
    directly in our code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we discussed in our check-writing service that we don’t want someone
    responsible for the ERP to cut checks to the facilities vendor. Where is the data
    that determines that? Well, it’s probably in your enterprise’s ERP system. Depending
    on how big you are, this could be a homegrown application or a SAP or Oracle.
    Let’s say you wanted Istio to make the authorization decision for our check-writing
    service. How would it get that data? Do you think the people responsible for the
    ERP want you, as a cluster owner, to talk to their database directly? Do you,
    as a cluster owner, want that responsibility? What happens when something goes
    wrong with the ERP and someone points the finger at you for the problem? Do you
    have the resources to prove that you, and your team, were not responsible?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the silos in enterprises that benefit from the management
    aspects of microservice design also work against centralized authorization. In
    our example of determining who can write the check for a specific vendor, it’s
    probably just easiest to make this decision inside our service. This way, if there’s
    a problem, it’s not the Kubernetes team’s responsibility to determine the issue,
    and the people who are responsible are in control of their own destiny.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: That’s not to say there isn’t an advantage to a more centralized approach to
    authorization. Having teams implement their own authorization code will lead to
    different standards being used and different approaches. Without careful controls,
    it can lead to a compliance nightmare. Let’s look at how Istio could provide a
    more robust framework for authorization.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Using OPA with Istio
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the Envoy filters feature discussed in *Chapter 16*, *An Introduction
    to Istio*, you can integrate the **Open Policy Agent** (**OPA**) into your service
    mesh to make authorization decisions. We discussed OPA in *Chapter 11*, *Extending
    Security Using Open Policy Agent*. There are a few key points about OPA we need
    to review:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: OPA does not (typically) reach out to external data stores to make authorization
    decisions. Much of the benefit of OPA requires that it uses its own internal database.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OPA’s database is not persistent. When an OPA instance dies, it must be repopulated
    with data.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OPA’s databases are not clustered. If you have multiple OPA instances, each
    database must be updated independently.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use OPA to validate whether our user can write a check for a specific vendor,
    OPA would either need to be able to pull that data directly from the JWT or have
    the ERP data replicated in its own database. The former is unlikely to happen
    for multiple reasons. First, the issues with your cluster talking to your ERP
    will still exist when your identity provider tries to talk to your ERP. Second,
    the team that runs your identity provider would need to know to include the correct
    data, which is a difficult task and is unlikely something they’re interested in
    doing. Finally, there could be numerous folks, from security to the ERP team,
    who are not comfortable with this data being stored in a token that gets passed
    around. The latter option, syncing data into OPA, is more likely to be successful.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways you could sync your authorization data from your ERP into
    your OPA databases. The first is by pushing the data. A “bot” could push updates
    to each OPA instance. This way, the ERP owner is responsible for pushing the data,
    with your cluster just being a consumer. However, there’s no simple way to do
    this, and security would be a concern to make sure someone doesn’t push false
    data. The alternative is to write a pull “bot” that runs as a sidecar to your
    OPA pods. This is how GateKeeper works. The advantage here is that you have the
    responsibility of keeping your data synced without having to build a security
    framework to push data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In either scenario, you’ll need to understand whether there are any compliance
    issues with the data you are storing. Now that you have the data, what’s the impact
    of losing it in a breach? Is that a responsibility you want?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Centralized authorization services have been discussed for entitlements long
    before Kubernetes or even RESTful APIs existed. They even predate SOAP and XML!
    For enterprise applications, it’s never really worked because of the additional
    costs in data management, ownership, and bridging silos. If you own all of the
    data, this is a great approach. When one of the main goals of microservices is
    to allow silos to better manage their own development, forcing a centralized entitlements
    engine is not likely to succeed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that said, there has been a move towards centralizing authorization
    services. This movement has spawned several commercial companies and projects
    outside of OPA:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Cedar**: An open source project from Amazon Web Services that creates a new
    policy language. Amazon has also created a service built on this language: [https://github.com/cedar-policy](https://github.com/cedar-policy).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topaz**: Built on OPA and Zanzibar, Topaz provides the OPA authorization
    engine with relationship-based authorizations from Zanzibar. There’s also a commercial
    offering: [https://github.com/aserto-dev/topaz](https://github.com/aserto-dev/topaz).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenFGA**: Another engine built on Zanzibar’s relationship-based authorization
    system, built by Auth0/Okta: [https://github.com/openfga](https://github.com/openfga).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re not going to dive into any of these solutions in detail; the point is
    that there has been a clear movement toward building authorization solutions,
    similar to how externalized authentication has been a product and project category
    for multiple decades.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know some of the issues involved in creating a centralized authorization,
    let’s build out an authorization rule with OPA for Istio.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Creating an OPA Authorization Rule
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this section, we discussed writing checks. A common rule for writing
    checks is that the person who writes the check is now also allowed to sign the
    check. This rule is called a “separation of duties.” It’s designed to build checkpoints
    for potentially harmful and costly processes. For instance, if an employee were
    allowed to both write the check and sign it, there’s no chance for someone to
    ask if the check is being written for a valid reason.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already implemented an AuthorizationPolicy that validates group membership,
    but for separation of duties, what we want is to implement a rule that validates
    that a user is a member of one group while NOT a member of another group. This
    sort of complex decision isn’t possible with a generic AuthorizationPolicy, so
    we’re going to need to build our own. We can use OPA as our authorization engine
    while instructing Istio to use our policy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we deploy our policy, let’s review it. The full policy is in `chapter17/opa/rego`
    and includes test cases:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We removed the comments to make the code more compact. The basics of this policy
    are that we:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Verify that there’s an `authorization` header.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the `authorization` header is a `Bearer` token.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the bearer token is a JWT.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the JWT and verify that there is a `groups` claim.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `groups` claim is a list, make sure that it contains the `k8s-cluster-admins`
    group, but NOT the `group2` group.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `groups` claim is not a list, only validate that it’s the `k8s-cluster-admins`
    group.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are validating that the authorization header is present and properly formatted
    because Istio does not require a token to be present to pass authentication. This
    was done by our previous `AuthorizationPolicy`, either explicitly by requiring
    that a principal be present or implicitly by requiring that a specific claim has
    a specific value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Once we have validated that the authorization header is properly formatted,
    we parse it for a payload. We’re not validating the JWT based on its public key,
    validity, or issuer because our `RequestAuthentication` object is doing that for
    us. We just need to make sure that the token is there.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have two potential `allow` policies. The first is if the `groups`
    claim is a list, so we need to apply array logic to see if the correct group is
    present and that the forbidden group is not present. The second `allow` policy
    will trigger if the `groups` claim is not a list but only a single value. In this
    case, we only care that the group’s value is our admin group.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy this policy, go to the `chapter17/opa` directory and run `deploy_opa_istio.sh`.
    The script will enable authorization and deploy our policy:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**Configure istiod**: Updates the `istio` `ConfigMap` that stores the mesh
    configuration to enable the `envoyExtAuthzGrpc` extension provider.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deploy an OPA mutating admission controller**: A mutating admission controller
    is deployed to automate the creation of an OPA instance on pods that runs alongside
    your services.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deploys our policy**: The policy we created earlier is created as a `ConfigMap`.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Redeploy our service**: Deletes the pod so that it is recreated with our
    authorization policy.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once everything is deployed, we can now verify that our policy is being enforced
    using a `curl` command. If we try to call our headers service now with our `mmosley`
    user, it will fail because `mmosley` is a member of both the `k8s-cluster-admin`
    group and the `group2` group:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, if we use our `pipeline_svc_account` user, it succeeds because this
    user is only a member of the `k8s-cluster-admin` group:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we can build more complex policies than what’s possible with Istio’s `AuthorizationPolicy`'s
    built-in authorization capabilities.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Having determined how to integrate entitlements into our services, the next
    question we need to answer is, how do we securely call other services?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Calling other services
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve written services that do simple things, but what about when your service
    needs to talk to another service? Just like with almost every other set of choices
    in your cluster rollout, you have multiple options to authenticate to other services.
    Which choice you make will depend on your needs. We’ll first cover the OAuth2
    standard way of getting new tokens for service calls and how Istio works with
    it. We’ll then cover some alternatives that should be considered anti-patterns
    but that you may choose to use anyway.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Using OAuth2 Token Exchange
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your service knows who your user is but needs to call another service. How do
    you identify yourself to the second service? The OAuth2 specification, which OpenID
    Connect is built on, has RFC 8693 – OAuth2 Token Exchange for this purpose. The
    basic idea is that your service will get a fresh token from your identity provider
    for the service call, based on the existing user. By getting a fresh token for
    your own call to a remote service, you’re making it easier to lock down where
    tokens can be used and who can use them, allowing yourself to more easily track
    a call’s authentication and authorization flow. The following diagram gives a
    high-level overview.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, line, diagram  Description automatically
    generated](img/B21165_17_06.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: OAuth2 Token Exchange sequence'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some details we’ll walk through that depend on your use case:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The user requests an `id_token` from the identity provider. How the user gets
    their token doesn’t really matter for this part of the sequence. We’ll use a utility
    in OpenUnison for our lab.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming you’re authenticated and authorized, your identity provider will give
    you an `id_token` with an `aud` claim that will be accepted by Service-X.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user uses the `id_token` as a bearer token to call Service-X. It goes without
    saying that Istio will validate this token.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service-X requests a token for Service-Y from the identity provider on behalf
    of the user. There are two potential methods to do this. One is impersonation;
    the other is delegation. We’ll cover both in detail later in this section. You’ll
    send your identity provider your original `id_token` and something to identify
    the service to the identity provider.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming Service-X is authorized, the identity provider sends a new `id_token`
    to Service-X with the original user’s attributes and an `aud` scoped to Service-Y.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service-X uses the new `id_token` as the `Authorization` header when calling
    Service-Y. Again, Istio validates the `id_token`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 7 and 8 in the previous diagram aren’t really important here.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think this seems like quite a bit of work to make a service call, you’re
    right. There are several authorization steps going on here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The identity provider authorizes the user to generate a token scoped to Service-X.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Istio validates the token and that it’s properly scoped to Service-X.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The identity provider authorizes Service-X to get a token for Service-Y and
    to do so for our user.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Istio validates that the token used by Service-X for Service-Y is properly scoped.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These authorization points provide a chance for an improper token to be stopped,
    allowing you to create very short-lived tokens that are harder to abuse and are
    more narrowly scoped. For instance, if the token used to call Service-X was leaked,
    it couldn’t be used to call Service-Y on its own. You’d still need Service-X’s
    own token before you could get a token for Service-Y. That’s an additional step
    an attacker would need to take in order to get control of Service-Y. It also means
    breaching more than one service, providing multiple layers of security. This lines
    up with our discussion of defense in depth from *Chapter 11*, *Extending Security
    Using Open Policy Agent*. With a high-level understanding of how OAuth2 Token
    Exchange works, the next question we need to answer is, how will your services
    authenticate themselves to your identity provider?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating your service
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order for the token exchange to work, your identity provider needs to know
    who the original user is and which service wants to exchange the token on behalf
    of the user. In the check-writing service example we’ve discussed, you wouldn’t
    want the service that provides today’s lunch menu to be able to generate a token
    for issuing a check! You accomplish this by making sure your identity provider
    knows the difference between your check-writing services and your lunch menu service
    by authenticating each service individually.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways a service running in Kubernetes can authenticate itself
    to the identity provider:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Use the Pod’s `ServiceAccount` token
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Istio’s mTLS capabilities
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a pre-shared “client secret”
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Throughout the rest of this section, we’re going to focus on option #1, using
    the Pod’s built-in `ServiceAccount` token. This token is provided by default for
    each running pod. This token can be validated by either submitting it to the API
    server’s `TokenReview` service or by treating it as a JWT, validating it against
    the public key published by the API server.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, we’re going to use the `TokenReview` API to test the passed-in
    `ServiceAccount` token against the API server. This is the most backward-compatible
    approach and supports any kind of token integrated into your cluster. For instance,
    if you’re deployed in a managed cloud with its own IAM system that mounts tokens,
    you could use that as well. This could generate a considerable amount of load
    on your API server, since every time a token needs to be validated, it gets sent
    to the API server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TokenRequest` API discussed in *Chapter 6*, *Integrating Authentication
    into Your Cluster*, can be used to cut down on this additional load. Instead of
    using the `TokenReview` API, we can call the API server’s issuer endpoint to get
    the appropriate token verification public key and use that key to validate the
    token’s JWT. While this is convenient and scales better, it does have some drawbacks:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Starting in 1.21, `ServiceAccount` tokens are mounted using the `TokenRequest`
    API but with lifespans of a year or more. You can manually change this to be as
    short as 10 minutes.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating the JWT directly against a public key won’t tell you if the pod is
    still running. The `TokenReview` API will fail if a `ServiceAcount` token is associated
    with a deleted pod, adding an additional layer of security.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling this feature requires enabling anonymous authentication in your cluster,
    which can be leveraged to elevate privileges with misconfigured RBAC or potential
    bugs.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re not going to use Istio’s mTLS capabilities because it’s not as flexible
    as tokens. It’s primarily meant for intra-cluster communications, so if our identity
    provider were outside of the cluster, it would be much harder to use. Also, since
    mTLS requires a point-to-point connection, any TLS termination points would break
    its use. Since it’s rare for an enterprise system to host its own certificate,
    even outside of Kubernetes, it would be very difficult to implement mTLS between
    your cluster’s services and your identity provider.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’re not going to use a shared secret between our services and our
    identity provider because we don’t need to. Shared secrets are only needed when
    you have no other way to give a workload an identity. Since Kubernetes gives every
    pod its own identity, there’s no need to use a client secret to identify our service.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how our services will identify themselves to our identity provider,
    let’s walk through an example of using OAuth2 Token Exchange to securely call
    one service from another.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and running the check-writing service
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Having walked through much of the theory of using a token exchange to securely
    call services, let’s deploy an example check-writing service. When we call this
    service, it will call two other services. The first service, `check-funds`, will
    use the impersonation profile of OAuth2 Token Exchange, while the second service,
    `pull-funds`, will use delegation. We’ll walk through each of these individually.
    First, use Helm to deploy an identity provider. Go into the `chapter17` directory
    and run:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We’re not going to go into the details of OpenUnison’s configuration. Suffice
    it to say, this will set up an identity provider for our services and a way to
    get an initial token. Next, deploy the `write-checks` service:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should look pretty familiar after the first set of examples in this chapter.
    We deployed our service as Python in a `ConfigMap` and the same Istio objects
    we created in the previous service. The only major difference is in our `RequestAuthentication`
    object:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There’s an additional setting, `forwardOriginalToken`, that tells Istio to send
    the service the original JWT used to authenticate the call. We’ll need this token
    in order to prove to the identity provider that we should even attempt to perform
    a token exchange. You can’t ask for a new token if you can’t provide the original.
    This keeps someone with access to your service’s pod from requesting a token on
    your behalf with just the service’s `ServiceAccount`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, we said we couldn’t leak a token we didn’t have, so
    we shouldn’t have access to the original token. This would be true if we didn’t
    need it to get a token for another service. Following the concept of least privilege,
    we shouldn’t forward the token if we don’t need to. In this case, we need it for
    a token exchange, so it’s worth the increased risk to have more secure service-to-service
    calls.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'With our example check-writing service deployed, let’s run it and work backward.
    Just like with our earlier examples, we’ll use `curl` to get the token and call
    our service. In `chapter17/write-checks`, run `call_service.sh`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output you see is the result of the calls to `/write-check`, which then
    calls `/check-funds` and `/pull-funds`. Let’s walk through each call, the tokens
    that are generated, and the code that generates them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Using Impersonation
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re not talking about the same Impersonation you used in *Chapter 6*, *Integrating
    Authentication into Your Cluster*. It’s a similar concept, but this is specific
    to token exchange. When `/write-check` needs to get a token to call `/check-funds`,
    it asks OpenUnison for a token on behalf of our user, `mmosley`. The important
    aspect of Impersonation is that there’s no reference to the requesting client
    in the generated token. The `/check-funds` service does not know that the token
    it’s received wasn’t retrieved by the user themselves. Working backward, the `impersonated_jwt`
    in the response to our service call is what `/write-check` uses to call `/check-funds`.
    Here’s the payload after dropping the result into `jwt.io`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The two important fields here are `sub` and `aud`. The `sub` field tells `/check-funds`
    who the user is and the `aud` field tells Istio which services can consume this
    token. Compare this to the payload from the original token in the `user_jwt` response:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The original `sub` is the same, but the `aud` is different. The original `aud`
    is for users, while the impersonated `aud` is for `checkfunds`. This is what differentiates
    the impersonated token from the original one. While our Istio deployment is configured
    to accept both audiences for the same service, that’s not a guarantee in most
    production clusters. When we call `/check-funds`, you’ll see that, in the output,
    we echo the user of our token, `mmosley`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen the end product, let’s see how we get it. First, we get
    the original JWT that was used to call `/write-check`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once we have the original JWT, we need the Pod’s `ServiceAccount` token:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now have everything we need to get an impersonation token. We’ll create
    a POST body and an `Authorization` header to authenticate us to OpenUnison to
    get our token:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first data structure we created is the body of an HTTP POST that will tell
    OpenUnison to generate an impersonation token for the `clientfunds aud`, using
    our existing user (`user_jwt`). OpenUnison will authenticate our service by verifying
    the JWT sent in the `Authorization` header as a `Bearer` token, using the `TokenReview`
    API.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenUnison will then apply its internal policy to verify that our service is
    able to generate a token for `mmosley` for the `clientfunds` audience, and then
    generate an `access_token`, `id_token`, and `refresh_token`. We’ll use the `id_token`
    to call `/check-funds`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since the final JWT makes no mention of the impersonation, how do we track
    a request back to our service? Hopefully, you’re piping your logs into a centralized
    logging system. If we look at the `jti` claim of our impersonation token, we can
    find the impersonation call in the OpenUnison logs:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, we at least have a way of tying them together. We can see that our Pod’s
    service account was authorized to create the impersonation token for `mmosley`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Having worked through an example of impersonation, let’s cover token delegation
    next.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Using delegation
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the last example, we used impersonation to generate a new token on behalf
    of our user, but our downstream service had no knowledge that the impersonation
    happened. Delegation is different in that the token carries information about
    both the original user and the service, or actor, that requested it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the service being called knows both the originator of the call
    and the service that makes the call. We can see this in the `pull_funds_text`
    value from the response of our `call_service.sh` run. It contains both our original
    user, `mmosley`, and the `ServiceAccount` for the service that made the call,
    `system:serviceaccount:write-checks:default`. Just as with impersonation, let’s
    look at the generated token:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In addition to the claims that identify the user as `mmosley`, there’s an `act`
    claim that identifies the `ServiceAccount` that’s used by `/write-checks`. Our
    service can make additional authorization decisions based on this claim or simply
    log it, noting that the token it received was delegated to a different service.
    In order to generate this token, we start by getting the original subject’s JWT
    and the Pod’s `ServiceAccount` token.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of calling OpenUnison for a delegated token, our client first has to
    get an actor token by using the `client_credentials` grant. This will get us the
    token that will eventually go into the `act` claim:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We authenticate to OpenUnison using our Pod’s native identity. OpenUnison returns
    an `access_token` and an `id_token`, but we only need the `id_token`. With our
    actor token in hand, we can now get our delegation token:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Similarly to impersonation, in this call, we not only send the original user’s
    token (`user_jwt`) but also the `actor_token` we just received from OpenUnison.
    We also don’t send an Authorization header. The `actor_token` authenticates us
    already. Finally, we’re able to use our returned token to call `/pull-funds`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at the most correct way to call services, using both impersonation
    and delegation, let’s take a look at some anti-patterns and why you shouldn’t
    use them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Passing tokens between services
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whereas, in the previous section, we used an identity provider to generate either
    impersonation or delegation tokens, this method skips that and just passes the
    original token from service to service. This is a simple approach that’s easy
    to implement. It also creates a larger blast radius. If the token gets leaked
    (and given that it’s now being passed to multiple services, the likelihood of
    it leaking goes up quite a bit), you’ve now not only exposed one service; you’ve
    also exposed all the services that trust that token.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: While using OAuth2 Token Exchange does require more work, it will limit your
    blast radius should a token be leaked. Next, we’ll look at how you can simply
    tell a downstream service who’s calling it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Using simple impersonation
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Where the previous examples of service-to-service calls rely on a third party
    to generate a token for a user, direct impersonation is where your service’s code
    uses a service account (in the generic sense, not the Kubernetes version) to call
    the second service and just tells the service who the user is as an input to the
    call. For instance, instead of calling OpenUnison to get a new token, `/write-check`
    could have just used the Pod’s `ServiceAccount` token to call `/check-funds`,
    with a parameter containing the user’s ID. Something like the following would
    work:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is, again, very simple. You can tell Istio to authenticate a Kubernetes
    `ServiceAccount`. This takes two lines of code to do something that took 15 to
    20 lines using a token service. Just like with passing tokens between services,
    this approach leaves you exposed in multiple ways. First, if anyone gets the `ServiceAccount`
    used by our service, they can impersonate anyone they want without checks. Using
    the token service ensures that a compromised service account doesn’t lead to it
    being used to impersonate anyone.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: You might find this method very similar to the impersonation we used in *Chapter
    6*, *Integrating Authentication into Your Cluster*. You’re correct. While this
    uses the same mechanism, a `ServiceAccount` and some parameters to specify who
    the user is, the type of impersonation Kubernetes uses for the API server is often
    referred to as a **protocol transition**. This is used when you are moving from
    one protocol (OpenID Connect) to another (a Kubernetes service account). As we
    discussed in *Chapter 5*, there are several controls you can put in place with
    Kubernetes impersonation, including using `NetworkPolicies`, `RBAC`, and the `TokenRequest`
    API. It’s also a much more isolated use case than a generic service.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: We’ve walked through multiple ways for services to call and authenticate each
    other. While it may not be the simplest way to secure access between services,
    it will limit the impact of a leaked token. Now that we know how our services
    will talk to each other, the last topic we need to cover is the relationship between
    Istio and API gateways.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Do I need an API gateway?
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re using Istio, do you still need an API gateway? In the past, Istio
    was primarily concerned with routing traffic for services. It got traffic into
    the cluster and figured out where to route it to. API gateways have typically
    focused more on application-level functionality such as authentication, authorization,
    input validation, and logging.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: For example, earlier in this chapter, we identified schema input validation
    as a process that needs to be repeated for each call and shouldn’t need to be
    done manually. This is important to protect against attacks that can leverage
    unexpected input, and it also makes for a better developer experience, providing
    feedback to developers sooner in the integration process. This is a common function
    for API gateways but is not available in Istio.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a function that is not built into Istio but is common for
    API gateways is logging authentication and authorization decisions and information.
    Throughout this chapter, we leveraged Istio’s built-in authentication and authorization
    to validate service access, but Istio makes no record of that decision, other
    than that a decision was made. It doesn’t record who accessed a particular URL,
    only where it was accessed from. Logging who accessed a service, from an identity
    standpoint, is left to each individual service. This is a common function for
    API gateways.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Finally, API gateways are able to handle more complex transformations. Gateways
    will typically provide functionality for mapping inputs and outputs, or even integrating
    with legacy systems.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: These functions could all be integrated into Istio, either directly or via Envoy
    filters. We saw an example of this when we looked at using OPA to make more complex
    authorization decisions than what the `AuthorizationPolicy` object provides. However,
    over the last few releases, Istio has moved further into the realm of traditional
    API gateways, and API gateways have begun taking on more service mesh capabilities.
    I suspect there will be considerable overlap between these systems in the future,
    but at the time of writing, Istio isn’t yet capable of fulfilling all the functions
    of an API gateway.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: We’ve had quite the journey building out the services for our Istio service
    mesh. You should now have the tools you need to begin building services in your
    own cluster.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how both monoliths and microservices run in Istio.
    We explored why and when to use each approach. We deployed a monolith, taking
    care to ensure our monolith’s session management worked. We then moved into deploying
    microservices, authenticating requests, authorizing requests, and finally, how
    services can securely communicate. To wrap things up, we discussed whether an
    API gateway is still necessary when using Istio.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Istio can be complex, but when used properly, it can provide considerable power.
    What we didn’t cover in this chapter is how to build containers and manage the
    deployment of our services. We’re going to tackle that next, in *Chapter 18*,
    *Provisioning a Multitenant Platform*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True or false: Istio is an API Gateway.'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: b – False. Istio is a service mesh, and while it has many of the functions
    of a gateway, it doesn’t have all of them (such as schema checking).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Should I always build applications as microservices?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obviously – this is the right way.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only if a microservices architecture aligns with your organization’s structure
    and needs.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: No. Microservices are more trouble than they’re worth.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s a microservice?
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: b – Microservices are great when you have a team that is able to make
    use of the granularity they provide.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: What is a monolith?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A large object that appears to be made from a single piece by an unknown maker
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An application that is self-contained
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A system that won’t run on Kubernetes
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A product from a new start-up
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: b – A monolith is a self-contained application that can run quite well
    on Kubernetes.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: How should you authorize access to your services in Istio?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can write a rule that limits access in Istio by a claim in the token.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can integrate OPA with Istio for more complex authorization decisions.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can embed complex authorization decisions in your code.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: d – These are all valid strategies from a technical standpoint. Each
    situation is different, so look at each one to determine which one is best for
    you!'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: Calling services on behalf of a user without token exchange
    is a secure approach.'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: b. False – Without using token exchange to get a new token for when
    the user uses the next service, you leave yourself open to various attacks because
    you can’t limit calls or track them.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: Istio supports sticky sessions.'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: a. True – They are not a default, but they are supported.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code965214276169525265.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
