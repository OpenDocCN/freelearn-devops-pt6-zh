<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer096">
    <h1 class="chapterNumber">4</h1>
    <h1 class="chapterTitle" id="_idParaDest-141">Running Your Containers in Kubernetes</h1>
    <p class="normal">This chapter is probably the most important one in this book. Here, we are going to discuss the concept of <strong class="keyWord">Pods</strong>, which <a id="_idIndexMarker355"/>are the objects Kubernetes uses to launch your application containers. Pods are at the heart of Kubernetes and mastering them is essential.</p>
    <p class="normal">In <em class="chapterRef">Chapter 3</em>, <em class="italic">Installing your First Kubernetes Cluster</em>, we said that the Kubernetes API defines a set of resources representing a computing unit. Pods are resources that are defined in the Kubernetes API that represent one or several containers. We never create containers directly with Kubernetes, but we always create Pods, which will be <em class="italic">converted</em> into containers on a compute node in our Kubernetes cluster.</p>
    <p class="normal">At first, it can be a little difficult to understand the connection between Kubernetes Pods and containers, which is why we are going to explain what Pods are and why we use them rather than containers directly. A Kubernetes Pod can contain one or more application containers. In this chapter, however, we will focus on Kubernetes Pods that contain only one container. We will then have the opportunity to discover Pods that contain several containers in the next chapter.</p>
    <p class="normal">We will create, delete, and update Pods using<a id="_idIndexMarker356"/> the <strong class="keyWord">BusyBox</strong> image, which is a Linux-based image containing many utilities useful for running tests. We will also launch a Pod based on the NGINX container image to launch an HTTP server. We will explore how to access the default NGINX home page via a feature that <code class="inlineCode">kubectl</code> exposes called port forwarding. It’s going to be useful to access and test the Pods running on your Kubernetes cluster from your web browser.</p>
    <p class="normal">Then, we will discover how to label and annotate our Pods to make them easily accessible. This will help us organize our Kubernetes cluster so that it’s as clean as possible. Finally, we will discover two additional resources, which are <strong class="keyWord">Jobs</strong> and <strong class="keyWord">CronJobs</strong>. By the end of this chapter, you will be able to launch your first containers managed by Kubernetes, which is the first step in becoming a Kubernetes master!</p>
    <p class="normal">In this chapter, we’re going to cover the following main topics:</p>
    <ul>
      <li class="bulletList">Let’s explain the notion of Pods</li>
      <li class="bulletList">Launching your first Pods</li>
      <li class="bulletList">Labeling and annotating the Pods</li>
      <li class="bulletList">Launching your first Job</li>
      <li class="bulletList">Launching your first CronJob</li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-142">Technical requirements</h1>
    <p class="normal">To follow along with the examples in this chapter, you will require the following:</p>
    <ul>
      <li class="bulletList">A properly configured Kubernetes cluster so that you can practice the commands shown as you read. Whether it’s a minikube, Kind, GKE, EKS, or AKS cluster is not important.</li>
      <li class="bulletList">A working <code class="inlineCode">kubectl</code> installation on your local machine. You can have more than one node if you want, but at least one <code class="inlineCode">Ready</code> node is required to have a working Kubernetes setup.</li>
    </ul>
    <p class="normal">You can download the latest code samples for this chapter from the official GitHub repository at <a href="https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04"><span class="url">https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04</span></a></p>
    <h1 class="heading-1" id="_idParaDest-143">Let’s explain the notion of Pods</h1>
    <p class="normal">In this section, we will explain the concept of Pods from a theoretical point of view. Pods have certain peculiarities that must be understood if you wish to master them well.</p>
    <h2 class="heading-2" id="_idParaDest-144">What are Pods?</h2>
    <p class="normal">When you<a id="_idIndexMarker357"/> want to create, update, or delete a container through Kubernetes, you do so through a Pod. A Pod is a group of one or more containers that you want to launch on the same machine, in the same Linux namespace. That’s the first rule to understand about Pods: they can be made up of one or more containers but all the containers that belong to the same Pod will be launched on the same worker node. A Pod cannot and <em class="italic">won’t ever</em> span across multiple worker nodes: that’s an absolute rule.</p>
    <p class="normal">But why do we bother delegating the management of our containers to this intermediary resource? After all, Kubernetes could have a container resource that would just launch a single container. The reason is that containerization invites you to think in terms of Linux processes rather than in terms of virtual machines. You may already know<a id="_idIndexMarker358"/> about the biggest and most recurrent container anti-pattern, which consists of using containers as virtual machine replacements: in the past, you used to install and deploy all your processes on top of a virtual machine. But containers are no virtual machine replacements, and they are not meant to run multiple processes.</p>
    <p class="normal">Container technology invites you to follow one golden rule: <em class="italic">there should be a one-to-one relationship between a container and a Linux process</em>. That being said, modern applications are often made up of multiple processes, not just one, so in most cases, using only one container won’t suffice to run a full-featured microservice. This implies that the processes, and thus the containers, should be able to communicate with each other by sharing file systems, networking, and so on. That’s what Kubernetes Pods offer you: the ability to group your containers logically. All the containers/processes that make up an application should be grouped in the same Pod. That way, they’ll be launched together and benefit from all the features when it comes to facilitating inter-process and inter-container communications.</p>
    <figure class="mediaobject"><img alt="" src="image/B22019_04_01.png"/></figure>
    <p class="packt_figref">Figure 4.1: Containers and Pods</p>
    <p class="normal">To help you understand<a id="_idIndexMarker359"/> this, imagine you have a working WordPress blog on a virtual machine and you want to convert that virtual machine into a WordPress Pod to deploy your blog on your Kubernetes cluster. WordPress is one of the most common pieces of software and is a perfect example to illustrate the need for Pods. This is because WordPress requires multiple processes to work properly.</p>
    <p class="normal">WordPress <a id="_idIndexMarker360"/>is a PHP application that requires both a web server and a PHP interpreter to work. Let’s list what Linux processes WordPress needs to work on:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">An NGINX HTTP server</strong>: It’s a <a id="_idIndexMarker361"/>web application, so it needs an HTTP server running as a process to receive and serve server blog pages. NGINX is a good HTTP server that will do the job perfectly.</li>
      <li class="bulletList"><strong class="keyWord">The PHP-FastCGI-Process-Manager (FPM) interpreter</strong>: It’s a blog engine written in PHP, so it<a id="_idIndexMarker362"/> needs a PHP interpreter to work.</li>
    </ul>
    <p class="normal">NGINX and PHP-FPM are two processes: they are two binaries that you need to launch separately, but they need to be able to work together. On a virtual machine, the job is simple: you just install NGINX <a id="_idIndexMarker363"/>and <strong class="keyWord">PHP-FPM</strong> on the virtual machine and have both of them communicate through Unix sockets. You can do this by telling NGINX that the Linux socket PHP-FPM is accessible thanks to the <code class="inlineCode">/etc/nginx.config</code> configuration file.</p>
    <p class="normal">In the container world, things become harder because running these two processes in the same container is an anti-pattern: you have to run two containers, one for each process, and you must have them communicate with each other and share a common directory so that they can both access the application code. To solve this problem, you have to use the Docker networking layer to have the NGINX container be able to communicate with the PHP-FPM one. Then, you must use a volume mount to share the WordPress code between the two containers. You can do this with some Docker commands but imagine it now in production at scale, on multiple machines, on multiple environments, and so on. Achieving inter-process communication is possible with bare Docker, but that’s difficult to achieve at scale while keeping all the production-related requirements in mind. With tons of microservices to manage and spread on different machines, it would become a nightmare to manage all these Docker networks, volume mounts, and so on. As you can imagine, that’s the kind of problem the Kubernetes Pod resource solves. Pods are very useful because they wrap multiple containers and enable easy inter-process communication. The following are the core benefits Pods bring you:</p>
    <ul>
      <li class="bulletList">All the containers in the same Pod can reach each other through localhost as they share the same network namespace.</li>
      <li class="bulletList">All the containers in the same Pod share the same port space.</li>
      <li class="bulletList">You can attach a volume to a Pod, and then mount the volume to underlying containers, allowing them to share directories and file locations.</li>
    </ul>
    <p class="normal">With the benefits Kubernetes brings you, it would be super easy to provision your WordPress blog as you can create a Pod that will run two containers: NGINX and PHP-FPM. Since they both can access each other on localhost, having them communicate is super easy. You can then use a volume to expose WordPress’s code to both containers.</p>
    <p class="normal">The most complex applications will forcibly require several containers, so it’s a good idea to group them in the same Pod to have Kubernetes launch them together. Keep in mind that the Pod is here for only one reason: to ease inter-container (or inter-process) communications at scale.</p>
    <div class="note">
      <p class="normal">That being said, it is not uncommon at all to have Pods that are only made up of one container. But in any case, the Pod is the lowest level of abstraction provided by the Kubernetes APIs and the one you will interact with.</p>
    </div>
    <p class="normal">Lastly, please note that a container that was launched manually on a machine managed by a Kubernetes cluster won’t be seen by Kubernetes as a container it manages. It becomes a kind of <em class="italic">orphan</em> container outside of the scope of the orchestrator. Kubernetes only manages the container it has launched through its Pod API.</p>
    <h2 class="heading-2" id="_idParaDest-145">Each Pod gets an IP address</h2>
    <p class="normal">Containers<a id="_idIndexMarker364"/> inside a single Pod are capable of communicating with each other through localhost, but Pods are also capable of communicating with each other. At launch time, each Pod gets a private IP address. Each Pod can communicate with any other Pod in the cluster by calling it through its IP address.</p>
    <p class="normal">Kubernetes uses a flat network model that is implemented by a component called <strong class="keyWord">Container Network Interface</strong> (<strong class="keyWord">CNI</strong>). CNI <a id="_idIndexMarker365"/>acts as a standardized bridge between containerized applications and the underlying network infrastructure within Kubernetes clusters. This eliminates the need for custom networking configurations for each container, streamlining communication and data flow.</p>
    <p class="normal">CNI leverages a flexible plugin-based architecture. These plugins, written in various languages, communicate with the container runtime using standard input/output. The plugin specification defines a clear interface for network configuration, IP address provisioning, and maintaining connections across multiple hosts. Container runtimes call upon these plugins, enabling dynamic management and updates to container networks within the Kubernetes environment. This approach ensures seamless and adaptable networking for your containerized applications.</p>
    <p class="normal">The following diagram shows the high-level communication flow between Pods and containers.</p>
    <figure class="mediaobject"><img alt="" src="image/B22019_04_02.png"/></figure>
    <p class="packt_figref">Figure 4.2: Container and Pod communication</p>
    <h2 class="heading-2" id="_idParaDest-146">How should you design your Pods?</h2>
    <p class="normal">While <a id="_idIndexMarker366"/>understanding Pods is crucial, in the real world of Kubernetes, most teams leverage a more powerful construct: Deployment. Deployments provide a higher-level abstraction for managing Pods. They automate tasks like scaling and restarting Pods in case of failures, ensuring a more robust and manageable application experience. We’ll delve deeper into deployments in a moment, but for now, let’s explore the Pods API to solidify your understanding of these foundational building blocks.</p>
    <p class="normal">So, here is the second golden rule about Pods: they are meant to be destroyed and recreated easily. Pods can be destroyed voluntarily or not. For example, if a given worker node running four Pods were to fail, each of the underlying containers would become inaccessible. Because of this, you should be able to destroy and recreate your Pods at will, without it affecting the stability of your application. The best way to achieve this is to respect two simple design rules when building your Pods:</p>
    <ul>
      <li class="bulletList">A Pod should contain everything required to launch an application.</li>
      <li class="bulletList">A Pod should store any kind of state outside of the Pod using external storage (PersistentVolume).</li>
    </ul>
    <p class="normal">When you start<a id="_idIndexMarker367"/> designing Pods on Kubernetes, it’s hard to know exactly what a Pod should and shouldn’t contain. It’s pretty straightforward to explain: a Pod has to contain an application or a microservice. Take the example of our WordPress Pod, which we mentioned earlier: the Pod should contain the NGINX and PHP-FPM containers, which are required to launch WordPress. If such a Pod were to fail, our WordPress would become inaccessible, but recreating the Pod would make WordPress accessible again because the Pod contains everything necessary to run WordPress.</p>
    <p class="normal">That being said, every modern application stores its state outside by utilizing external storage, database storage, such as Redis or MySQL, or by calling another microservice application to store the state. WordPress on its own does that too – it uses MySQL (or MariaDB) to store and retrieve your post. So, you’ll also have to run a MySQL container somewhere. Two solutions are possible here:</p>
    <ul>
      <li class="bulletList">You run the MySQL container as part of the WordPress Pod.</li>
      <li class="bulletList">You run the MySQL container as part of a dedicated MySQL Pod.</li>
    </ul>
    <p class="normal">Both solutions can be used, but the second is preferred. It’s a good idea to decouple your application (here, this is WordPress, but tomorrow, it could be a microservice) from its database or logic layer by running them in two separate Pods. Remember that Pods are capable of communicating with each other. You can benefit from this by dedicating a Pod to running MySQL and giving its Pod IP address to your WordPress blog.</p>
    <p class="normal">By separating the database layer from the application, you improve the stability of the setup: the application Pod crashing will not affect the database.</p>
    <p class="normal">To summarize, grouping the application layers in the same Pods would cause three problems:</p>
    <ul>
      <li class="bulletList">Data durability</li>
      <li class="bulletList">Availability</li>
      <li class="bulletList">Stability</li>
    </ul>
    <p class="normal">That’s why it is recommended to keep your application Pods stateless as much as possible, by storing their states in an independent Pod. By treating the data layer as a separate application<a id="_idIndexMarker368"/> with its own development and management life cycle, we can achieve a decoupled architecture. This separation allows for independent scaling, updates, and testing of the data layer without impacting the application code itself.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Stateful monolithic applications</strong></p>
      <p class="normal">Despite some niche possibilities, running fast-moving monolithic stateful workloads on Kubernetes in 2024 is generally discouraged due to the complexity of managing monolithic applications within containers, potential inefficiencies for frequent updates in fast-paced environments, and increased management overhead for persistent storage needs compared to traditional deployments.</p>
      <p class="normal"><strong class="keyWord">Accessing Pods via an IP address</strong></p>
      <p class="normal">You can access Pods using their IP addresses; however, this is not the recommended method for interacting with running applications. In upcoming chapters, we will delve into the Service resource, which plays a crucial role in mapping IP addresses to Pods. Stay tuned for a detailed explanation of how Services enhance Pod accessibility and application communication.</p>
    </div>
    <p class="normal">Now, let’s launch our first Pod. Creating a WordPress Pod would be too complex for now, so let’s start easy by launching some NGINX Pods and see how Kubernetes manages the container.</p>
    <h1 class="heading-1" id="_idParaDest-147">Launching your first Pods</h1>
    <p class="normal">In this section, we<a id="_idIndexMarker369"/> will explain how to create our first Pods in our Kubernetes cluster. Pods have certain peculiarities that must be understood to master them well.</p>
    <p class="normal">We are not going to create a resource on your Kubernetes cluster at the moment; instead, we are simply going to explain what Pods are. In the next section, we’ll start building our first Pods.</p>
    <h2 class="heading-2" id="_idParaDest-148">Creating a Pod with imperative syntax</h2>
    <p class="normal">In this <a id="_idIndexMarker370"/>section, we are going to create a Pod based on the NGINX image. We need two parameters to create a Pod:</p>
    <ul>
      <li class="bulletList">The Pod’s name, which is arbitrarily defined by you</li>
      <li class="bulletList">The container images to build its underlying containers</li>
    </ul>
    <p class="normal">As with almost everything on Kubernetes, you can create Pods using either of the two syntaxes available: the imperative syntax and the declarative syntax, which you have learned about in <em class="chapterRef">Chapter 2</em>, <em class="italic">Kubernetes Architecture – from Container Images to Running Pods</em>. As a reminder, the imperative syntax is to run <code class="inlineCode">kubectl</code> commands directly from a terminal, while with declarative syntax, you must write a YAML file containing the configuration information for your Pod, and then apply it with the <code class="inlineCode">kubectl apply -f</code> command.</p>
    <p class="normal">To create a Pod on your Kubernetes cluster, you have to use the <code class="inlineCode">kubectl run</code> command. That’s the simplest and fastest way to get a Pod running on your Kubernetes cluster. Here is how the command can be called:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl run nginx-pod --image nginx:latest
</code></pre>
    <p class="normal">In this command, the Pod’s name is set to <code class="inlineCode">nginx-pod</code>. This name is important because it is a pointer to the Pod: when you need to run the <code class="inlineCode">update</code> or <code class="inlineCode">delete</code> command on this Pod, you’ll have to specify that name to tell Kubernetes which Pod the action should run on. The <code class="inlineCode">--image</code> flag will be used to mention the container that this Pod will run. Once the Pod is created by the cluster, the status can be checked as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods
NAME        READY   STATUS    RESTARTS   AGE
nginx-pod   1/1     Running   0          79s
</code></pre>
    <div class="note">
      <p class="normal">Standing up a Pod isn’t instantaneous. Kubernetes might need to pull the container image from a registry if it’s not available locally and configure the Pod’s environment. To track this process in real time, use <code class="inlineCode">kubectl get po -w</code>, which shows Pod information and refreshes automatically.</p>
    </div>
    <p class="normal">Here, you are telling Kubernetes to build a Pod based on the <code class="inlineCode">nginx:latest</code> container image hosted on Docker Hub. This <code class="inlineCode">nginx-pod</code> Pod contains only one container based on this <code class="inlineCode">nginx:latest</code> image: you cannot specify multiple images here; this is a limitation of the imperative syntax.</p>
    <p class="normal">If you want to <a id="_idIndexMarker371"/>build a Pod containing multiple containers built from several different container images, then you will have to go through the declarative syntax and write a YAML file.</p>
    <h3 class="heading-3" id="_idParaDest-149">Tags versus digests – ensuring image consistency</h3>
    <p class="normal">While creating Pods, you might encounter references to tags and digests. Both are used to identify container images, but with a key difference:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Tags</strong>: Think <a id="_idIndexMarker372"/>of tags as human-readable names for image versions. They can be changed to point to different versions of the same image, potentially causing unexpected behavior.</li>
      <li class="bulletList"><strong class="keyWord">Digests</strong>: These<a id="_idIndexMarker373"/> are unique fingerprints of an image, ensuring you always reference the exact desired version. This is crucial for security and reproducibility, especially in light of potential software supply chain attacks.</li>
    </ul>
    <p class="normal">For example, instead of using <code class="inlineCode">nginx:latest</code> <code class="inlineCode">(tag)</code>, you might use <code class="inlineCode">nginx@sha256:1445eb9c6dc5e9619346c836ef6fbd6a95092e4663f27dcfce116f051cdbd232</code> (digest). You can fetch the digest information for the container image from the registry itself or by using the <code class="inlineCode">podman manifest inspect nginx:latest</code> command.</p>
    <figure class="mediaobject"><img alt="" src="image/B22019_04_03.png"/></figure>
    <p class="packt_figref">Figure 4.3: Fetching image digest from a container registry</p>
    <p class="normal">This guarantees you’re deploying the specific image version with the unique <code class="inlineCode">abcd1234</code> hash. This practice is becoming increasingly important for secure and reliable deployments.</p>
    <p class="normal">Let us learn how to create Pods using YAML declarations in the next section.</p>
    <h2 class="heading-2" id="_idParaDest-150">Creating a Pod with declarative syntax</h2>
    <p class="normal">Creating a Pod <a id="_idIndexMarker374"/>with declarative syntax is simple too. You have to create a YAML file containing your Pod definition and apply it against your Kubernetes cluster using the <code class="inlineCode">kubectl apply -f</code> command.</p>
    <p class="normal">Remember that Kubernetes cannot run two Pods with the same name in the same namespace (e.g., the <code class="inlineCode">default</code> namespace in our case): the Pod’s name is the unique identifier and is used to identify the Pods within a namespace. You need to delete the existing Pod that you created in the previous step before you create a new Pod with the same name in the same namespace:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl delete pod nginx-pod
pod "nginx-pod" deleted
</code></pre>
    <p class="normal">Here is the content of the <code class="inlineCode">nginx-pod.yaml</code> file, which you can create on your local workstation:</p>
    <pre class="programlisting con"><code class="hljs-con">apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
    - name: nginx-container
      image: nginx:latest
</code></pre>
    <p class="normal">Try to read this file and understand its content. YAML files are only key-value pairs. The Pod’s name is <code class="inlineCode">nginx-Pod</code>, and then we have an array of containers in the <code class="inlineCode">spec:</code> part of the file containing only one container created from the <code class="inlineCode">nginx:latest</code> image. The container itself is named <code class="inlineCode">nginx-container</code>.</p>
    <p class="normal">Once the <code class="inlineCode">nginx-Pod.yaml</code> file has been saved, run the following command to create the Pod:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl apply -f nginx-pod.yaml
pod/nginx-pod created
</code></pre>
    <p class="normal">If a Pod called <code class="inlineCode">nginx-pod</code> already<a id="_idIndexMarker375"/> exists in your cluster, this command will fail. Try to edit the YAML file to update the Pod’s name and then apply it again.</p>
    <h3 class="heading-3" id="_idParaDest-151">Namespaces in Kubernetes</h3>
    <p class="normal">If you<a id="_idIndexMarker376"/> omit to specify a namespace during resource creation, it defaults to the default namespace. Stay tuned for <em class="chapterRef">Chapter 6</em>, <em class="italic">Namespaces, Quotas, and Limits for Multi-Tenancy in Kubernetes</em>, where we’ll delve into the significance of Kubernetes namespaces.</p>
    <h2 class="heading-2" id="_idParaDest-152">Reading the Pod’s information and metadata</h2>
    <p class="normal">At this point, you <a id="_idIndexMarker377"/>should have a running Pod on your Kubernetes cluster. Here, we are going to try to read its information. At any time, we need to be able to retrieve and read information regarding the resources that were created on your Kubernetes cluster; this is especially true for Pods. Reading the Kubernetes cluster can be achieved using two <code class="inlineCode">kubectl</code> commands: <code class="inlineCode">kubectl get</code> and <code class="inlineCode">kubectl describe</code>. Let’s take a look at them:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">kubectl get</code>: The <code class="inlineCode">kubectl get</code> command <a id="_idIndexMarker378"/>is a list operation; you use this command to list a set of objects. Do you remember when we listed the nodes of your cluster after all the installation procedures described in the previous chapter? We did this using <code class="inlineCode">kubectl get nodes</code>. The command works by requiring you to pass the object type you want to list. In our case, it’s going to be the <code class="inlineCode">kubectl get pods</code> operation. In the upcoming chapters, we will discover other objects, such as <code class="inlineCode">configmaps</code> and <code class="inlineCode">secrets</code>. To list them, you’ll have to type <code class="inlineCode">kubectl get configmaps</code>; the same goes for the other object types. For example, the <code class="inlineCode">nginx-pod</code> can be listed as follows:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">kubectl describe</code>: The <code class="inlineCode">kubectl describe</code> command is quite different. It’s intended to <a id="_idIndexMarker379"/>retrieve a complete set of information for one specific object that’s been identified from both its kind and object name. You can retrieve the information of our previously created Pod by using <code class="inlineCode">kubectl describe pods nginx-pod</code>. Calling this command will return a full set of information available about that specific Pod, such as its IP address. To see the details of <code class="inlineCode">nginx-pod</code>, the following command can be used:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl describe pod nginx-pod
Name:             nginx-pod
Namespace:        default
...&lt;removed for brevity&gt;...
Containers:
  nginx-container:
    Container ID:   containerd://3afbbe30b51b77994df69f4c4dbefb02fc304efb2bf0f5bdb65a65
1154a8e311
    Image:          nginx:latest
...&lt;removed for brevity&gt;...
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
...&lt;removed for brevity&gt;...
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
...&lt;removed for brevity&gt;...
  Normal  Created    112s  kubelet            Created container nginx-container
  Normal  Started    112s  kubelet            Started container nginx-container
</code></pre>
      </li>
    </ul>
    <p class="normal">From the preceding <a id="_idIndexMarker380"/>command output, you can read a lot of information, including the following items:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Pod name and namespace</strong>: This identifies the specific Pod you requested information on (e.g., <code class="inlineCode">nginx-pod</code>).</li>
      <li class="bulletList"><strong class="keyWord">Container details</strong>: This lists information about the containers within the Pod, including image name, resource requests/limits, and current state.</li>
      <li class="bulletList"><strong class="keyWord">Pod conditions</strong>: This shows the current operational state of the Pod (e.g., Running, Pending, CrashLoopBackOff).</li>
      <li class="bulletList"><strong class="keyWord">Events</strong>: This provides a history of relevant events related to the Pod’s life cycle, including creation, restarts, or errors.</li>
    </ul>
    <p class="normal">Now, let’s look at some more advanced options for listing and describing objects in Kubernetes.</p>
    <h2 class="heading-2" id="_idParaDest-153">Listing the objects in JSON or YAML</h2>
    <p class="normal">The <code class="inlineCode">-o</code> or <code class="inlineCode">--output</code> option<a id="_idIndexMarker381"/> is one of the most useful options offered by the <code class="inlineCode">kubectl</code> command line. This one has some benefits you must be aware of. This option allows you to customize the output of the <code class="inlineCode">kubectl</code> command line. By default, the <code class="inlineCode">kubectl get pods</code> command will return a list of the Pods in your Kubernetes cluster in a formatted way so that the end user can see it easily. You can also retrieve this information in JSON format or YAML format by using the <code class="inlineCode">-o</code> option:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods --output yaml <span class="hljs-con-comment"># In YAML format</span>
<span class="hljs-con-meta">$ </span>kubectl get pods --output json <span class="hljs-con-comment"># In JSON format</span>
</code></pre>
    <p class="normal">If you know the Pod name, you can also get a specific Pod:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods &lt;POD_NAME&gt; -o yaml
<span class="hljs-con-meta"># </span>OR
<span class="hljs-con-meta">$ </span>kubectl get pods &lt;POD_NAME&gt; -o json
</code></pre>
    <p class="normal">This way, you can retrieve and export data from your Kubernetes cluster in a scripting-friendly format.</p>
    <h2 class="heading-2" id="_idParaDest-154">Backing up your resource using the list operation</h2>
    <p class="normal">You can also<a id="_idIndexMarker382"/> use these flags to back up your Kubernetes resources. Imagine a situation where you created a Pod using the imperative way, so you don’t have the YAML declaration file stored on your computer. If the Pod fails, it’s going to be hard to recreate it. The <code class="inlineCode">-o</code> option helps us retrieve the YAML declaration file of a resource that’s been created in Kubernetes, even if we created it using the imperative way. To do this, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods/nginx-pod -o yaml &gt; nginx-pod-output.yaml
</code></pre>
    <p class="normal">This way, you have a YAML backup of the <code class="inlineCode">nginx-pod</code> resource as it is running on your cluster. You can always compare the output file with the original YAML declaration and analyze the differences using the <code class="inlineCode">diff</code> command or other utilities:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>diff nginx-pod.yaml nginx-pod-output.yaml
</code></pre>
    <div class="note">
      <p class="normal">There are tools available to clean up the YAML and get a clean output of a usable declaration. For example, <code class="inlineCode">kube-neat</code> is such a utility that will help to clean the unwanted information from the detailed output. Refer to <a href="https://github.com/itaysk/kubectl-neat"><span class="url">https://github.com/itaysk/kubectl-neat</span></a> to learn more.</p>
    </div>
    <p class="normal">If something <a id="_idIndexMarker383"/>goes wrong, you’ll be able to recreate your Pod easily. Pay attention to the <code class="inlineCode">nginx-pod</code> section of this command. To retrieve the YAML declaration, you need to specify which resource you are targeting. By redirecting the output of this command to a file, you get a nice way to retrieve and back up the configuration of the object inside your Kubernetes cluster.</p>
    <h2 class="heading-2" id="_idParaDest-155">Getting more information from the list operation</h2>
    <p class="normal">It’s also <a id="_idIndexMarker384"/>worth mentioning the <code class="inlineCode">-o</code> wide format, which is going to be very useful for you: using this option allows you to expand the default output to add more data. By using it on the <code class="inlineCode">Pods</code> object, for example, you’ll get the name of the worker node where the Pod is running:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods -o wide
NAME        READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
nginx-pod   1/1     Running   0          15m   10.244.0.4   minikube   &lt;none&gt;           &lt;none&gt;
</code></pre>
    <p class="normal">Keep in mind that the <code class="inlineCode">-o</code> option can take a lot of different parameters and that some of them are much more advanced, such as <code class="inlineCode">jsonpath</code>, which allows you to directly execute sorting operations on top of a JSON body document to retrieve only specific information, just like the <code class="inlineCode">jq</code> library you used previously if you have already written some bash scripts that deal with JSON parsing.</p>
    <h2 class="heading-2" id="_idParaDest-156">Accessing a Pod from the outside world</h2>
    <p class="normal">At <a id="_idIndexMarker385"/>this point, you should have a Pod containing an NGINX HTTP server on your Kubernetes cluster. You should now be able to access it from your web browser. However, this is a bit complicated.</p>
    <p class="normal">By default, your Kubernetes cluster does not expose the Pod it runs to the outside world. For that, you will need to use another resource called a service, which we will cover in more detail in <em class="chapterRef">Chapter 8</em>, <em class="italic">Exposing Your Pods with Services</em>. However, <code class="inlineCode">kubectl</code> does offer a command for quickly accessing a running container on your cluster called <code class="inlineCode">kubectl port-forward</code>. This is how you can use it:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl port-forward pod/nginx-pod 8080:80
Forwarding from 127.0.0.1:8080 -&gt; 80
Forwarding from [::1]:8080 -&gt; 80
</code></pre>
    <p class="normal">This command is quite easy to understand: we are telling <code class="inlineCode">kubectl</code> to forward port <code class="inlineCode">8080</code> on my local machine (the one running <code class="inlineCode">kubectl</code>) to port <code class="inlineCode">80</code> on the Pod identified by <code class="inlineCode">pod/nginx-Pod</code>.</p>
    <p class="normal">Kubectl then <a id="_idIndexMarker386"/>outputs a message, telling you that it started to forward your local <code class="inlineCode">8080</code> port to the <code class="inlineCode">80</code> one of the Pod. If you get an error message, it’s probably because your local port <code class="inlineCode">8080</code> is currently being used. Try to set a different port or simply remove the local port from the command to let <code class="inlineCode">kubectl</code> choose a local port randomly:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl port-forward pod/nginx-pod 8080:80
Forwarding from 127.0.0.1:8080 -&gt; 80
Forwarding from [::1]:8080 -&gt; 80
</code></pre>
    <p class="normal">Now, you can launch your browser and try to reach the <code class="inlineCode">http://localhost:&lt;localport&gt;</code> address, which in your case is <code class="inlineCode">http://localhost:8080</code>:</p>
    <figure class="mediaobject"><img alt="Figure 4.1 – The NGINX default page running in a Pod and accessible on localhost, which indicates the port-forward command worked!  &#10;" src="image/B22019_04_04.png"/></figure>
    <p class="packt_figref">Figure 4.4: The NGINX default page running in a Pod and accessible on localhost, which indicates the port-forward command worked</p>
    <p class="normal">Once you have finished the testing, use the <em class="keystroke">Ctrl + C</em> command to end the port forwarding task.</p>
    <h2 class="heading-2" id="_idParaDest-157">Entering a container inside a Pod</h2>
    <p class="normal">When<a id="_idIndexMarker387"/> a Pod is launched, you can access the Pods it contains. Under Docker, the command to execute a command in a running container is called <code class="inlineCode">docker exec</code>. Kubernetes copies this behavior via a command called <code class="inlineCode">kubectl exec</code>. Use the following command to access our NGINX container inside <code class="inlineCode">nginx-pod</code>, which we launched earlier:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl <span class="hljs-con-built_in">exec</span> -it nginx-pod -- bash
root@nginx-pod:/# hostname
nginx-pod
</code></pre>
    <p class="normal">After running this command, you will be inside the NGINX container. You can do whatever you want here, just like with any other container. The preceding command assumes that the <code class="inlineCode">bash</code> binary is installed in the container you are trying to access. Otherwise, the <code class="inlineCode">sh</code> binary is generally installed on a lot of containers and might be used to access the container. Don’t be afraid to take a full binary path, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl <span class="hljs-con-built_in">exec</span> -it nginx-pod -- /bin/bash
</code></pre>
    <p class="normal">Once you have finished testing, exit from the bash shell of the container using the <code class="inlineCode">exit</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con">root@nginx-pod:/# exit
exit
</code></pre>
    <div class="note">
      <p class="normal">IMPORTANT: <strong class="keyWord">Security and Non-Root Users in Containers</strong></p>
      <p class="normal">It’s generally recommended to run containers with a non-root user. You need to limit potential damage from vulnerabilities. If a vulnerability is exploited, a non-root user has less access to the system, reducing the impact. Also, follow the principle of least privilege, which grants only the necessary permissions for the container to function, minimizing its attack surface. We will explore the security context in <em class="chapterRef">Chapter 18</em>, <em class="italic">Security in Kubernetes.</em></p>
    </div>
    <p class="normal">Now, let’s discover how to delete a Pod from a Kubernetes cluster.</p>
    <h2 class="heading-2" id="_idParaDest-158">Deleting a Pod</h2>
    <p class="normal">Deleting<a id="_idIndexMarker388"/> a Pod is super easy. You can do so using the <code class="inlineCode">kubectl delete</code> command. You need to know the name of the Pod you want to delete. In our case, the Pod’s name is <code class="inlineCode">nginx-pod</code>. Run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl delete pods nginx-pod
<span class="hljs-con-meta"># </span>or...
<span class="hljs-con-meta">$ </span>kubectl delete pods/nginx-pod
</code></pre>
    <p class="normal">If you do not know the name of the Pod, remember to run the <code class="inlineCode">kubectl get pods</code> command to retrieve the list of the Pods and find the one you want to delete.</p>
    <p class="normal">There is also something you must know: if you have built your Pod with declarative syntax and you still have its YAML configuration file, you can delete your Pod without having to know the name of the container because it is contained in the YAML file.</p>
    <p class="normal">Run the following command to delete the Pod using the declarative syntax:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl delete -f nginx-pod.yaml
</code></pre>
    <p class="normal">After you run this command, the Pod will be deleted in the same way.</p>
    <div class="note">
      <p class="normal">Remember that all containers belonging to the Pod will be deleted. The container’s life cycle is bound to the life cycle of the Pod that launched it. If the Pod is deleted, the containers it manages will be deleted. Remember to always interact with the Pods and not with the containers directly.</p>
    </div>
    <p class="normal">With that, we have reviewed the most important aspects of Pod management, such as launching a Pod with the imperative or declarative syntax, deleting a Pod, and listing and describing them. Now, we will introduce one of the most important aspects of Pod management in Kubernetes: labeling and annotating.</p>
    <h1 class="heading-1" id="_idParaDest-159">Labeling and annotating the Pods</h1>
    <p class="normal">We will <a id="_idIndexMarker389"/>now discuss another key concept of Kubernetes: labels and annotations. Labels are key-value pairs that you can attach to your Kubernetes objects. Labels are meant to tag your<a id="_idIndexMarker390"/> Kubernetes objects with key-value pairs defined by you. Once your Kubernetes objects have been labeled, you can build a custom query to retrieve specific Kubernetes objects based on the labels they hold. In this section, we are going to discover how to interact with labels through <code class="inlineCode">kubectl</code> by assigning some labels to our Pods.</p>
    <h2 class="heading-2" id="_idParaDest-160">What are labels and why do we need them?</h2>
    <p class="normal">What<a id="_idIndexMarker391"/> label you define for your objects is up to you – there is no specific rule regarding this. These labels are<a id="_idIndexMarker392"/> attributes that will allow you to organize your objects in your Kubernetes cluster. To give you a very concrete example, you could attach a label called <code class="inlineCode">environment = prod</code> to some of your Pods, and then use the <code class="inlineCode">kubectl get pods</code> command to list all the Pods within that environment. So, you could list all the Pods that belong to your production environment in one command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods --label <span class="hljs-con-string">"environment=production"</span>
</code></pre>
    <p class="normal">As you can see, it can be achieved using the <code class="inlineCode">--label</code> parameter, which can be shortened using its <code class="inlineCode">-l</code> equivalent:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods --label <span class="hljs-con-string">"environment=production"</span>
</code></pre>
    <p class="normal">This command will list all the Pods holding a label called <code class="inlineCode">environment</code> with a value of <code class="inlineCode">production</code>. Of course, in our case, no Pods will be found since none of the ones we created earlier are holding this label. You’ll have to be very disciplined about labels and not forget to set them every time you create a Pod or another object, and that’s why we are introducing them quite early in this book: not only Pods but almost every object in Kubernetes can be labeled, and you should take advantage of this feature to keep your cluster resources organized and clean.</p>
    <p class="normal">You use labels not only to organize your cluster but also to build relationships between your different Kubernetes objects: you will notice that some Kubernetes objects will read the labels that are carried by certain Pods and perform certain operations on them based on the labels they carry. If your Pods don’t have labels or they are misnamed or contain the wrong values, some of these mechanisms might not work as you expect.</p>
    <p class="normal">On the other hand, using labels is completely arbitrary: there is no particular naming rule, nor any convention Kubernetes expects you to follow. Thus, it is your responsibility to use the labels as you wish and build your convention. If you are in charge of the governance of a Kubernetes cluster, you should enforce the usage of mandatory labels and build some monitoring rules to quickly identify non-labeled resources.</p>
    <p class="normal">Keep in mind that labels are limited to 63 characters; they are intended to be short. Here are some label ideas you could use:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">environment</code> (<code class="inlineCode">prod</code>, <code class="inlineCode">dev</code>, <code class="inlineCode">uat</code>, and so on)</li>
      <li class="bulletList"><code class="inlineCode">stack</code> (<code class="inlineCode">blue</code>, <code class="inlineCode">green</code>, and so on)</li>
      <li class="bulletList"><code class="inlineCode">tier</code> (<code class="inlineCode">frontend</code> and <code class="inlineCode">backend</code>)</li>
      <li class="bulletList"><code class="inlineCode">app_name</code> (<code class="inlineCode">wordpress</code>, <code class="inlineCode">magento</code>, <code class="inlineCode">mysql</code>, and so on)</li>
      <li class="bulletList"><code class="inlineCode">team</code> (<code class="inlineCode">business</code> and <code class="inlineCode">developers</code>)</li>
    </ul>
    <p class="normal">Labels are not<a id="_idIndexMarker393"/> intended to be unique between objects. For example, perhaps you would like to list all the Pods that are part of the production environment. Here, several Pods with the same label key-value pair can exist in the cluster at the same time without posing any problem – it’s even recommended if you want your list query to work. For example, if you want to list all the resources that are part of the prod environment, a label environment such as <code class="inlineCode">= prod</code> should be created on multiple resources. Now, let’s look at annotations, which are another way we can assign metadata to our Pods.</p>
    <h2 class="heading-2" id="_idParaDest-161">What are annotations and how do they differ from labels?</h2>
    <p class="normal">Kubernetes<a id="_idIndexMarker394"/> also uses another type of metadata called <strong class="keyWord">annotations</strong>. Annotations are very similar to labels as they are also key-value pairs. However, annotations do not have the same use as labels. Labels are intended to identify resources and<a id="_idIndexMarker395"/> build relationships between them, while annotations are used to provide contextual information about the resource that they are defined on.</p>
    <p class="normal">For example, when <a id="_idIndexMarker396"/>you create a Pod, you could add an annotation containing the email of the support team to contact if this app does not work. This information has its place in an annotation but has nothing to do with a label.</p>
    <p class="normal">While it is highly recommended that you define labels wherever you can, you can omit annotations: they are less important to the operation of your cluster than labels. Be aware, however, that some Kubernetes objects or third-party applications often read annotations and use them as configuration. In this case, their usage of annotations will be explained explicitly in their documentation.</p>
    <h2 class="heading-2" id="_idParaDest-162">Adding a label</h2>
    <p class="normal">In this section, we <a id="_idIndexMarker397"/>will learn how to add and remove labels and annotations from Pods. We will also learn how to modify the labels of a Pod that already exists on a cluster.</p>
    <p class="normal">Let’s take the Pod based on the NGINX image that we used earlier. We will recreate it here with a label called <code class="inlineCode">tier</code>, which will contain the <code class="inlineCode">frontend</code> value. Here is the <code class="inlineCode">kubectl</code> command to run for that:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl run nginx-pod --image nginx --labels <span class="hljs-con-string">"tier=frontend"</span>
</code></pre>
    <p class="normal">As you can see, a label can be assigned using the <code class="inlineCode">--labels</code> parameter. You can also add multiple labels by using the <code class="inlineCode">--labels</code> parameter and comma-separated values, like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl run nginx-pod --image nginx  --labels=<span class="hljs-con-string">"app=myapp,env=dev,tier=frontend"</span>
</code></pre>
    <p class="normal">Here, the <code class="inlineCode">nginx</code> Pod will be created with two labels.</p>
    <p class="normal">The <code class="inlineCode">--labels</code> flag has a short version called <code class="inlineCode">-l</code>. You can use this to make your command shorter and easier to read. Labels can be appended to a YAML Pod definition. Here is the same Pod, holding the two labels we created earlier, but this time, it’s been created with the declarative syntax:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># labelled_pod.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pod</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">environment:</span> <span class="hljs-string">prod</span>
    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span>
</code></pre>
    <p class="normal">Consider the file that was created at <code class="inlineCode">~/labelled_pod.yaml</code>. The following <code class="inlineCode">kubectl</code> command would create the Pod the same way as it was created previously:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl apply -f ~/labelled_pod.yaml
</code></pre>
    <p class="normal">This time, running the command we used earlier should return at least one Pod – the one we just <a id="_idIndexMarker398"/>created:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pod -l environment=prod
NAME        READY   STATUS    RESTARTS   AGE
nginx-pod   1/1     Running   0          31m
</code></pre>
    <p class="normal">Now, let’s learn how we can list the labels attached to our Pod.</p>
    <h2 class="heading-2" id="_idParaDest-163">Listing labels attached to a Pod</h2>
    <p class="normal">There is <a id="_idIndexMarker399"/>no dedicated command to list the labels attached to a Pod, but you can make the output of <code class="inlineCode">kubectl get pods</code> a little bit more verbose. By using the <code class="inlineCode">--show-labels</code> parameter, the output of the command will include the labels attached to the Pods:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span> kubectl get pods --show-labels
NAME        READY   STATUS    RESTARTS   AGE   LABELS
nginx-pod   1/1     Running   0          56s   environment=prod,tier=frontend
</code></pre>
    <p class="normal">This command does not run any kind of query based on the labels; instead, it displays the labels themselves as part of the output.</p>
    <h2 class="heading-2" id="_idParaDest-164">Adding or updating a label to/of a running Pod</h2>
    <p class="normal">Now <a id="_idIndexMarker400"/>that we’ve learned how to create Pods with labels, we’ll learn how to add labels to a running Pod. You can add, create, or modify the labels of a resource at any time <a id="_idIndexMarker401"/>using the <code class="inlineCode">kubectl label</code> command. Here, we are going to add another label to our <code class="inlineCode">nginx</code> Pod. This label will be called <code class="inlineCode">stack</code> and will have a value of <code class="inlineCode">blue</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl label pod nginx-pod stack=blue
pod/nginx-pod labeled
</code></pre>
    <p class="normal">This command only works if the Pod has no label called <code class="inlineCode">stack</code>. When the command is executed, it can only add a new tag and not update it. This command will update the Pod by adding a label called <code class="inlineCode">stack</code> with a value of <code class="inlineCode">blue</code>. Run the following command to see that the change was applied:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods nginx-pod --show-labels
NAME        READY   STATUS    RESTARTS   AGE   LABELS
nginx-pod   1/1     Running   0          38m   environment=prod,stack=blue,tier=frontend
</code></pre>
    <p class="normal">To update an existing label, you must append the <code class="inlineCode">--overwrite</code> parameter to the preceding command. Let’s update the <code class="inlineCode">stack=blue</code> label to make it <code class="inlineCode">stack=green</code>; pay attention to the <code class="inlineCode">overwrite</code> parameter:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl label pod nginx-pod stack=green --overwrite
pod/nginx-pod labeled
</code></pre>
    <p class="normal">Here, the label<a id="_idIndexMarker402"/> should be updated. The <code class="inlineCode">stack</code> label should now be equal to <code class="inlineCode">green</code>. Run <a id="_idIndexMarker403"/>the following command to show the Pod and its labels again:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods nginx-pod --show-labels
NAME        READY   STATUS    RESTARTS   AGE   LABELS
nginx-pod   1/1     Running   0          41m   environment=prod,stack=green,tier=frontend
</code></pre>
    <div class="note">
      <p class="normal">Adding or updating labels using the <code class="inlineCode">kubectl label</code> command might be dangerous. As we mentioned earlier, you’ll build relationships between different Kubernetes objects based on labels. By updating them, you might break some of these relationships and your resources might start to behave not as expected. That’s why it’s better to add labels when a Pod is created and keep your Kubernetes configuration immutable. It’s always better to destroy and recreate rather than update an already running configuration.</p>
    </div>
    <p class="normal">The last thing we must do is learn how to delete a label attached to a running Pod.</p>
    <h2 class="heading-2" id="_idParaDest-165">Deleting a label attached to a running Pod</h2>
    <p class="normal">Just like we <a id="_idIndexMarker404"/>added and updated the labels of a running Pod, we can also delete them. The command is a little bit trickier. Here, we are going to remove the label called <code class="inlineCode">stack</code>, which we can do by adding a minus symbol (<code class="inlineCode">-</code>) right after the label name:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl label pod nginx-pod stack-
pod/nginx-pod unlabeled
</code></pre>
    <p class="normal">Adding that minus symbol at the end of the command might be quite strange, but running <code class="inlineCode">kubectl get pods --show-labels</code> again <a id="_idIndexMarker405"/>should show that the <code class="inlineCode">stack</code> label is now gone:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods nginx-pod --show-labels
</code></pre>
    <p class="normal">Now, let’s learn about annotations in Kubernetes in the next section.</p>
    <h2 class="heading-2" id="_idParaDest-166">Adding an annotation</h2>
    <p class="normal">Kubernetes <a id="_idIndexMarker406"/>annotations are key-value pairs that you can attach to various Kubernetes objects such as Pods, Deployments, and Services. They allow you to add extra information to these objects without changing their core functionality. Unlike labels, which are used for identification and selection, annotations are designed to store additional data that can be used for human readability or by external tools. Annotations can include details such as configuration information or the creator’s name.</p>
    <p class="normal">Let’s learn how to add annotations to a Pod:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># annotated_pod.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">tier:</span> <span class="hljs-string">webserver</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pod</span>
  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">environment:</span> <span class="hljs-string">prod</span>
    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span>
</code></pre>
    <p class="normal">Here, we simply added the <code class="inlineCode">tier:</code> <code class="inlineCode">webserver</code> annotation, which can help us identify that this Pod is running an HTTP server. Just keep in mind that it’s a way to add additional metadata.</p>
    <p class="normal">When you apply this new configuration, you can use the <code class="inlineCode">kubectl replace -f</code> command to replace the existing Pod configuration.</p>
    <div class="note">
      <p class="normal"><code class="inlineCode">kubectl replace</code> is a command used to update or replace existing Kubernetes resources using a manifest file. It offers a more forceful approach compared to <code class="inlineCode">kubectl apply -f</code>. The <code class="inlineCode">kubectl replace</code> command replaces the existing resource definition with the one specified in the manifest file. This essentially overwrites the existing resource configuration. Unlike <code class="inlineCode">kubectl apply</code>, which might attempt to merge changes, <code class="inlineCode">kubectl replace</code> aims for a complete replacement. This command can be helpful when you want to ensure a specific configuration for a resource, regardless of its current state. It’s also useful for situations where the resource definition might have become corrupted and needs to be replaced entirely.</p>
    </div>
    <p class="normal">The name <a id="_idIndexMarker407"/>of an annotation can be prefixed by a DNS name. This is the case for Kubernetes components such as <code class="inlineCode">kube-scheduler</code>, which must indicate to cluster users that this component is part of the Kubernetes core. The prefix can be omitted completely, as shown in the preceding example.</p>
    <p class="normal">You can see the annotations by using the <code class="inlineCode">kubectl</code> <code class="inlineCode">describe</code> Pod, <code class="inlineCode">kubectl get po -o yaml</code>, or with the <code class="inlineCode">jq</code> utility as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pod nginx-pod -o json | jq <span class="hljs-con-string">'.metadata.annotations'</span>
{
  "cni.projectcalico.org/containerID": "666d12cd2fb7d6ffe09add73d8466db218f01e7c7ef5315ef0187a675725b5ef",
  "cni.projectcalico.org/podIP": "10.244.151.1/32",
  "cni.projectcalico.org/podIPs": "10.244.151.1/32",
  "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"v1\",\"kind\":\"Pod\",\"metadata\":{\"annotations\":{},\"name\":\"nginx-pod\",\"namespace\":\"default\"},\"spec\":{\"containers\":[{\"image\":\"nginx:latest\",\"name\":\"nginx-container\"}]}}\n"
}
</code></pre>
    <p class="normal">Let us learn about Jobs in Kubernetes in the next section of this chapter.</p>
    <h1 class="heading-1" id="_idParaDest-167">Launching your first Job</h1>
    <p class="normal">Now, let’s <a id="_idIndexMarker408"/>discover another Kubernetes resource that is derived from Pods: the Job resource. In Kubernetes, a computing resource is a Pod, and everything else is just an intermediate resource that manipulates Pods.</p>
    <p class="normal">This is the case for the <code class="inlineCode">Job</code> object, which is an object that will create one or multiple Pods to complete a specific computing task, such as running a Linux command.</p>
    <h2 class="heading-2" id="_idParaDest-168">What are Jobs?</h2>
    <p class="normal">A Job is <a id="_idIndexMarker409"/>another kind of resource that’s exposed by the Kubernetes API. In the end, a job will create one or multiple Pods to execute a command defined by you. That’s how jobs work: they launch Pods. You have to understand the relationship between the two: jobs are not independent of Pods, and they would be useless without Pods. In the end, the two things they are capable of are launching Pods and managing them. Jobs are meant to handle a certain task and then exit. Here are some examples of typical use cases for a Kubernetes Job:</p>
    <ul>
      <li class="bulletList">Taking a backup of a database</li>
      <li class="bulletList">Sending an email</li>
      <li class="bulletList">Consuming some messages in a queue</li>
    </ul>
    <p class="normal">These are tasks you do not want to run forever. You expect the Pods to be terminated once they have completed their task. This is where the Jobs resource will help you.</p>
    <p class="normal">But why bother using another resource to execute a command? After all, we can create one or multiple Pods directly that will run our command and then exit.</p>
    <p class="normal">This is true. You can use a Pod based on a container image to run the command you want and that would work fine. However, jobs have mechanisms implemented at their level that allow them to manage Pods in a more advanced way. Here are some things that jobs are capable of:</p>
    <ul>
      <li class="bulletList">Running Pods multiple times</li>
      <li class="bulletList">Running Pods multiple times in parallel</li>
      <li class="bulletList">Retrying to launch the Pods if they encountered any errors</li>
      <li class="bulletList">Killing a Pod after a specified number of seconds</li>
    </ul>
    <p class="normal">Another good point is that a job manages the labels of the Pods it will create so that you won’t have to manage the labels on those Pods directly.</p>
    <p class="normal">All of this can be done without using jobs, but this would be very difficult to manage and that is the reason we have the Jobs resource in Kubernetes.</p>
    <h2 class="heading-2" id="_idParaDest-169">Creating a job with restartPolicy</h2>
    <p class="normal">Since <a id="_idIndexMarker410"/>creating a job might require some advanced configurations, we are going to focus on declarative syntax here. This is how you can create a Kubernetes job through YAML. We are going to make things simple here; the job will just echo <code class="inlineCode">Hello world</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-job.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
        <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
        <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'"</span>]
</code></pre>
    <p class="normal">Pay attention to the <code class="inlineCode">kind</code> resource, which tells Kubernetes that we need to create a job and not a Pod, as we did previously. Also, notice <code class="inlineCode">apiVersion:</code>, which also differs from the one that’s used to create the Pod.</p>
    <figure class="mediaobject"><img alt="" src="image/B22019_04_05.png"/></figure>
    <p class="packt_figref">Figure 4.5: Job definition details and Pod template</p>
    <p class="normal">You can <a id="_idIndexMarker411"/>create the job with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl apply -f hello-world-job.yaml
</code></pre>
    <p class="normal">As you can see, this job will create a Pod based on the <code class="inlineCode">busybox</code> container image:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get <span class="hljs-con-built_in">jobs</span>
NAME              COMPLETIONS   DURATION   AGE
hello-world-job   1/1           9s         8m46s
</code></pre>
    <p class="normal">This will run the <code class="inlineCode">echo 'Hello World'</code> command. Lastly, the <code class="inlineCode">restartPolicy</code> option is set to <code class="inlineCode">OnFailure</code>, which tells Kubernetes to restart the Pod or the container in case it fails. If the entire Pod fails, a new Pod will be relaunched. If the container fails (the memory limit has been reached or a non-zero exit code occurs), the individual container will be relaunched on the same node because the Pod will remain untouched, which means it’s still scheduled on the same machine.</p>
    <p class="normal">The <code class="inlineCode">restartPolicy</code> parameter can take two options:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Never</code></li>
      <li class="bulletList"><code class="inlineCode">OnFailure</code></li>
    </ul>
    <p class="normal">Setting it to <code class="inlineCode">Never</code> will prevent the job from relaunching the Pods, even if it fails. When debugging a failing job, it’s a good idea to set <code class="inlineCode">restartPolicy</code> to <code class="inlineCode">Never</code> to help with debugging. Otherwise, new Pods might be recreated over and over, making your life harder when it comes to debugging.</p>
    <p class="normal">In our case, there is little chance that our job was not successful since we only want to run a simple <code class="inlineCode">Hello world</code>. To make sure that our job worked well, we can read the job logs as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span>kubectl logs <span class="hljs-con-built_in">jobs</span>/hello-world-job
Hello world
</code></pre>
    <p class="normal">We can also retrieve the name of the Pod the job created using the <code class="inlineCode">kubectl get pods</code> command. Then, we can use the <code class="inlineCode">kubectl logs</code> command, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span> kubectl logs pods/hello-world-job-2qh4d
Hello world
</code></pre>
    <p class="normal">Here, we can see that our job has worked well since we can see the <code class="inlineCode">Hello world</code> message displayed in the log of our Pod. However, what if it had failed? Well, this depends on <code class="inlineCode">restartPolicy</code> – if it’s set to <code class="inlineCode">Never</code>, then nothing would happen, and Kubernetes wouldn’t <a id="_idIndexMarker412"/>try to relaunch the Pods.</p>
    <p class="normal">However, if <code class="inlineCode">restartPolicy</code> was set to <code class="inlineCode">OnFailure</code>, Kubernetes would try to restart the job after 10 seconds and then double that time on each new failure. 10 seconds, then 20 seconds, then 40 seconds, then 80 seconds, and so on. After 6 minutes, Kubernetes would give up.</p>
    <h2 class="heading-2" id="_idParaDest-170">Understanding the job’s backoffLimit</h2>
    <p class="normal">By default, the<a id="_idIndexMarker413"/> Kubernetes job will try to relaunch the failing Pod six times during the next six minutes after its failure. You can change this limitation by changing the <code class="inlineCode">backoffLimit</code> option. Here is the updated YAML file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-job-2.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-2</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-2</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
        <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
        <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'"</span>]
</code></pre>
    <p class="normal">This way, the job will only try to relaunch the Pods twice after its failure.</p>
    <h2 class="heading-2" id="_idParaDest-171">Running a task multiple times using completions</h2>
    <p class="normal">You can also <a id="_idIndexMarker414"/>instruct Kubernetes to launch a job multiple times using the <code class="inlineCode">Job</code> object. You can do this by using the <code class="inlineCode">completions</code> option to specify the number of times you want a command to be executed. The number of completions will create 10 different Pods that will be launched one after the other in<a id="_idIndexMarker415"/> the following example. Once one Pod has finished, the next one will be started. Here is the updated YAML file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-job-3.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-3</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">completions:</span> <span class="hljs-number">10</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-3</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
        <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
        <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'"</span>]
</code></pre>
    <p class="normal">The <code class="inlineCode">completions</code> option was added here. Also, please notice that the <code class="inlineCode">args</code> section was updated by us by adding the <code class="inlineCode">sleep 3</code> option. Using this option will make the task sleep for three seconds before completing, giving us enough time to notice the next Pod being created. Once you’ve applied this configuration file to your Kubernetes cluster, you can run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods --watch
<span class="hljs-con-meta">$ </span>kubectl get <span class="hljs-con-built_in">jobs</span> -w
NAME                STATUS     COMPLETIONS   DURATION   AGE
hello-world-job-2   Complete   1/1           10s        52s
hello-world-job-3   Running    5/10          49s        49s
hello-world-job-3   Running    5/10          51s        51s
hello-world-job-3   Running    5/10          52s        52s
hello-world-job-3   Running    6/10          52s        52s
hello-world-job-3   Running    6/10          56s        56s
&lt;removed for brevity&gt;
</code></pre>
    <p class="normal">The <code class="inlineCode">watch</code> (<code class="inlineCode">-w</code> or <code class="inlineCode">–watch</code>) mechanism will update your <code class="inlineCode">kubectl</code> output when something new arrives, such as the <a id="_idIndexMarker416"/>creation of the new Pods being managed by your Kubernetes. If you want to wait for the job to finish, you’ll see 10 Pods being created with a 3-second delay between each.</p>
    <h2 class="heading-2" id="_idParaDest-172">Running a task multiple times in parallel</h2>
    <p class="normal">The <code class="inlineCode">completions</code> option <a id="_idIndexMarker417"/>ensures that the Pods are created one after the other. You can also enforce parallel execution using the <code class="inlineCode">parallelism</code> option. If you do that, you can get rid of the <code class="inlineCode">completions</code> option. Kubernetes Jobs can leverage parallelism to significantly speed up execution. By running multiple Pods concurrently, you distribute workload across your cluster, leading to faster completion times and improved resource utilization, especially for large or complex tasks. Here is the updated YAML file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-job-4.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-4</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">5</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-4</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
        <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
        <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'; sleep 3"</span>]
</code></pre>
    <p class="normal">Please notice that the <code class="inlineCode">completions</code> option is now gone and that we replaced it with <code class="inlineCode">parallelism</code>. The job will now launch five Pods at the same time and will have them run in parallel:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl get pods -w
NAME                      READY   STATUS              RESTARTS   AGE
hello-world-job-4-9dspk   0/1     ContainerCreating   0          7s
hello-world-job-4-n6qv9   0/1     Completed           0          7s
hello-world-job-4-pv754   0/1     ContainerCreating   0          7s
hello-world-job-4-ss4g8   1/1     Running             0          7s
hello-world-job-4-v78cj   1/1     Running             0          7s
...&lt;removed for brevity&gt;...
</code></pre>
    <p class="normal">In the next section, we<a id="_idIndexMarker418"/> will learn how to terminate a Job automatically after a particular time period.</p>
    <h2 class="heading-2" id="_idParaDest-173">Terminating a job after a specific amount of time</h2>
    <p class="normal">You can also <a id="_idIndexMarker419"/>decide to terminate a Pod after a specific amount of time. This can be very useful when you are running a job that is meant to consume a queue, for example. You could poll the messages for one minute and then automatically terminate the processes. You can do that using the <code class="inlineCode">activeDeadlineSeconds</code> parameter. Here is the updated YAML file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-job-5.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-5</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">60</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-5</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
        <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
        <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'"</span>]
</code></pre>
    <p class="normal">Here, the job will terminate after 60 seconds, no matter what happens. It’s a good idea to use this feature if you want to keep a process running for an exact amount of time and then terminate it.</p>
    <h2 class="heading-2" id="_idParaDest-174">What happens if a job succeeds?</h2>
    <p class="normal">If your<a id="_idIndexMarker420"/> job is completed, it will remain created in your Kubernetes cluster and will not be deleted automatically: that’s the default behavior. The reason for this is that you can read its logs a long time after its completion. However, keeping your jobs created on your Kubernetes cluster that way might not suit you. You can delete the jobs automatically, and the Pods they created, by using the <code class="inlineCode">ttlSecondsAfterFinished</code> option. Here is the updated YAML file for implementing this solution:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-job-6.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-6</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">ttlSecondsAfterFinished:</span> <span class="hljs-number">30</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-job-6</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
      <span class="hljs-attr">containers:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
        <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
        <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'"</span>]
</code></pre>
    <p class="normal">Here, the jobs are going to be deleted 30 seconds after their completion.</p>
    <h2 class="heading-2" id="_idParaDest-175">Deleting a job</h2>
    <p class="normal">Keep in mind that <a id="_idIndexMarker421"/>the Pods that are created are bound to the life cycle of their parent. Deleting a job will result in deleting the Pods they manage.</p>
    <p class="normal">Start by getting the name of the job you want to destroy. In our case, it’s <code class="inlineCode">hello-world-job</code>. Otherwise, use the <code class="inlineCode">kubectl get jobs</code> command to retrieve the correct name. Then, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl delete <span class="hljs-con-built_in">jobs</span> hello-world-job
</code></pre>
    <p class="normal">If you want to delete the jobs but not the Pods it created, you need to add the <code class="inlineCode">--cascade=false</code> parameter<a id="_idIndexMarker422"/> to the <code class="inlineCode">delete</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl delete <span class="hljs-con-built_in">jobs</span> hello-world-job --cascade=<span class="hljs-con-literal">false</span>
</code></pre>
    <p class="normal">Thanks to this command, you can get rid of all the jobs that will be kept on your Kubernetes cluster once they’ve been completed. Now, let’s move on to launching the first CronJob.</p>
    <h1 class="heading-1" id="_idParaDest-176">Launching your first CronJob</h1>
    <p class="normal">To close this first chapter on Pods, we will look at another Kubernetes resource called <strong class="keyWord">CronJob</strong>.</p>
    <h2 class="heading-2" id="_idParaDest-177">What are CronJobs?</h2>
    <p class="normal">The <a id="_idIndexMarker423"/>name <strong class="keyWord">CronJob</strong> can mean two different things and it is important that we do not get confused with these:</p>
    <ul>
      <li class="bulletList">The Unix <code class="inlineCode">cron</code> feature</li>
      <li class="bulletList">The Kubernetes <code class="inlineCode">CronJob</code> resource</li>
    </ul>
    <p class="normal">Historically, CronJobs are commands scheduled using the cron Unix feature, which is the most robust way to schedule the execution of a command in Unix systems. This idea was later taken up in Kubernetes.</p>
    <p class="normal">Be careful because even though the two ideas are similar, they don’t work the same at all. On Unix and other derived systems such as Unix, you schedule commands by editing a file called <code class="inlineCode">Crontab</code>, which is usually found in <code class="inlineCode">/etc/crontab</code> or related paths. In the world of Kubernetes, things are different: you are not going to schedule the execution of commands but the execution of Job resources, which themselves will create Pod resources. Keep in mind that the <code class="inlineCode">CronJob</code> object you’ll create will create Job objects.</p>
    <p class="normal">Think of it as a kind of wrapper around the Job resource: in Kubernetes, we call that a controller. <code class="inlineCode">CronJob</code> can do everything the Job resource is capable of because it is nothing more than a wrapper around the Job resource, according to the <code class="inlineCode">cron</code> expression specified.</p>
    <p class="normal">The good news is that the Kubernetes <code class="inlineCode">CronJob</code> resource is using the <code class="inlineCode">cron</code> format inherited from Unix. So, if you have already written some CronJobs on a Linux system, mastering Kubernetes CronJobs will be super straightforward.</p>
    <p class="normal">But first, why would you want to execute a Pod? The answer is simple; here are some concrete use cases:</p>
    <ul>
      <li class="bulletList">Taking database backups regularly every Sunday at 1 A.M.</li>
      <li class="bulletList">Clearing cached data every Monday at 4 P.M.</li>
      <li class="bulletList">Sending a queued email every 5 minutes.</li>
      <li class="bulletList">Various maintenance operations to be executed regularly.</li>
    </ul>
    <p class="normal">The use cases of <a id="_idIndexMarker424"/>Kubernetes CronJobs do not differ much from their Unix counterparts – they are used to answer the same need, but they do provide the massive benefit of allowing you to use your already configured Kubernetes cluster to schedule regular jobs using your container images and your already existing Kubernetes cluster.</p>
    <h2 class="heading-2" id="_idParaDest-178">Preparing your first CronJob</h2>
    <p class="normal">It’s time <a id="_idIndexMarker425"/>to create your first <code class="inlineCode">CronJob</code>. Let’s do this using declarative syntax. First, let’s create a <code class="inlineCode">cronjob.yaml</code> file and place the following YAML content into it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-cronjob.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-cronjob</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">schedule:</span> <span class="hljs-string">"* * * * *"</span>
  <span class="hljs-attr">jobTemplate:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">template:</span>
        <span class="hljs-attr">metadata:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-cronjob</span>
        <span class="hljs-attr">spec:</span>
          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
          <span class="hljs-attr">containers:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
            <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
            <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>
            <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
            <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'"</span>]
</code></pre>
    <p class="normal">Before applying this file to the Kubernetes cluster, let’s start to explain it. There are two important things <a id="_idIndexMarker426"/>to notice here:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">schedule</code> key, which lets you input the <code class="inlineCode">cron</code> expression</li>
      <li class="bulletList">The <code class="inlineCode">jobTemplate</code> section, which is exactly what you would input in a job YAML manifest</li>
    </ul>
    <p class="normal">Let’s explain these two keys quickly before applying the file.</p>
    <h2 class="heading-2" id="_idParaDest-179">Understanding the schedule key</h2>
    <p class="normal">The <code class="inlineCode"><a id="_idIndexMarker427"/></code><code class="inlineCode">schedule</code> key allows you to insert an expression in a <code class="inlineCode">cron</code> format such as Linux. Let’s explain how these expressions work; if you already know these expressions, you can skip these explanations:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span>┌───────────── minute (0 - 59)
<span class="hljs-con-meta"># </span>│ ┌───────────── hour (0 - 23)
<span class="hljs-con-meta"># </span>│ │ ┌───────────── day of the month (1 - 31)
<span class="hljs-con-meta"># </span>│ │ │ ┌───────────── month (1 - 12)
<span class="hljs-con-meta"># </span>│ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;
<span class="hljs-con-meta"># </span>│ │ │ │ │                                   7 is also Sunday on some systems)
<span class="hljs-con-meta"># </span>│ │ │ │ │                                   OR sun, mon, tue, wed, thu, fri, sat
<span class="hljs-con-meta"># </span>│ │ │ │ │
<span class="hljs-con-meta"># </span>* * * * *
</code></pre>
    <p class="normal">A <code class="inlineCode">cron</code> expression is made up of five entries separated by white space. From left to right, these entries correspond to the following:</p>
    <ul>
      <li class="bulletList">Minutes</li>
      <li class="bulletList">Hour</li>
      <li class="bulletList">Day of the month</li>
      <li class="bulletList">Month</li>
      <li class="bulletList">Day of the week</li>
    </ul>
    <p class="normal">Each entry can be filled with an asterisk, which means <em class="italic">every</em>. You can also set several values for one entry by separating them with a <code class="inlineCode">,</code>. You can also use a <code class="inlineCode">–</code> to input a range of values. Let me show you some examples:</p>
    <ul>
      <li class="bulletList">“<code class="inlineCode">10 11 * * *</code>" means “At 11:10 every day of every month.”</li>
      <li class="bulletList">“<code class="inlineCode">10 11 * 12 *</code>" means “At 11:10 every day of December.”</li>
      <li class="bulletList">“<code class="inlineCode">10 11 * 12 1</code>" means “At 11:10 of every Monday of December.”</li>
      <li class="bulletList">“<code class="inlineCode">10 11 * * 1,2</code>" means “At 11:10 of every Monday and Tuesday of every month.”</li>
      <li class="bulletList">“<code class="inlineCode">10 11 * 2-5 *</code>" means “At 11:10 every day from February to May.”</li>
    </ul>
    <p class="normal">Here are some <a id="_idIndexMarker428"/>examples that should help you understand how cron works. Of course, you don’t have to memorize the syntax: most people help themselves with documentation or cron expression generators online such as crontab.cronhub.io and crontab.guru. If this is too complicated, feel free to use this kind of tool; it can help you confirm that your syntax is valid before you deploy the object to Kubernetes.</p>
    <h2 class="heading-2" id="_idParaDest-180">Understanding the role of the jobTemplate section</h2>
    <p class="normal">If you’ve<a id="_idIndexMarker429"/> been paying attention to the structure of the YAML file, you may have noticed that the <code class="inlineCode">jobTemplate</code> key contains the definition of a Job object. When we use the <code class="inlineCode">CronJob</code> object, we are simply delegating the creation of a Job object to the <code class="inlineCode">CronJob</code> object.</p>
    <figure class="mediaobject"><img alt="" src="image/B22019_04_06.png"/></figure>
    <p class="packt_figref">Figure 4.6: CronJob YAML architecture</p>
    <p class="normal">Therefore, the <code class="inlineCode">CronJob</code> object is a resource that only manipulates another resource.</p>
    <p class="normal">Later, we will discover many objects that will allow us to create Pods so that we don’t have to do it ourselves. These special objects are called <strong class="keyWord">controllers</strong>: they manipulate other Kubernetes resources by obeying their own logic. Moreover, when you think about it, the Job object is itself a controller since, in the end, it only manipulates Pods by providing <a id="_idIndexMarker430"/>them with its own features, such as the possibility of running Pods in parallel.</p>
    <p class="normal">In a real context, you should always try to create Pods using these intermediate objects as they provide additional and more advanced management features.</p>
    <p class="normal">Try to remember this rule: the basic unit in Kubernetes is a Pod, but you can delegate the creation of Pods to many other objects. In the rest of this section, we will continue to discover <em class="italic">naked</em> Pods. Later, we will learn how to manage their creation and management via controllers.</p>
    <h2 class="heading-2" id="_idParaDest-181">Controlling the CronJob execution deadline</h2>
    <p class="normal">For some<a id="_idIndexMarker431"/> reason, a <code class="inlineCode">CronJob</code> may fail to execute. In this case, Kubernetes cannot execute the Job at the moment it is supposed to start. If jobs surpass their configured deadline, Kubernetes considers them unsuccessful.</p>
    <p class="normal">The optional <code class="inlineCode">.spec.startingDeadlineSeconds</code> field establishes a deadline (in complete seconds) for initiating the Job in case it misses its scheduled time due to any reason. Once the deadline is missed, the Cronjob skips that specific instance of the Job, though future occurrences are still scheduled.</p>
    <h2 class="heading-2" id="_idParaDest-182">Managing the history limits of jobs</h2>
    <p class="normal">After<a id="_idIndexMarker432"/> the completion of a Cronjob, regardless of its success status, your Kubernetes cluster retains a history. The history setting can be configured at the <code class="inlineCode">CronJob</code> level, allowing you to determine whether to preserve the history for each <code class="inlineCode">CronJob</code>. If you choose to keep it, you can specify the number of entries to retain for both succeeded and failed jobs using the optional <code class="inlineCode">.spec.successfulJobsHistoryLimit</code> and <code class="inlineCode">.spec.failedJobsHistoryLimit</code> fields.</p>
    <h2 class="heading-2" id="_idParaDest-183">Creating a CronJob</h2>
    <p class="normal">If you <a id="_idIndexMarker433"/>already have the YAML manifest file, creating a <code class="inlineCode">CronJob</code> object is easy:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># hello-world-cronjob.yaml</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-cronjob</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">schedule:</span> <span class="hljs-string">"*/1 * * * *"</span>
  <span class="hljs-comment"># Run every minute</span>
  <span class="hljs-attr">successfulJobsHistoryLimit:</span> <span class="hljs-number">5</span>
  <span class="hljs-attr">startingDeadlineSeconds:</span> <span class="hljs-number">30</span>
  <span class="hljs-attr">jobTemplate:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">template:</span>
        <span class="hljs-attr">metadata:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-cronjob</span>
        <span class="hljs-attr">spec:</span>
          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>
          <span class="hljs-attr">containers:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-container</span>
              <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
              <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>
              <span class="hljs-attr">command:</span> [<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"-c"</span>]
              <span class="hljs-attr">args:</span> [<span class="hljs-string">"echo 'Hello world'"</span>]
</code></pre>
    <p class="normal">See the details in the preceding YAML sample.</p>
    <p class="normal"><code class="inlineCode">successfulJobsHistoryLimit: 5</code>, instructs the <code class="inlineCode">CronJob</code> controller to retain the 5 most recent successful job runs. Older successful jobs will be automatically deleted.</p>
    <p class="normal">You can create the <code class="inlineCode">CronJob</code> using the <code class="inlineCode">kubectl apply -f</code> command as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl apply -f hello-world-cronjob.yaml
cronjob.batch/hello-world-cronjob created
</code></pre>
    <p class="normal">With that, the <code class="inlineCode">CronJob</code> has been created on your Kubernetes cluster. It will launch a scheduled Pod, as configured in the YAML file; in this case, every minute:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span> kubectl get cronjobs
NAME                  SCHEDULE      TIMEZONE   SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello-world-cronjob   */1 * * * *   &lt;none&gt;     False     0        37s             11m
<span class="hljs-con-meta">$ </span>kubectl get <span class="hljs-con-built_in">jobs</span>
NAME                           COMPLETIONS   DURATION   AGE
hello-world-cronjob-28390196   1/1           3s         4m47s
hello-world-cronjob-28390197   1/1           3s         3m47s
hello-world-cronjob-28390198   1/1           3s         2m47s
hello-world-cronjob-28390199   1/1           3s         107s
hello-world-cronjob-28390200   1/1           4s         47s
<span class="hljs-con-meta">$ </span>kubectl get pods
NAME                                 READY   STATUS      RESTARTS   AGE
hello-world-cronjob-28390196-fpmc6   0/1     Completed   0          4m52s
hello-world-cronjob-28390197-vkzw2   0/1     Completed   0          3m52s
hello-world-cronjob-28390198-tj6qv   0/1     Completed   0          2m52s
hello-world-cronjob-28390199-dd666   0/1     Completed   0          112s
hello-world-cronjob-28390200-kn89r   0/1     Completed   0          52s
</code></pre>
    <p class="normal">Since you have<a id="_idIndexMarker434"/> configured <code class="inlineCode">successfulJobsHistoryLimit: 5</code>, only the last 5 jobs or Pods will be visible.</p>
    <h2 class="heading-2" id="_idParaDest-184">Deleting a CronJob</h2>
    <p class="normal">Like any other<a id="_idIndexMarker435"/> Kubernetes resource, deleting a <code class="inlineCode">CronJob</code> can be achieved through the <code class="inlineCode">kubectl delete</code> command. Like before, if you have the YAML manifest, it’s easy:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>kubectl delete -f ~/cronjob.yaml
cronjob/hello-world-cronjob deleted
</code></pre>
    <p class="normal">With that, the <code class="inlineCode">CronJob</code> has been destroyed by your Kubernetes cluster. No scheduled jobs will be launched anymore.</p>
    <h1 class="heading-1" id="_idParaDest-185">Summary</h1>
    <p class="normal">We have come to the end of this chapter on Pods and how to create them; we hope you enjoyed it. You’ve learned how to use the most important objects in Kubernetes: Pods.</p>
    <p class="normal">The knowledge you’ve developed in this chapter is part of the essential basis for mastering Kubernetes: all you will do in Kubernetes is manipulate Pods, label them, and access them. But also remember, in the actual Kubernetes environment, you will not be creating or modifying resources directly, instead using other methods to deploy your application Pods and other resources. In addition, you saw that Kubernetes behaves like a traditional API, in that it executes CRUD operations to interact with the resources on the cluster. In this chapter, you learned how to launch containers on Kubernetes, how to access these containers using <code class="inlineCode">kubectl</code> port forwarding, how to add labels and annotations to Pods, how to delete Pods, and how to launch and schedule jobs using the <code class="inlineCode">CronJob</code> resource.</p>
    <p class="normal">Just remember this rule about container management: any container that will be launched in Kubernetes will be launched through the object. Mastering this object is like mastering most of Kubernetes: everything else will consist of automating things around the management of Pods, just like we did with the <code class="inlineCode">CronJob</code> object; you have seen that the <code class="inlineCode">CronJob</code> object only launches Job objects that launch Pods. If you’ve understood that some objects can manage others, but in the end, all containers are managed by Pods, then you’ve understood the philosophy behind Kubernetes, and it will be very easy for you to move forward with this orchestrator.</p>
    <p class="normal">Also, we invite you to add labels and annotations to your Pods, even if you don’t see the need for them right away. Know that it is essential to label your objects well to keep a clean, structured, and well-organized cluster.</p>
    <p class="normal">However, you still have a lot to discover when it comes to managing Pods because, so far, we have only seen Pods that are made up of only one Docker container. The greatest strength of Pods is that they allow you to manage multiple containers at the same time, and of course, to do things properly, there are several design patterns that we can follow to manage our Pods when they are made of several containers.</p>
    <p class="normal">In the next chapter, we will learn how to manage Pods that are composed of several containers. While this will be very similar to the Pods we’ve seen so far, you’ll find that some little things are different and that some are worth knowing. First, you will learn how to launch multi-container Pods using <code class="inlineCode">kubectl</code> (hint: <code class="inlineCode">kubectl</code> will not work), and then how to get the containers to communicate with each other. After that, you will learn how to access a specific container in a multi-container Pod, as well as how to access logs from a specific container. Finally, you will learn how to share volumes between containers in the same Pod.</p>
    <p class="normal">As you read the next chapter, you will learn about the rest of the fundamentals of Pods in Kubernetes. So, you’ll get an overview of Pods while we keep moving forward by discovering additional objects in Kubernetes that will be useful for deploying applications in our clusters.</p>
    <h1 class="heading-1" id="_idParaDest-186">Further reading</h1>
    <ul>
      <li class="bulletList"><strong class="keyWord">Managing Pods</strong>: <a href="https://kubernetes.io/docs/concepts/workloads/pods/"><span class="url">https://kubernetes.io/docs/concepts/workloads/pods/</span></a></li>
      <li class="bulletList"><strong class="keyWord">Kubernetes Jobs</strong>: <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/"><span class="url">https://kubernetes.io/docs/concepts/workloads/controllers/job/</span></a></li>
      <li class="bulletList"><strong class="keyWord">Well-Known Labels, Annotations and Taints</strong>: <a href="https://kubernetes.io/docs/reference/labels-annotations-taints/"><span class="url">https://kubernetes.io/docs/reference/labels-annotations-taints/</span></a></li>
      <li class="bulletList"><strong class="keyWord">Kubernetes CronJob</strong>: <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/"><span class="url">https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/</span></a></li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-187">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the authors and other readers:</p>
    <p class="normal"><a href="https://packt.link/cloudanddevops"><span class="url">https://packt.link/cloudanddevops</span></a></p>
    <p class="normal"><img alt="" src="image/QR_Code119001106479081656.png"/></p>
  </div>
</body></html>