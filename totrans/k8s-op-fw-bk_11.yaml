- en: '*Chapter 8*: Preparing for Ongoing Maintenance of Your Operator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have shown the steps for creating a new **Kubernetes** Operator.
    We've covered the full range of processes from conception to design, to coding,
    deployment, and finally, release. But, very few software projects end their life
    cycle after the initial release, Operators included. In fact, for many Operators,
    the majority of work will eventually be done after release on a long enough timescale.
    So, it's valuable to prepare for the future maintenance of your Operator by understanding
    the expectations of your users and the Operator community at large.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a Kubernetes-based project, it can be very helpful to rely on the established
    conventions from Kubernetes and its subprojects for your own ongoing development.
    While you are free to form your own guidelines for future releases, it is likely
    that your Operator will depend on at least some library or aspect of the core
    Kubernetes platform simply by virtue of being built for Kubernetes. For that reason,
    knowing the policies in place for Kubernetes can help align your own development
    practices in preparation for changes in the upstream platform, which you will
    almost certainly inherit and be forced to react to. That''s why this chapter will
    focus on those conventions throughout the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Releasing new versions of your Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning for deprecation and backward compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complying with Kubernetes standards for changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning with the Kubernetes release timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Kubernetes community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The procedures established by the Kubernetes community provide an excellent
    template for your own development practices and a familiar set of policies for
    your users. There is, of course, no requirement for any Operator to strictly follow
    these guidelines, but it is the goal of this chapter to explain them in a way
    that provides the relevant precedent for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, the only technical work will be done in the *Releasing new
    versions of your Operator* section, in which we will build on the existing nginx
    Operator code from earlier chapters to add new code and run that code in a Kubernetes
    cluster. As such, the requirements for this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `operator-sdk` binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Go` 1.16+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a running Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3aiaokl](https://bit.ly/3aiaokl)'
  prefs: []
  type: TYPE_NORMAL
- en: Releasing new versions of your Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that your Operator is published, the fun has just begun. It's now time to
    start thinking about your next release! As with any software project, your Operator
    will evolve over time by introducing new features and adapting to changes in upstream
    Kubernetes. There are tomes of literature written on releasing software with recommendations
    on when and how to publish updates to a software product. Much of that information
    is out of the scope of this book. Instead, we will explain the technical steps
    required to create and publish a new version of your Operator with the **Operator
    SDK**, **Operator Lifecycle Manager** (**OLM**), and **OperatorHub** in mind.
    From there, methods and timing for your release are entirely up to your organization
    (though you may want to learn more about how other Kubernetes projects are released
    later in this chapter in the *Aligning with the Kubernetes release timeline* section).
  prefs: []
  type: TYPE_NORMAL
- en: Adding an API version to your Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While there are many factors that may influence your decision to release a new
    version of your Operator (such as bug fixes or simply following a regular release
    schedule), one type of change that is common among Operators is updating the Operator's
    config API. Recall that this is the API translated into the Operator's **CustomResourceDefinition**
    (**CRD**). So, in some cases, it may be necessary to update the API that is shipped
    with your Operator to indicate changes to users (see the *Complying with Kubernetes
    standards for changes* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to create a new API version and include that version in
    the Operator''s CRD (for a more in-depth look at what this means from a technical
    standpoint, see the Kubernetes documentation on CRD versioning for information
    on the details of how this works: [https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing an Operator
    with the Operator SDK*, we initialized the first version of our Operator''s API
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This created the `NginxOperator` API type as the `v1alpha1` version. We then
    filled out the API in `api/v1alpha1/nginxoperator_types.go` and generated the
    corresponding CRD, which provides the interface for using the Operator once it
    was deployed in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'If some incompatible changes needed to be made to this API that required a
    new version, that version could be generated similarly. Say, for example, that
    we wanted to allow the nginx Deployment managed by our Operator to expose multiple
    ports, such as one for HTTP and another for HTTPS requests. We could do this by
    changing the `port` field in the existing nginx Operator''s CRD to a `ports` field
    that defines a list of `v1.ContainerPorts` (this is a native Kubernetes API type
    that allows for naming multiple ports for a container). This new type exposes
    additional information, such as `Name` and `HostPort`, but it also includes the
    same `int32` value for defining a singular `ContainerPort` that the original `port`
    field used. Let''s take the following line from `controllers/nginxoperator_controller.go`
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be simplified to just the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To show what this means for the Operator types, we will take the existing `NginxOperatorSpec`
    type in `v1alpha1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we will change it to a new `NginxOperatorSpec` type in `v1alpha2`
    that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In order to preserve functionality for our users, it's important to introduce
    the new version in a way that ensures the Operator supports both versions for
    as long as required by the deprecation policy.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the new API directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to generate the new API files. The new API version is generated
    as a scaffold with the `operator-sdk` command, just like when we generated `v1alpha1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that this time, the `--controller` flag was omitted (and we chose `n` for
    `Create Controller [y/n]`) because the controller for this Operator already exists
    (`controllers/nginxoperator_controller.go`), so we don't need to generate another
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the existing controller will need to be manually updated to remove
    references to `v1alpha1` and replace them with `v1alpha2`. This step can also
    be automated with tools such as `sed`, but be sure to carefully review any changes
    whenever automating code updates like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the version is generated, it will create a new `api/v1alpha2` folder,
    which also contains an `nginxoperator_types.go` file. Copy the existing type definitions
    from `api/v1alpha1/nginxoperator_types.go` into this file and change the `port`
    field into `ports`, as shown in the preceding code. The new file should look as
    follows (note the highlighted change to `Ports`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'api/v1alpha2/nginxoperator_types.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Updating the Operator's CRD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, the Operator''s CRD needs to be updated to include definitions for both
    `v1alpha1` and `v1alpha2`. First, one version needs to be defined as the `etcd`.
    When the Operator only had one version, it wasn''t necessary to specify this (that
    was the only version available to be stored). Now, however, the API server needs
    to know how to store the object. This is done by adding another `kubebuilder`
    marker (`//+kubebuilder:storageversion`) to the `NginxOperator` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This instructs the CRD generator to label `v1alpha2` as the storage version.
    Now, running `make manifests` will generate new changes to the CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the Operator''s CRD should include a new `v1alpha2` specification definition
    under `versions`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/crd/bases/operator.example.com_nginxoperators.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Implementing API conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the API server needs to know how to convert between these two incompatible
    versions. Specifically, the `int32` value for the `v1alpha1` port needs to be
    converted into a `ContainerPort` value in a list of `ports` for `v1alpha2`. For
    the sake of this example, we will define the behavior as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1alpha1` to `v1alpha2`: `int32(port)` becomes `ports[0].ContainerPort`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v1alpha2` to `v1alpha1`: `ports[0].ContainerPort` becomes `int32(port)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, if we are handed a list of ports and need to convert to a single
    port (`v1alpha2` to `v1alpha1`), we will take the first value in the list and
    use that. In reverse (`v1alpha1` to `v1alpha2`), we will take the single `port`
    value and make it the first (and only) value in a new list of ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define these conversion rules, we will implement the `Convertible` and `Hub`
    interfaces from `sigs.k8s.io/controller-runtime/pkg/conversion`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sigs.k8s.io/controller-runtime/pkg/conversion/conversion.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: These will then be exposed to the API server via a `operator-sdk` are wrappers
    for kubebuilder commands, so the steps for implementing the conversion webhook
    in an Operator are the same as for any other controller, as shown in the kubebuilder
    documentation). This process defines one version as the `Hub` type through which
    the `Convertible` spoke types are converted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, first create a new file, `api/v1alpha2/nginxoperator_conversion.go`,
    to define `v1alpha2` as the Hub version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'api/v1alpha2/nginxoperator_conversion.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create another file, `api/v1alpha1/nginxoperator_conversion.go` (note
    this is in the `v1alpha1` directory). This file will implement the `ConvertTo()`
    and `ConvertFrom()` functions to translate `v1alpha1` to and from `v1alpha2`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'api/v1alpha1/nginxoperator_conversion.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, fill in these functions to do the actual conversions. For the fields
    such as `Replicas` and `ForceRedeploy`, the conversion is 1:1 (it''s also important
    to copy the `Metadata` and `Status.Conditions` too). But, for `Port`/`Ports`,
    we need to add the logic defined previously. That makes `ConvertTo()` look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'And `ConvertFrom()` is similar, but in reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can generate the webhook logic and endpoints by using `operator-sdk
    create webhook`, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: You can ignore the message saying `You need to implement the conversion.Hub
    and conversion.Convertible interfaces for your CRD types` because we already did
    that (the generator simply assumes that it will be run before these are implemented).
    At this point, everything has been implemented, and the only next step is to ensure
    that the webhook is properly deployed with the Operator when it is installed in
    a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Updating project manifests to deploy the webhook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like how the manifests to enable metrics resources needed to be uncommented
    in order to be deployed with the Operator ([*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*), so too do resources related
    to the webhook.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, first, modify `config/crd/kustomization.yaml` to uncomment the
    `patches/webhook_in_nginxoperators.yaml` and `patches/cainject_in_nginxoperators.yaml`
    lines to include these two patch files in the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/crd/kustomization.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify one of those files, `patches/webhook_in_nginxoperators.yaml`, to
    add the two CRD versions as `conversionReviewVersions` in the Operator''s CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/crd/patches/webhook_in_nginxoperators.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make the following changes to `config/default/kustomization.yaml` to
    uncomment the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`- ../webhook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- ../certmanager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- manager_webhook_patch.yaml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the variables in the `vars` section with the `[CERTMANAGER]` label.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final file will look as follows (uncommented lines highlighted and some
    sections omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/default/kustomization.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, comment out the `manifests.yaml` line in `config/webhook/kustomization.yaml`
    (this file does not exist for our use case, and trying to deploy without uncommenting
    this line will result in an error). The following snippet shows which line should
    be commented out with `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/webhook/kustomization.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: With these changes, the Operator can be re-built and deployed using the `operator-sdk`
    and `make` commands from earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and testing the new API version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To confirm that the API server now understands and can convert between versions
    of the Operator CRD, install it in a cluster. Note that now your Operator will
    depend on **cert-manager** being present in the cluster, so be sure to install
    that first (instructions are available at [https://cert-manager.io/docs/installation/](https://cert-manager.io/docs/installation/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, you need to update `controllers/nginxoperator_controller.go` to replace
    `v1alpha1` references with `v1alpha2` and change the `Ports` check (in `Reconcile()`)
    to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'controllers/nginxoperator_controller.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Forgetting to do this will cause an error when creating or retrieving the Operator
    CRD (which won't show up at compile time). This is because the `v1alpha1` API
    types are still defined and valid (so the Operator code compiles correctly), but
    the new client and reconciliation code will expect the object to be retrieved
    in the `v1alpha2` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy the nginx Operator, build and push the new container image before
    running `make deploy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a simple `NginxOperator` object. To demonstrate the API conversion,
    create it as the `v1alpha1` version and use the old `port` field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sample-cr.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the custom resource object with kubectl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using `kubectl get` to view the object will show it as `v1alpha2` because
    it was automatically converted and stored as this version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'You can choose to specifically view the object as `v1alpha1` with the following
    command, which will instruct the API server to call the Operator''s webhook and
    convert it back using the functions we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: What this means for your users is that they can continue using the existing
    API, which allows valuable transition time while you introduce a new version.
    Note that if they are already using the Operator, and you introduce a new storage
    version, they may need to use **kube-storage-version-migrator** ([https://github.com/kubernetes-sigs/kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator))
    to migrate the existing storage version to the new one. You can provide migration
    files for them (or even automate it into the Operator, as migrations are simply
    Kubernetes resources) to make this easier.
  prefs: []
  type: TYPE_NORMAL
- en: With a new API version introduced and conversion handled, your Operator is now
    ready to be packaged into a new bundle so that deployment can be managed by the
    OLM. This means updating your Operator's CSV to a new version.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Operator CSV version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating the version of the Operator in its CSV provides information to the
    OLM, OperatorHub, and users about which version of the Operator they are running.
    It also instructs the OLM on which versions replace other versions for in-cluster
    upgrades. This allows developers to define specific upgrade `alpha` and `beta`),
    which are similar to the versioning channels in other software projects that allow
    users to subscribe to a different release cadence. The Operator SDK documentation
    goes into technical detail about this process on GitHub, but it is not necessary
    to understand these details for completing this section ([https://github.com/operator-framework/operator-lifecycle-manager/blob/b43ecc4/doc/design/how-to-update-operators.md](https://github.com/operator-framework/operator-lifecycle-manager/blob/b43ecc4/doc/design/how-to-update-operators.md)).
    In this section, however, we will cover the simple task of updating the CSV version
    in a single channel.
  prefs: []
  type: TYPE_NORMAL
- en: The first step toward bumping the Operator's CSV version is updating the version
    that will be replaced with the current version. In other words, `v0.0.2` will
    replace `v0.0.1`, so the `v0.0.2` CSV must indicate that it is replacing `v0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by modifying the base CSV in `config/manifests/bases` to add a
    `replaces` field under its spec, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'config/manifests/bases/nginx-operator.clusterserviceversion.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the `VERSION` variable in the project''s Makefile (you can also
    export this variable to the new version in your shell similar to the other environment
    variables we have used from this file, but updating it manually clearly indicates
    the version and ensures that the right version will be propagated when built on
    any machine):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the new CSV can be built as part of the regular make bundle command from
    [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108), *Installing and Running
    Operators with the Operator Lifecycle Manager*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: This updates the version of the Operator listed in `bundle/manifests/nginx-operator.clusterserviceversion.yaml`
    (which is the main CSV packaged into the Operator's bundle). If you followed the
    steps from the previous section to add a new API version, it also adds information
    about that new version (and the conversion webhook) to the CSV and the sample
    CRD packaged along with the bundle. In addition, it will generate a new Service
    manifest in the bundle that exposes the conversion endpoint for the two API versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bundle image can then be built, pushed, and run with the OLM just like
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: With a new bundle image built and working, the only step remaining in releasing
    your new version is to publish it on OperatorHub for users to find.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing a new version on OperatorHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a new version of your Operator, the bundle that is published to OperatorHub
    also needs to be updated (if you have chosen to release your Operator on OperatorHub).
    Thankfully, this process is not too complex. In fact, it is essentially the same
    as releasing your initial version (as in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*), wherein
    you created a folder with your Operator's bundle and submitted that folder as
    a pull request to the community Operators repository on GitHub ([https://github.com/k8s-operatorhub/community-operators](https://github.com/k8s-operatorhub/community-operators)).
  prefs: []
  type: TYPE_NORMAL
- en: To release a new version of your Operator, simply create a new folder under
    your Operator's directory in the community Operators project named after the version
    number. For example, if the first version was `nginx-operator/0.0.1`, this version
    would be `nginx-operator/0.0.2`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, just like with your first version, simply copy the contents of your Operator's
    `bundle` directory (after generating the new bundle version) into the new version
    folder. Commit and push the changes to your fork of the GitHub repository and
    open a new pull request against the main repository with the changes.
  prefs: []
  type: TYPE_NORMAL
- en: When your pull request passes the automated checks, it should merge, and the
    new version of your Operator should be visible on OperatorHub soon after.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Screenshot of version and channel listing on OperatorHub for
    the Grafana Operator](img/B18147_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Screenshot of version and channel listing on OperatorHub for the
    Grafana Operator
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have finished releasing a new version of your Operator. By introducing
    a new API, ensuring that the new API is convertible between existing versions,
    updating your Operator's bundle, and publishing that updated bundle on OperatorHub,
    you should now announce to your users that the new version of your Operator is
    available. In the next sections, we'll discuss ways to ensure that future releases
    continue to go smoothly by planning ahead to minimize breaking API changes that
    require new versions and following the Kubernetes standards for making new changes.
  prefs: []
  type: TYPE_NORMAL
- en: Planning for deprecation and backward compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed the work needed to release a new version
    of an Operator. While the processes for bundling and publishing a new version
    are relatively simple in terms of the effort required, implementing a new API
    version is not an insignificant task. As such, doing so should be done only as
    necessary in order to minimize the use of engineering resources and disruption
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it will occasionally be unavoidable that incompatible changes must
    be introduced, for example, in the case of deprecation. Some of this deprecation
    might even come from upstream, where it is beyond your direct control (see the
    *Complying with Kubernetes standards for changes* section). However, the frequency
    of such changes can often be controlled through careful planning. In this section,
    we'll discuss some ways to plan for deprecation and support backward compatibility
    without causing undue strain on your engineers or users.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Operator design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032), *Understanding How
    Operators Interact with Kubernetes*, the *Planning for changes in your Operator*
    section discussed, in general terms, various design approaches that establish
    good practices for outlining an Operator's design for future evolution. These
    suggested guidelines (which could, in reality, be applied to many software projects)
    were to start small, iterate effectively, and deprecate gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Now, having gone through the steps of building an Operator from scratch in the
    form of our nginx Operator, it will be helpful to revisit these guidelines and
    examine how they were specifically applied to our own design.
  prefs: []
  type: TYPE_NORMAL
- en: Starting small
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nginx Operator design started out very simple. The Operator was intended
    to serve a very basic function: manage the deployment of an nginx Pod. For configuration
    options, it exposed three fields to control the container port on the Pod, the
    number of replicas to deploy, and an extra field to trigger a forced redeployment.
    As a **minimum viable product** (**MVP**), this served well to get our Operator
    off the ground. While this design was intentionally kept minimal for the purpose
    of a reasonably sized demonstration, it still shows the mindset that keeps Operator
    CRDs from starting out with too many knobs exposed. Shipping excessive configuration
    options can be confusing to users, which then poses potential risks to the stability
    of your product if users cannot fully understand what every option does. This
    also adds a support burden on your own teams.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the first release of an Operator will actually likely make up
    a minority of its life cycle. There will be plenty of time to add more features
    in future releases, but this becomes difficult as the CRD grows in its API definition
    and new features dilute the viability of existing ones. Of course, that's not
    to say you should never add new features to your Operator or its CRD. But, when
    that time comes, it's important to do so carefully, which is the focus of iterating
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating effectively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we introduced an API change to the Operator wherein the type
    of one field was converted to an entirely different nested struct. This effectively
    removed the old field, which would be a breaking change for any user who was already
    relying on that field (in fact, we did technically remove the old field, but more
    on that in a minute). The benefit of changes such as this needs to be weighed
    against the negatives, which include disruption for your users (if applicable)
    and ongoing support for your own team.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we chose to move from a single `int32` field (named `port`) to
    a list of `v1.ContainerPort` objects (named `ports`). This added some complexity
    to the CRD (because `v1.ContainerPort` contains other nested fields). However,
    it also shifted our CRD to rely on a native, stable API type from upstream Kubernetes.
    This, along with the added functionality of being able to configure multiple ports
    and added fields, offers usability and stability benefits for users and developers
    of the Operator (not that `int32` is likely to be unstable, but the general idea
    remains).
  prefs: []
  type: TYPE_NORMAL
- en: Still, this change required the removal of the existing `port` field. This is
    what users must ultimately react to, but that transition can be made smoother
    through graceful deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecating gracefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When adding the new `ports` field to our Operator's CRD, a conscious decision
    was made to remove the existing single `port` field, and that's perfectly acceptable;
    in fact, keeping it would have been unnecessarily redundant. But, the fact remains
    that users who were relying on the old field would have to transition to the new
    one or face data loss when their old configurations were migrated to the new ones.
    While that may seem small for something such as a single integer value, the scope
    of degradation can clearly scale with more complex Operators.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we added a conversion webhook to the Operator, to translate the
    old field into the new one automatically. But that webhook would not have been
    as simple to implement if the new `ports` field wasn't effectively a super-set
    of the old field. Choosing to go with a fairly compatible existing type made this
    transition much easier for developers to implement and users to understand. Design
    decisions such as this greatly help to reduce friction in a growing code base.
  prefs: []
  type: TYPE_NORMAL
- en: However, our conversion was not completely perfect. While the transition from
    `v1alpha1` to `v1alpha2` carries over just fine, the reverse can only hold one
    port value (the first from the list). This may be suitable for practical use cases,
    as most users would be more likely to upgrade to the new version than downgrade
    to the deprecated one, but from a support standpoint, lossy conversion like this
    can create headaches down the road. There are ways to address this that are relevant
    to the next section, which discusses how Kubernetes prescribes ways to smoothly
    implement changes.
  prefs: []
  type: TYPE_NORMAL
- en: Complying with Kubernetes standards for changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes defines a standard set of policies for deprecation (and other breaking
    changes) that all core projects must abide by. This policy is available at [https://kubernetes.io/docs/reference/using-api/deprecation-policy/](https://kubernetes.io/docs/reference/using-api/deprecation-policy/).
    It's not necessary to read and understand the whole policy for the purposes of
    Operator development, as we will highlight some of the relevant bits here. It
    primarily defines the standards for deprecating parts of the Kubernetes API, with
    many of the same (or similar) guidelines being applied to other types of deprecation
    as well (such as user-facing features that are not directly part of the API).
    It does this by enumerating a list of explicit rules for deprecating changes,
    some of which we will cover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: As a third-party component, your Operator is under no obligation to follow the
    Kubernetes deprecation policy. But, in a practical sense, there are benefits to
    working within the constraints of the ecosystem your Operator is built to be a
    part of. These include a template provided to set expectations for your users
    and a set of guidelines for planning your own ongoing development. And, even if
    you choose not to follow these policies for your own Operator, it is still crucial
    to understand how they are enforced upstream to be prepared for deprecations and
    changes beyond your control that you will eventually inherit.
  prefs: []
  type: TYPE_NORMAL
- en: The full deprecation policy linked at the start of this section goes into specific
    detail for standards that govern every applicable Kubernetes component. So, some
    details of the deprecation are not directly relevant to Operator development.
    However, certain elements, such as those pertaining to the support and removal
    of API fields, do apply to Operators (should you choose to follow them).
  prefs: []
  type: TYPE_NORMAL
- en: Removing APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes deprecation policy is very clear on forbidding the removal of
    API elements from the current API version. In fact, this is the first rule in
    the entire policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule #1'
  prefs: []
  type: TYPE_NORMAL
- en: API elements may only be removed by incrementing the version of the API group.
  prefs: []
  type: TYPE_NORMAL
- en: This means that it is forbidden to remove any field or object from an existing
    API. The removal can only be done by introducing a new API version with that element
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: This is relevant to our nginx Operator, where we removed the `port` field that
    was present in `v1alpha1` as we incremented the API version to `v1alpha2`. Following
    this rule ensures that current users of an API version will not have their workflows
    suddenly broken by updating to a new release. The distinction between API versions
    makes a clear indication of some level of incompatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Inversely, this rule allows for the addition of API elements without incrementing
    the version of the existing API. This is because a new element in the current
    API version will not break any existing use cases because it is as if consumers
    of the object are simply leaving this field blank (as opposed to the removal of
    an existing field, which could result in data loss as non-blank entries are dropped).
    This is directly relevant to our use case because it provides an ability for seamless
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: API conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second rule of the Kubernetes deprecation policy is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule #2'
  prefs: []
  type: TYPE_NORMAL
- en: API objects must be able to round-trip between API versions in a given release
    without information loss, with the exception of whole REST resources that do not
    exist in some versions.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when any two API versions exist within the same release of Kubernetes
    (or, in this case, your Operator), objects of either API version must be able
    to convert between the two versions while preserving all data fields.
  prefs: []
  type: TYPE_NORMAL
- en: In our nginx Operator, we did not follow this rule (because a `v1alpha2` CRD
    object with multiple ports defined cannot translate them all to a single `port`
    value). This is OK because, as a third-party project, we are not beholden to the
    upstream Kubernetes policies. But, from a practical standpoint, it would be useful
    for us and our users to support such lossless conversions. This could be done
    by adding the `ports` field to both `v1alpha2` and `v1alpha1`. Then, our conversion
    could have stored the additional ports in the new field when converting to `v1alpha1`.
    Existing code that only knows about the `v1alpha1` single `port` field may not
    be able to use these additional ports, but the important part is that the data
    is preserved during conversion. Alternatively, we could have simply stored the
    additional `ports` values as an annotation in the CRD object's metadata and read
    from this during conversion.
  prefs: []
  type: TYPE_NORMAL
- en: API lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How long you choose to support an API version is entirely up to your organization's
    agreement with your users. The Kubernetes standards for support timelines vary
    based on the stability level of that API. The three levels of stability are alpha,
    beta, and general availability (GA).
  prefs: []
  type: TYPE_NORMAL
- en: In our nginx Operator, the API is currently in alpha. Technically, this means
    that there is no support guarantee for any duration. However, when working toward
    graduating an API to a more stable level, it is good practice to operate as if
    that API is already at the next level of stability. For beta APIs, this timeline
    is the longer of 9 months or three releases (see the *Aligning with the Kubernetes
    release timeline* section). APIs that are graduated to GA cannot be removed, but
    they can be marked as deprecated. The intent is that an API that is GA can be
    assumed stable for the lifetime of that major version of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Removal, conversion, and lifetime are the three main points of the Kubernetes
    deprecation policy relevant to our Operator development. There are more details
    in the link provided at the top of this section. You can also follow the planned
    timeline for upcoming upstream API deprecation, which is published at [https://kubernetes.io/docs/reference/using-api/deprecation-guide/](https://kubernetes.io/docs/reference/using-api/deprecation-guide/),
    for each release.
  prefs: []
  type: TYPE_NORMAL
- en: While this section mentioned the Kubernetes release as a unit of time, we did
    not define exactly how much time that is. In the next section, we will explain
    exactly how the Kubernetes release breaks down and how it relates to your Operator
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning with the Kubernetes release timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each new release of Kubernetes is driven by the hard work and dedication of
    many people from different companies and time zones. This process for publishing
    a new version of Kubernetes is, therefore, the product of an orchestration effort
    among component areas and **special interest groups** (**SIGs**) to ensure timely,
    stable releases. While there are occasional roadblocks and delays, the release
    timeline is, for the most part, a well-defined collaborative effort that strives
    to provide predictable updates that the Kubernetes ecosystem of users and downstream
    products can depend on.
  prefs: []
  type: TYPE_NORMAL
- en: When developing an Operator, you or your organization will likely have similar
    organized release efforts. You also want to provide a dependable and timely schedule
    for shipping updates to your users. And, while your own release schedule may differ
    from the Kubernetes timeline, there are still benefits to a keen understanding
    of how the upstream release works. For example, it offers you the ability to plan
    around specific dates at which a beta API will be promoted to GA, or an entirely
    new feature will become available that you can leverage in your own product to
    pass on to your users. On the other hand, it also outlines the remaining time
    that deprecated APIs have before they are removed entirely. As a product vendor,
    you can rely on this timeline to guide your release planning.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, aligning your Operator's release timeline for updates with
    that of Kubernetes is a valuable effort and it's why we will explain that timeline
    more in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of a Kubernetes release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes release cycle is approximately 15 weeks long. As of Kubernetes
    1.22, this has defined a goal of three releases per calendar year. Of course,
    three 15-week releases do not account for an entire 52-week-long year. This is
    because the release cycle allows for several breaks in work, including holidays,
    end-of-year travel, and events or conferences such as **KubeCon**. This timeline
    was decided on by the SIG Release team with input from the community, and you
    can read more details about the decision in a blog post at [https://kubernetes.io/blog/2021/07/20/new-kubernetes-release-cadence/](https://kubernetes.io/blog/2021/07/20/new-kubernetes-release-cadence/).
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of a single release, there are several key dates that signal
    important progress updates in that release. These include an **Enhancements Freeze**,
    **Code Freeze**, deadlines for documentation updates and blog posts, and **release
    candidate** (**RC**) version releases. The exact timeline for each release is
    posted in the SIG Release GitHub repository at [https://github.com/kubernetes/sig-release](https://github.com/kubernetes/sig-release).
    As an example, the Kubernetes 1.24 release cycle looked like the following, with
    some of these key dates highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Kubernetes 1.24 release cycle calendar](img/B18147_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Kubernetes 1.24 release cycle calendar
  prefs: []
  type: TYPE_NORMAL
- en: Each of these dates plays an important role in the progression of an individual
    release. In the following sections, we'll explain what each of them means in more
    detail and how they can relate to your own release cycle for your Operator. Much
    of this information is also documented in the SIG Release repository at [https://github.com/kubernetes/sig-release/blob/master/releases/release_phases.md](https://github.com/kubernetes/sig-release/blob/master/releases/release_phases.md).
  prefs: []
  type: TYPE_NORMAL
- en: Start of release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fairly self-explanatory, this is the official date that the release cycle for
    the next version of Kubernetes begins. This provides a reference date from which
    all other steps in the cycle can be derived. Note that this is not the same date
    as the previous release's publication because of the buffer between release cycles,
    along with post-release processes such as **Retrospective**. So, there may already
    be work-in-progress for the current release before this date (see the *GA release/Code
    Thaw* subsection). However, just as any race needs a starting line, every release
    needs a date to denote its official beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements Freeze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New features in Kubernetes take many forms. While all changes to the platform
    are valuable regardless of size, certain undertakings involve increased effort
    and a broadened scope of work. Examples include significant user-facing changes
    or architectural designs involving collaboration between multiple components and
    SIGs. Such features require additional management to ensure their successful rollout.
    At this point, the feature may be considered as an **enhancement** or **Kubernetes
    Enhancement Proposal** (**KEP**).
  prefs: []
  type: TYPE_NORMAL
- en: We have already mentioned several individual KEPs in this book. For example,
    in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an Operator
    – Advanced Functionality,* we referred to `Condition` type for components to report
    their status (including our nginx Operator). All KEPs such as this are tracked
    in the *Kubernetes Enhancements* GitHub repository at [https://github.com/kubernetes/enhancements](https://github.com/kubernetes/enhancements).
  prefs: []
  type: TYPE_NORMAL
- en: The full details of the KEP process and repository are beyond the scope of this
    book, but the essential knowledge is that KEPs signify wide-scale design changes
    that can impact users or consumers of APIs. As the developer of an Operator, which
    is itself a component that may consume one or more upstream APIs (such as the
    `Condition` field), it is then important to be aware of the status of upcoming
    changes of this scale, as they may directly affect you. Providing this information
    is the goal of the KEP process.
  prefs: []
  type: TYPE_NORMAL
- en: During a release cycle, the Enhancements Freeze stage signifies the point at
    which all proposed KEPs for that release must be either accepted and committed
    toward implementing their changes or delayed for a future release. This is the
    critical *go*/*no-go* date for moving forward with a KEP for that release. And,
    while many in-progress KEPs are able to proceed at this point, there may be a
    reasonable justification why certain changes may not be able to commit to the
    release by this date. In these cases, the developers of an enhancement may request
    an **exception** during the *Call for Exceptions* period, described next.
  prefs: []
  type: TYPE_NORMAL
- en: For Operator developers, the Enhancements Freeze deadline is an important date
    to keep in mind during your own development cycle because, while KEPs are often
    used to introduce new features to Kubernetes, part of their definition is to outline
    the removal of other features (such as any that are being replaced). Being aware
    of any features you depend on being officially slated for removal helps to gauge
    the urgency with which you will need to react to that removal. On the other hand,
    knowing that a KEP missed the deadline for Enhancements Freeze can provide assurance
    that any related features planned for removal will continue to be supported for
    at least another release unless that plan receives an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Call for Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If, during the course of a release, a certain feature is not yet ready to commit
    to Enhancement Freeze (or *Code Freeze*), the contributors and participating SIGs
    who are working on that enhancement may request an exception to the freeze deadlines.
    If approved, this allows those contributors a reasonable extension to accommodate
    the additional time needed to prepare the enhancement for release.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements seeking an exception need to meet certain criteria to ensure that
    they do not risk impacting the stability of the platform or delaying the release.
    Therefore, release managers evaluate each exception request based on its scope,
    the estimated extension time requested, and the time at which the request was
    submitted within the release cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Exception requests and approvals are generally communicated via the participating
    SIG's mailing lists, Slack channels, and the specific KEP issue discussion page
    on GitHub. This is why it's important to monitor these communication channels
    for features your Operator implements or depends on. Just because a new feature
    missed Enhancements Freeze, that doesn't mean it won't be implemented until an
    exception has been officially denied. The same goes for planned removals, in the
    event that an exception is granted. Knowing whether the upstream SIG related to
    your Operator's function is going to request any exceptions after Enhancements
    Freeze (or Code Freeze) is a good signal for what to commit to in your Operator's
    development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Code Freeze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code Freeze is the point during the release cycle at which all code changes
    must be complete and merged into the Kubernetes code base (besides any features
    that have been granted an exception). This signifies that no more changes will
    be accepted into the release unless they are critical to the stability of the
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: As the developer of a downstream Operator, this is relevant to your own project
    timeline because it is the point at which you can begin updating your libraries
    to the latest Kubernetes version with a reasonable expectation of stability. This
    can be done by updating your dependencies to the latest RC version of the upstream
    Kubernetes libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The first RC for a new release is usually published soon after the Code Freeze
    date. This timing allows developers to update dependencies with additional *soak
    time* to catch any additional updates or reactions that need to be made in order
    to function with the new version of Kubernetes before it is finally released.
    It is very beneficial to take advantage of this timing to minimize the delay between
    publishing your updated Operator after the Kubernetes version release. Due to
    the size and fluctuating nature of Kubernetes, it's recommended to upgrade any
    upstream dependencies regularly. Failure to do so is likely to result in snowballing
    technical debt and eventual lack of compatibility with newer versions of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Test Freeze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Code Freeze defines a strict deadline for enhancements to have their implementations
    completely merged, Test Freeze allows an additional buffer to expand test coverage.
    This provides an opportunity to improve test cases once a feature has merged before
    release. After this date, the only changes allowed to any tests are to fix or
    remove tests that are consistently failing. This date may not have a consistent
    impact on your own release cycle, but it is a good signal to be aware of when
    monitoring the progress of a key enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: GA release/Code Thaw
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At last, the moment everyone has been waiting for. If there are a few problems
    discovered during the release that cause a delay, this is the date that Kubernetes
    releases its newest version. For developers, this means that the code in Kubernetes
    (at [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes))
    is updated with a new Git tag, which allows the opportunity to easily reference
    the release point at a definitive point in code (for example, when updating your
    Operator''s dependencies in its `go.mod` file). In addition, the client libraries
    that support Kubernetes and its subprojects are also updated, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/api](https://github.com/kubernetes/api) – Core
    API types used by the Kubernetes platform (imported as `k8s.io/api`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/apimachinery](https://github.com/kubernetes/apimachinery)
    – The library used to implement the encoding and decoding of API types in code
    (`k8s.io/apimachinery`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go)
    – The Go client used by Operators and other programs to interact with Kubernetes
    resources programmatically (`k8s.io/client-go`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few of the additional dependencies that, on GA release day,
    will be updated with a new Git tag. These dependencies are actually part of the
    core Kubernetes repository (`k8s.io/kubernetes`), but they are synced to symbolic
    canonical locations by an automated bot for better dependency management. This
    can sometimes cause a slight delay between core Kubernetes releasing its tag and
    the libraries updating with their own (which are usually more important to developers).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes as a Dependency
  prefs: []
  type: TYPE_NORMAL
- en: The core Kubernetes repository at `k8s.io/kubernetes` (or [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes))
    contains all of the code needed by the core platform components. So, it may be
    tempting to import code from here directly. However, due to its complexity, it
    is not recommended to import code from `k8s.io/kubernetes` directly into your
    project as it can cause dependency issues that are difficult to resolve with Go
    modules and bring excess transitive dependencies into your project. Instead, it
    is best to rely on the component libraries (such as those listed previously),
    which are meant to be imported into outside projects.
  prefs: []
  type: TYPE_NORMAL
- en: After the new release is officially published, the Kubernetes project enters
    `master` (or `main`) branch at any point after this really means you are interacting
    with the `N+1` version code (where `N` is the current version of Kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: Retrospective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the dust has settled, the SIG Release team takes time to review the release
    during **Retrospective**. The intent of Retrospective is to meet and discuss any
    roadblocks or concerns that occurred during that release and propose solutions
    to address them in the future. In addition, any exceptional successes are identified
    and praised. It is meant as a blameless process through which the end goal is
    simply to reduce friction for future releases. While the specific details of the
    Retrospective may not be directly relevant to the development of your Operator
    (the focus is generally more on the release infrastructure and processes that
    drive the release rather than specific feature changes), it can be a very informative
    way to be aware of future changes to the release cycle.
  prefs: []
  type: TYPE_NORMAL
- en: All of the above dates form the most important signals in the Kubernetes release
    cycle. Being aware of them can help inform your team about the status of the current
    features you depend on, and that information can be passed on in the form of the
    commitments you make to your users. Staying up to date with the latest Kubernetes
    releases is critical to avoid tiresome technical debt from piling up, as the Kubernetes
    project is constantly evolving within the support constraints it offers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, knowing where you are in the current release cycle also provides
    the opportunity to contribute to Kubernetes at meaningful times. In the next section,
    we will discuss ways you can do this and how it can benefit you.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Kubernetes community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused heavily on the standards, policies, and timelines of Kubernetes
    as they relate to Operator development. While it might seem that these are fixed,
    prescriptive decrees, the reality is that they are fluid frameworks for development
    created through an open and fair process. This process is organized by contributors
    from different companies all over the world, and it is always open to new voices.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer for the Kubernetes platform, you have inherent stock in the community
    that organizes Kubernetes upstream. Therefore, improvements or concerns that affect
    you are likely to affect others as well. This is why it's not only OK but encouraged
    that you play an active role in upstream development alongside your own Operator.
    If nothing else, doing so serves to benefit your own development, as the open
    process allows you to help steer upstream work as you feel it should be done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting involved is as simple as sending a message or joining a video call.
    The various GitHub repositories and Slack channels shown in other chapters for
    support are a great place to offer support yourself. The Kubernetes Slack server
    is [slack.k8s.io](http://slack.k8s.io), and it is free to join and contribute.
    You may also want to follow the various SIG meetings for topics of interest, all
    of which are listed on the *Kubernetes Community* repository at [https://github.com/kubernetes/community](https://github.com/kubernetes/community).
    This repository includes links and schedules for all SIG and community meetings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once, in an interview, champion football quarterback Tom Brady was asked which
    of his championship rings was his favorite, to which he replied, "The next one."
    Coming from a person who many already considered to be one of the most successful
    in his field, that response showed powerful commitment to a continuous pursuit
    of achievement (if not a little tongue-in-cheek hubris). As software developers,
    that same passion is what drives the never-ending cycle of improvement with every
    new release.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter was about the part of the Operator development cycle that is even
    more important than the first release: the next one. Releasing new software versions
    is not something that is exclusive to Operators, but the idiomatic processes and
    upstream Kubernetes standards do create a unique set of requirements for Operator
    projects. By exploring the technical steps necessary to create and publish a new
    version, alongside the more abstract policies and timelines that dictate guidelines
    for doing so, we have ensured that you are aware of a few suggestions for how
    to keep your Operator running for many releases to come.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the technical tutorial section of this book. While there are
    many topics and details that, unfortunately, did not fit within the scope of these
    chapters, we have explained all of the foundational concepts to build an Operator
    following the Operator Framework. In the next chapter, we'll summarize these concepts
    in an FAQ-style format to quickly refresh what was covered.
  prefs: []
  type: TYPE_NORMAL
