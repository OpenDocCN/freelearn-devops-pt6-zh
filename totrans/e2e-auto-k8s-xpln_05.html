<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-40"><em class="italic"><a id="_idTextAnchor039"/>Chapter 3</em>: Automating Infrastructure with Crossplane</h1>
			<p>It is time to stop being abstract about ideas and deep-dive into details. Starting with this chapter, we will go on a hands-on journey to implement what we have learned and explore different Crossplane concepts at the same time. Trying out the examples given in this book will ensure that we have the ideas and experience to practice modern infrastructure engineering in our day-to-day jobs. This chapter will specifically cover the detailed architecture of Crossplane and its out-of-the-box features.</p>
			<p>The following are the topics covered in this chapter:</p>
			<ul>
				<li>Understanding Custom Resource Definitions and custom controllers</li>
				<li>Understanding the Crossplane architecture</li>
				<li>Installing Crossplane</li>
				<li>Installing and configuring providers</li>
				<li>Multiple provider configuration</li>
				<li>An example of POSTGRES provisioning</li>
			</ul>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Understanding Custom Resource Definitions and custom controllers</h1>
			<p>Understanding the concept of <strong class="bold">Custom Resource Definitions</strong> (<strong class="bold">CRDs</strong>) and custom controllers in Kubernetes is <a id="_idIndexMarker108"/>vital to know how Crossplane<a id="_idIndexMarker109"/> works. Before getting into the Crossplane architecture, we will take a quick look at CRDs and custom controllers.</p>
			<p class="callout-heading">Terminology</p>
			<p class="callout">The term <strong class="bold">resources</strong> in Kubernetes represents a collection of objects of a similar kind. Pods, Services, Deployments, namespaces, and many more are the in-built object kinds. Each resource has the respective API endpoints at kube-apiserver.</p>
			<p>CRDs are the way to extend <a id="_idIndexMarker110"/>the in-built resources list. It adds a new resource kind, including a set of API endpoints at kube-apiserver, to operate over the new resource. The term CRD precisely indicates what it does. The new resource added to <a id="_idIndexMarker111"/>Kubernetes using a CRD is called a <strong class="bold">Custom Resource</strong> (<strong class="bold">CR</strong>). Storing and<a id="_idIndexMarker112"/> retrieving a structured object defined with a CRD is not helpful unless backed by a custom controller. Custom controllers are our addition to the in-built controllers. They generally operate over a CR to perform specific actions in a control loop for each API event of a given resource. <a href="B17830_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introducing the New Operating Model</em>, has already covered the concept of a control loop. Refer to the <em class="italic">Control theory</em> section if you want to brush up on the idea. Note that the custom controllers do not necessarily always work with a CR. They can work with any existing resources to extend its functionality, which is not in the scope of our discussion. The Prometheus operator is one of the most famous and widely used examples of adding a few new CRs and controllers into the Kubernetes cluster to perform monitoring of workloads.</p>
			<p class="callout-heading">Terminology</p>
			<p class="callout">The term <strong class="bold">operator</strong> when applied to Prometheus is a term coined by CoreOS. Operators are nothing but a combination of <em class="italic">CRD + a custom controller + application focus</em>.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Adding a new CRD</h2>
			<p>While there are a few ways to add CRDs to Kubernetes, let's add CRDs by creating a <strong class="source-inline">yaml</strong> file and applying the same on the cluster. The <strong class="source-inline">yaml</strong> file provides a structure to the CR. The following are the key attributes of a CRD YAML:</p>
			<ul>
				<li><strong class="bold">ApiVersion</strong> for a CRD YAML falls under <strong class="source-inline">apiextensions.k8s.io/v1beta1</strong>.</li>
				<li><strong class="bold">Kind</strong> is the elements that specify that we are representing a resource as YAML. The name designated for the CRD resource is <strong class="source-inline">CustomResourceDefinition</strong>.</li>
				<li>The <strong class="bold">metadata name</strong> is the next critical element that requires a standard format. The format is the plural name (the plural name of the CR we define) + . + group (the API group under which we what to classify the CR). In the following YAML sample, we describe it as <strong class="source-inline">clouddbs.book.imarunrk.com</strong>, where <strong class="source-inline">clouddbs</strong> is the plural name and <strong class="source-inline">book.imarunrk.com</strong> is a newly defined API group. The term plural name is nothing but a representation of the resource name in the plural format. For example, the plural format of the existing resource pod is pods. We can always use that with kubectl commands (<strong class="source-inline">kubectl get pods</strong>).</li>
				<li><strong class="bold">Spec</strong> is the section under<a id="_idIndexMarker113"/> which we define the details of the CR. The attributes of this <a id="_idIndexMarker114"/>section include the API group, version, scope, and name. This section also describes the validation requirements of the API itself, such as the parameter list, their data types, and whether they are a required parameter.</li>
			</ul>
			<p>The following is a sample CRD YAML that represents a cloud database resource. It takes a couple of mandatory parameters, the database type, and the cloud provider name:</p>
			<pre class="source-code">apiVersion: "apiextensions.k8s.io/v1beta1"</pre>
			<pre class="source-code">kind: "CustomResourceDefinition"</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: "clouddbs.book.imarunrk.com"</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  group: "book.imarunrk.com"</pre>
			<pre class="source-code">  version: "v1"</pre>
			<pre class="source-code">  scope: "Namespaced"</pre>
			<pre class="source-code">  names:</pre>
			<pre class="source-code">    plural: "clouddbs"</pre>
			<pre class="source-code">    singular: "clouddb"</pre>
			<pre class="source-code">    kind: "CloudDB"</pre>
			<pre class="source-code">  validation:</pre>
			<pre class="source-code">    openAPIV3Schema:</pre>
			<pre class="source-code">      required: ["spec"]</pre>
			<pre class="source-code">      properties:</pre>
			<pre class="source-code">        spec:</pre>
			<pre class="source-code">         required: ["type","cloud"]</pre>
			<pre class="source-code">         properties:</pre>
			<pre class="source-code">           type:</pre>
			<pre class="source-code">              type: "string"</pre>
			<pre class="source-code">              minimum: 1</pre>
			<pre class="source-code">           cloud:</pre>
			<pre class="source-code">              type: "string"</pre>
			<pre class="source-code">              minimum: 1 </pre>
			<p>Executing the following YAML code will enable new rest endpoints at kube-apiserver to create, modify, and delete the CloudDB resource:</p>
			<pre class="source-code"># Apply the CRD yaml to the Kubernetes cluster</pre>
			<pre class="source-code">kubectl create -f crd.yaml</pre>
			<p>The next step is to write the <a id="_idIndexMarker115"/>custom controller to manage the CR<a id="_idIndexMarker116"/> API events. We can write a controller in many different languages using different open source frameworks. Writing a controller is an advanced topic that is covered later in <a href="B17830_07_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 7</em></a>, <em class="italic">Extending and Scaling Crossplane</em>. Crossplane providers are nothing but controllers to manage external infrastructure resources – generally, cloud providers' managed services. For now, we must remember that controllers implement functions to execute three actions – observe, analyze, and react in a control loop. In the preceding example, the control loop will create, update, and delete the cloud database based on the resource's creation, update, and delete API events.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Working with the CRD</h2>
			<p>Once we have the CRD and controller in<a id="_idIndexMarker117"/> place, we can start creating and managing the cloud database with <strong class="source-inline">kubectl</strong>. It will work very similarly to other in-built resources such as the Pod. The following YAML is an example of creating Amazon RDS:</p>
			<pre class="source-code">apiVersion: "book.imarunrk.com/v1"</pre>
			<pre class="source-code">kind: "CloudDB"</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: "aws_RDS"</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  type: "sql"</pre>
			<pre class="source-code">  cloud : "aws"</pre>
			<p>Applying the following command will create a new CloudDB resource:</p>
			<pre class="source-code"># Apply the CloudDB yaml to the Kubernetes cluster</pre>
			<pre class="source-code">kubectl create -f aws_rds.yaml</pre>
			<p>Note that the preceding YAML will not create an RDS, as we have not developed and deployed a controller. The example is to explain how CRDs and custom controllers work. Now that we have learned about CRDs and custom controllers, it's time to look at the Crossplane architecture in detail.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Understanding the Crossplane architecture</h1>
			<p>From what we know so far, Crossplane is <a id="_idIndexMarker118"/>nothing but a set of Kubernetes custom controllers and CRDs representing external infrastructure resources. If you take a closer<a id="_idIndexMarker119"/> look, Crossplane is much more than a combination of CRDs and custom controllers. Crossplane has four key components. The components are as follows:</p>
			<ul>
				<li>Managed resources </li>
				<li>Providers</li>
				<li>Composite resources</li>
				<li>The Crossplane core</li>
			</ul>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Managed resources</h2>
			<p>A <strong class="bold">Managed Resource</strong> (<strong class="bold">MR</strong>) connects a CRD <a id="_idIndexMarker120"/>and respective custom controller to represent a single external infrastructure resource. MRs are in a one-to-one mapping with infrastructure resources. For example, CloudSQLInstance is an MR representing Google Cloud SQL. The following diagram depicts the MR mapping for Amazon RDS and Google Cloud Storage:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_3.1_B17830.jpg" alt="Figure 3.1 – MR mapping&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – MR mapping</p>
			<p>The <strong class="bold">Crossplane Resource Model</strong> (<strong class="bold">XRM</strong>) is the open standard used when developing an MR. The XRM is an opinionated extension of the <strong class="bold">Kubernetes Resource Model</strong> (<strong class="bold">KRM</strong>). The XRM sets the standards for external resource naming, dependency management, package management, and so on. MRs are the basic building blocks on which everything else in Crossplane is made. We can use MRs directly to provision an external infrastructure, but this is very rarely done. The best practice is to compose a higher-level API above an MR to consume. We will look at <em class="italic">how</em> and <em class="italic">why</em> in a later section of this chapter, as well as a dedicated chapter to address this aspect in detail. The following YAML<a id="_idIndexMarker121"/> represents the provisioning of CloudSQLInstance directly using an MR:</p>
			<pre class="source-code">apiVersion: database.gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: CloudSQLInstance</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: my-GCP-DB</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  forProvider:</pre>
			<pre class="source-code">    databaseVersion: POSTGRES_9_6</pre>
			<pre class="source-code">    region: asia-south2</pre>
			<pre class="source-code">    settings:</pre>
			<pre class="source-code">      tier: db-n1-standard-1</pre>
			<pre class="source-code">      dataDiskSizeGb: 10</pre>
			<pre class="source-code">  writeConnectionSecretToRef:</pre>
			<pre class="source-code">    namespace: DB</pre>
			<pre class="source-code">    name: my-GCP-DB-credentials</pre>
			<p>The YAML will provision a GCP Cloud SQL instance with the resource constraints mentioned in the configurations. Since MR is the low-level Crossplane construct mapping to the infrastructure provider API, it will directly support all the attributes available in the infrastructure API. The reconciliation control loop of Crossplane controllers will fill default values assigned by the infrastructure API for the features not provided in the configuration YAML. This concept of MR is called late<a id="_idIndexMarker122"/> initialization. Whatever we provide under the <strong class="source-inline">forProvider:</strong> section will represent the attributes of the infrastructure API. If someone or a parallel process performs an unauthorized change to the infrastructure resource, Crossplane will roll back the changes to the source of truth mentioned in the YAML. The remaining parts of the configuration will help to determine other Crossplane behavior. For example, the preceding YAML has <strong class="source-inline">writeConnectionSecretToRef:</strong> to decide how to save the database credentials. There can be many more such behavior controls, which we will learn as we go further. The following commands can help look at the details of the created GCP resource and clean up the resources after testing:</p>
			<pre class="source-code"># View the resources created with</pre>
			<pre class="source-code">kubectl get cloudsqlinstance my-GCP-DB</pre>
			<pre class="source-code">kubectl describe cloudsqlinstance my-GCP-DB</pre>
			<pre class="source-code"># Delete the resources created with</pre>
			<pre class="source-code">kubectl delete cloudsqlinstance my-GCP-DB</pre>
			<p>We can also import the existing<a id="_idIndexMarker123"/> provisioned infrastructure into the Crossplane ecosystem. The MR checks whether the resources named in the configuration YAML already exist before fresh provisioning. When we build that YAML for the existing infrastructure, we can provide the authorized attributes that need to be maintained by the reconciliation loop under <strong class="source-inline">forProvider</strong>. In the next chapter, we will look at an example of importing existing infrastructure into Crossplane.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">One of the possible Crossplane behavior controls is the deletion policy, specified with an attribute called <strong class="bold">deletionPolicy</strong>. It can <a id="_idIndexMarker124"/>have two possible values – <strong class="bold">Delete</strong>, which is the default, and <strong class="bold">Orphan</strong>. While Delete will remove the resource from the infrastructure provider, Orphan will just remove the Crossplane reference.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Providers</h2>
			<p>Providers are a group of related<a id="_idIndexMarker125"/> MRs packaged together as a bundle. Each cloud vendor, other infrastructure services such as Rook (the cloud-native storage for Kubernetes – <a href="https://rook.io/">https://rook.io/</a>), and software tools such as Helm have a provider package. The format of these packages is nothing but a container image. Installing a provider can be done either with a configuration YAML or using a Helm package. It requires a ProviderConfig configuration before we can start using these packages. The ProviderConfig resource helps us to set up the infrastructure vendor credentials. We will look at<a id="_idIndexMarker126"/> provider installation and ProviderConfig setup in the next section of the chapter. </p>
			<p>The following figure represents the AWS and GCP providers extending Crossplane for the respective cloud resource provisioning:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_3.2_B17830.jpg" alt="Figure 3.2 – A provider view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – A provider view</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Composite resources</h2>
			<p>Every organization is<a id="_idIndexMarker127"/> different in its structure, size, operating model, technology maturity, compliance, and security requirements. All these aspects will directly create a set of rules as policies for infrastructure provisioning and usage. Also, there is a complexity in assembling multiple pieces of the infrastructure stack. Composing is a way to build our custom infrastructure APIs above one or more MR APIs. These custom APIs can encode all the policy guidelines and assemble multiple pieces of infrastructure into simple, easy-to-use infrastructure recipes. These APIs <a id="_idIndexMarker128"/>are called <strong class="bold">Composite Resources</strong> (<strong class="bold">XRs</strong>). The critical aspect is that Crossplane allows us to define such resources in a no-code way, just with configurations. In the absence of a Crossplane composite, we will end up building complex Kubernetes custom controllers. Composition and <strong class="bold">Composite Resource Definition</strong> (<strong class="bold">XRD</strong>) are the configurations that we use to compose a higher-level XR API. XRD defines the schema of the new custom API that we are building. It's the definition of a new CRD. Composition is the configuration that provides a mapping between the new CRD schema <a id="_idIndexMarker129"/>and the existing MRs. Once the new XR resource is available, we can start provisioning the infrastructure recipes using a resource claim object. The Claim API is something that gets created when we add a new XR API, provided we have asked for it in the XRD configuration. The Claim and XR APIs are almost the same with minor differences, which we will explore in an upcoming section. The following diagram represents how we can use CloudSQLInstance, a firewall, and network MRs from the GCP provider to construct an XPOSTGRES database composite:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.3_B17830.jpg" alt="Figure 3.3 – A composite resource&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – A composite resource</p>
			<p>We have thousands of cloud-managed services with many attributes requiring a detailed configuration. It adds a significant cognitive load to shortlist the options and implement the resource provisioning, with good guardrail settings that suit our organization's needs. Every product team in an organization cannot take up this level of cognitive load. Usually, organizations use a platform team to abstract the cognitive load. The composing layer is for platform teams to build such abstractions. Crossplane enables us to expose these abstractions as Kubernetes APIs, allowing self-service for the product teams. The following diagram represents the platform and product team interaction model:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.4_B17830.jpg" alt="Figure 3.4 – Product and platform team interaction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Product and platform team interaction</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Crossplane core</h2>
			<p>Before setting up the providers we are interested in and building XRs above that, we need to <a id="_idIndexMarker130"/>have a Crossplane core component installed in the cluster. This component provides the primitives required to manage multiple providers, build new XRs, and build new packages. Again, the core component is a bundle of CRDs and custom controllers. It is the glue that holds everything else about Crossplane together. The following figure represents how all the pieces fit within the Kubernetes ecosystem:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.5_B17830.jpg" alt="Figure 3.5 – All the pieces of Crossplane&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – All the pieces of Crossplane</p>
			<p>Let's revisit some of the acronyms<a id="_idIndexMarker131"/> that we have used so far, which we will use going forward:</p>
			<ul>
				<li><strong class="bold">CRD</strong> stands for <strong class="bold">Custom Resource Definition</strong>, a way to extend the Kubernetes API to support new resource types.</li>
				<li>CRs are the resources defined with the CRD. <strong class="bold">CR</strong> stands for <strong class="bold">Custom Resource</strong>.</li>
				<li><strong class="bold">XRM</strong> stands for <strong class="bold">Crossplane Resource Model</strong>, an extension of the <strong class="bold">Kubernetes Resource Model</strong>. It is a set of rules set by Crossplane on how to build an XR or MR.</li>
				<li><strong class="bold">MRs</strong> are nothing but <strong class="bold">Managed Resources</strong>, a combination of a CRD and custom controllers in a one-to-one mapping with external infrastructure resources.</li>
				<li><strong class="bold">XRD</strong> stands for <strong class="bold">Composite Resource Definition</strong>, a definition for building a custom infrastructure API above Crossplane.</li>
				<li><strong class="bold">XR</strong> stands for <strong class="bold">Composite Resource</strong>, which represents a custom infrastructure API built with Crossplane.</li>
			</ul>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Installing Crossplane</h1>
			<p>I have set up a local Kubernetes cluster on <a id="_idIndexMarker132"/>my Macintosh computer. We will make this cluster the Crossplane control plane for provisioning resources from Google Cloud Platform in our tutorials. To follow the tutorials, we assume that you already have access to a Kubernetes cluster. If you need help setting up a local Kubernetes cluster, refer to <a href="https://kind.sigs.k8s.io/">https://kind.sigs.k8s.io/</a>. kind is one of the simplest ways to set up a local Kubernetes cluster, but you can work on the tutorials with any Kubernetes cluster setup. The following screenshot gives a quick glimpse at cluster information, versions, and node details:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.6_B17830.jpg" alt="Figure 3.6 – Cluster information, versions, and node details&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Cluster information, versions, and node details</p>
			<p>While there are a few ways to install Crossplane in Kubernetes, we will install it with a Helm chart. Make sure you have Helm installed. Installing Helm is pretty simple on both Macintosh and Windows with the <strong class="source-inline">brew</strong> or <strong class="source-inline">choco</strong> package managers. The following commands can install <strong class="source-inline">helm</strong> in your environment:</p>
			<pre class="source-code"># Install helm in mac</pre>
			<pre class="source-code">brew install helm</pre>
			<pre class="source-code"># Install helm in windows</pre>
			<pre class="source-code">choco install kubernetes-helm</pre>
			<p>For more installation options, visit <a href="https://helm.sh/docs/intro/install/">https://helm.sh/docs/intro/install/</a>. For Crossplane installation, we need a minimum Kubernetes version of v1.16.0 and a minimum Helm version of v3.0.0. Master and stable are the two flavors of Crossplane available. Master has the latest commits, but this <a id="_idIndexMarker133"/>version may have stability issues. Stable is a version that is ready for community use and recommended for production usage. We will be using the stable version of the Crossplane in this tutorial. The installation of Crossplane is done in three steps, as follows:</p>
			<ol>
				<li>Create a new target namespace called <strong class="source-inline">crossplane-system</strong> for installation.</li>
				<li>Add and update the Crossplane repository to the <strong class="source-inline">helm</strong> repo list.</li>
				<li>Install Crossplane with <strong class="source-inline">helm</strong> in the target namespace.</li>
			</ol>
			<p>The code is as follows:</p>
			<pre class="source-code"># Step 1: Create target namespace </pre>
			<pre class="source-code">kubectl create namespace crossplane-system</pre>
			<pre class="source-code"># Step 2: Add crossplane stable repo to helm and update </pre>
			<pre class="source-code">helm repo add crossplane-stable \ https://charts.crossplane.io/stable</pre>
			<pre class="source-code">helm repo update</pre>
			<pre class="source-code"># Step 3: Install Crossplane</pre>
			<pre class="source-code">helm install crossplane --namespace crossplane-system crossplane-stable/crossplane</pre>
			<p>The Crossplane Helm chart supports quite a few template values for custom configuration options. Replica count is one example, which specifies how many Crossplane Pods are to run for a high-availability setup. Have a look at all possible configuration options available for the Crossplane Helm template at Artifact Hub. The installation screenshot is as follows:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.7_B17830.jpg" alt="Figure 3.7 – Crossplane installation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Crossplane installation</p>
			<p>We can remove the Crossplane installation<a id="_idIndexMarker134"/> with the standard <strong class="source-inline">helm delete</strong> command:</p>
			<pre class="source-code"># To remove Crossplane</pre>
			<pre class="source-code">helm delete crossplane --namespace crossplane-system</pre>
			<p>A screenshot of the result is as follows:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_3.8_B17830.jpg" alt="Figure 3.8 – Crossplane installation health&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Crossplane installation health</p>
			<p>Now that we have installed Crossplane, we will learn how to install and configure the providers in the following <a id="_idIndexMarker135"/>section.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Installing and configuring providers</h1>
			<p>Once we have the Crossplane core<a id="_idIndexMarker136"/> component installed in the Kubernetes cluster, the<a id="_idIndexMarker137"/> next step is installing and configuring the Crossplane provider. We will install and configure the GCP provider, which is the scope of our tutorial. We can do this in a three-step process:</p>
			<ol>
				<li value="1">Setting up a cloud account</li>
				<li>Installing a provider</li>
				<li>Configuring the provider</li>
			</ol>
			<p>We will look at each of these aspects in detail with a step-by-step guide in the following sections.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Setting up a cloud account</h2>
			<p>We need to have a Google Cloud account <a id="_idIndexMarker138"/>with the project and billing setup enabled. Google Cloud offers $300 credit for new users to learn and experiment for a maximum of 3 months, provided you have a credit card. It will be more than enough for us to learn Crossplane and other infrastructure automation concepts. All we need to do is log on to the Google Cloud account to fill out a form and start the free trial. The next step is to create a separate project space for us to experiment with Crossplane. You can create a new project by clicking the project dropdown on the top bar of the GCP console and clicking on <strong class="bold">NEW PROJECT</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_3.9_B17830.jpg" alt="Figure 3.9 – Creating a new GCP project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Creating a new GCP project</p>
			<p>Once we have a GCP account, free credits, and<a id="_idIndexMarker139"/> the project started, the next step is to enable all the needed cloud API access. We are going to do that with the <strong class="source-inline">gcloud</strong> CLI. Download the CLI from <a href="https://cloud.google.com/sdk/docs/install">https://cloud.google.com/sdk/docs/install</a> and follow these steps:</p>
			<ol>
				<li value="1">Install the <strong class="source-inline">gcloud</strong> CLI after the download:<p class="source-code">./google-cloud-sdk/install.sh</p></li>
				<li>Initialize the SDK with the cloud credentials and project:<p class="source-code">gcloud init</p></li>
			</ol>
			<p><strong class="source-inline">gcloud init</strong> will redirect us to a web browser to authenticate with the Google account. Once we can successfully provide necessary access, we must select the project when asked for it by the CLI. Now, we should be able to enable the required cloud services with the following commands:</p>
			<pre class="source-code"># Enable Kubernetes APIs , CloudSQL APIs, Network APIs and Compute APIs</pre>
			<pre class="source-code">gcloud services enable container.googleapis.com</pre>
			<pre class="source-code">gcloud services enable sqladmin.googleapis.com</pre>
			<pre class="source-code">gcloud services enable compute.googleapis.com</pre>
			<pre class="source-code">gcloud services enable servicenetworking.googleapis.com</pre>
			<p>A screenshot of the result is as follows:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.10_B17830.jpg" alt="Figure 3.10 – Enabling the cloud APIs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Enabling the cloud APIs</p>
			<p>Once we are done enabling the API <a id="_idIndexMarker140"/>access for the project, the next step is to create a service account and extract the credentials required to set up the GCP Crossplane provider. It involves a few steps:</p>
			<ol>
				<li value="1">Find the project ID to use in the necessary upcoming commands:<p class="source-code">gcloud projects list --format='value(project_id)'</p></li>
				<li>Create the service account, get the name, and enable the required roles on the service account. Note that <strong class="source-inline">crossplane-330620</strong> in all the following commands is my Google project ID. You will replace that with your Google project ID. Use the preceding command to explore the list of your project IDs. Similarly, <strong class="source-inline">crossplane-service-account@crossplane-330620.iam.gserviceaccount.com</strong> is the name of the created service account in my GCP environment. Replace this with your service account name. You can get your service account name by executing the second command in the following code block to list the service accounts:<p class="source-code"># Create service account</p><p class="source-code">gcloud iam service-accounts create crossplane-service-account --display-name "crossplane service account" --project=crossplane-330620</p><p class="source-code"># Get the name of the service account</p><p class="source-code">gcloud iam service-accounts list --filter="email ~ ^crossplane-service-account" --format='value(email)'</p><p class="source-code"># Add required IAM role to the service account</p><p class="source-code">gcloud projects add-iam-policy-binding crossplane-330620 --member "serviceAccount:crossplane-service-account@crossplane-330620.iam.gserviceaccount.com" --role="roles/iam.serviceAccountUser"</p><p class="source-code">gcloud projects add-iam-policy-binding crossplane-330620 --member "serviceAccount:crossplane-service-account@crossplane-330620.iam.gserviceaccount.com" --role="roles/cloudsql.admin"</p><p class="source-code">gcloud projects add-iam-policy-binding crossplane-330620 --member "serviceAccount:crossplane-service-account@crossplane-330620.iam.gserviceaccount.com" --role="roles/container.admin"</p><p class="source-code">gcloud projects add-iam-policy-binding crossplane-330620 --member "serviceAccount:crossplane-service-account@crossplane-330620.iam.gserviceaccount.com" --role="roles/redis.admin"</p><p class="source-code">gcloud projects add-iam-policy-binding crossplane-330620 --member "serviceAccount:crossplane-service-account@crossplane-330620.iam.gserviceaccount.com" --role="roles/compute.networkAdmin"</p><p class="source-code">gcloud projects add-iam-policy-binding crossplane-330620 --member "serviceAccount:crossplane-service-account@crossplane-330620.iam.gserviceaccount.com" --role="roles/storage.admin"</p></li>
				<li>To extract the service <a id="_idIndexMarker141"/>account file, use the first command, as follows:<p class="source-code">gcloud iam service-accounts keys create crossplane-service-account.json --iam-account crossplane-service-account@crossplane-330620.iam.gserviceaccount.com</p></li>
				<li>Finally, create a Kubernetes Secret with the service account file. The Secret will be referred to when we make a provider configuration, which you will see in the next section:<p class="source-code">kubectl create secret generic gcp-account -n crossplane-system --from-file=creds=./crossplane-service-account.json </p></li>
			</ol>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Installing a provider</h2>
			<p>Let's now install the GCP Crossplane provider. We <a id="_idIndexMarker142"/>have to run the following provider resource YAML with the latest GCP provider container image version. The current available stable version is v0.18.0. Update the version accordingly when you are executing:</p>
			<pre class="source-code">apiVersion: pkg.crossplane.io/v1</pre>
			<pre class="source-code">kind: Provider</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: provider-gcp</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  package: crossplane/provider-gcp:v0.18.0</pre>
			<p>Apply the YAML and validate whether the provider container is running:</p>
			<pre class="source-code">kubectl apply -f Provider.yaml</pre>
			<pre class="source-code">kubectl get all -n crossplane-system</pre>
			<p>A screenshot of the result is as <a id="_idIndexMarker143"/>follows:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.11_B17830.jpg" alt="Figure 3.11 – Running the GCP provider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Running the GCP provider</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Configuring the provider</h2>
			<p>The final step is to set up provider<a id="_idIndexMarker144"/> configuration for authentication using the <strong class="source-inline">ProviderConfig</strong> Crossplane API. Preparing the credentials can be slightly different for each provider, depending on the construct for authentication by the infrastructure vendor. In the case of GCP, it will be a service account, it's a service principle for Azure, an IAM for AWS, and so on. The following YAML will configure credentials for the GCP provider:</p>
			<pre class="source-code">apiVersion: gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: ProviderConfig</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: gcp-credentials-project-1 </pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  projectID: crossplane-330620</pre>
			<pre class="source-code">  credentials:</pre>
			<pre class="source-code">    source: Secret</pre>
			<pre class="source-code">    secretRef:</pre>
			<pre class="source-code">      namespace: crossplane-system</pre>
			<pre class="source-code">      name: gcp-account</pre>
			<pre class="source-code">      key: service-account</pre>
			<p>A couple of crucial aspects of GCP provider configuration are the project ID reference and the service account credentials. We need to provide our GCP project ID under <strong class="source-inline">projectID:</strong>. We will not have this configuration element for other infrastructure provider configurations such as AWS. Note that the provider configuration mentioned previously references the<a id="_idIndexMarker145"/> Kubernetes Secrets. Apply the YAML and validate the provider configuration with the following commands:</p>
			<pre class="source-code">kubectl apply -f providerconfig.yaml</pre>
			<pre class="source-code">kubectl get providerconfig</pre>
			<p>A screenshot of the result is as follows:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_3.12_B17830.jpg" alt="Figure 3.12 – The GCP provider config&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – The GCP provider config</p>
			<p>With this, we are concluding Crossplane installation, GCP provider setup, and configuration. Other provider setups also mostly look like GCP. Now, the environment is ready for provisioning GCP resources with an MR, or we can start composing our XR API above the MR.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Multiple provider configuration</h1>
			<p>We can have multiple ProviderConfig configured against a provider. It's like having many credentials or <a id="_idIndexMarker146"/>cloud accounts to access the cloud platform and choosing the appropriate credentials based on the given context. When provisioning the infrastructure resources with an MR or XR, we specify <strong class="source-inline">providerConfigRef:</strong> to determine which ProviderConfig to use in the given context. If <strong class="source-inline">providerConfigRef:</strong> is not available in an MR or XR, Crossplane refers to the ProviderConfig named <strong class="source-inline">default</strong>. This way of organizing infrastructure resources under different credentials can help us manage infrastructure billing and maintain resources concerning the organizational structure in groups. The following YAML will provision POSTGRES from GCP using the provider config named <strong class="source-inline">gcp-credentials-project-1</strong>, which we created in the preceding section:</p>
			<pre class="source-code">apiVersion: database.gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: CloudSQLInstance</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: my-GCP-DB</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  # Reference to use a specific provider config </pre>
			<pre class="source-code">  providerConfigRef:</pre>
			<pre class="source-code">    name: gcp-credentials-project-1</pre>
			<pre class="source-code">  forProvider:</pre>
			<pre class="source-code">    databaseVersion: POSTGRES_9_6</pre>
			<pre class="source-code">    region: asia-south2</pre>
			<pre class="source-code">    settings:</pre>
			<pre class="source-code">      tier: db-n1-standard-1</pre>
			<pre class="source-code">      dataDiskSizeGb: 10</pre>
			<p>The following figure represents multiple teams using different provider configs:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_3.13_B17830.jpg" alt="Figure 3.13 – Multiple provider configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Multiple provider configuration</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>An example of POSTGRES provisioning</h1>
			<p>It's time that we<a id="_idIndexMarker147"/> go through an actual provisioning experience. We will create a POSTGRES instance in GCP using <strong class="source-inline">CloudSQLInstance</strong>, an MR available in the GCP Crossplane provider. Direct provisioning of infrastructure resources with an MR or XR is not a good strategy. Instead, we should be using the claim object created with XR for provisioning. The next chapter is devoted to covering these topics. Currently, we are using an MR for resource provisioning to understand the basic building blocks of Crossplane. We are going to use the following attributes while provisioning the resource:</p>
			<ul>
				<li>The name of the resource provisioned should be <strong class="source-inline">db-gcp</strong>.</li>
				<li>The region of provisioning will be <strong class="source-inline">us-central</strong>.</li>
				<li>We will request POSTGRES version 9.6 – <strong class="source-inline">POSTGRES_9_6</strong>.</li>
				<li>The size of the data disk should be 20 GB.</li>
				<li>The GCP tier of the database should be <strong class="source-inline">db-g1-small</strong>.</li>
				<li>Create the resource under the <strong class="source-inline">gcp-credentials-project-1</strong> provider configuration.</li>
				<li>Database credentials should go to a <strong class="source-inline">crossplane-system</strong> namespace with a Secret named <strong class="source-inline">db-conn</strong>.</li>
			</ul>
			<p>These are just a few possible parameters. The complete API documentation for CloudSQLInstance is available at <a href="https://doc.crds.dev/github.com/crossplane/provider-gcp/database.gcp.crossplane.io/CloudSQLInstance/v1beta1@v0.18.0">https://doc.crds.dev/github.com/crossplane/provider-gcp/database.gcp.crossplane.io/CloudSQLInstance/v1beta1@v0.18.0</a>. Note that there is a required tag against a few API parameters, which are mandatory in YAML. The following YAML <a id="_idIndexMarker148"/>code will provision GCP POSTGRES with the mentioned attributes:</p>
			<pre class="source-code">apiVersion: database.gcp.crossplane.io/v1beta1</pre>
			<pre class="source-code">kind: CloudSQLInstance</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: db-gcp</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  providerConfigRef:</pre>
			<pre class="source-code">    name: gcp-credentials-project-1</pre>
			<pre class="source-code">  writeConnectionSecretToRef:</pre>
			<pre class="source-code">    namespace: crossplane-system</pre>
			<pre class="source-code">    name: db-conn</pre>
			<pre class="source-code">  forProvider:</pre>
			<pre class="source-code">    databaseVersion: POSTGRES_9_6</pre>
			<pre class="source-code">    region: us-central</pre>
			<pre class="source-code">    settings:</pre>
			<pre class="source-code">      tier: db-g1-small</pre>
			<pre class="source-code">      dataDiskSizeGb: 20</pre>
			<p>Once you apply the YAML code, you can see the resources provisioned in the GCP console. Use the following command to look at the states. Note that, initially, we will see the status as pending creation (<strong class="source-inline">PENDING_CREATE</strong>), and it will soon become runnable (<strong class="source-inline">RUNNABLE</strong>). Also, we can see that the database credentials are available in the Secrets:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_3.14_B17830.jpg" alt="Figure 3.14 – Database provisioning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Database provisioning</p>
			<p>Suppose we look at the database details in the GCP console and change the database machine type. Crossplane will restore it to the original tier mentioned in the YAML code. It was fun to try that and see the<a id="_idIndexMarker149"/> status change. Initially, it will go into maintenance mode when we change the console, and then Crossplane will realize that something was changed to put the resource out of sync. Then, Crossplane will bring it back to its original state. Please refer to the following screenshot and go through values in each column (<strong class="source-inline">STATE</strong>, <strong class="source-inline">SYNCED</strong>, and <strong class="source-inline">READY</strong>):</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_3.15_B17830.jpg" alt="Figure 3.15 – The reconciliation loop&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – The reconciliation loop</p>
			<p>And finally, the resources will sync. We can clean up the provisioned resources based on the deletion policy:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_3.16_B17830.jpg" alt="Figure 3.16 – The final state&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – The final state</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to create the resource in the vendor infrastructure with a name different from that of the Crossplane resource claim, use the <strong class="source-inline">crossplane.io/external-name:my-special-name</strong> annotation in the metadata section.</p>
			<p>All the examples discussed throughout this <a id="_idIndexMarker150"/>book can be referred to at <a href="https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane">https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane</a>.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Summary</h1>
			<p>We started with understanding CRDs and custom controllers, and then the Kubernetes resource extension point concept, which are the building blocks of Crossplane. Then, we went through various Crossplane components, their architecture, and how those components fit together. Finally, we undertook some hands-on work by installing Crossplane and its GCP provider, and experimenting with Postgres database provisioning. Now we know how Crossplane works end to end, which brings us to the end of the chapter. In the next chapter, we will learn advanced Crossplane concepts.</p>
		</div>
	</body></html>