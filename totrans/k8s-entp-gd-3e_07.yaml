- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: RBAC Policies and Auditing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RBAC 策略与审计
- en: Authentication is only the first step in managing access to a cluster. Once
    access to a cluster is granted, it’s important to limit what accounts can do,
    depending on whether an account is for an automated system or a user. Authorizing
    access to resources is an important part of protecting against both accidental
    issues and bad actors looking to abuse a cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证仅是管理集群访问的第一步。一旦授予对集群的访问权限，就需要限制账户的操作权限，具体取决于账户是为自动化系统还是用户所使用。授权访问资源是防止意外问题和恶意行为者滥用集群的重要部分。
- en: In this chapter, we’re going to detail how Kubernetes authorizes access via
    its **Role-Based Access Control** (**RBAC**) model. The first part of this chapter
    will be a deep dive into how Kubernetes RBAC is configured, what options are available,
    and mapping the theory onto practical examples. Debugging and troubleshooting
    RBAC policies will be the focus of the second half.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍 Kubernetes 如何通过其 **基于角色的访问控制** (**RBAC**) 模型授权访问。本章的第一部分将深入探讨 Kubernetes
    RBAC 如何配置、可用的选项以及如何将理论应用于实际示例。调试和故障排除 RBAC 策略将是第二部分的重点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to RBAC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC 介绍
- en: Mapping enterprise identities to Kubernetes to authorize access to resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将企业身份映射到 Kubernetes 以授权访问资源
- en: Implementing namespace multi-tenancy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现命名空间多租户
- en: Kubernetes auditing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 审计
- en: Using `audit2rbac` to debug policies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `audit2rbac` 来调试策略
- en: Once you have completed this chapter, you’ll have the tools needed to manage
    access to your cluster via Kubernetes’ integrated RBAC model and debug issues
    when they arise. Next, let’s dive into the technical requirements for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将掌握通过 Kubernetes 的集成 RBAC 模型管理集群访问权限并调试出现问题时的工具。接下来，让我们深入探讨本章的技术要求。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: An Ubuntu 22.04+ server running Docker with a minimum of 4 GB of RAM, though
    8 GB is suggested.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Docker 的 Ubuntu 22.04+ 服务器，至少需要 4 GB 的 RAM，建议使用 8 GB。
- en: 'Scripts from the `chapter7` folder from the repo, which you can access by going
    to this book’s GitHub repository: [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自仓库中 `chapter7` 文件夹的脚本，您可以通过访问本书的 GitHub 仓库来获取：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)
- en: Introduction to RBAC
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RBAC 介绍
- en: '**RBAC** stands for **Role-Based Access Control**. At its core is the idea
    of building permission sets, which are called **Roles**, and lists of subjects
    (users) that those permissions apply to. In this chapter, we’ll walk through building
    roles and their corresponding bindings to build out the permissions in our clusters.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**RBAC** 代表 **基于角色的访问控制**。它的核心思想是构建权限集，这些权限集被称为 **Role**，以及这些权限适用的主体（用户）列表。在本章中，我们将通过构建角色及其相应的绑定，来构建集群中的权限。'
- en: What’s a Role?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Role？
- en: In Kubernetes, a **Role** is a way to tie together permissions into an object
    standardized to a specific schema. By codifying **Roles** into this schema, you’re
    able to standardize and automate their creation and management.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，**Role** 是一种将权限绑定到标准化的特定架构对象中的方式。通过将 **Role** 规范化为这种架构，你可以标准化并自动化它们的创建和管理。
- en: 'Roles have rules, which are a collection of resources and verbs. Working backward,
    we have the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 角色包含规则，规则是资源和动词的集合。倒推过来，我们有以下内容：
- en: '**Verbs**: The actions that can be taken on an API, such as reading (`get`),
    writing (`create`, `update`, `patch`, and `delete`), or listing and watching.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动词**：可以在 API 上执行的操作，例如读取（`get`）、写入（`create`、`update`、`patch` 和 `delete`），或者列出和监视。'
- en: '**Resources**: Names of APIs to apply the verbs to, such as `services`, `endpoints`,
    and so on. Specific sub-resources, such as `logs` and `status`, may be listed
    as well. Specific resources can be named to provide very specific permissions
    on an object.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：要将动词应用于的 API 名称，例如 `services`、`endpoints` 等。也可以列出特定的子资源，如 `logs` 和 `status`。可以命名特定的资源，以便为对象提供非常具体的权限。'
- en: A Role does not say who can perform the verbs on the resources—that is handled
    by `RoleBindings` and `ClusterRoleBindings`. We will learn more about these in
    the *RoleBindings and ClusterRoleBindings* section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 角色并不指定谁可以对资源执行动词——这一点由 `RoleBindings` 和 `ClusterRoleBindings` 处理。我们将在 *RoleBindings
    和 ClusterRoleBindings* 部分了解更多内容。
- en: The term “role” can have multiple meanings, and RBAC is often used in other
    contexts. In the enterprise world, the term “role” is often associated with a
    business role and used to convey entitlements to that role instead of a specific
    person.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “角色”一词可以有多种含义，RBAC 在其他上下文中也经常使用。在企业界，“角色”一词通常与业务角色相关联，并用来表示该角色的授权，而非某个特定人员。
- en: '![Diagram  Description automatically generated](img/B21165_07_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图示 描述自动生成](img/B21165_07_01.png)'
- en: 'Figure 7.1: RBAC versus entitlement-based access control'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：RBAC 与基于授权的访问控制
- en: As an example, in *Figure 7.1*, a user is a member of the “role” for accounts
    payable. Being a member of this role automatically provides the entitlement to
    “write checks.” If our user’s job changes to accounts receivable, their permissions
    will change automatically because the permissions are tied to the user’s role.
    In enterprise RBAC models, what ties a user to a “role” is generally some context
    instead of a specific group membership or attribute value. For instance, users
    might be located in different parts of the corporate directory based on their
    “role.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 *图 7.1* 中，一个用户是应付账款角色的成员。作为该角色的成员，自动获得“开支票”的授权。如果该用户的工作变为应收账款，他们的权限会自动发生变化，因为权限与用户的角色相关联。在企业
    RBAC 模型中，将用户与“角色”绑定的通常是某种上下文，而不是特定的组成员身份或属性值。例如，用户可能根据他们的“角色”位于公司目录的不同位置。
- en: This is different from how Kubernetes uses the term “Role” to mean a list of
    permissions, and those permissions aren’t tied together because of a business
    role but because of a technical requirement. As we’ll see when we get to bindings,
    Kubernetes Roles are tightly bound to accounts and groups, and while the permissions
    of a `Role` are grouped together for a specific function, that function is defined
    at a lower, technical level than “enterprise” roles.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Kubernetes 使用“角色”一词表示权限列表的方式不同，这些权限并非因为业务角色而绑定在一起，而是基于技术需求。正如我们在学习绑定时将看到的，Kubernetes
    角色与账户和组紧密绑定，虽然 `Role` 的权限是为了特定功能而分组的，但该功能的定义低于“企业”角色的技术层次。
- en: Now that we’ve differentiated between what the “enterprise” definition of a
    role is from how Kubernetes defines a `Role`, let’s dive into how you build a
    `Role`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经区分了“企业”角色的定义与 Kubernetes 中 `Role` 的定义，让我们深入了解如何构建 `Role`。
- en: 'Each resource that a role will be built from is identified by the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 角色所基于的每个资源通过以下方式标识：
- en: '`apiGroups`: A list of groups the resources are a member of'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiGroups`：资源所属的组列表'
- en: '`resources`: The name of the object type for the resource (and potentially
    sub-resources)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`：资源的对象类型名称（以及可能的子资源）'
- en: '`resourceNames`: An optional list of specific objects to apply this rule to'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resourceNames`：应用此规则的特定对象的可选列表'
- en: Each rule *must* have a list of `apiGroups` and `resources`. `resourceNames`
    is optional.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则 *必须* 包含 `apiGroups` 和 `resources` 列表。`resourceNames` 是可选的。
- en: Once the resource is identified in a rule, verbs can be specified. A verb is
    an action that can be taken on the resource, providing access to the object in
    Kubernetes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在规则中识别出资源，就可以指定动词。动词是对资源可以执行的操作，它提供对 Kubernetes 中对象的访问。
- en: If the desired access to an object should be `all`, you do not need to add each
    verb; instead, the wildcard character may be used to identify all the `verbs`,
    `resources`, or `apiGroups`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对对象的期望访问是 `all`，则无需添加每个动词；相反，可以使用通配符字符来标识所有的 `verbs`、`resources` 或 `apiGroups`。
- en: Identifying a Role
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别角色
- en: 'The Kubernetes authorization page ([https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/))
    uses the following `Role` as an example to allow someone to get the details of
    a pod and its logs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 授权页面（[https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)）使用以下
    `Role` 作为示例，允许某人获取 Pod 的详细信息及其日志：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before defining what a `Role` manages, it’s important to note that `Role` objects
    are namespaced, so the `namespace` the `Role` is created in means that the permissions
    it defines apply only within its own `namespace`. In this example, the `Role`
    only applies to the `default namespace`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`Role`管理什么之前，需要注意的是，`Role`对象是命名空间的，因此`Role`创建所在的`namespace`意味着它定义的权限仅适用于该命名空间。在这个示例中，`Role`仅适用于`default
    namespace`。
- en: Working backward to determine how this `Role` was defined, we will start with
    `resources`, since it is the easiest aspect to find. All objects in Kubernetes
    are represented by URLs. If you wanted to pull all the information about the pods
    in the `default` `namespace`, you would call the `/api/v1/namespaces/default/pods`
    URL, and if you wanted the logs for a specific pod, you would call the `/api/v1/namespaces/default/pods/mypod/log`
    URL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 反向推理如何定义此`Role`，我们将从`resources`开始，因为这是最容易找到的部分。Kubernetes 中的所有对象都是通过 URL 表示的。如果你想获取`default`
    `namespace`中所有 Pod 的信息，你可以调用`/api/v1/namespaces/default/pods` URL；如果你想获取某个特定 Pod
    的日志，你可以调用`/api/v1/namespaces/default/pods/mypod/log` URL。
- en: The URL pattern will be true of all namespace-scoped objects. pods lines up
    to `resources`, as does `pods/log`. When trying to identify which resources you
    want to authorize, use the `api-reference` document from the Kubernetes API documentation
    at [https://kubernetes.io/docs/reference/#api-reference](https://kubernetes.io/docs/reference/#api-reference).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该 URL 模式适用于所有命名空间范围的对象。pods 与`resources`对齐，`pods/log`也一样。当试图识别你想要授权的资源时，可以使用
    Kubernetes API 文档中的`api-reference`文档，网址为[https://kubernetes.io/docs/reference/#api-reference](https://kubernetes.io/docs/reference/#api-reference)。
- en: If you are trying to access an additional path component after the name of the
    object (such as with `status` and `logs` on pods), it needs to be explicitly authorized.
    Authorizing `Pods` does not immediately authorize `logs` or `status`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问对象名称之后的额外路径组件（如 Pod 上的`status`和`logs`），则需要明确授权。授权`Pods`并不会立即授权`logs`或`status`。
- en: Based on the use of URL mapping to `resources`, your next thought may be that
    the `verbs` field is going to be HTTP verbs. This is not the case. There is no
    `GET` verb in Kubernetes. Verbs are instead defined by the schema of the object
    in the API server. The good news is that there’s a static mapping between HTTP
    verbs and RBAC verbs ([https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb)).
    Looking at this URL, notice that there are verbs on top of the HTTP verbs for
    **impersonation**. That’s because the RBAC model is used beyond authorizing specific
    APIs and is also used to authorize who can impersonate users. The focus of this
    chapter is going to be on the standard HTTP verb mappings.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 URL 映射到`resources`，你接下来的想法可能是`verbs`字段将是 HTTP 动词。但事实并非如此，Kubernetes 中没有`GET`动词。动词是由
    API 服务器中的对象模式定义的。好消息是，HTTP 动词和 RBAC 动词之间存在静态映射关系（[https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb)）。查看这个
    URL，你会注意到除了 HTTP 动词外，还有用于**模拟**的动词。这是因为 RBAC 模型不仅用于授权特定的 API，还用于授权谁可以模拟用户。本章的重点将是标准
    HTTP 动词的映射。
- en: 'The final component to identify is `apiGroups`. APIs will be in an API group
    and that group will be part of their URL. You can find the group by looking at
    the API documentation for the object you are looking to authorize or by using
    the `kubectl api-resources` command. For instance, to get `apiGroups` for the
    `Ingress` object, you could run:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要识别的组件是`apiGroups`。API 将属于一个 API 组，而该组将是其 URL 的一部分。你可以通过查看你要授权的对象的 API 文档或使用`kubectl
    api-resources`命令来找到该组。例如，要获取`Ingress`对象的`apiGroups`，你可以运行：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The second result gives you what you would see in the `apiVersion` of a YAML
    version of an `Ingress` object. Use this for `apiGroups`, but without the version
    number. To apply a `Role` to an `Ingress` object, the `apiGroups` would be `networking.k8s.io`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个结果展示了你在`Ingress`对象的 YAML 版本中的`apiVersion`。可以将其用于`apiGroups`，但不包括版本号。要将`Role`应用于`Ingress`对象，`apiGroups`应该是`networking.k8s.io`。
- en: The inconsistencies in the RBAC model can make debugging difficult, to say the
    least. The last lab in this chapter will walk through the debugging process and
    take much of the guesswork out of defining your rules.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 模型中的不一致性可能使调试变得困难，至少可以说是这样。本章的最后一个实验将带你逐步走过调试过程，并大大减少定义规则时的猜测。
- en: Now that we’ve defined the contents of a Role and how to define specific permissions,
    it’s important to note that Roles can be applied at both the namespace and cluster
    level.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了角色的内容以及如何定义特定权限，重要的是要注意，角色可以在命名空间和集群级别都进行应用。
- en: Roles versus ClusterRoles
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色与集群角色
- en: 'RBAC rules can be scoped either to specific namespaces or to the entire cluster.
    Taking the preceding example, if we defined it as a `ClusterRole` instead of a
    `Role`, and removed the namespace, we would have a `Role` that authorizes someone
    to get the details and logs of all pods across the cluster. This new `Role` could
    alternatively be used in individual namespaces to assign the permissions to the
    pods in a specific namespace:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 规则可以作用于特定的命名空间，或者作用于整个集群。以之前的示例为例，如果我们将其定义为 `ClusterRole` 而不是 `Role`，并移除命名空间，那么我们将拥有一个
    `Role`，它授权某人查看整个集群中所有 pod 的详细信息和日志。这个新的 `Role` 还可以在各个命名空间中使用，将权限分配给特定命名空间中的 pod：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Whether this permission is applied globally across a cluster or within the scope
    of a specific namespace depends on how it’s bound to the subjects it applies to.
    This will be covered in the *RoleBindings and ClusterRoleBindings* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将该权限应用于整个集群，还是仅在特定命名空间的范围内应用，取决于它与所适用的主体的绑定方式。这将在 *RoleBindings 和 ClusterRoleBindings*
    部分进行介绍。
- en: In addition to applying a set of rules across the cluster, `ClusterRoles` are
    used to apply rules to resources that aren’t mapped to a namespace, such as `PersistentVolume`
    and `StorageClass` objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在集群中应用一组规则外，`ClusterRoles` 还用于将规则应用于那些未映射到命名空间的资源，例如 `PersistentVolume` 和
    `StorageClass` 对象。
- en: After learning how a `Role` is defined, let’s explore the different ways `Roles`
    can be designed for specific purposes. In the next sections, we’ll look at different
    patterns for defining `Roles` and their application in a cluster.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何定义 `Role` 之后，接下来让我们探讨为特定目的设计 `Role` 的不同方式。在接下来的部分中，我们将看一下定义 `Role` 的不同模式及其在集群中的应用。
- en: Negative Roles
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负面角色
- en: 'One of the most common requests for authorization is “*Can I write a Role that
    lets me do everything EXCEPT xyz*?”. In RBAC, the answer is *NO*. RBAC requires
    either every resource to be allowed or specific resources and verbs to be enumerated.
    There are two reasons for this in RBAC:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的授权请求之一是“*我可以写一个角色，允许我做所有事情，除了 xyz*”。在 RBAC 中，答案是*不行*。RBAC 要求要么允许每个资源，要么列举出特定资源和动词。在
    RBAC 中有两个原因：
- en: '**Better security through simplicity**: Being able to enforce a rule that says
    *every Secret except this one* requires a much more complex evaluation engine
    than RBAC provides. The more complex an engine, the harder it is to test and validate,
    and the easier it is to break. A simpler engine is just simpler to code and keep
    secure.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过简化实现更好的安全性**：能够强制执行一个规则，表示*每个秘密都允许，除了这个*，需要一个比 RBAC 提供的更复杂的评估引擎。引擎越复杂，测试和验证就越难，且更容易出错。一个更简单的引擎在编写和保持安全性方面要简单得多。'
- en: '**Unintended consequences**: Allowing someone to do everything *except* xyz
    leaves the door open for issues in unintended ways as the cluster grows and new
    capabilities are added.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意外后果**：允许某人做所有事情*除了* xyz，会在集群增长并添加新功能时，以意想不到的方式打开出现问题的大门。'
- en: On the first point, an engine with this capability is difficult to build and
    maintain. It also makes the rules much harder to keep track of. To express this
    type of rule, you need to not only have authorization rules but also an order
    to those rules. For instance, to say *I want to allow everything except this Secret*,
    you would first need a rule that says *allow everything* and then a rule that
    says *deny this secret*. If you switch the rules to say *deny this secret* then
    *allow everything*, the first rule would be overridden. You could assign priorities
    to different rules, but that now makes it even more complex.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，具有这种能力的引擎既难以构建也难以维护。同时，它也使得规则的追踪变得更加困难。为了表达这种类型的规则，你不仅需要有授权规则，还需要对这些规则进行排序。例如，要表达*我想允许所有内容，除了这个秘密*，你首先需要一个规则来表示*允许一切*，然后再有一个规则表示*拒绝这个秘密*。如果你将规则顺序调换，变成*拒绝这个秘密*，再*允许一切*，那么第一个规则就会被覆盖。你可以为不同的规则分配优先级，但这会让它变得更加复杂。
- en: There are ways to implement this pattern, either by using a custom authorization
    webhook or by using a controller to dynamically generate RBAC `Role` objects.
    These should both be considered security anti-patterns and so won’t be covered
    in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这种模式，要么通过使用自定义授权 webhook，要么通过使用控制器动态生成 RBAC `Role` 对象。这两种方法都应被视为安全反模式，因此在本章中不会进行讲解。
- en: The second point deals with unintended consequences. It’s becoming more popular
    to support the provisioning of infrastructure that isn’t Kubernetes using the
    operator pattern, where a custom controller looks for new instances of a **CustomResourceDefinition**
    (**CRD**) to provision infrastructure such as databases.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点涉及到意外后果。支持使用操作员模式支持不是 Kubernetes 的基础设施的配置正变得越来越普遍，其中自定义控制器寻找新的 **CustomResourceDefinition**
    (**CRD**) 的实例来配置基础设施，例如数据库。
- en: Amazon Web Services publishes an operator for this purpose ([https://github.com/aws/aws-controllers-k8s](https://github.com/aws/aws-controllers-k8s)).
    These operators run in their own namespaces with administrative credentials for
    their cloud looking for new instances of their objects to provision resources.
    If you have a security model that allows everything “except…”, then once deployed,
    anyone in your cluster can provision cloud resources that have real costs and
    can create security holes. Enumerating your resources, from a security perspective,
    is an important part of knowing what is running and who has access.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊网络服务为此目的发布了一个操作员（[https://github.com/aws/aws-controllers-k8s](https://github.com/aws/aws-controllers-k8s)）。这些操作员在其自己的命名空间中以其云的管理凭据运行，以查找其对象的新实例以供资源配给。如果您的安全模型允许“除了…”之外的所有内容，那么一旦部署，您集群中的任何人都可以配置具有实际成本并可能创建安全漏洞的云资源。从安全角度来看，列举您的资源是了解正在运行的内容及其访问权限的重要部分。
- en: The trend in Kubernetes clusters is to provide more control over infrastructure
    outside of the cluster via the custom resource API. You can provision anything
    from VMs to additional nodes, to any kind of API-driven cloud infrastructure.
    There are other tools you can use besides RBAC to mitigate the risk of someone
    creating a resource they shouldn’t, but these should be secondary measures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群的趋势是通过自定义资源 API 在集群外部提供对基础设施的更多控制。您可以为任何类型的 API 驱动的云基础设施提供从虚拟机到额外节点的任何内容的资源配给。除了
    RBAC 之外，还有其他工具可以用来减轻某人可能创建不应有的资源的风险，但这些工具应作为辅助措施。
- en: So far, we’ve looked at how to create permissions for specific use cases. What
    happens if you need some flexibility to be able to define permissions more dynamically
    than the static lists we’re providing now? Next, we’ll discover how to use aggregated
    `ClusterRoles` to provide a dynamic approach to permission lists.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何为特定用例创建权限。如果您需要某些灵活性，以能够动态定义权限而不是我们现在提供的静态列表，那么接下来我们将发现如何使用聚合的
    `ClusterRoles` 提供权限列表的动态方法。
- en: Aggregated ClusterRoles
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合的 ClusterRoles
- en: '`ClusterRoles` can become confusing quickly and be difficult to maintain. It’s
    best to break them up into smaller `ClusterRoles` that can be combined as needed.
    Take the `admin` `ClusterRole`, which is designed to let someone do generally
    anything inside of a specific namespace. When we look at the `admin` `ClusterRole`,
    it enumerates just about every resource there is. You may think someone wrote
    this `ClusterRole` so that it would contain all those resources, but that would
    be really inefficient, and what happens as new resource types get added to Kubernetes?
    The `admin` `ClusterRole` is an aggregated `ClusterRole`. Take a look at the `ClusterRole`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRoles` 很快就会变得混乱并且难以维护。最好将它们拆分成更小的 `ClusterRoles`，以便根据需要进行组合。以 `admin`
    `ClusterRole` 为例，旨在允许某人在特定命名空间内执行几乎任何操作。当我们查看 `admin` `ClusterRole` 时，它列举了几乎所有的资源。你可能会认为有人编写了这个
    `ClusterRole`，以便它包含所有这些资源，但那样做效率非常低，而且当新的资源类型添加到 Kubernetes 时会发生什么呢？`admin` `ClusterRole`
    是一个聚合的 `ClusterRole`。看一看 `ClusterRole`：'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The key is the `aggregationRule` section. This section tells Kubernetes to
    combine the rules for all `ClusterRoles` where the `rbac.authorization.k8s.io/aggregate-to-admin`
    label is `true`. When a new CRD is created, an admin is not able to create instances
    of that CRD without adding a new `ClusterRole` that includes this label. To allow
    namespace admin users to create an instance of the new `myapi/superwidget` objects,
    create a new `ClusterRole`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于 `aggregationRule` 部分。此部分告诉 Kubernetes 将所有带有 `rbac.authorization.k8s.io/aggregate-to-admin`
    标签为 `true` 的 `ClusterRoles` 的规则结合起来。当创建新的 CRD 时，管理员无法创建该 CRD 的实例，除非添加包含此标签的新的
    `ClusterRole`。为允许命名空间管理员用户创建新的 `myapi/superwidget` 对象的实例，请创建一个新的 `ClusterRole`：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next time you look at the `admin` `ClusterRole`, it will include `myapi/superwidgets`.
    You can also reference this `ClusterRole` directly for more specific permissions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下次查看 `admin` `ClusterRole` 时，它将包括 `myapi/superwidgets`。您还可以直接引用此 `ClusterRole`
    获取更具体的权限。
- en: So far, we’ve focussed on creating permission lists via `Roles` and `ClusterRoles`.
    Next, we’ll work on assigning those permissions to users and services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于通过`Roles`和`ClusterRoles`创建权限列表。接下来，我们将研究如何将这些权限分配给用户和服务。
- en: RoleBindings and ClusterRoleBindings
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RoleBindings和ClusterRoleBindings
- en: 'Once a permission is defined, it needs to be assigned to something to enable
    it. “Something” can be a user, a group, or a service account. These options are
    referred to as **subjects**. Just as with `Roles` and `ClusterRoles`, a `RoleBinding`
    binds a `Role` or `ClusterRole` to a specific namespace, and a `ClusterRoleBinding`
    will apply a `ClusterRole` across the cluster. A binding can have many subjects
    but may only reference a single `Role` or `ClusterRole`. To assign the `pod-and-pod-logs-reader`
    `Role` created earlier in this chapter to a service account called `mysa` in the
    default namespace, a user named `podreader`, or anyone with the `podreaders` group,
    create a `RoleBinding`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了权限，就需要将其分配给某个对象才能启用。“某个对象”可以是用户、组或服务帐户。这些选项称为**主体**。与`Roles`和`ClusterRoles`一样，`RoleBinding`将`Role`或`ClusterRole`绑定到特定的命名空间，而`ClusterRoleBinding`则在整个集群中应用`ClusterRole`。一个绑定可以有多个主体，但只能引用一个`Role`或`ClusterRole`。为了将本章前面创建的`pod-and-pod-logs-reader`
    `Role`分配给默认命名空间中的服务帐户`mysa`、名为`podreader`的用户或任何属于`podreaders`组的人，可以创建一个`RoleBinding`：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding `RoleBinding` lists three different subjects:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`RoleBinding`列出了三个不同的主体：
- en: '`ServiceAccount`: Any service account in the cluster can be authorized to a
    `RoleBinding`. The namespace must be included since a `RoleBinding` can authorize
    a service account in any namespace, not just the one the `RoleBinding` is defined
    in.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceAccount`：集群中的任何服务帐户都可以被授权到`RoleBinding`。必须包括命名空间，因为`RoleBinding`可以在任何命名空间中授权服务帐户，而不仅仅是定义`RoleBinding`的命名空间。'
- en: '`User`: A user is asserted by the authentication process. Remember from *Chapter
    6*, *Integrating Authentication into Your Cluster*, that there are no objects
    in Kubernetes that represent users.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：用户是通过认证过程确认的。请记住，在*第六章*，*将认证集成到集群中*中提到，Kubernetes中没有表示用户的对象。'
- en: '`Group`: Just as with users, groups are asserted as part of the authentication
    process and have no object associated with them.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Group`：与用户一样，组是作为认证过程的一部分进行确认的，也没有与之关联的对象。'
- en: 'Finally, the `Role` we created earlier is referenced. In a similar fashion,
    to assign the same subjects the ability to read pods and their logs across the
    cluster, a `ClusterRoleBinding` can be created to reference the `cluster-pod-and-pod-logs-reader`
    `ClusterRole` created earlier in the chapter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，引用了我们之前创建的`Role`。以类似的方式，为了为相同的主体赋予跨集群读取pod及其日志的能力，可以创建一个`ClusterRoleBinding`来引用本章前面创建的`cluster-pod-and-pod-logs-reader`
    `ClusterRole`：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ClusterRoleBinding` is bound to the same subjects but is bound to a `ClusterRole`
    instead of a namespace-bound `Role`. Now, instead of being able to read pod details
    and `Pod/logs` in the default namespace, these users can read all pod details
    and `Pod/logs` in all namespaces.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRoleBinding`绑定到相同的主体，但绑定的是`ClusterRole`而不是命名空间绑定的`Role`。现在，这些用户可以读取所有命名空间中的所有pod详细信息和`Pod/logs`，而不仅仅是默认命名空间中的pod详细信息和`Pod/logs`。'
- en: Till now, the focus has been on combining a `Role` with a `RoleBinding` and
    a `ClusterRole` with a `ClusterRoleBinding`. If you want to define the same permissions
    that are scoped to multiple namespaces, you’ll want a way to do that without reproducing
    the same `Role` every time. Next, we’ll cover how to simplify `Role` management
    by combining `ClusterRoles` and `RoleBindings`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的重点一直是在将`Role`与`RoleBinding`和`ClusterRole`与`ClusterRoleBinding`结合。如果你想定义作用于多个命名空间的相同权限，你需要一种方法来做到这一点，而不必每次都重复创建相同的`Role`。接下来，我们将介绍如何通过结合`ClusterRoles`和`RoleBindings`来简化`Role`管理。
- en: Combining ClusterRoles and RoleBindings
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并ClusterRoles和RoleBindings
- en: 'We have a use case where a log aggregator wants to pull logs from pod in multiple
    namespaces, but not all namespaces. A `ClusterRoleBinding` is too broad. While
    the `Role` could be recreated in each namespace, this is inefficient and a maintenance
    headache. Instead, define a `ClusterRole` but reference it from a `RoleBinding`
    in the applicable namespaces. This allows the reuse of permission definitions
    while still applying those permissions to specific namespaces. In general, note
    the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用例，日志聚合器希望从多个命名空间的 pod 中提取日志，但并非所有命名空间都需要。这时`ClusterRoleBinding`过于宽泛。虽然可以在每个命名空间中重新创建`Role`，但这种做法效率低下且维护困难。相反，定义一个`ClusterRole`，并在适用的命名空间中通过`RoleBinding`引用它。这样可以重用权限定义，同时将这些权限应用到特定命名空间。通常，注意以下几点：
- en: '`ClusterRole` + `ClusterRoleBinding` = cluster-wide permission'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRole` + `ClusterRoleBinding` = 集群级别的权限'
- en: '`ClusterRole` + `RoleBinding` = namespace-specific permission'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRole` + `RoleBinding` = 命名空间特定权限'
- en: 'To apply our `ClusterRoleBinding` in a specific namespace, create a `Role`,
    referencing the `ClusterRole` instead of a namespaced `Role` object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在特定命名空间中应用我们的`ClusterRoleBinding`，需要创建一个`Role`，引用`ClusterRole`而不是命名空间特定的`Role`对象：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding `RoleBinding` lets us reuse the existing `ClusterRole`. This cuts
    down on the number of objects that need to be tracked in the cluster and makes
    it easier to update permissions across the cluster if the `ClusterRole` permissions
    need to change.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`RoleBinding`让我们可以重用现有的`ClusterRole`。这样减少了需要在集群中跟踪的对象数量，也便于在需要更改`ClusterRole`权限时更新集群中的权限。
- en: Having built our permissions and defined how to assign them, next, we’ll look
    at how to map enterprise identities into cluster policies.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了我们的权限并定义了如何分配之后，接下来我们将看看如何将企业身份映射到集群策略中。
- en: Mapping enterprise identities to Kubernetes to authorize access to resources
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将企业身份映射到 Kubernetes 中以授权访问资源
- en: 'One of the benefits of centralizing authentication is leveraging the enterprise’s
    existing identities instead of having to create new credentials that users who
    interact with your clusters need to remember. It’s important to know how to map
    your policies to these centralized users. In *Chapter 6*, *Integrating Authentication
    into Your Cluster*, you created a cluster and integrated it with an “enterprise
    **Active Directory**.” To finish the integration, the following `ClusterRoleBinding`
    was created:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 集中化身份验证的一个好处是利用企业现有的身份，而无需创建用户与集群交互时需要记住的新凭证。了解如何将策略映射到这些集中化用户非常重要。在*第六章*，*将身份验证集成到集群中*中，你创建了一个集群，并将其与“企业**Active
    Directory**”进行了集成。为了完成集成，创建了以下`ClusterRoleBinding`：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This binding allows all users that are members of the `cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com`
    group to have full cluster access. At the time, the focus was on authentication,
    so there weren’t many details provided as to why this binding was created.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绑定允许所有属于`cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com`组的用户拥有完整的集群访问权限。当时，重点是身份验证，因此没有提供关于为什么创建这个绑定的很多细节。
- en: 'What if we wanted to authorize our users directly? That way, we will have control
    over who has access to our cluster. Our RBAC `ClusterRoleBinding` would look different:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想直接授权给我们的用户怎么办？那样，我们就能控制谁可以访问我们的集群。我们的 RBAC `ClusterRoleBinding` 将会有所不同：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the same `ClusterRole` as before, this `ClusterRoleBinding` will assign
    the `cluster-admin` privileges only to my testing user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的`ClusterRole`，这个`ClusterRoleBinding`将只会赋予我的测试用户`cluster-admin`权限。
- en: The first issue to point out is that the user has the URL of our **OpenID Connect**
    issuer in front of the username. When OpenID Connect was first introduced, it
    was thought that Kubernetes would integrate with multiple identity providers and
    different types of identity providers, so the developers wanted you to be able
    to easily distinguish between users from different identity sources. For instance,
    `mmosley` in domain 1 is a different user than `mmosley` in domain 2\. To ensure
    that a user’s identity doesn’t collide with another user across identity providers,
    Kubernetes requires the identity provider’s issuer to be prepended to your username.
    This rule doesn’t apply if the username claim defined in your API server flags
    is `mail`. It also doesn’t apply if you’re using certificates or impersonation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要指出的问题是，用户的用户名前面有我们**OpenID Connect**发行者的 URL。当 OpenID Connect 最初被引入时，认为
    Kubernetes 会与多个身份提供者以及不同类型的身份提供者集成，因此开发者希望你能够轻松地区分来自不同身份源的用户。例如，域 1 中的 `mmosley`
    与域 2 中的 `mmosley` 是不同的用户。为了确保用户身份不会与跨身份提供者的其他用户冲突，Kubernetes 要求身份提供者的发行者 URL 被添加到用户名的前面。如果你在
    API 服务器标志中定义的用户名声明是 `mail`，则此规则不适用。如果你使用的是证书或模拟身份，也不适用。
- en: 'Beyond the inconsistent implementation requirements, this approach can cause
    problems in a few ways:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不一致的实现要求外，这种方法可能在几个方面引发问题：
- en: '**Changing your identity provider URL**: Today, you’re using an identity provider
    at one URL, but tomorrow you decide to move it. Now, you need to go through every
    `ClusterRoleBinding` and update them.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改身份提供者 URL**：今天，你正在使用某个身份提供者的一个 URL，但明天你决定更换它。现在，你需要遍历每个`ClusterRoleBinding`并更新它们。'
- en: '**Audits**: You can’t query for all `RoleBindings` associated with a user.
    You need to instead enumerate every binding.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：你无法查询与某个用户关联的所有 `RoleBindings`。你需要枚举每个绑定。'
- en: '**Large bindings**: Depending on how many users you have, your bindings can
    become quite large and difficult to track.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大规模绑定**：根据用户数量的不同，绑定可能变得非常庞大，难以追踪。'
- en: While there are tools you can use to help manage these issues, it’s much easier
    to associate your bindings with groups instead of individual users. You could
    use the `mail` attribute to avoid the URL prefix, but that is considered an anti-pattern
    and will result in equally difficult changes to your cluster if an email address
    changes for any reason.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有工具可以帮助你管理这些问题，但将绑定与组关联，而不是与单个用户关联，会更容易一些。你可以使用 `mail` 属性来避免 URL 前缀，但这被视为一种反模式，如果因为任何原因更改了电子邮件地址，将导致集群出现同样复杂的问题。
- en: So far in this chapter, we have learned how to define access policies and map
    those policies to enterprise users. Next, we need to determine how clusters will
    be divided into tenants.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何定义访问策略并将这些策略映射到企业用户。接下来，我们需要确定如何将集群划分为租户。
- en: Implementing namespace multi-tenancy
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现命名空间多租户
- en: 'Clusters deployed for multiple stakeholders, or tenants, should be divided
    up by namespace. This is the boundary that was designed in Kubernetes from the
    very beginning. When deploying namespaces, there are generally two `ClusterRoles`
    that are assigned to users in the namespace:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 部署给多个利益相关者或租户的集群应该按命名空间进行划分。这是 Kubernetes 从一开始就设计的边界。在部署命名空间时，通常会为命名空间中的用户分配两个
    `ClusterRoles`：
- en: '`admin`: This aggregated `ClusterRole` provides access to every verb and nearly
    every resource that ships with Kubernetes, making the `admin` user the ruler of
    their namespace. The exception to this is any namespace-scoped object that could
    affect the entire cluster, such as `ResourceQuotas`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin`：这个聚合型 `ClusterRole` 提供对 Kubernetes 附带的几乎所有资源和操作的访问权限，使得 `admin` 用户成为其命名空间的管理者。唯一的例外是任何可能影响整个集群的命名空间范围对象，例如
    `ResourceQuotas`。'
- en: '`edit`: Similar to `admin`, but without the ability to create RBAC `Roles`
    or `RoleBindings`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit`：与 `admin` 类似，但没有创建 RBAC `Roles` 或 `RoleBindings` 的权限。'
- en: It’s important to note that the `admin` `ClusterRole` can’t make changes to
    the namespace object by itself. Namespaces are cluster-wide resources, so they
    can only be assigned permissions via a `ClusterRoleBinding`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`admin` `ClusterRole` 本身无法对命名空间对象进行更改。命名空间是集群范围的资源，因此只能通过 `ClusterRoleBinding`
    来分配权限。
- en: 'Depending on your strategy for multi-tenancy, the `admin` `ClusterRole` may
    not be appropriate. The ability to generate RBAC `Role` and `RoleBinding` objects
    means that a namespace admin may grant themselves the ability to change resource
    quotas. This is where RBAC tends to fall apart and needs some additional options:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t grant access to Kubernetes**: Many cluster owners want to keep Kubernetes
    out of the hands of their users and limit their interaction with external CI/CD
    tools. This works well with microservices but begins to fall apart on multiple
    lines. First, more legacy applications being moved into Kubernetes means more
    legacy administrators needing to directly access their namespace. Second, if the
    Kubernetes team keeps users out of the clusters, they are now responsible. The
    people who own Kubernetes may not want to be the reason things aren’t happening
    the way application owners want them to and, often, the application owners want
    to be able to control their own infrastructure to ensure they can handle any situation
    that impacts their own performance.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Treat access as privileged**: Most enterprises require a privileged user
    to access infrastructure. This is typically done using a privileged access model
    where an admin has a separate account that needs to be “checked out” in order
    to use it and is only authorized at certain times, as approved by a “change board”
    or process. The use of these accounts is closely monitored. This is a good approach
    if you already have a system in place, especially one that integrates with your
    enterprise’s central authentication system.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Give each tenant a cluster**: This model moves multi-tenancy from the cluster
    to the infrastructure layer. You haven’t eliminated the problem, only moved where
    it is addressed. This can lead to sprawl that becomes unmanageable and costs can
    skyrocket depending on how you are implementing Kubernetes. In *Chapter 9*, *Building
    Multitenant Clusters with vClusters*, we’ll explore how we can give each tenant
    its own cluster without having to worry about the sprawl as much.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admission controllers**: These augment RBAC by limiting which objects can
    be created. For instance, an admission controller can decide to block an RBAC
    policy from being created, even if RBAC explicitly allows it. This topic will
    be covered in *Chapter 11*, *Extending Security Using Open Policy Agent*.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to authorizing access to namespaces and resources, a multi-tenant
    solution needs to know how to provision tenants. This topic will be covered in
    the final chapters – *Chapter 18*, *Provisioning a Multitenant Platform*, and
    *Chapter 19*, *Building a Developer Portal*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a strategy for implementing authorization policies, we’ll need
    a way to debug those policies as we create them and also to know when those policies
    are violated. Kubernetes provides an audit capability that will be the focus of
    the next section, where we will add the audit log to our KinD cluster and debug
    the implementation of RBAC policies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes auditing
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes audit log is where you track what is happening in your cluster
    from an API perspective. It’s in JSON format, which makes reading it directly
    more difficult, but makes it much easier to parse using tools such as OpenSearch.
    In *Chapter 15*, *Managing Clusters and Workloads*, we will cover how to create
    a full logging system using the **OpenSearch** stack.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Creating an audit policy
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A policy file is used to control what events are recorded and where to store
    the logs, which can be a standard log file or a webhook. We have included an example
    audit policy in the `chapter7` directory of the GitHub repository, and we will
    apply it to the KinD cluster that we have been using throughout the book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: An **audit policy** is a collection of rules that tell the API server which
    API calls to log and how. When Kubernetes parses the policy file, all rules are
    applied in order and only the initial matching policy event will be applied. If
    you have more than one rule for a certain event, you may not receive the expected
    data in your log files. For this reason, you need to be careful that your events
    are created correctly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Policies use the `audit.k8s.io` API and the manifest kind of `Policy`. The
    following example shows the beginning of a policy file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While a policy file may look like a standard Kubernetes manifest, you do not
    apply it using `kubectl`. A policy file is used with the `--audit-policy-file`
    API flag on the API server(s). This will be explained in the *Enabling auditing
    on a cluster* section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: To understand the rule and what it will log, we will go through each section
    in detail.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section of the rule is `level`, which determines the type of information
    that will be logged for the event. There are four levels that can be assigned
    to events:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.1 – Kubernetes auditing levels ](img/B21165_Table_07_01.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'Table 7.1: Kubernetes auditing levels'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The `userGroups`, `verbs`, and `resources` values tell the API server the object
    and action that will trigger the auditing event. In this example, only requests
    from `system:nodes` that attempt an action of `update` or `patch` on a `node/status`
    or `pod/status` on the `core` API will create an event.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '`omitStages` tells the API server to skip any logging events during a stage,
    which helps you limit the amount of data that is logged. There are four stages
    that an API request goes through:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.2 – Auditing stages ](img/B21165_Table_07_02.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'Table 7.2: Auditing stages'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have set the event to ignore the `RequestReceived` event,
    which tells the API server not to log any data for the incoming API request.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Every organization has its own auditing policy, and policy files can become
    long and complex. Don’t be afraid to set up a policy that logs everything until
    you get a handle on the types of events that you can create. Logging everything
    is not a good practice since the log files become very large. Even when pushing
    logs into an external system, like **OpenSearch**, there’s still a cost in processing
    and management. Fine-tuning an audit policy is a skill that is learned over time
    and as you learn more about the API server, you will start to learn what events
    are most valuable to audit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Policy files are just the start of enabling cluster auditing, and now that we
    have an understanding of the policy file, let’s explain how to enable auditing
    on a cluster.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Enabling auditing on a cluster
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enabling auditing is specific to each distribution of Kubernetes. In this section,
    we will enable the audit log in KinD to understand the low-level steps. As a quick
    refresher, the finished product of the last chapter was a KinD cluster with impersonation
    enabled (instead of directly integrating with OpenID Connect). The rest of the
    steps and examples in this chapter assume this cluster is being used. Start with
    a fresh cluster and deploy **OpenUnison** with impersonation from *Chapter 6*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we’re going to configure the API server to send audit log data to a file.
    This is more complex than setting a switch because kubeadm, the installer that
    KinD is built on, runs the API server as a static pod(s). The API server is a
    container inside of Kubernetes! This means that in order for us to tell the API
    server where to write log data to, we first have to have storage to write it to
    and then configure the API server’s pod to use that location as a volume. We’re
    going to walk through this process manually to give you experience with modifying
    the API server’s context.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'You can follow the steps in this section manually or you can execute the included
    script, `enable-auditing.sh`, in the `chapter7` directory of the GitHub repository:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the example audit policy from the `chapter7` directory to the API
    server:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create the directories to store the audit log and policy configuration
    on the API server. We will `exec` into the container since we need to modify the
    API server file in the next step:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, you have the audit policy on the API server and you can enable
    the API options to use the file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: On the API server, edit the `kubeadm` configuration file (you will need to install
    an editor such as vi by running `apt-get update; apt-get install vim`), `/etc/kubernetes/manifests/kube-apiserver.yaml`,
    which is the same file that we updated to enable OpenID Connect. To enable auditing,
    we need to add three values.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important to note that many Kubernetes clusters may only require the file
    and the API options. We need the second and third steps since we are using a KinD
    cluster for our testing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add bold command-line flags for the API server that enable the audit
    logs. Along with the policy file, we can add options to control the log file rotation,
    retention, and maximum size:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the option is pointing to the policy file that you copied over in
    the previous step.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the bold directories that store the policy configuration and the
    resulting logs to the `volumeMounts` section:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, add the bold `hostPath` configurations to the `volumes` section so
    that Kubernetes knows where to mount the local paths:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save and exit the file.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like all API option changes, you need to restart the API server for the changes
    to take effect; however, KinD will detect that the file has changed and restart
    the API server’s pod automatically.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit the attached shell and check the pods in the `kube-system` namespace:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The API server is highlighted to have been running for only 47 seconds, showing
    that it successfully restarted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Having verified that the API server is running, let’s look at the audit log
    to verify that it’s working correctly. To check the log, you can use `docker exec`
    to tail `audit.log`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command generates the following log data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is quite a bit of information in this JSON, and it would be challenging
    to find a specific event by looking at a log file directly. Luckily, now that
    you have auditing enabled, you can forward events to a central logging server.
    We will do this in *Chapter 15*, *Monitoring Clusters and Workloads with Prometheus*,
    where we will deploy an **EFK** stack.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have auditing enabled, the next step is to practice debugging RBAC
    policies.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Using audit2rbac to debug policies
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a tool called `audit2rbac` that can reverse-engineer errors in the
    audit log into RBAC policy objects. In this section, we’ll use this tool to generate
    an RBAC policy after discovering that one of our users can’t perform an action
    they need to be able to do. This is a typical RBAC debugging process and learning
    how to use this tool can save you hours trying to isolate RBAC issues:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, a generic RBAC policy was created to allow all members
    of the `cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com` group to be administrators
    in our cluster. If you’re logged into OpenUnison, log out.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, log in again with the username `jjackson` and the password `start123`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on **Sign In**. Once you’re logged in, go to the dashboard. Just
    as when OpenUnison was first deployed, there won’t be any namespaces or other
    information because the RBAC policy for cluster administrators doesn’t apply anymore.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, copy your `kubectl` configuration from the token screen, making sure to
    paste it into a window that isn’t your main KinD terminal so you do not overwrite
    your master configuration.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your tokens are set, attempt to create a namespace called `not-going-to-work`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There’s enough information here to reverse-engineer an RBAC policy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to eliminate this error message, create a `ClusterRole` with a resource
    for `"namespaces"`, `apiGroups` set to `""`, and a verb of `"create"` using your
    KinD administrative user:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, create a `ClusterRoleBinding` for the user and this `ClusterRole`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the `ClusterRole` and `ClusterRoleBinding` are created, try running the
    command again, and it will work:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Unfortunately, this is not likely how most RBAC debugging will go. Most of the
    time, debugging RBAC will not be this clear or simple. Typically, debugging RBAC
    means getting unexpected error messages between systems. For instance, if you’re
    deploying the `kube-prometheus` project for monitoring, you’ll generally want
    to monitor by `Service` objects, not by explicitly naming Pods. In order to do
    this, the Prometheus `ServiceAccount` needs to be able to list the `Service` objects
    in the namespace of the service you want to monitor. Prometheus won’t tell you
    this needs to happen; you just won’t see your services listed. A better way to
    debug is to use a tool that knows how to read the audit log and can reverse-engineer
    a set of roles and bindings based on the failures in the log.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The `audit2rbac` tool is the best way to do this. It will read the audit log
    and give you a set of policies that will work. It may not be the exact policy
    that’s needed, but it will provide a good starting point. Let’s try it out:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'First, attach a shell to the `control-plane` container of your cluster and
    download the tool from GitHub ([https://github.com/liggitt/audit2rbac/releases](https://github.com/liggitt/audit2rbac/releases)):'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before using the tool, make sure to close the browser with the Kubernetes dashboard
    in it to avoid polluting the logs. Also, remove the `cluster-create-ns` `ClusterRole`
    and `ClusterRoleBinding` created previously. Finally, try creating the `still-not-going-to-work`
    namespace:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, use the `audit2rbac` tool to look for any failures for your test user:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command generated a policy that will allow the test user to create namespaces.
    This becomes an anti-pattern, though, of explicitly authorizing access to users.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to better leverage this policy, it would be better to use our group:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The major change is highlighted. Instead of referencing the user directly, the
    `ClusterRoleBinding` is now referencing the `cn=k8s-create-ns,ou=Groups,DC=domain,DC=com`
    group so that any member of that group can now create namespaces.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter’s focus was on **RBAC** policy creation and debugging. We explored
    how Kubernetes defines authorization policies and how it applies those policies
    to enterprise users. We also looked at how these policies can be used to enable
    multi-tenancy in your cluster. Finally, we enabled the audit log in our KinD cluster
    and learned how to use the `audit2rbac` tool to debug RBAC issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes’ built-in RBAC policy management objects lets you enable access
    that’s needed for operational and development tasks in your clusters. Knowing
    how to design policies can help limit the impact of issues, providing the confidence
    to let users do more on their own.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 8*, *Managing Secrets*, we’ll learn how Kubernetes
    manages secret data and how you should integrate external secrets into your clusters
    using HashiCorp Vault and the External Secrets Operator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: True or false – ABAC is the preferred method of authorizing access to Kubernetes
    clusters.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three components of a `Role`?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subject, noun, and verb
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resource, action, and group
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`apiGroups`, resources, and verbs'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Group, resource, and sub-resource
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you go to look up resource information?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes API reference
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The library
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tutorials and blog posts
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you reuse `Roles` across namespaces?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can’t; you need to re-create them.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `ClusterRole` and reference it in each namespace as a `RoleBinding`.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reference the `Role` in one namespace with the `RoleBindings` of other namespaces.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How should bindings reference users?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Directly, listing every user.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RoleBindings` should only reference service accounts.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only `ClusterRoleBindings` should reference users.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever possible, `RoleBindings` and `ClusterRoleBindings` should reference
    groups.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – RBAC can be used to authorize access to everything except for
    one resource.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false – RBAC is the only method of authorization in Kubernetes.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'a: false'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: Resource, action, and group'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a: Kubernetes API reference'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: Define a `ClusterRole` and reference it in each namespace as a `RoleBinding`.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: Whenever possible, `RoleBindings` and `ClusterRoleBindings` should reference
    groups.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: False'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: False'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our book’s Discord space
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code965214276169525265.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
