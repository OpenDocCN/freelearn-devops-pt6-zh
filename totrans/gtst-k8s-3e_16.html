<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 1: Introduction to Kubernetes
</h1>
                </header>
            
            <article>
                
<ol>
<li>Minikube, Google Cloud Platform, and Azure Kubernetes Service.</li>
<li>Virtual Machines, FreeBSD Jails, LXC (Linux Containers), Open VZ, and Solaris Containers.</li>
<li>Memory, filesystem CPU, threads, processes, namespaces, and memory interface files.</li>
<li>It allows companies to ship incremental updates to software. It also allows packaging of software from a developer laptop all of the way to production.</li>
<li>An account and billing set up. You'll also need to enable the API on GCE.</li>
<li><kbd>kube-apiserver</kbd>, <kbd>etcd</kbd>, <kbd>kube-scheduler</kbd>, <kbd>kube-controller-manager</kbd>, and <kbd>cloud-controller-manager</kbd>.</li>
<li><kbd>kops</kbd>, <kbd>kubespray</kbd>, <kbd>kubeadm</kbd>, and <kbd>bootkube</kbd>.</li>
<li><kbd>kubeadm</kbd>.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 2: Building a Foundation with Core Kubernetes Constructs</h1>
                </header>
            
            <article>
                
<ol>
<li>HTTP, TCP, and application-level health checks</li>
<li>ReplicaSet</li>
<li>Ecosystem, interface, governance, application, and nucleus</li>
</ol>
<ol start="4">
<li>Calico and Flannel</li>
<li><kbd>rkt</kbd>, <kbd>kata</kbd>, <kbd>frakti</kbd>, <kbd>containerd</kbd>, and <kbd>runv</kbd></li>
<li>Cluster control plane, cluster state, and cluster nodes</li>
<li>Equality-based selectors</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 3: Working with Networking, Load Balancers, and Ingress</h1>
                </header>
            
            <article>
                
<ol>
<li>Communication is governed between pods, not containers. Pod communication to service is provided by the services object. K8s doesn't use NAT to communicate between containers.</li>
<li>Network address translation</li>
<li>CNI plugins that use the overlay network, or the <kbd>kubenet</kbd> plugin, which uses the bridge and host-local features.</li>
<li>Canal, Calico, Flannel, and Kube-router.</li>
<li>Pods.</li>
<li>Userspace, iptables, and ipvs.</li>
<li>Virtual IPs, service proxies, and multi-port.</li>
<li>The spec.</li>
<li>GCE, nginx, Kong, Traefik, and HAProxy.</li>
<li>Use namespaces, RBAC, container permissions, ingress rules, and clear network policing.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 4: Implementing Reliable, Container-Native Applications</h1>
                </header>
            
            <article>
                
<ol>
<li>The <span>four use cases for Kubernetes deployments are as follows:</span>
<ul>
<li>Roll out a ReplicaSet</li>
<li>Update the state of a set of pods</li>
<li>Roll back to an earlier version of a deployment</li>
<li>Scale up to accommodate cluster load</li>
</ul>
</li>
<li>The selector.</li>
</ol>
<ol start="3">
<li>The record flag, <kbd>--record</kbd>.</li>
<li><kbd>ReplicationControllers</kbd>.</li>
<li>Horizontal pod autoscaling.</li>
<li>Scheduled jobs.</li>
<li>DaemonSet simply define a pod to run on every single node in the cluster or a defined subset of those nodes. This can be very useful for a number of production–related activities, such as monitoring and logging agents, security agents, and filesystem daemons.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 5: Exploring Kubernetes Storage Concepts</h1>
                </header>
            
            <article>
                
<ol>
<li>Persistent, temporary disks, cloud volumes, <kbd>emptyDir</kbd>, and <kbd>nfs</kbd></li>
<li><kbd>emptydir</kbd></li>
<li>EBS volumes in AWS and disk storage on Azure</li>
<li>Different application performance or durability requirements.</li>
<li>Binding, using, reclaiming, and expanding.</li>
<li>Persistent volume claim.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 6: Application Updates, Gradual Rollouts, and Autoscaling</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>kubectl scale --replicas</kbd></li>
<li><kbd>rolling-update</kbd></li>
<li>ClientIP</li>
<li>Horizontal pod autoscaling</li>
<li>CPU and memory usage settings at minimum and maximum values</li>
<li>Helm</li>
<li>A chart</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 7: Designing for Continuous Integration and Delivery</h1>
                </header>
            
            <article>
                
<ol>
<li>Node.js</li>
<li>Jenkins</li>
<li>Helm charts</li>
<li>Persistent volume</li>
<li>Installing the Jenkins plugin</li>
<li>A ReplicationController</li>
<li>npm</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 8: Monitoring and Logging</h1>
                </header>
            
            <article>
                
<ol>
<li>cAdvisor and Heapster.</li>
<li>Kube-system.</li>
<li>Grafana.</li>
<li>A collector.</li>
<li>Stackdriver.</li>
<li>Good reasons to use Prometheus are as follows:
<ul>
<li><strong>Simple to operate</strong>: It was built to run as individual servers using local storage for reliability.</li>
<li><strong>It's precise</strong>: You can use a query language similar to JQL, DDL, DCL, or SQL queries to define alerts and provide a multi-dimensional view of status.</li>
<li><strong>Lots of libraries</strong>: You can use more than ten languages and numerous client libraries in order to introspect your services and software.</li>
<li><strong>Efficient</strong>: With data stored in an efficient, custom format both in memory and on disk, you can scale out easily with sharding and federation, creating a strong platform from which to issue powerful queries that can construct powerful data models and ad hoc tables, graphs, and alerts.</li>
</ul>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 10: Designing for High Availability and Scalability</h1>
                </header>
            
            <article>
                
<ol>
<li>Availability, responsivity, and durability.</li>
<li>Uptime is the measure of time a given system, application, network, or other logical and physical object has been <em>up</em> and available to be used by the appropriate end user.</li>
<li>The five 9s of availability.</li>
<li>It means that it fails <em>gracefully</em>.</li>
<li><strong>Google Kubernetes Engine</strong> (<strong>GKE</strong>).</li>
<li>A set of master nodes that has the Kubernetes control plane and the <kbd>etcd</kbd> servers collocated.</li>
<li>The Workloads API.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 11: Kubernetes SIGs, Incubation Projects, and the CNCF</h1>
                </header>
            
            <article>
                
<ol>
<li>Kubernetes and Prometheus.</li>
<li>Linkerd, rkt, CNI, TUF, Vitess, CoreDNS, Jaeger, Envoy.</li>
<li>Spiffe, Spire, Open Policy Agent, Telepresence, Harbor, TiKV, Cortex, and Buildpacks. See more here: <a href="https://www.cncf.io/sandbox-projects/">https://www.cncf.io/sandbox-projects/</a>.</li>
<li>Committees are there to define meta-standards and address community-wide issues.</li>
<li>It's a great way to understand the core concepts and inner workings of Kubernetes. It's a fun way to meet other motivated, smart people. Lastly, Kubernetes, at its essence, is a community project, and relies on the contributions of its members and users.</li>
<li>SSH keys and SSL connectivity.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 12: Cluster Federation and Multi-Tenancy</h1>
                </header>
            
            <article>
                
<ol>
<li style="font-weight: 400">Using federation, we can run multiple Kubernetes clusters on-premise and in one or more public cloud providers and manage applications utilizing the entire set of our organizational resources.</li>
<li style="font-weight: 400">Federation allows you increase the availability and tenancy capabilities of your Kubernetes clusters.</li>
<li style="font-weight: 400">Resource synchronization across clusters and multi-cluster service discovery.</li>
<li style="font-weight: 400">Kubefed.</li>
<li style="font-weight: 400">Federation-controller-manager and the federation-apiserver.</li>
<li style="font-weight: 400">HPAs will act in a similar fashion to normal HPAs, with the same functionality and same API-based compatibility—only, with federation, the management of pods will traverse your clusters.</li>
<li style="font-weight: 400">Deployments, ReplicaSets, Events, ConfigMaps, DaemonSets, Ingress, Namespaces, Secrets, and Services.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 13: Cluster Authentication, Authorization, and Container Security</h1>
                </header>
            
            <article>
                
<ol>
<li>Container repository or registry</li>
<li>Any three from the following: Node, ABAC, RBAC, Webhook</li>
<li>Privileged</li>
<li><kbd>kubectl get secrets</kbd></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 14: Hardening Kubernetes</h1>
                </header>
            
            <article>
                
<ol>
<li>Data encryption, secrets, service discovery, compliance, RBAC, system event tracking, and trend deviation alerts</li>
<li class="mce-root">Stackdriver, Sysdig, Datadog, and Sensu</li>
<li class="mce-root">Terraform or CloudFormation and Ansible, Chef, or Puppet</li>
</ol>
<ol start="4">
<li class="mce-root">The principle of least privilege</li>
<li class="mce-root">CPU, memory, and limits</li>
<li class="mce-root">Maximum and minimum</li>
<li class="mce-root">Transport Layer Security (TLS)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 15: Kubernetes Infrastructure Management</h1>
                </header>
            
            <article>
                
<ol>
<li style="font-weight: 400"><kbd>kubeadm-dind</kbd>, Minikube, and Ubuntu on LXD.</li>
<li style="font-weight: 400">Google Kubernetes Engine, Amazon Elastic Container Services, Azure Kubernetes Service, and Stackpoint.io.</li>
<li style="font-weight: 400">Logging, Authentication, Authorization, and Linux System Parameters.</li>
<li style="font-weight: 400"><span>The commands to upgrade each of the major CSPs hosted Kubernetes clusters are as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>az aks upgrade --name &lt;CLUSTER_NAME&gt; --resource-group &lt;RESOURCE_GROUP&gt; --kubernetes-version &lt;VERSION&gt; <br/><br/>gcloud container clusters upgrade &lt;CLUSTER_NAME&gt;</strong></pre>
<ol start="5">
<li style="font-weight: 400">Google Compute Platform, with EKS</li>
<li style="font-weight: 400"><kbd>kubectl drain &lt;node&gt;</kbd></li>
<li style="font-weight: 400"><kbd>kubectl uncordon &lt;node&gt;</kbd></li>
</ol>


            </article>

            
        </section>
    </div>



  </body></html>