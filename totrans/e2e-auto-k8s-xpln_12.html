<html><head></head><body>
		<div id="_idContainer110">
			<h1 id="_idParaDest-145"><em class="italic"><a id="_idTextAnchor144"/>Chapter 9</em>: Using Helm, Kustomize, and KubeVela</h1>
			<p>This chapter concentrates mainly on configuration management for bespoke applications. The Kubernetes configuration for bespoke applications includes deployment, service, ingress, secret, configmaps, tags needed for governance, cross-cutting concerns, application security context, and other dependencies. Managing these configurations requires carefully choosing patterns and tools that fit the use case. Also, we must keep reuse, team collaboration, and scalability in mind. In the previous chapter, we lightly touched on a few tools such as Helm, Kustomize, and KubeVela for application configuration management. This chapter will be an opportunity to explore these tools in more detail.</p>
			<p>The following topics are covered in the chapter:</p>
			<ul>
				<li>Application configuration management capabilities</li>
				<li>Using Helm for application deployment</li>
				<li>Hands-on chart development</li>
				<li>Customizing configurations with Kustomize</li>
				<li>Deploying application workloads with KubeVela </li>
			</ul>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Application configuration management capabilities</h1>
			<p>Operating an application successfully in the Kubernetes environment requires a few capabilities from the perspective of configuration management. Here is a list of critical configuration management <a id="_idIndexMarker507"/>capabilities:</p>
			<ul>
				<li><strong class="bold">Packaging</strong>: As discussed several times, deploying an application into Kubernetes involves configuring <a id="_idIndexMarker508"/>multiple resources. It requires a capability where we can package all these resources into a single bundle.</li>
				<li><strong class="bold">Life cycle management</strong>: An application and all its dependencies must be executed into the cluster as a single <a id="_idIndexMarker509"/>deployment supporting the required release management constructs such as rollout, rollback, version management, and blue-green deployment.</li>
				<li><strong class="bold">Application discovery</strong>: This is a capability that is required for day-to-day operations. It will enable any discovery<a id="_idIndexMarker510"/> tools to dashboard a list of applications deployed, their version, and dependencies.</li>
				<li><strong class="bold">Application description customization</strong>: Not all environments will hold the same configuration. For<a id="_idIndexMarker511"/> example, the replication count in a staging environment could be one, while in production, we may set up horizontal Pod scaling. The capability is also required when we want to inject dependencies enabling segregation of concerns.</li>
			</ul>
			<p>Let’s explore the tools available for application configuration management, keeping the capabilities in mind. The following section will deep dive into Helm, our first tool to explore.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Using Helm for application deployment</h1>
			<p>Helm is one of the popular<a id="_idIndexMarker512"/> configuration management tools in the Kubernetes ecosystem. It came into existence as early as 2015. It has come a long way in evolving itself and solving<a id="_idIndexMarker513"/> all the bottlenecks. Being a <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>)-graduated project shows its maturity, production readiness, and value. Here are three key concepts of Helm:</p>
			<ul>
				<li><strong class="bold">Charts</strong>: Charts are the basic <a id="_idIndexMarker514"/>units of applications in Helm. A chart is nothing but the bundled package of an application with all its dependencies.</li>
				<li><strong class="bold">Repository</strong>: A bundled chart requires a consistent way of storage to distribute reliably, and repositories <a id="_idIndexMarker515"/>support this requirement. While open source applications can use a public repository, private repositories can be used for proprietary applications. Starting from Helm v3.8.0, any <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>)-compliant<a id="_idIndexMarker516"/> repository will support Helm. This means that most container registries support Helm packages as well.</li>
				<li><strong class="bold">Release</strong>: This is an instance of the <a id="_idIndexMarker517"/>chart running in the cluster. When we install a chart for the first time, it creates a new release version. Any update will be an increment in the release version. The construct enables release management capabilities such as rollout, rollback, and blue-green deployment.</li>
			</ul>
			<p>Using Helm requires a client-side <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) setup. In a macOS operating system, use <strong class="source-inline">brew</strong> to install the CLI, while<a id="_idIndexMarker518"/> the <strong class="source-inline">choco</strong> installer can be used for Windows. The following code snippet shows how to install the CLI on either of these operating systems:</p>
			<pre class="source-code"># Helm install macOS</pre>
			<pre class="source-code">brew install Helm</pre>
			<pre class="source-code"># Helm install Windows</pre>
			<pre class="source-code">choco install kubernetes-helm</pre>
			<p>For more<a id="_idIndexMarker519"/> installation options, visit <a href="https://helm.sh/docs/intro/install/">https://helm.sh/docs/intro/install/</a>. We will explore Helm in two parts—the first part will cover working with an existing chart, and new chart development will be covered in the second part.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Working with an existing chart</h2>
			<p>Working with an existing chart can be<a id="_idIndexMarker520"/> categorized into repository management, release management, and cluster discovery. Here are a few repository management commands:</p>
			<pre class="source-code"># Add a repo (Add bitnami repo to your local repo list)</pre>
			<pre class="source-code">helm repo add bitnami https://charts.bitnami.com/bitnami</pre>
			<pre class="source-code"># For private repository, use additional authentication flags</pre>
			<pre class="source-code"># To view the list of possible authentication flags</pre>
			<pre class="source-code">helm repo add --help</pre>
			<pre class="source-code"># Update the charts in all the added repo's</pre>
			<pre class="source-code">helm repo update</pre>
			<pre class="source-code"># Update the charts in a specific repo.</pre>
			<pre class="source-code">helm repo update bitnami</pre>
			<pre class="source-code"># Search for charts with the given name within the added repo</pre>
			<pre class="source-code">helm search repo wordpress</pre>
			<pre class="source-code"># Search charts in ArtifactHub, a famous open-source repo  </pre>
			<pre class="source-code">helm search hub wordpress</pre>
			<pre class="source-code">#List all the repositories added</pre>
			<pre class="source-code">helm repo list</pre>
			<p>The preceding repository management commands are good enough for our day-to-day repository operations. Next, we will look at a few release management Helm commands, as follows:</p>
			<pre class="source-code"># Install a chart</pre>
			<pre class="source-code"># Format</pre>
			<pre class="source-code">helm install &lt;release-name&gt; &lt;chart-name&gt;</pre>
			<pre class="source-code"># Example</pre>
			<pre class="source-code">helm install redis bitnami/redis</pre>
			<pre class="source-code"># Each chart will support a list of variables to be set</pre>
			<pre class="source-code"># Variables can be hierarchical. For example, the 'enabled' flag is under the 'auth' hierarchy in the bitnami/redis chart.</pre>
			<pre class="source-code">helm install redis bitnami/redis --set auth.enabled=false</pre>
			<pre class="source-code"># Install with a value set in the values file</pre>
			<pre class="source-code">helm install redis bitnami/redis -f values.yaml</pre>
			<pre class="source-code"># If the same variable is present in both the command line set and value file, the command line set takes precedence. </pre>
			<pre class="source-code">helm install redis bitnami/redis -f values.yaml --set auth.enabled=false</pre>
			<pre class="source-code"># Update a release</pre>
			<pre class="source-code"># Format</pre>
			<pre class="source-code">helm upgrade &lt;release-name&gt; &lt;chart-name&gt;</pre>
			<pre class="source-code"># Example</pre>
			<pre class="source-code">helm upgrade redis bitnami/redis -f values.yaml --set auth.enabled=true</pre>
			<pre class="source-code"># Roll back a release </pre>
			<pre class="source-code"># Format</pre>
			<pre class="source-code">helm rollback &lt;release-name&gt; &lt;release&gt;</pre>
			<pre class="source-code"># Example, roll back redis to the first release version </pre>
			<pre class="source-code">helm rollback redis 1</pre>
			<pre class="source-code"># Uninstall format</pre>
			<pre class="source-code">helm uninstall &lt;release-name&gt;</pre>
			<pre class="source-code"># Uninstall redis release </pre>
			<pre class="source-code">helm uninstall redis</pre>
			<p>The preceding commands <a id="_idIndexMarker521"/>are some frequently used release management commands. The following snippet will cover a couple of cluster discovery commands:</p>
			<pre class="source-code"># List all the Helm releases in the target cluster</pre>
			<pre class="source-code">helm list</pre>
			<pre class="source-code"># Find the status of a release named redis</pre>
			<pre class="source-code">helm status redis</pre>
			<p>It’s time to explore new chart development through a step-by-step, hands-on example.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Hands-on chart development</h1>
			<p>Helm charts are nothing but a set of configuration templates with variable placeholders in the templates. These placeholders can be replaced with values when templates are rendered <a id="_idIndexMarker522"/>for installation. Helm has a powerful <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) providing a wide range of <a id="_idIndexMarker523"/>constructs for variable replacement. We will look at some frequently used constructs to learn chart development in the upcoming sections.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Chart generation</h2>
			<p>A Helm chart bundle <a id="_idIndexMarker524"/>has a set of organized files and folders. Either we need to understand the structure to develop it from scratch or we can use the generator. In the hands-on example, we will use the generator to create a chart named <strong class="source-inline">hello-world</strong> (<strong class="source-inline">helm create &lt;chart-name&gt;</strong>), as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B17830_09_01.jpg" alt="Figure 9.1 – Creating a chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Creating a chart</p>
			<p>Let’s look at the use of each file, as follows:</p>
			<ul>
				<li><strong class="source-inline">Chart.yaml</strong>: This is <a id="_idIndexMarker525"/>a file that holds a description for the chart. It contains information such as supported Helm version, chart version, application version, application name, description, other dependent charts, maintainers, and so on. It also has an attribute called <strong class="source-inline">type</strong> that holds the value of either <strong class="source-inline">application</strong> or <strong class="source-inline">library</strong>. <strong class="source-inline">application</strong> refers to the fact that we are packing a Kubernetes application, and <strong class="source-inline">library</strong> means that the chart contains utility functions for reuse.</li>
				<li><strong class="source-inline">charts</strong> folder: This is a folder that can hold a list of dependent sub-charts. We can use sub-charts for many reasons. Dividing an extensive application into small modules with a sub-chart for each module is one way to use it. Another way could be to use it as a packaging mechanism for application dependencies such as a database. We could also use it as a holder of reusable functions that can be used as a shared library. An important thing to note here is that sub-charts can be<a id="_idIndexMarker526"/> independently deployed, meaning they cannot explicitly refer to the parent, but a parent can override values of sub-chart templates when required. </li>
				<li><strong class="source-inline">values.yaml</strong>: This <strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>) file holds values that need to<a id="_idIndexMarker527"/> be replaced when templates are rendered. We can override this file with a new file through the CLI—for example, <strong class="source-inline">helm upgrade redis-install-1 bitnami/redis -f values.yaml</strong>. Also, we can use the <strong class="source-inline">set</strong> flag in the CLI to override a specific value.</li>
				<li><strong class="source-inline">template</strong> folder: <strong class="source-inline">NOTES.txt</strong>, <strong class="source-inline">_helpers.tpl</strong>, and Kubernetes resource YAML templates are files that are part of the <strong class="source-inline">template</strong> folder. The <strong class="source-inline">NOTES.txt</strong> file is a template file that will be rendered and printed in the console when we run <strong class="source-inline">helm install</strong> or <strong class="source-inline">helm upgrade</strong>. The <strong class="source-inline">_helpers.tpl</strong> file will hold reusable functions that can be used across a chart. The rest of the files will be standard Kubernetes resource templates relevant to the application. Using the Helm <strong class="source-inline">create</strong> command to generate a basic chart adds a list of Kubernetes resources required for application deployment into the <strong class="source-inline">template</strong> folder. We can delete resources that are not necessary.</li>
				<li><strong class="source-inline">tests</strong> folder: This can hold unit tests to test the logic we write in the resource template.</li>
			</ul>
			<p>Helm uses the <strong class="source-inline">template</strong> package from the Go language and provides many powerful templating constructs to render complex scenarios. The following sections will explain each concept using the <strong class="source-inline">hello-world</strong> example.</p>
			<h3>Variable access</h3>
			<p>When templates are<a id="_idIndexMarker528"/> rendered, we can replace placeholder variables by simply specifying the variable hierarchy with the following syntax:</p>
			<pre class="source-code"># Variable reference syntax - {{ variable-hierarchy }}</pre>
			<pre class="source-code"># Examples  </pre>
			<pre class="source-code"># Refer deployment.yaml line no 9</pre>
			<pre class="source-code">{{ .Values.replicaCount }}</pre>
			<pre class="source-code"># Refer _helpers.tpl line no 50</pre>
			<pre class="source-code">{{ .Release.Name }}</pre>
			<p>In the preceding example, note that <strong class="source-inline">.</strong> acts as a separator representing the variable hierarchy. We start with <strong class="source-inline">.</strong> representing the root, then refer to one of the root objects. Note that we could have a variable with a multiple-depth hierarchy—for example, <strong class="source-inline">{{ .Values.image.repository }}</strong>. Here are some important built-in root objects available for us to use:</p>
			<ul>
				<li><strong class="source-inline">Release</strong>: This object holds release-related information such as the release’s name, release namespace, revision number, and so on.</li>
				<li><strong class="source-inline">Values</strong>: An object formed with the values file/command-line set flags.</li>
				<li><strong class="source-inline">Chart</strong>: Values defined in the <strong class="source-inline">chart.yaml</strong> file will be available under this object.</li>
			</ul>
			<p>There are more objects available, such as <strong class="source-inline">Files</strong>, <strong class="source-inline">Capabilities</strong>, <strong class="source-inline">Template</strong>, and so on. Refer to <a href="https://helm.sh/docs/chart_template_guide/builtin_objects/">https://helm.sh/docs/chart_template_guide/builtin_objects/</a> for a complete list.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To remove an object or a specific attribute from the template, use the <strong class="source-inline">--set</strong> command-line with a <strong class="source-inline">null</strong> value—for example, <strong class="source-inline">--set livenessProbe.httpGet=null</strong>.</p>
			<h3>Functions and pipelines</h3>
			<p>We may have requirements to replace variables after doing some transformation, and built-in functions and pipelines can help with these. For example, refer to the following code snippet:</p>
			<pre class="source-code"># Refer _helpers.tpl line no 40</pre>
			<pre class="source-code">app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}</pre>
			<p>We refer to the application version and then enclose a string inside a quote in the preceding example. There are two essential things to note here. The quote is an built-in function available for us to<a id="_idIndexMarker529"/> use, and <strong class="source-inline">|</strong> will help pipe the output from one instruction to another. Here is a list of some frequently used functions:</p>
			<ul>
				<li><strong class="source-inline">indent</strong>: Useful to format the configuration YAML. It takes a numerical input and indents the row with the specified index.</li>
				<li><strong class="source-inline">nindent</strong>: The function works like the <strong class="source-inline">intent</strong> function, with an addition of a newline at the beginning.</li>
				<li><strong class="source-inline">trunc</strong>: Truncates a string with the specified number of indexes.</li>
				<li><strong class="source-inline">trimSuffix</strong>: This method takes a string suffix as input and truncates the suffix if it is present in the operating string.</li>
				<li><strong class="source-inline">replace</strong>: The <strong class="source-inline">replace</strong> method can replace one substring with another in an operating string.</li>
				<li><strong class="source-inline">semverCompare</strong>: This function can be used to compare two semantic versions.</li>
			</ul>
			<p>These are some of the functions used in <strong class="source-inline">deployment.yaml</strong> and <strong class="source-inline">_helpers.tpl</strong>. Refer to <a href="https://helm.sh/docs/chart_template_guide/function_list/">https://helm.sh/docs/chart_template_guide/function_list/</a> to look at an extensive list of built-in functions.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Note that there is <strong class="source-inline">-</strong> in many template placeholders—for example, the sixth line of <strong class="source-inline">deployment.yaml</strong> has <strong class="source-inline">{{-</strong>. This instructs the template engine to remove whitespace on the left. Similarly, <strong class="source-inline">-}}</strong> can remove whitespace on the right.</p>
			<h3>Flow control</h3>
			<p>Flow controls make any programming language powerful and enable us to encode complex logic. Helm’s template<a id="_idIndexMarker530"/> language provides three flow controls. The first flow control available is the standard <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> statement. It is helpful to include a block based on a specific condition. The following code snippet from the <strong class="source-inline">ingress.yaml</strong> file checks<a id="_idIndexMarker531"/> the Kubernetes version to decide on the ingress <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) version:</p>
			<pre class="source-code"># Refer ingress.yaml line no 9</pre>
			<pre class="source-code">{{- if semverCompare "&gt;=1.19-0" .Capabilities.KubeVersion.GitVersion -}}</pre>
			<pre class="source-code">apiVersion: networking.k8s.io/v1</pre>
			<pre class="source-code">{{- else if semverCompare "&gt;=1.14-0" .Capabilities.KubeVersion.GitVersion -}}</pre>
			<pre class="source-code">apiVersion: networking.k8s.io/v1beta1</pre>
			<pre class="source-code">{{- else -}}</pre>
			<pre class="source-code">apiVersion: extensions/v1beta1</pre>
			<pre class="source-code">{{- end }}</pre>
			<p>Note that <strong class="source-inline">Capabilities</strong> is an built-in object providing the capabilities of the target Kubernetes cluster. The second flow control, <strong class="source-inline">with</strong>, allows us to create a block with a specific variable scope. Refer to the following code snippet from <strong class="source-inline">serviceaccount.yaml</strong>:</p>
			<pre class="source-code"># Refer serviceaccount.yaml line no 8</pre>
			<pre class="source-code"># We create a scope block with variable Values.serviceAccount.annotations</pre>
			<pre class="source-code">{{- with .Values.serviceAccount.annotations }}</pre>
			<pre class="source-code">annotations:</pre>
			<pre class="source-code">  {{- toYaml . | nindent 4 }}</pre>
			<pre class="source-code">{{- end }}</pre>
			<p>Remember our earlier discussion about variable references? We mentioned that the initial <strong class="source-inline">.</strong> refers to all objects’ roots. Inside a <strong class="source-inline">with</strong> block, the definition changes. The initial <strong class="source-inline">.</strong> within the block will refer to the scope variable defined. The third flow control is the range used for looping. Refer to the following code snippet from <strong class="source-inline">NOTES.txt</strong>:</p>
			<pre class="source-code"># Refer NOTES.txt line no 2</pre>
			<pre class="source-code"># Loops over the hosts with an inner loop on path</pre>
			<pre class="source-code">{{- range $host := .Values.ingress.hosts }}</pre>
			<pre class="source-code">  {{- range .paths }}</pre>
			<pre class="source-code">  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}</pre>
			<pre class="source-code">  {{- end }}</pre>
			<pre class="source-code">{{- end }}</pre>
			<p>We declare a new<a id="_idIndexMarker532"/> variable, <strong class="source-inline">host</strong>, in the preceding example, and refer to it within the loop. Similarly, we could use variable declaration in other places as well.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We can use <strong class="source-inline">dry-run</strong> and a <strong class="source-inline">disable-openapi-validation</strong> flag with <strong class="source-inline">helm install</strong> or <strong class="source-inline">helm upgrade</strong> to debug or validate the YAML outputs.</p>
			<h3>Named templates</h3>
			<p>Named templates are frequently used, and they act as static custom-defined functions. We define a template with a <a id="_idIndexMarker533"/>name and then import them into the required place. Generally, these named templates are described in the helper file and reused across the chart. Refer to the two pieces of code in the following snippet:</p>
			<pre class="source-code"># Template named hello-world.selectorLabels is defined in the _helpers.tps line no 45</pre>
			<pre class="source-code"># hello-world is a release name prefix added to avoid name conflicts when we have sub-charts and dependent charts.</pre>
			<pre class="source-code">{{- define "hello-world.selectorLabels" -}}</pre>
			<pre class="source-code">app.kubernetes.io/name: {{ include "hello-world.name" . }}</pre>
			<pre class="source-code">app.kubernetes.io/instance: {{ .Release.Name }}</pre>
			<pre class="source-code">{{- end }}</pre>
			<pre class="source-code"># deployment.yaml line number 12</pre>
			<pre class="source-code"># Template included with the name</pre>
			<pre class="source-code">matchLabels:</pre>
			<pre class="source-code">  {{- include "hello-world.selectorLabels" . | nindent 6 }}</pre>
			<p>Note that the template output can be piped with other built-in functions. We have covered most of the skills<a id="_idIndexMarker534"/> required to create new Helm charts for our bespoke applications. After changing the image name to <strong class="source-inline">hello-world</strong> in the <strong class="source-inline">value.yaml</strong> file, we can deploy the chart. Refer to the following screenshot for the chart installation:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B17830_09_02.jpg" alt="Figure 9.2 – Installing the chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Installing the chart</p>
			<p>In the next section, we can use Kustomize to customize the configuration.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Customizing configurations with Kustomize</h1>
			<p>Be it a configuration<a id="_idIndexMarker535"/> managed by Helm or other configuration management tools, Kustomize is one of the best tools for configuration customization. Let’s look at some of the use cases for Kustomize, as follows:</p>
			<ul>
				<li>Keeping environment-specific customization separate from the base configuration is one use case. For example, replication counts can be done in staging, while the production environment could be enabled with auto-scaling.</li>
				<li>Managing cross-cutting configurations outside the base configuration is another use case. For example, the application operator working with governance-specific labels in all<a id="_idIndexMarker536"/> deployments can keep the configuration separate from the base configuration. It can enable <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>) for multi-persona collaboration without friction. Injecting a service mesh configuration as a cross-cutting concern is another example.</li>
				<li>The third use case is fixing vulnerabilities as a step in the configuration pipeline. Consider that there is a security vulnerability with an nginx image. The security team can add a customization step in the pipeline to ensure that the vulnerable version of nginx is updated for all deployments.</li>
				<li>The classic use case is to<a id="_idIndexMarker537"/> avoid abstraction leaking, as we discussed many times in the previous chapters. When we want to reuse the base configuration template across a few similar workloads, we can consider Kustomize as the new parameter.</li>
			</ul>
			<p>The following screenshot represents how Kustomize patching can be used in a multi-persona collaboration environment:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B17830_09_03.jpg" alt="Figure 9.3 – Configuration customization&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Configuration customization</p>
			<p>Let’s look at a simple example to use<a id="_idIndexMarker538"/> Kustomize. We should have the base configuration on one side and <strong class="source-inline">kustomization.yaml</strong> on the other. <strong class="source-inline">kustomization.yaml</strong> defines how to customize the base configuration. Here is a sample <strong class="source-inline">kustomization.yaml</strong> file:</p>
			<pre class="source-code">resources:</pre>
			<pre class="source-code">- deployment.yaml</pre>
			<pre class="source-code">commonLabels:</pre>
			<pre class="source-code">    team-name: alpha</pre>
			<pre class="source-code">namespace: test</pre>
			<p>The preceding configuration refers to the base configuration and defines how to customize it. The <strong class="source-inline">deployment.yaml</strong> file is the base configuration reference under the <strong class="source-inline">resources</strong> section. The <strong class="source-inline">commonLabels</strong> configuration adds the team’s name as a label to the deployment, and the <strong class="source-inline">namespace</strong> configuration will override the deployment resource namespace. We can run the <strong class="source-inline">kubectl kustomize .</strong> command to perform the customization. Refer to the following screenshot:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B17830_09_04.jpg" alt="Figure 9.4 – Configuration customization (continued)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Configuration customization (continued)</p>
			<p>Kustomize can work with Crossplane configurations as well. An example to add a label to the composition is<a id="_idIndexMarker539"/> available in the hands-on example repository for this chapter.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><strong class="source-inline">helm install</strong> can use Kustomize as a post-render step by specifying the path to <strong class="source-inline">kustomization.yaml</strong>. The syntax is <strong class="source-inline">helm install &lt;release-name&gt; &lt;chart-name&gt; --post-renderer ./path/to/executable</strong>.</p>
			<p class="callout">An example<a id="_idIndexMarker540"/> of using Helm and <a id="_idIndexMarker541"/>Kustomize is available at <a href="https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render">https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render</a>.</p>
			<p>More than labels and namespaces, a lot more is possible with Kustomize. Refer to <a href="https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/">https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/</a> for a deep dive into all possible customizations. This takes us to the end of the discussion on Kustomize, and in the following section, we will discuss KubeVela for application workload deployment.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Deploying application workloads with KubeVela</h1>
			<p>As discussed earlier, KubeVela is a<a id="_idIndexMarker542"/> project like Crossplane <a id="_idIndexMarker543"/>but focuses primarily on bespoke application workload. It can also cover off-the-shelf components via add-ons. Before getting into the details, let’s look at ways to install KubeVela. We will do the KubeVela installation in two steps. The first part is installing the KubeVela CLI. We can use Homebrew or a script if you have a macOS operating system. In<a id="_idIndexMarker544"/> the case of Windows, we can use PowerShell. Here are the CLI installation instructions:</p>
			<pre class="source-code"># Installing in macOS with Homebrew</pre>
			<pre class="source-code">brew update</pre>
			<pre class="source-code">brew install kubevela</pre>
			<pre class="source-code"># Installing in macOS with script </pre>
			<pre class="source-code">curl -fsSl https://kubevela.io/script/install.sh | bash -s 1.3.0</pre>
			<pre class="source-code"># Installing in windows with a script</pre>
			<pre class="source-code">powershell -Command "iwr -useb https://kubevela.io/script/install.ps1 | iex"</pre>
			<p>As the next step, we should install KubeVela into the Kubernetes cluster, which is nothing but a set of <strong class="bold">Custom Resource Definitions</strong> (<strong class="bold">CRDs</strong>). Here are the KubeVela CRDs’ installation<a id="_idIndexMarker545"/> instructions. We can use either the CLI or a Helm chart:</p>
			<pre class="source-code"># Using the CLI</pre>
			<pre class="source-code">vela install</pre>
			<pre class="source-code"># Using a Helm chart</pre>
			<pre class="source-code">helm repo add kubevela https://charts.kubevela.net/core</pre>
			<pre class="source-code">helm repo update</pre>
			<pre class="source-code">helm install --create-namespace -n vela-system kubevela kubevela/vela-core --version 1.3.0 --wait</pre>
			<p>Additionally, we can enable add-ons. Add-ons enhance the capability of KubeVela. For example, we can use the <strong class="source-inline">velaux</strong> add-on as an application management dashboard. <strong class="source-inline">terraform-gcp</strong> is another add-on useful to compose <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>) resources’ dependencies:</p>
			<pre class="source-code"># View list of Add-ons available</pre>
			<pre class="source-code">vela add-on list</pre>
			<pre class="source-code"># Install the application management dashboard add-on</pre>
			<pre class="source-code">vela add-on enable velaux</pre>
			<p>We are all good to start using <a id="_idIndexMarker546"/>KubeVela. The core of the KubeVela configuration is the application API, and the anatomy of the application <a id="_idIndexMarker547"/>API is described in the following section.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Anatomy of a KubeVela application definition</h2>
			<p>The application specification carries the following four key sections:</p>
			<ul>
				<li><strong class="bold">Components</strong>: Components are the root specification representing what we want to deploy as a Kubernetes <a id="_idIndexMarker548"/>workload. It can also be an external off-the-shelf dependency. In the case of Kubernetes workloads, it can be a Helm chart or a Kustomize package, or other Kubernetes objects such as <strong class="source-inline">Deployment</strong> and <strong class="source-inline">Job</strong>. The external off-the-shelf dependency components can be a Terraform module, CloudFormation template, or even a Crossplane <strong class="bold">Composite Resource</strong> (<strong class="bold">XR</strong>)/Claim.</li>
				<li><strong class="bold">Traits</strong>: Traits are nothing but declarative operational behavior. Application rollout behavior, auto-scaling<a id="_idIndexMarker549"/> rules, and route rules are some examples of a trait. Traits are attached to the components, and we could have more than one trait attached.</li>
				<li><strong class="bold">Policies</strong>: Policies are a <a id="_idIndexMarker550"/>set of rules to be enforced. Pod security policy and health-check configurations are a couple of examples.</li>
				<li><strong class="bold">Workflow</strong>: A workflow is a final section that allows us to control the component delivery process. Approval <a id="_idIndexMarker551"/>steps and environment-specific traits are examples.</li>
			</ul>
			<p>Have a look at the complete list of components, traits, policies, and workflows supported by our cluster using the following commands:</p>
			<pre class="source-code"># List of Components</pre>
			<pre class="source-code">kubectl get ComponentDefinition -n vela-system</pre>
			<pre class="source-code"># List of Traits</pre>
			<pre class="source-code">kubectl get TraitDefinition -n vela-system</pre>
			<pre class="source-code"># List of Policies</pre>
			<pre class="source-code">kubectl get PolicyDefinition -n vela-system</pre>
			<pre class="source-code"># List of Workflows</pre>
			<pre class="source-code">kubectl get WorkflowStepDefinition -n vela-system</pre>
			<p>The following screenshot describes the anatomy of a KubeVela application with a hands-on example:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B17830_09_05.jpg" alt="Figure 9.5 – Application API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Application API</p>
			<p>Apply the <strong class="source-inline">application</strong> YAML, and you will find that our <strong class="source-inline">hello-world</strong> application is running successfully, as we can <a id="_idIndexMarker552"/>see here:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B17830_09_06.jpg" alt="Figure 9.6 – Deployed application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Deployed application</p>
			<p>The KubeVela community has developed many components, traits, policies, and workflows <a id="_idIndexMarker553"/>based on the <strong class="bold">Open Application Model</strong> (<strong class="bold">OAM</strong>) specifications and documented them in the usage examples. The list will cover most of the requirements. Refer to <a href="https://kubevela.io/docs/end-user/components/references">https://kubevela.io/docs/end-user/components/references</a> for a deep dive. If we have a custom requirement, KubeVela has all the ingredients to compose a custom component, trait, policy, and <a id="_idIndexMarker554"/>workflow. It is again creating and registering new CRDs. As with Crossplane, KubeVela also provides a framework to develop these CRDs. That takes us to the end of the chapter and the discussion on KubeVela.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Summary</h1>
			<p>The chapter discussed some popular configuration management tools from the perspective of bespoke applications. While we did not cover every aspect of the tool, we did cover basic concepts, usage patterns, and a hands-on example. Each tool discussed here requires a book by itself to learn about in depth, which is beyond the scope of this book. The concepts, patterns, and tools we discussed will guide us to approach <strong class="bold">end-to-end</strong> (<strong class="bold">E2E</strong>) automation of the whole application using Crossplane.</p>
			<p>The next chapter will go through a hands-on journey to onboard a complete application and its dependency using Crossplane, Helm, and a few other tools.</p>
		</div>
	</body></html>