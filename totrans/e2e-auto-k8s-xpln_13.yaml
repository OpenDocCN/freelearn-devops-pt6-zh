- en: '*Chapter 10*: Onboarding Applications with Crossplane'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This will be a fully hands-on chapter where we will look at the end-to-end automation
    of an application and all its dependencies. The dependencies will involve the
    setup of the project repository, creating the **Continuous Integration and Continuous
    Deployment** (**CI/CD**) pipelines, dependent infrastructure resources, and so
    on. You will see the real power of how Crossplane can automate every possible
    step, starting from the initial repository setup. We will go through the hands-on
    journey from the perspective of three different personas. The three personas are
    the platform developer creating the required XR/claim APIs, the application operator
    configuring the application deployment using the XR/claim, and the developer contributing
    to the application development. The platform developer persona is the key to the
    whole journey, so most of the content in this chapter will be from their perspective.
    Whenever required, we will explicitly mention the other personas. The hands-on
    journey will cover application, services, and infrastructure, all three aspects
    of automation with Crossplane.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The automation requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the control plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating the application deployment environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The repository and CI setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API boundary analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with the requirement from the product team to explore the ways
    to automate.
  prefs: []
  type: TYPE_NORMAL
- en: The automation requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start our high-level requirement story from the perspective of an imaginary
    organization, *X*. They are planning to develop a new e-commerce website named
    `product-a`. It has many modules, each functional at a different time in the customer
    journey, for example, cart, payment, and customer support. Each model requires
    independent release and scaling capabilities while sharing a standard website
    theme and a unified experience. The product architecture group has recommended
    micro-frontend architecture with separate deployment for each module in Kubernetes.
    They also suggested that an individual team will develop the website framework,
    shared UI components, and cross-cutting concerns in the form of a library. The
    independent module team can use these dependent libraries to build their features.
    The product team has recently heard about Crossplane and its ability to automate
    the applications from end to end. They wanted to use the opportunity of developing
    a greenfield product and experiment with Crossplane to set up a high-velocity,
    reliable product development practice. They have reached the platform team, requesting
    help to develop a **proof of concept** (**POC**). The POC project will be the
    scope of our hands-on journey in this chapter. The following diagram represents
    what the product development team wanted to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Product team requirements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Product team requirements
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Please note that both the requirements and solutions discussed in the chapter
    are not exhaustive. Our attempt here is to look for ways to approach automation
    from end to end, covering the entire application life cycle and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The following section explores one possible solution option from the perspective
    of a platform engineer using Crossplane.
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will approach the solution in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will completely automate the `product-a` deployment environment provisioning
    (Kubernetes) and cross-cutting concern setups to support all the micro-frontend
    deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next will be the application onboarding, which covers steps such as new repository
    creation and setting up the CI pipeline for a specific micro-frontend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step will be to set up the CD pipeline and dependent infrastructures
    (database) provisioning for the micro-frontend for which the repository is created.
    We will do this using a set of providers, such as Helm, GitLab, GCP, and Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will create a template GitLab project with the dependent library and kick-start
    the micro-frontend development using a repository cloned from the base template
    repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following diagram represents the complete solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – High-level solution view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – High-level solution view
  prefs: []
  type: TYPE_NORMAL
- en: 'The following stages cover the high-level solution in the preceding diagram
    in a bit more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage 1**: The first stage will be to get the Crossplane control plane ready
    with the required providers (GCP, Helm, Kubernetes, and GitLab) and configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product-a` cluster. The Helm provider configuration helps to set up Argo CD
    in the `product-a` cluster. The Kubernetes provider configuration will help deploy
    micro-frontend applications into the `product-a` cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 3**: The third stage is relevant to every micro-frontend application
    in the product. This step will create a new repository for the micro-frontend
    from the template repository. While creating the new repository, we will also
    clone the CI pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage 4**: The final stage will be to set the CD for the created repository
    using the Kubernetes provider. The Kubernetes provider configuration created in
    stage 2 will be used here. The stage will also create the cloud database instance
    required by the submodule/micro-frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the chapter will investigate details of how we configure Crossplane
    and implement the solution discussed. The following section will deep dive into
    the control plan setup required to implement the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter10/Hands-on-example](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter10/Hands-on-example).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the control plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the stage to install the required components into the Crossplane cluster.
    We will establish the necessary providers and respective configurations. The first
    step will be to install the GCP provider.
  prefs: []
  type: TYPE_NORMAL
- en: The GCP provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the same step we took in [*Chapter 3*](B17830_03_ePub.xhtml#_idTextAnchor039),
    *Automating Infrastructure with Crossplane*, but slightly deviating from it. We
    will differ in how we create and use the GCP provider configuration. It is good
    to have an individual provider configuration for each product team to enhance
    security, auditing, policy compliance, governance, and so on in using the XR/claim
    APIs. Each product team and platform team should create a different provider configuration
    referring to a separate GCP service account secret. The provider configurations
    will be named against the product (`product-a`), and a new namespace will be created
    with the same name. The compositions will be developed in such a way to refer
    to the provider configuration based on the claim namespace dynamically. It is
    one of the multi-tenancy patterns we discussed in [*Chapter 7*](B17830_07_ePub.xhtml#_idTextAnchor109),
    *Extending and Scaling Crossplane*. To finish the GCP setup, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute `GCP-Provider.yaml` to install the provider. Wait until the provider
    pods are up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Meanwhile, ensure that the Kubernetes Secret with the `product-a` GCP service
    account is available in the cluster. This Secret will be referred to in the provider
    configuration. To remind yourself of the steps to make the Secret, refer to the
    *Configure the provider* section in [*Chapter 3*](B17830_03_ePub.xhtml#_idTextAnchor039).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have the Secret available, execute `Provider-Config.yaml` to create
    the product-specific provider configuration. Note that the name of the provider
    configuration is `product-a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, apply `namespace.yaml` to create the `product-a` namespace. It is an
    additional step to hold `Claim` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps will ensure that the GCP provider is fully set. In the following
    section, we will look at the GitLab provider.
  prefs: []
  type: TYPE_NORMAL
- en: The GitLab provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the GitLab provider to manage the micro-frontend repository and
    CI pipeline. The free account provided by GitLab is good enough to continue with
    our experiment. The provider setup is done in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GitLab credentials**: We need to create the GitLab access token as a Kubernetes
    Secret. It will be referred to in the GitLab provider configuration. Generate
    a GitLab access token in the GitLab UI user setting. Use the following command
    to create the Secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`provider-gitlab.yaml` to install the GitLab provider and wait until the pods
    are up and running.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`provider-config.yaml` to create the provider configuration. Again, it will
    be specific to the product with the name `product-a`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are done with the GitLab provider setup. The following section will look
    at the Helm and Kubernetes provider setup.
  prefs: []
  type: TYPE_NORMAL
- en: Helm and Kubernetes provider setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both the Helm and Kubernetes providers are helpful to configure a remote or
    the same Kubernetes cluster. It is the remote Kubernetes cluster created for `product-a`
    in our case. Both providers require credentials to access the remote cluster.
    The product-specific provider configuration will be created automatically for
    the remote cluster when we provision the cluster with our XR API. We will look
    at more details on this in the next section. We will only install the provider
    for now. Execute `Helm-Provider.yaml` and `k8s-Provider.yaml` to install the providers.
    Refer to the following screenshot showing the installation of all providers and
    respective configuration setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Provider setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Provider setup
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the setup yourself, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This takes us to the end of configuring the Crossplane control plane. All these
    activities are meant to be done by the platform team. In the following section,
    we will deep dive into setting up a remote Kubernetes cluster as a deployment
    environment for `product-a`.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the application deployment environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete Kubernetes cluster creation and configuring of the cross-cutting
    concerns will be automated using this step. We will develop an XR/claim API, which
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provisions a remote GKE cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets up Helm and the Kubernetes provider configuration for the GKE cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs Argo CD using the Helm provider into the `product-a` GKE cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at the XRD and composition to understand the API in detail (refer
    to the XRD and composition in the book’s GitHub repository). We will capture two
    mandatory parameters (node count and machine size). The `size` parameter takes
    either `BIG` or `SMALL` as an enum value. Inside the composition, we have composed
    five resources. The following is the list of resources and their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster and NodePool**: Cluster and NodePool are two relevant resources responsible
    for GKE cluster provisioning. It is very similar to the way we provisioned GKE
    in [*Chapter 5*](B17830_05_ePub.xhtml#_idTextAnchor074), *Extending Providers*.
    The node count and the machine type will be patched into the node pool. The node
    pool is again referred to inside the cluster. Both resources will refer to the
    GCP provider configuration dynamically using the claim namespace. Also, the Secret
    required to connect to the GKE cluster is stored in the claim namespace. Refer
    to the following code snippet on the patching operation in the cluster resource:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Helm and Kubernetes ProviderConfig**: As the cluster is ready, it’s time
    to create the Helm and Kubernetes provider configuration. The provider configuration
    will refer to the newly created cluster Secret. Another critical point is defining
    the readiness check as none, as ProviderConfig is not an external resource. Failing
    to do so will not allow the XR/claim to become ready. Refer to the following code
    snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Install Argo CD**: We will install Argo CD into the cluster using the Helm
    provider. Again, the provider configuration will be referred to dynamically with
    a predictable naming strategy. Argo CD is designed to enable CD for the micro-frontend
    repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the cluster creation XR/claim API example discussed here is not production
    ready. You should be installing other cross-cutting concerns using the Helm or
    Kubernetes provider. Also, we missed many fine-grained cluster configurations.
    Refer to [https://github.com/upbound/platform-ref-gcp](https://github.com/upbound/platform-ref-gcp)
    for a more detailed cluster configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To establish and validate our cluster API into the control plane, execute the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The platform team that manages the control plane will do the preceding operations.
    Refer to the following screenshot where the APIs are established:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Cluster API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Cluster API
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, the application operator close to the product team can create
    the cluster using a claim configuration. The application operator will create
    a GKE cluster with the name `product-a` using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot where the GKE cluster and Helm releases are
    established:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Cluster claim'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Cluster claim
  prefs: []
  type: TYPE_NORMAL
- en: We are all good with the cluster creation. We will discuss the next stage to
    onboard the micro-frontend repository in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The repository and CI setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, an XR/claim is developed to clone the template repository to
    create the new micro-frontend repository and CI pipeline. We can do this in two
    steps. First, we will configure GitLab, and then we’ll develop an XR/claim API.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to make the following one-time configurations in GitLab before we start
    the XR/claim API development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create the template project**: We need to have a template repository from
    which we will make a new micro-frontend repository. You can access the template
    repository I have created at [https://gitlab.com/unified.devops/react-template](https://gitlab.com/unified.devops/react-template).
    The repository has a GitLab pipeline set up to build and push the Docker image
    into the Docker Hub registry. You can also set up a private registry here. We
    will automatically get the template project structure and CI set up while we clone
    the template repository for a micro-frontend. The Docker image name will be chosen
    based on the micro-frontend repository name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group for product-a**: We will keep all micro-frontend repositories in a
    single GitLab group to keep it organized, manage user permissions, and maintain
    environment variables for a CI pipeline. You can access the group I have created
    at [https://gitlab.com/unified-devops-project-x](https://gitlab.com/unified-devops-project-x).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REG_USER` and `REG_PASSWORD` with your Docker Hub credentials, as shown in
    the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – CI Docker Hub variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – CI Docker Hub variables
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note that the group creation and user onboarding into the group can be automated.
    Considering doing that with Crossplane. An example of this is available at [https://github.com/crossplane-contrib/provider-gitlab/tree/master/examples/groups](https://github.com/crossplane-contrib/provider-gitlab/tree/master/examples/groups).
  prefs: []
  type: TYPE_NORMAL
- en: We have all the components to develop our project onboarding XR/claim API. The
    following section will look at the details of the onboarding API.
  prefs: []
  type: TYPE_NORMAL
- en: The onboarding XR/claim API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we look at the XRD (`gitproject-xrd.yaml`), we take in two parameters as
    inputs. The template’s name refers to the template repository from which we should
    be cloning, and the group ID will determine the GitLab group under which the repository
    will be created. You can get the group ID from the GitLab group details page or
    group settings page. These two parameters make the API generic, so it can be used
    across the organization. The newly created micro-frontend repo URL and an access
    token to work with the repository will be stored as connection Secrets. We can
    use these with Argo CD to read the repo. Our example doesn’t require the access
    token as the repository is public. It will be a simple composition to map the
    template name with a template URL, clone the repository into the specified group,
    and copy back the repository details into the Secret. The repository’s name will
    be referred to from the name of the claim object. To establish and validate the
    onboarding API into the control plane, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot, where the APIs are established:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Onboarding API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Onboarding API
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step in the onboarding stage, the application operator can onboard
    the repository and CI pipeline using a `Claim` configuration. The application
    operator will create a repository with the name `micro-frontend-one` using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot where the claims are created in GitLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Onboarding the repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Onboarding the repository
  prefs: []
  type: TYPE_NORMAL
- en: You can go to the CI/CD section of the new repository to run the CI pipeline
    to see that the Docker images are created and pushed into Docker Hub. Developers
    can now make changes to the repository, and any new commit will automatically
    trigger the GitLab CI pipeline. In the following section, we can investigate the
    final stage to set up CD and provision other infrastructure dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final stage is to automate the deployment dependencies for the micro-frontend.
    Automating the deployment dependencies means taking care of two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure dependencies**: The step involves provisioning the needed
    infrastructure dependencies for the micro-frontend. In our case, we will create
    a GCP MySQL database. There could be more dependencies for an application. We
    will settle with just a database to keep the example simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template-helm` folder inside our template repository ([https://gitlab.com/unified.devops/react-template/-/tree/main/template-helm](https://gitlab.com/unified.devops/react-template/-/tree/main/template-helm)),
    it holds a Helm chart for deploying the application into Kubernetes. To deploy
    this Helm chart in a GitOps fashion, we must add an Argo CD configuration to the
    `product-a` Kubernetes cluster to sync the chart. We will construct an `Object`-type
    Kubernetes provider configuration, which can help apply any Kubernetes configuration
    to a target cluster. Our composition will compose an Argo CD configuration to
    deploy a Helm chart from a repository. Read more on how to use Argo CD for Helm
    deployment at [https://cloud.redhat.com/blog/continuous-delivery-with-helm-and-argo-cd](https://cloud.redhat.com/blog/continuous-delivery-with-helm-and-argo-cd).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will build a nested XR to satisfy the preceding requirement. The XWebApplication
    will be the parent API, and XGCPdb will be the nested inner XR. The parent API
    captures the product Git group and database size as input. The micro-frontend
    name will be another input derived from the name of the claim. The parent composition
    will compose the Argo CD config and an XGCPdb resource (inner XR). Refer to our
    example repo’s application and database folder to go through the XRD and composition
    of both XRs. The following are a few code snippets that are key to understanding.
    In the Argo CD object, the following is the patch for the repository URL. We construct
    the GitLab URL from the group name and claim name (repository name). Look at the
    claim to see the actual input (`Claim-Application.yaml`). The following is the
    repository URL patch code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We dynamically patch the Kubernetes provider config name using a predictable
    naming strategy. The following is the code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important patch is to bind the Docker image name dynamically. In our
    CI pipeline, we use the repository name as the Docker image name. As the claim
    name and the repository name are the same, we can use the claim name to dynamically
    construct the Docker image name. The following is the patch code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`source` and `destination` are two key sections under the Argo CD config. This
    configuration provides information about the source of the Helm chart and how
    to deploy this in the destination Kubernetes cluster. The following is the code
    snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To establish and validate our APIs in the control plane, execute the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot, where the APIs are established and validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Onboarding the application API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Onboarding the application API
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note that we did not configure any access token for Argo CD to access GitLab
    as it is a public repository. We will have private repositories in real life,
    and a token is required. Refer to [https://argo-cd.readthedocs.io/en/release-1.8/operator-manual/declarative-setup/#repositories](https://argo-cd.readthedocs.io/en/release-1.8/operator-manual/declarative-setup/#repositories)
    to see how to set up an access token. Again, this can be automated as a part of
    repository onboarding.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step in the application deployment automation stage, the application
    operator can provision the database as an infrastructure dependency and configure
    the CD setup using the following claim configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The application operator will use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot, where the application infrastructure dependencies
    and CD configurations are provisioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Onboarding the API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Onboarding the API
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We have used Argo CD and Helm chart deployment to handle application automation.
    We can replace Helm with KubeVela, combine Helm/KubeVela with Kustomize, or even
    use a plain Kubernetes object as required for your team. Even Argo CD can be replaced
    with other GitOps tools, such as Flex.
  prefs: []
  type: TYPE_NORMAL
- en: This takes us to the end of the hands-on journey to automate the application
    from end to end. Our micro-frontend example and its dependent database are up
    and running now. In the following section of this chapter, we will discuss the
    reasoning behind our XR/claim API boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: API boundary analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We divided the end-to-end automation into four stages. We can ignore stage
    one as it is about preparing the Crossplane control plane itself. It’s essential
    to understand why we split the remaining stages into three with four XR/claim
    APIs. The following are the ideas behind our API boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`product-a`. All modern workloads are generally deployed in Kubernetes, and
    the organization will have many such cluster setup activities in the future. Building
    a separate API to enable reusability and centralized policy management makes sense.
    Another critical reason to keep the API separate is that the cluster setup is
    a one-time activity and acts as cross-cutting for further application workload
    deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The onboarding API**: The XR/claim for the GitLab project onboarding is developed
    as a separate API. We don’t need to onboard the repository and CI pipeline for
    every environment (production, staging, and development). That’s why we decided
    to keep XGitProjectAPI/GitProject API separate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application API**: This is the step where we onboard the application
    infrastructure dependencies and CI setup, which is done once per environment.
    That’s why we developed XWebApplication/WebApplication as a separate API. Note
    that there is an inner nested API for the database provisioning. The idea is to
    keep it separate as there are organization-wide policies in database provisioning.
    Note that the database API does not have a claim as it is designed to be used
    as only a nested API. The policy requirement is an assumption that may not be
    true for your case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The repository URL and access token created with the onboarding API is required
    in the application API to set up CI. The onboarding API is a one-time activity,
    and the application API is used in every environment. If we have a different Crossplane
    for every environment (production, staging, and development), sharing the credentials
    across in an automated way could be challenging. Consider using an external key
    vault to sync the repository details from the onboarding API. Other Crossplane
    environments can synchronize these Secrets using tools such as External Secrets
    ([https://external-secrets.io/v0.5.3/](https://external-secrets.io/v0.5.3/)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed one of the approaches to handling the end-to-end automation
    of applications, infrastructure, and services. There are multiple patterns to
    approach end-to-end control plane-based automation using the ways we learned throughout
    the book. I can’t wait to see what unique ways you come up with. This chapter
    takes us to the end of learning Crossplane concepts and patterns and our hands-on
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we will look at some inspirations to run a platform as
    a product. You will learn essential engineering practices that make our Crossplane
    platform team successful.
  prefs: []
  type: TYPE_NORMAL
