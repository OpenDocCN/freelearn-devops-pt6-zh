- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world is rapidly generating massive amounts of data from a variety of sources
    – mobile devices, social media, e-commerce transactions, sensors, and more. This
    data explosion is often referred to as “big data.” While big data presents immense
    opportunities for businesses and organizations to gain valuable insights, it also
    brings tremendous complexity in how to store, process, analyze, and extract value
    from huge volumes of diverse data.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Kubernetes comes in. Kubernetes is an open source container orchestration
    system that helps automate the deployment, scaling, and management of containerized
    applications. Kubernetes brings important advantages for building big data systems.
    It provides a standard way to deploy containerized big data applications on any
    infrastructure. This makes it easy to migrate applications across on-premises
    servers or cloud providers. It also makes it simple to scale big data applications
    up or down based on demand. Additional containers can be spun up or shut down
    automatically based on usage.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes helps ensure the high availability of big data applications through
    features such as self-healing and auto-restarting of failed containers. It also
    provides a unified way to deploy, monitor, and manage different big data components.
    This reduces operational complexity compared to managing each system separately.
  prefs: []
  type: TYPE_NORMAL
- en: This book aims to provide you with practical skills for leveraging Kubernetes
    to build robust and scalable big data pipelines. You will learn how to containerize
    and deploy popular big data tools such as Spark, Kafka, Airflow, and more on Kubernetes.
    The book covers architectural best practices and hands-on examples for building
    batch and real-time data pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: By the end, you will gain an end-to-end view of running big data workloads on
    Kubernetes and be equipped to build efficient data platforms that power analytics
    and artificial intelligence applications. The knowledge you will gain will be
    of immense value whether you are a data engineer, data scientist, DevOps engineer,
    or technology leader driving digital transformation in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: The foundation of Kubernetes is containers. Containers are one of the most used
    technologies in data engineering today. They allow engineers to package software
    into standardized units for development, shipment, and deployment. By the end
    of this chapter, you will understand the basics of containers and be able to build
    and run your own containers using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover what containers are, why they are useful, and
    how to create and run containers on your local machine using Docker. Containers
    solve many problems that developers face when moving applications between environments.
    They ensure that the application and its dependencies are packaged together and
    isolated from the underlying infrastructure. This allows the application to run
    quickly and reliably from one computing environment to another.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by installing Docker, a platform for building and running containers,
    on your local system. We will run simple Docker images and learn the basic Docker
    commands. We will then build our first Docker image containing a simple Python
    application. We will learn how to define a Dockerfile to efficiently specify the
    environment and dependencies for our application. We will then run our image as
    a container and explore how to access the application and check its logs.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are a key technology for modern software deployment. They are lightweight,
    portable, and scalable, allowing you to build and ship applications faster. The
    concepts and skills you will learn in this chapter will provide a strong foundation
    for working with containers and deploying data applications. By the end of this
    chapter, you will be ready to start building and deploying your own containerized
    data processing jobs, APIs, and data engineering tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Container architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you should have Docker installed. Also, a computer with a
    minimum of 4 GB of RAM (8 GB is recommended) is required, as Docker can really
    consume a computer’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is available on GitHub. Please refer to [https://github.com/PacktPublishing/Bigdata-on-Kubernetes](https://github.com/PacktPublishing/Bigdata-on-Kubernetes)
    and access the `Chapter01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Container architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are an operating system-level virtualization method that we can use
    to run multiple isolated processes on a single host machine. Containers allow
    applications to run in an isolated environment with their own dependencies, libraries,
    and configuration files without the overhead of a full **virtual machine** (**VM**),
    which makes them lighter and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: If we compare containers to traditional VMs, they differ in a few ways. VMs
    virtualize at the hardware level, creating a full virtual operating system. Containers,
    on the other hand, virtualize at the operating system level. Because of that,
    containers share the host system’s kernel, whereas VMs each have their own kernel.
    This allows containers to have much faster startup times, typically in milliseconds
    compared to minutes for VMs (it is worth noting that in a Linux environment, Docker
    can leverage the capabilities of a Linux kernel directly. While running in a Windows
    system, however, it runs in a lightweight Linux VM that is still lighter than
    a full VM).
  prefs: []
  type: TYPE_NORMAL
- en: Also, containers have better resource isolation as they only isolate the application
    layer, whereas VMs isolate an entire operating system. Containers are immutable
    infrastructure, making them more portable and consistent as updates create new
    container images (versions) rather than updating in place.
  prefs: []
  type: TYPE_NORMAL
- en: Due to these differences, containers allow higher density, faster startup times,
    and lower resource usage compared to VMs. A single server can run dozens or hundreds
    of containerized applications isolated from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is one of the most popular container platforms that provides tools to
    build, run, deploy, and manage containers. Docker architecture consists of the
    Docker client, Docker daemon, Docker registry, and Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client is a **command-line interface** (**CLI**) client used to interact
    with the Docker daemon to build, run, and manage containers. This interaction
    occurs through a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker daemon is a background service that runs on the host machine and
    manages building, running, and distributing containers. It is the base for all
    the containers to run on.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker registry is a repository to host, distribute, and download Docker
    images. Docker Hub is the default public registry with many pre-built images,
    but cloud providers usually have their own private container registry as well.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Docker images are read-only templates used to create Docker containers.
    Images define the container environment, dependencies, operating system, environment
    variables, and everything that a container needs to run.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.1* shows the difference between an application running in a VM
    and an application running in a container.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – VMs versus containers](img/B21927_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – VMs versus containers
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.2* shows how a container runs with separate layer levels. There
    is the shared kernel at the bottom. On top of that, we have as many operating
    systems as we need. On top of the Debian OS layer, we see a Java 8 image and an
    NGINX image. The Java 8 layer is shared by three containers, one of them with
    only the image information and two using another image, Wildfly. The figure demonstrates
    why the container architecture is so efficient in sharing resources and lightweight
    because it is built upon layers of libraries, dependencies, and applications that
    will run isolated from each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Container layers](img/B21927_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Container layers
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get to it. In the next section, you will learn how to install Docker
    and run your first Docker CLI commands.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with Docker, you can install it by using the package manager
    for your Linux distribution or install Docker Desktop for Mac/Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Docker Desktop on Windows, you must turn on the WSL 2 feature. Refer
    to this link for detailed instructions: [https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you can install Docker Desktop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    and download the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the download is ready, double-click the installer and follow the prompts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should ensure that the **Use WSL 2 instead of Hyper-V** option is selected
    on the **Configuration** page. This is the recommended usage. (If your system
    does not support WSL 2, this option will not be available. You can still run Docker
    with Hyper-V, though.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the installation is finished, close to complete and start Docker Desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have any doubts, refer to the official documentation: [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/).'
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation of Docker Desktop on macOS is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    and download the installer for macOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the installer and follow the prompts to install Docker Desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installation completes, Docker Desktop will start automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Desktop runs natively on macOS using the HyperKit VM and does not need
    additional configuration. When Docker Desktop starts for the first time, it will
    prompt you to authorize it for drive access. Authorize Docker Desktop to allow
    it to access files on your filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing Docker on Linux-based systems is very straightforward. You can use
    your Linux distribution package manager to do that with just a few commands. For
    Ubuntu, for instance, the first thing is to remove any older versions of Docker
    that you previously had on the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install Docker from the default `apt` repository using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will install a slightly older version of Docker. If you want the latest
    version, check the official Docker website ([https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/))
    and follow the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use Docker without having to `sudo` commands, run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s get hands-on practice with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very first Docker image we can run is the `hello-world` image. It is often
    used to test whether Docker is correctly installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: hello-world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the installation, open the terminal (Command Prompt in Windows) and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will pull the `hello-world` image from the Docker Hub public repository
    and run the application in it. If you can run it successfully, you will see this
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You just ran your first Docker image! Now, let’s try something
    a little more ambitious.
  prefs: []
  type: TYPE_NORMAL
- en: NGINX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NGINX is a well-known open source software for web serving, reverse proxying,
    and caching. It is widely used in Kubernetes-based architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different from the `hello-world` application (which behaves like a job execution),
    NGINX behaves like a service. It opens a port and keeps listening for user requests.
    We can start by searching for the available NGINX images in Docker Hub using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show several available images. Usually, the first in the list
    is the official image. Now, to set up a running NGINX container, we can use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download the current latest version of the image. The `latest` keyword
    after the colon stands for the “tag” of this image. To install a specific version
    (recommended), specify the tag like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can visit [https://hub.docker.com/_/nginx](https://hub.docker.com/_/nginx)
    to check for all the available tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to run the container, you should specify which version of the image you
    want to use. The following command will do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will start to see NGINX logs in the terminal. Then, open your preferred
    browser and type `http://localhost/`. You should see this message (*Figure 1**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – The nginx default output in the browser](img/B21927_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – The nginx default output in the browser
  prefs: []
  type: TYPE_NORMAL
- en: The `docker run` command has a few important parameters. `--name` defines the
    name of the container that will run. If you don’t define a name, Docker will automatically
    choose a name for it (trust me, it can be very creative). `-p` connects a port
    on your machine (port `80`) to a port inside the container (also `80`). If you
    do not open this port, you won’t be able to reach the container’s running application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After your test is successful, get back to the terminal running the container
    and press “CTRL + C” to stop the container. After it stops, it will still be there,
    although not running. To remove the container, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are in doubt, you can see all the running and stopped containers with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also can see all the locally available images with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, the output shows three images: `hello-world` and two NGINX images,
    one of them with the `latest` tag and the other with the `1.25.2-alpine-slim`
    tag. All images and their respective versions will show.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this last example, we will learn how to use technology that is not installed
    in our machine by interacting with running containers. We will run a container
    with a new and efficient programming language for data science called Julia. To
    do that, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `docker run` command looks for a local image. If it’s not downloaded,
    Docker will automatically pull the image from Docker Hub. With the preceding command,
    we will start an interactive session in a Julia 1.9.3 container. The `-it` parameters
    allow us to use it interactively. The `--rm` parameter states that the container
    will automatically be removed after it is stopped, so we don’t have to manually
    remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the container is up and running, let’s play with a simple custom function
    to calculate two descriptive statistics: a mean and a standard deviation. You
    will see a Julia’s logo in the terminal, and you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the function, we will run it with a small array of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the proper output on the screen. Congratulations! You have just
    used the Julia programming language without having to install or configure it
    on your computer with Docker! To exit the container, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we used the `--rm` parameter, if we run the `docker ps -a` command, we will
    see that it has been automatically removed.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will customize our own container images for running a simple data processing
    job and an API service.
  prefs: []
  type: TYPE_NORMAL
- en: Batch processing job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a simple Python code for a batch processing job:'
  prefs: []
  type: TYPE_NORMAL
- en: '**run.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This Python code loads a CSV dataset from a URL into a pandas DataFrame, adding
    a new column by multiplying an existing column by 2 and then printing out some
    information about the DataFrame (column names, first five rows, and size of the
    DataFrame). Type this code using your favorite code editor and save the file with
    the name `run.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, we test our code locally (whenever possible) to be sure it is working.
    To do that, first, you need to install the `pandas` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to package our simple processing job into a container. Let’s
    start by defining a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile_job**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Those are the only four lines we need to define a working container. The first
    line specifies the base image to use, which is a slim version of `Python 3.11.6`.
    This is a Debian-based OS that already has `Python 3.11.6` installed, which can
    save us a lot of time. Using a slim image is very important to keep the container
    size small and optimize transfer time and storage costs (when it’s the case).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line installs the `pandas` library. The third line copies the local
    `run.py` file into the container. Finally, the last line sets the default command
    to run when the container starts to execute the `/run.py` script. After you are
    done defining the code, save it as `Dockerfile_job` (no `.extension`). Now, it’s
    time to build our Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `docker build` command builds an image according to the Dockerfile instructions.
    Usually, this command expects a file named `Dockerfile`. Since we are working
    with a filename different from expected, we must tell Docker which file to use
    with the `-f` flag. The `-t` flag defines a tag for the image. It is composed
    of a name and a version, separated by a colon (`:`). In this case, the name we
    set for the image is `data_processing_job` and a `1.0` version. The last parameter
    to this command is the path where code files are located. Here, we set the current
    folder with a dot (`.`). This dot is very easy to forget, so be careful!
  prefs: []
  type: TYPE_NORMAL
- en: 'After the build is finished, we can check the locally available images with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the first line of the output showing your recently built data
    processing image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to run our data processing job from inside the container, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker run` command runs the specified image. The `--name` flag defines
    the name of the container as `data_processing`. After you start running the container,
    you should see the same output as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, don’t forget to remove the exited containers from your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Congrats! You have run your first job using containers. Now, let’s move to
    another type of containerized application: a service.'
  prefs: []
  type: TYPE_NORMAL
- en: API service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will use `app`, and create a Python script named `main.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script, first, we import FastAPI and the random module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an instance of the FastAPI app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code block defines a route using the `@``app.get` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `@app.get` decorator indicates that this is a `GET` endpoint. This function
    is defined to answer at the `"/api"` route. It just returns a pleasant message
    on request of the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code chunk defines a route, `"/api/{name}"`, where `name` is a parameter
    that will be received in the request. It returns a greeting message with the given
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last code block defines a `"/joke"` route. This function returns a (very
    funny!) random joke from the list of jokes previously defined. Feel free to replace
    them with your own cool jokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It is important to notice that every function returns a response in JSON format.
    This is a very common pattern with APIs. For the whole Python code, refer to the
    book’s GitHub repository ([https://github.com/PacktPublishing/Bigdata-on-Kubernetes](https://github.com/PacktPublishing/Bigdata-on-Kubernetes)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we build the Docker image, it is advised to test the code locally (whenever
    possible). To do this, you must install the `fastapi` and `uvicorn` packages.
    Run this command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the API, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you will see an output like this in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This command runs the API service locally on port `8087`. To test it, open a
    browser and access `http://localhost:8087/api`. You should see the programmed
    message on the screen. Test the `http://localhost:8087/api/<YOUR_NAME>` and `http://localhost:8087/joke`
    endpoints as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know everything is working fine, let’s package the API in a Docker
    image. To do that, we will build a simple Dockerfile. To optimize it, we will
    use the `alpine` linux distribution, an extremely lightweight base OS. In the
    root folder of your project, create a new file named `Dockerfile` (no `.extension`).
    This is the code we will use for this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first line imports a Python container based on the `alpine` Linux distribution.
    The second line installs `fastapi` and `uvicorn`. The third line informs Docker
    that the container will listen on port `8087` at runtime. Without this command,
    we would not be able to access the API service. The fourth line copies all the
    code inside our local `/app` folder to a `/app` folder inside the container. Finally,
    the `CMD` command specifies the command to run when the container starts. Here,
    we are starting the `uvicorn` server to run our FastAPI application. After `uvicorn`,
    we state a location pattern of `folder.script_name:FastAPI_object_name` to tell
    FastAPI where to look for the API process object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this Dockerfile is built into an image, we will have a containerized Python
    application configured to run a FastAPI web server on port `8087`. The Dockerfile
    allows us to package up the application and its dependencies into a standardized
    unit for deployment. To build the image, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: No need to specify the `-f` flag here since we are using a Dockerfile with the
    default name. And remember the dot at the end of the line!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we run the container with a slightly different set of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `-p` parameter sets that we will open port `8087` in the server (in this
    case, your computer) to port `8087` in the container. If we don’t set this parameter,
    there is no way to communicate with the container whatsoever. The `-d` parameter
    runs the container in *detached* mode. The terminal will not be showing container
    logs but it will be available for use while the container is running in the background.
    The `--rm` parameter sets the container to be automatically removed after it is
    finished (very handy). Finally, `--name` sets the name for the container as `api`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check whether the container is correctly running with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to check the logs to a container, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can test our API endpoints in the browser with the same links shown
    before (`http://localhost:8087/api, http://localhost:8087/api/<YOUR_NAME>` and
    `http://localhost:8087/joke`).
  prefs: []
  type: TYPE_NORMAL
- en: Congrats! You are running your API service from inside a container. This is
    a completely portable and self-contained application that can be deployed anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the API service, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that the stopped container has been automatically removed, use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Nicely done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamentals of containers and how to build
    and run them using Docker. Containers provide a lightweight and portable way to
    package applications and their dependencies so they can run reliably across environments.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about key concepts such as images, containers, Dockerfiles, and
    registries. We installed Docker and ran simple containers such as NGINX and Julia
    to get hands-on experience. You built your own containers for a batch processing
    job and API service, defining Dockerfiles to package dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: These skills allow you to develop applications and containerize them for smooth
    deployment anywhere. Containers are super useful as they ensure your software
    runs exactly as intended every time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at orchestrating containers using Kubernetes
    to easily scale, monitor, and manage containerized applications. We will take
    a look at the most important Kubernetes concepts and components and learn how
    to implement them with YAML files (manifests).
  prefs: []
  type: TYPE_NORMAL
