<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DevOps with Containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We're now familiar with a wide variety of DevOps tools that can help us to automate tasks and manage configuration throughout the delivery journey of an application. </span><span class="koboSpan" id="kobo.2.2">Challenges still lie ahead, however, as applications have now become more diverse than ever. </span><span class="koboSpan" id="kobo.2.3">In this chapter, we'll add another skill to our tool belt: the container. </span><span class="koboSpan" id="kobo.2.4">In particular, we'll talk about the </span><strong><span class="koboSpan" id="kobo.3.1">Docker container</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">In doing this, we'll seek to understand the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">Key concepts related to containers</span></li>
<li><span class="koboSpan" id="kobo.6.1">Running Docker applications</span></li>
<li><span class="koboSpan" id="kobo.7.1">Building Docker applications with Dockerfile</span></li>
<li><span class="koboSpan" id="kobo.8.1">Orchestrating multiple containers with Docker compose</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Understanding containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">One of the key features of containers is isolation. </span><span class="koboSpan" id="kobo.2.2">In this section, we'll establish a proper understanding of this powerful tool by looking at how a container achieves isolation and why this matters in the software development life cycle.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Resource isolation</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When an application launches, it consumes CPU time, occupies memory space, links to its dependent libraries, writes to the disk, transmits packets, and may access other devices as well. </span><span class="koboSpan" id="kobo.2.2">Everything it uses up is a kind of resource, which is shared by all the programs on the same host. </span><span class="koboSpan" id="kobo.2.3">To increase the efficiency of resource utilization, we may try to put as many applications as possible on a single machine. </span><span class="koboSpan" id="kobo.2.4">However, the complexity involved in making every application work in a box effectively increases exponentially, even if we just want to run two applications, let alone work with tons of applications and machines. </span><span class="koboSpan" id="kobo.2.5">Because of this, the idea to separate the resources of a physical computing unit into isolated pieces soon became a paradigm in the industry.</span></p>
<p><span class="koboSpan" id="kobo.3.1">You may have heard of terms such as </span><strong><span class="koboSpan" id="kobo.4.1">Virtual Machines</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong><span class="koboSpan" id="kobo.6.1">VMs</span></strong><span class="koboSpan" id="kobo.7.1">), BSD jails, Solaris containers, Linux containers, Docker, and others. All of these promise us </span><span><span class="koboSpan" id="kobo.8.1">similar isolation concepts but use fundamentally distinct mechanisms, so the actual level of isolation differs.</span></span><span class="koboSpan" id="kobo.9.1"> For example, the implementation of a </span><span><span><span class="koboSpan" id="kobo.10.1">VM involves full virtualization of </span></span></span><span class="koboSpan" id="kobo.11.1">the hardware layer with a hypervisor. </span><span class="koboSpan" id="kobo.11.2">If you want to run an application on a VM, you have to start from a full operating system. </span><span class="koboSpan" id="kobo.11.3">In other words, the resources are isolated between guest operating systems running on the same hypervisor. </span><span class="koboSpan" id="kobo.11.4">In contrast, </span><span><span class="koboSpan" id="kobo.12.1">Linux</span></span><span class="koboSpan" id="kobo.13.1"> and Docker containers are built on top of Linux primitives, which means they can only run in an operating system with those capabilities. </span><span class="koboSpan" id="kobo.13.2">BSD jails and Solaris containers work in a similar fashion, but on other operating systems. </span><span class="koboSpan" id="kobo.13.3">T</span><span><span class="koboSpan" id="kobo.14.1">he following diagram illustrates t</span></span><span class="koboSpan" id="kobo.15.1">he isolation relationship of the Linux container and VMs. </span><span class="koboSpan" id="kobo.15.2">The c</span><span><span class="koboSpan" id="kobo.16.1">ontainer isolates an application on the operating system layer, while VM-based separation is achieved by the underlying hypervisor or host operating system:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img class=" image-border" src="assets/e66656ae-d26e-4df1-a84d-b5f82716b601.png" style="width:21.25em;height:18.00em;"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Linux containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A Linux container is made up of several building blocks, the two most important of which are </span><strong><span class="koboSpan" id="kobo.3.1">namespaces</span></strong><span class="koboSpan" id="kobo.4.1"> and </span><span><strong><span class="koboSpan" id="kobo.5.1">control groups</span></strong><span class="koboSpan" id="kobo.6.1"> (</span></span><strong><span class="koboSpan" id="kobo.7.1">cgroups</span></strong><span class="koboSpan" id="kobo.8.1">)</span><span><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">Both of these are Linux kernel features. </span><span class="koboSpan" id="kobo.9.3">Namespaces provide logical partitions of certain kinds of system resources, such as the mounting point (</span></span><kbd><span class="koboSpan" id="kobo.10.1">mnt</span></kbd><span><span class="koboSpan" id="kobo.11.1">), the process ID (</span></span><kbd><span class="koboSpan" id="kobo.12.1">PID</span></kbd><span><span class="koboSpan" id="kobo.13.1">), and the network (</span></span><kbd><span class="koboSpan" id="kobo.14.1">net</span></kbd><span><span class="koboSpan" id="kobo.15.1">). </span><span class="koboSpan" id="kobo.15.2">To further understand the concept of isolation, let's look at some simple examples on the</span></span> <kbd><span class="koboSpan" id="kobo.16.1">pid</span></kbd> <span><span class="koboSpan" id="kobo.17.1">namespace. </span><span class="koboSpan" id="kobo.17.2">The following examples are from Ubuntu 18.04.1 and</span></span><span class="koboSpan" id="kobo.18.1"> util-linux </span><span><span class="koboSpan" id="kobo.19.1">2.31.1.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">When we type </span><kbd><span class="koboSpan" id="kobo.21.1">ps axf</span></kbd><span class="koboSpan" id="kobo.22.1"> in our Terminal, we'll see a long list of running processes:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.23.1">$ ps axf</span><br/><span class="koboSpan" id="kobo.24.1">  PID TTY  STAT TIME COMMAND</span><br/><span class="koboSpan" id="kobo.25.1">    2 ?    </span><span class="koboSpan" id="kobo.25.2">S    0:00 [kthreadd]</span><br/><span class="koboSpan" id="kobo.26.1">    4 ?    </span><span class="koboSpan" id="kobo.26.2">I&lt;   0:00 \_ [kworker/0:0H]</span><br/><span class="koboSpan" id="kobo.27.1">    5 ?    </span><span class="koboSpan" id="kobo.27.2">I    0:00 \_ [kworker/u2:0]</span><br/><span class="koboSpan" id="kobo.28.1">    6 ?    </span><span class="koboSpan" id="kobo.28.2">I&lt;   0:00 \_ [mm_percpu_wq]</span><br/><span class="koboSpan" id="kobo.29.1">    7 ?    </span><span class="koboSpan" id="kobo.29.2">S    0:00 \_ [ksoftirqd/0]</span><br/><span class="koboSpan" id="kobo.30.1">...</span></strong></pre>
<div class="packt_infobox"><kbd><span class="koboSpan" id="kobo.31.1">ps</span></kbd><span class="koboSpan" id="kobo.32.1"> is a utility that is used to report current processes on the system. </span><kbd><span class="koboSpan" id="kobo.33.1">ps axf</span></kbd><span class="koboSpan" id="kobo.34.1"> provides a list of all processes in a forest.</span></div>
<p><span class="koboSpan" id="kobo.35.1">Let's now enter a new </span><kbd><span class="koboSpan" id="kobo.36.1">pid</span></kbd><span class="koboSpan" id="kobo.37.1"> namespace with </span><kbd><span class="koboSpan" id="kobo.38.1">unshare</span></kbd><span class="koboSpan" id="kobo.39.1">, which is able to disassociate a process resource part by part into a new namespace. </span><span class="koboSpan" id="kobo.39.2">We'll then check the processes again:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.40.1">$ sudo unshare --fork --pid --mount-proc=/proc /bin/sh</span><br/><span class="koboSpan" id="kobo.41.1"># ps axf</span><br/><span class="koboSpan" id="kobo.42.1">  PID TTY      STAT   TIME COMMAND</span><br/><span class="koboSpan" id="kobo.43.1">    1 pts/0    S      0:00 /bin/sh</span><br/><span class="koboSpan" id="kobo.44.1">    2 pts/0    R+     0:00 ps axf</span></strong></pre>
<p><span class="koboSpan" id="kobo.45.1">You'll find that the </span><kbd><span class="koboSpan" id="kobo.46.1">pid</span></kbd><span class="koboSpan" id="kobo.47.1"> of the shell process at the new namespace becomes </span><kbd><span class="koboSpan" id="kobo.48.1">1</span></kbd><span class="koboSpan" id="kobo.49.1"> and all other processes have disappeared. </span><span class="koboSpan" id="kobo.49.2">This means you've successfully created a </span><kbd><span class="koboSpan" id="kobo.50.1">pid</span></kbd><span class="koboSpan" id="kobo.51.1"> container. </span><span class="koboSpan" id="kobo.51.2">Let's switch to another session outside the namespace and list the processes again:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.52.1">$ ps axf ## from another terminal</span><br/><span class="koboSpan" id="kobo.53.1">  PID TTY    STAT TIME COMMAND</span><br/><span class="koboSpan" id="kobo.54.1"> ...</span><br/></strong><strong><span class="koboSpan" id="kobo.55.1"> 1260 pts/0  Ss   0:00 \_ -bash</span><br/><span class="koboSpan" id="kobo.56.1"> 1496 pts/0  S    0:00 | \_ sudo unshare --fork --pid --mount-proc=/proc /bin/sh</span><br/><span class="koboSpan" id="kobo.57.1"> 1497 pts/0  S    0:00 | \_ unshare --fork --pid --mount-proc=/proc /bin/sh</span><br/><span class="koboSpan" id="kobo.58.1"> 1498 pts/0  S+   0:00 | \_ /bin/sh</span><br/><span class="koboSpan" id="kobo.59.1"> 1464 pts/1  Ss   0:00 \_ -bash</span><br/><span class="koboSpan" id="kobo.60.1"> ...</span></strong></pre>
<p><span class="koboSpan" id="kobo.61.1">You can still see the other processes and your shell process within the new namespace. </span><span class="koboSpan" id="kobo.61.2">With the </span><kbd><span class="koboSpan" id="kobo.62.1">pid</span></kbd><span class="koboSpan" id="kobo.63.1"> namespace's isolation, processes </span><span><span class="koboSpan" id="kobo.64.1">inhabiting</span></span><span class="koboSpan" id="kobo.65.1"> different namespaces can't see each other. </span><span class="koboSpan" id="kobo.65.2">However, if one process uses a considerable amount of system resources, such as the memory, it could cause the system to run out of that resource and become unstable. </span><span class="koboSpan" id="kobo.65.3">In other words, an isolated process could still disrupt other processes or even crash the whole system if we don't impose resource usage restrictions on it.</span></p>
<p><span class="koboSpan" id="kobo.66.1">The following diagram illustrates the </span><kbd><span class="koboSpan" id="kobo.67.1">PID</span></kbd><span class="koboSpan" id="kobo.68.1"> namespaces and how an </span><strong><span class="koboSpan" id="kobo.69.1">Out-Of-Memory</span></strong><span class="koboSpan" id="kobo.70.1"> (</span><strong><span class="koboSpan" id="kobo.71.1">OOM</span></strong><span class="koboSpan" id="kobo.72.1">) event can affect other processes outside a child namespace. </span><span class="koboSpan" id="kobo.72.2">The numbered blocks are the processes in the system, </span><span><span class="koboSpan" id="kobo.73.1">and the numbers are their PIDs. </span><span class="koboSpan" id="kobo.73.2">Blocks with two numbers are processes created with the child namespace, where the second number represents their PIDs in the child</span></span><span><span class="koboSpan" id="kobo.74.1"> namespace. </span><span class="koboSpan" id="kobo.74.2">In the upper part of the diagram, there's still free memory available in the system. </span><span class="koboSpan" id="kobo.74.3">Later on, however, in the lower part of the diagram, the processes in the child namespace exhaust the remaining memory in the system. </span><span class="koboSpan" id="kobo.74.4">Due to the lack of free memory, the host kernel then starts the OOM killer to release memory, the victims of which are likely to be processes outside the child namespace. </span><span class="koboSpan" id="kobo.74.5">In the example here, processes</span></span> <strong><span class="koboSpan" id="kobo.75.1">8</span></strong> <span><span class="koboSpan" id="kobo.76.1">and</span></span> <strong><span class="koboSpan" id="kobo.77.1">13</span></strong> <span><span class="koboSpan" id="kobo.78.1">in the system are killed:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.79.1"><img class=" image-border" src="assets/f06dbc4f-0da3-43f6-a512-9f76754d83b6.png" style="width:28.08em;height:40.75em;"/></span></div>
<p><span class="koboSpan" id="kobo.80.1">In light of this, </span><kbd><span class="koboSpan" id="kobo.81.1">cgroups</span></kbd><span class="koboSpan" id="kobo.82.1"> is utilized here to limit resource usage. </span><span class="koboSpan" id="kobo.82.2">Like namespaces, this can impose constraints on different kinds of system resources. </span><span class="koboSpan" id="kobo.82.3">Let's continue from our </span><kbd><span class="koboSpan" id="kobo.83.1">pid</span></kbd><span class="koboSpan" id="kobo.84.1"> namespace, generate some loadon the CPU with </span><kbd><span class="koboSpan" id="kobo.85.1">yes &gt; /dev/null</span></kbd><span class="koboSpan" id="kobo.86.1">, and then monitor it with </span><kbd><span class="koboSpan" id="kobo.87.1">top</span></kbd><span class="koboSpan" id="kobo.88.1">:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.89.1">## in the container terminal</span><br/><span class="koboSpan" id="kobo.90.1"># yes &gt; /dev/null &amp; top</span><br/></strong><strong><span class="koboSpan" id="kobo.91.1">PID USER PR  NI   VIRT  RES  SHR S %CPU %MEM    TIME+ COMMAND</span><br/><span class="koboSpan" id="kobo.92.1">  2 root 20   0   7468  788  724 R 99.7  0.1  0:15.14 yes</span><br/><span class="koboSpan" id="kobo.93.1">  1 root 20   0   4628  780  712 S  0.0  0.1  0:00.00 sh</span><br/><span class="koboSpan" id="kobo.94.1">  3 root 20   0  41656 3656 3188 R  0.0  0.4  0:00.00 top</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.95.1">Our CPU load reaches 100%, as expected. </span><span class="koboSpan" id="kobo.95.2">Let's now limit it with the </span><kbd><span class="koboSpan" id="kobo.96.1">cgroup</span></kbd><span class="koboSpan" id="kobo.97.1"> CPU. </span><kbd><span class="koboSpan" id="kobo.98.1">cgroups</span></kbd><span class="koboSpan" id="kobo.99.1"> are organized as folders under </span><kbd><span class="koboSpan" id="kobo.100.1">/sys/fs/cgroup/</span></kbd><span class="koboSpan" id="kobo.101.1">. </span><span class="koboSpan" id="kobo.101.2">First, we need to switch to the host session:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.102.1">## on the host session</span><br/><span class="koboSpan" id="kobo.103.1">$ ls /sys/fs/cgroup</span><br/><span class="koboSpan" id="kobo.104.1">blkio  cpu  cpuacct  cpu,cpuacct  cpuset  devices  freezer  hugetlb  memory  net_cls  net_cls,net_prio  net_prio  perf_event  pids  rdma  systemd  unified</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.105.1">Each folder represents the resources it controls. </span><span class="koboSpan" id="kobo.105.2">It's pretty easy to create a </span><kbd><span class="koboSpan" id="kobo.106.1">cgroup</span></kbd><span class="koboSpan" id="kobo.107.1"> and control processes with it: just create a </span><span><span class="koboSpan" id="kobo.108.1">folder</span></span><span class="koboSpan" id="kobo.109.1"> under the resource type with any name and append the process IDs you'd like to control to </span><kbd><span class="koboSpan" id="kobo.110.1">tasks</span></kbd><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">Here, we want to throttle the CPU usage of our </span><kbd><span class="koboSpan" id="kobo.112.1">yes</span></kbd><span class="koboSpan" id="kobo.113.1"> process, so create a new </span><span><span class="koboSpan" id="kobo.114.1">folder</span></span><span class="koboSpan" id="kobo.115.1"> under </span><kbd><span class="koboSpan" id="kobo.116.1">cpu</span></kbd><span class="koboSpan" id="kobo.117.1"> and find out the </span><kbd><span class="koboSpan" id="kobo.118.1">PID</span></kbd><span class="koboSpan" id="kobo.119.1"> of the </span><kbd><span class="koboSpan" id="kobo.120.1">yes</span></kbd><span class="koboSpan" id="kobo.121.1"> process:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.122.1">## also on the host terminal</span><br/><span class="koboSpan" id="kobo.123.1">$ ps ax | grep yes | grep -v grep</span><br/><span class="koboSpan" id="kobo.124.1"> 1658 pts/0    R      0:42 yes</span><br/><span class="koboSpan" id="kobo.125.1">$ sudo mkdir /sys/fs/cgroup/cpu/box &amp;&amp; \</span><br/><span class="koboSpan" id="kobo.126.1">  echo 1658 | sudo tee /sys/fs/cgroup/cpu/box/tasks &gt; /dev/null</span></strong></pre>
<p><span class="koboSpan" id="kobo.127.1">We've just added </span><kbd><span class="koboSpan" id="kobo.128.1">yes</span></kbd><span class="koboSpan" id="kobo.129.1"> into the newly created </span><span><kbd><span class="koboSpan" id="kobo.130.1">box</span></kbd><span class="koboSpan" id="kobo.131.1"> </span></span><span class="koboSpan" id="kobo.132.1">CPU group, but the policy remains unset, and the process still runs without any restrictions. </span><span class="koboSpan" id="kobo.132.2">Set a limit by writing the desired number into the corresponding file and check the CPU usage again:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.133.1">$ echo 50000 | sudo tee /sys/fs/cgroup/cpu/box/cpu.cfs_quota_us &gt; /dev/null</span><br/><br/><span class="koboSpan" id="kobo.134.1">## go back to namespaced terminal, check stats with top</span></strong><strong><br/></strong><strong><span class="koboSpan" id="kobo.135.1">PID USER PR  NI   VIRT  RES  SHR S %CPU %MEM    TIME+ COMMAND</span><br/><span class="koboSpan" id="kobo.136.1">  2 root 20  0    7468  748  684 R 50.3  0.1 6:43.68  yes</span><br/><span class="koboSpan" id="kobo.137.1">  1 root 20  0    4628  784  716 S  0.0  0.1 0:00.00  sh</span><br/><span class="koboSpan" id="kobo.138.1">  3 root 20  0   41656 3636 3164 R  0.0  0.4 0:00.08  top </span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.139.1">The CPU usage is dramatically reduced, meaning that our CPU throttle works.</span></p>
<p><span class="koboSpan" id="kobo.140.1">The previous two examples elucidate how a Linux container isolates system resources. </span><span class="koboSpan" id="kobo.140.2">By putting more confinements in an application, we can build a fully isolated box, including filesystems and networks, without encapsulating an operating system within it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Containerized delivery</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">The usual way to run applications consists of the following steps:</span></p>
<ol>
<li class="mce-root"><span class="koboSpan" id="kobo.3.1">Provision machines and the corresponding infrastructure resources</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.4.1">Install an operating system</span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.5.1">Install system programs and application dependencies</span></li>
<li><span><span class="koboSpan" id="kobo.6.1">Deploy the application</span></span></li>
<li class="mce-root"><span class="koboSpan" id="kobo.7.1">Maintain the running states of the application</span></li>
</ol>
<p><span class="koboSpan" id="kobo.8.1">The entire process is tedious and complicated, which is why we usually don't want to do it manually. </span><span class="koboSpan" id="kobo.8.2">The </span><strong><span class="koboSpan" id="kobo.9.1">configuration management tool</span></strong><span class="koboSpan" id="kobo.10.1">, introduced in </span><a href="43698ec3-b595-4aa0-811a-111010763585.xhtml"><span class="koboSpan" id="kobo.11.1">Chapter 1</span></a><span class="koboSpan" id="kobo.12.1">, </span><em><span class="koboSpan" id="kobo.13.1">Introduction to DevOps</span></em><span class="koboSpan" id="kobo.14.1">, is used to eliminate most of the effort otherwise required in the delivery process. </span><span class="koboSpan" id="kobo.14.2">Its modular and code-based configuration design works well until application stacks grow complex and diverse. </span><span class="koboSpan" id="kobo.14.3">Maintaining a large configuration base is hard, especially if it's a legacy configuration that contains various hacks. </span><span class="koboSpan" id="kobo.14.4">Although changing configuration codes with the configuration management tool has a direct impact on the production environment, the configuration code often gets less attention than application code. Whenever we want to update an installed package, we would have to work in entangled and fragile dependencies between the system and application packages. </span><span class="koboSpan" id="kobo.14.5">It's not uncommon that some applications break inadvertently after upgrading an unrelated package. </span><span class="koboSpan" id="kobo.14.6">Moreover, upgrading the configuration management tool itself is also a challenging task.</span></p>
<p><span><span class="koboSpan" id="kobo.15.1">In order to overcome this problem, immutable deployments with pre-baked VM images were introduced. </span><span class="koboSpan" id="kobo.15.2">This means that whenever we carry out any updates on the system or application packages, we would build a full VM image against the change and deploy it accordingly. </span><span class="koboSpan" id="kobo.15.3">This reduces some of the complexity, because we can test changes prior to roll-outs and we're able to customize runtimes for applications that can't share the same environments. </span><span class="koboSpan" id="kobo.15.4">Nevertheless, carrying out immutable deployment with VM images is costly. </span><span class="koboSpan" id="kobo.15.5">The overhead of booting, distributing, and running a bloated VM image is significantly larger than deploying packages.</span></span></p>
<p><span><span class="koboSpan" id="kobo.16.1">The container, here, is a jigsaw piece that snugly fits the deployment needs. </span><span class="koboSpan" id="kobo.16.2">A manifestation of a container can be managed within VCS and built into a blob image, and the image can be deployed immutably as well. </span><span class="koboSpan" id="kobo.16.3">This enables developers to abstract from actual resources and infrastructure engineers to avoid dependency hell. </span><span class="koboSpan" id="kobo.16.4">Besides, since we only need to pack up the application itself and its dependent libraries, its image size would be significantly smaller than a VM's. </span><span class="koboSpan" id="kobo.16.5">Consequently, distributing a container image is more economical than distributing a VM image. </span><span class="koboSpan" id="kobo.16.6">Additionally, we already know that running a process inside a container is basically identical to running it on its Linux host and, as such, almost no overhead will be produced. </span><span class="koboSpan" id="kobo.16.7">To summarize, a container is lightweight, self-contained, and almost immutable. </span><span class="koboSpan" id="kobo.16.8">This provides clear borders to distinguish responsibilities between applications and infrastructure.</span></span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.17.1">Due to the fact that Linux containers share the same kernel, there are still potential security risks for the kernel from containers running on top of it. </span><span class="koboSpan" id="kobo.17.2">An emerging trend to address this concern is making running VMs as easy and efficient as operating system containers, such as </span><strong><span class="koboSpan" id="kobo.18.1">unikernel</span></strong><span class="koboSpan" id="kobo.19.1">-based solutions or the </span><strong><span class="koboSpan" id="kobo.20.1">Kata container</span></strong><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">Another approach is inserting a mediator layer between applications and the host kernel, such as </span><strong><span class="koboSpan" id="kobo.22.1">gVisor</span></strong><span class="koboSpan" id="kobo.23.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting started with containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are many mature container engines such as </span><strong><span class="koboSpan" id="kobo.3.1">Docker</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><a href="https://www.docker.com" target="_blank"><span class="koboSpan" id="kobo.5.1">https://www.docker.com</span></a><span class="koboSpan" id="kobo.6.1">) or </span><strong><span class="koboSpan" id="kobo.7.1">rkt</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><a href="https://coreos.com/rkt" target="_blank"><span class="koboSpan" id="kobo.9.1">https://coreos.com/rkt</span></a><span class="koboSpan" id="kobo.10.1">) that have already implemented features for production usage, so you don't need to build your own container from scratch. </span><span class="koboSpan" id="kobo.10.2">As well as this, the </span><strong><span class="koboSpan" id="kobo.11.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><a href="https://www.opencontainers.org" target="_blank"><span class="koboSpan" id="kobo.13.1">https://www.opencontainers.org</span></a><span class="koboSpan" id="kobo.14.1">), an organization formed by container industry leaders, has standardized container specifications. </span><span class="koboSpan" id="kobo.14.2">Any implementation of standards, regardless of the underlying platform, should have similar properties, as the OCI aims to provide a seamless experience of using containers across a variety of operating systems. </span><span class="koboSpan" id="kobo.14.3">In fact, the core of Docker is </span><strong><span class="koboSpan" id="kobo.15.1">containerd</span></strong><span class="koboSpan" id="kobo.16.1">, which is an OCI-compatible runtime and can be used without Docker. </span><span><span class="koboSpan" id="kobo.17.1">In this book, we'll use the Docker (community edition) container engine to fabricate our containerized applications.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installing Docker for Ubuntu</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Docker requires a 64-bit version of Bionic 18.04 LTS, Artful 17.10, Xenial 16.04 LTS, or Trusty 14.04 LTS. </span><span class="koboSpan" id="kobo.2.2">You can install Docker with </span><kbd><span class="koboSpan" id="kobo.3.1">apt-get install docker.io</span></kbd><span class="koboSpan" id="kobo.4.1">, but its updates are usually slower than the Docker official repository.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Here are the installation steps from Docker (</span><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository"><span class="koboSpan" id="kobo.6.1">https://docs.docker.com/install/linux/docker-ce/ubuntu/</span></a><span class="koboSpan" id="kobo.7.1">):</span></p>
<ol>
<li><span class="koboSpan" id="kobo.8.1">Make sure you have the packages to allow </span><kbd><span class="koboSpan" id="kobo.9.1">apt</span></kbd><span class="koboSpan" id="kobo.10.1"> repositories; </span><span><span class="koboSpan" id="kobo.11.1">if not, you can </span></span><span class="koboSpan" id="kobo.12.1">get them with the following command:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.13.1">$ sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span><br/></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.14.1">Add Docker's </span><kbd><span class="koboSpan" id="kobo.15.1">gpg</span></kbd><span class="koboSpan" id="kobo.16.1"> key and verify whether its fingerprint matches </span><kbd><span class="koboSpan" id="kobo.17.1">9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</span></kbd><span class="koboSpan" id="kobo.18.1">:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong><span class="koboSpan" id="kobo.19.1">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo apt-key fingerprint 0EBFCD88 </span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.20.1">Set up the repository of the </span><kbd><span class="koboSpan" id="kobo.21.1">amd64</span></kbd><span class="koboSpan" id="kobo.22.1"> arch:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.23.1">$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" </span></strong></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.24.1">Update the package index and install Docker CE:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong><span class="koboSpan" id="kobo.25.1"> $ sudo apt-get update &amp;&amp; sudo apt-get install docker-ce</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installing Docker for CentOS</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><span><span class="koboSpan" id="kobo.3.1">64-bit version of </span></span><span><span class="koboSpan" id="kobo.4.1">CentOS 7 is required to run Docker. </span><span class="koboSpan" id="kobo.4.2">You can get the Docker package from CentOS's repository via</span></span> <kbd><span class="koboSpan" id="kobo.5.1">sudo yum install docker</span></kbd><span><span class="koboSpan" id="kobo.6.1">, but this might be an older version. </span><span class="koboSpan" id="kobo.6.2">Again, the installation steps from Docker's official guide (</span></span><a href="https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository"><span class="koboSpan" id="kobo.7.1">https://docs.docker.com/install/linux/docker-ce/centos/</span></a><span><span class="koboSpan" id="kobo.8.1">) are as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.9.1">Install the utility to enable </span><kbd><span class="koboSpan" id="kobo.10.1">yum</span></kbd><span class="koboSpan" id="kobo.11.1"> to use the extra repository:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.12.1">$ sudo yum install -y yum-utils  </span></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.13.1">Set up Docker's repository:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong><span class="koboSpan" id="kobo.14.1">$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo </span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.15.1">Install Docker CE and start it. </span><span class="koboSpan" id="kobo.15.2">If key verification is prompted, make sure it matches </span><kbd><span class="koboSpan" id="kobo.16.1">060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35</span></kbd><span class="koboSpan" id="kobo.17.1">:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong><span class="koboSpan" id="kobo.18.1">$ sudo yum install docker-ce</span><br/><span class="koboSpan" id="kobo.19.1">$ sudo systemctl start docker</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Installing Docker for macOS</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Docker wraps a micro Linux with the hypervisor framework to build a native application on macOS, which means we don't need third-party virtualization tools to use Docker on a Mac. </span><span class="koboSpan" id="kobo.2.2">To benefit from the hypervisor framework, you must upgrade your macOS to version 10.10.3 or more:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Download the Docker package and install it: </span><a href="https://download.docker.com/mac/stable/Docker.dmg"><span class="URLPACKT"><span class="koboSpan" id="kobo.4.1">https://download.docker.com/mac/stable/Docker.dmg</span></span></a><span class="koboSpan" id="kobo.5.1">.</span></li>
</ol>
<div class="packt_tip"><span class="koboSpan" id="kobo.6.1">Docker for Windows requires no third-party tools either. </span><span class="koboSpan" id="kobo.6.2">Check for the installation guide at the following link: </span><a href="https://docs.docker.com/docker-for-windows/install" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://docs.docker.com/docker-for-windows/install</span></span></a><span class="koboSpan" id="kobo.8.1">.</span></div>
<ol start="2">
<li><span class="koboSpan" id="kobo.9.1">You're now in Docker. </span><span class="koboSpan" id="kobo.9.2">Try creating and running your very first Docker container. </span><span class="koboSpan" id="kobo.9.3">Run the command with </span><kbd><span class="koboSpan" id="kobo.10.1">sudo</span></kbd><span class="koboSpan" id="kobo.11.1"> if you're on Linux:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong><span class="koboSpan" id="kobo.12.1">$ docker run alpine ls</span><br/><span class="koboSpan" id="kobo.13.1">bin dev etc home lib media mnt proc root run sbin srv sys tmp usr var</span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.14.1">You'll see that you're under a </span><kbd><span class="koboSpan" id="kobo.15.1">root</span></kbd><span class="koboSpan" id="kobo.16.1"> directory instead of your current one. </span><span class="koboSpan" id="kobo.16.2">Let's check the process list again:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong><span class="koboSpan" id="kobo.17.1">$ docker run alpine ps aux</span><br/><span class="koboSpan" id="kobo.18.1">PID   USER     TIME  COMMAND</span><br/><span class="koboSpan" id="kobo.19.1">    1 root      0:00 ps aux</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.20.1">It's isolated, as expected. </span><span class="koboSpan" id="kobo.20.2">You're now all ready to work with the container.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.21.1">Alpine is a Linux distribution. </span><span class="koboSpan" id="kobo.21.2">Since it's really small in size, many people use it as their base image to build their application container. </span><span class="koboSpan" id="kobo.21.3">Do note, however, that it still has a few differences from mainstream Linux distributions. </span><span class="koboSpan" id="kobo.21.4">For example, Alpine uses </span><kbd><span class="koboSpan" id="kobo.22.1">musl libc</span></kbd><span class="koboSpan" id="kobo.23.1">, while most </span><span><span class="koboSpan" id="kobo.24.1">distributions</span></span><span class="koboSpan" id="kobo.25.1"> use </span><kbd><span class="koboSpan" id="kobo.26.1">glibc</span></kbd><span class="koboSpan" id="kobo.27.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The life cycle of a container</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Using containers isn't as intuitive as most of the tools that we're used to working with, so we'll need to change the way we work. </span><span class="koboSpan" id="kobo.2.2">In this section, we'll go through how to use Docker so that we're able to benefit from containers.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The basics of Docker</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When </span><kbd><span class="koboSpan" id="kobo.3.1">docker run alpine ls</span></kbd><span class="koboSpan" id="kobo.4.1"> is executed, Docker carries out the following steps behind the scenes:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">It finds the </span><kbd><span class="koboSpan" id="kobo.6.1">alpine</span></kbd> <span><span class="koboSpan" id="kobo.7.1">image </span></span><span class="koboSpan" id="kobo.8.1">locally. </span><span class="koboSpan" id="kobo.8.2">If this is not found, Docker will try to locate and pull it from the public Docker registry to the local image storage.</span></li>
<li><span class="koboSpan" id="kobo.9.1">It extracts the image and creates a container accordingly.</span></li>
<li><span class="koboSpan" id="kobo.10.1">It executes the entry point defined in the image with commands, which are the arguments after the image name. </span><span class="koboSpan" id="kobo.10.2">In this example, the argument is </span><kbd><span class="koboSpan" id="kobo.11.1">ls</span></kbd><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">By default, the entry point is </span><kbd><span class="koboSpan" id="kobo.13.1">/bin/sh -c</span></kbd><span class="koboSpan" id="kobo.14.1"> on Linux-based Docker.</span></li>
<li><span class="koboSpan" id="kobo.15.1">When the entry point process is finished, the container then exits.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.16.1">An image is an immutable bundle of code, libraries, configurations, and everything else we want to put in it. </span><span class="koboSpan" id="kobo.16.2">A container is an instance of an image, which is executed during runtime. </span><span class="koboSpan" id="kobo.16.3">You can use the </span><kbd><span class="koboSpan" id="kobo.17.1">docker inspect IMAGE</span></kbd><span class="koboSpan" id="kobo.18.1"> and </span><kbd><span class="koboSpan" id="kobo.19.1">docker inspect CONTAINER</span></kbd><span class="koboSpan" id="kobo.20.1"> commands to see the difference between an image and a container.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Anything launched with </span><kbd><span class="koboSpan" id="kobo.22.1">docker run</span></kbd><span class="koboSpan" id="kobo.23.1"> would take the </span><span><span class="koboSpan" id="kobo.24.1">foreground</span></span><span><span class="koboSpan" id="kobo.25.1">; the </span></span><kbd><span class="koboSpan" id="kobo.26.1">-d</span></kbd> <span><span class="koboSpan" id="kobo.27.1">option </span></span><span><span class="koboSpan" id="kobo.28.1">(</span></span><kbd><span class="koboSpan" id="kobo.29.1">--detach</span></kbd><span><span class="koboSpan" id="kobo.30.1">) enables us to run a container in the detached mode. </span><span class="koboSpan" id="kobo.30.2">Sometimes, we may need to enter an active container to check the image or update something inside it. </span><span class="koboSpan" id="kobo.30.3">To do this, we could use the </span></span><kbd><span class="koboSpan" id="kobo.31.1">-i</span></kbd> <span><span class="koboSpan" id="kobo.32.1">and</span></span> <kbd><span class="koboSpan" id="kobo.33.1">-t</span></kbd><span><span class="koboSpan" id="kobo.34.1"> </span></span><span><span class="koboSpan" id="kobo.35.1">options </span></span><span><span class="koboSpan" id="kobo.36.1">(</span></span><kbd><span class="koboSpan" id="kobo.37.1">--interactive</span></kbd> <span><span class="koboSpan" id="kobo.38.1">and</span></span> <kbd><span class="koboSpan" id="kobo.39.1">--tty</span></kbd><span><span class="koboSpan" id="kobo.40.1">). </span><span class="koboSpan" id="kobo.40.2">If we want to interact with a detached container, we can use the </span></span><kbd><span class="koboSpan" id="kobo.41.1">exec</span></kbd> <span><span class="koboSpan" id="kobo.42.1">and</span></span> <kbd><span class="koboSpan" id="kobo.43.1">attach</span></kbd> <span><span class="koboSpan" id="kobo.44.1">command: the</span></span> <kbd><span class="koboSpan" id="kobo.45.1">exec</span></kbd> <span><span class="koboSpan" id="kobo.46.1">command allows us to run a process in a running container, while </span></span><kbd><span class="koboSpan" id="kobo.47.1">attach</span></kbd> <span><span class="koboSpan" id="kobo.48.1">works as its name suggests. </span><span class="koboSpan" id="kobo.48.2">The following example demonstrates how to use these commands:</span></span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.49.1">$ docker run busybox /bin/sh -c "while :;do echo </span></strong><strong><span class="koboSpan" id="kobo.50.1">'meow~';sleep 1;done"</span><br/><span class="koboSpan" id="kobo.51.1">meow~</span><br/><span class="koboSpan" id="kobo.52.1">meow~</span><br/><span class="koboSpan" id="kobo.53.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.54.1">Your Terminal should now be flooded with </span><kbd><span class="koboSpan" id="kobo.55.1">meow~</span></kbd><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">Switch to another Terminal and run </span><kbd><span class="koboSpan" id="kobo.57.1">docker ps</span></kbd><span class="koboSpan" id="kobo.58.1">, a command to get the status of containers, to find out the name and the ID of th</span><span><span><span class="koboSpan" id="kobo.59.1">e</span></span></span><span class="koboSpan" id="kobo.60.1"> container. </span><span class="koboSpan" id="kobo.60.2">Here, both the name and the ID are generated by Docker, and you can access a container with either of them:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.61.1">$ docker ps</span><br/><span class="koboSpan" id="kobo.62.1">CONTAINER ID    IMAGE    (omitted)  STATUS       PORTS   NAMES</span><br/><span class="koboSpan" id="kobo.63.1">d51972e5fc8c    busybox     ...     </span><span class="koboSpan" id="kobo.63.2">Up 3 seconds         agitated_banach</span><br/><br/><span class="koboSpan" id="kobo.64.1">$ docker exec -it d51972e5fc8c /bin/sh</span><br/><span class="koboSpan" id="kobo.65.1">/ # ps</span><br/><span class="koboSpan" id="kobo.66.1">PID   USER     TIME   COMMAND</span><br/></strong><strong><span class="koboSpan" id="kobo.67.1">    1 root      0:00 /bin/sh -c while :;do echo 'meow~';sleep 1;done</span><br/><span class="koboSpan" id="kobo.68.1">   19 root      0:00 /bin/sh</span><br/><span class="koboSpan" id="kobo.69.1">   30 root      0:00 sleep 1</span><br/><span class="koboSpan" id="kobo.70.1">   31 root      0:00 ps</span><br/><span class="koboSpan" id="kobo.71.1">/ # kill -s 2 1</span><br/><span class="koboSpan" id="kobo.72.1">## container terminated</span><br/></strong></pre>
<div class="packt_tip"><span><span class="koboSpan" id="kobo.73.1">As a matter of convenience, the name can be assigned upon </span><kbd><span class="koboSpan" id="kobo.74.1">create</span></kbd><span class="koboSpan" id="kobo.75.1"> or </span><kbd><span class="koboSpan" id="kobo.76.1">run</span></kbd><span class="koboSpan" id="kobo.77.1"> with the </span><kbd><span class="koboSpan" id="kobo.78.1">--name</span></kbd><span class="koboSpan" id="kobo.79.1"> flag.</span></span></div>
<p><span><span class="koboSpan" id="kobo.80.1">Once we access the container and inspect its processes, we'll see two shells: one is meowing and the other is where we are. </span><span class="koboSpan" id="kobo.80.2">Kill the first shell with </span></span><kbd><span class="koboSpan" id="kobo.81.1">kill -s 2 1</span></kbd><span><span class="koboSpan" id="kobo.82.1"> inside the container and we'll see the whole container stopped as the entry point is exited. </span></span><span class="koboSpan" id="kobo.83.1">Finally, we'll list the stopped containers with </span><kbd><span class="koboSpan" id="kobo.84.1">docker ps -a</span></kbd><span class="koboSpan" id="kobo.85.1"> and clean them up with </span><kbd><span class="koboSpan" id="kobo.86.1">docker rm CONTAINER_NAME</span></kbd><span class="koboSpan" id="kobo.87.1"> or </span><kbd><span class="koboSpan" id="kobo.88.1">docker rm CONTAINER_ID</span></kbd><span class="koboSpan" id="kobo.89.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.90.1">$ docker ps -a</span></strong><br/><strong><span class="koboSpan" id="kobo.91.1">CONTAINER ID     IMAGE    (omitted)  STATUS       PORTS   NAMES</span></strong><br/><strong><span class="koboSpan" id="kobo.92.1">d51972e5fc8c     busybox     ...     </span><span class="koboSpan" id="kobo.92.2">Exited (130)         agitated_banach</span><br/><span class="koboSpan" id="kobo.93.1">$ docker rm d51972e5fc8c ## "agitated_banach" also works</span><br/><span class="koboSpan" id="kobo.94.1">d51972e5fc8c</span><br/><span class="koboSpan" id="kobo.95.1">$ docker ps -a</span><br/><span class="koboSpan" id="kobo.96.1">CONTAINER ID     IMAGE    (omitted)  STATUS       PORTS   NAMES</span><br/><span class="koboSpan" id="kobo.97.1">## nothing left now</span></strong></pre>
<p><span class="koboSpan" id="kobo.98.1">Since Docker 1.13, the </span><kbd><span class="koboSpan" id="kobo.99.1">docker system prune</span></kbd><span class="koboSpan" id="kobo.100.1"> command has been introduced, which helps us clean up stopped containers and occupied resources with ease.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.101.1">The </span><kbd><span class="koboSpan" id="kobo.102.1">PID 1</span></kbd><span class="koboSpan" id="kobo.103.1"> process is very special in UNIX-like operating systems. </span><span class="koboSpan" id="kobo.103.2">Regardless of what kind of process it is, it should reclaim its exited children and not take the </span><kbd><span class="koboSpan" id="kobo.104.1">SIGKILL</span></kbd><span class="koboSpan" id="kobo.105.1"> signal. </span><span class="koboSpan" id="kobo.105.2">That's why the previous example uses </span><kbd><span class="koboSpan" id="kobo.106.1">SIGINT</span></kbd><span class="koboSpan" id="kobo.107.1"> (2) instead of </span><kbd><span class="koboSpan" id="kobo.108.1">SIGKILL</span></kbd><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">Besides, most of the entry processes in a container don't handle terminated children, which may cause lots of un-reaped zombie processes in the system. </span><span class="koboSpan" id="kobo.109.3">If there's a need to run Docker containers in production without Kubernetes, use the </span><kbd><span class="koboSpan" id="kobo.110.1">--init</span></kbd><span class="koboSpan" id="kobo.111.1"> flag upon </span><kbd><span class="koboSpan" id="kobo.112.1">docker run</span></kbd><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">This injects a </span><kbd><span class="koboSpan" id="kobo.114.1">PID 1</span></kbd><span class="koboSpan" id="kobo.115.1"> process, which handles its terminated </span><span><span class="koboSpan" id="kobo.116.1">children correctly,</span></span><span class="koboSpan" id="kobo.117.1"> into the container to run.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Layers, images, containers, and volumes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We know that an image is immutable and a container is ephemeral, and we know how to run an image as a container. </span><span class="koboSpan" id="kobo.2.2">Nevertheless, we are still missing some information</span><span><span class="koboSpan" id="kobo.3.1"> </span></span><span><span class="koboSpan" id="kobo.4.1">with regard to packing an image.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">An image is a read-only stack that consists of one or more layers, and a layer is a collection of files and directories in the filesystem. </span><span class="koboSpan" id="kobo.5.2">To improve disk space utilization, layers aren't locked to just one image but are shared among images, which means that Docker simply stores one copy of a base image locally, regardless of how many images are derived from it. </span><span class="koboSpan" id="kobo.5.3">You can utilize the </span><kbd><span class="koboSpan" id="kobo.6.1">docker history [image]</span></kbd><span class="koboSpan" id="kobo.7.1"> command to understand how an image is built. </span><span class="koboSpan" id="kobo.7.2">For example, you will see that Alpine has only one layer if you check it with </span><kbd><span class="koboSpan" id="kobo.8.1">docker history alpine</span></kbd><span class="koboSpan" id="kobo.9.1">.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Whenever a container is created, it adds a thin, writable layer on top of the base image. </span><span class="koboSpan" id="kobo.10.2">Docker adopts the </span><strong><span class="koboSpan" id="kobo.11.1">Copy-On-Write</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong><span class="koboSpan" id="kobo.13.1">COW</span></strong><span class="koboSpan" id="kobo.14.1">) strategy on the thin layer. </span><span class="koboSpan" id="kobo.14.2">This means that a container reads the layers of the base image where the target files are stored and copies the file to its own writable layer if the file is modified. </span><span class="koboSpan" id="kobo.14.3">This approach prevents containers that are created from the same image from intervening with each other. </span><span class="koboSpan" id="kobo.14.4">The </span><kbd><span class="koboSpan" id="kobo.15.1">docker diff [CONTAINER]</span></kbd><span class="koboSpan" id="kobo.16.1"> command shows the difference between the container and its base image in terms of their filesystem states. </span><span class="koboSpan" id="kobo.16.2">For example, if </span><kbd><span class="koboSpan" id="kobo.17.1">/etc/hosts</span></kbd><span class="koboSpan" id="kobo.18.1"> in the base image is modified, Docker copies the file to the writable layer, and it'll be the only file in the output of </span><kbd><span class="koboSpan" id="kobo.19.1">docker diff</span></kbd><span class="koboSpan" id="kobo.20.1">.</span></p>
<p><span class="koboSpan" id="kobo.21.1">The following diagram illustrates the hierarchical structure of Docker images:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img class="alignnone size-full wp-image-161 image-border" src="assets/fabdc429-ba54-4123-9bf4-3ab0d77e337b.png" style="width:17.92em;height:17.42em;"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">It's important to note that data in the writable layer is deleted along with its container. </span><span class="koboSpan" id="kobo.23.2">To persist data, you commit the container layer </span><span><span class="koboSpan" id="kobo.24.1">as a new image </span></span><span><span class="koboSpan" id="kobo.25.1">with the</span></span> <kbd><span class="koboSpan" id="kobo.26.1">docker commit [CONTAINER]</span></kbd> <span><span class="koboSpan" id="kobo.27.1">command or mount data volumes into a container.</span></span></p>
<p><span><span class="koboSpan" id="kobo.28.1">A data volume allows a container to carry out reading and writing operations, bypassing Docker's filesystem.</span></span><span class="koboSpan" id="kobo.29.1"> It can either be on a host's directory or in other storage, such as Ceph or GlusterFS. </span><span class="koboSpan" id="kobo.29.2">Therefore, any disk I/O against the volume can operate at native speeds depending on the underlying storage. </span><span class="koboSpan" id="kobo.29.3">Since the data is persistent outside a container, it can be reused and shared by multiple containers. </span><span class="koboSpan" id="kobo.29.4">Mounting a volume is done by specifying the </span><kbd><span class="koboSpan" id="kobo.30.1">-v</span></kbd><span class="koboSpan" id="kobo.31.1"> (</span><kbd><span class="koboSpan" id="kobo.32.1">--volume</span></kbd><span class="koboSpan" id="kobo.33.1">) flag with </span><kbd><span class="koboSpan" id="kobo.34.1">docker run</span></kbd><span class="koboSpan" id="kobo.35.1"> or </span><kbd><span class="koboSpan" id="kobo.36.1">docker create</span></kbd><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">The following example mounts a volume under </span><kbd><span class="koboSpan" id="kobo.38.1">/chest</span></kbd><span class="koboSpan" id="kobo.39.1"> in the container and leaves a file there. </span><span class="koboSpan" id="kobo.39.2">Afterwards, we use </span><kbd><span class="koboSpan" id="kobo.40.1">docker inspect</span></kbd><span class="koboSpan" id="kobo.41.1"> to locate the data volume:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.42.1">$ docker run --name demo -v /chest alpine touch /chest/coins</span><br/><span class="koboSpan" id="kobo.43.1">$ docker inspect demo ## or filter outputs with --format '{{json .Mounts}}'</span><br/><span class="koboSpan" id="kobo.44.1">...</span><br/></strong><strong><span class="koboSpan" id="kobo.45.1">"Mounts": [</span><br/><span class="koboSpan" id="kobo.46.1">    {</span><br/><span class="koboSpan" id="kobo.47.1">        "Type": "volume",</span><br/><span class="koboSpan" id="kobo.48.1">        "Name":"(hash-digits)",</span><br/><span class="koboSpan" id="kobo.49.1">        "Source": "/var/lib/docker/volumes/(hash-digits)/_data",</span><br/><span class="koboSpan" id="kobo.50.1">        "Destination": "/chest",</span><br/><span class="koboSpan" id="kobo.51.1">        "Driver": "local",</span><br/><span class="koboSpan" id="kobo.52.1">        "Mode": "",</span><br/><span class="koboSpan" id="kobo.53.1">        "RW": true,</span><br/><span class="koboSpan" id="kobo.54.1">        "Propagation": ""</span><br/><span class="koboSpan" id="kobo.55.1">    }</span><br/><span class="koboSpan" id="kobo.56.1">],</span><br/><span class="koboSpan" id="kobo.57.1">...</span><br/><span class="koboSpan" id="kobo.58.1">$ ls /var/lib/docker/volumes/(hash-digits)/_data</span><br/><span class="koboSpan" id="kobo.59.1">coins</span></strong></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.60.1">The default </span><kbd><span class="koboSpan" id="kobo.61.1">tty</span></kbd><span class="koboSpan" id="kobo.62.1"> path of the micro Linux provided by Docker CE on macOS can be found in the following location:</span><br/>
<kbd><span class="koboSpan" id="kobo.63.1">~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty</span></kbd><span class="koboSpan" id="kobo.64.1">.</span><br/><span class="koboSpan" id="kobo.65.1">
You can attach to it with </span><kbd><span class="koboSpan" id="kobo.66.1">screen</span></kbd><span class="koboSpan" id="kobo.67.1">.</span></div>
<p><span class="koboSpan" id="kobo.68.1">One use case of data volumes is sharing data between containers. </span><span class="koboSpan" id="kobo.68.2">To do this, we first create a container and mount volumes on it, and then reference the volume with the </span><kbd><span class="koboSpan" id="kobo.69.1">--volumes-from</span></kbd><span class="koboSpan" id="kobo.70.1"> flag when launching other containers. </span><span class="koboSpan" id="kobo.70.2">The following examples create a container with a data volume, </span><kbd><span class="koboSpan" id="kobo.71.1">/share-vol</span></kbd><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">Container A can put a file into it, and container B can read it:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.73.1">$ docker create --name box -v /share-vol alpine nop</span><br/><span class="koboSpan" id="kobo.74.1">7ed7c0c4426df53275c0e41798923121093b67d41bec17d50756250508f7b897</span><br/><span class="koboSpan" id="kobo.75.1">$ docker run --name AA --volumes-from box alpine touch /share-vol/wine</span><br/><span class="koboSpan" id="kobo.76.1">$ docker run --name BB --volumes-from box alpine ls /share-vol</span><br/><span class="koboSpan" id="kobo.77.1">wine</span></strong></pre>
<p><span class="koboSpan" id="kobo.78.1">In addition, data volumes can be mounted under a given </span><kbd><span class="koboSpan" id="kobo.79.1">host</span></kbd><span class="koboSpan" id="kobo.80.1"> path, and of course the data inside is persistent:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.81.1">$ docker run --name hi -v $(pwd)/host/dir:/data alpine touch /data/hi</span><br/><span class="koboSpan" id="kobo.82.1">$ docker rm hi</span><br/><span class="koboSpan" id="kobo.83.1">$ ls $(pwd)/host/dir</span><br/><span class="koboSpan" id="kobo.84.1">hi</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Distributing images</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A registry is a service that stores, manages, and distributes images. </span><span class="koboSpan" id="kobo.2.2">Public services, such as Docker Hub (</span><a href="https://hub.docker.com" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.3.1">https://hub.docker.com</span></span></a><span class="koboSpan" id="kobo.4.1">) and Quay (</span><a href="https://quay.io" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.5.1">https://quay.io</span></span></a><span class="koboSpan" id="kobo.6.1">), collect all kinds of pre-built images of popular tools, such as Ubuntu, </span><kbd><span class="koboSpan" id="kobo.7.1">nginx</span></kbd><span class="koboSpan" id="kobo.8.1">, and custom images from other developers. </span><span class="koboSpan" id="kobo.8.2">The Alpine Linux tool we've used many times already is actually pulled from Docker Hub (</span><a href="https://hub.docker.com/_/alpine" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.9.1">https://hub.docker.com/_/alpine</span></span></a><span class="koboSpan" id="kobo.10.1">). </span><span class="koboSpan" id="kobo.10.2">You can upload your own tool onto these services and share them with everyone else as well.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.11.1">If you need a private registry, but for some reason you don't want to subscribe to the paid plans of registry service providers, you can always set up one on your own with the Docker Registry (</span><a href="https://hub.docker.com/_/registry" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.12.1">https://hub.docker.com/_/registry</span></span></a><span class="koboSpan" id="kobo.13.1">). </span><span class="koboSpan" id="kobo.13.2">Other popular registry service providers include Harbor (</span><a href="https://goharbor.io/"><span class="koboSpan" id="kobo.14.1">https://goharbor.io/</span></a><span class="koboSpan" id="kobo.15.1">) and Portus (</span><a href="http://port.us.org/"><span class="koboSpan" id="kobo.16.1">http://port.us.org/</span></a><span class="koboSpan" id="kobo.17.1">).</span></div>
<p><span class="koboSpan" id="kobo.18.1">Before provisioning a container, Docker will try to locate the specified image in a rule indicated in the image name. </span><span class="koboSpan" id="kobo.18.2">An image name consists of three sections, </span><kbd><span class="koboSpan" id="kobo.19.1">[registry/]name[:tag]</span></kbd><span class="koboSpan" id="kobo.20.1">, and it's resolved with the following rules:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">If the </span><kbd><span class="koboSpan" id="kobo.22.1">registry</span></kbd><span class="koboSpan" id="kobo.23.1"> field is left out, Docker searches for the name on Docker Hub</span></li>
<li><span class="koboSpan" id="kobo.24.1">If the </span><kbd><span class="koboSpan" id="kobo.25.1">registry</span></kbd><span class="koboSpan" id="kobo.26.1"> field is a registry server, Docker searches the name for it</span></li>
<li><span class="koboSpan" id="kobo.27.1">You can have more than one slash in a name</span></li>
<li><span class="koboSpan" id="kobo.28.1">The tag defaults to </span><kbd><span class="koboSpan" id="kobo.29.1">latest</span></kbd><span class="koboSpan" id="kobo.30.1"> if it's omitted</span></li>
</ul>
<p><span class="koboSpan" id="kobo.31.1">For example, an image name such as </span><kbd><span class="koboSpan" id="kobo.32.1">gcr.io/google-containers/guestbook:v3</span></kbd><span class="koboSpan" id="kobo.33.1"> instructs Docker to download </span><kbd><span class="koboSpan" id="kobo.34.1">v3</span></kbd><span class="koboSpan" id="kobo.35.1"> of </span><kbd><span class="koboSpan" id="kobo.36.1">google-containers/guestbook</span></kbd><span class="koboSpan" id="kobo.37.1"> from </span><kbd><span class="koboSpan" id="kobo.38.1">gcr.io</span></kbd><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">Likewise, if you want to push an image to a registry, tag your image in the same manner and push it with </span><kbd><span class="koboSpan" id="kobo.40.1">docker push [IMAGE]</span></kbd><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">To list the images you currently own locally, use </span><kbd><span class="koboSpan" id="kobo.42.1">docker images</span></kbd><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">You can remove an image with </span><kbd><span class="koboSpan" id="kobo.44.1">docker rmi [IMAGE]</span></kbd><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">The following example shows how to work between different registries: downloading an </span><kbd><span class="koboSpan" id="kobo.46.1">nginx</span></kbd><span class="koboSpan" id="kobo.47.1"> image from Docker Hub, tagging it to a private registry path, and pushing it accordingly. </span><span class="koboSpan" id="kobo.47.2">The private registry is hosted locally with </span><kbd><span class="koboSpan" id="kobo.48.1">docker run -p 5000:5000 registry</span></kbd><span class="koboSpan" id="kobo.49.1">.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.50.1">Here, we use the registry mentioned previously with the most basic setup. </span><span class="koboSpan" id="kobo.50.2">A more detailed guide about the deployment can be found at the following link: </span><a href="https://docs.docker.com/registry/deploying/"><span class="koboSpan" id="kobo.51.1">https://docs.docker.com/registry/deploying/</span></a><span class="koboSpan" id="kobo.52.1">.</span></div>
<p><span class="koboSpan" id="kobo.53.1">Notice that although the default tag is </span><kbd><span class="koboSpan" id="kobo.54.1">latest</span></kbd><span class="koboSpan" id="kobo.55.1">, you have to tag and </span><kbd><span class="koboSpan" id="kobo.56.1">push</span></kbd><span class="koboSpan" id="kobo.57.1"> it explicitly:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.58.1">$ docker pull nginx</span><br/><span class="koboSpan" id="kobo.59.1">Using default tag: latest</span><br/><span class="koboSpan" id="kobo.60.1">latest: Pulling from library/nginx</span><br/><span class="koboSpan" id="kobo.61.1">802b00ed6f79: Pull complete</span><br/><span class="koboSpan" id="kobo.62.1">...</span><br/><span class="koboSpan" id="kobo.63.1">Status: Downloaded newer image for nginx:latest</span><br/><br/><span class="koboSpan" id="kobo.64.1">$ docker tag nginx localhost:5000/comps/prod/nginx:1.15</span><br/><span class="koboSpan" id="kobo.65.1">$ docker push localhost:5000/comps/prod/nginx:1.15</span><br/><span class="koboSpan" id="kobo.66.1">The push refers to repository [localhost:5000/comps/prod/nginx]</span><br/><span class="koboSpan" id="kobo.67.1">...</span><br/><span class="koboSpan" id="kobo.68.1">8b15606a9e3e: Pushed</span><br/><span class="koboSpan" id="kobo.69.1">1.15: digest: sha256:(64-digits-hash) size: 948</span><br/><span class="koboSpan" id="kobo.70.1">$ docker tag nginx localhost:5000/comps/prod/nginx</span><br/><span class="koboSpan" id="kobo.71.1">$ docker push localhost:5000/comps/prod/nginx</span><br/><span class="koboSpan" id="kobo.72.1">The push refers to repository [localhost:5000/comps/prod/nginx]</span><br/><span class="koboSpan" id="kobo.73.1">...</span><br/><span class="koboSpan" id="kobo.74.1">8b15606a9e3e: Layer already exists</span><br/><span class="koboSpan" id="kobo.75.1">latest: digest: sha256:(64-digits-hash) size: 948</span></strong></pre>
<p><span class="koboSpan" id="kobo.76.1">Most registry services ask for authentications if you're going to push images. </span><kbd><span class="koboSpan" id="kobo.77.1">docker login</span></kbd><span class="koboSpan" id="kobo.78.1"> is designed for this purpose. </span><span class="koboSpan" id="kobo.78.2">For some older versions of Docker, you may </span><span><span class="koboSpan" id="kobo.79.1">sometimes</span></span><span><span class="koboSpan" id="kobo.80.1"> </span></span><span><span class="koboSpan" id="kobo.81.1">receive an </span></span><kbd><span class="koboSpan" id="kobo.82.1">image not found</span></kbd> <span><span class="koboSpan" id="kobo.83.1">error when attempting to pull an image, even though the image path is valid. </span><span class="koboSpan" id="kobo.83.2">This is likely to mean that you're unauthorized with the registry that keeps the image.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">In addition to </span><span><span class="koboSpan" id="kobo.85.1">images </span></span><span class="koboSpan" id="kobo.86.1">distributed via the registry service, there are options to dump images as a TAR archive and import them back into the local repository:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.87.1">docker commit [CONTAINER]</span></kbd><span class="koboSpan" id="kobo.88.1">: Commits the changes of the container layer into a new image</span></li>
<li><kbd><span class="koboSpan" id="kobo.89.1">docker save --output [filename] IMAGE1 IMAGE2 ...</span></kbd><span class="koboSpan" id="kobo.90.1">: Saves one or more images to a TAR archive</span></li>
<li><kbd><span class="koboSpan" id="kobo.91.1">docker load -i [filename]</span></kbd><span class="koboSpan" id="kobo.92.1">: Loads a TAR image into the local repository</span></li>
<li><kbd><span class="koboSpan" id="kobo.93.1">docker export --output [filename] [CONTAINER]</span></kbd><span class="koboSpan" id="kobo.94.1">: Exports a container's filesystem as a TAR archive</span></li>
<li><kbd><span class="koboSpan" id="kobo.95.1">docker import --output [filename] IMAGE1 IMAGE2</span></kbd><span class="koboSpan" id="kobo.96.1">: Imports an exported TAR archive</span></li>
</ul>
<p><span class="koboSpan" id="kobo.97.1">The </span><kbd><span class="koboSpan" id="kobo.98.1">commit</span></kbd><span class="koboSpan" id="kobo.99.1">, </span><kbd><span class="koboSpan" id="kobo.100.1">save</span></kbd><span class="koboSpan" id="kobo.101.1">, and </span><kbd><span class="koboSpan" id="kobo.102.1">export</span></kbd><span class="koboSpan" id="kobo.103.1"> commands look pretty much the same. </span><span class="koboSpan" id="kobo.103.2">The main difference is that a saved image preserves files in between layers even if they are to be deleted eventually. </span><span class="koboSpan" id="kobo.103.3">On the other hand, an exported image squashes all intermediate layers into one final layer. </span><span class="koboSpan" id="kobo.103.4">Another difference is that a saved image keeps metadata such as layer histories, but this isn't available with an exported image. </span><span class="koboSpan" id="kobo.103.5">As a result, the exported image is usually smaller in size.</span></p>
<p><span class="koboSpan" id="kobo.104.1">The following diagram depicts the relationship of states between a container and the images. </span><span class="koboSpan" id="kobo.104.2">The captions on the arrows are the corresponding Docker </span><span><span class="koboSpan" id="kobo.105.1">sub-commands</span></span><span><span class="koboSpan" id="kobo.106.1">:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.107.1"><img class="alignnone size-full wp-image-264 image-border" src="assets/7a5cfc93-ca67-4258-9142-e2d84b831e71.png" style="width:33.67em;height:22.75em;"/></span></div>
<div class="packt_infobox"><span class="koboSpan" id="kobo.108.1">The container technology is tightly bound to operating system features, which means an image built for one platform can't run on another platform without recompiling a new image on the target platform. </span><span class="koboSpan" id="kobo.108.2">To make this simpler, Docker introduced the Image Manifest, which supports multi-arch builds. </span><span class="koboSpan" id="kobo.108.3">We won't discuss multi-arch builds in this book further, but you can find more information at the following link: </span><a href="https://docs.docker.com/edge/engine/reference/commandline/manifest/"><span class="koboSpan" id="kobo.109.1">https://docs.docker.com/edge/engine/reference/commandline/manifest/</span></a><span class="koboSpan" id="kobo.110.1">. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Connecting containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Docker provides three kinds of networks to manage communications between containers and the hosts, namely </span><kbd><span class="koboSpan" id="kobo.3.1">bridge</span></kbd><span class="koboSpan" id="kobo.4.1">, </span><kbd><span class="koboSpan" id="kobo.5.1">host</span></kbd><span class="koboSpan" id="kobo.6.1">, and </span><kbd><span class="koboSpan" id="kobo.7.1">none</span></kbd><span class="koboSpan" id="kobo.8.1">:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.9.1">$ docker network ls</span><br/><span class="koboSpan" id="kobo.10.1">NETWORK ID          NAME                DRIVER              SCOPE</span><br/><span class="koboSpan" id="kobo.11.1">8bb41db6b13e        bridge              bridge              local</span><br/><span class="koboSpan" id="kobo.12.1">4705332cb39e        host                host                local</span><br/><span class="koboSpan" id="kobo.13.1">75ab6cbbbbac        none                null                local</span></strong></pre>
<p><span class="koboSpan" id="kobo.14.1">By default, every container is connected to the bridge network upon creation. </span><span class="koboSpan" id="kobo.14.2">In this mode, every container is allocated a virtual interface as well as a private IP address, and the traffic going through the interface is bridged to the host's </span><kbd><span class="koboSpan" id="kobo.15.1">docker0</span></kbd><span class="koboSpan" id="kobo.16.1"> interface. </span><span class="koboSpan" id="kobo.16.2">Containers within the same bridge network can also connect to each other via their IP address. </span><span class="koboSpan" id="kobo.16.3">Let's run one container that's feeding a short message over port </span><kbd><span class="koboSpan" id="kobo.17.1">5000</span></kbd><span class="koboSpan" id="kobo.18.1">, and observe its configuration. </span><span class="koboSpan" id="kobo.18.2">The </span><kbd><span class="koboSpan" id="kobo.19.1">--expose</span></kbd><span class="koboSpan" id="kobo.20.1"> flag opens the given ports to the world outside the container:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.21.1">$ docker run --name greeter -d --expose 5000 busybox \</span><br/><span class="koboSpan" id="kobo.22.1">  /bin/sh -c "echo Welcome stranger! </span><span class="koboSpan" id="kobo.22.2">| nc -lp 5000"</span><br/><span class="koboSpan" id="kobo.23.1">841138a693d220c92b8634adf97426559fd0ae622e94ac4ee9f295ab088833f5</span><br/></strong><br/><strong><span class="koboSpan" id="kobo.24.1">$ docker exec greeter ifconfig</span><br/><span class="koboSpan" id="kobo.25.1">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02</span><br/><span class="koboSpan" id="kobo.26.1">          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0</span><br/><span class="koboSpan" id="kobo.27.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.28.1">Here, the </span><kbd><span class="koboSpan" id="kobo.29.1">greeter</span></kbd><span class="koboSpan" id="kobo.30.1"> </span><span><span class="koboSpan" id="kobo.31.1">container </span></span><span><span class="koboSpan" id="kobo.32.1">is allocated to the IP address </span></span><kbd><span class="koboSpan" id="kobo.33.1">172.17.0.2</span></kbd><span><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">Now, run another container, connecting to it with this IP address:</span></span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.35.1">$ docker run -t busybox telnet 172.17.0.2 5000</span><br/><span class="koboSpan" id="kobo.36.1">Welcome stranger!</span><br/><span class="koboSpan" id="kobo.37.1">Connection closed by foreign host</span></strong></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.38.1">The </span><kbd><span class="koboSpan" id="kobo.39.1">docker network inspect bridge</span></kbd><span class="koboSpan" id="kobo.40.1"> command provides configuration details, such as attached containers, subnet segments, and gateway information.</span></div>
<p><span class="koboSpan" id="kobo.41.1">You can group some containers into one user-defined bridge network. </span><span class="koboSpan" id="kobo.41.2">This is the recommended way to connect multiple containers on a single host. </span><span class="koboSpan" id="kobo.41.3">The user-defined bridge network slightly differs from the default one, the major difference being that you can access a container from other containers with its name, rather than its IP address. </span><span class="koboSpan" id="kobo.41.4">Creating a network is done using the </span><kbd><span class="koboSpan" id="kobo.42.1">docker network create [NW-NAME]</span></kbd><span class="koboSpan" id="kobo.43.1"> command, and we can attach containers to it by adding the </span><kbd><span class="koboSpan" id="kobo.44.1">--network [NW-NAME]</span></kbd> <span><span class="koboSpan" id="kobo.45.1">flag </span></span><span class="koboSpan" id="kobo.46.1">at the time of creation. </span><span class="koboSpan" id="kobo.46.2">The network name of a container is its name by default, but it can be given another alias name with the </span><kbd><span class="koboSpan" id="kobo.47.1">--network-alias</span></kbd><span class="koboSpan" id="kobo.48.1"> flag as well:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.49.1">## create a network called "room"</span><br/><span class="koboSpan" id="kobo.50.1">$ docker network create room</span><br/><span class="koboSpan" id="kobo.51.1">a59c7fda2e636e2f6d8af5918c9cf137ca9f09892746f4e072acd490c00c5e99</span><br/><span class="koboSpan" id="kobo.52.1">## run a container with the name "sleeper" and an alias "dad" in the room</span><br/><span class="koboSpan" id="kobo.53.1">$ docker run -d --network room \</span><br/><span class="koboSpan" id="kobo.54.1">                --network-alias dad --name sleeper busybox sleep 60</span><br/><span class="koboSpan" id="kobo.55.1">56397917ccb96ccf3ded54d79e1198e43c41b6ed58b649db12e7b2ee06a69b79</span><br/><span class="koboSpan" id="kobo.56.1">## ping the container with its name "sleeper" from another container</span><br/><span class="koboSpan" id="kobo.57.1">$ docker run --network room busybox ping -c 1 sleeper</span><br/><span class="koboSpan" id="kobo.58.1">PING sleeper (172.18.0.2): 56 data bytes</span><br/><span class="koboSpan" id="kobo.59.1">64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.087 ms</span><br/><br/><br/><span class="koboSpan" id="kobo.60.1">--- sleeper ping statistics ---</span><br/><span class="koboSpan" id="kobo.61.1">1 packets transmitted, 1 packets received, 0% packet loss</span><br/><span class="koboSpan" id="kobo.62.1">round-trip min/avg/max = 0.087/0.087/0.087 ms</span><br/><span class="koboSpan" id="kobo.63.1">## ping the container with its alias "dad", it also works</span><br/><span class="koboSpan" id="kobo.64.1">$ docker run --network room alpine ping -c 1 dad</span><br/><span class="koboSpan" id="kobo.65.1">PING dad (172.18.0.2): 56 data bytes</span><br/><span class="koboSpan" id="kobo.66.1">...</span></strong></pre>
<p><span class="koboSpan" id="kobo.67.1">The </span><kbd><span class="koboSpan" id="kobo.68.1">host</span></kbd><span class="koboSpan" id="kobo.69.1"> network works as its name suggests; every connected container shares the host's network, but it loses the isolation property at the same time. </span><span class="koboSpan" id="kobo.69.2">The </span><kbd><span class="koboSpan" id="kobo.70.1">none</span></kbd><span class="koboSpan" id="kobo.71.1"> network is a logically air-gapped box. </span><span class="koboSpan" id="kobo.71.2">Regardless of ingress or egress, traffic is isolated inside as there's no network interface attached to the container. </span><span class="koboSpan" id="kobo.71.3">Here, we attach a container that listens on port </span><kbd><span class="koboSpan" id="kobo.72.1">5000</span></kbd><span class="koboSpan" id="kobo.73.1"> to the </span><kbd><span class="koboSpan" id="kobo.74.1">host</span></kbd><span class="koboSpan" id="kobo.75.1"> network and communicates with it locally:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.76.1">$ docker run -d --expose 5000 --network host busybox \</span><br/><span class="koboSpan" id="kobo.77.1">  /bin/sh -c "echo im a container | nc -lp 5000"</span><br/><span class="koboSpan" id="kobo.78.1">a6918174c06f8f3f485913863ed69d4ae838fb550d9f4d66e24ef91534c76b3a</span><br/><span class="koboSpan" id="kobo.79.1">$ telnet localhost 5000</span><br/><span class="koboSpan" id="kobo.80.1">im a container</span><br/><span class="koboSpan" id="kobo.81.1">Connection closed by foreign host</span></strong></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.82.1">If you are using Docker CE for macOS, the host is the micro Linux on top of the hypervisor framework.</span></div>
<p><span class="koboSpan" id="kobo.83.1">The interaction between the host and the three network modes is shown in the following diagram. </span><span class="koboSpan" id="kobo.83.2">Containers in the </span><kbd><span class="koboSpan" id="kobo.84.1">host</span></kbd><span class="koboSpan" id="kobo.85.1"> and </span><kbd><span class="koboSpan" id="kobo.86.1">bridge</span></kbd><span class="koboSpan" id="kobo.87.1"> networks are attached with proper network interfaces and communicate with containers within the same network, as well as the outside world, but the </span><kbd><span class="koboSpan" id="kobo.88.1">none</span></kbd><span class="koboSpan" id="kobo.89.1"> network is kept away from the host interfaces:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.90.1"><img src="assets/b60d1e99-879c-46b7-8fde-5c8a47af6900.png" style="width:29.75em;height:21.08em;"/></span></div>
<p><span class="koboSpan" id="kobo.91.1">Other than sharing the host network, the </span><kbd><span class="koboSpan" id="kobo.92.1">-p(--publish) [host]:[container]</span></kbd><span class="koboSpan" id="kobo.93.1"> flag, when creating a container, also allows you to map a host port to a container. </span><span class="koboSpan" id="kobo.93.2">We don't need attaching a </span><kbd><span class="koboSpan" id="kobo.94.1">--expose</span></kbd><span class="koboSpan" id="kobo.95.1"> flag together with the </span><kbd><span class="koboSpan" id="kobo.96.1">--publish</span></kbd><span class="koboSpan" id="kobo.97.1"> flag, as you'll need to open a container's port in any case. </span><span class="koboSpan" id="kobo.97.2">The following command launches a simple HTTP server at port </span><kbd><span class="koboSpan" id="kobo.98.1">80</span></kbd><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">You can view it with a browser as well:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.100.1">$ docker run -p 80:5000 busybox /bin/sh -c \</span><br/><span class="koboSpan" id="kobo.101.1">  "while :; do echo -e 'HTTP/1.1 200 OK\n\ngood day'|nc -lp 5000; done"</span><br/><span class="koboSpan" id="kobo.102.1">$ curl localhost</span><br/><span class="koboSpan" id="kobo.103.1">good day</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Working with a Dockerfile</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When assembling an image, whether using </span><kbd><span class="koboSpan" id="kobo.3.1">docker commit</span></kbd><span class="koboSpan" id="kobo.4.1"> or </span><kbd><span class="koboSpan" id="kobo.5.1">export</span></kbd><span class="koboSpan" id="kobo.6.1">, optimizing the outcome in a managed way is a challenge, let alone integrating it with a CI/CD pipeline. </span><span class="koboSpan" id="kobo.6.2">A </span><kbd><span class="koboSpan" id="kobo.7.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.8.1"> represents the building task in the form of code, which significantly reduces the difficulty of building tasks for us. </span><span class="koboSpan" id="kobo.8.2">In this section, we'll describe how to map Docker commands into a </span><kbd><span class="koboSpan" id="kobo.9.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.10.1"> and take a step towards optimizing it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Writing your first Dockerfile</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><kbd><span class="koboSpan" id="kobo.3.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.4.1"> consists of a series of text instructions to guide the Docker daemon to form an image, and a </span><kbd><span class="koboSpan" id="kobo.5.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.6.1"> must start with the </span><kbd><span class="koboSpan" id="kobo.7.1">FROM</span></kbd><span class="koboSpan" id="kobo.8.1"> directive. </span><span class="koboSpan" id="kobo.8.2">For example, we may have an image built from the following one-liner:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.9.1">docker commit $(                         \</span><br/><span class="koboSpan" id="kobo.10.1">  docker start $(                        \</span><br/><span class="koboSpan" id="kobo.11.1">    docker create alpine /bin/sh -c      \</span><br/><span class="koboSpan" id="kobo.12.1">      "echo My custom build &gt; /etc/motd" \</span><br/><span class="koboSpan" id="kobo.13.1">))</span></strong></pre>
<p><span class="koboSpan" id="kobo.14.1">This roughly equates to the following </span><kbd><span class="koboSpan" id="kobo.15.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.16.1">:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.17.1">FROM alpine</span><br/><span class="koboSpan" id="kobo.18.1">RUN echo "My custom build" &gt; /etc/motd</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.19.1">Obviously, building with a </span><kbd><span class="koboSpan" id="kobo.20.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.21.1"> is much more concise and precise.</span></p>
<p><span class="koboSpan" id="kobo.22.1">The </span><kbd><span class="koboSpan" id="kobo.23.1">docker build [OPTIONS] [CONTEXT]</span></kbd><span class="koboSpan" id="kobo.24.1"> command is the only command associated with building tasks. </span><span class="koboSpan" id="kobo.24.2">A context can be a local path, URL, or </span><kbd><span class="koboSpan" id="kobo.25.1">stdin</span></kbd><span class="koboSpan" id="kobo.26.1">, which denotes the location of the </span><kbd><span class="koboSpan" id="kobo.27.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">Once a build is triggered, the </span><kbd><span class="koboSpan" id="kobo.29.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.30.1">, alongside everything under the context, will be sent to the Docker daemon beforehand and then the daemon will start to execute instructions in the </span><kbd><span class="koboSpan" id="kobo.31.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.32.1"> sequentially. </span><span class="koboSpan" id="kobo.32.2">Every execution of the instructions results in a new cache layer, and the ensuing instruction is executed at the new cache layer in the cascade. </span><span class="koboSpan" id="kobo.32.3">Since the context will be sent somewhere that isn't guaranteed to be a local path, and sending too many </span><span><span class="koboSpan" id="kobo.33.1">irrelevant </span></span><span class="koboSpan" id="kobo.34.1">files takes time, it's a good practice to put the </span><kbd><span class="koboSpan" id="kobo.35.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.36.1">, code, necessary files, and a </span><kbd><span class="koboSpan" id="kobo.37.1">.dockerignore</span></kbd><span class="koboSpan" id="kobo.38.1"> file in an </span><kbd><span class="koboSpan" id="kobo.39.1">empty</span></kbd><span class="koboSpan" id="kobo.40.1"> folder to make sure the resultant image contains only the desired files.</span></p>
<p><span class="koboSpan" id="kobo.41.1">The </span><kbd><span class="koboSpan" id="kobo.42.1">.dockerignore</span></kbd><span class="koboSpan" id="kobo.43.1"> file is a list indicating which files under the same directory can be ignored at build time. </span><span class="koboSpan" id="kobo.43.2">It typically looks as follows:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.44.1">$ cat .dockerignore</span><br/><span class="koboSpan" id="kobo.45.1"># ignore .dockerignore, .git</span><br/><span class="koboSpan" id="kobo.46.1">.dockerignore</span><br/><span class="koboSpan" id="kobo.47.1">.git</span><br/><span class="koboSpan" id="kobo.48.1"># exclude all *.tmp files and vim swp file recursively</span><br/><span class="koboSpan" id="kobo.49.1">**/*.tmp</span><br/><span class="koboSpan" id="kobo.50.1">**/[._]*.s[a-w][a-z]</span><br/><span class="koboSpan" id="kobo.51.1"># exclude all markdown files except README*.md</span><br/><span class="koboSpan" id="kobo.52.1">!README*.md</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.53.1">Generally, </span><kbd><span class="koboSpan" id="kobo.54.1">docker build</span></kbd><span class="koboSpan" id="kobo.55.1"> will try to locate a file named </span><kbd><span class="koboSpan" id="kobo.56.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.57.1"> under the context to start a build. </span><span class="koboSpan" id="kobo.57.2">Sometimes, however, we may want to give it another name, which we can do using the </span><kbd><span class="koboSpan" id="kobo.58.1">-f</span></kbd><span class="koboSpan" id="kobo.59.1"> (</span><kbd><span class="koboSpan" id="kobo.60.1">--file</span></kbd><span class="koboSpan" id="kobo.61.1">) flag. </span><span class="koboSpan" id="kobo.61.2">Another useful flag, </span><kbd><span class="koboSpan" id="kobo.62.1">-t</span></kbd><span class="koboSpan" id="kobo.63.1"> (</span><kbd><span class="koboSpan" id="kobo.64.1">--tag</span></kbd><span class="koboSpan" id="kobo.65.1">), is able to give an image one or more repository tags after an image is built. </span><span class="koboSpan" id="kobo.65.2">Let's say we want to build a </span><kbd><span class="koboSpan" id="kobo.66.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.67.1"> named </span><kbd><span class="koboSpan" id="kobo.68.1">builder.dck</span></kbd><span class="koboSpan" id="kobo.69.1"> under </span><kbd><span class="koboSpan" id="kobo.70.1">./deploy</span></kbd><span class="koboSpan" id="kobo.71.1"> and label it with the current date and the latest tag. </span><span class="koboSpan" id="kobo.71.2">The command to do this is as follows:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.72.1">## We can assign the image with more than one tag within a build command</span><br/><span class="koboSpan" id="kobo.73.1">$ docker build -f deploy/builder.dck               \</span><br/><span class="koboSpan" id="kobo.74.1">   -t my-reg.com/prod/teabreaker:$(date +"%g%m%d") \</span><br/><span class="koboSpan" id="kobo.75.1">   -t my-reg.com/prod/teabreaker:latest .</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The syntax of a Dockerfile</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The building blocks of a </span><kbd><span class="koboSpan" id="kobo.3.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.4.1"> are a dozen directives. </span><span class="koboSpan" id="kobo.4.2">Most of these are made up of functions of the </span><kbd><span class="koboSpan" id="kobo.5.1">docker run/create</span></kbd><span class="koboSpan" id="kobo.6.1"> flags. </span><span class="koboSpan" id="kobo.6.2">Let's take a look at the most essential ones:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.7.1">FROM &lt;IMAGE&gt;[:TAG|[@DIGEST]</span></kbd><span class="koboSpan" id="kobo.8.1">: This is to tell the Docker daemon which image the current </span><kbd><span class="koboSpan" id="kobo.9.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.10.1"> is based on. </span><span class="koboSpan" id="kobo.10.2">It's also the one and only instruction that has to be in a </span><kbd><span class="koboSpan" id="kobo.11.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.12.1">; you can have a </span><kbd><span class="koboSpan" id="kobo.13.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.14.1"> that contains only this line. </span><span class="koboSpan" id="kobo.14.2">Like all of </span><span><span class="koboSpan" id="kobo.15.1">the</span></span><span class="koboSpan" id="kobo.16.1"> other image-relevant commands, the tag defaults to the latest if unspecified.</span></li>
<li><kbd><span class="koboSpan" id="kobo.17.1">RUN</span></kbd><span class="koboSpan" id="kobo.18.1">:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.19.1"> RUN &lt;commands&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1"> RUN ["executable", "params", "more params"]</span></strong></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.21.1">The </span><kbd><span class="koboSpan" id="kobo.22.1">RUN</span></kbd><span class="koboSpan" id="kobo.23.1"> instruction runs one line of a command at the current cache layer and commits the outcome. </span><span class="koboSpan" id="kobo.23.2">The main discrepancy between the two forms is with regards to how the command is executed. </span><span class="koboSpan" id="kobo.23.3">The first form is called </span><strong><span class="koboSpan" id="kobo.24.1">shell form</span></strong><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">This actually executes commands in the form of </span><kbd><span class="koboSpan" id="kobo.26.1">/bin/sh -c &lt;commands&gt;</span></kbd><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">The other form is </span><strong><span class="koboSpan" id="kobo.28.1">exec form</span></strong><span class="koboSpan" id="kobo.29.1">.</span><strong><span class="koboSpan" id="kobo.30.1"> </span></strong><span class="koboSpan" id="kobo.31.1">This treats the command with </span><kbd><span class="koboSpan" id="kobo.32.1">exec</span></kbd><span class="koboSpan" id="kobo.33.1"> directly.</span></p>
<p><span class="koboSpan" id="kobo.34.1">Using the shell form is similar to writing shell scripts, hence concatenating multiple commands by shell operators and line continuation, condition tests, or variable substitutions is completely valid. </span><span class="koboSpan" id="kobo.34.2">Bear in mind, however, that commands aren't processed by </span><kbd><span class="koboSpan" id="kobo.35.1">bash</span></kbd><span class="koboSpan" id="kobo.36.1"> but by </span><kbd><span class="koboSpan" id="kobo.37.1">sh</span></kbd><span class="koboSpan" id="kobo.38.1">.</span></p>
<p><span class="koboSpan" id="kobo.39.1">The </span><kbd><span class="koboSpan" id="kobo.40.1">exec</span></kbd><span class="koboSpan" id="kobo.41.1"> form is parsed as a JSON array, which means that you have to wrap texts with double quotes and escape the reserved characters. </span><span class="koboSpan" id="kobo.41.2">Besides, as the command is not processed by any shell, the shell variables in the array will not be evaluated. </span><span class="koboSpan" id="kobo.41.3">On the other hand, if the shell doesn't exist in the base image, you can still use the </span><kbd><span class="koboSpan" id="kobo.42.1">exec</span></kbd><span class="koboSpan" id="kobo.43.1"> form to invoke executables.</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.44.1">CMD</span></kbd><span class="koboSpan" id="kobo.45.1">:</span></li>
</ul>
<pre style="padding-left: 90px"><span class="koboSpan" id="kobo.46.1">CMD ["executable", "params", "more params"]</span><br/><span class="koboSpan" id="kobo.47.1">CMD ["param1","param2"]</span><br/><span class="koboSpan" id="kobo.48.1">CMD command param1 param2 ...</span></pre>
<p><span class="koboSpan" id="kobo.49.1">The </span><kbd><span class="koboSpan" id="kobo.50.1">CMD</span></kbd><span class="koboSpan" id="kobo.51.1"> it to set default commands for the built image, but it doesn't run the command at build time. </span><span class="koboSpan" id="kobo.51.2">If arguments are supplied upon executing </span><kbd><span class="koboSpan" id="kobo.52.1">docker run</span></kbd><span class="koboSpan" id="kobo.53.1">, the </span><kbd><span class="koboSpan" id="kobo.54.1">CMD</span></kbd><span class="koboSpan" id="kobo.55.1"> configurations here are overridden. </span><span class="koboSpan" id="kobo.55.2">The syntax rules of </span><kbd><span class="koboSpan" id="kobo.56.1">CMD</span></kbd><span class="koboSpan" id="kobo.57.1"> are almost identical to </span><kbd><span class="koboSpan" id="kobo.58.1">RUN</span></kbd><span class="koboSpan" id="kobo.59.1">; the previous two forms are the </span><kbd><span class="koboSpan" id="kobo.60.1">exec</span></kbd><span class="koboSpan" id="kobo.61.1"> form, and the third one is the shell form, which prepends </span><kbd><span class="koboSpan" id="kobo.62.1">/bin/sh -c</span></kbd><span class="koboSpan" id="kobo.63.1"> to the parameters as well. </span><span class="koboSpan" id="kobo.63.2">There's another </span><kbd><span class="koboSpan" id="kobo.64.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.65.1"> directive that would interact with </span><kbd><span class="koboSpan" id="kobo.66.1">CMD</span></kbd><span class="koboSpan" id="kobo.67.1">;the parameter of </span><span><kbd><span class="koboSpan" id="kobo.68.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.69.1"> would prepend to the </span></span><span class="koboSpan" id="kobo.70.1">three forms of </span><kbd><span class="koboSpan" id="kobo.71.1">CMD</span></kbd><span class="koboSpan" id="kobo.72.1"> when a container starts. </span><span class="koboSpan" id="kobo.72.2">There can be many </span><kbd><span class="koboSpan" id="kobo.73.1">CMD</span></kbd><span class="koboSpan" id="kobo.74.1"> directives in a </span><kbd><span class="koboSpan" id="kobo.75.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.76.1">, but only the last one will take effect.</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.77.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.78.1">:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.79.1"> ENTRYPOINT ["executable", "param1", "param2"]</span><br/><span class="koboSpan" id="kobo.80.1"> ENTRYPOINT command param1 param2</span></pre>
<p><span class="koboSpan" id="kobo.81.1">These two forms are, respectively, the </span><kbd><span class="koboSpan" id="kobo.82.1">exec</span></kbd><span class="koboSpan" id="kobo.83.1"> form and the shell form, and the syntax rules are the same as </span><kbd><span class="koboSpan" id="kobo.84.1">RUN</span></kbd><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">The entry point is the default executable for an image. </span><span class="koboSpan" id="kobo.85.3">This means that when a container spins up, it runs the executable configured by </span><kbd><span class="koboSpan" id="kobo.86.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">When </span><kbd><span class="koboSpan" id="kobo.88.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.89.1"> is combined with the </span><kbd><span class="koboSpan" id="kobo.90.1">CMD</span></kbd><span class="koboSpan" id="kobo.91.1"> and </span><kbd><span class="koboSpan" id="kobo.92.1">docker run</span></kbd><span class="koboSpan" id="kobo.93.1"> arguments, writing it in a different form would lead to very different behavior. </span><span class="koboSpan" id="kobo.93.2">Here are the rules regarding their combinations:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.94.1">If the </span><kbd><span class="koboSpan" id="kobo.95.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.96.1"> is in shell form, then the </span><kbd><span class="koboSpan" id="kobo.97.1">CMD</span></kbd><span class="koboSpan" id="kobo.98.1"> and </span><kbd><span class="koboSpan" id="kobo.99.1">docker run</span></kbd><span class="koboSpan" id="kobo.100.1"> arguments would be ignored. </span><span class="koboSpan" id="kobo.100.2">The runtime command would be as follows:</span></li>
</ul>
<pre style="padding-left: 90px" class="mce-root"><strong><span class="koboSpan" id="kobo.101.1">/bin/sh -c entry_cmd entry_params ...</span></strong></pre>
<ul>
<li><span class="koboSpan" id="kobo.102.1">If the </span><kbd><span class="koboSpan" id="kobo.103.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.104.1"> is in </span><kbd><span class="koboSpan" id="kobo.105.1">exec</span></kbd><span class="koboSpan" id="kobo.106.1"> form and the </span><kbd><span class="koboSpan" id="kobo.107.1">docker run</span></kbd><span class="koboSpan" id="kobo.108.1"> arguments are specified, then the </span><kbd><span class="koboSpan" id="kobo.109.1">CMD</span></kbd><span class="koboSpan" id="kobo.110.1"> commands are overridden. </span><span class="koboSpan" id="kobo.110.2">The runtime command would be as follows:</span></li>
</ul>
<pre style="padding-left: 90px" class="mce-root"><strong><span class="koboSpan" id="kobo.111.1">entry_cmd entry_params run_arguments</span></strong></pre>
<ul>
<li><span class="koboSpan" id="kobo.112.1">If the </span><kbd><span class="koboSpan" id="kobo.113.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.114.1"> is in </span><kbd><span class="koboSpan" id="kobo.115.1">exec</span></kbd><span class="koboSpan" id="kobo.116.1"> form and only </span><kbd><span class="koboSpan" id="kobo.117.1">CMD</span></kbd><span class="koboSpan" id="kobo.118.1"> is configured, the runtime command would become the following for the three forms:</span></li>
</ul>
<pre style="padding-left: 90px" class="mce-root"><strong><span class="koboSpan" id="kobo.119.1">entry_cmd entry_parms CMD_exec CMD_parms</span><br/><span class="koboSpan" id="kobo.120.1">entry_cmd entry_parms CMD_parms</span><br/><span class="koboSpan" id="kobo.121.1">entry_cmd entry_parms /bin/sh -c CMD_cmd </span></strong><strong><span class="koboSpan" id="kobo.122.1">CMD_parms</span></strong></pre>
<ul>
<li><kbd><span class="koboSpan" id="kobo.123.1">ENV</span></kbd><span class="koboSpan" id="kobo.124.1">:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.125.1"> ENV key value</span><br/><span class="koboSpan" id="kobo.126.1"> ENV key1=value1 key2=value2 ...</span></pre>
<p><span class="koboSpan" id="kobo.127.1">The </span><kbd><span class="koboSpan" id="kobo.128.1">ENV</span></kbd><span class="koboSpan" id="kobo.129.1"> instruction sets environment variables for the consequent instructions and the built image. </span><span class="koboSpan" id="kobo.129.2">The first form sets the key to the string after the first space, including special characters, except the line continuation character. </span><span class="koboSpan" id="kobo.129.3">The second form allows us to set multiple variables in a line, separated with spaces. </span><span class="koboSpan" id="kobo.129.4">If there are spaces in a value, either enclose them with double quotes or escape the space character. </span><span class="koboSpan" id="kobo.129.5">Moreover, the key defined with </span><kbd><span class="koboSpan" id="kobo.130.1">ENV</span></kbd><span class="koboSpan" id="kobo.131.1"> also takes effect on variables in the same document. </span><span class="koboSpan" id="kobo.131.2">See the following examples to observe the behavior of </span><kbd><span class="koboSpan" id="kobo.132.1">ENV</span></kbd><span class="koboSpan" id="kobo.133.1">:</span></p>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.134.1">FROM alpine</span><br/><span class="koboSpan" id="kobo.135.1"># first form</span><br/><span class="koboSpan" id="kobo.136.1">ENV k1 wD # aw</span><br/><span class="koboSpan" id="kobo.137.1"># second form, </span><span><span class="koboSpan" id="kobo.138.1">line </span></span><span><span class="koboSpan" id="kobo.139.1">continuation character also works</span><br/></span><span class="koboSpan" id="kobo.140.1">
ENV k2=v2 k3=v\ 3 \</span><br/><span class="koboSpan" id="kobo.141.1">    k4="v 4"</span><br/><span class="koboSpan" id="kobo.142.1"># ${k2} would be evaluated, so the key is "k_v2" in this case</span><br/><span class="koboSpan" id="kobo.143.1">ENV k_${k2}=$k3 k5=\"K\=da\"</span><br/><span class="koboSpan" id="kobo.144.1"># show the variables</span><br/><span class="koboSpan" id="kobo.145.1">RUN env | grep -Ev '(HOSTNAME|PATH|PWD|HOME|SHLVL)' | sort</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.146.1">The output during the </span><kbd><span class="koboSpan" id="kobo.147.1">docker build</span></kbd><span class="koboSpan" id="kobo.148.1"> would be as follows:</span></p>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.149.1">...</span><br/><span class="koboSpan" id="kobo.150.1"> ---&gt; Running in c5407972c5f5</span><br/><span class="koboSpan" id="kobo.151.1">k1=wD # aw</span><br/><span class="koboSpan" id="kobo.152.1">k2=v2</span><br/><span class="koboSpan" id="kobo.153.1">k3=v 3</span><br/><span class="koboSpan" id="kobo.154.1">k4=v 4</span><br/><span class="koboSpan" id="kobo.155.1">k5="K=da"</span><br/><span class="koboSpan" id="kobo.156.1">k_v2=v 3</span><br/></strong><strong><span class="koboSpan" id="kobo.157.1">...</span></strong></pre>
<ul>
<li><kbd><span class="koboSpan" id="kobo.158.1">ARG key[=&lt;default value&gt;]</span></kbd><span><span class="koboSpan" id="kobo.159.1">: The </span><kbd><span class="koboSpan" id="kobo.160.1">ARG</span></kbd><span class="koboSpan" id="kobo.161.1"> instruction can pass our arguments as environment variables into the building container via the </span></span><span><kbd><span class="koboSpan" id="kobo.162.1">--build-arg</span></kbd><span class="koboSpan" id="kobo.163.1"> flag of </span><kbd><span class="koboSpan" id="kobo.164.1">docker build</span></kbd><span class="koboSpan" id="kobo.165.1">. </span><span class="koboSpan" id="kobo.165.2">For instance, building the following file using </span><kbd><span class="koboSpan" id="kobo.166.1">docker build --build-arg FLAGS=--static</span></kbd><span class="koboSpan" id="kobo.167.1"> would result in </span><kbd><span class="koboSpan" id="kobo.168.1">RUN ./build/dev/run --static</span></kbd><span class="koboSpan" id="kobo.169.1"> on the last line:</span></span></li>
</ul>
<pre style="color: black;padding-left: 90px"><strong><span class="koboSpan" id="kobo.170.1">FROM alpine</span></strong><br/><strong><span class="koboSpan" id="kobo.171.1">ARG TARGET=dev</span><br/><span class="koboSpan" id="kobo.172.1">ARG FLAGS</span><br/><span class="koboSpan" id="kobo.173.1">RUN ./build/$TARGET/run $FLAGS</span></strong></pre>
<p><span><span class="koboSpan" id="kobo.174.1">Unlike </span><kbd><span class="koboSpan" id="kobo.175.1">ENV</span></kbd><span class="koboSpan" id="kobo.176.1">, only one argument can be assigned per line. </span><span class="koboSpan" id="kobo.176.2">If we are using </span><kbd><span class="koboSpan" id="kobo.177.1">ARG</span></kbd><span class="koboSpan" id="kobo.178.1"> together with </span><kbd><span class="koboSpan" id="kobo.179.1">ENV</span></kbd></span><span class="koboSpan" id="kobo.180.1">, then the value of </span><kbd><span class="koboSpan" id="kobo.181.1">ARG</span></kbd><span class="koboSpan" id="kobo.182.1">, no matter where it is (either by </span><kbd><span class="koboSpan" id="kobo.183.1">--build-arg</span></kbd><span class="koboSpan" id="kobo.184.1"> or the default value), would be overwritten by the value of </span><kbd><span class="koboSpan" id="kobo.185.1">ENV</span></kbd><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">Due to the frequent use of the proxy environment variables, these are all supported as arguments by default, including </span><kbd><span class="koboSpan" id="kobo.187.1">HTTP_PROXY</span></kbd><span class="koboSpan" id="kobo.188.1">, </span><kbd><span class="koboSpan" id="kobo.189.1">http_proxy</span></kbd><span class="koboSpan" id="kobo.190.1">, </span><kbd><span class="koboSpan" id="kobo.191.1">HTTPS_PROXY</span></kbd><span class="koboSpan" id="kobo.192.1">, </span><kbd><span class="koboSpan" id="kobo.193.1">https_proxy</span></kbd><span class="koboSpan" id="kobo.194.1">, </span><kbd><span class="koboSpan" id="kobo.195.1">FTP_PROXY</span></kbd><span class="koboSpan" id="kobo.196.1">, </span><kbd><span class="koboSpan" id="kobo.197.1">ftp_proxy</span></kbd><span class="koboSpan" id="kobo.198.1">, </span><kbd><span class="koboSpan" id="kobo.199.1">NO_PROXY</span></kbd><span class="koboSpan" id="kobo.200.1">, and </span><kbd><span class="koboSpan" id="kobo.201.1">no_proxy</span></kbd><span class="koboSpan" id="kobo.202.1">. </span><span class="koboSpan" id="kobo.202.2">This means we can pass these building arguments without defining them in the </span><kbd><span class="koboSpan" id="kobo.203.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.204.1"> beforehand. </span><span class="koboSpan" id="kobo.204.2">One thing worth noting is that the value of </span><kbd><span class="koboSpan" id="kobo.205.1">ARG</span></kbd><span class="koboSpan" id="kobo.206.1"> would remain in both the shell history on the building machine and the Docker history of the image, which means it's wise not to pass sensitive data via </span><kbd><span class="koboSpan" id="kobo.207.1">ARG</span></kbd><span class="koboSpan" id="kobo.208.1">:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.209.1">LABEL key1=value1 key2=value2 ...</span></kbd><span class="koboSpan" id="kobo.210.1">: The use of </span><kbd><span class="koboSpan" id="kobo.211.1">LABEL</span></kbd><span class="koboSpan" id="kobo.212.1"> resembles that of </span><kbd><span class="koboSpan" id="kobo.213.1">ENV</span></kbd><span class="koboSpan" id="kobo.214.1">, but a label is only stored in the metadata section of an image and is used by other host programs instead of programs in a container. </span><span class="koboSpan" id="kobo.214.2">For example, if we attach the maintainer of our image in the form </span><kbd><span class="koboSpan" id="kobo.215.1">LABEL maintainer=johndoe@example.com</span></kbd><span class="koboSpan" id="kobo.216.1">, we can filter the annotated image with the </span><kbd><span class="koboSpan" id="kobo.217.1">-f(--filter)</span></kbd><span class="koboSpan" id="kobo.218.1"> </span><span><span class="koboSpan" id="kobo.219.1">flag in this query: </span><kbd><span class="koboSpan" id="kobo.220.1">docker images --filter label=maintainer=johndoe@example.com</span></kbd></span><span class="koboSpan" id="kobo.221.1">.</span></li>
<li><kbd><span class="koboSpan" id="kobo.222.1">EXPOSE &lt;port&gt; [&lt;port&gt; ...]</span></kbd><span class="koboSpan" id="kobo.223.1">: This instruction is identical to the </span><kbd><span class="koboSpan" id="kobo.224.1">--expose</span></kbd><span class="koboSpan" id="kobo.225.1"> flag used with </span><kbd><span class="koboSpan" id="kobo.226.1">docker run/create</span></kbd><span class="koboSpan" id="kobo.227.1">, exposing ports in the container created by the resulting image.</span></li>
<li><kbd><span class="koboSpan" id="kobo.228.1">USER &lt;name|uid&gt;[:&lt;group|gid&gt;]</span></kbd><span class="koboSpan" id="kobo.229.1">: The </span><kbd><span class="koboSpan" id="kobo.230.1">USER</span></kbd><span class="koboSpan" id="kobo.231.1"> instruction switches the user to run the subsequent instructions, including the ones in </span><kbd><span class="koboSpan" id="kobo.232.1">CMD</span></kbd><span class="koboSpan" id="kobo.233.1"> or </span><kbd><span class="koboSpan" id="kobo.234.1">ENTRYPOINT</span></kbd><span class="koboSpan" id="kobo.235.1">. </span><span class="koboSpan" id="kobo.235.2">However, it can't work properly if the user doesn't exist in the image. </span><span class="koboSpan" id="kobo.235.3">If you want to run instructions using a user that doesn't exist, you have to run </span><kbd><span class="koboSpan" id="kobo.236.1">adduser</span></kbd><span class="koboSpan" id="kobo.237.1"> before using the </span><kbd><span class="koboSpan" id="kobo.238.1">USER</span></kbd><span class="koboSpan" id="kobo.239.1"> directive.</span></li>
</ul>
<ul>
<li><kbd><span class="koboSpan" id="kobo.240.1">WORKDIR &lt;path&gt;</span></kbd><span class="koboSpan" id="kobo.241.1">: This instruction sets the working directory to a certain path. </span><span class="koboSpan" id="kobo.241.2">E</span><span><span class="koboSpan" id="kobo.242.1">nvironment variables set with </span></span><kbd><span class="koboSpan" id="kobo.243.1">ENV</span></kbd><span><span class="koboSpan" id="kobo.244.1"> take effect on the path. </span></span><span class="koboSpan" id="kobo.245.1">The path would be created automatically if it doesn't already exist. </span><span class="koboSpan" id="kobo.245.2">It works like </span><kbd><span class="koboSpan" id="kobo.246.1">cd</span></kbd><span class="koboSpan" id="kobo.247.1"> in a </span><kbd><span class="koboSpan" id="kobo.248.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.249.1">, as it takes both relative and absolute paths and can be used multiple times. If an absolute path is followed by a relative path, the result would be relative to the previous path:</span></li>
</ul>
<pre style="padding-left: 90px"><strong><span class="koboSpan" id="kobo.250.1">WORKDIR /</span></strong><strong><span class="koboSpan" id="kobo.251.1">usr</span></strong><br/><strong><span class="koboSpan" id="kobo.252.1">WORKDIR src</span></strong><br/><strong><span class="koboSpan" id="kobo.253.1">WORKDIR app</span></strong><br/><strong><span class="koboSpan" id="kobo.254.1">RUN pwd</span></strong><br/><strong><span class="koboSpan" id="kobo.255.1"># run docker build</span></strong><br/><strong><span class="koboSpan" id="kobo.256.1">...</span></strong><br/><strong><span class="koboSpan" id="kobo.257.1">---&gt; Running in 73aff3ae46ac</span></strong><br/><strong><span class="koboSpan" id="kobo.258.1">/usr/src/app</span></strong></pre>
<ul>
<li><kbd><span class="koboSpan" id="kobo.259.1">COPY</span></kbd><span class="koboSpan" id="kobo.260.1">:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.261.1"> COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt; ... </span><span class="koboSpan" id="kobo.261.2">&lt;dest&gt;</span><br/><span class="koboSpan" id="kobo.262.1"> COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;", ..., "&lt;dest&gt;"]</span></pre>
<p><span class="koboSpan" id="kobo.263.1">This directive copies the source to a file or a directory in the building container. The source as well as the destination could be files or directories. </span><span class="koboSpan" id="kobo.263.2">The source must be within the context path and not excluded by </span><kbd><span class="koboSpan" id="kobo.264.1">.dockerignore</span></kbd><span class="koboSpan" id="kobo.265.1">, as only those will be sent to the Docker daemon. </span><span><span class="koboSpan" id="kobo.266.1">The second form is for cases in which the path contains spaces. </span><span class="koboSpan" id="kobo.266.2">The </span><kbd><span class="koboSpan" id="kobo.267.1">--chown</span></kbd><span class="koboSpan" id="kobo.268.1"> flag enables us to set the file owner on the fly without running </span></span><span class="koboSpan" id="kobo.269.1">additional </span><kbd><span class="koboSpan" id="kobo.270.1">chown</span></kbd><span class="koboSpan" id="kobo.271.1"> steps inside containers. </span><span class="koboSpan" id="kobo.271.2">It also accepts numeric user IDs and group IDs:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.272.1">ADD</span></kbd><span class="koboSpan" id="kobo.273.1">:</span></li>
</ul>
<pre style="padding-left: 90px"><span class="koboSpan" id="kobo.274.1">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src &gt; ... </span><span class="koboSpan" id="kobo.274.2">&lt;dest&gt;</span><br/><span class="koboSpan" id="kobo.275.1">ADD [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;", ..., "&lt;dest&gt;"]</span></pre>
<p><kbd><span class="koboSpan" id="kobo.276.1">ADD</span></kbd><span class="koboSpan" id="kobo.277.1"> is quite similar to </span><kbd><span class="koboSpan" id="kobo.278.1">COPY</span></kbd><span class="koboSpan" id="kobo.279.1"> in terms of its functionality: it moves files into an image. </span><span class="koboSpan" id="kobo.279.2">The major differences are that </span><kbd><span class="koboSpan" id="kobo.280.1">ADD</span></kbd><span class="koboSpan" id="kobo.281.1"> supports downloading files from a remote address and extracting compressed files from the container in one line. </span><span class="koboSpan" id="kobo.281.2">As such, </span><kbd><span class="koboSpan" id="kobo.282.1">&lt;src&gt;</span></kbd><span class="koboSpan" id="kobo.283.1"> can also be a URL or compressed file. </span><span class="koboSpan" id="kobo.283.2">If </span><kbd><span class="koboSpan" id="kobo.284.1">&lt;src&gt;</span></kbd><span class="koboSpan" id="kobo.285.1"> is a URL, </span><kbd><span class="koboSpan" id="kobo.286.1">ADD</span></kbd><span class="koboSpan" id="kobo.287.1"> will download it and copy it into the image; if </span><kbd><span class="koboSpan" id="kobo.288.1">&lt;src&gt;</span></kbd><span class="koboSpan" id="kobo.289.1"> is inferred as a compressed file, it'll be extracted into the </span><kbd><span class="koboSpan" id="kobo.290.1">&lt;dest&gt;</span></kbd><span class="koboSpan" id="kobo.291.1"> path:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.292.1">VOLUME</span></kbd><span class="koboSpan" id="kobo.293.1">:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.294.1">VOLUME mount_point_1 mount_point_2 ...</span><br/><span class="koboSpan" id="kobo.295.1">VOLUME ["mount point 1", "mount point 2", ...]</span></pre>
<p><span class="koboSpan" id="kobo.296.1">The </span><kbd><span class="koboSpan" id="kobo.297.1">VOLUME</span></kbd><span class="koboSpan" id="kobo.298.1"> instruction creates data volumes at the given mount points. </span><span class="koboSpan" id="kobo.298.2">Once it's been declared during build time, any change in the data volume at consequent directives would not persist. </span><span class="koboSpan" id="kobo.298.3">Besides, mounting host directories in a </span><kbd><span class="koboSpan" id="kobo.299.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.300.1"> or </span><kbd><span class="koboSpan" id="kobo.301.1">docker build</span></kbd><span class="koboSpan" id="kobo.302.1"> isn't doable because of portability concerns: there's no guarantee that the specified path would exist in the host. </span><span class="koboSpan" id="kobo.302.2">The effect of both syntax forms is identical; they only differ with regard to syntax parsing. </span><span class="koboSpan" id="kobo.302.3">The second form is a JSON array, so characters such as </span><kbd><span class="koboSpan" id="kobo.303.1">\</span></kbd><span class="koboSpan" id="kobo.304.1"> should be escaped.</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.305.1">ONBUILD [Other directives]</span></kbd><span class="koboSpan" id="kobo.306.1">: </span><kbd><span class="koboSpan" id="kobo.307.1">ONBUILD</span></kbd><span class="koboSpan" id="kobo.308.1"> allows you to postpone some instructions to later builds that happen in the derived image. </span><span class="koboSpan" id="kobo.308.2">For example, suppose we have the following two Dockerfiles:</span></li>
</ul>
<pre style="padding-left: 90px"><strong><span class="koboSpan" id="kobo.309.1">--- baseimg.dck ---</span><br/><span class="koboSpan" id="kobo.310.1">FROM alpine</span><br/><span class="koboSpan" id="kobo.311.1">RUN apk add --no-cache git make</span><br/><span class="koboSpan" id="kobo.312.1">WORKDIR /usr/src/app</span><br/><span class="koboSpan" id="kobo.313.1">ONBUILD COPY . </span><span class="koboSpan" id="kobo.313.2">/usr/src/app/</span><br/><span class="koboSpan" id="kobo.314.1">ONBUILD RUN git submodule init \</span><br/><span class="koboSpan" id="kobo.315.1">       &amp;&amp; git submodule update \</span><br/><span class="koboSpan" id="kobo.316.1">       &amp;&amp; make</span><br/><span class="koboSpan" id="kobo.317.1">--- appimg.dck ---</span><br/><span class="koboSpan" id="kobo.318.1">FROM baseimg</span><br/><span class="koboSpan" id="kobo.319.1">EXPOSE 80</span><br/><span class="koboSpan" id="kobo.320.1">CMD ["/usr/src/app/entry"]</span></strong></pre>
<p><span class="koboSpan" id="kobo.321.1">The instruction then would be evaluated in the following order when running </span><kbd><span class="koboSpan" id="kobo.322.1">docker build</span></kbd><span><span class="koboSpan" id="kobo.323.1">:</span></span></p>
<pre style="padding-left: 30px"><strong><span class="koboSpan" id="kobo.324.1">$ docker build -t baseimg -f baseimg.dck .</span><br/><span class="koboSpan" id="kobo.325.1">---</span><br/><span class="koboSpan" id="kobo.326.1">FROM alpine</span><br/><span class="koboSpan" id="kobo.327.1">RUN apk add --no-cache git make</span><br/><span class="koboSpan" id="kobo.328.1">WORKDIR /usr/src/app</span><br/><span class="koboSpan" id="kobo.329.1">---</span><br/><span class="koboSpan" id="kobo.330.1">$ docker build -t appimg -f appimg.dck .</span><br/><span class="koboSpan" id="kobo.331.1">---</span><br/><span class="koboSpan" id="kobo.332.1">COPY . </span><span class="koboSpan" id="kobo.332.2">/usr/src/app/</span><br/><span class="koboSpan" id="kobo.333.1">RUN git submodule init   \</span><br/><span class="koboSpan" id="kobo.334.1"> &amp;&amp; git submodule update \</span><br/><span class="koboSpan" id="kobo.335.1"> &amp;&amp; make</span><br/><span class="koboSpan" id="kobo.336.1">EXPOSE 80</span><br/><span class="koboSpan" id="kobo.337.1">CMD ["/usr/src/app/entry"]</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Organizing a Dockerfile</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Even though writing a </span><kbd><span class="koboSpan" id="kobo.3.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.4.1"> is pretty much the same as composing a build script, there are some more factors that we should consider to build efficient, secure, and stable images. </span><span class="koboSpan" id="kobo.4.2">Moreover, a </span><kbd><span class="koboSpan" id="kobo.5.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.6.1"> itself is also a document. </span><span class="koboSpan" id="kobo.6.2">Keeping it readable makes it easier to manage.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Let's say we have an application stack that consists of application code, a database, and a cache. </span><span class="koboSpan" id="kobo.7.2">The initial </span><kbd><span class="koboSpan" id="kobo.8.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.9.1"> of our stack could be the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.10.1">FROM ubuntu</span><br/><span class="koboSpan" id="kobo.11.1">ADD . </span><span class="koboSpan" id="kobo.11.2">/proj</span><br/><span class="koboSpan" id="kobo.12.1">RUN apt-get update</span><br/><span class="koboSpan" id="kobo.13.1">RUN apt-get upgrade -y</span><br/><span class="koboSpan" id="kobo.14.1">RUN apt-get install -y redis-server python python-pip mysql-server</span><br/><span class="koboSpan" id="kobo.15.1">ADD /proj/db/my.cnf /etc/mysql/my.cnf</span><br/><span class="koboSpan" id="kobo.16.1">ADD /proj/db/redis.conf /etc/redis/redis.conf</span><br/><span class="koboSpan" id="kobo.17.1">ADD https://example.com/otherteam/dep.tgz /tmp/</span><br/><span class="koboSpan" id="kobo.18.1">RUN -zxf /tmp/dep.tgz -C /usr/src</span><br/><span class="koboSpan" id="kobo.19.1">RUN pip install -r /proj/app/requirements.txt</span><br/><span class="koboSpan" id="kobo.20.1">RUN cd /proj/app ; python setup.py</span><br/><span class="koboSpan" id="kobo.21.1">CMD /proj/start-all-service.sh</span></strong></pre>
<p><span class="koboSpan" id="kobo.22.1">The first suggestion is to make sure a container is dedicated to one thing and one thing only. </span><span class="koboSpan" id="kobo.22.2">This gives our system better transparency since it helps us clarify the boundaries between components in the system. </span><span class="koboSpan" id="kobo.22.3">Also, packing unnecessary packages is discouraged, as it increases the image size, which could slow down the time it takes to build, distribute, and launch the image. </span><span class="koboSpan" id="kobo.22.4">We'll remove the installation and configuration of both </span><kbd><span class="koboSpan" id="kobo.23.1">mysql</span></kbd><span class="koboSpan" id="kobo.24.1"> and </span><kbd><span class="koboSpan" id="kobo.25.1">redis</span></kbd><span class="koboSpan" id="kobo.26.1"> in our </span><kbd><span class="koboSpan" id="kobo.27.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.28.1"> in the beginning. </span><span class="koboSpan" id="kobo.28.2">Next, the code is moved into the container with </span><kbd><span class="koboSpan" id="kobo.29.1">ADD .</span></kbd><span class="koboSpan" id="kobo.30.1">, which means that we're very likely to move the whole code repository into the container. </span><span class="koboSpan" id="kobo.30.2">Usually, there're lots of files that aren't directly relevant to the application, including VCS files, CI server configurations, or even build caches, and we probably wouldn't like to pack them into an image. </span><span class="koboSpan" id="kobo.30.3">For this reason, it is suggested to use </span><kbd><span class="koboSpan" id="kobo.31.1">.dockerignore</span></kbd><span class="koboSpan" id="kobo.32.1"> to filter out these files as well. </span><span class="koboSpan" id="kobo.32.2">Lastly, using </span><kbd><span class="koboSpan" id="kobo.33.1">COPY</span></kbd><span class="koboSpan" id="kobo.34.1"> is preferred over </span><kbd><span class="koboSpan" id="kobo.35.1">ADD</span></kbd><span class="koboSpan" id="kobo.36.1"> in general, unless we want to extract a file in one step. </span><span class="koboSpan" id="kobo.36.2">This is because it is easier to predict the outcome when we use </span><kbd><span class="koboSpan" id="kobo.37.1">COPY</span></kbd><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">Now our </span><kbd><span class="koboSpan" id="kobo.39.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.40.1"> is simpler, as shown in the following code snippet:</span></p>
<pre><strong><span class="koboSpan" id="kobo.41.1">FROM ubuntu</span><br/><span class="koboSpan" id="kobo.42.1">ADD proj/app /app</span><br/><span class="koboSpan" id="kobo.43.1">RUN apt-get update</span><br/><span class="koboSpan" id="kobo.44.1">RUN apt-get upgrade -y</span><br/><span class="koboSpan" id="kobo.45.1">RUN apt-get install -y python python-pip</span><br/><span class="koboSpan" id="kobo.46.1">ADD https://example.com/otherteam/dep.tgz /tmp/</span><br/><span class="koboSpan" id="kobo.47.1">RUN tar -zxf /tmp/dep.tgz -C /usr/src</span><br/><span class="koboSpan" id="kobo.48.1">RUN pip install -r /app/requirements.txt</span><br/><span class="koboSpan" id="kobo.49.1">RUN cd /app ; python setup.py</span><br/><span class="koboSpan" id="kobo.50.1">CMD python app.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.51.1">While building an image, the Docker engine will try to reuse the cache layer as much as possible, which notably reduces the build time. </span><span class="koboSpan" id="kobo.51.2">In our </span><kbd><span class="koboSpan" id="kobo.52.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.53.1">, we have to go through all the updating and dependency installation processes if any package to be installed needs updating. </span><span class="koboSpan" id="kobo.53.2">To benefit from building caches, we'll re-order the directives based on a rule of thumb: run less frequent instructions first.</span></p>
<p><span class="koboSpan" id="kobo.54.1">Additionally, as we've described before, any changes made to the container filesystem result in a new image layer. </span><span class="koboSpan" id="kobo.54.2">To be more specific, </span><kbd><span class="koboSpan" id="kobo.55.1">ADD</span></kbd><span class="koboSpan" id="kobo.56.1">, </span><kbd><span class="koboSpan" id="kobo.57.1">RUN</span></kbd><span class="koboSpan" id="kobo.58.1">, and </span><kbd><span class="koboSpan" id="kobo.59.1">COPY</span></kbd><span class="koboSpan" id="kobo.60.1"> create layers. </span><span class="koboSpan" id="kobo.60.2">Even though we deleted certain files in the consequent layer, these files still occupy image layers as they're still being kept at intermediate layers. </span><span class="koboSpan" id="kobo.60.3">Therefore, our next step is to minimize the image layers by simply compacting multiple </span><kbd><span class="koboSpan" id="kobo.61.1">RUN</span></kbd><span class="koboSpan" id="kobo.62.1"> instructions and cleaning the unused files at the end of the </span><kbd><span class="koboSpan" id="kobo.63.1">RUN</span></kbd><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">Moreover, to keep the readability of the </span><kbd><span class="koboSpan" id="kobo.65.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.66.1">, we tend to format the compacted </span><kbd><span class="koboSpan" id="kobo.67.1">RUN</span></kbd><span class="koboSpan" id="kobo.68.1"> with the line continuation character, </span><kbd><span class="koboSpan" id="kobo.69.1">\</span></kbd><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Although </span><kbd><span class="koboSpan" id="kobo.71.1">ADD</span></kbd><span class="koboSpan" id="kobo.72.1"> can fetch a file from a remote location to the image, it's still not a good idea to do this as this would still occupy a layer in order to store the downloaded file. </span><span class="koboSpan" id="kobo.72.2">Downloading files with </span><kbd><span class="koboSpan" id="kobo.73.1">RUN</span></kbd><span class="koboSpan" id="kobo.74.1"> and </span><kbd><span class="koboSpan" id="kobo.75.1">wget/curl</span></kbd><span class="koboSpan" id="kobo.76.1"> is more common.</span></p>
<p><span class="koboSpan" id="kobo.77.1">In addition to working with the building mechanisms of Docker, we'd also like to write a maintainable </span><kbd><span class="koboSpan" id="kobo.78.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.79.1"> to make it clearer, more predictable, and more stable. </span><span class="koboSpan" id="kobo.79.2">Here are some suggestions:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.80.1">Use </span><kbd><span class="koboSpan" id="kobo.81.1">WORKDIR</span></kbd><span class="koboSpan" id="kobo.82.1"> instead of the inline </span><kbd><span class="koboSpan" id="kobo.83.1">cd</span></kbd><span class="koboSpan" id="kobo.84.1">, and use the absolute path for </span><kbd><span class="koboSpan" id="kobo.85.1">WORKDIR</span></kbd></li>
<li><span class="koboSpan" id="kobo.86.1">Explicitly expose the required ports</span></li>
<li><span class="koboSpan" id="kobo.87.1">Specify a tag for the base image</span></li>
<li><span class="koboSpan" id="kobo.88.1">Separate and sort packages line by line</span></li>
<li><span class="koboSpan" id="kobo.89.1">Use the </span><kbd><span class="koboSpan" id="kobo.90.1">exec</span></kbd><span class="koboSpan" id="kobo.91.1"> form to launch an application</span></li>
</ul>
<p><span class="koboSpan" id="kobo.92.1">The first four suggestions are pretty straightforward, aimed at eliminating ambiguity. </span><span class="koboSpan" id="kobo.92.2">The last one refers to how an application is terminated. </span><span class="koboSpan" id="kobo.92.3">When a stop request from the Docker daemon is sent to a running container, the main process (</span><kbd><span class="koboSpan" id="kobo.93.1">PID 1</span></kbd><span class="koboSpan" id="kobo.94.1">) will receive a stop signal (</span><kbd><span class="koboSpan" id="kobo.95.1">SIGTERM</span></kbd><span class="koboSpan" id="kobo.96.1">). </span><span class="koboSpan" id="kobo.96.2">If the process is not stopped after a certain period of time, the Docker daemon will send another signal (</span><kbd><span class="koboSpan" id="kobo.97.1">SIGKILL</span></kbd><span class="koboSpan" id="kobo.98.1">) to kill the container. </span><span class="koboSpan" id="kobo.98.2">The </span><kbd><span class="koboSpan" id="kobo.99.1">exec</span></kbd><span class="koboSpan" id="kobo.100.1"> form and shell form differ here. </span><span class="koboSpan" id="kobo.100.2">In the shell form, the </span><kbd><span class="koboSpan" id="kobo.101.1">PID 1</span></kbd><span class="koboSpan" id="kobo.102.1"> process is </span><kbd><span class="koboSpan" id="kobo.103.1">/bin/sh -c</span></kbd><span class="koboSpan" id="kobo.104.1">, not the application. </span><span class="koboSpan" id="kobo.104.2">Furthermore, different shells don't handle signals in the same way. </span><span class="koboSpan" id="kobo.104.3">Some forward the stop signal to the child processes, while some do not. </span><span class="koboSpan" id="kobo.104.4">The shell at Alpine Linux doesn't forward them. </span><span class="koboSpan" id="kobo.104.5">As a result, to stop and clean up our application properly, using the </span><kbd><span class="koboSpan" id="kobo.105.1">exec</span></kbd><span class="koboSpan" id="kobo.106.1"> form is encouraged.</span></p>
<p><span class="koboSpan" id="kobo.107.1">Combining those principles, we have the following </span><kbd><span class="koboSpan" id="kobo.108.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.109.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.110.1">FROM ubuntu:18.04</span><br/><br/><span class="koboSpan" id="kobo.111.1">RUN apt-get update &amp;&amp; apt-get upgrade -y \</span><br/><span class="koboSpan" id="kobo.112.1"> &amp;&amp; apt-get install -y </span><span><span class="koboSpan" id="kobo.113.1">--no-install-recommends </span></span><span class="koboSpan" id="kobo.114.1">\</span><br/><span class="koboSpan" id="kobo.115.1">      curl \</span><br/><span class="koboSpan" id="kobo.116.1">      python3.6 \</span><br/><span class="koboSpan" id="kobo.117.1">      python-pip=9.* \</span><br/><span class="koboSpan" id="kobo.118.1"> &amp;&amp; curl -SL https://example.com/otherteam/dep.tgz \</span><br/><span class="koboSpan" id="kobo.119.1">  | tar -zxC /usr/src \</span><br/><span class="koboSpan" id="kobo.120.1"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br/><br/><span class="koboSpan" id="kobo.121.1">ENTRYPOINT ["python"]</span><br/><span class="koboSpan" id="kobo.122.1">CMD ["entry.py"]</span><br/><span class="koboSpan" id="kobo.123.1">EXPOSE 5000</span><br/><span class="koboSpan" id="kobo.124.1">WORKDIR /app</span><br/><span class="koboSpan" id="kobo.125.1">COPY requirements.txt .</span><br/><span class="koboSpan" id="kobo.126.1">RUN pip install -r requirements.txt</span><br/><span class="koboSpan" id="kobo.127.1">COPY . </span><span class="koboSpan" id="kobo.127.2">/app</span></strong></pre>
<p><span class="koboSpan" id="kobo.128.1">There are other practices that we can follow to make our </span><kbd><span class="koboSpan" id="kobo.129.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.130.1"> better, including starting from a dedicated and smaller base image rather than general-purpose distributions, using users other than </span><kbd><span class="koboSpan" id="kobo.131.1">root</span></kbd><span class="koboSpan" id="kobo.132.1"> for better security, and removing unnecessary files in the </span><kbd><span class="koboSpan" id="kobo.133.1">RUN</span></kbd><span class="koboSpan" id="kobo.134.1"> in which they are joined.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Multi-stage builds</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The principles we've discussed so far are all about how to make builds fast and how to make the final image smaller while keeping the maintainability of the </span><kbd><span class="koboSpan" id="kobo.3.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Instead of striving to optimize a </span><kbd><span class="koboSpan" id="kobo.5.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.6.1">, writing one to build the artifacts we need and then moving them to another image with runtime dependencies only makes it much easier to sort the </span><span><span class="koboSpan" id="kobo.7.1">different</span></span><span><span class="koboSpan" id="kobo.8.1"> </span></span><span><span class="koboSpan" id="kobo.9.1">logic out. </span><span class="koboSpan" id="kobo.9.2">In the building stage, we can forget about minimizing the layers so that the build cache can be reused efficiently; when it comes to the release image, we can follow the previously recommended techniques to make our image clean and small. </span><span class="koboSpan" id="kobo.9.3">Before Docker CE 17.05, we had to write two Dockerfiles to implement this build pattern. </span><span class="koboSpan" id="kobo.9.4">Now, Docker has built-in support to define different stages in a single</span></span> <kbd><span class="koboSpan" id="kobo.10.1">Dockerfile</span></kbd><span><span class="koboSpan" id="kobo.11.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Take a </span><kbd><span class="koboSpan" id="kobo.13.1">golang</span></kbd><span class="koboSpan" id="kobo.14.1"> build as an example: this requires lots of dependencies and a compiler, but the artifact can merely be a single binary. </span><span class="koboSpan" id="kobo.14.2">Let's look at the following example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.15.1">FROM golang:1.11 AS builder</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">ARG GOOS=linux</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">ARG GOARCH=amd64</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">ARG CGO_ENABLED=0</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">WORKDIR /go/src/app</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">COPY main.go .</span><br/><span class="koboSpan" id="kobo.21.1">RUN go get .</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">RUN go build -a -tags netgo -ldflags '-w -s -extldflags "-static"'</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.23.1">FROM scratch</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">COPY --from=builder /go/src/app/app .</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">ENTRYPOINT ["/app"]</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">CMD ["--help"]</span></strong></pre>
<p><span class="koboSpan" id="kobo.27.1">The delimiter for the different stages is the </span><kbd><span class="koboSpan" id="kobo.28.1">FROM</span></kbd><span class="koboSpan" id="kobo.29.1"> directive, and we can name the stages with the </span><kbd><span class="koboSpan" id="kobo.30.1">AS</span></kbd> <span><span class="koboSpan" id="kobo.31.1">keyword </span></span><span class="koboSpan" id="kobo.32.1">after the image name. </span><span class="koboSpan" id="kobo.32.2">At the </span><kbd><span class="koboSpan" id="kobo.33.1">builder</span></kbd><span class="koboSpan" id="kobo.34.1"> stage, Docker starts a </span><kbd><span class="koboSpan" id="kobo.35.1">golang</span></kbd><span class="koboSpan" id="kobo.36.1"> base image, and then builds the target binary as usual. </span><span class="koboSpan" id="kobo.36.2">Afterwards, during the second build, it copies the binary from the </span><kbd><span class="koboSpan" id="kobo.37.1">builder</span></kbd><span class="koboSpan" id="kobo.38.1"> container with </span><kbd><span class="koboSpan" id="kobo.39.1">--from=[stage name|image name]</span></kbd><span class="koboSpan" id="kobo.40.1"> to a </span><kbd><span class="koboSpan" id="kobo.41.1">scratch</span></kbd><span class="koboSpan" id="kobo.42.1"> image—a reserved name for an entirely empty image. </span><span class="koboSpan" id="kobo.42.2">As there's only one binary file and one layer in the resultant image, its size is dramatically smaller than the </span><kbd><span class="koboSpan" id="kobo.43.1">builder</span></kbd><span class="koboSpan" id="kobo.44.1"> one. </span></p>
<p><span class="koboSpan" id="kobo.45.1">The number of stages isn't limited to two, and the source of the </span><kbd><span class="koboSpan" id="kobo.46.1">COPY</span></kbd><span class="koboSpan" id="kobo.47.1"> directive can either be a previously defined stage or a built image. </span><span class="koboSpan" id="kobo.47.2">The </span><kbd><span class="koboSpan" id="kobo.48.1">ARG</span></kbd><span class="koboSpan" id="kobo.49.1"> directive works against </span><kbd><span class="koboSpan" id="kobo.50.1">FROM</span></kbd><span class="koboSpan" id="kobo.51.1">, which is also the only exception that can be written before a </span><kbd><span class="koboSpan" id="kobo.52.1">FROM</span></kbd><span class="koboSpan" id="kobo.53.1"> directive, as they belong to different stages. </span><span class="koboSpan" id="kobo.53.2">In order to use it, </span><span><span class="koboSpan" id="kobo.54.1">the </span></span><kbd><span class="koboSpan" id="kobo.55.1">ARG</span></kbd><span><span class="koboSpan" id="kobo.56.1"> directive to be consumed in </span></span><kbd><span class="koboSpan" id="kobo.57.1">FROM</span></kbd><span><span class="koboSpan" id="kobo.58.1"> should be declared before </span></span><kbd><span class="koboSpan" id="kobo.59.1">FROM</span></kbd><span class="koboSpan" id="kobo.60.1">, as shown here:</span></p>
<pre><strong><span class="koboSpan" id="kobo.61.1">ARG TAGS=latest</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">FROM ubuntu:$TAGS</span><br/></strong><strong><span class="koboSpan" id="kobo.63.1">...</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Multi-container orchestration</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As we pack more and more applications into isolated boxes, we'll soon realize that we need a tool that is able to help us tackle many containers simultaneously. </span><span class="koboSpan" id="kobo.2.2">In this section, we'll move a step up from spinning up just one single container to orchestrating multiple containers in a band.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Piling up containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Modern systems are usually built as stacks made up of multiple components that are distributed over networks, such as application servers, caches, databases, and message queues. </span><span class="koboSpan" id="kobo.2.2">Each individual component is also a self-contained system with many sub-components. </span><span class="koboSpan" id="kobo.2.3">What's more, the rising trend of microservices introduces additional degrees of complexity into these entangled relationships between systems. </span><span class="koboSpan" id="kobo.2.4">Because of this, even though container technology gives us a certain degree of relief regarding deployment tasks, coordinating components in a system is still difficult.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Let's say we have a simple application called </span><kbd><span class="koboSpan" id="kobo.4.1">kiosk</span></kbd><span class="koboSpan" id="kobo.5.1">, which connects to a </span><kbd><span class="koboSpan" id="kobo.6.1">redis</span></kbd><span class="koboSpan" id="kobo.7.1"> to manage how many tickets we currently have. </span><span class="koboSpan" id="kobo.7.2">Once a ticket is sold, it publishes an event through a </span><kbd><span class="koboSpan" id="kobo.8.1">redis</span></kbd><span class="koboSpan" id="kobo.9.1"> channel. </span><span class="koboSpan" id="kobo.9.2">The </span><strong><span class="koboSpan" id="kobo.10.1">recorder</span></strong><span class="koboSpan" id="kobo.11.1"> subscribes the </span><kbd><span class="koboSpan" id="kobo.12.1">redis</span></kbd><span class="koboSpan" id="kobo.13.1"> channel and writes a timestamp log into a MySQL database upon receiving any event.</span></p>
<p><span class="koboSpan" id="kobo.14.1">For the </span><kbd><span class="koboSpan" id="kobo.15.1">kiosk</span></kbd><span class="koboSpan" id="kobo.16.1"> and the </span><kbd><span class="koboSpan" id="kobo.17.1">recorder</span></kbd><span class="koboSpan" id="kobo.18.1">, you can find the code as well as their Dockerfiles here: </span><a href="https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter2"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter2</span></a><span class="koboSpan" id="kobo.20.1">. The architecture is as follows:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.21.1"><img class="alignnone size-full wp-image-163 image-border" src="assets/0adc75ae-67ca-499e-bf09-be8ca35c7489.png" style="width:26.67em;height:17.08em;"/></span></div>
<p><span class="koboSpan" id="kobo.22.1">We know how to start those containers separately and connect them with each other. </span><span class="koboSpan" id="kobo.22.2">Based on what we've discussed before, we would first create a bridge network and run the containers inside:</span></p>
<pre><strong><span class="koboSpan" id="kobo.23.1">$ docker network create kiosk</span><br/><span class="koboSpan" id="kobo.24.1">$ docker run -d --network-alias lcredis --network=kiosk redis</span><br/><span class="koboSpan" id="kobo.25.1">$ docker run -d --network-alias lmysql -e MYSQL_ROOT_PASSWORD=$MYPS \</span><br/><span class="koboSpan" id="kobo.26.1">                --network=kiosk mysql:5.7</span><br/><span class="koboSpan" id="kobo.27.1">$ docker run -d -p 5000:5000 \</span><br/><span class="koboSpan" id="kobo.28.1">                -e REDIS_HOST=lcredis --network=kiosk kiosk-example</span><br/><span class="koboSpan" id="kobo.29.1">$ docker run -d -e REDIS_HOST=lcredis -e MYSQL_HOST=lmysql      \</span><br/><span class="koboSpan" id="kobo.30.1">                -e MYSQL_ROOT_PASSWORD=$MYPS -e MYSQL_USER=root \</span><br/><span class="koboSpan" id="kobo.31.1">                --network=kiosk recorder-example</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.32.1">Because our </span><kbd><span class="koboSpan" id="kobo.33.1">kiosk</span></kbd><span class="koboSpan" id="kobo.34.1"> and </span><kbd><span class="koboSpan" id="kobo.35.1">recorder</span></kbd><span class="koboSpan" id="kobo.36.1"> are much lighter than the database, our applications are very likely to start up earlier than the database's. </span><span class="koboSpan" id="kobo.36.2">In this case, our </span><kbd><span class="koboSpan" id="kobo.37.1">kiosk</span></kbd><span class="koboSpan" id="kobo.38.1"> might fail if any incoming connection requests changes to the databases or to Redis. </span><span class="koboSpan" id="kobo.38.2">In other words, we have to consider the startup order in our startup scripts. </span><span class="koboSpan" id="kobo.38.3">We also have to deal with problems such as how to deal with random components crashing, how to manage variables, how to scale out certain components, and how to manage the states of every moving part.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">An overview of Docker compose</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Docker compose is a tool that enables us to run multiple containers with ease. </span><span class="koboSpan" id="kobo.2.2">It's a built-in tool in the Docker CE distribution. </span><span class="koboSpan" id="kobo.2.3">All it does is read </span><kbd><span class="koboSpan" id="kobo.3.1">docker-compose.yml</span></kbd><span class="koboSpan" id="kobo.4.1"> (or </span><kbd><span class="koboSpan" id="kobo.5.1">.yaml</span></kbd><span class="koboSpan" id="kobo.6.1">) to run the defined containers. </span><span class="koboSpan" id="kobo.6.2">A </span><kbd><span class="koboSpan" id="kobo.7.1">docker-compose</span></kbd><span class="koboSpan" id="kobo.8.1"> file is a YAML-based template, and it typically looks like this:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">version: '3'</span><br/><span class="koboSpan" id="kobo.10.1">services:</span><br/><span class="koboSpan" id="kobo.11.1"> hello-world:</span><br/><span class="koboSpan" id="kobo.12.1"> image: hello-world</span></pre>
<p><span class="koboSpan" id="kobo.13.1">Launching it is pretty simple: save the template to </span><kbd><span class="koboSpan" id="kobo.14.1">docker-compose.yml</span></kbd><span class="koboSpan" id="kobo.15.1"> and use the </span><kbd><span class="koboSpan" id="kobo.16.1">docker-compose up</span></kbd><span class="koboSpan" id="kobo.17.1"> command to start it:</span></p>
<pre><strong><span class="koboSpan" id="kobo.18.1">$ docker-compose up</span><br/><span class="koboSpan" id="kobo.19.1">Creating network "user_default" with the default driver</span><br/><span class="koboSpan" id="kobo.20.1">Pulling hello-world (hello-world:)...</span><br/><span class="koboSpan" id="kobo.21.1">...</span><br/><span class="koboSpan" id="kobo.22.1">Creating user_hello-world_1 ... </span><span class="koboSpan" id="kobo.22.2">done</span><br/><span class="koboSpan" id="kobo.23.1">Attaching to user_hello-world_1</span><br/><span class="koboSpan" id="kobo.24.1">hello-world_1  |</span><br/><span class="koboSpan" id="kobo.25.1">hello-world_1  | Hello from Docker!</span><br/><span class="koboSpan" id="kobo.26.1">hello-world_1  | This message shows that your installation appears to be working correctly.</span><br/><span class="koboSpan" id="kobo.27.1">...</span><br/><span class="koboSpan" id="kobo.28.1">user_hello-world_1 exited with code 0</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.29.1">Let's take a look at what </span><kbd><span class="koboSpan" id="kobo.30.1">docker-compose</span></kbd><span class="koboSpan" id="kobo.31.1"> did when the </span><kbd><span class="koboSpan" id="kobo.32.1">up</span></kbd><span class="koboSpan" id="kobo.33.1"> command was executed.</span></p>
<p><span class="koboSpan" id="kobo.34.1">Docker compose is basically a medley of Docker functions for multiple containers. </span><span class="koboSpan" id="kobo.34.2">For example, the counterpart of </span><kbd><span class="koboSpan" id="kobo.35.1">docker build</span></kbd><span class="koboSpan" id="kobo.36.1"> is </span><kbd><span class="koboSpan" id="kobo.37.1">docker-compose build</span></kbd><span class="koboSpan" id="kobo.38.1">; the former builds a Docker image and the latter builds Docker images listed in </span><kbd><span class="koboSpan" id="kobo.39.1">docker-compose.yml</span></kbd><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">Remember, however, that the </span><kbd><span class="koboSpan" id="kobo.41.1">docker-compose run</span></kbd><span class="koboSpan" id="kobo.42.1"> command doesn't correspond to </span><kbd><span class="koboSpan" id="kobo.43.1">docker run</span></kbd><span class="koboSpan" id="kobo.44.1">; it's actually used to run a specific container from the configuration in </span><kbd><span class="koboSpan" id="kobo.45.1">docker-compose.yml</span></kbd><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">In fact, the closest command to </span><kbd><span class="koboSpan" id="kobo.47.1">docker run</span></kbd><span class="koboSpan" id="kobo.48.1"> is </span><kbd><span class="koboSpan" id="kobo.49.1">docker-compose up</span></kbd><span class="koboSpan" id="kobo.50.1">.</span></p>
<p><span class="koboSpan" id="kobo.51.1">The </span><kbd><span class="koboSpan" id="kobo.52.1">docker-compose.yml</span></kbd><span class="koboSpan" id="kobo.53.1"> file consists of different configurations of volumes, networks, and services. </span><span class="koboSpan" id="kobo.53.2">There should be a version definition to indicate which version of the </span><kbd><span class="koboSpan" id="kobo.54.1">docker-compose</span></kbd><span class="koboSpan" id="kobo.55.1"> format should be used. </span><span class="koboSpan" id="kobo.55.2">With this understanding of the template structure, what the previous </span><kbd><span class="koboSpan" id="kobo.56.1">hello-world</span></kbd><span class="koboSpan" id="kobo.57.1"> example does is quite clear; it creates a service called </span><kbd><span class="koboSpan" id="kobo.58.1">hello-world</span></kbd><span class="koboSpan" id="kobo.59.1"> that uses the </span><kbd><span class="koboSpan" id="kobo.60.1">hello-world:latest</span></kbd><span class="koboSpan" id="kobo.61.1"> image.</span></p>
<p><span class="koboSpan" id="kobo.62.1">Since there's no network defined, </span><kbd><span class="koboSpan" id="kobo.63.1">docker-compose</span></kbd><span class="koboSpan" id="kobo.64.1"> will create a new network with a default driver and connect services to that network, as shown at the start of the </span><span><span class="koboSpan" id="kobo.65.1">output</span></span><span><span class="koboSpan" id="kobo.66.1"> of the example.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">The network name of a container will be the name of the service. </span><span class="koboSpan" id="kobo.67.2">You may notice that the name displayed in the console differs slightly from its original one in </span><kbd><span class="koboSpan" id="kobo.68.1">docker-compose.yml</span></kbd><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">This is because Docker compose tries to avoid name conflicts between containers. </span><span class="koboSpan" id="kobo.69.3">As a result, Docker compose runs the container with the name it generated and makes a network alias with the service name. </span><span class="koboSpan" id="kobo.69.4">In this example, both </span><kbd><span class="koboSpan" id="kobo.70.1">hello-world</span></kbd><span class="koboSpan" id="kobo.71.1"> and </span><kbd><span class="koboSpan" id="kobo.72.1">user_hello-world_1</span></kbd><span class="koboSpan" id="kobo.73.1"> are resolvable to other containers within the same network.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.74.1">Docker compose is the easiest option to run multiple containers on a single machine, but it's not designed to orchestrate containers across networks. </span><span class="koboSpan" id="kobo.74.2">Other major container orchestration engines such as </span><strong><span class="koboSpan" id="kobo.75.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.76.1">, </span><strong><span class="koboSpan" id="kobo.77.1">Docker Swarm</span></strong><span class="koboSpan" id="kobo.78.1">, </span><strong><span class="koboSpan" id="kobo.79.1">Mesos</span></strong><span class="koboSpan" id="kobo.80.1"> (with </span><strong><span class="koboSpan" id="kobo.81.1">Marathon</span></strong><span class="koboSpan" id="kobo.82.1"> or </span><strong><span class="koboSpan" id="kobo.83.1">Aurora</span></strong><span class="koboSpan" id="kobo.84.1">), or </span><strong><span class="koboSpan" id="kobo.85.1">Nomad</span></strong><span class="koboSpan" id="kobo.86.1"> are better choices to run containers across multiple nodes.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Composing containers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As Docker compose is the same as Docker in many aspects, it's more efficient to understand how to write </span><kbd><span class="koboSpan" id="kobo.3.1">docker-compose.yml</span></kbd><span class="koboSpan" id="kobo.4.1"> with examples than start from </span><kbd><span class="koboSpan" id="kobo.5.1">docker-compose</span></kbd><span class="koboSpan" id="kobo.6.1"> syntax. </span><span class="koboSpan" id="kobo.6.2">Let's now go back to the </span><kbd><span class="koboSpan" id="kobo.7.1">kiosk-example</span></kbd><span class="koboSpan" id="kobo.8.1"> we looked at earlier and start with a </span><kbd><span class="koboSpan" id="kobo.9.1">version</span></kbd><span class="koboSpan" id="kobo.10.1"> definition and four </span><kbd><span class="koboSpan" id="kobo.11.1">services</span></kbd><span class="koboSpan" id="kobo.12.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.13.1">version: '3'</span><br/><span class="koboSpan" id="kobo.14.1">services:</span><br/><span class="koboSpan" id="kobo.15.1">  kiosk-example:</span><br/><span class="koboSpan" id="kobo.16.1">  recorder-example:</span><br/><span class="koboSpan" id="kobo.17.1">  lcredis:</span><br/><span class="koboSpan" id="kobo.18.1">  lmysql:</span></strong></pre>
<p><span class="koboSpan" id="kobo.19.1">The </span><kbd><span class="koboSpan" id="kobo.20.1">docker run</span></kbd><span class="koboSpan" id="kobo.21.1"> arguments for </span><kbd><span class="koboSpan" id="kobo.22.1">kiosk-example</span></kbd><span class="koboSpan" id="kobo.23.1"> are pretty simple. </span><span class="koboSpan" id="kobo.23.2">They include a publishing port and an environment variable. </span><span class="koboSpan" id="kobo.23.3">On the Docker compose side, we fill the source image, the publishing port, and environment variables accordingly. </span><span class="koboSpan" id="kobo.23.4">Because Docker compose is able to handle </span><kbd><span class="koboSpan" id="kobo.24.1">docker build</span></kbd><span class="koboSpan" id="kobo.25.1">, it can build images if those images can't be found locally. </span><span class="koboSpan" id="kobo.25.2">We want to use this to decrease the effort of image management:</span></p>
<pre><strong><span class="koboSpan" id="kobo.26.1">kiosk-example:</span><br/><span class="koboSpan" id="kobo.27.1">  image: kiosk-example</span><br/><span class="koboSpan" id="kobo.28.1">  build: ./kiosk</span><br/><span class="koboSpan" id="kobo.29.1">  ports:</span><br/><span class="koboSpan" id="kobo.30.1">  - "5000:5000"</span><br/><span class="koboSpan" id="kobo.31.1">  environment:</span><br/><span class="koboSpan" id="kobo.32.1">    REDIS_HOST: lcredis</span></strong></pre>
<p><span class="koboSpan" id="kobo.33.1">Converting the Docker run of the </span><kbd><span class="koboSpan" id="kobo.34.1">recorder-example</span></kbd><span class="koboSpan" id="kobo.35.1"> and </span><kbd><span class="koboSpan" id="kobo.36.1">redis</span></kbd><span class="koboSpan" id="kobo.37.1"> in the same manner, we have a template that looks as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.38.1">version: '3'</span><br/><span class="koboSpan" id="kobo.39.1">services:</span><br/><span class="koboSpan" id="kobo.40.1">  kiosk-example:</span><br/><span class="koboSpan" id="kobo.41.1">    image: kiosk-example</span><br/><span class="koboSpan" id="kobo.42.1">    build: ./kiosk</span><br/><span class="koboSpan" id="kobo.43.1">    ports:</span><br/><span class="koboSpan" id="kobo.44.1">    - "5000:5000"</span><br/><span class="koboSpan" id="kobo.45.1">    environment:</span><br/><span class="koboSpan" id="kobo.46.1">      REDIS_HOST: lcredis</span><br/><span class="koboSpan" id="kobo.47.1">  recorder-example:</span><br/><span class="koboSpan" id="kobo.48.1">    image: recorder-example</span><br/><span class="koboSpan" id="kobo.49.1">    build: ./recorder</span><br/><span class="koboSpan" id="kobo.50.1">    environment:</span><br/><span class="koboSpan" id="kobo.51.1">      REDIS_HOST: lcredis</span><br/><span class="koboSpan" id="kobo.52.1">      MYSQL_HOST: lmysql</span><br/><span class="koboSpan" id="kobo.53.1">      MYSQL_USER: root</span><br/><span class="koboSpan" id="kobo.54.1">      MYSQL_ROOT_PASSWORD: mysqlpass</span><br/><span class="koboSpan" id="kobo.55.1">  lcredis:</span><br/><span class="koboSpan" id="kobo.56.1">    image: redis</span><br/><span class="koboSpan" id="kobo.57.1">    ports:</span><br/><span class="koboSpan" id="kobo.58.1">    - "6379"</span></strong></pre>
<p><span class="koboSpan" id="kobo.59.1">For the MySQL part, </span><span><span><span class="koboSpan" id="kobo.60.1">MySQL</span></span></span><span class="koboSpan" id="kobo.61.1"> requires a data volume to keep its data as well as its configurations. </span><span class="koboSpan" id="kobo.61.2">In addition to the </span><kbd><span class="koboSpan" id="kobo.62.1">lmysql</span></kbd><span class="koboSpan" id="kobo.63.1"> section, we add </span><kbd><span class="koboSpan" id="kobo.64.1">volumes</span></kbd><span class="koboSpan" id="kobo.65.1"> at the level of </span><kbd><span class="koboSpan" id="kobo.66.1">services</span></kbd><span class="koboSpan" id="kobo.67.1"> and an empty map called </span><kbd><span class="koboSpan" id="kobo.68.1">mysql-vol</span></kbd><span class="koboSpan" id="kobo.69.1"> to claim a data volume:</span></p>
<pre><strong><span class="koboSpan" id="kobo.70.1">  lmysql:</span><br/><span class="koboSpan" id="kobo.71.1">    image: mysql:5.7</span><br/><span class="koboSpan" id="kobo.72.1">    environment:</span><br/><span class="koboSpan" id="kobo.73.1">      MYSQL_ROOT_PASSWORD: mysqlpass</span><br/><span class="koboSpan" id="kobo.74.1">      MYSQL_DATABASE: db</span><br/><span class="koboSpan" id="kobo.75.1">      MYSQL_USER: user</span><br/><span class="koboSpan" id="kobo.76.1">      MYSQL_PASSWORD: pass</span><br/><span class="koboSpan" id="kobo.77.1">    volumes:</span><br/><span class="koboSpan" id="kobo.78.1">    - mysql-vol:/var/lib/mysql</span><br/><span class="koboSpan" id="kobo.79.1">    ports:</span><br/><span class="koboSpan" id="kobo.80.1">    - "3306"</span><br/><span class="koboSpan" id="kobo.81.1">volumes:</span><br/><span class="koboSpan" id="kobo.82.1">  mysql-vol: {}</span></strong></pre>
<p><span class="koboSpan" id="kobo.83.1">One of the benefits of this is that we can manage the launching order between the components with </span><kbd><span class="koboSpan" id="kobo.84.1">depends_on</span></kbd><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">What this does is maintain the order; it can't detect whether the components that it will use are ready. </span><span class="koboSpan" id="kobo.85.3">This means our application could </span><span><span class="koboSpan" id="kobo.86.1">still</span></span><span><span class="koboSpan" id="kobo.87.1"> connect and write to the database</span></span><span class="koboSpan" id="kobo.88.1"> </span><span><span class="koboSpan" id="kobo.89.1">before the database is ready. </span><span class="koboSpan" id="kobo.89.2">All in all, as our program is a part of a distributed system with many moving parts, it's a good idea to make it resilient to the changes of its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">Combining all of the preceding configurations, including </span><kbd><span><span class="koboSpan" id="kobo.91.1">depends_on</span></span></kbd><span class="koboSpan" id="kobo.92.1">, we have the final template, as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.93.1">version: '3'</span></strong><br/><strong><span class="koboSpan" id="kobo.94.1">services:</span></strong><br/><strong><span class="koboSpan" id="kobo.95.1">  kiosk-example:</span></strong><br/><strong><span class="koboSpan" id="kobo.96.1">    image: kiosk-example</span></strong><br/><strong><span class="koboSpan" id="kobo.97.1">    build: ./kiosk</span></strong><br/><strong><span class="koboSpan" id="kobo.98.1">    ports:</span></strong><br/><strong><span class="koboSpan" id="kobo.99.1">    - "5000:5000"</span></strong><br/><strong><span class="koboSpan" id="kobo.100.1">    environment:</span></strong><br/><strong><span class="koboSpan" id="kobo.101.1">      REDIS_HOST: lcredis</span></strong><br/><strong><span class="koboSpan" id="kobo.102.1">    depends_on:</span></strong><br/><strong><span class="koboSpan" id="kobo.103.1">    - lcredis</span></strong><br/><strong><span class="koboSpan" id="kobo.104.1">  recorder-example:</span></strong><br/><strong><span class="koboSpan" id="kobo.105.1">    image: recorder-example</span></strong><br/><strong><span class="koboSpan" id="kobo.106.1">    build: ./recorder</span></strong><br/><strong><span class="koboSpan" id="kobo.107.1">    environment:</span></strong><br/><strong><span class="koboSpan" id="kobo.108.1">      REDIS_HOST: lcredis</span></strong><br/><strong><span class="koboSpan" id="kobo.109.1">      MYSQL_HOST: lmysql</span></strong><br/><strong><span class="koboSpan" id="kobo.110.1">      MYSQL_USER: root</span></strong><br/><strong><span class="koboSpan" id="kobo.111.1">      MYSQL_ROOT_PASSWORD: mysqlpass</span></strong><br/><strong><span class="koboSpan" id="kobo.112.1">    depends_on:</span></strong><br/><strong><span class="koboSpan" id="kobo.113.1">    - lmysql</span></strong><br/><strong><span class="koboSpan" id="kobo.114.1">    - lcredis</span></strong><br/><strong><span class="koboSpan" id="kobo.115.1">  lcredis:</span></strong><br/><strong><span class="koboSpan" id="kobo.116.1">    image: redis</span></strong><br/><strong><span class="koboSpan" id="kobo.117.1">    ports:</span></strong><br/><strong><span class="koboSpan" id="kobo.118.1">    - "6379"</span></strong><br/><strong><span class="koboSpan" id="kobo.119.1">  lmysql:</span></strong><br/><strong><span class="koboSpan" id="kobo.120.1">    image: mysql:5.7</span></strong><br/><strong><span class="koboSpan" id="kobo.121.1">    environment:</span></strong><br/><strong><span class="koboSpan" id="kobo.122.1">      MYSQL_ROOT_PASSWORD: mysqlpass</span></strong><br/><strong><span class="koboSpan" id="kobo.123.1">      MYSQL_DATABASE: db</span></strong><br/><strong><span class="koboSpan" id="kobo.124.1">      MYSQL_USER: user</span></strong><br/><strong><span class="koboSpan" id="kobo.125.1">      MYSQL_PASSWORD: pass</span></strong><br/><strong><span class="koboSpan" id="kobo.126.1">    volumes:</span></strong><br/><strong><span class="koboSpan" id="kobo.127.1">    - mysql-vol:/var/lib/mysql</span></strong><br/><strong><span class="koboSpan" id="kobo.128.1">    ports:</span></strong><br/><strong><span class="koboSpan" id="kobo.129.1">    - "3306"</span></strong><br/><strong><span class="koboSpan" id="kobo.130.1">volumes:</span></strong><br/><strong><span class="koboSpan" id="kobo.131.1">  mysql-vol: {}</span></strong></pre>
<p><span class="koboSpan" id="kobo.132.1">This file is put in the </span><kbd><span class="koboSpan" id="kobo.133.1">root</span></kbd><span class="koboSpan" id="kobo.134.1"> folder of a project. </span><span class="koboSpan" id="kobo.134.2">The corresponding file tree is shown here:</span></p>
<pre><strong><span class="koboSpan" id="kobo.135.1">├── docker-compose.yml</span><br/><span class="koboSpan" id="kobo.136.1">├── kiosk</span><br/><span class="koboSpan" id="kobo.137.1">│   ├── Dockerfile</span><br/><span class="koboSpan" id="kobo.138.1">│   ├── app.py</span><br/><span class="koboSpan" id="kobo.139.1">│   └── requirements.txt</span><br/><span class="koboSpan" id="kobo.140.1">└── recorder</span><br/><span class="koboSpan" id="kobo.141.1">    ├── Dockerfile</span><br/><span class="koboSpan" id="kobo.142.1">    ├── process.py</span><br/><span class="koboSpan" id="kobo.143.1">    └── requirements.txt</span></strong></pre>
<p><span class="koboSpan" id="kobo.144.1">Finally, run </span><kbd><span class="koboSpan" id="kobo.145.1">docker-compose up</span></kbd><span class="koboSpan" id="kobo.146.1"> to check everything is fine. </span><span class="koboSpan" id="kobo.146.2">W</span><span><span class="koboSpan" id="kobo.147.1">e can check every component is linked nicely using </span><kbd><span class="koboSpan" id="kobo.148.1">kiosk</span></kbd><span class="koboSpan" id="kobo.149.1">:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.150.1">$ curl localhost:5000</span></strong><br/><strong><span class="koboSpan" id="kobo.151.1">Gooday!</span></strong><br/><strong><span class="koboSpan" id="kobo.152.1"> Import tickets with "curl -XPOST -F 'value=&lt;int&gt;' /tickets"</span></strong><br/><strong><span class="koboSpan" id="kobo.153.1"> Purchase a ticket with "curl -XPOST /buy</span></strong><br/><strong><span class="koboSpan" id="kobo.154.1"> Get current tickets with "curl -XGET /tickets"</span><br/><span class="koboSpan" id="kobo.155.1">$ curl -XGET localhost:5000/tickets</span><br/><span class="koboSpan" id="kobo.156.1">0</span><br/><span class="koboSpan" id="kobo.157.1">$ curl -XPOST -F 'value=10' localhost:5000/tickets</span><br/><span class="koboSpan" id="kobo.158.1">SUCCESS</span><br/><span class="koboSpan" id="kobo.159.1">$ curl -XGET localhost:5000/tickets</span><br/><span class="koboSpan" id="kobo.160.1">10</span><br/><span class="koboSpan" id="kobo.161.1">$ curl -XPOST localhost:5000/buy</span><br/><span class="koboSpan" id="kobo.162.1">SUCCESS</span><br/><span class="koboSpan" id="kobo.163.1">$ docker exec chapter2_lmysql_1  mysql -u root -pmysqlpass \</span><br/><span class="koboSpan" id="kobo.164.1">              -e "select * from kiosk.sellinglog;"</span><br/><span class="koboSpan" id="kobo.165.1">id  ts</span><br/><span class="koboSpan" id="kobo.166.1">1   1536704902204</span><br/></strong></pre>
<p><span class="koboSpan" id="kobo.167.1">Writing a template for Docker compose is as simple as this. </span><span class="koboSpan" id="kobo.167.2">We're now able to run an application in the stack with ease.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Starting from the very primitive elements of Linux containers and Docker tool stacks, we went through every aspect of containerizing an application, including packing and running a Docker container, writing a </span><kbd><span class="koboSpan" id="kobo.3.1">Dockerfile</span></kbd><span class="koboSpan" id="kobo.4.1"> for code-based immutable deployment, and manipulating multiple containers with Docker compose. </span><span class="koboSpan" id="kobo.4.2">However, the abilities we gained in this chapter only allow us to run and connect containers within the same host, which limits our ability to build larger applications.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In </span><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="koboSpan" id="kobo.6.1">Chapter 3</span></a><span class="koboSpan" id="kobo.7.1">, </span><em><span class="koboSpan" id="kobo.8.1">Getting Started with Kubernetes</span></em><span class="koboSpan" id="kobo.9.1">, we'll meet Kubernetes, unleashing the power of containers beyond the limits of scale.</span></p>


            </article>

            
        </section>
    </body></html>