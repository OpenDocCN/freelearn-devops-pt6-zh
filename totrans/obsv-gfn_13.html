<html><head></head><body>
		<div id="_idContainer182">
			<h1 id="_idParaDest-227" class="chapter-number"><a id="_idTextAnchor239"/>13</h1>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor240"/>Application Performance with Grafana Pyroscope and k6</h1>
			<p>This chapter will explore two tools, <strong class="bold">Pyroscope</strong> and <strong class="bold">k6</strong>. Pyroscope is a <strong class="bold">continuous profiling</strong> tool that allows users to collect very detailed<a id="_idIndexMarker1065"/> information about the usage<a id="_idIndexMarker1066"/> of system resources<a id="_idIndexMarker1067"/> such as CPU and memory. k6 is a <strong class="bold">load testing</strong> tool that can be used to interact<a id="_idIndexMarker1068"/> with an application via endpoints, or via a browser session in a <span class="No-Break">scripted way.</span></p>
			<p>With Pyroscope, we will see how to search data, which will give you a good understanding of how to make use of the data available. We will then show how to add instrumentation to collect this data using both an installed client and by adding a native language SDK to the application code. Finally, we will see how the new version of the Pyroscope architecture leverages Grafana’s knowledge of highly scalable storage platforms, using inexpensive block storage to set Pyroscope on a path toward offering truly continuous profiling for developers. This functionality will allow those of you who need visibility of code execution to improve operational cost or end <span class="No-Break">user performance.</span></p>
			<p>k6 will move a little away from observability into the very closely related field of load or performance testing. We will discuss the general principles of load testing and look at the different categories of load tests that you may need. Then, you will be introduced to the scripting language used by k6 to easily write tests<a id="_idIndexMarker1069"/> that validate the application is performing as expected. We will see how k6 uses <strong class="bold">virtual users</strong> (<strong class="bold">VUs</strong>) to scale tests and create a significant load on an application, so you can use it to prove your applications are running as expected. Finally, we’ll see how k6 can be installed, and how it is versatile enough to even run as part of a CI pipeline, ensuring your applications are continuously <span class="No-Break">load tested.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Using Pyroscope for <span class="No-Break">continuous profiling</span></li>
				<li>Using k6 for <span class="No-Break">load testing</span></li>
			</ul>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor241"/>Using Pyroscope for continuous profiling</h1>
			<p>First, let’s address the question of what <strong class="bold">continuous profiling</strong> is. As we outlined at the start of this book, a system is observable <a id="_idIndexMarker1070"/>when the internal state of the system can be inferred<a id="_idIndexMarker1071"/> from its external outputs. We have seen three types<a id="_idIndexMarker1072"/> of output telemetry: logs, metrics, and traces. Profiling data is another form of telemetry. Profiling data is very low-level data that relates to a workload’s use of resources, such as the use of CPU or memory. As profiling tools analyze very low-level system data, they capture information such as the running time or the number of objects in memory of a specific application function. This is very powerful for domain experts to inspect how an application behaves, and this power can lead to significant performance and cost improvements. Profiling has been around for a long time, as anyone who has produced a stack trace will know. Pyroscope offers the ability to capture this profiling data continuously, with a default interval of 15 seconds. The ability to collect this telemetry continuously over the lifetime of an application can give insight into how an application runs over time, which can link the inner workings of the code base to specific user actions seen in logs, metrics, <span class="No-Break">and traces.</span></p>
			<p>In this section, we will briefly introduce Pyroscope. You will be shown how to search the data collected by Pyroscope. We will talk about configuring the client to collect profiles, and we will look at the architecture of the <span class="No-Break">Pyroscope server.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor242"/>A brief overview of Pyroscope</h2>
			<p>Pyroscope, also known as Grafana<a id="_idIndexMarker1073"/> Cloud Profiles, was founded in 2020 and acquired<a id="_idIndexMarker1074"/> by Grafana Labs<a id="_idIndexMarker1075"/> in 2023. The Pyroscope team joined the team from a Grafana Labs experimental product called Phlare, and the product is now a standard offering from Grafana Cloud. Some of the key features<a id="_idIndexMarker1076"/> of Pyroscope are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Great horizontal scalability using the same architecture as Loki, Mimir, <span class="No-Break">and Tempo</span></li>
				<li>Cheap storage for <span class="No-Break">profile data</span></li>
				<li>Can store data locally or using <span class="No-Break">Grafana Cloud</span></li>
				<li>High frequency of sampling, which produces very <span class="No-Break">granular data</span></li>
			</ul>
			<p>Now, let’s explore how we can examine the data collected <span class="No-Break">by Pyroscope.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor243"/>Searching Pyroscope data</h2>
			<p>Profile telemetry<a id="_idIndexMarker1077"/> can be viewed using the <strong class="bold">Explore</strong> view in the Grafana UI by selecting a Pyroscope source. While the view is similar to Loki, Mimir, and Tempo, the query language is limited by the nature of the telemetry type; effectively, only selection functionality is available to select a signal from an application or group of applications by tag. This is the view you will see to select data from a <span class="No-Break">Pyroscope source:</span></p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B18277_13_1.jpg" alt="Figure 13.1 – Pyroscope query pane"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Pyroscope query pane</p>
			<p>The first view to look at is the <strong class="bold">Top Table</strong> view, as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>. For those of you who know the Linux <strong class="source-inline">top</strong> command, this view will be familiar. The view lists every function and the amount of time that has been spent on the function. The <strong class="bold">Self</strong> column shows the time spent on that function. The <strong class="bold">Total</strong> column shows the total time each function takes to run. This allows users to see functions that have a long running time. Long runtimes could indicate an inefficient function, but it could also indicate a function that is central to the application. Domain expertise is needed to understand where improvements could be made. This screenshot shows the <strong class="bold">Top </strong><span class="No-Break"><strong class="bold">Table</strong></span><span class="No-Break"> view:</span></p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B18277_13_2.jpg" alt="Figure 13.2 – Pyroscope Top Table view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Pyroscope Top Table view</p>
			<p>The second view is the <strong class="bold">Flame Graph</strong> view. This chart <a id="_idIndexMarker1078"/>is specifically designed to visualize profile data. <strong class="bold">Flame graphs</strong> were invented to be able to visualize stack trace output<a id="_idIndexMarker1079"/> from applications to make debugging easier. Before we look at the view in Pyroscope, let’s take a look at a sample application <span class="No-Break">stack trace:</span></p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B18277_13_3.jpg" alt="Figure 13.3 – Example application stack trace"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Example application stack trace</p>
			<p>We can see there is a <strong class="source-inline">main()</strong> function, which is started<a id="_idIndexMarker1080"/> when the application is run. This function calls the child functions, <strong class="source-inline">foo()</strong> and <strong class="source-inline">bar()</strong>, in order, and <strong class="source-inline">bar()</strong> also calls the <strong class="source-inline">baz()</strong> and <strong class="source-inline">qux()</strong> functions. A flame graph captures the hierarchical nature of these stack calls by grouping child functions under their parent. This allows us to see how deep the call stack is by looking at the <em class="italic">y</em> axis. The total population of functions is shown in the <em class="italic">x</em> axis; importantly, this does not represent the time but rather each function that was seen on the call stack during the sampling period. The visualization of duration is shown in a flame graph by the width of the box for each function, which shows the total time spent on a function during the sampling period. Let’s have a look at how this looks <span class="No-Break">in practice:</span></p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B18277_13_4.jpg" alt="Figure 13.4 – Example flame graph from the stack trace"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Example flame graph from the stack trace</p>
			<p>In this example flame graph, we can see <a id="_idIndexMarker1081"/>that the <strong class="source-inline">baz()</strong> function takes up a significant portion of the operating time. In some applications, this may be completely expected behavior; in other applications, this may indicate a function that needs to <span class="No-Break">be optimized.</span></p>
			<p>Very few applications are as simple as this example. Let’s look at a real flame graph from the OpenTelemetry <span class="No-Break">Demo application:</span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B18277_13_5.jpg" alt="Figure 13.5 – A real flame graph"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – A real flame graph</p>
			<p>We’ve seen how continuous profiling<a id="_idIndexMarker1082"/> tools such as Pyroscope can be valuable in creating efficient code and debugging issues. Let’s now look at how to collect <span class="No-Break">profile data.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor244"/>Continuous profiling client configuration</h2>
			<p>There are currently three separate<a id="_idIndexMarker1083"/> ways to collect data for Pyroscope, although we expect this to evolve as Pyroscope is quite a new piece of technology. We would recommend the Grafana Labs blog for those of you who want to keep up to date with the latest developments from this exciting technology (https://grafana.com/blog/). Let’s explore how to set up <span class="No-Break">each one:</span></p>
			<ul>
				<li><strong class="bold">Extended Berkeley Packet Filter (eBPF) client</strong>: The first way to collect profile data for Pyroscope<a id="_idIndexMarker1084"/> is to make use of a Linux kernel-level tool called eBPF. This tool allows the profiling client to view the trace information for all applications running on the server or node. The eBPF client combines this data with metadata on the data source (for example, a Kubernetes Pod or namespace) and then sends this profile information to a Pyroscope backend. The following diagram shows a simplified view of how eBPF stores data for the Pyroscope client <span class="No-Break">to collect:</span></li>
			</ul>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B18277_13_6.jpg" alt="Figure 13.6 – eBPF client process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – eBPF client process</p>
			<p class="list-inset">With eBPF, the kernel collects profile data, as well as several other types of data, and stores it in eBPF maps. Pyroscope links into the eBPF maps, packages the data, and then sends<a id="_idIndexMarker1085"/> it for storage in the <span class="No-Break">configured</span><span class="No-Break"><a id="_idIndexMarker1086"/></span><span class="No-Break"> backend.</span></p>
			<ul>
				<li><strong class="bold">Native language instrumentation</strong>: The second way to collect profile data is to use a language-specific Pyroscope<a id="_idIndexMarker1087"/> SDK to add instrumentation to your application. SDKs are currently provided for Go, Java, .NET, Python, Ruby, Rust, and Node.js. Apart from the Go SDK, all these libraries only support a <em class="italic">push</em> mode of operation. Go supports both a <em class="italic">push</em> and a <em class="italic">pull</em> mode of operation; the pull mode allows the Grafana agent to collect profile data from a scraping endpoint published by the application. In push mode, it is currently necessary to add the Pyroscope server address, basic authenticated username, and password at the application level, although as this tool matures, we’re sure this will become<a id="_idIndexMarker1088"/> easier to manage in an <span class="No-Break">operational environment.</span></li>
				<li><strong class="bold">Instrumenting Lambda functions</strong>: Pyroscope also provides tooling for AWS Lambda functions. This consists<a id="_idIndexMarker1089"/> of a Lambda extension that is loaded as a layer when the function is triggered. This allows the profiling tooling to collect the required profile telemetry asynchronously without impacting<a id="_idIndexMarker1090"/> the operation of your Lambda function. Like the native language instrumentation, environment variables must be provided with the remote address for the Pyroscope backend and the relevant <span class="No-Break">authentication tokens.</span><p class="list-inset">For teams running serverless functions, this adds the capability to look inside the Lambda function black box and allows teams to answer questions such as, <em class="italic">Why is my Lambda costing so much?</em>, <em class="italic">Why do I have such high latency?</em>, and <em class="italic">Why is my function failing </em><span class="No-Break"><em class="italic">so often?</em></span></p></li>
			</ul>
			<p>There are benefits and drawbacks to the eBPF client, the SDK, and the Lambda approaches: their usage is dependent<a id="_idIndexMarker1091"/> on the use case. Here are<a id="_idIndexMarker1092"/> some benefits and drawbacks for <span class="No-Break">each method:</span></p>
			<table id="table001-10" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Instrumentation method</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Benefits</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Drawbacks</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">eBPF</span></p>
						</td>
						<td class="No-Table-Style">
							<p>System-wide whole system profiles are easy <span class="No-Break">to collect.</span></p>
							<p>Infrastructure metadata is easy to add (for example, Kubernetes Pod <span class="No-Break">or namespace).</span></p>
							<p>Easy to manage a multi-language or <span class="No-Break">large system.</span></p>
							<p>Can combine with native <span class="No-Break">language instrumentation.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Linux <span class="No-Break">kernel constraints.</span></p>
							<p>Limited ability to tag <span class="No-Break">user-level code.</span></p>
							<p>Some profile types are not performant to collect (for example, <span class="No-Break">memory use).</span></p>
							<p>More complex for local <span class="No-Break">development environments.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Native language</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Flexible tagging <span class="No-Break">of code.</span></p>
							<p>Detailed profiling of specific parts <span class="No-Break">of code.</span></p>
							<p>Ability to profile other types of data (for example, <span class="No-Break">memory use).</span></p>
							<p>Simple to use in local <span class="No-Break">development environments.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Managing a multi-language or large system <span class="No-Break">is difficult.</span></p>
							<p>Difficult to auto-tag infrastructure metadata (for example, Kubernetes Pod <span class="No-Break">or namespace).</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Lambda functions</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Allows for collection of trace data from <span class="No-Break">serverless functions.</span></p>
							<p>Links with the native language support to instrument <span class="No-Break">the function.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Currently only available for <span class="No-Break">AWS Lambda.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.1 – Advantages and drawbacks of Pyroscope instrumentation methods</p>
			<p>We’ve looked at the different ways to set up applications and clients to collect profile data. Now, let’s consider the storage and search architecture <span class="No-Break">of Pyroscope.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor245"/>Understanding the Pyroscope architecture</h2>
			<p>Pyroscope 1.0 has introduced<a id="_idIndexMarker1093"/> a major change to the architecture of Pyroscope. This leverages the Grafana knowledge of Cortex architectures to make the architecture horizontally scalable. This is a breaking change from previous versions so we will only be considering the architecture from this <span class="No-Break">change onward.</span></p>
			<p>Similar to Loki, Mimir, and Tempo, Pyroscope uses low-cost, highly available block storage such as Amazon S3, Google Cloud Storage, or Microsoft Azure Storage to provide massive scalability. Here’s a diagram<a id="_idIndexMarker1094"/> of the <span class="No-Break">Pyroscope architecture:</span></p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B18277_13_7.jpg" alt="Figure 13.7 – Pyroscope architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Pyroscope architecture</p>
			<p>When data is written, it is sent to the <strong class="bold">Ingester</strong>, which persists the data to <strong class="bold">Object Storage</strong>. On the <strong class="bold">Reads</strong> side, queries are split and sharded to instances of the <strong class="bold">Querier</strong>, which grabs the necessary data from the <strong class="bold">Ingester</strong> and/or the <span class="No-Break">long-term storage.</span></p>
			<p>There are several alternatives to Pyroscope on the market that may be of interest to you. The open source tools include OpenTelemetry eBPF, Parca, and profefe, and several observability vendors<a id="_idIndexMarker1095"/> include similar profiling tools. These tools can be found at <a href="https://github.com/open-telemetry/opentelemetry-ebpf">https://github.com/open-telemetry/opentelemetry-ebpf</a>, <a href="https://www.parca.dev/">https://www.parca.dev/</a>, and https://github.com/profefe/profefe. We’ve now seen how Pyroscope functions. Another tool that is helpful for developers and testers<a id="_idIndexMarker1096"/> is k6 load testing. Let’s take a look at <span class="No-Break">this next.</span></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor246"/>Using k6 for load testing</h1>
			<p>Load testing is the practice of applying <a id="_idIndexMarker1097"/>a known, artificial load to an application to see how<a id="_idIndexMarker1098"/> it behaves. The term is often used interchangeably with performance testing, and we will follow the k6 documentation in using <em class="italic">average load</em> to differentiate a specific type <span class="No-Break">of test.</span></p>
			<p>Several different types of load tests can be applied; they differ on two axes – the load throughput and the duration. They may also differ in the content of the tests that are performed. Some common types of tests are shown in the <span class="No-Break">following table:</span></p>
			<table id="table002-6" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Test</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Runtime </strong><span class="No-Break"><strong class="bold">and volume</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Smoke tests</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are designed to validate that the system works. They can also be known as sanity or confidence tests. They are called smoke tests after testing a device by powering it on and checking <span class="No-Break">for smoke.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are designed to quickly say that things look as expected or that something <span class="No-Break">is wrong</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These should run quickly, in minutes <span class="No-Break">not hours.</span></p>
							<p>They should be <span class="No-Break">low volume.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Average </strong><span class="No-Break"><strong class="bold">load tests</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>These tests show how the system is used in <span class="No-Break">most conditions.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are designed to simulate the most frequent level of load on <span class="No-Break">the system.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These should run relatively quickly, but slower than <span class="No-Break">smoke tests.</span></p>
							<p>They should simulate average volumes <span class="No-Break">of traffic.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Stress tests</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>These tests stress the system with higher-than-average <span class="No-Break">peak traffic.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are designed to simulate what would happen if peak traffic were experienced for an <span class="No-Break">extended duration.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These should run in less than <span class="No-Break">a day.</span></p>
							<p>They should simulate high volumes <span class="No-Break">of traffic.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Spike tests</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>These tests should show how the system behaves with a sudden, short, massive increase in traffic, as might be seen during a <strong class="bold">denial of service</strong> (<span class="No-Break"><strong class="bold">DoS</strong></span><span class="No-Break">) attack.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are designed to test how the system would handle a sudden overwhelming spike in traffic, such as a <span class="No-Break">DoS attack.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These should <span class="No-Break">run quickly.</span></p>
							<p>They should simulate unrealistic amounts <span class="No-Break">of traffic.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Breakpoint tests</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>These tests gradually increase traffic until the system <span class="No-Break">breaks down.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are designed to understand when the system will fail with <span class="No-Break">added load.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These can run for <span class="No-Break">extended periods.</span></p>
							<p>They should simulate steadily increasing rates <span class="No-Break">of traffic.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Soak tests</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>These tests assess the performance of the system over extended periods. They are like an average load test over a significantly <span class="No-Break">longer period.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are designed to demonstrate how the system will function during real operations for extended periods. They are good for identifying issues such as <span class="No-Break">memory leaks.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These will run over extended periods such as <span class="No-Break">48 hours.</span></p>
							<p>They should simulate average volumes <span class="No-Break">of traffic.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.2 – Types of load tests</p>
			<p>The following graph<a id="_idIndexMarker1099"/> shows the different tests<a id="_idIndexMarker1100"/> <span class="No-Break">for reference:</span></p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B18277_13_8.jpg" alt="Figure 13.8 – Visual representation of the different load test types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Visual representation of the different load test types</p>
			<p>In the preceding figure, we can<a id="_idIndexMarker1101"/> see the different types of tests graphed by the test throughput <a id="_idIndexMarker1102"/>and the test duration. Try correlating what you can see in the graph with what you’ve just learned about these tests in <span class="No-Break"><em class="italic">Table 13.2</em></span><span class="No-Break">.</span></p>
			<p>You can see that load testing and observability are very closely linked. The data collected from a live system will show what average and unrealistic loads look like. The data injected by a smoke test can show a system is working as expected, for example, after a new version is deployed. The data collected from the load testing environment can give critical insights into the operation of the system <span class="No-Break">under load.</span></p>
			<p>It is good practice to separate the observability data collected from load testing from other data. Due to the nature of the tests that are being tried, very large volumes of data can be generated, which can be a very costly thing to collect. One huge advantage of open source systems such as Grafana is the ability to run the data storage system as part of the load testing environment while using the same visualization as <span class="No-Break">in production.</span></p>
			<p>There are several load testing tools<a id="_idIndexMarker1103"/> on the market, both open source and commercial. The open source offerings<a id="_idIndexMarker1104"/> include JMeter, k6, Gatling, Locust, Artillery, Tsung, Vegeta, Hey, and Siege. As this book focuses on Grafana tools, we will only discuss k6 here. Let’s have a look at some of the features <span class="No-Break">of k6.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor247"/>A brief overview of k6</h2>
			<p>k6 is the load testing tool developed<a id="_idIndexMarker1105"/> by Grafana Labs after they acquired LoadImpact. k6 offers several <span class="No-Break">key features:</span></p>
			<ul>
				<li>A <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) that allows tests to be run, paused, resumed, <span class="No-Break">or </span><span class="No-Break"><a id="_idIndexMarker1106"/></span><span class="No-Break">scaled.</span></li>
				<li>The ability to start tests locally, from a Kubernetes cluster, or in the cloud with the CLI. k6 supports distributed running via a <span class="No-Break">Kubernetes operator.</span></li>
				<li>Scripting support <span class="No-Break">using JavaScript.</span></li>
				<li>The ability to load additional modules into scripts, although this does not include support for <span class="No-Break">Node.js modules.</span></li>
				<li>A browser module that adds browser-level APIs for full <span class="No-Break">frontend testing.</span></li>
				<li>Support for goal-oriented load testing using checks <span class="No-Break">and thresholds.</span></li>
				<li>Great supporting tools, such as <span class="No-Break">the following:</span><ul><li><span class="No-Break">Reference projects</span></li><li>Tools to convert scripts from other tools <span class="No-Break">to k6</span></li><li>Tools to convert k6 output to other <span class="No-Break">common formats</span></li><li>A GUI for <span class="No-Break">test building</span></li></ul></li>
			</ul>
			<p>Let’s now look at the process of writing a <span class="No-Break">simple test.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As k6 requires a test file to run, we have included the installation and usage instructions after these instructions on writing <span class="No-Break">a test.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor248"/>Writing a test using checks</h2>
			<p>Tests are written in k6 using<a id="_idIndexMarker1107"/> JavaScript. A very simple test to submit a <strong class="source-inline">GET</strong> request to the <strong class="source-inline">acme</strong> website <a id="_idIndexMarker1108"/>would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
import http from 'k6/http';
export default function () {
  http.get('http://www.acme.com');
}</pre>			<p>This script would just submit a request to the web page, but it would not validate that the request was successful. The <strong class="source-inline">check</strong> functionality would be used to confirm that this is the case, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
import { check } from 'k6';
import http from 'k6/http';
export default function () {
  const res = http.get('http://www.acme.com');
  check(res, {
    'is status 200': (r) =&gt; r.status === 200,
  },
  { company: 'Acme' }
  );
}</pre>			<p>The <strong class="source-inline">check()</strong> function takes a value, an object containing the checks that will be run against the value, and an object containing any tags. If all the checks pass, then the function returns <strong class="source-inline">true</strong>; otherwise, it will return <strong class="source-inline">false</strong>. The <strong class="source-inline">check</strong> functionality makes it very simple to check for simple<a id="_idIndexMarker1109"/> conditions in a script. It is common to want to check that an endpoint is meeting<a id="_idIndexMarker1110"/> specific expectations, and k6 offers thresholds for <span class="No-Break">this goal.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor249"/>Writing a test using thresholds</h2>
			<p>Thresholds are checked<a id="_idIndexMarker1111"/> against all requests made in the <a id="_idIndexMarker1112"/>script, and it is good practice to use the <strong class="bold">service-level objectives</strong> (<strong class="bold">SLOs</strong>) set by the team as a starting point<a id="_idIndexMarker1113"/> for testing. Here is an example of a <span class="No-Break">threshold test:</span></p>
			<pre class="source-code">
import http from 'k6/http';
export const options = {
  thresholds: {
    http_req_failed: ['rate&lt;0.01'], // http errors should be less than 1%
    http_req_duration: ['p(95)&lt;200'], // 95% of requests should be below 200ms
  },
};
export default function () {
  http.get('http://www.acme.com');
}</pre>			<p>This test would make a call to the <strong class="source-inline">acme</strong> website and check that the built-in <strong class="source-inline">http_req_failed</strong> and <strong class="source-inline">http_req_duration</strong> HTTP metrics meet the threshold expression specified. These metrics are collected from all the requests made in the script; in this case, there<a id="_idIndexMarker1114"/> is only a single<a id="_idIndexMarker1115"/> request made. If needed, it is possible to use <strong class="bold">groups</strong> and <strong class="bold">tags</strong> to evaluate HTTP <span class="No-Break">requests independently.</span></p>
			<p>Now that we know how<a id="_idIndexMarker1116"/> to write basic<a id="_idIndexMarker1117"/> scripted tests, let’s look at how we can use <strong class="source-inline">options</strong> <span class="No-Break">to scale.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor250"/>Adding scenarios to a test to run at scale</h2>
			<p>In the previous section, we mentioned<a id="_idIndexMarker1118"/> that the test would only make a single HTTP<a id="_idIndexMarker1119"/> request. By using <strong class="source-inline">options</strong>, it is easy to manage the behavior of the default function in complex ways. Let’s consider a simple example in which we create 100 VUs, and each VU will execute the default function repeatedly for <span class="No-Break">30 minutes:</span></p>
			<pre class="source-code">
import http from 'k6/http';
export const options = {
  vus: 100,
  duration: '30m'
};
export default function () {
  http.get('http://www.acme.com');
}</pre>			<p>You might notice that we are using the same <strong class="source-inline">options</strong> constant as we used when we created the test thresholds in the previous section. The <strong class="source-inline">options</strong> configuration option offers a lot of flexibility for defining the behavior of a test. It is a common requirement to share data with each of the VUs that will run the tests. Let’s have a look at how the test life cycle can manage <span class="No-Break">these requirements.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor251"/>Test life cycle</h2>
			<p>There are four stages<a id="_idIndexMarker1120"/> to the k6 test life cycle. These stages are explicitly set in the ordering of a <span class="No-Break">test file:</span></p>
			<ol>
				<li><strong class="bold">Initialization code</strong>: This is any code that appears at the top of the test script, before the setup code. It is run once per VU and is used to load files, import modules, configure the options used in the test, and for <span class="No-Break">similar operations.</span></li>
				<li><strong class="bold">Setup code</strong>: The code runs once and is used to set up data that is shared by all the VUs that are running the tests. This code uses the <span class="No-Break">following syntax:</span><p class="list-inset"><strong class="source-inline">export function setup() { }</strong></p></li>
				<li><strong class="bold">VU code</strong>: The code is run as many times as needed on each VU and is used to define the functions that will be run during a test. This code uses the <span class="No-Break">following syntax:</span><p class="list-inset"><strong class="source-inline">export default function (data) { }</strong></p></li>
				<li><strong class="bold">Teardown code</strong>: The code is run once, but it will not run if the setup ends abnormally. It is used to process results and stop the test environments. This code uses the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker1121"/></span><span class="No-Break">syntax:</span><p class="list-inset"><strong class="source-inline">export function teardown (data) { }</strong></p></li>
			</ol>
			<p>Now that we have a good understanding of using k6 to run tests, we need to consider the different ways we can install and <span class="No-Break">run k6.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor252"/>Installing and running k6</h2>
			<p>k6 is available in several<a id="_idIndexMarker1122"/> <span class="No-Break">package formats:</span></p>
			<ul>
				<li>Linux (<strong class="source-inline">.rpm</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">.deb</strong></span><span class="No-Break">)</span></li>
				<li><span class="No-Break">macOS</span></li>
				<li><span class="No-Break">Windows</span></li>
				<li><span class="No-Break">Containerized image</span></li>
				<li>Standalone binary for <span class="No-Break">all platforms</span></li>
			</ul>
			<p>Installation is very simple<a id="_idIndexMarker1123"/> on all platforms, and full instructions<a id="_idIndexMarker1124"/> can be found on the k6 website <span class="No-Break">at </span><a href="https://k6.io/docs/get-started/installation/"><span class="No-Break">https://k6.io/docs/get-started/installation/</span></a><span class="No-Break">.</span></p>
			<p>Running k6 is also very easy as all processes<a id="_idIndexMarker1125"/> are triggered from the CLI. This is very well documented via the <strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">help</strong></span><span class="No-Break"> flag:</span></p>
			<pre class="source-code">
$ k6 --help
          /\      |‾‾| /‾‾/   /‾‾/
     /\  /  \     |  |/  /   /  /
    /  \/    \    |     (   /   ‾‾\
   /          \   |  |\  \ |  (‾)  |
  / __________ \  |__| \__\ \_____/ .io
Usage:
  k6 [command]
Available Commands:
  archive     Create an archive
  cloud       Run a test on the cloud
  completion  Generate the autocompletion script for the specified shell
  help        Help about any command
  inspect     Inspect a script or archive
  login       Authenticate with a service
  pause       Pause a running test
  resume      Resume a paused test
  run         Start a test
  scale       Scale a running test
  stats       Show test metrics
  status      Show test status
  version     Show application version</pre>			<p>The <strong class="source-inline">k6 run</strong> and <strong class="source-inline">k6 cloud</strong> operations are used to run<a id="_idIndexMarker1126"/> tests locally or via the k6 cloud, respectively. Here are some example commands using a test file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">test.js</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Run a single <span class="No-Break">VU once:</span><p class="list-inset"><strong class="source-inline">k6 </strong><span class="No-Break"><strong class="source-inline">run test.js</strong></span></p></li>
				<li>Run 10 VUs with 20 iterations of the test being run across <span class="No-Break">these VUs:</span><p class="list-inset"><strong class="source-inline">k6 run -u 10 -i </strong><span class="No-Break"><strong class="source-inline">20 test.js</strong></span></p></li>
				<li>Ramp VUs from <strong class="source-inline">0</strong> to <strong class="source-inline">50</strong> over 20 secs, maintain the <strong class="source-inline">50</strong> VU count for 60 secs, then ramp down to <strong class="source-inline">0</strong> over <span class="No-Break">10 secs:</span><p class="list-inset"><strong class="source-inline">k6 run -u 0 -s 20s:50 -s 60s:50 -s </strong><span class="No-Break"><strong class="source-inline">10s:0 test.js</strong></span></p></li>
			</ul>
			<p>These commands could all have <strong class="source-inline">k6 run</strong> replaced with <strong class="source-inline">k6 cloud</strong> to use a k6 cloud runner instead of running the tests from the <span class="No-Break">local machine.</span></p>
			<p>Now that we’ve seen how to use k6 to perform load testing, let’s <span class="No-Break">wrap up.</span></p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor253"/>Summary</h1>
			<p>In this chapter, we have explored two of the tools that Grafana offers as part of its observability platform: Pyroscope and k6. We learned how to search the profile data collected by Pyroscope and how to configure the client to collect that profile data. We also learned how to instrument applications, both using a native language SDK and using Lambda layers for serverless applications. Finally, we explored the new Pyroscope architecture and saw how it is very similar to Loki, Mimir, and Tempo. This new scalability should give Pyroscope the space to grow into a vital fourth telemetry type, making systems <span class="No-Break">more observable.</span></p>
			<p>With k6, we learned about various types of load or performance tests. We saw how we can easily write tests using the JavaScript language, using checks and thresholds to articulate vital measures for an application. We saw how to use <strong class="source-inline">options</strong> to manage how k6 runs its tests, and how to add the correct data and functions to our scripts to best make use of the test life cycle. Finally, we saw the process for installing and running k6, and how the simple operation even allows us to run the tool as part of a CI/CD pipeline to continuously load test applications to validate that their performance is <span class="No-Break">meeting SLOs.</span></p>
			<p>In the next chapter, we will bring together all of the tools, APIs, and knowledge to understand how to best support DevOps principles <span class="No-Break">using Grafana.</span></p>
		</div>
	</body></html>