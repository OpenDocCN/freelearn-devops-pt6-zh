<html><head></head><body>
		<div id="_idContainer135">
			<h1 id="_idParaDest-226" class="chapter-number"><a id="_idTextAnchor227"/>12</h1>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor228"/>Communicating with Edge Devices across Long Distances Using LoRa</h1>
			<p><strong class="bold">Long Range</strong> (<strong class="bold">LoRa</strong>) is a <a id="_idIndexMarker837"/>wireless protocol that you can use to receive and send data over long distances using low-powered devices. You can use these edge devices with solar panels or other sources of energy. Sometimes, your edge devices use batteries and are not connected to a common power source like we often find in our houses. When you are crafting edge systems, you could use edge devices using sensors that you have to configure. You could use prototype hardware platforms such as Arduino or devices such as ESP32 microcontrollers or a Raspberry Pi. These devices support LoRa modules to bring communication capabilities to your device, which is crucial for sending and receiving data from devices. In this chapter, we are going to explore how to take advantage of the LoRa wireless protocol to send or receive data from long distances. We will continue expanding the options for monitoring edge devices as in the previous chapter but now using the LoRa wireless protocol.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>LoRa wireless protocol and edge computing</li>
				<li>Deploying MySQL to store sensor data</li>
				<li>Deploying a service to store sensor data in a MySQL database</li>
				<li>Programming the ESP32 microcontroller to send sensor data</li>
				<li>Programming the ESP32 microcontroller to receive sensor data</li>
				<li>Visualizing data from ESP32 microcontrollers using MySQL and Grafana</li>
			</ul>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor229"/>Technical requirements</h1>
			<p>To deploy our databases in this chapter, you will need the following:</p>
			<ul>
				<li>A single or multi-node K3s cluster that can use ARM devices with MetalLB and Longhorn storage installed. This example will be tested using a Raspberry Pi 4B with 4 GB of RAM and using Ubuntu 20.04 or later for ARM 64-bit.</li>
				<li>A Kubernetes cluster hosted in your public cloud provider (AWS, Azure, GCP) or your private cloud.</li>
				<li>2 ESP32 microcontrollers with the LoRa module installed. We are using the Heltec ESP32 + Lora v2 model; one to send and the other to receive data.</li>
				<li>Arduino IDE installed on your Mac. You can use Windows since it’s pretty similar to configure, and it is also more stable when working with hardware.</li>
				<li>A USB 2.0 A-Male to Micro B cable for programming your ESP32 devices.</li>
				<li>A Keyes DHT11 sensor or similar connected to your edge device to read temperature and humidity.</li>
				<li><strong class="source-inline">kubectl</strong> configured to be used in your local machine for your Kubernetes cloud cluster or your K3s cluster to avoid using the <strong class="source-inline">--kubeconfig</strong> parameter.</li>
				<li>Clone the GitHub repository at <a href="https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch12">https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch12</a> if you want to run the YAML configurations using <strong class="source-inline">kubectl apply</strong> instead of copying the code from this book. Take a look at the <strong class="source-inline">code</strong> directory for Arduino source codes for Heltec devices and the <strong class="source-inline">yaml</strong> directory for YAML configurations. These are located inside the <strong class="source-inline">ch12</strong> directory.</li>
			</ul>
			<p>Now, let’s understand how our scenario of using LoRa devices, Prometheus, and Grafana is going to work.</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor230"/>LoRa wireless protocol and edge computing</h1>
			<p>LoRa refers <a id="_idIndexMarker838"/>to a radio modulation technique for long distances, and together with LoRaWAN, it defines a network protocol that can be used to interconnect devices. LoRaWAN is <a id="_idIndexMarker839"/>also a network architecture that uses a start-of-start topology in which the gateway relays messages between edge devices. LoRa uses three popular frequencies: <strong class="source-inline">433</strong>, <strong class="source-inline">868</strong>, and <strong class="source-inline">915</strong>. <strong class="source-inline">433</strong> is sometimes used outdoors. <strong class="source-inline">868</strong> is used in Europe and <strong class="source-inline">915</strong> is used in America. LoRaWAN has gateway devices <a id="_idIndexMarker840"/>that can connect LoRa networks to the internet. LoRa is designed for low power, which is why LoRa is used for applications in IoT to interconnect devices across long distances. </p>
			<p>As we know, the <a id="_idIndexMarker841"/>goal of edge computing is to process data near the source. Therefore, LoRa allows us to implement edge computing and interconnect devices for long distances without using a lot of energy. Some use cases include agriculture, buildings, supply chain, logistics, geo localization applications, and more. Some common devices that support LoRa are Heltec ESP32 devices, which are designed for low power consumption. We are going to focus on configuring a Heltec ESP32 device with LoRa support in this chapter.</p>
			<p>To start our use case implementation of using LoRa on the tiny edge to interact with a far edge Kubernetes cluster, let’s explore the following diagram:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B16945_12_01.jpg" alt="Figure 12.1 – Monitoring with ESP32 devices and LoRaWAN&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Monitoring with ESP32 devices and LoRaWAN</p>
			<p>This diagram is divided into different layers. You can see how the data flows between the far edge, where LoRa communication is implemented, to the cloud layer. But first, let’s describe the different components of this use case that we want to implement:</p>
			<ul>
				<li><strong class="bold">Tiny edge</strong>: In this layer, we are going to find the Heltec ESP32 devices, which you can <a id="_idIndexMarker842"/>classify as devices that send or receive data. This device sends data, reads data from the DHT11 sensor, and sends the information in JSON format using the LoRa protocol. The other devices read the information, send it across LoRa, and send it to the cluster on the far edge using a post request in a LAN. You can add as many devices to send data as you want.</li>
				<li><strong class="bold">Far edge</strong>: Here, you <a id="_idIndexMarker843"/>can find a single or multi-node K3s cluster using ARM devices. This cluster provides the metrics service, which receives data in JSON format from the tiny edge. Once the data is received, the metrics service writes this data to the cloud layer in the MySQL deployment inside a Kubernetes cluster provisioned in the cloud provider. This could be Amazon, GCP, Azure, and so on.</li>
				<li><strong class="bold">Near edge</strong>: This <a id="_idIndexMarker844"/>layer contains the local router that connects the local network to the internet. Keep in mind that the cluster in the far edge works as a gateway to send data from the LoRa network to the internet.</li>
				<li><strong class="bold">Cloud layer</strong>: Here, you <a id="_idIndexMarker845"/>can find the Kubernetes cluster, which contains MySQL and Grafana. MySQL stores data coming from your local sensors, while Grafana uses MySQL to create dashboards using your sensor data.</li>
			</ul>
			<p>In summary, all your sensor data is coming from ESP32 devices, some equipped with sensors. These devices send and receive data using the LoRa protocol. When a receiver device receives information, it’s transformed into JSON format and then sent to a Kubernetes service located on the far edge. After this service receives this information, it’s forwarded to the cloud layer and stored in a MySQL database. MySQL is used by Grafana to show sensor data collected at the edge in real time. Now, let’s deploy our MySQL databases to store data.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor231"/>Deploying MySQL to store sensor data</h1>
			<p>Before you can store data from your devices using LoRa, you must deploy your database. For this, we are going to use MySQL. MySQL is a pretty popular database that you can <a id="_idIndexMarker846"/>use to store data from your sensor. The <a id="_idIndexMarker847"/>main advantage of using MySQL is that it is well documented, and you can find a lot of examples on the internet. For our deployment, we are going to use a <strong class="source-inline">PersistentVolumeClaim</strong> and the <strong class="source-inline">mysql:8.0.28-oracle</strong> image. Even if you decide to deploy your MySQL over the cloud or locally at the edge, you must use a <strong class="source-inline">LoadBalancer</strong> service so that you have an endpoint for the service that is going to store all sensor data. Our MySQL database will be deployed in the default namespace to simplify the implementation. To deploy our MySQL database, follow these steps:</p>
			<ol>
				<li>Create a <strong class="source-inline">PersistentVolumeClaim</strong> with 5 GB of storage:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: PersistentVolumeClaim</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: db-pv-claim</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  accessModes:</strong></p><p class="source-code"><strong class="bold">    - ReadWriteOnce</strong></p><p class="source-code"><strong class="bold">  resources:</strong></p><p class="source-code"><strong class="bold">    requests:</strong></p><p class="source-code"><strong class="bold">      storage: 5Gi</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Don’t forget to use ConfigMaps and Secrets for a more secure and advanced configuration. You can explore <a href="B16945_10_Final_PG.xhtml#_idTextAnchor198"><em class="italic">Chapter 10</em></a>, <em class="italic">SQL and NoSQL Databases at the Edge</em>, for more details.</p>
			<ol>
				<li value="2">Now, let’s <a id="_idIndexMarker848"/>deploy our MySQL database. Our <a id="_idIndexMarker849"/>deployment is going to use the previous <strong class="source-inline">PersistentVolumeClaim</strong>, called <strong class="source-inline">db-pv-claim</strong>, for this run:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: mysql</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      app: mysql</strong></p><p class="source-code"><strong class="bold">  strategy:</strong></p><p class="source-code"><strong class="bold">    type: Recreate</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata:</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        app: mysql</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - image: mysql:8.0.28-oracle</strong></p><p class="source-code"><strong class="bold">        name: mysql</strong></p><p class="source-code"><strong class="bold">        env:</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_DATABASE</strong></p><p class="source-code"><strong class="bold">          value: sensor_data</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_USER</strong></p><p class="source-code"><strong class="bold">          value: lora_mysql</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_PASSWORD</strong></p><p class="source-code"><strong class="bold">          value: lora123-</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_ROOT_PASSWORD</strong></p><p class="source-code"><strong class="bold">          value: lora123-</strong></p><p class="source-code"><strong class="bold">        ports:</strong></p><p class="source-code"><strong class="bold">        - containerPort: 3306</strong></p><p class="source-code"><strong class="bold">          name: mysql</strong></p><p class="source-code"><strong class="bold">        volumeMounts:</strong></p><p class="source-code"><strong class="bold">        - name: mysql-persistent-storage</strong></p><p class="source-code"><strong class="bold">          mountPath: /var/lib/mysql</strong></p><p class="source-code"><strong class="bold">      volumes:</strong></p><p class="source-code"><strong class="bold">      - name: mysql-persistent-storage</strong></p><p class="source-code"><strong class="bold">        persistentVolumeClaim:</strong></p><p class="source-code"><strong class="bold">          claimName: db-pv-claim</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>In this <a id="_idIndexMarker850"/>deployment, we are using some <a id="_idIndexMarker851"/>environment variables:</p>
			<ul>
				<li><strong class="source-inline">MYSQL_DATABASE</strong>: Creates an initial database</li>
				<li><strong class="source-inline">MYSQL_USER</strong>: Creates a super admin user for the database defined in <strong class="source-inline">MYSQL_DATABASE</strong></li>
				<li><strong class="source-inline">MYSQL_PASSWORD</strong>: Sets a password for the defined user in the <strong class="source-inline">MYSQL_USER</strong> variable</li>
				<li><strong class="source-inline">MYSQL_ROOT_PASSWORD</strong>: Sets a password for the root user</li>
			</ul>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you are using a multi-node cluster, use the <strong class="source-inline">nodeSelector</strong> option to prevent issues with the provisioned <strong class="source-inline">PersistentVolumeClaim</strong>.</p>
			<ol>
				<li value="3">Now, we <a id="_idIndexMarker852"/>need a <strong class="source-inline">ClusterIP</strong> service. This <a id="_idIndexMarker853"/>will be used inside Grafana to configure this MySQL database as a data source:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  creationTimestamp: null</strong></p><p class="source-code"><strong class="bold">  name: mysql</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 3306</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 3306</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: mysql</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">status:</strong></p><p class="source-code"><strong class="bold">  loadBalancer: {}</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>We also need a <strong class="source-inline">LoadBalancer</strong> service to expose MySQL. This service will be used to expose MySQL to the outside world. This could be over the internet or using <a id="_idIndexMarker854"/>an IP address inside your local <a id="_idIndexMarker855"/>network. Regardless, the provisioned load balancer IP address will be used inside your ESP32 devices. These ESP32 devices are going to send information to this endpoint, using our metrics service to finally store sensor data in MySQL. Let’s create this <strong class="source-inline">LoadBalancer</strong> service:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  creationTimestamp: null</strong></p><p class="source-code"><strong class="bold">  name: mysql-lb</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 3306</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 3306</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: mysql</strong></p><p class="source-code"><strong class="bold">  type: LoadBalancer</strong></p><p class="source-code"><strong class="bold">status:</strong></p><p class="source-code"><strong class="bold">  loadBalancer: {}</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>Now that <a id="_idIndexMarker856"/>MySQL is running, we have to create <a id="_idIndexMarker857"/>a table to store sensor data. To do so, follow these steps:</p>
			<ol>
				<li value="1">Create a MySQL CLI client to run some commands to create the table where data will be stored:<p class="source-code"><strong class="bold">$ kubectl run client -it --rm --image=mysql:8.0.28-oracle -- bash</strong></p></li>
			</ol>
			<p>Once you are inside, run the following command. This will ask you for a password. Use <strong class="source-inline">lora123-</strong> as your password:</p>
			<p class="source-code"><strong class="bold">$ mysql -u lora_mysql -h mysql -p</strong></p>
			<p>The prompt will change to something similar to <strong class="source-inline">mysql&gt;</strong>.</p>
			<ol>
				<li value="2">Create the metric table and include the <strong class="source-inline">device</strong>, <strong class="source-inline">temperature_c</strong>, <strong class="source-inline">temperature_f</strong>, <strong class="source-inline">humidity</strong>, and <strong class="source-inline">time</strong> fields:<p class="source-code"><strong class="bold">use sensor_data;</strong></p><p class="source-code"><strong class="bold">CREATE TABLE metric (device INT NOT NULL,temperature_c DECIMAL(4,2),temperature_f DECIMAL(4,2) NOT NULL,humidity DECIMAL(4,2) NOT NULL, time DATETIME NOT NULL);</strong></p></li>
			</ol>
			<p>First, we must select the <strong class="source-inline">sensor_data</strong> database to create the table inside using the <strong class="source-inline">use</strong> command. Then, we must create the table metric using the <strong class="source-inline">CREATE TABLE</strong> command. We configure it so that each field has to have values. We use <strong class="source-inline">DECIMAL(4,2)</strong>, which means 4-2 = 2 integer numbers and 2 decimals. We store data using the format used by the <strong class="source-inline">now()</strong> MySQL function as <strong class="source-inline">MONTH/DAY/YEAR HOUR:MINUTE:SECOND</strong>.</p>
			<p>Here is a small explanation of what each field contains:</p>
			<ul>
				<li><strong class="source-inline">device</strong>: This represents the number of the ESP32 Lora device that sends sensor data. This could be a number greater than 0.</li>
				<li><strong class="source-inline">temperature_c</strong>: This is the temperature measured in Celsius.</li>
				<li><strong class="source-inline">temperature_f</strong>: This is the temperature measured in Fahrenheit.</li>
				<li><strong class="source-inline">humidity</strong>: Ambient humidity, measured as a percentage.</li>
			</ul>
			<ol>
				<li value="3">Exit the <a id="_idIndexMarker858"/>MySQL client using the <strong class="source-inline">quit</strong> command inside MySQL.</li>
				<li>Exit the <a id="_idIndexMarker859"/>client using the <strong class="source-inline">exit</strong> command. After exiting, the pod will be deleted.</li>
				<li>Get the MySQL IP address provisioned in the <strong class="source-inline">LoadBalancer</strong> service. To do so, run the following commands:<p class="source-code"><strong class="bold">$ MYSQL_IP="$(kubectl get svc mysql-lb -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')"</strong></p><p class="source-code"><strong class="bold">$ echo $MYSQL_IP</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">echo</strong> command is going to show the IP address of your MySQL.</p>
			<p>Now that our MySQL database has been deployed and is ready to be used, let’s deploy our metrics application on the far edge to store data in this MySQL database.</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor232"/>Deploying a service to store sensor data in a MySQL database</h1>
			<p>For this <a id="_idIndexMarker860"/>scenario, we need <a id="_idIndexMarker861"/>to deploy a service to store data in the previously deployed MySQL. We are going to call this <strong class="source-inline">metrics</strong>. The <strong class="source-inline">metrics</strong> service contains the following code:</p>
			<p class="source-code">from flask import Flask, request</p>
			<p class="source-code">import mysql.connector</p>
			<p class="source-code">import os</p>
			<p class="source-code"> </p>
			<p class="source-code">app = Flask(__name__)</p>
			<p class="source-code"> </p>
			<p class="source-code">@app.route('/')</p>
			<p class="source-code">def hello_world():</p>
			<p class="source-code">    return 'It works'</p>
			<p class="source-code"> </p>
			<p class="source-code">def insert(data):</p>
			<p class="source-code">    conn = mysql.connector.connect(</p>
			<p class="source-code">     host=os.environ['HOST'],</p>
			<p class="source-code">     user=os.environ['MYSQL_USER'],</p>
			<p class="source-code">     password=os.environ['MYSQL_PASSWORD'],</p>
			<p class="source-code">     database=os.environ['MYSQL_DATABASE']</p>
			<p class="source-code">    )</p>
			<p class="source-code">    cursor = conn.cursor()</p>
			<p class="source-code">    sql = "INSERT INTO metric "+\</p>
			<p class="source-code">          "(device,temperature_c,"+\</p>
			<p class="source-code">          "temperature_f,humidity,time) "+\</p>
			<p class="source-code">          "VALUES (%s,%s,%s,%s,now());"</p>
			<p class="source-code">    val = (data["d"],data["t"],data["t_f"],data["h"])</p>
			<p class="source-code">    cursor.execute(sql,val)</p>
			<p class="source-code">    conn.commit()</p>
			<p class="source-code">    cursor.close()</p>
			<p class="source-code">    conn.close()</p>
			<p class="source-code"> </p>
			<p class="source-code">@app.route('/device',methods = ['POST'])</p>
			<p class="source-code">def device():</p>
			<p class="source-code">    data = request.json</p>
			<p class="source-code">    print(data)</p>
			<p class="source-code">    #Process data in some way</p>
			<p class="source-code">    t_farenheit = float(data["t"])*(9/5)+32</p>
			<p class="source-code">    data["t_f"] = t_farenheit</p>
			<p class="source-code">    insert(data)</p>
			<p class="source-code">    return "processed"</p>
			<p class="source-code"> </p>
			<p class="source-code">if __name__ == '__main__':</p>
			<p class="source-code">    app.run(host='0.0.0.0', port=3000, debug=True)</p>
			<p>This code has two endpoints:</p>
			<ul>
				<li><strong class="source-inline">/</strong>: This is only a test URL.</li>
				<li><strong class="source-inline">/device</strong>: This gets data from POST requests and writes it to MySQL by calling the <strong class="source-inline">insert</strong> function.</li>
			</ul>
			<p>It also <a id="_idIndexMarker862"/>uses the <strong class="source-inline">insert(data)</strong> function to insert the data into the MySQL deployed in the cloud layer. This <a id="_idIndexMarker863"/>function takes the data coming from LoRaWAN and recalculates the temperature in Fahrenheit. Once stored, the data returns the process word. </p>
			<p>This script also uses the following environment variables:</p>
			<ul>
				<li><strong class="source-inline">HOST</strong>: Defines the IP address where MySQL is listening</li>
				<li><strong class="source-inline">MYSQL_USER</strong>: The user to connect to the database</li>
				<li><strong class="source-inline">MYSQL_PASSWORD</strong>: The password used to connect to the database</li>
				<li><strong class="source-inline">MYSQL_DATABASE</strong>: The database name where <strong class="source-inline">metrics</strong> is going to store data</li>
			</ul>
			<p>Our deployment in Kubernetes must have these variables set to work properly, without errors.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can check the code on how to build a container based on this example at <a href="https://github.com/sergioarmgpl/containers/tree/main/metric">https://github.com/sergioarmgpl/containers/tree/main/metric</a>. </p>
			<p>Now that <a id="_idIndexMarker864"/>we’ve looked at the <a id="_idIndexMarker865"/>code of the <strong class="source-inline">metrics</strong> service, let’s deploy <strong class="source-inline">metrics</strong> to start storing sensor data in this database. For this, follow these steps:</p>
			<ol>
				<li value="1">Deploy our <strong class="source-inline">metrics</strong> application so that it’s running:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  creationTimestamp: null</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: metrics</strong></p><p class="source-code"><strong class="bold">  name: metrics</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  replicas: 1</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      app: metrics</strong></p><p class="source-code"><strong class="bold">  strategy: {}</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata: </strong></p><p class="source-code"><strong class="bold">      creationTimestamp: null</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        app: metrics</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - image: sergioarmgpl/metric</strong></p><p class="source-code"><strong class="bold">        name: metric </strong></p><p class="source-code"><strong class="bold">        env:</strong></p><p class="source-code"><strong class="bold">        - name: HOST</strong></p><p class="source-code"><strong class="bold">          value: "192.168.0.240"</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_USER</strong></p><p class="source-code"><strong class="bold">          value: "lora_mysql"</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_PASSWORD</strong></p><p class="source-code"><strong class="bold">          value: "lora123-"</strong></p><p class="source-code"><strong class="bold">        - name: MYSQL_DATABASE</strong></p><p class="source-code"><strong class="bold">          value: "sensor_data"</strong></p><p class="source-code"><strong class="bold">        resources: {} </strong></p><p class="source-code"><strong class="bold">status: {} </strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>In this deployment, we are using the following values for the environment variables:</p>
			<ul>
				<li><strong class="source-inline">HOST</strong>: This is the IP address of the <strong class="source-inline">LoadBalancer</strong> service that was created for our MySQL – that is, <strong class="source-inline">192.168.0.240</strong>. This will be the IP address that was returned in the last step of the previous section.</li>
				<li><strong class="source-inline">MYSQL_USER</strong>: The MySQL user. In this case, this is <strong class="source-inline">lora_mysql</strong>.</li>
				<li><strong class="source-inline">MYSQL_PASSWORD</strong>: The password for <strong class="source-inline">lora_mysql</strong>. In this case, this is <strong class="source-inline">lora123-</strong>.</li>
				<li><strong class="source-inline">MYSQL_DATABASE</strong>: The name of the MySQL database where sensor data will be stored. In this case, this is <strong class="source-inline">sensor_data</strong>.</li>
			</ul>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can customize all these values to fit your needs. Remember that you can use ConfigMaps or Secrets to secure your deployments. We are using hard-coded values just to simplify the implementation. Check out <a href="B16945_10_Final_PG.xhtml#_idTextAnchor198"><em class="italic">Chapter 10</em></a>, <em class="italic">SQL and NoSQL Databases at the Edge</em>, for this kind of configuration.</p>
			<ol>
				<li value="2">Now, let’s <a id="_idIndexMarker866"/>create our <strong class="source-inline">LoadBalancer</strong> service for the <strong class="source-inline">metrics</strong> deployment. The provisioned IP <a id="_idIndexMarker867"/>address will be hard-coded inside the code of our ESP32 devices. To create the service, run the following code:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  creationTimestamp: null</strong></p><p class="source-code"><strong class="bold">  name: metrics</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 3000</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 3000</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: metrics</strong></p><p class="source-code"><strong class="bold">  type: LoadBalancer</strong></p><p class="source-code"><strong class="bold">status:</strong></p><p class="source-code"><strong class="bold">  loadBalancer: {}</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>To obtain <a id="_idIndexMarker868"/>the provisioned IP <a id="_idIndexMarker869"/>address from the <strong class="source-inline">metrics</strong> service, run the following commands: <p class="source-code"><strong class="bold">$ METRICS_IP="$(kubectl get svc metrics -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')"</strong></p><p class="source-code"><strong class="bold">$ echo METRICS_IP</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">echo</strong> command will show the IP address of our <strong class="source-inline">metrics</strong> application. Take note of this value since it will be used to program our ESP32 devices. Let’s assume that this value is <strong class="source-inline">192.168.0.241</strong> for this scenario.</p>
			<p>Now that we have deployed our <strong class="source-inline">metrics</strong> service on the far edge, let’s configure our ESP32 devices so that they can send and receive data.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor233"/>Programming the ESP32 microcontroller to send sensor data</h1>
			<p>ESP32 is <a id="_idIndexMarker870"/>a low-cost, low-power microcontroller chip and the successor of the ESP8266 microcontroller. In this <a id="_idIndexMarker871"/>chapter, we will be using the Heltec ESP32 + LoRa, which is an ESP32 microcontroller plus the capability to use the LoRa wireless protocol. This microcontroller can also send and receive data using the LoRa wireless protocol using the integrated SX1276 chip in this Heltec dashboard.</p>
			<p>Before configuring our device, we have to do the following:</p>
			<ol>
				<li value="1">Connect the DHT11 sensor to the Heltec ESP32 + LoRa device.</li>
				<li>Install the USB to UART bridge driver.</li>
				<li>Install and configure Arduino IDE to program the Heltec ESP32 + LoRa device.</li>
				<li>Flash the Heltec ESP32 + Lora device.</li>
			</ol>
			<p>So, let’s get started by connecting a DHT11 sensor to our Heltec ESP32 + Lora device.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor234"/>Configuring Heltec ESP32 + LoRa to read DHT11 sensor data</h2>
			<p>Heltec <a id="_idIndexMarker872"/>devices are often used for IoT, and ESP32 is a very popular device for IoT and <a id="_idIndexMarker873"/>LoRa implementations. You <a id="_idIndexMarker874"/>can find the <a id="_idIndexMarker875"/>official documentation for Heltec devices at <a href="https://heltec-automation-docs.readthedocs.io/en/latest">https://heltec-automation-docs.readthedocs.io/en/latest</a>. For our LoRa implementation, we are going to use the following diagram:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B16945_12_02.jpg" alt="Figure 12.2 – Heltec ESP32 reading data from the DHT11 schema&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Heltec ESP32 reading data from the DHT11 schema</p>
			<p>To <a id="_idIndexMarker876"/>connect <a id="_idIndexMarker877"/>your Heltec <a id="_idIndexMarker878"/>ESP32 to your DHT11 sensor, follow these steps. This is the sender device:</p>
			<ol>
				<li value="1">Connect your LoRa antenna. This could affect the transmission range if the antenna is not connected.</li>
				<li>Connect your power source to the USB connection. You must use a USB 2.0 A-Male to Micro B cable.</li>
				<li>Connect your <strong class="source-inline">PIN 17</strong> with a wire to the <strong class="source-inline">S</strong> input in the DHT11 sensor.</li>
				<li>Connect the GND (ground) to the <strong class="source-inline">G</strong> input in the DHT11 sensor.</li>
				<li>Connect one of the 3V3 volt outputs to the <strong class="source-inline">V</strong> input in the DHT11 sensor.</li>
			</ol>
			<p>For your receiver device, just follow these steps:</p>
			<ol>
				<li value="1">Connect your LoRa antenna.</li>
				<li>Connect your power source to the USB connection as your sender device.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Remember that you have to use a power source supply or a battery that gives you 3.5 or 5 volts. To learn more, check out <a href="https://heltec-automation-docs.readthedocs.io/en/latest/esp32/index.html">https://heltec-automation-docs.readthedocs.io/en/latest/esp32/index.html</a>.</p>
			<p>With <a id="_idIndexMarker879"/>that, your <a id="_idIndexMarker880"/>sender and receiver devices are ready to upload some code. Now, let’s install <a id="_idIndexMarker881"/>all the software that we need to upload some code into our devices.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor235"/>Installing the USB to UART bridge driver</h2>
			<p>When <a id="_idIndexMarker882"/>installing the generic SiLabs CP210X driver that installs support for the USB to UART bridge, this driver is going to <a id="_idIndexMarker883"/>recognize your device on your computer. In this way, your Heltec device can connect to the computer and interact with Arduino IDE using serial communication. </p>
			<p>To install <a id="_idIndexMarker884"/>this driver, you can visit the following link for detailed instructions: <a href="https://heltec-automation-docs.readthedocs.io/en/latest/general/establish_serial_connection.html">https://heltec-automation-docs.readthedocs.io/en/latest/general/establish_serial_connection.html</a>. There, you can find the latest documentation to install the driver on Windows and Mac. </p>
			<p>These instructions consist of downloading various drivers:</p>
			<ul>
				<li>For Windows: <a href="https://www.silabs.com/documents/public/software/CP210x_Windows_Drivers.zip">https://www.silabs.com/documents/public/software/CP210x_Windows_Drivers.zip</a></li>
				<li>For Mac: <a href="https://www.silabs.com/documents/public/software/Mac_OSX_VCP_Driver.zip">https://www.silabs.com/documents/public/software/Mac_OSX_VCP_Driver.zip</a></li>
			</ul>
			<p>You must follow the wizard to install them, depending on your system. Once you have installed the driver, you can connect your device to your system and check if it was detected. For Mac, you can execute the following command:</p>
			<pre class="source-code">
$ ls /dev | grep cu | grep 'usbserial\|UART'</pre>
			<p>You will see an output similar to the following:</p>
			<pre class="source-code">
cu.SLAB_USBtoUART
cu.usbserial-0001</pre>
			<p>This means <a id="_idIndexMarker885"/>that your device <a id="_idIndexMarker886"/>was detected. Some common problems may occur where your device can’t be recognized. This will be because of the cable that you are using; try to find a cable in an optimal condition for your computer to detect the device.</p>
			<p>For Windows, you will see that your device appears in the Hardware manager in the part of ports. Then, the device will appear like so:</p>
			<ul>
				<li>Silicon Labs CP210X USB to UART bridge (COM3) </li>
			</ul>
			<p>This means that your Heltec device was detected successfully.</p>
			<p>Now that your system recognizes the device, it’s time to install Arduino IDE to upload some code inside your Heltec device.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor236"/>Installing Arduino IDE</h2>
			<p>Arduino IDE is <a id="_idIndexMarker887"/>a piece of software that you can use to upload code to <a id="_idIndexMarker888"/>your boards. In this case, we are using a board designed <a id="_idIndexMarker889"/>by Heltec, which is the one we called the Heltec device. To start using Arduino IDE, follow these steps:</p>
			<ol>
				<li value="1">Download <a id="_idIndexMarker890"/>Arduino IDE by going to <a href="https://www.arduino.cc/en/software">https://www.arduino.cc/en/software</a>. This will depend on which operating system are you using. You can choose between Windows, Linux, or Mac. In this chapter, we are going to cover just Mac. We will use Arduino 1.8.19.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can <a id="_idIndexMarker891"/>also follow the official page of Heltec, which explains how to install the Heltec driver and Arduino IDE for Windows and Mac. The quick start link is <a href="https://heltec-automation-docs.readthedocs.io/en/latest/esp32/quick_start.html">https://heltec-automation-docs.readthedocs.io/en/latest/esp32/quick_start.html</a>.</p>
			<ol>
				<li value="2">Open <a id="_idIndexMarker892"/>Arduino IDE by clicking on its icon on your desktop <a id="_idIndexMarker893"/>or inside Launchpad on Mac.</li>
				<li>Click <strong class="bold">File</strong> | <strong class="bold">Preferences</strong> and paste <a href="https://github.com/Heltec-Aaron-Lee/WiFi_Kit_series/releases/download/0.0.5/package_heltec_esp32_index.json">https://github.com/Heltec-Aaron-Lee/WiFi_Kit_series/releases/download/0.0.5/package_heltec_esp32_index.json</a> inside the <strong class="bold">Additional Boards Manager URLs</strong> field. Then, click <strong class="bold">OK</strong>. The new ESP32 board will be loaded in Arduino IDE:</li>
			</ol>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B16945_12_03.jpg" alt="Figure 12.3 – Configuring Preferences to use the Heltec ESP32 device&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Configuring Preferences to use the Heltec ESP32 device</p>
			<ol>
				<li value="4">Now, go <a id="_idIndexMarker894"/>to <strong class="bold">Tools</strong> | <strong class="bold">Board</strong> | <strong class="bold">Boards Manager</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B16945_12_04.jpg" alt="Figure 12.4 – The Boards Manager menu&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – The Boards Manager menu</p>
			<ol>
				<li value="5">S<a id="_idTextAnchor237"/>earch <a id="_idIndexMarker895"/>for <strong class="source-inline">heltec</strong> in the new <a id="_idIndexMarker896"/>pop-up dialog, then click <strong class="bold">Install</strong> to install it:</li>
			</ol>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B16945_12_05.jpg" alt="Figure 12.5 – Searching for heltec on Boards Manager&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Searching for heltec on Boards Manager</p>
			<p>You <a id="_idIndexMarker897"/>will see something similar <a id="_idIndexMarker898"/>to the following:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B16945_12_06.jpg" alt="Figure 12.6 – Heltec board installed via Boards Manager&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Heltec board installed via Boards Manager</p>
			<ol>
				<li value="6">Now, select the board by going to <strong class="bold">Tools</strong> | <strong class="bold">Board</strong> | <strong class="bold">Heltec ESP32 Arduino</strong> and select <strong class="bold">WiFi LoRa 32(V2)</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B16945_12_07.jpg" alt="Figure 12.7 – Setting WiFi LoRa 32(V2) as the default board&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Setting WiFi LoRa 32(V2) as the default board</p>
			<ol>
				<li value="7">Now, repeat <a id="_idIndexMarker899"/>this process by going to <strong class="bold">Tools</strong> | <strong class="bold">Manage Libraries</strong>, searching for the <strong class="bold">DHT sensor</strong> library from <a id="_idIndexMarker900"/>Adafruit, and choosing <strong class="bold">Heltec ESP32 Dev-Boards</strong>. Make sure you install it.</li>
			</ol>
			<p>With that, our Arduino IDE is ready to be used. Now, let’s learn about some configurations that you will need in case of errors.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor238"/>Troubleshooting Arduino IDE when using Heltec ESP32 + LoRa </h2>
			<p>macOS <a id="_idIndexMarker901"/>has some challenges, depending <a id="_idIndexMarker902"/>on your <a id="_idIndexMarker903"/>Mac version, but you can fix them. </p>
			<p>One is the esptool Python library. To fix it, follow these steps:</p>
			<ol>
				<li value="1">Copy your current <strong class="source-inline">esptool.py</strong> file inside the <strong class="source-inline">tools</strong> folder. The command will look as follows:<p class="source-code"><strong class="bold">$ cp /Users/&lt;YOUR_USER&gt;/Library/Arduino15/packages/Heltec-esp32/hardware/esp32/&lt;X.X.X&gt; /tools/esptool.py /Users/ &lt;YOUR_USER&gt; /Library/Arduino15/packages/Heltec-esp32/tools/esptool_py/&lt;X.X.X&gt;/</strong></p></li>
				<li>Change the permissions for the <strong class="source-inline">esptool.py</strong> file:<p class="source-code"><strong class="bold">$ chmod +x esptool.py</strong></p></li>
			</ol>
			<p>Run the <strong class="source-inline">esptool.py</strong> file:</p>
			<p class="source-code"><strong class="bold">$ ./esptool.py</strong></p>
			<ol>
				<li value="3">Sometimes, you have to install the serial library if the previous command returns <a id="_idIndexMarker904"/>an error. For <a id="_idIndexMarker905"/>this, you have several options. One is to install the library from scratch by going to <a href="https://github.com/pyserial/pyserial/releases">https://github.com/pyserial/pyserial/releases</a>. In this case, we are using version 3.4. For this run, the following commands:<p class="source-code"><strong class="bold">$ wget https://github.com/pyserial/pyserial/archive/refs/tags/v3.4.zip</strong></p><p class="source-code"><strong class="bold">$ sudo python setup.py install</strong></p></li>
				<li>Then, try again if the <strong class="source-inline">./esptool.py</strong> command returns errors.</li>
				<li>Depending on which Python version is installed on your computer, you can try this other alternative:<p class="source-code"><strong class="bold">$ sudo pip install pyserial or</strong></p><p class="source-code"><strong class="bold">$ sudo pip3 install pyserial</strong></p></li>
				<li>The last alternative is to use <strong class="source-inline">easy_install</strong> to install the pyserial library. To do so, run the following command:<p class="source-code"><strong class="bold">$ sudo easy_install pyserial</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">macOS Monterrey deletes Python 2.7 by default, so you have to install this Python version. You could stay with Python 3, but you have to open Arduino IDE with the <strong class="source-inline">open /Applications/Arduino.app</strong> command. You can find a more detailed way to fix these problems by watching the following video: <a href="https://www.youtube.com/watch?v=zkyoghpT8_U">https://www.youtube.com/watch?v=zkyoghpT8_U</a>.</p>
			<p>Another <a id="_idIndexMarker906"/>problem to fix, depending <a id="_idIndexMarker907"/>on your Arduino version, is that Heltec installs its Wi-Fi library. So, when you try to compile and upload the program, sometimes, you will see some errors. To avoid these errors, you have two options:</p>
			<ol>
				<li value="1">Uninstall the default Arduino Wi-Fi library by going to <strong class="bold">Tools</strong> | <strong class="bold">Manage libraries</strong>. Then, find the Wi-Fi library from Arduino and uninstall it.</li>
				<li>Remove or rename the default Arduino Wi-Fi library folder by using the following commands:<p class="source-code"><strong class="bold">$ cd /Applications/Arduino.app/Contents/Java/libraries</strong></p><p class="source-code"><strong class="bold">$ mv libraries/WiFi</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">On Windows, the installation is smooth, so you won’t have to fix this kind of issue.</p>
			<p>Now, it is time to upload some code to your devices using Arduino IDE.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor239"/>Uploading code to the ESP32 microcontroller to send sensor data</h2>
			<p>Now, let’s upload our code to our Heltec devices. Let’s start with the sender device. This device <a id="_idIndexMarker908"/>is going to capture data from the DHT11 sensor and send it to the receiver device using the LoRa wireless protocol. Let’s create a new file by going to <strong class="bold">File</strong> | <strong class="bold">New</strong>. By default, you will see something similar to the following:</p>
			<p class="source-code">void setup() {</p>
			<p class="source-code">  // put your setup code here, to run once: </p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">void loop() {</p>
			<p class="source-code">  // put your main code here, to run repeatedly:</p>
			<p class="source-code">}</p>
			<p>Now, replace it with the following code:</p>
			<p class="source-code">#include "heltec.h"</p>
			<p class="source-code">#define BAND    915E6</p>
			<p class="source-code"> </p>
			<p class="source-code">#include "DHT.h"</p>
			<p class="source-code">#define DHTPIN 17</p>
			<p class="source-code">#define DHTTYPE DHT11</p>
			<p class="source-code">DHT dht(DHTPIN, DHTTYPE);</p>
			<p class="source-code"> </p>
			<p class="source-code">#define DEVICE 1</p>
			<p class="source-code">#define DELAY 3000</p>
			<p class="source-code"> </p>
			<p class="source-code">void setup()</p>
			<p class="source-code">{</p>
			<p class="source-code">  Heltec.begin(false,true,true,true,BAND);</p>
			<p class="source-code">  Serial.begin(9600);</p>
			<p class="source-code">  LoRa.setSyncWord(0xF3);</p>
			<p class="source-code">  Serial.println("LoRa started");</p>
			<p class="source-code">  dht.begin();</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">void sendTH()</p>
			<p class="source-code">{</p>
			<p class="source-code">  String values = "";</p>
			<p class="source-code">  LoRa.beginPacket();</p>
			<p class="source-code">  float h = dht.readHumidity();</p>
			<p class="source-code">  float t = dht.readTemperature();</p>
			<p class="source-code">  if (isnan(h) || isnan(t)) {</p>
			<p class="source-code">    Serial.println(F("Failed to get data from sensor"));</p>
			<p class="source-code">    return;</p>
			<p class="source-code">  } </p>
			<p class="source-code">  String hS = (String)h;</p>
			<p class="source-code">  String tS = (String)t;</p>
			<p class="source-code">  String dS = (String)DEVICE;</p>
			<p class="source-code">  values = "{\"t\":"+tS+",\"h\":"+hS+",\"d\":"+dS+"}";</p>
			<p class="source-code">  Serial.println(values);</p>
			<p class="source-code">  LoRa.print(values);</p>
			<p class="source-code">  LoRa.endPacket();</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">void loop()</p>
			<p class="source-code">{</p>
			<p class="source-code">  delay(DELAY);</p>
			<p class="source-code">  sendTH();</p>
			<p class="source-code">}</p>
			<p>Let’s <a id="_idIndexMarker909"/>look at the preceding code in more detail:</p>
			<ul>
				<li><strong class="source-inline">heltec.h</strong>: We import the library to use the ESP32 + LoRa device. With this, you can use the Wi-Fi and LoRa wireless protocol.</li>
				<li><strong class="source-inline">DHT.h</strong>: We import the library to read data from the DHT11 sensor.</li>
				<li><strong class="source-inline">BAND</strong>: We set the band to use to connect the devices. For Europe, you have to use a value of <strong class="source-inline">868E6</strong>, while for America, you have to use <strong class="source-inline">915E6</strong>.</li>
				<li><strong class="source-inline">DHTPIN</strong>: This is a constant value that we use to set the PIN that’s used to read data in our ESP32 device. In this case, we are using pin 17. Keep in mind that the pin to use has to support digital information.</li>
				<li><strong class="source-inline">DHTTYPE</strong>: This defines the type of sensor. The library that we are using supports the DHT11 and DHT12 sensors.</li>
				<li><strong class="source-inline">DEVICE</strong>: This is the device number that is sending data. You must change this value every time you upload the code on a device, just to identify each device using a number.</li>
				<li><strong class="source-inline">DELAY</strong>: This is the time to wait until sending the next sensor measure data.</li>
				<li><strong class="source-inline">setup()</strong>: This function does an initial configuration for the Heltec device and sets the network ID for LoRa using <strong class="source-inline">0xF3</strong> – that is, the network ID for our devices. This value must be set between <strong class="source-inline">0</strong> and <strong class="source-inline">0xFF</strong>.</li>
				<li><strong class="source-inline">sendTH()</strong>: This function captures and sends the sensor data with the L<a id="_idTextAnchor240"/>oRa Wi-Fi protocol in the <strong class="source-inline">{"t":26.2,"h":35.5,"d":1}</strong> format, where <strong class="source-inline">t</strong> is the temperature in Celsius, <strong class="source-inline">h</strong> is the humidity in percentages, and <strong class="source-inline">d</strong> is the device number.</li>
				<li><strong class="source-inline">loop()</strong>: This function runs as a loop and calls <strong class="source-inline">sendTH()</strong> to capture and send sensor data using LoRa.</li>
			</ul>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can find the source code of the sender and receiver device at <a href="https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch12/code/arduino">https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch12/code/arduino</a>.</p>
			<p>In summary, first, we set all the constant values to configure how to read data from the DHT11 <a id="_idIndexMarker910"/>sensor and send data using LoRa. Then, the setup is called to prepare reading data from the sensor and the initial configuration for LoRa. Finally, <strong class="source-inline">loop()</strong> runs as a loop that calls <strong class="source-inline">sendTH()</strong>, which sends and receives data. Once you have your device with this code, just turn it on to send data. To stop sending data, you must power off the device.</p>
			<p>Pay attention to the lines that contain the <strong class="source-inline">Serial.println</strong> command. This command prints information using the serial port. You can troubleshoot what is happening in your device using Arduino when your device is powered with your USB port from your laptop by opening <strong class="bold">Tools</strong> | <strong class="bold">Serial Monitor</strong>. Doing this will show all the <strong class="source-inline">Serial.println</strong> outputs inside the window:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B16945_12_08.jpg" alt="Figure 12.8 – Monitoring with Heltec ESP32 devices in Arduino&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Monitoring with Heltec ESP32 devices in Arduino</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">To connect your device to macOS, you need a USB A-to-USB C adaptor. If you need a power source with at least 5 volts, you can also use a battery bank instead of connecting the device to a laptop or a computer.</p>
			<p>Now that <a id="_idIndexMarker911"/>your Heltec sender device is working, you can start uploading the code for the receiver device.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor241"/>Programming the ESP32 microcontroller to receive sensor data</h1>
			<p>Now, we <a id="_idIndexMarker912"/>have to configure <a id="_idIndexMarker913"/>our Heltec ESP32 device to receive the sensor data and send it to the far edge cluster by doing a request across the wireless network. To start, we must create another file by clicking <strong class="bold">File</strong> | <strong class="bold">New</strong> and replacing the default content with the following code:</p>
			<pre class="source-code">
#include "heltec.h"
#include "WiFi.h"
#include &lt;HTTPClient.h&gt;
#define BAND    915E6
#define METRICS_IP "192.168.0.241"
void setup()
{
  Heltec.begin(false, true, true, true, BAND);
  Serial.begin(9600);
  LoRa.setSyncWord(0xF3);
  Serial.println("LoRa started");
  WIFISetUp();
}
 
void WIFISetUp(void)
{
  WiFi.disconnect(true);
  delay(100);
  WiFi.mode(WIFI_STA);
  WiFi.setAutoConnect(true);
  WiFi.begin("NET_NAME","PASSWORD");
  delay(100);
 
  byte count = 0;
  while(WiFi.status() != WL_CONNECTED &amp;&amp; count &lt; 10)
  {
    count ++;
    delay(500);
    Serial.println("Connecting...");
  }
  if(WiFi.status() == WL_CONNECTED)
    Serial.println("Connected OK");
  else
    Serial.println("Failed");
}
void callURL(String data)
{
  String postData = data;
  Serial.println("Sending: " + postData);
  WiFiClient client;
  HTTPClient http;
  http.begin(client, "http://"+((String)METRICS_IP)+":3000/device");
  http.addHeader("Content-Type","application/json");
  int httpResponseCode = http.POST(postData);
  Serial.println("HTTP Response code xyz: "+(String)httpResponseCode);
  http.end();
}
 
void loop()
{
  onReceive(LoRa.parsePacket());
}
 
void onReceive(int packetSize)
{
  String incoming = "";
  if (packetSize == 0) return;
 
  while (LoRa.available())
    incoming += (char)LoRa.read();
 
  Serial.println("Received: " + incoming);
  callURL(incoming);
}</pre>
			<p>Let’s <a id="_idIndexMarker914"/>understand the code <a id="_idIndexMarker915"/>a little bit:</p>
			<ul>
				<li><strong class="source-inline">Heltec.h</strong>, <strong class="source-inline">WiFi.h</strong>, <strong class="source-inline">HTTPClient.h</strong>: These are the libraries that we are using for the receiver. <strong class="source-inline">Heltec.h</strong> is used to send data with LoRa, <strong class="source-inline">WiFi.h</strong> is the Wi-Fi Heltec library to connect to the wireless network, and <strong class="source-inline">HTTPClient.h</strong> is used to send a request to our far edge server with the sensor data.</li>
				<li><strong class="source-inline">BAND</strong>: Here, we set the same band that’s used in the sender device.</li>
				<li><strong class="source-inline">METRICS_IP</strong>: This is the IP address of the <strong class="source-inline">metrics</strong> service in your cluster. To get this value, go to the <em class="italic">Deploying a service to store sensor data in a MySQL database</em> section. Replace this value before uploading the code to your device.</li>
				<li><strong class="source-inline">setup()</strong>: Here, we configure the Heltec device to receive data from the same LoRa network defined by <strong class="source-inline">setSyncWord</strong>. It also configures the Wi-Fi connection.</li>
				<li><strong class="source-inline">WIFISetUp(void)</strong>: Here, we configure the Wi-Fi connection. To do so, you must replace <strong class="source-inline">NET_NAME</strong> with your network name and <strong class="source-inline">PASSWORD</strong> with the necessary password to access your connection.</li>
				<li><strong class="source-inline">callURL(String data)</strong>: This calls the <strong class="source-inline">metrics</strong> service in your cluster. The URL to access it will be something like <strong class="source-inline">http://METRICS_IP:3000/device</strong>, but this function automatically generates this URL using the value of the <strong class="source-inline">METRICS_IP</strong> constant.</li>
				<li><strong class="source-inline">onReceive(int packetSize)</strong>: This receives information that’s been sent to the configured network using the LoRa protocol and then sends that information to the <strong class="source-inline">metrics</strong> service in the far edge cluster using an HTTP POST request.</li>
				<li><strong class="source-inline">loop()</strong>: This function runs as a loop and calls <strong class="source-inline">onReceive(int packetSize)</strong>, which gets LoRa packets that contains sensor data. Then, it sends these to the <strong class="source-inline">metrics</strong> endpoint in the far edge cluster.</li>
			</ul>
			<p>To summarize, first, we configure the device so that we can connect to the same LoRa network. We <a id="_idIndexMarker916"/>must also <a id="_idIndexMarker917"/>configure the Wi-Fi, which has access to the far edge server. <strong class="source-inline">loop()</strong> constantly checks if it has received some data to send it to the <strong class="source-inline">metrics</strong> server in the far edge cluster. </p>
			<p>Now, upload the code to your device and turn it on, as we did in the <em class="italic">Programming the ESP32 microcontroller to send sensor data</em> section. With that, our devices have been configured, so let’s move to the last step and configure Grafana to show all our data in a dashboard, using the sensor data stored in MySQL.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor242"/>Visualizing data from ESP32 microcontrollers using MySQL and Grafana</h1>
			<p>Now, let’s <a id="_idIndexMarker918"/>finish off our implementation <a id="_idIndexMarker919"/>of a real-time temperature and humidity system. For this, we are going to use Grafana to create our reports and MySQL as our source of data to feed the reports. You can deploy this <a id="_idIndexMarker920"/>software in Kubernetes in the <a id="_idIndexMarker921"/>cloud or a private cloud using a network that can be accessed by your edge clusters. In this section, we are assuming <a id="_idIndexMarker922"/>that we are <a id="_idIndexMarker923"/>using Kubernetes in the cloud. To start creating our reports, follow these steps:</p>
			<ol>
				<li value="1">Create the necessary namespace monitoring:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Namespace</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  creationTimestamp: null</strong></p><p class="source-code"><strong class="bold">  name: monitoring</strong></p><p class="source-code"><strong class="bold">spec: {}</strong></p><p class="source-code"><strong class="bold">status: {}</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Create a ConfigMap to create a default data source that contains our MySQL connection:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: ConfigMap</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: grafana-datasources</strong></p><p class="source-code"><strong class="bold">  namespace: monitoring</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    grafana_datasource: "true"</strong></p><p class="source-code"><strong class="bold">data:</strong></p><p class="source-code"><strong class="bold">  datasource.yaml: |-</strong></p><p class="source-code"><strong class="bold">    apiVersion: 1</strong></p><p class="source-code"><strong class="bold">    datasources:</strong></p><p class="source-code"><strong class="bold">      - name: sensor_data</strong></p><p class="source-code"><strong class="bold">        type: mysql</strong></p><p class="source-code"><strong class="bold">        url: mysql.default.svc</strong></p><p class="source-code"><strong class="bold">        access: proxy</strong></p><p class="source-code"><strong class="bold">        database: sensor_data</strong></p><p class="source-code"><strong class="bold">        user: lora_mysql</strong></p><p class="source-code"><strong class="bold">        secureJsonData:</strong></p><p class="source-code"><strong class="bold">          password: lora123-</strong></p><p class="source-code"><strong class="bold">        isDefault: true</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
			</ol>
			<p>This <a id="_idIndexMarker924"/>will <a id="_idIndexMarker925"/>be <a id="_idIndexMarker926"/>the <a id="_idIndexMarker927"/>default <a id="_idIndexMarker928"/>data <a id="_idIndexMarker929"/>source configured in your <strong class="source-inline">grafana</strong> deployment.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can use a <strong class="source-inline">Secret</strong> object to secure sensitive data, but we are using <strong class="source-inline">ConfigMap</strong> to simplify this example.</p>
			<ol>
				<li value="3">Deploy <a id="_idIndexMarker930"/>Grafana so <a id="_idIndexMarker931"/>that <a id="_idIndexMarker932"/>it can <a id="_idIndexMarker933"/>use <a id="_idIndexMarker934"/>the <a id="_idIndexMarker935"/>previous ConfigMap by running the following code:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: apps/v1</strong></p><p class="source-code"><strong class="bold">kind: Deployment</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: grafana</strong></p><p class="source-code"><strong class="bold">  namespace: monitoring</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  replicas: 1</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    matchLabels:</strong></p><p class="source-code"><strong class="bold">      app: grafana</strong></p><p class="source-code"><strong class="bold">  template:</strong></p><p class="source-code"><strong class="bold">    metadata:</strong></p><p class="source-code"><strong class="bold">      name: grafana</strong></p><p class="source-code"><strong class="bold">      labels:</strong></p><p class="source-code"><strong class="bold">        app: grafana</strong></p><p class="source-code"><strong class="bold">    spec:</strong></p><p class="source-code"><strong class="bold">      containers:</strong></p><p class="source-code"><strong class="bold">      - name: grafana</strong></p><p class="source-code"><strong class="bold">        image: grafana/grafana:8.4.4</strong></p><p class="source-code"><strong class="bold">        ports:</strong></p><p class="source-code"><strong class="bold">        - name: grafana</strong></p><p class="source-code"><strong class="bold">          containerPort: 3000</strong></p><p class="source-code"><strong class="bold">        resources:</strong></p><p class="source-code"><strong class="bold">          limits:</strong></p><p class="source-code"><strong class="bold">            memory: "1Gi"</strong></p><p class="source-code"><strong class="bold">            cpu: "1000m"</strong></p><p class="source-code"><strong class="bold">          requests: </strong></p><p class="source-code"><strong class="bold">            memory: 500M</strong></p><p class="source-code"><strong class="bold">            cpu: "500m"</strong></p><p class="source-code"><strong class="bold">        volumeMounts:</strong></p><p class="source-code"><strong class="bold">          - mountPath: /var/lib/grafana</strong></p><p class="source-code"><strong class="bold">            name: grafana-storage</strong></p><p class="source-code"><strong class="bold">          - mountPath: /etc/grafana/provisioning/datasources</strong></p><p class="source-code"><strong class="bold">            name: grafana-datasources</strong></p><p class="source-code"><strong class="bold">            readOnly: false</strong></p><p class="source-code"><strong class="bold">      volumes:</strong></p><p class="source-code"><strong class="bold">        - name: grafana-storage</strong></p><p class="source-code"><strong class="bold">          emptyDir: {}</strong></p><p class="source-code"><strong class="bold">        - name: grafana-datasources</strong></p><p class="source-code"><strong class="bold">          configMap:</strong></p><p class="source-code"><strong class="bold">              defaultMode: 420</strong></p><p class="source-code"><strong class="bold">              name: grafana-datasources</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Let’s <a id="_idIndexMarker936"/>create <a id="_idIndexMarker937"/>the service <a id="_idIndexMarker938"/>to access <a id="_idIndexMarker939"/>Grafana:<p class="source-code"><strong class="bold">$ cat &lt;&lt;EOF | kubectl apply -f -</strong></p><p class="source-code"><strong class="bold">apiVersion: v1</strong></p><p class="source-code"><strong class="bold">kind: Service</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  creationTimestamp: null</strong></p><p class="source-code"><strong class="bold">  labels:</strong></p><p class="source-code"><strong class="bold">    app: grafana</strong></p><p class="source-code"><strong class="bold">  name: grafana</strong></p><p class="source-code"><strong class="bold">  namespace: monitoring</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  ports:</strong></p><p class="source-code"><strong class="bold">  - port: 3000</strong></p><p class="source-code"><strong class="bold">    protocol: TCP</strong></p><p class="source-code"><strong class="bold">    targetPort: 3000</strong></p><p class="source-code"><strong class="bold">  selector:</strong></p><p class="source-code"><strong class="bold">    app: grafana</strong></p><p class="source-code"><strong class="bold">  type: ClusterIP</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Use <strong class="source-inline">port-forward</strong> to forward the previous Grafana service. This will help us connect to Grafana locally:<p class="source-code"><strong class="bold">$ kubectl port-forward svc/grafana 3000 -n monitoring --address 0.0.0.0</strong></p></li>
				<li>Go <a id="_idIndexMarker940"/>to <strong class="source-inline">http://localhost:3000</strong>. When <a id="_idIndexMarker941"/>the login <a id="_idIndexMarker942"/>page appears, use <a id="_idIndexMarker943"/>the username <a id="_idIndexMarker944"/><strong class="source-inline">admin</strong> and password <strong class="source-inline">admin</strong> and click on the <strong class="bold">Log in</strong> button. After <a id="_idIndexMarker945"/>that, you will be you for new credentials:</li>
			</ol>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B16945_12_09.jpg" alt="Figure 12.9 – Grafana login&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Grafana login</p>
			<ol>
				<li value="7">After <a id="_idIndexMarker946"/>logging in, you <a id="_idIndexMarker947"/>can check that <a id="_idIndexMarker948"/>your default data <a id="_idIndexMarker949"/>source is set to MySQL <a id="_idIndexMarker950"/>by going <a id="_idIndexMarker951"/>to <strong class="bold">Configuration</strong> | <strong class="bold">Data sources</strong>: </li>
			</ol>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B16945_12_10.jpg" alt="Figure 12.10 – Grafana configuration menu&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Grafana configuration menu</p>
			<p>You will see something similar to the following:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B16945_12_11.jpg" alt="Figure 12.11 – sensor_data default data source&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – sensor_data default data source</p>
			<ol>
				<li value="8">Now, click on <strong class="bold">Create</strong> | <strong class="bold">Dashboard</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B16945_12_12.jpg" alt="Figure 12.12 – Creating a dashboard "/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Creating a dashboard </p>
			<p>Then, click <strong class="bold">Add a new panel</strong>:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B16945_12_13.jpg" alt="Figure 12.13 – Grafana – The Add panel page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Grafana – The Add panel page</p>
			<ol>
				<li value="9">Then, configure <a id="_idIndexMarker952"/>the <a id="_idIndexMarker953"/>new dashboard <a id="_idIndexMarker954"/>with <a id="_idIndexMarker955"/>the following <a id="_idIndexMarker956"/>query <a id="_idIndexMarker957"/>and values:<p class="source-code"><strong class="bold">SELECT </strong></p><p class="source-code"><strong class="bold">  UNIX_TIMESTAMP(time) AS "time", </strong></p><p class="source-code"><strong class="bold">  temperature_c AS "Temperature(Celcius)", </strong></p><p class="source-code"><strong class="bold">  temperature_f AS "Temperature(Farenheit)", </strong></p><p class="source-code"><strong class="bold">  humidity AS "Humidity(%)" </strong></p><p class="source-code"><strong class="bold">FROM metric </strong></p><p class="source-code"><strong class="bold">WHERE </strong></p><p class="source-code"><strong class="bold">  $__timeFilter(time) </strong></p><p class="source-code"><strong class="bold">  and device=1 </strong></p><p class="source-code"><strong class="bold">ORDER BY time</strong></p></li>
			</ol>
			<p>You <a id="_idIndexMarker958"/>must <a id="_idIndexMarker959"/>edit the default query by clicking <a id="_idIndexMarker960"/>on the pencil <a id="_idIndexMarker961"/>icon. Then, copy <a id="_idIndexMarker962"/>the <a id="_idIndexMarker963"/>previous query there:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B16945_12_14.jpg" alt="Figure 12.14 – Editing the default MySQL query&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Editing the default MySQL query</p>
			<p>We have set <strong class="bold">Title</strong> to <strong class="bold">Device 1 Sensor Data</strong> here. The new dashboard will look like this:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B16945_12_15.jpg" alt="Figure 12.15 – The New dashboard/Edit Panel window&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – The New dashboard/Edit Panel window</p>
			<p>After <a id="_idIndexMarker964"/>changing the query <a id="_idIndexMarker965"/>if data is available, you <a id="_idIndexMarker966"/>will see a graph with three lines – one representing the temperature <a id="_idIndexMarker967"/>in Celsius, another representing the temperature in Fahrenheit, and <a id="_idIndexMarker968"/>the humidity as a percentage. Remember to set the dashboard to visualize the proper <a id="_idIndexMarker969"/>range of data – for example, to show data from the last 5 minutes – and refresh the dashboard every 5 seconds. </p>
			<ol>
				<li value="10">After that, save your dashboard by clicking on the <strong class="bold">Save</strong> button.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Check out <a href="B16945_11_Final_PG.xhtml#_idTextAnchor213"><em class="italic">Chapter 11</em></a>, <em class="italic">Monitoring the Edge with Prometheus and Grafana</em>, for more details about customizing your dashboard.</p>
			<ol>
				<li value="11">Finally, your <a id="_idIndexMarker970"/>dashboard <a id="_idIndexMarker971"/>will look <a id="_idIndexMarker972"/>as <a id="_idIndexMarker973"/>follows:</li>
			</ol>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B16945_12_16.jpg" alt="Figure 12.16 – ESP32 monitoring dashboard in Grafana&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.16 – ESP32 monitoring dashboard in Grafana</p>
			<p>At this <a id="_idIndexMarker974"/>point, you are <a id="_idIndexMarker975"/>visualizing the data from your Heltec devices to send and receive data. This device interacts with your far edge cluster. If you chose to deploy Grafana and MySQL on the cloud, this scenario is also interacting with the cloud layer. All these components interact with each other to do their job. Remember that this is a simple implementation that you can extend to your own. Now, let’s summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor243"/>Summary</h1>
			<p>In this chapter, we explored how to implement an edge computing system by using LoRa devices to send and receive sensor data. Finally, we implemented a dashboard using MySQL and Grafana. In this way, the LoRa wireless protocol represents a way to implement lower-cost systems that need to transmit information close to the edge. Therefore, LoRa is a common choice as a transmission protocol for edge devices and IoT applications. In the next chapter, we are going to use a GPS module to extend the range of communication and databases to implement geolocation applications. </p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor244"/>Questions</h1>
			<p>Here are a few questions to validate your new knowledge:</p>
			<ul>
				<li>What are the uses and advantages of using the LoRa wireless protocol?</li>
				<li>What is LoRaWAN?</li>
				<li>How can I use a Heltec ESP32 + LoRa device to send sensor data?</li>
				<li>How can I use Arduino IDE to program ESP32 devices?</li>
				<li>How can I create a simple gateway to send data coming from LoRaWAN to LAN?</li>
				<li>How can I use MySQL and Grafana to create reports?</li>
			</ul>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor245"/>Further reading</h1>
			<p>Please refer to the following references for more information on the topics covered in this chapter:</p>
			<ul>
				<li>What is the LoRaWAN specification?: <a href="https://lora-alliance.org/about-lorawan">https://lora-alliance.org/about-lorawan</a></li>
				<li>What is LoRa?: <a href="https://www.semtech.com/lora/what-is-lora">https://www.semtech.com/lora/what-is-lora</a></li>
				<li>LoRa applications: <a href="https://www.semtech.com/lora/lora-applications">https://www.semtech.com/lora/lora-applications</a></li>
				<li>LoRaWAN Frequency Plans: <a href="https://www.thethingsnetwork.org/docs/lorawan/frequency-plans">https://www.thethingsnetwork.org/docs/lorawan/frequency-plans</a>.</li>
				<li>CP210x USB to UART Bridge VCP Drivers: <a href="https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers">https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers</a></li>
				<li>Arduino download software: <a href="https://www.arduino.cc/en/software">https://www.arduino.cc/en/software</a></li>
				<li>HttpClient documentation and examples: <a href="https://github.com/amcewen/HttpClient">https://github.com/amcewen/HttpClient</a></li>
				<li>All fixes to run ESP32/Arduino on Arduino IDE and Platform I/O using MacOS Big Sur and Newer: <a href="https://www.youtube.com/watch?v=zkyoghpT8_U">https://www.youtube.com/watch?v=zkyoghpT8_U</a></li>
				<li>ESP32 + LoRa Heltec documentation: <a href="https://heltec-automation-docs.readthedocs.io/en/latest/esp32/index.html">https://heltec-automation-docs.readthedocs.io/en/latest/esp32/index.html</a></li>
				<li>Heltec Automation Docs Page: <a href="https://heltec-automation-docs.readthedocs.io/en/latest">https://heltec-automation-docs.readthedocs.io/en/latest</a></li>
				<li>Heltec ESP32 LoRaWAN library and examples: <a href="https://github.com/HelTecAutomation/ESP32_LoRaWAN">https://github.com/HelTecAutomation/ESP32_LoRaWAN</a></li>
				<li>WIFI LoRa 32(V2) Pinout Diagram: <a href="http://resource.heltec.cn/download/WiFi_LoRa_32/WIFI_LoRa_32_V2.pdf">http://resource.heltec.cn/download/WiFi_LoRa_32/WIFI_LoRa_32_V2.pdf</a></li>
				<li>Provisioning Grafana: <a href="https://github.com/grafana/grafana/blob/main/docs/sources/administration/provisioning/index.md">https://github.com/grafana/grafana/blob/main/docs/sources/administration/provisioning/index.md</a></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer136">
			</div>
		</div>
	</body></html>