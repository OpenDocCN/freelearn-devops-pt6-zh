<html><head></head><body>
		<div id="_idContainer105">
			<h1 id="_idParaDest-133" class="chapter-number"><a id="_idTextAnchor151"/><st c="0">6</st></h1>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor152"/><st c="2">Architecting a Content Translation Pipeline</st></h1>
			<p><st c="45">In this chapter, you are going to have your first contact with </st><strong class="bold"><st c="109">Continuous Integration and Continuous Delivery</st></strong><st c="155"> (</st><strong class="bold"><st c="157">CI/CD</st></strong><st c="162">). </st><st c="166">You are going to build an event website that automatically </st><a id="_idIndexMarker356"/><st c="225">renders in your users’ preferred language but deploys it in an automated fashion unlike you have done </st><span class="No-Break"><st c="327">so far.</st></span></p>
			<p><st c="334">Just like in the previous chapter, you are also going to use AWS machine learning services, Python, </st><span class="No-Break"><st c="435">and Terraform.</st></span></p>
			<p><st c="449">In summary, this chapter covers the following </st><span class="No-Break"><st c="496">main topics:</st></span></p>
			<ul>
				<li><st c="508">What you are going to build – a multilingual web application using a </st><span class="No-Break"><st c="578">CICD pipeline</st></span></li>
				<li><st c="591">How you are going to build it – using S3, CloudFront, Lambda@Edge, Translate, and </st><span class="No-Break"><st c="674">CICD tooling</st></span></li>
				<li><st c="686">Building it – using Terraform </st><span class="No-Break"><st c="717">and Python</st></span></li>
				<li><st c="727">How to improve the application – adopting CICD for infrastructure and supporting </st><span class="No-Break"><st c="809">more languages</st></span></li>
			</ul>
			<p><st c="823">By the end of this chapter, you will have hands-on experience with AWS CI/CD services and be able to build your own </st><span class="No-Break"><st c="940">application pipelines.</st></span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor153"/><st c="962">Technical requirements</st></h1>
			<p><st c="985">This chapter has a dedicated folder in the GitHub repository of this book, where you will find the code snippets required to follow </st><span class="No-Break"><st c="1118">along: </st></span><a href="https://github.com/PacktPublishing/AWS-Cloud-Projects/tree/main/chapter6/code"><span class="No-Break"><st c="1125">https://github.com/PacktPublishing/AWS-Cloud-Projects/tree/main/chapter6/code</st></span></a><span class="No-Break"><st c="1202">.</st></span></p>
			<p><st c="1203">To follow along, you will need access to an </st><span class="No-Break"><st c="1248">AWS account.</st></span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor154"/><st c="1260">Scenario</st></h1>
			<p><st c="1269">Your company </st><a id="_idIndexMarker357"/><st c="1283">hosts tech events, such as conferences and webinars, in North America. </st><st c="1354">Your marketing colleagues publicize these events, individually, on various social media platforms. </st><st c="1453">However, they think it would be beneficial to have a single page where people can find all the </st><span class="No-Break"><st c="1548">upcoming events.</st></span></p>
			<p><st c="1564">You are tasked to</st><a id="_idIndexMarker358"/><st c="1582"> create a </st><strong class="bold"><st c="1592">proof of concept</st></strong><st c="1608"> for this functionality as a </st><span class="No-Break"><st c="1637">web application.</st></span></p>
			<p><st c="1653">In a conversation with a senior leader, she mentions that accessibility is a company tenet. </st><st c="1746">She also mentions that although all your company events are streamed in multiple languages, they are always only advertised in English. </st><st c="1882">This is reflected in their </st><span class="No-Break"><st c="1909">attendance numbers.</st></span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor155"/><st c="1928">Requirements</st></h2>
			<p><st c="1941">You need to </st><a id="_idIndexMarker359"/><st c="1954">build an application that shows all the upcoming company events and takes the user to the event’s registration page. </st><st c="2071">Language accessibility is important; the application should dynamically render in the user’s </st><span class="No-Break"><st c="2164">preferred language.</st></span></p>
			<p><st c="2183">Since events keep happening, and new ones are scheduled, you need a mechanism to </st><span class="No-Break"><st c="2265">make changes.</st></span></p>
			<p><st c="2278">Cloud costs at the company are at an all-time high. </st><st c="2331">This application should be as low-cost as possible while maintaining high availability. </st><st c="2419">If people try to access it, and it is down, that will reflect in lower event attendance. </st><st c="2508">However, you do not want to contribute to even higher </st><span class="No-Break"><st c="2562">cloud costs.</st></span></p>
			<p><st c="2574">You can format the requirements into various categories: functional, non-functional, </st><span class="No-Break"><st c="2660">and technical.</st></span></p>
			<h3><st c="2674">Functional requirements</st></h3>
			<p><st c="2698">Functional requirements define the specific features, functionalities, and capabilities that the solution must provide. </st><st c="2819">In this case, those are </st><span class="No-Break"><st c="2843">as follows:</st></span></p>
			<ul>
				<li><st c="2854">Display company </st><span class="No-Break"><st c="2871">future events</st></span></li>
				<li><st c="2884">Ability to create, edit, and </st><span class="No-Break"><st c="2914">delete events</st></span></li>
				<li><st c="2927">Ability to roll back to </st><span class="No-Break"><st c="2952">previous versions</st></span></li>
				<li><st c="2969">Support for images </st><span class="No-Break"><st c="2989">and text</st></span></li>
				<li><st c="2997">Interfaces must adapt to users’ </st><span class="No-Break"><st c="3030">preferred languages</st></span></li>
			</ul>
			<h3><st c="3049">Non-functional requirements</st></h3>
			<p><st c="3077">Non-functional requirements define the qualitative attributes that the solution must provide. </st><st c="3172">In this case, those are </st><span class="No-Break"><st c="3196">as follows:</st></span></p>
			<ul>
				<li><span class="No-Break"><st c="3207">Low cost</st></span></li>
				<li><st c="3216">Low latency in </st><span class="No-Break"><st c="3232">North America</st></span></li>
				<li><span class="No-Break"><st c="3245">High availability</st></span></li>
				<li><st c="3263">Ease </st><span class="No-Break"><st c="3269">of maintainability</st></span></li>
			</ul>
			<h3><st c="3287">Technical requirements</st></h3>
			<p><st c="3310">Technical requirements define specific technologies, programming languages, frameworks, and tools that the solution must use or integrate with. </st><st c="3455">In this case, those are </st><span class="No-Break"><st c="3479">as follows:</st></span></p>
			<ul>
				<li><st c="3490">Must integrate with </st><span class="No-Break"><st c="3511">Terraform codebase</st></span></li>
				<li><st c="3529">Must use a</st><a id="_idIndexMarker360"/><st c="3540">n automated mechanism for </st><span class="No-Break"><st c="3567">content translation</st></span></li>
			</ul>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor156"/><st c="3586">Architecture patterns</st></h2>
			<p><st c="3608">Navigate to the </st><a id="_idIndexMarker361"/><st c="3625">AWS Architecture Center and search for </st><strong class="source-inline"><st c="3664">content localization</st></strong><st c="3684">. You will find </st><em class="italic"><st c="3700">Guidance for Automated Language Translations on AWS</st></em><st c="3751"> and </st><em class="italic"><st c="3756">Content Localization on AWS</st></em> <span class="No-Break"><st c="3783">reference architecture.</st></span></p>
			<p><st c="3807">The reference architecture is for a solution that creates multi-language subtitles, while the guidance is focused on translation product information that sits in databases. </st><st c="3981">Although these are not exact matches, you can see a pattern: both take advantage of Amazon Translate for the actual </st><span class="No-Break"><st c="4097">content translation.</st></span></p>
			<p><st c="4117">Before moving on, search for </st><strong class="source-inline"><st c="4147">CICD</st></strong><st c="4151">.</st><a id="_idTextAnchor157"/><st c="4152"> This returns plenty of results. </st><st c="4185">Explore them. </st><st c="4199">A particularly interesting</st><a id="_idIndexMarker362"/><st c="4225"> one is </st><strong class="bold"><st c="4233">CI/CD for .NET Applications on AWS Fargate</st></strong><st c="4275">. It uses CodeCommit as a code repository, CodeBuild to build the artifacts, and finally, ECS to deploy them. </st><st c="4385">All these are orchestrated as </st><span class="No-Break"><st c="4415">CodePipeline stages.</st></span></p>
			<p><st c="4435">At the time of writing this, CodeCommit was deprecated </st><span class="No-Break"><st c="4491">by AWS.</st></span></p>
			<p><st c="4498">None of the </st><a id="_idIndexMarker363"/><st c="4511">architectures are an exact match to your requirements. </st><st c="4566">You must design </st><span class="No-Break"><st c="4582">it yourself.</st></span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor158"/><st c="4594">Architecture</st></h1>
			<p><st c="4607">There are separate</st><a id="_idIndexMarker364"/><st c="4626"> ways to render a webpage in the users’ preferred languages. </st><st c="4687">You can use specific framework tools, such as </st><strong class="source-inline"><st c="4733">i18n</st></strong><st c="4737"> in React, or infrastructure redirection, such </st><span class="No-Break"><st c="4784">as </st></span><span class="No-Break"><strong class="source-inline"><st c="4787">Lambda@Edge</st></strong></span><span class="No-Break"><st c="4798">.</st></span></p>
			<p class="callout-heading"><st c="4799">Important note</st></p>
			<p class="callout"><st c="4814">This is a practical AWS book, not a specific web framework one, so this chapter implements the infrastructure </st><span class="No-Break"><st c="4925">redirection method.</st></span></p>
			<p><st c="4944">However, how do you identify a user’s preferred language? </st><st c="5003">You can add a button at the top for the user to choose the language. </st><st c="5072">This is a common approach. </st><st c="5099">However, you can do better. </st><st c="5127">You will make it automatically detect the users’ preferences based on </st><span class="No-Break"><st c="5197">request properties.</st></span></p>
			<p><st c="5216">After deciding how you want to implement the language rendering, and going back to the solution requirements, you will notice that they are similar to </st><em class="italic"><st c="5368">Chapters 2</st></em><st c="5378"> and </st><em class="italic"><st c="5383">3</st></em><st c="5384">. However, since this is a proof of concept, and you want to minimize time to market, you decide to re-use the static architecture, with a configuration that automatically detects the language property and sends the appropriate resources. </st><st c="5623">Using AWS services, the architecture looks like </st><span class="No-Break"><em class="italic"><st c="5671">Figure 6</st></em></span><em class="italic"><st c="5679">.1</st></em><st c="5681">. Use two or more S3 buckets to store your application pages (in this case, English and Spanish), and CloudFront with </st><strong class="source-inline"><st c="5799">Lambda@Edge</st></strong><st c="5810"> to inspect users’ requests and fetch specific </st><span class="No-Break"><st c="5857">language assets.</st></span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B22051_06_1.jpg" alt="Figure 6.1 – Multilingual static website architecture"/><st c="5873"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5956">Figure 6.1 – Multilingual static website architecture</st></p>
			<p><st c="6009">This architecture works, but it does not fulfill all requirements, such as ease of maintainability or automatic translation. </st><st c="6135">You can add, alter, and delete events; however, in </st><a href="B22051_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic"><st c="6186">Chapter 2</st></em></span></a><st c="6195">, it was a single bucket. </st><st c="6221">In this new architecture, every time you want to make a change, you must replicate it to all the buckets. </st><st c="6327">You are also missing an automated mechanism to create translated content. </st><st c="6401">Although you can use S3 object versioning to support rollbacks, it is not an ideal mechanism, especially when you must keep your content in sync in multiple </st><span class="No-Break"><st c="6558">different buckets.</st></span></p>
			<p><st c="6576">As you previously </st><a id="_idIndexMarker365"/><st c="6595">saw in the Architecture Center, CI/CD can help with building and pushing changes to applications. </st><st c="6693">In this case, you could store your web application files in a code repository and use a CICD pipeline to orchestrate the translation and synchronization of your content to multiple buckets. </st><span class="No-Break"><em class="italic"><st c="6883">Figure 6</st></em></span><em class="italic"><st c="6891">.2</st></em><st c="6893"> shows what it looks like using AWS services. </st><st c="6939">The application administrator, Admin, stores the application files in English in a GitHub repository. </st><st c="7041">Changes to the repository trigger a CodePipeline that interacts with Amazon Translate to generate translated versions of the files and deploys them in their respective buckets. </st><st c="7218">The GitHub repository is depicted inside the AWS cloud, but it lives outside. </st><st c="7296">This was just for ease </st><span class="No-Break"><st c="7319">of representation.</st></span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B22051_06_2.jpg" alt="Figure 6.2 – Multilingual website with a content translation pipeline architecture"/><st c="7337"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7463">Figure 6.2 – Multilingual website with a content translation pipeline architecture</st></p>
			<p><st c="7545">Using this architecture, the</st><a id="_idIndexMarker366"/><st c="7574"> administrator only makes changes in a single place, in a single language. </st><st c="7649">Although the example shows Spanish, modifications can be propagated to any number of </st><span class="No-Break"><st c="7734">configured languages.</st></span></p>
			<p><st c="7755">AWS CI/CD services are one of many options. </st><st c="7800">You can also implement this architecture using 3rd party CI/CD tools. </st><st c="7870">Examples </st><a id="_idIndexMarker367"/><st c="7879">include Jenkins, GitHub Actions, or </st><span class="No-Break"><st c="7915">GitLab CI/CD.</st></span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor159"/><st c="7928">AWS services</st></h1>
			<p><st c="7941">This architecture </st><a id="_idIndexMarker368"/><st c="7960">uses four new services. </st><st c="7984">In this section, you will learn what these new services do, and why they address </st><span class="No-Break"><st c="8065">your requirements.</st></span></p>
			<p><st c="8083">Other services, such as S3 or CloudFront, were already deployed previously. </st><st c="8160">Refer to the previous chapters for an in-depth explanation of </st><span class="No-Break"><st c="8222">their functionality.</st></span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor160"/><st c="8242">Lambda@Edge</st></h2>
			<p><st c="8254">You already learned abou</st><a id="_idIndexMarker369"/><st c="8279">t Lambda</st><a id="_idIndexMarker370"/><st c="8288"> in other chapters, but Lambda@Edge is different. </st><st c="8338">Instead of running in an AWS region, these special lambdas run at AWS edge locations when you associate them with </st><span class="No-Break"><st c="8452">CloudFront distributions.</st></span></p>
			<p><st c="8477">The main idea behind Lambda@Edge</st><a id="_idTextAnchor161"/><st c="8510"> is to bring compute capabilities closer to your users, enabling operations such as modifying requests or responses at the edge, exactly what you want </st><span class="No-Break"><st c="8661">to do.</st></span></p>
			<p><st c="8667">Lambda@Edge functions are tightly integrated with CloudFront. </st><st c="8730">The functions can be triggered in response to four types </st><span class="No-Break"><st c="8787">of events:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="8797">Viewer request</st></strong><st c="8812">: This event is </st><a id="_idIndexMarker371"/><st c="8829">triggered when a viewer requests content from your CloudFront distribution. </st><st c="8905">A Lambda@Edge function at this event can modify the request headers or the requested object path before it is sent to </st><span class="No-Break"><st c="9023">the origin.</st></span></li>
				<li><strong class="bold"><st c="9034">Origin request</st></strong><st c="9049">: This event is triggered when CloudFront needs to request content from your origin. </st><st c="9135">A Lambda@Edge function at this event can modify the request headers or the requested object path before it is sent to </st><span class="No-Break"><st c="9253">the origin.</st></span></li>
				<li><strong class="bold"><st c="9264">Origin response</st></strong><st c="9280">: This event is triggered when CloudFront receives the response from your origin server. </st><st c="9370">You can use a Lambda@Edge function at this event to inspect and modify the origin’s response</st><a id="_idTextAnchor162"/><st c="9462"> before it is cached and returned to </st><span class="No-Break"><st c="9499">the viewer.</st></span></li>
				<li><strong class="bold"><st c="9510">Viewer response</st></strong><st c="9526">: This event is triggered before CloudFront returns the requested content to the viewer. </st><st c="9616">A Lambda@Edge function at this event can modify the CloudFront </st><a id="_idIndexMarker372"/><st c="9679">response headers or the response body before it is sent to </st><span class="No-Break"><st c="9738">the viewer.</st></span></li>
			</ul>
			<p><st c="9749">In your case, you want to change the object path based on users’ requests. </st><st c="9825">The Origin Request </st><span class="No-Break"><st c="9844">trigger fits.</st></span></p>
			<p><st c="9857">These special lambdas are used in many other use cases such as adding HTTP security headers, blocking unwanted requests, redirecting to different pages, A/B testing, </st><span class="No-Break"><st c="10024">and others.</st></span></p>
			<p><st c="10035">There is no free tier, but</st><a id="_idIndexMarker373"/><st c="10062"> these lambdas are </st><a id="_idIndexMarker374"/><st c="10081">priced at $0.0000006 per request plus $0.00005001 for every GB-second. </st><st c="10152">You can see the details on the AWS website </st><span class="No-Break"><st c="10195">at </st></span><a href="https://aws.amazon.com/lambda/pricing/"><span class="No-Break"><st c="10198">https://aws.amazon.com/lambda/pricing/</st></span></a><span class="No-Break"><st c="10236">.</st></span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor163"/><st c="10237">Amazon Translate</st></h2>
			<p><st c="10254">You need an </st><a id="_idIndexMarker375"/><st c="10267">automated </st><a id="_idIndexMarker376"/><st c="10277">translation mechanism. </st><st c="10300">Amazon Translate is that and more. </st><st c="10335">It is a managed API-based service that supports 75 different languages. </st><st c="10407">It uses machine learning to provide high-quality translations on-demand, </st><span class="No-Break"><st c="10480">meaning pay-per-translation.</st></span></p>
			<p><st c="10508">It supports both text and document translation. </st><st c="10557">In your case, you will send HTML documents. </st><st c="10601">However, depending on the web application framework, you might need to send text excerpts. </st><st c="10692">If you are using React with i18n, you will need to create </st><span class="No-Break"><strong class="source-inline"><st c="10750">translation.json</st></strong></span><span class="No-Break"><st c="10766"> files.</st></span></p>
			<p><st c="10773">There are other third-party translation services. </st><st c="10824">However, Translate is well-integrated into the AWS ecosyste</st><a id="_idTextAnchor164"/><st c="10883">m. </st><st c="10887">You can use IAM roles with temporary credentials for access instead of usernames and passwords, and your data does not have to travel through </st><span class="No-Break"><st c="11029">the internet.</st></span></p>
			<p><st c="11042">If you are a new user, it also includes a </st><span class="No-Break"><st c="11085">free tier.</st></span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor165"/><st c="11095">AWS CodePipeline and AWS CodeBuild</st></h2>
			<p><st c="11130">You need </st><a id="_idIndexMarker377"/><st c="11140">something to</st><a id="_idIndexMarker378"/><st c="11152"> tie all your</st><a id="_idIndexMarker379"/><st c="11165"> components</st><a id="_idIndexMarker380"/><st c="11176"> together and orchestrate </st><span class="No-Break"><st c="11202">the steps.</st></span></p>
			<p><st c="11212">AWS CodePipeline is a fully </st><a id="_idIndexMarker381"/><st c="11241">managed </st><strong class="bold"><st c="11249">Continuous Delivery/Deployment</st></strong><st c="11279"> (</st><strong class="bold"><st c="11281">CD</st></strong><st c="11283">) service that helps you automate your application and infrastructure updates. </st><st c="11363">However, before diving into CodePipeline benefits and how it ties to your requirements, what </st><span class="No-Break"><st c="11456">is CI/CD?</st></span></p>
			<p><st c="11465">CI/CD is a software</st><a id="_idIndexMarker382"/><st c="11485"> development practice that aims to automate and streamline the entire process of building, testing, and </st><span class="No-Break"><st c="11589">deploying applications.</st></span></p>
			<p><strong class="bold"><st c="11612">Continuous Integration</st></strong><st c="11635"> (</st><strong class="bold"><st c="11637">CI</st></strong><st c="11639">) refers </st><a id="_idIndexMarker383"/><st c="11649">to the practice of frequently merging code changes into a central repository. </st><st c="11727">Whenever developers push code changes, the CI process automatically builds the application, runs unit tests, and checks for any </st><span class="No-Break"><st c="11855">integration issues.</st></span></p>
			<p><st c="11874">CD is the next step after CI. </st><st c="11905">CD focuses on automating the entire software release process, including building, testing, and packaging an application. </st><st c="12026">The goal is to ensure that the application is always in a releasable state and can be deployed quickly and safely with minimal manual intervention. </st><st c="12174">Continuous deployment is an extension of continuous delivery. </st><st c="12236">In this practice, every code change that passes the automated tests and checks is automatically deployed without manual intervention. </st><st c="12370">In your project, you will use </st><span class="No-Break"><st c="12400">continuous deployment.</st></span></p>
			<p><st c="12422">A typical CI/CD process involves the </st><span class="No-Break"><st c="12460">following components:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="12481">Code repository</st></strong><st c="12497">: This is a </st><a id="_idIndexMarker384"/><st c="12510">place where developers commit code changes, in your </st><span class="No-Break"><st c="12562">case GitHub.</st></span></li>
				<li><strong class="bold"><st c="12574">CI tooling</st></strong><st c="12585">: These are tools that compile source code, run tests, and produce ready-to-deploy software packages. </st><st c="12688">Popular CD tools include TravisCI or </st><span class="No-Break"><st c="12725">AWS CodeBuild.</st></span></li>
				<li><strong class="bold"><st c="12739">Continuous delivery tooling</st></strong><st c="12767">: These are tools that automatically detect code changes, retrieve the latest version from your repository, and execute a series of steps. </st><st c="12907">Popular CD tools include Jenkins, GitHub Actions, </st><span class="No-Break"><st c="12957">AWS CodePipeline.</st></span></li>
				<li><strong class="bold"><st c="12974">Continuous deployment tooling</st></strong><st c="13004">: This is a tool that automates the deployment of an application after it is built and tested, they implement popular deployment strategies such as blue-green, canary, and others. </st><st c="13185">Popular tools include AWS</st><a id="_idIndexMarker385"/><st c="13210"> CodeDeploy </st><span class="No-Break"><st c="13222">or Ansible.</st></span></li>
			</ul>
			<p><st c="13233">CI/CD practices aim to deliver software faster, more reliably, and with higher quality by automating the entire process from code commit to deployment. </st><st c="13386">They eliminate manual effort, reduce the risk of human errors, and enable teams to release updates more frequently and consistently. </st><st c="13519">In your case, it enables you to have a single code repository in English and deploy to multiple buckets in </st><span class="No-Break"><st c="13626">multiple languages.</st></span></p>
			<p><st c="13645">CodePipeline is a viable choice for continuous delivery. </st><st c="13703">It has a free tier, integrates natively within the AWS ecosystem, has an easy-to-understand syntax, and is an </st><span class="No-Break"><st c="13813">AWS project.</st></span></p>
			<p><st c="13825">Since your deployment targets are S3 buckets, you will not need a traditional continuous deployment tool. </st><st c="13932">You are doing continuous deployment, meaning that if you make a change in your code repository, that change will be pushed directly into your web application. </st><st c="14091">However, you will be using a continuous integration tool, CodeBuild, to </st><span class="No-Break"><st c="14163">achieve it.</st></span></p>
			<p><st c="14174">Are you confused? </st><st c="14193">CodeBuild is a fully managed continuous integration service that compiles source code, runs tests, and produces packages. </st><st c="14315">In your case, a deployment is copying files to S3 buckets. </st><st c="14374">CodeBuild can do that. </st><st c="14397">CodeBuild reads and executes the instructions from a build specification file, </st><strong class="source-inline"><st c="14476">buildspec.yml</st></strong><st c="14489">, in a configurable environment, for example, a Linux virtual machine or a </st><span class="No-Break"><st c="14564">Docker container.</st></span></p>
			<p><st c="14581">Traditional continuous deployment tools are aimed at applicatio</st><a id="_idTextAnchor166"/><st c="14645">ns that require traditional compute environments such as virtual machines. </st><st c="14721">If you were implementing this web application with an API </st><a id="_idIndexMarker386"/><st c="14779">backend as you did in </st><a href="B22051_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic"><st c="14801">Chapter 3</st></em></span></a><st c="14810">, you would take advantage </st><a id="_idIndexMarker387"/><st c="14837">of</st><a id="_idIndexMarker388"/> <span class="No-Break"><st c="14839">these</st></span><span class="No-Break"><a id="_idIndexMarker389"/></span><span class="No-Break"><st c="14845"> tools.</st></span></p>
			<p><st c="14852">In the </st><em class="italic"><st c="14860">Building the CI/CD pipeline</st></em><st c="14887"> section of this chapter, you will see each of these tools in more detail and interact </st><span class="No-Break"><st c="14974">with them.</st></span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor167"/><st c="14984">Coding the solution</st></h1>
			<p><st c="15004">This solution has two parts: the web application and the CI/CD pipeline. </st><st c="15078">You will build </st><span class="No-Break"><st c="15093">them sequentially.</st></span></p>
			<p><st c="15111">During this chapter, you are going to deploy your resources to the </st><strong class="bold"><st c="15179">N. </st></strong><span class="No-Break"><strong class="bold"><st c="15182">Virginia</st></strong></span><span class="No-Break"><st c="15190"> region.</st></span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor168"/><st c="15198">Building the web application</st></h2>
			<p><st c="15227">In this section, you</st><a id="_idIndexMarker390"/><st c="15248"> will build the architecture discussed in </st><span class="No-Break"><em class="italic"><st c="15290">Figure 6</st></em></span><em class="italic"><st c="15298">.1</st></em> <span class="No-Break"><st c="15300">using Terraform.</st></span></p>
			<p><st c="15317">If you have not yet done so, clone the book’s repository from </st><a href="https://github.com/packtpublishing/aws-cloud-projects"><st c="15380">https://github.com/packtpublishing/aws-cloud-projects</st></a><st c="15433">. Navigate to the </st><span class="No-Break"><strong class="source-inline"><st c="15451">chapter6/code</st></strong></span><span class="No-Break"><st c="15464"> folder.</st></span></p>
			<p><st c="15472">In this folder, you will find multiple files </st><span class="No-Break"><st c="15518">and folders:</st></span></p>
			<pre class="console"><st c="15530">
.
├── app
│   ├── index.css
│   ├── index.html
│   └── translate.py
├── buildspec.yml
├── ch2-files
│   ├── index.css
│   └── index.html
├── cicd.tf
├── dev.tfvars
├── infrastructure.tf
├── lambda
│   ├── lambda.py
│   └── lambda.zip
└── variables.tf</st></pre>			<p><st c="15766">Open </st><strong class="source-inline"><st c="15772">infrastructure.tf</st></strong><st c="15789"> in your favorite code editor and examine the code carefully. </st><st c="15851">This code creates two S3 buckets with </st><a href="B22051_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic"><st c="15889">Chapter 2</st></em></span></a><st c="15898">’s HTML and CSS files inside, a CloudFront distribution that uses OAC to connect to S3, a Lambda@Edge function that triggers on origin requests, and roles with permissions for all these components’ interactions </st><span class="No-Break"><st c="16110">to work.</st></span></p>
			<p><st c="16118">There are snippets worth highlighting, for example, how the bucket names are </st><span class="No-Break"><st c="16196">input variables:</st></span></p>
			<pre class="source-code"><st c="16212">
resource "aws_s3_bucket" "english-bucket" {
  bucket = </st><strong class="bold"><st c="16266">var.en_bucket_name</st></strong><st c="16284">
}
resource "aws_s3_bucket" "spanish-bucket" {
  bucket = </st><strong class="bold"><st c="16340">var.es_bucket_name</st></strong><st c="16358">
}</st></pre>			<p><st c="16360">You must define</st><a id="_idIndexMarker391"/><st c="16375"> these variables yourself in </st><strong class="source-inline"><st c="16404">dev.tfvars</st></strong><st c="16414">. They are pre-populated. </st><st c="16440">However, you must change them to different values because bucket names are unique. </st><st c="16523">You will refer to this file </st><span class="No-Break"><st c="16551">at runtime:</st></span></p>
			<pre class="source-code"><st c="16562">
en_bucket_name = "my-english-assets-bucket"
es_bucket_name = "my-spanish-assets-bucket"</st></pre>			<p><st c="16650">It is also worth highlighting some of your CloudFront variables: the </st><strong class="source-inline"><st c="16720">PriceClass_100</st></strong><st c="16734"> price class, the forwarded headers, and the low TTL </st><span class="No-Break"><st c="16787">cache values:</st></span></p>
			<pre class="source-code"><st c="16800">
resource "aws_cloudfront_distribution" "s3_distribution" {
  origin {
    </st><a id="_idTextAnchor169"/><st c="16869">domain_name    </st><a id="_idTextAnchor170"/><st c="16881">          = aws_s3_bucket.english-bucket.bucket_regional_domain_name
    origin_access_control_id = aws_cloudfront_origin_access_control.oac.</st><a id="_idTextAnchor171"/><st c="17008">id
    origin_id                = local.s3_origin_id
  }
  enabled             = true
  default_root_object = "index.html"
  default_cache_behavior {
    allowed_methods  = ["DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT"]
    cached_methods   = ["GET</st><a id="_idTextAnchor172"/><st c="17221">", "HEAD"]
    target_origin_id = local.s3_origin_id
</st><strong class="bold"><st c="17271">    forwarded_values {</st></strong>
<strong class="bold"><st c="17289">      query_string = false</st></strong>
<strong class="bold"><st c="17310">      headers      = ["Accept-Language"]</st></strong>
<strong class="bold"><st c="17340">      cookies {</st></strong>
<strong class="bold"><st c="17350">        forward = "none"</st></strong>
<strong class="bold"><st c="17367">      }</st></strong>
<strong class="bold"><st c="17369">    }</st></strong><st c="17371">
    lambda_function_association {
      event_type = "origin-request"
      lambda_arn = aws_lambda_function.terraform_lambda_func.qualified_arn
    }
    viewer_protocol_policy = "allow-all"
    </st><strong class="bold"><st c="17540">min_ttl                = 0</st></strong>
<strong class="bold"><st c="17551">    default_ttl            = 1</st></strong>
<strong class="bold"><st c="17567">    max_ttl                = 1</st></strong><st c="17579">
  }
  </st><strong class="bold"><st c="17582">price_class = "PriceClass_100"</st></strong><st c="17612">
  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }
  viewer_certificate {
    cloudfront_default_certificate = true
  }
}</st></pre>			<p><st c="17738">Of the requirements, your company only expects viewers in North America. </st><st c="17812">CloudFront has different pricing strategies, whereby it does not distribute your content to all edge locations. </st><st c="17924">This price class distributes your content only in North American and European edge locations, making data transfers cheaper. </st><st c="18049">This does not mean users from other locations cannot access your content, it just means it will travel through the internet instead of the backbone </st><span class="No-Break"><st c="18197">AWS network.</st></span></p>
			<p><st c="18209">The cache is lowered to </st><a id="_idIndexMarker392"/><st c="18234">a time to live between 0 and 1. </st><st c="18266">It makes CloudFront fetch the assets from the origin after one second. </st><st c="18337">This configuration helps you test and troubleshoot the solution without having to wait for cache timeouts. </st><st c="18444">You can increase </st><span class="No-Break"><st c="18461">it afterward.</st></span></p>
			<p><st c="18474">Lastly, there’s the </st><strong class="bold"><st c="18495">Accept-Language</st></strong><st c="18510"> forwarded header. </st><st c="18529">There are separate ways to implement what a user’s preferred language is. </st><st c="18603">For example, you can use the user’s IP address to infer their country, or CloudFront-added headers such as </st><strong class="bold"><st c="18710">CloudFront-Viewer-City</st></strong><st c="18732"> or </st><strong class="bold"><st c="18736">CloudFront-Viewer-Country-Name</st></strong><st c="18766">. In this project, you will use the Accept-Language header because you consider that even though a person might be physically located in a country, they may not be able to speak that country’s language. </st><st c="18969">This happens often </st><span class="No-Break"><st c="18988">while traveling.</st></span></p>
			<p><st c="19004">The Accept-Language header indicates users’ language preferences. </st><st c="19071">It is a list. </st><st c="19085">Browsers set this value according to users’ settings. </st><st c="19139">In Chrome, the setting is under the </st><strong class="bold"><st c="19175">Languages</st></strong><st c="19184"> section, as shown in </st><span class="No-Break"><em class="italic"><st c="19206">Figure 6</st></em></span><span class="No-Break"><em class="italic"><st c="19214">.3</st></em></span><span class="No-Break"><st c="19216">.</st></span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B22051_06_3.jpg" alt="Figure 6.3 – Google Chrome Languages settings UI"/><st c="19217"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19779">Figure 6.3 – Google Chrome Languages settings UI</st></p>
			<p><st c="19827">In CloudFront, you must forward this header so it can be evaluated by the </st><span class="No-Break"><st c="19902">Lambda@Edge function.</st></span></p>
			<p><st c="19923">Move on to the Python code, </st><strong class="source-inline"><st c="19952">lambda.py</st></strong><st c="19961">, inside the </st><strong class="source-inline"><st c="19974">lambda</st></strong><st c="19980"> folder. </st><st c="19989">This code will power your Lambda@Edge function. </st><st c="20037">Although short, the code in this function parses the</st><em class="italic"> </em><st c="20089">Accept-Language header and checks whether the first value on the list starts with </st><strong class="bold"><st c="20172">es</st></strong><st c="20174">. If it does, it changes the </st><a id="_idIndexMarker393"/><st c="20203">origin to the bucket where the Spanish versio</st><a id="_idTextAnchor173"/><st c="20248">n of the </st><span class="No-Break"><st c="20258">assets is:</st></span></p>
			<pre class="source-code"><st c="20268">
import re
def handler(event, contex</st><a id="_idTextAnchor174"/><st c="20304">t):
  </st><a id="_idTextAnchor175"/><st c="20309">  request = event['Records'][0]['cf']['request']
  </st><a id="_idTextAnchor176"/><st c="20356">  viewerCountry = request['headers'].get('accept-language')
    if viewerCountry:
        countryCode = viewerCountry[0]['value']
        </st><strong class="bold"><st c="20472">if re.match(r'^es', countryCode):</st></strong><strong class="bold"><st c="20505">domainName = "my-spanish-assets-bucket.s3.us-east-1.amazona</st><a id="_idTextAnchor177"/><st c="20565">ws.com</st><a id="_idTextAnchor178"/><st c="20572">"</st></strong><st c="20574">
            request['origin']['s3']['domainName'] = doma</st><a id="_idTextAnchor179"/><st c="20619">inName
            request['headers']['host'] = [{'key': 'host', 'value': domainName}]
    return request</st></pre>			<p><st c="20709">You need to alter this code with your own </st><strong class="bold"><st c="20752">domainName</st></strong><st c="20762"> parameter. </st><st c="20774">This is the URL for your Spanish assets S3 bucket. </st><st c="20825">This code uses the first value on the list because the Accept-Language header is ordered by </st><span class="No-Break"><st c="20917">users’ preferences.</st></span></p>
			<p><st c="20936">Terraform reads all </st><strong class="source-inline"><st c="20957">.tf</st></strong><st c="20960"> files in a directory and applies the required changes to your infrastructure. </st><st c="21039">You could run these Terraform modules individually by refactoring the code and moving it to a separate directory. </st><st c="21153">However, it is a best practice to maintain all project assets in a single</st><a id="_idIndexMarker394"/><st c="21226"> Terraform state file. </st><st c="21249">For now, do not run the Terraform </st><strong class="source-inline"><st c="21283">apply</st></strong><st c="21288"> command. </st><st c="21298">You will do it in the </st><span class="No-Break"><st c="21320">next section.</st></span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor180"/><st c="21333">Building the CI/CD pipeline</st></h2>
			<p><st c="21361">In the previous section, you </st><a id="_idIndexMarker395"/><st c="21391">learned about how to build the architecture discussed in </st><span class="No-Break"><em class="italic"><st c="21448">Figure 6</st></em></span><em class="italic"><st c="21456">.1</st></em><st c="21458">. In this section, you will learn about the CI/CD components, and build the complete </st><span class="No-Break"><em class="italic"><st c="21543">Figure 6</st></em></span><em class="italic"><st c="21551">.2</st></em><st c="21553"> architecture </st><span class="No-Break"><st c="21567">using Terraform.</st></span></p>
			<p><st c="21583">Open </st><strong class="source-inline"><st c="21589">cicd.tf</st></strong><st c="21596"> in your code editor. </st><st c="21618">This Terraform file creates a CodeStar connection to a GitHub repository, an S3 bucket with the value of the </st><strong class="source-inline"><st c="21727">codepipeline_bucket_name</st></strong><st c="21751"> variable in the </st><strong class="source-inline"><st c="21768">dev.tfvars</st></strong><st c="21778"> file, a CodeBuild project using </st><strong class="source-inline"><st c="21811">buildspec.yml</st></strong><st c="21824">, a CodePipeline with two stages (</st><em class="italic"><st c="21858">Source</st></em><st c="21865"> and </st><em class="italic"><st c="21870">Build</st></em><st c="21875">), and roles and policies for all the components to interact with each </st><span class="No-Break"><st c="21947">other successfully.</st></span></p>
			<p><st c="21966">CodeStar is the simplest. </st><st c="21993">It is just a connection to a GitHub code repository. </st><st c="22046">However, for this to work, you must create your own GitHub repository. </st><st c="22117">If you are not familiar with the process, you can follow this guide. </st><st c="22186">Learn how to create a new repository and commit your first change in five minutes </st><span class="No-Break"><st c="22268">at </st></span><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories"><span class="No-Break"><st c="22271">https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories</st></span></a><span class="No-Break"><st c="22373">.</st></span></p>
			<p><st c="22374">In this repository, you will save your website files. </st><st c="22429">After creating your repository, alter the </st><strong class="source-inline"><st c="22471">github_repository_url</st></strong><st c="22492"> variable in </st><strong class="source-inline"><st c="22505">dev.tfvars</st></strong><st c="22515"> to match your </st><span class="No-Break"><st c="22530">GitHub URL.</st></span></p>
			<p><st c="22541">Look at the CodePipeline piece. </st><st c="22574">It creates a pipeline with two stages but notices how each stage’s artifacts are connected through the </st><strong class="source-inline"><st c="22677">input_artifacts</st></strong><st c="22692"> and </st><strong class="source-inline"><st c="22697">output_artifacts</st></strong><st c="22713"> variables. </st><st c="22725">This functionality makes sure you have what was built previously available in the next </st><a id="_idIndexMarker396"/><st c="22812">stages. </st><st c="22820">It uses an S3 bucket as you can see in the </st><span class="No-Break"><strong class="source-inline"><st c="22863">artifact_store</st></strong></span><span class="No-Break"><st c="22877"> variable:</st></span></p>
			<pre class="source-code"><st c="22887">
resource "aws_codepipeline" "codepipeline" {
  name     = "tf-test-pipeline"
  role_arn = aws_iam_role.codepipeline_role.arn
  </st><strong class="bold"><st c="23005">a</st><a id="_idTextAnchor181"/><st c="23006">rtifact_store</st></strong><st c="23019"> {
    </st><a id="_idTextAnchor182"/><st c="23022">location = aws_s3_bucket.codepipeline_bucket.bucket
    type     = "S3"
  }
  stage {
    </st><strong class="bold"><st c="23096">name = "Source"</st></strong><st c="23111">
    action {
      name             = "Source"
      category         = "Source"
      owner            = "AWS"
      </st><strong class="bold"><st c="23171">provider         = "CodeStarSourceConnection"</st></strong><st c="23208">
      version          = "1"
      </st><strong class="bold"><st c="23223">output_artifacts = ["source_output"]</st></strong><st c="23259">
      configuration = {
        ConnectionArn    = aws_codestarconnections_connection.codestar_connection.arn
</st><strong class="bold"><st c="23353">        FullRepositoryId = var.github_repository_url</st></strong>
<strong class="bold"><st c="23397">        BranchName       = "main"</st></strong><st c="23417">
      }
    }
  }
  stage {
    </st><strong class="bold"><st c="23432">name = "Build"</st></strong><st c="23446">
    action {
      name             = "Build"
      category         = "Build"
      owner            = "AWS"
      </st><strong class="bold"><st c="23504">provider         = "CodeBuild"</st></strong><strong class="bold"><st c="23526">input_artifacts  = ["source_output"]</st></strong><st c="23562">
      output_artifacts = ["build_output"]
      version          = "1"
      configuration = {
        </st><strong class="bold"><st c="23631">ProjectName = "event-website"</st></strong><st c="23660">
      }
    }
  }
}</st></pre>			<p><st c="23668">The first stage clones</st><a id="_idIndexMarker397"/><st c="23691"> the repository, and the second stage triggers a </st><span class="No-Break"><st c="23740">CodeBuild project.</st></span></p>
			<p><st c="23758">Now, shift your atten</st><a id="_idTextAnchor183"/><st c="23780">tion to the CodeBuild piece. </st><st c="23810">It uses a compute environment of Lambda, meaning it uses a lambda function to run the instructions instead of an EC2. </st><st c="23928">The instructions that CodeBuild executes are defined in a </st><strong class="source-inline"><st c="23986">buildspec</st></strong> <span class="No-Break"><st c="23995">YAML file:</st></span></p>
			<pre class="source-code"><st c="24006">
resource "aws_codebuild_project" "translate" {
  name         = "event-website"
  service_role = aws_iam_role.codebuild.arn
  artifacts {
    type = "CODEPIPELINE"
  }
  environment {
    </st><strong class="bold"><st c="24169">compute_type = "BUILD_LAMBDA_2GB"</st></strong><st c="24202">
    image        = "a</st><a id="_idTextAnchor184"/><st c="24213">ws/codebuild/amazonlinux-x86_64-lambda-standard:python3.12"
    type         = "LINUX_LAMBDA_CONTAINER"
  }
  source {
    type      = "CODEPIPELINE"
    </st><strong class="bold"><st c="24339">buildspec = file("buildspec.yml")</st></strong><st c="24372">
  }
}</st></pre>			<p><st c="24376">Open </st><strong class="source-inline"><st c="24382">buildspec.yml</st></strong><st c="24395">. You </st><a id="_idIndexMarker398"/><st c="24401">can see what five commands CodeBuild will execute. </st><st c="24452">In summary, CodeBuild will copy the contents of the local directory to each of the buckets, then execute a Python function. </st><st c="24576">Lastly it copies the resulting file of that Python function to the </st><span class="No-Break"><st c="24643">Spanish bucket:</st></span></p>
			<pre class="source-code"><st c="24658">
version: 0.2
phases:
  build:
  </st><a id="_idTextAnchor185"/><st c="24687">  commands:
       - ls
       - aws s3 sync . </st><st c="24718">s3://m</st><a id="_idTextAnchor186"/><st c="24724">y-english-assets-bucket
       - aws s3 sync . </st><st c="24765">s3://my-spanish-assets-bucket
       - </st><strong class="bold"><st c="24797">python translate.py en es index.html</st></strong>
<strong class="bold"><st c="24833">       - aws s3 cp es-index.html s3://my-spanish-assets-bucket/index.html</st></strong></pre>			<p><st c="24900">You need to replace the URLs with your own for all AWS </st><span class="No-Break"><st c="24956">S3 commands.</st></span></p>
			<p><st c="24968">Why does CodeBuild have files in the local directory? </st><st c="25023">This is because CodeBuild is executed after pulling from GitHub in CodePipeline. </st><st c="25104">Now, open </st><strong class="source-inline"><st c="25114">translate.py</st></strong><st c="25126"> in the </st><span class="No-Break"><strong class="source-inline"><st c="25134">app</st></strong></span><span class="No-Break"><st c="25137"> folder.</st></span></p>
			<p class="callout-heading"><st c="25145">Important note</st></p>
			<p class="callout"><st c="25160">The </st><strong class="source-inline"><st c="25165">s3 sync</st></strong><st c="25172"> command synchronizes directories to and from S3 by recursively copying files. </st><st c="25251">It only transfers </st><span class="No-Break"><st c="25269">changed files.</st></span></p>
			<p><st c="25283">Remember, the</st><a id="_idIndexMarker399"/><st c="25297"> goal of this pipeline was to propagate changes made to the website’s source code; you do that with the </st><strong class="source-inline"><st c="25401">s3 sync</st></strong><st c="25408"> command. </st><st c="25418">However, you also wanted to have the assets automatically translated to Spanish and propagated to a different bucket. </st><st c="25536">This is what </st><strong class="source-inline"><st c="25549">translate.py</st></strong><st c="25561">, leveraging Amazon Translate, does. </st><st c="25598">The code calls the </st><strong class="source-inline"><st c="25617">translate_document</st></strong><st c="25635"> API with </st><strong class="source-inline"><st c="25645">index.html</st></strong><st c="25655"> as data and creates a local document with </st><span class="No-Break"><st c="25698">the result:</st></span></p>
			<pre class="source-code"><st c="25709">
import boto3
import argparse
parser = argparse.ArgumentParser()
</st><strong class="bold"><st c="25774">parser.add_argument("SourceLanguageCode")</st></strong>
<strong class="bold"><st c="25815">parser.add_argument("TargetLanguageCode")</st></strong>
<strong class="bold"><st c="25857">parser.add_argument("SourceFile")</st></strong><st c="25891">
args = parser.parse_args()
translate = boto3.client('transla</st><a id="_idTextAnchor187"/><st c="25952">te')
localFile = args.SourceFile
file = open(localFile, "rb")
data = file.read()
file.close()
</st><strong class="bold"><st c="26047">result = t</st><a id="_idTextAnchor188"/><st c="26057">ranslate.translate_document(</st></strong>
<strong class="bold"><st c="26086">    Document={</st></strong>
<strong class="bold"><st c="26097">            "Content": data,</st></strong>
<strong class="bold"><st c="26114">            "ContentType": "text/html"</st></strong>
<strong class="bold"><st c="26141">        },</st></strong>
<strong class="bold"><st c="26144">    SourceLanguageCode=args.SourceLanguageCode,</st></strong>
<strong class="bold"><st c="26188">    TargetLanguageCode=args.TargetLanguageCode</st></strong>
<strong class="bold"><st c="26231">)</st></strong><st c="26233">
if "TranslatedDocument" in </st><a id="_idTextAnchor189"/><st c="26261">result:
    fileName = localFile.split("/")[-1]
    tmpfile = f"{args.</st><a id="_idTextAnchor190"/><st c="26323">TargetLanguageCode}-{fileName}"
    with open(tmpfile,  'w') as f:
        f.wri</st><a id="_idTextAnchor191"/><st c="26391">te(result["TranslatedDocument"]["</st><a id="_idTextAnchor192"/><st c="26425">Content"].decode('utf-8'))
    print("Translated document ", tmpfile)</st></pre>			<p><st c="26491">The code is extendable. </st><st c="26516">It reads the input and output language, as well as the file to be translated from the </st><span class="No-Break"><st c="26602">execution arguments.</st></span></p>
			<p><st c="26622">In the </st><strong class="source-inline"><st c="26630">app</st></strong><st c="26633"> folder, you will also find new </st><strong class="source-inline"><st c="26665">index.css</st></strong><st c="26674"> and </st><strong class="source-inline"><st c="26679">index.html</st></strong><st c="26689"> files. </st><st c="26697">These are your new website assets. </st><st c="26732">Explore these in your local workstation to see what the website will </st><span class="No-Break"><st c="26801">look like.</st></span></p>
			<p><st c="26811">Now that you know all the solution components and how they are represented in Terraform, it is time to create them. </st><st c="26928">Run </st><strong class="source-inline"><st c="26932">terraform apply</st></strong><st c="26947"> with your </st><span class="No-Break"><st c="26958">variable file:</st></span></p>
			<pre class="console"><st c="26972">
terraform apply -var-file="dev.tfvars"</st></pre>			<p><st c="27011">A successful</st><a id="_idIndexMarker400"/><st c="27024"> execution should output </st><span class="No-Break"><strong class="source-inline"><st c="27049">Apply Complete!</st></strong></span><span class="No-Break"><st c="27064">.</st></span></p>
			<p><st c="27065">There is one manual step you must do before it all works: give permissions to CodePipeline to access your </st><span class="No-Break"><st c="27172">GitHub repository:</st></span></p>
			<ol>
				<li><st c="27190">Navigate to the </st><strong class="bold"><st c="27207">CodePipeline</st></strong><st c="27219"> console </st><span class="No-Break"><st c="27228">at </st></span><a href="https://us-east-1.console.aws.amazon.com/codesuite/settings/"><span class="No-Break"><st c="27231">https://us-east-1.console.aws.amazon.com/codesuite/settings/</st></span></a><span class="No-Break"><st c="27291">.</st></span></li>
				<li><st c="27292">Under </st><strong class="bold"><st c="27299">Settings</st></strong><st c="27307">, </st><span class="No-Break"><st c="27309">select </st></span><span class="No-Break"><strong class="bold"><st c="27316">Connections</st></strong></span><span class="No-Break"><st c="27327">.</st></span></li>
				<li><st c="27328">You will find the </st><strong class="source-inline"><st c="27347">app-dev-codestar</st></strong><st c="27363"> connection with the </st><strong class="bold"><st c="27384">Pending</st></strong><st c="27391"> status. </st><st c="27400">Select it and click </st><strong class="bold"><st c="27420">Update </st></strong><span class="No-Break"><strong class="bold"><st c="27427">pending connection</st></strong></span><span class="No-Break"><st c="27445">.</st></span></li>
				<li><st c="27446">On the popup, select </st><strong class="bold"><st c="27468">Install a new App</st></strong><st c="27485">, as shown in </st><span class="No-Break"><em class="italic"><st c="27499">Figure 6</st></em></span><em class="italic"><st c="27507">.4</st></em><st c="27509">, and log in using your </st><span class="No-Break"><st c="27533">GitHub credentials.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B22051_06_4.jpg" alt="Figure 6.4 – Connect to GitHub AWS Menu"/><st c="27552"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27776">Figure 6.4 – Connect to GitHub AWS Menu</st></p>
			<p><st c="27815">Your </st><strong class="source-inline"><st c="27821">app-dev-codestar</st></strong><st c="27837"> connection</st><a id="_idIndexMarker401"/><st c="27848"> should now show the </st><span class="No-Break"><strong class="bold"><st c="27869">Available</st></strong></span><span class="No-Break"><st c="27878"> status.</st></span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor193"/><st c="27886">Testing the solution</st></h2>
			<p><st c="27907">Navigate to the </st><a id="_idIndexMarker402"/><st c="27924">CloudFront console and extract your distribution’s URL. </st><st c="27980">Visit it, and what do you see? </st><st c="28011">It should be </st><a href="B22051_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic"><st c="28024">Chapter </st></em></span><span class="No-Break"><em class="italic"><st c="28032">2</st></em></span></a><span class="No-Break"><st c="28033">’s frontend.</st></span></p>
			<p><st c="28045">The files in your S3 buckets were not changed. </st><st c="28093">To trigger a change, you first need to upload the application files to your </st><span class="No-Break"><st c="28169">GitHub repository.</st></span></p>
			<p><st c="28187">There are multiple ways to do this. </st><st c="28224">It is Git compatible, so you can clone the repository, and add your files that way. </st><st c="28308">Another way is to manually upload the three files using the </st><span class="No-Break"><st c="28368">GitHub Console.</st></span></p>
			<p><st c="28383">Using the Git method, execute the following commands, from within the </st><strong class="source-inline"><st c="28454">app</st></strong><st c="28457"> folder, replacing the URL with </st><span class="No-Break"><st c="28489">your own:</st></span></p>
			<pre class="source-code"><st c="28498">
$ </st><strong class="bold"><st c="28501">ls</st></strong><st c="28503">
index.css    index.html   translate.py
$ </st><strong class="bold"><st c="28540">git clone  https://github.com/IvoP1/chapter6-repo.git</st></strong><st c="28592">
Cloning into 'chapter6-repo'...
</st><st c="28625">warning: You appear to have cloned an empty repository.
</st><st c="28681">$ </st><strong class="bold"><st c="28683">cp index.html index.css translate.py chapter6-repo/</st></strong><st c="28734">
$ </st><strong class="bold"><st c="28737">cd chapter6-repo</st></strong><st c="28753">
$ chapter6-repo git:(main) ✗</st><strong class="bold"><st c="28782"> ls</st></strong><st c="28785">
index.css    index.html   tra</st><a id="_idTextAnchor194"/><st c="28810">nslate.py
$ chapter6-repo git:(main) ✗</st><strong class="bold"><st c="28849"> git add .</st></strong><st c="28859">
$ chapter6-repo git:(main) ✗ </st><strong class="bold"><st c="28889">git commit -m "1 version"</st></strong><st c="28914">
$ chapter6-repo git:(main)</st><strong class="bold"><st c="28941"> git push</st></strong><st c="28950">
You are pushing to the remote origin at  https://github.com/IvoP1/chapter6-repo.git
Enumerating objects: 5, done.
</st><st c="29064">Counting objects: 100% (5/5), done.
</st><st c="29100">Delta compression using up to 12 threads
Compressing objects: 100% (5/5), done.
</st><st c="29180">Writing objects: 100% (5/5), 2.52 KiB | 2.52 MiB/s, done.
</st><st c="29238">Total 5 (delta 0), reused 0 (delta 0), pack-reused 0
remote: Validating objects: 100%
To  https://</st><a id="_idTextAnchor195"/><st c="29335">github.com/IvoP1/chapter6-repo.git
 * [new branch]      main -&gt; main
  chapter6-repo git:(main)</st></pre>			<p><st c="29423">Navigate to your </st><a id="_idIndexMarker403"/><st c="29441">distribution’s URL. </st><st c="29461">You should now see the new website, either in English or in Spanish depending on your browser preferences. </st><span class="No-Break"><em class="italic"><st c="29568">Figure 6</st></em></span><em class="italic"><st c="29576">.5</st></em><st c="29578"> shows a side-by-side comparison. </st><span class="No-Break"><st c="29612">Try both.</st></span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B22051_06_5.jpg" alt="Figure 6.5 – Side-by-side comparison of English and Spanish web application versions"/><st c="29621"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="30881">Figure 6.5 – Side-by-side comparison of English and Spanish web application versions</st></p>
			<p><st c="30965">Navigate to the CodePipeline and CodeBuild consoles and explore </st><span class="No-Break"><st c="31030">the outputs.</st></span></p>
			<p><st c="31042">Make any </st><a id="_idIndexMarker404"/><st c="31052">changes to your </st><strong class="source-inline"><st c="31068">index.html</st></strong><st c="31078"> or </st><strong class="source-inline"><st c="31082">index.css</st></strong><st c="31091"> local files and upload the newer versions to git. </st><st c="31142">Verify how that triggers </st><span class="No-Break"><st c="31167">your CodePipeline.</st></span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor196"/><st c="31185">Cleaning up</st></h2>
			<p><st c="31197">As you saw in the </st><a id="_idIndexMarker405"/><st c="31216">previous chapter, cleaning up using Terraform is simple. </st><st c="31273">You use the </st><span class="No-Break"><strong class="source-inline"><st c="31285">destroy</st></strong></span><span class="No-Break"><st c="31292"> command.</st></span></p>
			<p><st c="31301">However, in this architecture, there are three caveats you need to have </st><span class="No-Break"><st c="31374">in mind:</st></span></p>
			<ul>
				<li><st c="31382">S3 buckets cannot be deleted if they have objects inside. </st><st c="31441">Before running the </st><strong class="source-inline"><st c="31460">terraform destroy</st></strong><st c="31477"> command, you must manually, or programmatically, empty all the buckets. </st><st c="31550">There are three buckets: Spanish assets, English assets, and </st><span class="No-Break"><st c="31611">CodePipeline artifacts.</st></span></li>
				<li><st c="31634">Lambda@Edge functions can take a few hours to be deleted. </st><st c="31693">This is an AWS limitation highlighted in their documentation by the following quote; “Wait a few hours after deleting the function association so that the Lambda@Edge function replicas can be cleaned up. </st><st c="31897">After that, you will be able to delete the function by using the Lambda console, AWS CLI, Lambda API, or an AWS </st><span class="No-Break"><st c="32009">SDK.” (</st></span><a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-edge-delete-replicas.html"><span class="No-Break"><st c="32016">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-edge-delete-replicas.html</st></span></a><span class="No-Break"><st c="32116">).</st></span></li>
				<li><st c="32119">You created your own GitHub repository outside Terraform. </st><st c="32178">You have to delete </st><span class="No-Break"><st c="32197">that manually.</st></span></li>
			</ul>
			<p><st c="32211">With the previous in mind, run the </st><strong class="source-inline"><st c="32247">terraform destroy</st></strong><st c="32264"> command. </st><st c="32274">It will delete everything but</st><a id="_idIndexMarker406"/><st c="32303"> the Lambda function, assuming your buckets are empty. </st><st c="32358">A few hours later, you can delete the Lambda </st><span class="No-Break"><st c="32403">function manually.</st></span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor197"/><st c="32421">Future work</st></h1>
			<p><st c="32433">Your proof of concept was a success; now you must take it into production. </st><st c="32509">This section inspires you with </st><span class="No-Break"><st c="32540">some enhancements.</st></span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor198"/><st c="32558">Implementing custom names</st></h2>
			<p><st c="32584">The usual enhancements </st><a id="_idIndexMarker407"/><st c="32608">apply here. </st><st c="32620">A friendly DNS name is not only good for remembrance but also security, so folks do not connect to a different web application </st><span class="No-Break"><st c="32747">by mistake.</st></span></p>
			<p><st c="32758">If you own a domain name and a certificate, like you learned about in </st><a href="B22051_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic"><st c="32829">Chapter 3</st></em></span></a><st c="32838">, you should configure them in this application too. </st><st c="32891">With this architecture, this is done at the </st><span class="No-Break"><st c="32935">CloudFront level.</st></span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor199"/><st c="32952">Expanding your application functionality</st></h2>
			<p><st c="32993">Although this web </st><a id="_idIndexMarker408"/><st c="33012">application fulfills all the requirements, it could support many more languages. </st><st c="33093">Modify the solution to work with at least one </st><span class="No-Break"><st c="33139">more language.</st></span></p>
			<p><st c="33153">For this, you will need to create a new bucket and change the Lambda@Edge code to look for different </st><span class="No-Break"><st c="33255">header values.</st></span></p>
			<p><st c="33269">You can find out what is the header value for each language </st><span class="No-Break"><st c="33330">at </st></span><a href="https://learn.microsoft.com/en-us/graph/search-concept-acceptlanguage-header"><span class="No-Break"><st c="33333">https://learn.microsoft.com/en-us/graph/search-concept-acceptlanguage-header</st></span></a><span class="No-Break"><st c="33409">.</st></span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor200"/><st c="33410">Adopting CI/CD for infrastructure code</st></h2>
			<p><st c="33449">You have built </st><a id="_idIndexMarker409"/><st c="33465">many </st><a id="_idIndexMarker410"/><st c="33470">infrastructure components throughout the chapters of this book. </st><st c="33534">CI/CD, as you have learned in this chapter, also applies to IaC. </st><st c="33599">Instead of running IaC commands from your terminal, for example, </st><strong class="source-inline"><st c="33664">terraform apply</st></strong><st c="33679">, you can and should do it from a </st><span class="No-Break"><st c="33713">CI/CD tool.</st></span></p>
			<p><st c="33724">This approach has </st><span class="No-Break"><st c="33743">several benefits:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="33760">Scoped access</st></strong><st c="33774">: Human</st><a id="_idIndexMarker411"/><st c="33782"> operators only have access to the CI/CD tools, and do not have direct access </st><span class="No-Break"><st c="33860">to infrastructure</st></span></li>
				<li><strong class="bold"><st c="33877">Better traceability</st></strong><st c="33897">: Knowing who did </st><span class="No-Break"><st c="33916">what, when</st></span></li>
				<li><strong class="bold"><st c="33926">Standardization</st></strong><st c="33942">: No more “it works on my </st><span class="No-Break"><st c="33969">machine” comments</st></span></li>
			</ul>
			<p><st c="33986">If you are </st><a id="_idIndexMarker412"/><st c="33998">interested in this</st><a id="_idIndexMarker413"/><st c="34016"> topic, AWS has in-depth guidance on it </st><span class="No-Break"><st c="34056">at </st></span><a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/create-a-ci-cd-pipeline-to-validate-terraform-configurations-by-using-aws-codepipeline.html"><span class="No-Break"><st c="34059">https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/create-a-ci-cd-pipeline-to-validate-terraform-configurations-by-using-aws-codepipeline.html</st></span></a><span class="No-Break"><st c="34216">.</st></span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor201"/><st c="34217">Summary</st></h1>
			<p><st c="34225">In this chapter, you built a dynamic rendering web application that takes users’ preferences into account to deliver a better user experience. </st><st c="34369">Although you built it to adapt to your users’ preferred languages, the same approach can be used to adapt applications based on other information such as websites visited or </st><span class="No-Break"><st c="34543">device type.</st></span></p>
			<p><st c="34555">To build this application, you used an advanced CloudFront dynamic rendering functionality using Lambda@Edge and a machine learning algorithm powered by </st><span class="No-Break"><st c="34709">Amazon Translate.</st></span></p>
			<p><st c="34726">The second part of this chapter was focused on CI/CD. </st><st c="34781">You took advantage of AWS-native services to build a fully automated pipeline that received English assets, translated them, and deployed them to the web application. </st><st c="34948">CI/CD is widely leveraged in most </st><span class="No-Break"><st c="34982">applications today.</st></span></p>
			<p><st c="35001">The chapter finished with homework: tasks that you can implement on your own to sharpen your skills while improving this </st><span class="No-Break"><st c="35123">project’s functionalities.</st></span></p>
			<p><st c="35149">In the next chapter, you will continue taking advantage of AWS machine learning services, but this time, you will build a </st><span class="No-Break"><st c="35272">human-like chatbot.</st></span></p>
		</div>
	<div id="charCountTotal" value="35291"/>

		<div id="_idContainer106" class="Content">
			<h1 id="_idParaDest-154" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor202"/><st c="0">Part 3: Advanced Level Projects</st></h1>
			<p><st c="32">In </st><em class="italic"><st c="36">Part 3</st></em><st c="42"> of this book, you will continue learning about new AWS architectures and services. </st><st c="126">This last part focuses on advanced capabilities such as artificial intelligence, machine learning, and data analytics. </st><st c="245">You will leverage large language models, serverless ETL tools, and AWS-native dashboards. </st><st c="335">At the end of this part, you will find extra resources that you can follow to build your next </st><span class="No-Break"><st c="429">big project.</st></span></p>
			<p><st c="441">This part has the </st><span class="No-Break"><st c="460">following chapters:</st></span></p>
			<ul>
				<li><a href="B22051_07.xhtml#_idTextAnchor203"><em class="italic"><st c="479">Chapter 7</st></em></a><st c="489">, </st><em class="italic"><st c="491">Implementing a Chatbot Using Machine Learning</st></em></li>
				<li><a href="B22051_08.xhtml#_idTextAnchor227"><em class="italic"><st c="536">Chapter 8</st></em></a><st c="546">, </st><em class="italic"><st c="548">Building a Business Intelligence Application</st></em></li>
				<li><em class="italic"><st c="592">Chapter 9</st></em><st c="602">, </st><em class="italic"><st c="604">Exploring Future Work</st></em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer107">
			</div>
		</div>
	<div id="charCountTotal" value="625"/></body></html>