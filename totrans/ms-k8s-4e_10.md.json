["```\n$ k run -it --image g1g1/py-kube:0.3 -- bash\nIf you don't see a command prompt, try pressing enter.\nroot@bash:/#\nroot@bash:/# cat /etc/resolv.conf\nsearch default.svc.cluster.local svc.cluster.local cluster.local\nnameserver 10.96.0.10\noptions ndots:5 \n```", "```\n$ k get svc -n kube-system\nNAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE\nkube-dns   ClusterIP   10.96.0.10   <none>        53/UDP,53/TCP,9153/TCP   19m \n```", "```\napiVersion: v1\nkind: Service\nmetadata:\n  name: maker\nspec:\n  selector:\n    app: py-kube\n  clusterIP: None # headless service\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: py-kube1\n  labels:\n    app: py-kube\nspec:\n  hostname: trouble\n  subdomain: maker\n  containers:\n  - image: g1g1/py-kube:0.3\n    command:\n      - sleep\n      - \"9999\"\n    name: trouble\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: py-kube2\n  labels:\n    app: py-kube\nspec:\n  hostname: trouble2\n  subdomain: maker\n  containers:\n    - image: g1g1/py-kube:0.3\n      command:\n        - sleep\n        - \"9999\"\n      name: trouble \n```", "```\n$ k apply -f pod-with-dns.yaml\nservice/maker created\npod/py-kube1 created\npod/py-kube2 created \n```", "```\n$ k exec -it py-kube2 -- bash\nroot@trouble2:/# hostname\ntrouble2\nroot@trouble2:/# hostname --fqdn\ntrouble2.maker.default.svc.cluster.local\nroot@trouble2:/# dig +short trouble.maker.default.svc.cluster.local\n10.244.0.10\nroot@trouble2:/# dig +short trouble2.maker.default.svc.cluster.local\n10.244.0.9 \n```", "```\n$ k get po -o wide\nNAME       READY   STATUS    RESTARTS   AGE   IP            NODE                 NOMINATED NODE   READINESS GATES\npy-kube1   1/1     Running   0          10m   10.244.0.10   kind-control-plane   <none>           <none>\npy-kube2   1/1     Running   0          18m   10.244.0.9    kind-control-plane   <none>           <none> \n```", "```\n$ k describe svc -n kube-system kube-dns\nName:              kube-dns\nNamespace:         kube-system\nLabels:            k8s-app=kube-dns\n                   kubernetes.io/cluster-service=true\n                   kubernetes.io/name=CoreDNS\nAnnotations:       prometheus.io/port: 9153\n                   prometheus.io/scrape: true\nSelector:          k8s-app=kube-dns\nType:              ClusterIP\nIP Family Policy:  SingleStack\nIP Families:       IPv4\nIP:                10.96.0.10\nIPs:               10.96.0.10\nPort:              dns  53/UDP\nTargetPort:        53/UDP\nEndpoints:         10.244.0.2:53,10.244.0.3:53\nPort:              dns-tcp  53/TCP\nTargetPort:        53/TCP\nEndpoints:         10.244.0.2:53,10.244.0.3:53\nPort:              metrics  9153/TCP\nTargetPort:        9153/TCP\nEndpoints:         10.244.0.2:9153,10.244.0.3:9153\nSession Affinity:  None\nEvents:            <none> \n```", "```\n$ k get po -n kube-system -l k8s-app=kube-dns\nNAME                      READY   STATUS    RESTARTS   AGE\ncoredns-64897985d-n4x5b   1/1     Running   0          97m\ncoredns-64897985d-nqtwk   1/1     Running   0          97m \n```", "```\n$ k get deploy coredns -n kube-system -o jsonpath='{.spec.template.spec.containers[0]}' | jq .image\n\"k8s.gcr.io/coredns/coredns:v1.8.6\" \n```", "```\n{\n  \"cniVersion\": \"0.3.0\",\n  \"interfaces\": [              (this key omitted by IPAM plugins)\n      {\n          \"name\": \"<name>\",\n          \"mac\": \"<MAC address>\", (required if L2 addresses are meaningful)\n          \"sandbox\": \"<netns path or hypervisor identifier>\" (required for container/hypervisor interfaces, empty/omitted for host interfaces)\n      }\n  ],\n  \"ip\": [\n      {\n          \"version\": \"<4-or-6>\",\n          \"address\": \"<ip-and-prefix-in-CIDR>\",\n          \"gateway\": \"<ip-address-of-the-gateway>\",     (optional)\n          \"interface\": <numeric index into 'interfaces' list>\n      },\n      ...\n  ],\n  \"routes\": [                                           (optional)\n      {\n          \"dst\": \"<ip-and-prefix-in-cidr>\",\n          \"gw\": \"<ip-of-next-hop>\"                      (optional)\n      },\n      ...\n  ]\n  \"dns\": {\n    \"nameservers\": <list-of-nameservers>                (optional)\n    \"domain\": <name-of-local-domain>                    (optional)\n    \"search\": <list-of-additional-search-domains>       (optional)\n    \"options\": <list-of-options>                        (optional)\n  }\n} \n```", "```\n{\n  \"cniVersion\": \"0.3.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  // type (plugin) specific\n  \"bridge\": \"cni0\",\n  \"ipam\": {\n    \"type\": \"host-local\",\n    // ipam specific\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [\"10.1.0.1\"]\n  }\n} \n```", "```\nkubectl apply -f https://github.com/weaveworks/weave/releases/download/v2.8.1/weave-daemonset-k8s.yaml \n```", "```\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: test-network-policy\n  namespace: awesome-project\nspec:\n  podSelector:\n    matchLabels:\n      role: db\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:  \n    - from:\n        - namespaceSelector:\n            matchLabels:\n              project: awesome-project\n        - podSelector:\n            matchLabels:\n              role: frontend\n      ports:\n       - protocol: TCP\n         port: 6379\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.0/24\n      ports:\n        - protocol: TCP\n          port: 7777 \n```", "```\napiVersion: v1\nkind: Service\nmetadata:\n  name: api-gateway\nspec:\n  type: LoadBalancer\n  ports:\n  - port:  80\n    targetPort: 5000\n  selector:\n    svc: api-gateway\n    app: delinkcious \n```", "```\n$ kubectl expose deployment api-gateway --port=80 --target-port=5000 --name=api-gateway --type=LoadBalancer \n```", "```\n$ kubectl describe services example-service\nName: example-service\nSelector: app=example\nType: LoadBalancer\nIP: 10.67.252.103\nLoadBalancer Ingress: 123.45.678.9\nPort: <unnamed> 80/TCP\nNodePort: <unnamed> 32445/TCP\nEndpoints: 10.64.0.4:80,10.64.1.5:80,10.64.2.4:80\nSession Affinity: None\nNo events. \n```", "```\napiVersion: v1\nkind: Service\nmetadata:\n  name: api-gateway\nspec:\n  type: LoadBalancer\n  externalTrafficPolicy: Local\n  ports:\n  - port:  80\n    targetPort: 5000\n  selector:\n    svc: api-gateway\n    app: delinkcious \n```", "```\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: test\nspec:\n  ingressClassName: cool-ingress\n  rules:\n  - host: foo.bar.com\n    http:\n      paths:\n- path: /foo\n  backend: \n    service:\n      name: s1 \n      port: 80 \n- path: /bar \n  backend: \n    service:\n      name: s2 \n      port: 80 \n```", "```\napiVersion: networking.k8s.io/v1\nkind: IngressClass\nmetadata:\n  labels:\n    app.kubernetes.io/component: controller\n  name: cool-ingress\n  annotations:\n    ingressclass.kubernetes.io/is-default-class: \"true\"\nspec:\n  controller: k8s.io/ingress-nginx \n```", "```\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: cool-gateway\n  namespace: ns1\nspec:\n  gatewayClassName: cool-gateway-class\n  listeners:\n  - name: cool-service\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      kinds: \n        - kind: HTTPRoute\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            # This label is added automatically as of K8s 1.22\n            # to all namespaces\n            kubernetes.io/metadata.name: ns2 \n```", "```\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: cool-route\n  namespace: ns2\nspec:\n  parentRefs:\n  - kind: Gateway\n    name: cool-gateway\n    namespace: ns1\n  rules:\n  - backendRefs:\n    - name: cool-service\n      port: 8080 \n```", "```\npackage main\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"net\"\n    \"github.com/vishvananda/netlink\"\n    \"github.com/containernetworking/cni/pkg/skel\"\n    \"github.com/containernetworking/cni/pkg/types\"\n    current \"github.com/containernetworking/cni/pkg/types/100\"\n    \"github.com/containernetworking/cni/pkg/version\"\n    \"github.com/containernetworking/plugins/pkg/ns\"\n    bv \"github.com/containernetworking/plugins/pkg/utils/buildversion\"\n) \n```", "```\nfunc cmdAdd(args *skel.CmdArgs) error {\n    conf, err := parseNetConf(args.StdinData)\n    if err != nil {\n        return err\n    }\n    var v4Addr, v6Addr *net.IPNet\n    args.IfName = \"lo\" // ignore config, this only works for loopback\n    err = ns.WithNetNSPath(args.Netns, func(_ ns.NetNS) error {\n        link, err := netlink.LinkByName(args.IfName)\n        if err != nil {\n            return err // not tested\n        }\n        err = netlink.LinkSetUp(link)\n        if err != nil {\n            return err // not tested\n        }\n        v4Addrs, err := netlink.AddrList(link, netlink.FAMILY_V4)\n        if err != nil {\n            return err // not tested\n        }\n        if len(v4Addrs) != 0 {\n            v4Addr = v4Addrs[0].IPNet\n            // sanity check that this is a loopback address\n            for _, addr := range v4Addrs {\n                if !addr.IP.IsLoopback() {\n                    return fmt.Errorf(\"loopback interface found with non-loopback address %q\", addr.IP)\n                }\n            }\n        }\n        v6Addrs, err := netlink.AddrList(link, netlink.FAMILY_V6)\n        if err != nil {\n            return err // not tested\n        }\n        if len(v6Addrs) != 0 {\n            v6Addr = v6Addrs[0].IPNet\n            // sanity check that this is a loopback address\n            for _, addr := range v6Addrs {\n                if !addr.IP.IsLoopback() {\n                    return fmt.Errorf(\"loopback interface found with non-loopback address %q\", addr.IP)\n                }\n            }\n        }\n        return nil\n    })\n    if err != nil {\n        return err // not tested\n    }\n    var result types.Result\n    if conf.PrevResult != nil {\n        // If loopback has previous result which passes from previous CNI plugin,\n        // loopback should pass it transparently\n        result = conf.PrevResult\n    } else {\n        r := &current.Result{\n            CNIVersion: conf.CNIVersion,\n            Interfaces: []*current.Interface{\n                &current.Interface{\n                    Name:    args.IfName,\n                    Mac:     \"00:00:00:00:00:00\",\n                    Sandbox: args.Netns,\n                },\n            },\n        }\n        if v4Addr != nil {\n            r.IPs = append(r.IPs, &current.IPConfig{\n                Interface: current.Int(0),\n                Address:   *v4Addr,\n            })\n        }\n        if v6Addr != nil {\n            r.IPs = append(r.IPs, &current.IPConfig{\n                Interface: current.Int(0),\n                Address:   *v6Addr,\n            })\n        }\n        result = r\n    }\n    return types.PrintResult(result, conf.CNIVersion)\n} \n```", "```\nfunc cmdDel(args *skel.CmdArgs) error {\n    if args.Netns == \"\" {\n        return nil\n    }\n    args.IfName = \"lo\" // ignore config, this only works for loopback\n    err := ns.WithNetNSPath(args.Netns, func(ns.NetNS) error {\n        link, err := netlink.LinkByName(args.IfName)\n        if err != nil {\n            return err // not tested\n        }\n        err = netlink.LinkSetDown(link)\n        if err != nil {\n            return err // not tested\n        }\n        return nil\n    })\n    if err != nil {\n        //  if NetNs is passed down by the Cloud Orchestration Engine, or if it called multiple times\n        // so don't return an error if the device is already removed.\n        // https://github.com/kubernetes/kubernetes/issues/43014#issuecomment-287164444\n        _, ok := err.(ns.NSPathNotExistErr)\n        if ok {\n            return nil\n        }\n        return err\n    }\n    return nil\n} \n```", "```\nfunc main() {\n    skel.PluginMain(cmdAdd, cmdCheck, cmdDel, version.All, bv.BuildString(\"loopback\"))\n} \n```", "```\nfunc PluginMain(cmdAdd, cmdCheck, cmdDel func(_ *CmdArgs) error, versionInfo version.PluginInfo, about string) {\n    if e := PluginMainWithError(cmdAdd, cmdCheck, cmdDel, versionInfo, about); e != nil {\n        if err := e.Print(); err != nil {\n            log.Print(\"Error writing error JSON to stdout: \", err)\n        }\n        os.Exit(1)\n    }\n} \n```", "```\nfunc PluginMainWithError(cmdAdd, cmdCheck, cmdDel func(_ *CmdArgs) error, versionInfo version.PluginInfo, about string) *types.Error {\n    return (&dispatcher{\n        Getenv: os.Getenv,\n        Stdin:  os.Stdin,\n        Stdout: os.Stdout,\n        Stderr: os.Stderr,\n    }).pluginMain(cmdAdd, cmdCheck, cmdDel, versionInfo, about)\n} \n```", "```\nfunc (t *dispatcher) pluginMain(cmdAdd, cmdCheck, cmdDel func(_ *CmdArgs) error, versionInfo version.PluginInfo, about string) *types.Error {\n    cmd, cmdArgs, err := t.getCmdArgsFromEnv()\n    if err != nil {\n        // Print the about string to stderr when no command is set\n        if err.Code == types.ErrInvalidEnvironmentVariables && t.Getenv(\"CNI_COMMAND\") == \"\" && about != \"\" {\n            _, _ = fmt.Fprintln(t.Stderr, about)\n            _, _ = fmt.Fprintf(t.Stderr, \"CNI protocol versions supported: %s\\n\", strings.Join(versionInfo.SupportedVersions(), \", \"))\n            return nil\n        }\n        return err\n    }\n    if cmd != \"VERSION\" {\n        if err = validateConfig(cmdArgs.StdinData); err != nil {\n            return err\n        }\n        if err = utils.ValidateContainerID(cmdArgs.ContainerID); err != nil {\n            return err\n        }\n        if err = utils.ValidateInterfaceName(cmdArgs.IfName); err != nil {\n            return err\n        }\n    }\n    switch cmd {\n    case \"ADD\":\n        err = t.checkVersionAndCall(cmdArgs, versionInfo, cmdAdd)\n    case \"CHECK\":\n        configVersion, err := t.ConfVersionDecoder.Decode(cmdArgs.StdinData)\n        if err != nil {\n            return types.NewError(types.ErrDecodingFailure, err.Error(), \"\")\n        }\n        if gtet, err := version.GreaterThanOrEqualTo(configVersion, \"0.4.0\"); err != nil {\n            return types.NewError(types.ErrDecodingFailure, err.Error(), \"\")\n        } else if !gtet {\n            return types.NewError(types.ErrIncompatibleCNIVersion, \"config version does not allow CHECK\", \"\")\n        }\n        for _, pluginVersion := range versionInfo.SupportedVersions() {\n            gtet, err := version.GreaterThanOrEqualTo(pluginVersion, configVersion)\n            if err != nil {\n                return types.NewError(types.ErrDecodingFailure, err.Error(), \"\")\n            } else if gtet {\n                if err := t.checkVersionAndCall(cmdArgs, versionInfo, cmdCheck); err != nil {\n                    return err\n                }\n                return nil\n            }\n        }\n        return types.NewError(types.ErrIncompatibleCNIVersion, \"plugin version does not allow CHECK\", \"\")\n    case \"DEL\":\n        err = t.checkVersionAndCall(cmdArgs, versionInfo, cmdDel)\n    case \"VERSION\":\n        if err := versionInfo.Encode(t.Stdout); err != nil {\n            return types.NewError(types.ErrIOFailure, err.Error(), \"\")\n        }\n    default:\n        return types.NewError(types.ErrInvalidEnvironmentVariables, fmt.Sprintf(\"unknown CNI_COMMAND: %v\", cmd), \"\")\n    }\n    return err\n} \n```", "```\ntype NetConf struct {\n    types.NetConf\n    BrName       string `json:\"bridge\"`\n    IsGW         bool   `json:\"isGateway\"`\n    IsDefaultGW  bool   `json:\"isDefaultGateway\"`\n    ForceAddress bool   `json:\"forceAddress\"`\n    IPMasq       bool   `json:\"ipMasq\"`\n    MTU          int    `json:\"mtu\"`\n    HairpinMode  bool   `json:\"hairpinMode\"`\n    PromiscMode  bool   `json:\"promiscMode\"`\n    Vlan         int    `json:\"vlan\"`\n    MacSpoofChk  bool   `json:\"macspoofchk,omitempty\"`\n    EnableDad    bool   `json:\"enabledad,omitempty\"`\n    Args struct {\n        Cni BridgeArgs `json:\"cni,omitempty\"`\n    } `json:\"args,omitempty\"`\n    RuntimeConfig struct {\n        Mac string `json:\"mac,omitempty\"`\n    } `json:\"runtimeConfig,omitempty\"`\n    mac string\n} \n```", "```\nn, cniVersion, err := loadNetConf(args.StdinData, args.Args) \n```", "```\nbr, brInterface, err := setupBridge(n)\n    if err != nil {\n        return err\n    }\n    netns, err := ns.GetNS(args.Netns)\n    if err != nil {\n        return fmt.Errorf(\"failed to open netns %q: %v\", args.Netns, err)\n    }\n    defer netns.Close()\n    hostInterface, containerInterface, err := setupVeth(netns, br, args.IfName, n.MTU, n.HairpinMode, n.Vlan)\n    if err != nil {\n        return err\n    } \n```", "```\n // Assume L2 interface only\n    result := &current.Result{\n        CNIVersion: current.ImplementedSpecVersion,\n        Interfaces: []*current.Interface{\n            brInterface,\n            hostInterface,\n            containerInterface,\n        },\n    }\n    if n.MacSpoofChk {\n        ...\n    }\n\n    if isLayer3 {\n        // run the IPAM plugin and get back the config to apply\n        r, err := ipam.ExecAdd(n.IPAM.Type, args.StdinData)\n        if err != nil {\n            return err\n        }\n        // release IP in case of failure\n        defer func() {\n            if !success {\n                ipam.ExecDel(n.IPAM.Type, args.StdinData)\n            }\n        }()\n        // Convert whatever the IPAM result was into the current Result type\n        ipamResult, err := current.NewResultFromResult(r)\n        if err != nil {\n            return err\n        }\n        result.IPs = ipamResult.IPs\n        result.Routes = ipamResult.Routes\n        result.DNS = ipamResult.DNS\n        if len(result.IPs) == 0 {\n            return errors.New(\"IPAM plugin returned missing IP config\")\n        }\n        // Gather gateway information for each IP family\n        gwsV4, gwsV6, err := calcGateways(result, n)\n        if err != nil {\n            return err\n        }\n        // Configure the container hardware address and IP address(es)\n        if err := netns.Do(func(_ ns.NetNS) error {\n            ...\n        }\n        // check bridge port state\n        retries := []int{0, 50, 500, 1000, 1000}\n        for idx, sleep := range retries {\n            ...\n        }\n\n        if n.IsGW {\n            ...\n        }\n        if n.IPMasq {\n            ...\n        }\n    } else {\n        ...\n    } \n```", "```\n // Refetch the bridge since its MAC address may change when the first\n    // veth is added or after its IP address is set\n    br, err = bridgeByName(n.BrName)\n    if err != nil {\n        return err\n    }\n    brInterface.Mac = br.Attrs().HardwareAddr.String()\n    // Return an error requested by testcases, if any\n    if debugPostIPAMError != nil {\n        return debugPostIPAMError\n    }\n    // Use incoming DNS settings if provided, otherwise use the\n    // settings that were already configued by the IPAM plugin\n    if dnsConfSet(n.DNS) {\n        result.DNS = n.DNS\n    }\n    success = true\n    return types.PrintResult(result, cniVersion) \n```"]