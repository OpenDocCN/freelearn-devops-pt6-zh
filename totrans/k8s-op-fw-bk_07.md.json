["```\n// NginxOperatorStatus defines the observed state of NginxOperator\n```", "```\ntype NginxOperatorStatus struct {\n```", "```\n   // Conditions is the list of status condition updates\n```", "```\n   Conditions []metav1.Condition `json:\"conditions\"`\n```", "```\n}\n```", "```\nproperties:\n```", "```\n  conditions:\n```", "```\n    description: Conditions is the list of the most recent status condition\n```", "```\n      updates\n```", "```\n    items:\n```", "```\n      description: \"Condition contains details for one aspect \n```", "```\n                   of the current state of this API Resource. \n```", "```\n                   --- This struct is intended for direct use \n```", "```\n                   as an array at the field path \n```", "```\n                   .status.conditions.\"\n```", "```\n      properties:\n```", "```\n        lastTransitionTime:\n```", "```\n          description: lastTransitionTime is the last time the \n```", "```\n                       condition transitioned from one status \n```", "```\n                       to another. This should be when the \n```", "```\n                       underlying condition changed.  If that \n```", "```\n                       is not known, then using the time when \n```", "```\n                       the API field changed is acceptable.\n```", "```\n          format: date-time\n```", "```\n          type: string\n```", "```\n        message:\n```", "```\n          description: message is a human readable message \n```", "```\n                       indicating details about the \n```", "```\n                       transition. This may be an empty \n```", "```\n                       string.\n```", "```\n          maxLength: 32768\n```", "```\n          type: string\n```", "```\n...\n```", "```\n        status:\n```", "```\n          description: status of the condition, one of True, \n```", "```\n                       False, Unknown.\n```", "```\n          enum:\n```", "```\n          - \"True\"\n```", "```\n          - \"False\"\n```", "```\n          - Unknown\n```", "```\n          type: string\n```", "```\n        type:\n```", "```\n          description: type of condition in CamelCase or in \n```", "```\n                       foo.example.com/CamelCase. --- Many \n```", "```\n                       .condition.type values are consistent \n```", "```\n                       across resources like Available, but \n```", "```\n                       because arbitrary conditions can be \n```", "```\n                       useful (see .node.status.conditions), \n```", "```\n                       the ability to deconflict is important. \n```", "```\n                       The regex it matches is \n```", "```\n                     (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n```", "```\n          maxLength: 316\n```", "```\n          pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$\n```", "```\n          type: string\n```", "```\n      required:\n```", "```\n      - lastTransitionTime\n```", "```\n      - message\n```", "```\n      - reason\n```", "```\n      - status\n```", "```\n      - type\n```", "```\n      type: object\n```", "```\n    type: array\n```", "```\nrequired:\n```", "```\n- conditions\n```", "```\ntype: object\n```", "```\nfunc (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n```", "```\n   logger := log.FromContext(ctx)\n```", "```\n   operatorCR := &operatorv1alpha1.NginxOperator{}\n```", "```\n   err := r.Get(ctx, req.NamespacedName, operatorCR)\n```", "```\n   if err != nil && errors.IsNotFound(err) {\n```", "```\n      logger.Info(\"Operator resource object not found.\")\n```", "```\n      return ctrl.Result{}, nil\n```", "```\n   } else if err != nil {\n```", "```\n      logger.Error(err, \"Error getting operator resource object\")\n```", "```\n      meta.SetStatusCondition(&operatorCR.Status.Conditions, metav1.Condition{\n```", "```\n         Type:               \"OperatorDegraded\",\n```", "```\n         Status:             metav1.ConditionTrue,\n```", "```\n         Reason:             \"OperatorResourceNotAvailable\",\n```", "```\n         LastTransitionTime: metav1.NewTime(time.Now()),\n```", "```\n         Message:            fmt.Sprintf(\"unable to get operator custom resource: %s\", err.Error()),\n```", "```\n      })\n```", "```\n      return ctrl.Result{}, utilerrors.NewAggregate([]error{err, r.Status().Update(ctx, operatorCR)})\n```", "```\n   }\n```", "```\n   deployment := &appsv1.Deployment{}\n```", "```\n   create := false\n```", "```\n   err = r.Get(ctx, req.NamespacedName, deployment)\n```", "```\n   if err != nil && errors.IsNotFound(err) {\n```", "```\n      create = true\n```", "```\n      deployment = assets.GetDeploymentFromFile(\"assets/nginx_deployment.yaml\")\n```", "```\n   } else if err != nil {\n```", "```\n      logger.Error(err, \"Error getting existing Nginx deployment.\")\n```", "```\n      meta.SetStatusCondition(&operatorCR.Status.Conditions, metav1.Condition{\n```", "```\n         Type:               \"OperatorDegraded\",\n```", "```\n         Status:             metav1.ConditionTrue,\n```", "```\n         Reason:             \"OperandDeploymentNotAvailable\",\n```", "```\n         LastTransitionTime: metav1.NewTime(time.Now()),\n```", "```\n         Message:            fmt.Sprintf(\"unable to get operand deployment: %s\", err.Error()),\n```", "```\n      })\n```", "```\n      return ctrl.Result{}, utilerrors.NewAggregate([]error{err, r.Status().Update(ctx, operatorCR)})\n```", "```\n   }\n```", "```\n   deployment.Namespace = req.Namespace\n```", "```\n   deployment.Name = req.Name\n```", "```\n   if operatorCR.Spec.Replicas != nil {\n```", "```\n      deployment.Spec.Replicas = operatorCR.Spec.Replicas\n```", "```\n   }\n```", "```\n   if operatorCR.Spec.Port != nil {\n```", "```\n      deployment.Spec.Template.Spec.Containers[0].Ports[0].ContainerPort = *operatorCR.Spec.Port\n```", "```\n   }\n```", "```\n   ctrl.SetControllerReference(operatorCR, deployment, r.Scheme)\n```", "```\n   if create {\n```", "```\n      err = r.Create(ctx, deployment)\n```", "```\n   } else {\n```", "```\n      err = r.Update(ctx, deployment)\n```", "```\n   }\n```", "```\nif err != nil {\n```", "```\n   meta.SetStatusCondition(&operatorCR.Status.Conditions, metav1.Condition{\n```", "```\n      Type:               \"OperatorDegraded\",\n```", "```\n      Status:             metav1.ConditionTrue,\n```", "```\n      Reason:             \"OperandDeploymentFailed\",\n```", "```\n      LastTransitionTime: metav1.NewTime(time.Now()),\n```", "```\n      Message:            fmt.Sprintf(\"unable to update operand deployment: %s\", err.Error()),\n```", "```\n   })\n```", "```\n   return ctrl.Result{}, utilerrors.NewAggregate([]error{err, r.Status().Update(ctx, operatorCR)})\n```", "```\n}\n```", "```\n   meta.SetStatusCondition(&operatorCR.Status.Conditions, metav1.Condition{\n```", "```\n      Type:               \"OperatorDegraded\",\n```", "```\n      Status:             metav1.ConditionFalse,\n```", "```\n      Reason:             \"OperatorSucceeded\",\n```", "```\n      LastTransitionTime: metav1.NewTime(time.Now()),\n```", "```\n      Message:            \"operator successfully reconciling\",\n```", "```\n   })\n```", "```\n   return ctrl.Result{}, utilerrors.NewAggregate([]error{err, r.Status().Update(ctx, operatorCR)})\n```", "```\n}\n```", "```\nconst (\n```", "```\n ReasonCRNotAvailable  = \"OperatorResourceNotAvailable\"\n```", "```\n ReasonDeploymentNotAvailable = \"OperandDeploymentNotAvailable\"\n```", "```\n   ReasonOperandDeploymentFailed = \"OperandDeploymentFailed\"\n```", "```\n   ReasonSucceeded               = \"OperatorSucceeded\"\n```", "```\n)\n```", "```\n$ kubectl describe nginxoperators/cluster\n```", "```\nName:         cluster\n```", "```\nNamespace:    nginx-operator-system\n```", "```\nAPI Version:  operator.example.com/v1alpha1\n```", "```\nKind:         NginxOperator\n```", "```\nMetadata:\n```", "```\n  Creation Timestamp:  2022-01-20T21:47:32Z\n```", "```\n  Generation:          1\n```", "```\n...\n```", "```\nSpec:\n```", "```\n  Replicas:  1\n```", "```\nStatus:\n```", "```\n  Conditions:\n```", "```\n    Last Transition Time:  2022-01-20T21:47:32Z\n```", "```\n    Message:               operator successfully reconciling\n```", "```\n    Reason:                OperatorSucceeded\n```", "```\n    Status:                False\n```", "```\n    Type:                  OperatorDegraded\n```", "```\napiVersion: operators.coreos.com/v1\n```", "```\nkind: OperatorCondition\n```", "```\nmetadata:\n```", "```\n  name: sample-operator\n```", "```\n  namespace: operator-ns\n```", "```\nstatus:\n```", "```\n  conditions:\n```", "```\n  - type: Upgradeable\n```", "```\n    status: False\n```", "```\n    reason: \"OperatorBusy\"\n```", "```\n    message: \"Operator is currently busy with a critical task\"\n```", "```\n    lastTransitionTime: \"2022-01-19T12:00:00Z\"\n```", "```\nimport (\n```", "```\n...\n```", "```\n   apiv2 \"github.com/operator-framework/api/pkg/operators/v2\"\n```", "```\n   \"github.com/operator-framework/operator-lib/conditions\"\n```", "```\n)\n```", "```\nfunc (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n```", "```\n...\n```", "```\n  condition, err := conditions.InClusterFactory{r.Client}.\n```", "```\n   NewCondition(apiv2.ConditionType(apiv2.Upgradeable))\n```", "```\n  if err != nil {\n```", "```\n   return ctrl.Result{}, err\n```", "```\n  }\n```", "```\n  err = condition.Set(ctx, metav1.ConditionTrue,\n```", "```\n   conditions.WithReason(\"OperatorUpgradeable\"),\n```", "```\n   conditions.WithMessage(\"The operator is upgradeable\"))\n```", "```\n  if err != nil {\n```", "```\n   return ctrl.Result{}, err\n```", "```\n  }\n```", "```\n...\n```", "```\n}\n```", "```\napiVersion: operators.coreos.com/v1\n```", "```\nkind: OperatorCondition\n```", "```\nmetadata:\n```", "```\n  name: sample-operator\n```", "```\n  namespace: operator-ns\n```", "```\nspec:\n```", "```\n  overrides:\n```", "```\n  - type: Upgradeable\n```", "```\n    status: True\n```", "```\n    reason: \"OperatorIsStable\"\n```", "```\n    message: \"Forcing an upgrade to bypass bug state\"\n```", "```\nstatus:\n```", "```\n  conditions:\n```", "```\n  - type: Upgradeable\n```", "```\n    status: False\n```", "```\n    reason: \"OperatorBusy\"\n```", "```\n    message: \"Operator is currently busy with a critical task\"\n```", "```\n    lastTransitionTime: \"2022-01-19T12:00:00Z\"\n```", "```\npackage metrics\n```", "```\nimport (\n```", "```\n   \"github.com/prometheus/client_golang/prometheus\"\n```", "```\n   \"sigs.k8s.io/controller-runtime/pkg/metrics\"\n```", "```\n)\n```", "```\nvar (\n```", "```\n   ReconcilesTotal = prometheus.NewCounter(\n```", "```\n      prometheus.CounterOpts{\n```", "```\n         Name: \"reconciles_total\",\n```", "```\n         Help: \"Number of total reconciliation attempts\",\n```", "```\n      },\n```", "```\n   )\n```", "```\n)\n```", "```\nfunc init() {\n```", "```\n   metrics.Registry.MustRegister(ReconcilesTotal)\n```", "```\n}\n```", "```\nimport (\n```", "```\n...\n```", "```\n  \"github.com/sample/nginx-operator/controllers/metrics\"\n```", "```\n...\n```", "```\n)\n```", "```\nfunc (r *NginxOperatorReconciler) Reconcile(...) (...) {\n```", "```\n  metrics.ReconcilesTotal.Inc()\n```", "```\n  ...\n```", "```\n}\n```", "```\nfunc main() {\n```", "```\n...\n```", "```\n   var enableLeaderElection bool\n```", "```\n   flag.BoolVar(&enableLeaderElection, \"leader-elect\", false,\n```", "```\n      \"Enable leader election for controller manager. \"+\n```", "```\n         \"Enabling this will ensure there is only one active controller manager.\")\n```", "```\n...\n```", "```\n   mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n```", "```\n...\n```", "```\n      HealthProbeBindAddress: probeAddr,\n```", "```\n      LeaderElection:         enableLeaderElection,\n```", "```\n      LeaderElectionID:       \"df4c7b26.example.com\",\n```", "```\n   })\n```", "```\n   if err != nil {\n```", "```\n      setupLog.Error(err, \"unable to start manager\")\n```", "```\n      os.Exit(1)\n```", "```\n   }\n```", "```\nimport (\n```", "```\n   \"github.com/operator-framework/operator-lib/leader\"\n```", "```\n   ...\n```", "```\n   )\n```", "```\nvar (\n```", "```\n   ...\n```", "```\n   setupLog = ctrl.Log.WithName(\"setup\")\n```", "```\n   )\n```", "```\nfunc main() {\n```", "```\n   ...\n```", "```\n   var enableLeaderElection bool\n```", "```\n   flag.BoolVar(&enableLeaderElection, \"leader-elect\", false,\n```", "```\n      \"Enable leader election for controller manager. \"+\n```", "```\n         \"Enabling this will ensure there is only one active controller manager.\")\n```", "```\n   ...\n```", "```\n   if !enableLeaderElection {\n```", "```\n      err := leader.Become(context.TODO(), \"nginx-lock\")\n```", "```\n      if err != nil {\n```", "```\n         setupLog.Error(err, \"unable to acquire leader lock\")\n```", "```\n         os.Exit(1)\n```", "```\n      }\n```", "```\n   }\n```", "```\n   mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n```", "```\n      ...\n```", "```\n      LeaderElection:         enableLeaderElection,\n```", "```\n      LeaderElectionID:       \"df4c7b26.example.com\",\n```", "```\n   })\n```", "```\nimport (\n```", "```\n  ...\n```", "```\n  \"sigs.k8s.io/controller-runtime/pkg/healthz\"\n```", "```\n)\n```", "```\nfunc main() {\n```", "```\n...\n```", "```\n   mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(),   ctrl.Options{\n```", "```\n   Scheme:                 scheme,\n```", "```\n   MetricsBindAddress:     metricsAddr,\n```", "```\n   Port:                   9443,\n```", "```\n   HealthProbeBindAddress: probeAddr,\n```", "```\n   LeaderElection:         enableLeaderElection,\n```", "```\n   LeaderElectionID:       \"df4c7b26.example.com\",\n```", "```\n   })\n```", "```\n...\n```", "```\n    if err := mgr.AddHealthzCheck(\"healthz\", healthz.Ping); err != nil {\n```", "```\n      setupLog.Error(err, \"unable to set up health check\")\n```", "```\n      os.Exit(1)\n```", "```\n   }\n```", "```\n   if err := mgr.AddReadyzCheck(\"readyz\", healthz.Ping); err != nil {\n```", "```\n      setupLog.Error(err, \"unable to set up ready check\")\n```", "```\n      os.Exit(1)\n```", "```\n   }\n```", "```\n   setupLog.Info(\"starting manager\")\n```", "```\n   if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {\n```", "```\n      setupLog.Error(err, \"problem running manager\")\n```", "```\n      os.Exit(1)\n```", "```\n   }\n```", "```\n}\n```", "```\nfunc(*http.Request) error\n```"]