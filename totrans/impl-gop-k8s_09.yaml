- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps for Azure and AWS Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the evolving landscape of cloud computing, the adoption of GitOps practices
    stands out as a transformative approach to streamlining the deployment and management
    of applications and infrastructure. This chapter embarks on a detailed exploration
    of applying GitOps principles within the robust ecosystems of Azure and **Amazon
    Web Services** (**AWS**), two of the world’s leading cloud platforms. This chapter
    aims to unravel the complexities of leveraging cloud-native capabilities, providing
    readers with a comprehensive understanding of how to harness the full potential
    of **Azure Kubernetes Service** (**AKS**), **Azure DevOps**, **Elastic Kubernetes
    Service** (**EKS**), and **AWS CodePipeline** in a GitOps workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Through real-world case studies, expert insights, and practical guidance, we
    delve into the nuances of setting up **continuous integration/continuous deployment**
    (**CI/CD**) pipelines, managing configurations, and ensuring consistent, automated
    deployments across these platforms. By the end of this chapter, readers will be
    equipped with the knowledge to implement efficient, secure, and scalable GitOps
    workflows, marking a significant step forward in their cloud-native journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll focus on these key areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud GitOps essentials – Azure and AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment on Azure and AWS with GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Azure and AWS in GitOps workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps applications in cloud environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps strategies for Azure and AWS deployments for Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before delving into the intricacies of implementing GitOps for Azure and AWS
    deployments, it’s important to build upon the foundational knowledge established
    in the preceding chapters of this book. The principles of GitOps, containerization
    technologies such as Docker, Kubernetes concepts, and CI/CD principles discussed
    earlier provide a solid starting point for understanding the advanced applications
    highlighted in this chapter. Additionally, access to Azure and AWS accounts and
    a basic understanding of their services will be crucial for following along with
    practical exercises and case studies. Familiarity with version control systems,
    especially Git, will not only enhance comprehension but also facilitate the effective
    application of the GitOps practices detailed in our exploration of cloud-native
    deployments across Azure and AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant code and resource files for this chapter can be found in the `Chapter09`
    folder of our dedicated GitHub repository: [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).'
  prefs: []
  type: TYPE_NORMAL
- en: Azure and AWS accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this book delves into the intricacies of implementing GitOps within Azure
    and AWS ecosystems, providing a comprehensive exploration of their respective
    tools and practices, a detailed, step-by-step guide for creating Azure and AWS
    accounts falls beyond our scope. To embark on the practical journey of applying
    the concepts and examples outlined in the upcoming sections, it is essential for
    readers to have active Azure and AWS accounts. We encourage you to consult the
    official documentation provided by Azure at [https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/),
    and AWS at [https://aws.amazon.com/](https://aws.amazon.com/), for the most current
    and detailed instructions on setting up your accounts. These accounts are indispensable
    for deploying the examples and applying the GitOps practices discussed, serving
    as the foundation upon which you can build and experiment with the cloud-native
    capabilities of Azure and AWS.
  prefs: []
  type: TYPE_NORMAL
- en: In the forthcoming section, we will assume that readers possess an active and
    properly configured Azure or AWS account, along with basic knowledge of the **Azure
    CLI**, **AWS CLI**, or their respective web portals.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud GitOps essentials – Azure and AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the cloud computing landscape continues to evolve, the adoption of GitOps
    principles has become a cornerstone for achieving operational excellence and automation
    in **cloud-native deployments**. This chapter introduces the GitOps essentials
    for both Azure and AWS, showcasing how these leading cloud platforms support the
    seamless integration of GitOps workflows to enhance deployment speed, reliability,
    and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native developments and deployments
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native development represents a transformative approach to building and
    deploying applications that fully exploit the advantages of the cloud computing
    model. At its core, it involves leveraging managed services, microservices architectures,
    containers, and declarative APIs to create applications that are scalable, resilient,
    and easily updated. This paradigm shift encourages organizations to move away
    from monolithic architectures, enabling faster development cycles, enhanced scalability,
    and greater flexibility in responding to market demands. Cloud-native technologies,
    including Kubernetes, Docker, and serverless functions, play pivotal roles in
    this ecosystem, providing the tools necessary for developers to build applications
    that are not only highly available and fault tolerant but also capable of thriving
    in the dynamic environment of the cloud. By adopting cloud-native practices, businesses
    can accelerate their digital transformation journeys, enhancing their ability
    to innovate and compete in an increasingly digital world.
  prefs: []
  type: TYPE_NORMAL
- en: Azure and AWS each offer unique tools and services – such as AKS, Azure DevOps,
    EKS, and AWS CodePipeline – that empower teams to implement GitOps practices effectively.
    Through a comprehensive exploration of these essentials, readers will gain insight
    into leveraging the cloud-native capabilities of Azure and AWS to streamline their
    deployment processes, ensuring that infrastructure and application management
    is as efficient and error free as possible. This unified approach provides a solid
    foundation for understanding how GitOps can be optimally applied within the distinct
    but complementary ecosystems of Azure and AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Azure GitOps essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure, with its rich ecosystem and integration capabilities, offers fertile
    ground for implementing GitOps principles, enhancing automation, consistency,
    and scalability in deployments. At the heart of Azure’s GitOps capabilities lies
    the AKS, which simplifies the deployment, management, and operations of Kubernetes,
    enabling a seamless GitOps workflow. Coupled with **Azure DevOps** – a suite that
    provides a range of tools including **Azure Repos** for Git hosting and **Azure
    Pipelines** for CI/CD – developers can establish a robust GitOps pipeline that
    ensures continuous integration and deployment with minimal manual intervention.
    Leveraging these services, users can maintain a high degree of control and visibility
    over their deployments, benefiting from the declarative nature of GitOps to manage
    infrastructure and applications efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure DevOps represents a suite of development tools provided by Microsoft,
    designed to support the complete software development life cycle. At its core,
    Azure DevOps facilitates CI/CD practices, enabling teams to automate the build,
    test, and deployment phases of their applications. Specifically, in the context
    of GitOps, Azure DevOps becomes a powerful ally, allowing teams to manage infrastructure
    and application code in a Git repository, automatically apply changes to Kubernetes
    environments, and maintain a consistent state across development, testing, and
    production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For implementing Kubernetes GitOps deployment with Azure DevOps, the following
    base steps can guide you through the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up a Git repository**: Begin by setting up a Git repository within Azure
    Repos or any other Git hosting service. This repository will hold your Kubernetes
    manifest files, representing the desired state of your application and infrastructure
    in a declarative manner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create Azure Pipelines**: Utilize Azure Pipelines to define your CI/CD workflows.
    For GitOps, the CD pipeline plays a crucial role. It should be configured to trigger
    automatically upon changes to the main branch of your repository, where your Kubernetes
    manifest files are stored.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define environments**: In Azure DevOps, define environments to represent
    your deployment targets, such as development, staging, and production. These environments
    can be linked to your Kubernetes clusters managed by AKS or any Kubernetes clusters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Automate deployment with Helm or Kustomize**: Use Helm charts or Kustomize
    for managing complex Kubernetes applications. Azure Pipelines can be configured
    to use Helm or Kustomize to package and deploy applications, adhering to the GitOps
    principle of declarative configuration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubectl`, Helm, or a GitOps tool such as Flux or Argo CD. This step involves
    fetching the latest configuration from your Git repository and applying it to
    the designated environment, ensuring that the actual state matches the desired
    state declared in Git.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitor and rollback**: Finally, leverage Azure Monitor and other observability
    tools to keep an eye on your deployments. In case of any issues, your GitOps workflow
    should support easy rollbacks by simply reverting changes in your Git repository
    and re-running the pipeline to restore the previous state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes deployment with Azure DevOps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we embark on a hands-on journey to deploy a Kubernetes cluster
    on Azure, leveraging the powerful combination of Terraform, **Azure Container
    Registry** (**ACR**), and Azure DevOps pipelines. We’ll start by creating a straightforward
    AKS cluster and an ACR, and then establish a system-managed identity between them
    to facilitate secure interactions. The climax of our journey involves orchestrating
    the deployment of this image to the AKS cluster using a meticulously crafted Azure
    DevOps pipeline. This practical walkthrough is designed to illuminate the seamless
    integration of these components, illustrating how they converge to streamline
    the deployment process within a GitOps framework. Through this example, readers
    will gain a comprehensive understanding of deploying applications to Kubernetes
    using Azure’s robust ecosystem. The following are the necessary steps to successfully
    complete this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real-world scenario, executing the Terraform script would involve creating
    an **Azure service principal** with the appropriate permissions to provision resources.
    However, for this example, we are simplifying the process by using an Azure administrator
    account with full authorizations. It’s important to note that this approach is
    not recommended for production environments due to security concerns. Log in to
    Azure by typing the following command in a new terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To initialize Terraform, we use the `terraform init` command. For this step,
    we will utilize the `main.tf` and `versions.tf` Terraform files located in the
    `iac/azure` folder of the GitHub repository accompanying this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why Terraform?
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is a preferred tool for **infrastructure as code** (**IaC**) because
    it uses a declarative configuration language, which simplifies defining and managing
    complex environments by specifying the desired end state of the infrastructure.
    It supports multiple cloud providers, including AWS, Azure, and Google Cloud,
    enabling consistent IaC practices across different platforms. Additionally, Terraform’s
    state management feature keeps track of the current infrastructure status, allowing
    it to efficiently plan and apply changes while minimizing errors. Its extensive
    module ecosystem and robust community support further enhance its capability to
    automate and manage infrastructure at scale.
  prefs: []
  type: TYPE_NORMAL
- en: The `main.tf` file orchestrates the setup of essential Azure services for a
    Kubernetes-based deployment. Initially, it establishes a resource group called
    `aks-k8s-deployments-rg` in the `switzerlandnorth` region, serving as a container
    for all related Azure resources. Following this, an ACR named `aksgitops3003204acr`
    is provisioned within the same resource group and region, with the `AKS` cluster
    named `aksgitopscluster`, is then created, featuring a single default node pool
    configured with minimal resources to ensure cost efficiency. The cluster is set
    up with a system-assigned identity, streamlining the authentication process across
    Azure services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the Terraform configuration secures the integration between the AKS
    cluster and the ACR by assigning the necessary role permissions, enabling seamless
    container image pulls from the registry to the Kubernetes environment. Feel free
    to modify the names of the resource group or ACR and the region where the resources
    are deployed. In a terminal window, execute the following commands. The entire
    process will take a few minutes to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Await the successful provisioning of resources, then integrate the `kubectl`
    configuration for cluster management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the necessary steps to create a new Azure DevOps project
    and properly set up an Azure DevOps pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish a new Azure DevOps project, as illustrated in *Figure 9**.1*, within
    your existing Azure account to manage the CI/CD pipeline and project artifacts,
    opting for a `gitops-k8s-deployment`, and optionally add a project description.
    Select **Private** for **Visibility**, and then click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Azure DevOps window for creating a new project](img/B22100_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The Azure DevOps window for creating a new project
  prefs: []
  type: TYPE_NORMAL
- en: In the **Where is your code?** window, select **Pick** next to the GitHub option
    to choose the correct GitHub repository you wish to associate with the Azure DevOps
    project you previously created. You can directly use the GitHub repository associated
    with this chapter or select one that you have created, as seen in *Figure 9**.2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Selecting a repository panel](img/B22100_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Selecting a repository panel
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we’re prepared to configure the pipeline. In the configuration
    panel, select **Deploy to Azure Kubernetes Service** as illustrated in *Figure
    9**.3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Configure your pipeline section of the wizard](img/B22100_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Configure your pipeline section of the wizard
  prefs: []
  type: TYPE_NORMAL
- en: When prompted, as visible in *Figure 9**.4*, select the Azure subscription where
    the AKS cluster was previously configured and deployed using the Terraform script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Popup window for selecting the Azure subscription](img/B22100_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Popup window for selecting the Azure subscription
  prefs: []
  type: TYPE_NORMAL
- en: In the `weather-app-namespace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Deploy to AKS settings window](img/B22100_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Deploy to AKS settings window
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `src` subdirectory, we need to edit the last line of the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We edit the preceding code this way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, click the **Save and run** button, leave the default values as they are,
    and click the **Save and run** button again. The pipeline will be triggered as
    illustrated in *Figure 9**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Example of a triggered Azure DevOps pipeline](img/B22100_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Example of a triggered Azure DevOps pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Build** stage to view more details, as illustrated in *Figure
    9**.7*. This time, there’s no need to build the image locally and then push it
    to the registry, as everything is handled within the Azure DevOps pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Details of building and pushing an image to the container registry](img/B22100_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Details of building and pushing an image to the container registry
  prefs: []
  type: TYPE_NORMAL
- en: If required, authorize permissions for the pipeline, as illustrated in *Figure
    9**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Popup window to grant permissions for the current and subsequent
    runs of the pipeline](img/B22100_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Popup window to grant permissions for the current and subsequent
    runs of the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: At this point, after a few seconds, the pipeline should complete successfully,
    as illustrated in *Figure 9**.9*. An email should be sent to your account notifying
    you of the pipeline’s successful completion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Successful completion of the pipeline](img/B22100_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Successful completion of the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the deployment, you can utilize tools such as Visual Studio Code
    or execute the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this juncture, we can execute a `port-forward` command to display the app
    in the browser, as illustrated in *Figure 9**.10*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10 – A screenshot of weather-app running as a container on AKS](img/B22100_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – A screenshot of weather-app running as a container on AKS
  prefs: []
  type: TYPE_NORMAL
- en: Now, to explore the CI/CD capabilities of Azure DevOps, you could, for example,
    edit the `data.csv` file, changing the value for the `2023-01-04` day from `4.0`
    to, say, `5.0` (see *Figure 9**.11*). This file can be edited directly in your
    GitHub repository or by cloning the repository locally and using Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The updated data.csv file used as a data source from our weather-app
    application](img/B22100_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – The updated data.csv file used as a data source from our weather-app
    application
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the pipeline will be automatically triggered once more, as illustrated
    in *Figure 9**.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – New execution of the pipeline after pushing the updated data.csv
    file](img/B22100_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – New execution of the pipeline after pushing the updated data.csv
    file
  prefs: []
  type: TYPE_NORMAL
- en: By executing a new `port-forward` command targeting the newly deployed pod,
    we will have the opportunity to visualize the updated chart (see *Figure 9**.13*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The weather-app application after a new deployment, triggered
    by pushing the updated data.csv file](img/B22100_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – The weather-app application after a new deployment, triggered
    by pushing the updated data.csv file
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid incurring unnecessary costs, remember to destroy all Azure resources
    created for this example by typing the following command (or using the Azure portal):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! You have successfully completed your Azure DevOps CI/CD pipeline
    with deployment to AKS using an ACR instance. Now, it’s time to transition to
    the AWS ecosystem to explore how things operate on that side.
  prefs: []
  type: TYPE_NORMAL
- en: AWS GitOps essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS embraces the GitOps model by offering a suite of services designed to facilitate
    the management of cloud-native applications and infrastructure with high efficiency
    and reliability. The EKS stands out as AWS’s managed Kubernetes service, compared
    to other major cloud providers’ offerings such as **Google Kubernetes Engine**
    (**GKE**) from Google Cloud and AKS from Microsoft Azure. Each provides similar
    functionalities but with unique features tailored to their respective ecosystems,
    optimizing the deployment process and ensuring the automatic scaling and management
    of containerized applications. Integrating EKS with AWS CodePipeline, a service
    that automates the build, test, and deploy phases of your release process, enables
    a GitOps approach where the entire infrastructure is treated as code. This integration
    empowers teams to implement CD practices, allowing for rapid and safe application
    updates. AWS’s commitment to GitOps is evident in its tooling and services, which
    support immutable infrastructure, automated deployments, and detailed monitoring,
    aligning with the GitOps principles of declarative configuration and version control.
  prefs: []
  type: TYPE_NORMAL
- en: AWS CodePipepline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**AWS CodePipeline** (https://aws.amazon.com/codepipeline/) is a fully managed
    CI/CD service that automates the build, test, and deployment phases of your release
    process. It allows you to create pipelines that automate the steps required to
    release your software changes continuously. With CodePipeline, you can define
    your release process as a series of stages, where each stage performs a specific
    action, such as fetching source code from a version control system, building and
    testing your application, and deploying it to your infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features of AWS CodePipeline is its flexibility and integration
    with other AWS services. You can easily integrate CodePipeline with services such
    as **AWS CodeBuild** for building your application, **AWS CodeDeploy** for deploying
    it to EC2 instances or **AWS Lambda functions**, and **AWS Elastic Beanstalk**
    for deploying and managing web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'CodePipeline also supports integration with third-party tools and services
    through custom actions, allowing you to extend its capabilities to fit your specific
    requirements. Additionally, it provides visibility into your release process through
    its web-based console, allowing you to monitor the progress of your pipelines
    and troubleshoot any issues that arise. The following are the steps for implementing
    Kubernetes GitOps deployment with AWS CodePipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up AWS CodePipeline**: Begin by setting up AWS CodePipeline, which orchestrates
    the CI/CD workflow for your Kubernetes deployment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Connect to the GitHub repository**: In the CodePipeline configuration, connect
    to your GitHub repository where your Kubernetes manifests and deployment scripts
    are stored.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure source stage**: Define the source stage in the CodePipeline configuration,
    specifying the GitHub repository and branch to pull the Kubernetes manifests from.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add build stage**: Create a build stage in the CodePipeline configuration
    to execute any necessary build steps for your Kubernetes deployment, such as compiling
    code or packaging artifacts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integrate with EKS**: Incorporate EKS into your CodePipeline workflow. This
    may involve setting up connections or permissions between AWS services and CodePipeline.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement GitOps principles**: Ensure that your CI/CD pipeline adheres to
    GitOps principles, such as storing all configuration and deployment manifests
    in version control, automating deployment processes, and using pull-based synchronization
    for cluster updates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Define deployment strategy**: Define the deployment strategy for your Kubernetes
    application, specifying parameters such as rollout strategy, scaling options,
    and health checks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger deployments**: Configure AWS CodePipeline to trigger deployments
    automatically whenever changes are pushed to the GitHub repository, maintaining
    the CD of your Kubernetes application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitor and debug**: Implement monitoring and logging mechanisms to track
    the performance and health of your Kubernetes deployments. Ensure that you have
    tools in place to debug and troubleshoot any issues that may arise during deployment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Iterate and improve**: Continuously iterate on your CI/CD pipeline, incorporating
    feedback and making improvements to enhance the efficiency, reliability, and security
    of your Kubernetes deployments over time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping up, AWS CodePipeline streamlines the release process, empowering teams
    to deliver software changes more rapidly and reliably. By automating the deployment
    pipeline, CodePipeline helps accelerate time to market and enhances overall productivity,
    enabling organizations to respond swiftly to customer needs and market demands.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes deployment with AWS CodePipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we embark on a hands-on journey to deploy a Kubernetes cluster
    on AWS, leveraging Terraform, EKS, and AWS CodePipeline. We’ll start by provisioning
    an EKS cluster and an Amazon **Elastic Container Registry** (**ECR**). The highlight
    of our journey involves orchestrating the deployment of this image to the EKS
    cluster using AWS CodePipeline. As done for Azure in the *Kubernetes deployment
    with Azure DevOps* section, this practical walkthrough demonstrates the seamless
    integration of these components, showcasing how they streamline the deployment
    process within a GitOps framework. Through this example, readers will gain a comprehensive
    understanding of deploying applications to Kubernetes using AWS’s powerful services.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following walkthrough example, we assume that the reader has a valid
    AWS account and has already installed and configured AWS CLI version 2\. Please
    review the following AWS links for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS CLI user** **guide**: [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CLI** **examples**: [https://docs.aws.amazon.com/cli/latest/userguide/welcome-examples.html](https://docs.aws.amazon.com/cli/latest/userguide/welcome-examples.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the necessary steps to successfully complete this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that AWS CLI is correctly configured by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: IAM policy
  prefs: []
  type: TYPE_NORMAL
- en: An IAM policy is a document that defines permissions and is used to manage access
    to AWS resources. IAM policies grant specific rights to users, groups, or roles,
    determining what actions they can perform on which resources. These policies are
    made up of statements that include components such as **Effect** (allow or deny),
    **Action** (the specific actions permitted or denied), and **Resource** (the specific
    resources to which the actions apply). IAM policies help ensure secure and granular
    access control within an AWS environment, enabling administrators to enforce the
    principle of least privilege by giving entities only the permissions they need
    to perform their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following commands to start the cluster creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The entire process will take nearly 10 minutes to complete. *Figure 9**.14*
    illustrates the EKS cluster in the AWS console, while *Figure 9**.15* shows the
    created ECR registry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The EKS cluster after the execution of the Terraform script](img/B22100_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The EKS cluster after the execution of the Terraform script
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The ECR registry after the execution of the Terraform script](img/B22100_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The ECR registry after the execution of the Terraform script
  prefs: []
  type: TYPE_NORMAL
- en: 'Integrate the `kubectl` configuration for cluster management:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type the following command to test the access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you encounter authentication issues or generic issues after merging the
    cluster management, you need to add an access entry for the EKS cluster. This
    involves adding the following permissions to the user configured for the AWS CLI,
    as specified at the beginning of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the AWS console, navigate to the `eksgitopscluster`) and click on the **Create
    access entry** button, as illustrated in *Figure 9**.16*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 9.16 – The EKS cluster page and the Access tab for creating a n\uFEFF\
    ew access entry](img/B22100_09_16.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – The EKS cluster page and the Access tab for creating a new access
    entry
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **IAM Principal ARN** field, you have to select the IAM ARN that has
    been used to configure the AWS CLI and execute AWS CLI commands, as illustrated
    in *Figure 9**.17*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – The IAM principal ARN selection for AWS CLI configuration](img/B22100_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – The IAM principal ARN selection for AWS CLI configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click the **Next** button at the bottom of the page, and for this example,
    add all the following policy names (see *Figure 9**.18*) with **Cluster** as the
    selected **Access scope**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – The Access policies section for attaching permissions to the
    new IAM principal](img/B22100_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – The Access policies section for attaching permissions to the new
    IAM principal
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Next** button and then **Create**. Now, you should be able to administer
    the cluster using AWS CLI without any issues. For more information and details,
    please refer to the official documentation: https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#updating-access-entries.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before proceeding with the creation of an instance of AWS CodePipeline, we first
    need to create an `GitOpsCodeBuildRole`. This role will allow the pipeline to
    build a new image for our `weather-app` application whenever new code is committed
    to the repository, push the image to the created ECR, and deploy it to EKS. In
    the AWS console, navigate to **IAM** |**Roles**, and click on the **Create role**
    button, as illustrated in *Figure 9**.19*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – The Roles page in the AWS Management Console, where you can
    begin creating a new IAM role](img/B22100_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – The Roles page in the AWS Management Console, where you can begin
    creating a new IAM role
  prefs: []
  type: TYPE_NORMAL
- en: IAM role
  prefs: []
  type: TYPE_NORMAL
- en: An **IAM role** in AWS is a set of permissions that define what actions can
    be performed on AWS resources. Roles are used to delegate access to users, applications,
    or services within AWS, allowing them to interact securely with various AWS services.
    Roles are defined with policies that specify the actions allowed or denied, and
    they are assumed by entities such as AWS services, IAM users, or AWS resources.
    This approach ensures secure access control and helps enforce the principle of
    least privilege, where users and services have only the permissions necessary
    to perform their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Select trusted entity** section, choose **AWS service**, and in the
    **Use case** panel, select **CodeBuild**, as shown in *Figure 9**.20*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – The Trusted entity type and Use case section on the Create
    role page](img/B22100_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – The Trusted entity type and Use case section on the Create role
    page
  prefs: []
  type: TYPE_NORMAL
- en: On the `AmazonEC2ContainerRegistryFullAccess`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AmazonS3FullAccess`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AWSCodeBuildAdminAccess`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AWSCodeCommitFullAccess`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CloudWatchLogsFullAccess`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the following **inline policy**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inline policy
  prefs: []
  type: TYPE_NORMAL
- en: An **inline policy** is a set of permissions that can be directly attached to
    an IAM user, group, or role. Unlike managed policies, which are standalone entities,
    inline policies are embedded directly within the resources they are intended to
    control. This allows for more granular control and management of permissions at
    a more specific level. Inline policies are often used when certain permissions
    need to be applied only to a specific user, group, or role, rather than being
    shared across multiple entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before reviewing and creating the new IAM role, it’s important to ensure the
    addition of the specified trust relationship to control who can assume the role,
    enhancing security and compliance. This setup prevents unauthorized access and
    ensures that only designated entities can access certain AWS resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To complete the process, simply click the **Create** button. Now, we’re all
    set to create the AWS CodePipeline instance.
  prefs: []
  type: TYPE_NORMAL
- en: Following a similar approach as done for Azure DevOps, refer to the *Kubernetes
    deployment with Azure DevOps* section in this chapter; it’s time to automate the
    application deployment to AWS EKS using AWS CodePipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To set up the CodePipeline correctly, navigate to the AWS console, go to `weather-app-pipeline`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pipeline** **type**: **V2**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Execution** **mode**: **Queued**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Service role**: **New** **service role**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click the **Next** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Initial configurations for the new AWS CodePipeline](img/B22100_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Initial configurations for the new AWS CodePipeline
  prefs: []
  type: TYPE_NORMAL
- en: In `GitHub (Version 2)` as `main`. For `CodePipeline` default. Finally, click
    the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Connection with the GitHub repository source](img/B22100_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Connection with the GitHub repository source
  prefs: []
  type: TYPE_NORMAL
- en: In **Add build stage**, select **AWS CodeBuild** as the build provider (refer
    to *Figure 9**.23*). Choose the same region where EKS and ECR resources have been
    previously deployed, and then click on **Create project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – The section of the Build panel related to selecting the build
    provider and region](img/B22100_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – The section of the Build panel related to selecting the build
    provider and region
  prefs: []
  type: TYPE_NORMAL
- en: In the `weather-app-build` as the project name and keep all other values as
    default, except for `arn:aws:iam::[AWS_ACCOUNT_ID]:role/GitOpsCodeBuildRole`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.24 – The section of the Build panel related to the selection of
    service roles and roles](img/B22100_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – The section of the Build panel related to the selection of service
    roles and roles
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `buildspec.yaml` file. Then, click the `ECR_REPOSITORY_URI`: `[AWS_ACCOUNT_ID].dkr.ecr.eu-central-1.amazonaws.com`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IMAGE_AND_TAG`: `weather-app:latest`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.25 – The section of the Build panel related to adding environment
    variables](img/B22100_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – The section of the Build panel related to adding environment variables
  prefs: []
  type: TYPE_NORMAL
- en: For **Build type**, select **Single Build**. Click the **Next** button. At the
    **Add deploy stage** step, click on the **Skip deploy stage** button, and then
    on **Next**. Review the pipeline at the final stage and click the **Create pipeline**
    button. At this point, the CodePipeline will be triggered and completed successfully
    in one minute (see *Figure 9**.26*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.26 – weather-app-pipeline immediately after its definition](img/B22100_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – weather-app-pipeline immediately after its definition
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the pipeline execution, we can verify that the Docker image of
    `weather-app` has been correctly built and pushed to the ECR, as illustrated in
    *Figure 9**.27*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.27 – The weather-app:latest image successfully pushed to the ECR](img/B22100_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27 – The weather-app:latest image successfully pushed to the ECR
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the deployment has been successfully completed, execute the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we can execute a `port-forward` command to display the app in
    the browser, as illustrated in *Figure 9**.28*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.28 – weather-app rendered in the browser after the deployment](img/B22100_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28 – weather-app rendered in the browser after the deployment
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to edit the data source file as described in *Step 11* of the *Kubernetes
    deployment with Azure DevOps* section. After pushing the changes, `weather-pipeline`
    will be triggered immediately, as illustrated in *Figure 9**.29*. Perform a new
    `port-forward` command to view the updated version of the chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.29 – The pipeline is immediately triggered after pushing the updated
    data.csv file](img/B22100_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29 – The pipeline is immediately triggered after pushing the updated
    data.csv file
  prefs: []
  type: TYPE_NORMAL
- en: To avoid incurring unnecessary costs, remember to delete all AWS resources created
    for this example after you’ve finished by executing the appropriate commands or
    using the AWS Management Console.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! At this stage, you’ve successfully completed the deployment
    of the weather application on Azure using Azure DevOps and on AWS using CodePipeline.
    Now, let’s delve into GitOps applications in cloud environments in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps applications in cloud environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advent of GitOps has significantly revolutionized the way cloud environments
    are managed and deployed, by embedding the principles of version control and collaboration
    into the operational fabric of cloud-native applications. GitOps applications
    extend beyond mere deployment automation, encapsulating the entire life cycle
    of cloud resources and services. This includes provisioning, scaling, updating,
    and decommissioning, all governed through Git pull requests. The methodology fosters
    a transparent, auditable, and easily reversible process, enhancing both the security
    and compliance of cloud applications. Moreover, GitOps practices ensure that the
    desired state of the cloud environment is declaratively defined and maintained,
    promoting consistency and reliability across different stages of development and
    production. This systematic approach minimizes discrepancies between environments,
    significantly reducing *it works on my machine* issues and streamlining the path
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cloud strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In today’s multi-cloud landscape, organizations often leverage the unique advantages
    of Azure, AWS, and other cloud providers to optimize their operations and costs.
    Managing deployments across such diverse environments can present challenges,
    particularly in maintaining consistency and efficiency. GitOps offers a unified
    strategy for managing these deployments, facilitating cross-cloud interoperability
    and configuration management. The following is a list of benefits of adopting
    GitOps in a cross-cloud setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unified configuration management**: By storing infrastructure definitions
    and configurations as code in a Git repository, teams can use the same GitOps
    workflows to manage deployments across Azure, AWS, and other clouds. This centralizes
    control and ensures consistency across cloud environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability and portability**: Leveraging containerization and Kubernetes,
    applications can be designed to run seamlessly across different clouds. GitOps
    practices, coupled with these technologies, simplify the process of deploying
    and managing these applications, irrespective of the underlying cloud platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated synchronization**: Tools such as Argo CD or Flux can be used to
    automatically synchronize the desired state in the Git repository with the actual
    state in each cloud environment. This ensures that all environments adhere to
    the same configurations and policies, facilitating a smooth and consistent operational
    workflow across clouds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment parity**: GitOps enables teams to replicate environments across
    different clouds with high fidelity. This is particularly useful for testing,
    where an application deployed on Azure can be tested under similar conditions
    on AWS, ensuring that the application behaves consistently across platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets management**: Managing secrets and sensitive information can be challenging
    in a cross-cloud setup. GitOps workflows can integrate with cloud-specific secrets
    management services such as Azure Key Vault or AWS Secrets Manager, allowing secure
    handling of secrets while maintaining the flexibility of cross-cloud deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting a GitOps approach for cross-cloud strategies not only simplifies the
    complexity inherent in multi-cloud environments but also enhances operational
    efficiency, security, and compliance. By treating infrastructure and application
    configurations as code, teams gain the agility to adapt to changes swiftly, ensuring
    their deployments remain aligned with organizational goals and industry best practices.
    In the next section, we will introduce which GitOps strategies should be adopted
    for Kubernetes deployments on Azure and AWS.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps strategies for Azure and AWS deployments for Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of Kubernetes deployments, GitOps strategies offer a paradigm shift
    towards more efficient, transparent, and reliable operations. By leveraging GitOps
    principles, organizations can automate deployment processes, ensure consistency
    across environments, and significantly enhance their operational workflows. The
    following are insights into GitOps strategies tailored for Kubernetes deployments
    on Azure and AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Azure GitOps strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adopting GitOps strategies for AKS entails a detailed approach to integrating
    source control, CI/CD pipelines, and configuration management to enhance deployment
    processes. A pivotal strategy involves the deployment of IaC using tools such
    as ARM templates or Terraform, which are stored in Git repositories. This approach
    enables the declarative management of AKS configurations. *Chapters 10* and *11*
    will provide comprehensive examples of automating IaC with Terraform on Azure.
    These automations facilitate automated and repeatable deployments, thereby improving
    the stability and scalability of applications.
  prefs: []
  type: TYPE_NORMAL
- en: The use of Azure Policy in conjunction with GitOps further enforces compliance
    and governance across Kubernetes clusters, ensuring that deployments adhere to
    organizational and regulatory standards. Integrating Azure Monitor with GitOps
    workflows enables teams to implement observability as a core component of their
    operations, allowing for proactive monitoring and troubleshooting of AKS deployments.
  prefs: []
  type: TYPE_NORMAL
- en: AWS GitOps strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS offers a robust ecosystem for implementing GitOps with EKS. The foundation
    of AWS GitOps strategies lies in leveraging Amazon ECR for the Docker container
    registry, AWS CodeCommit for source control, and AWS CodePipeline for continuous
    integration and deployment. Similar to Azure, AWS advocates for the use of IaC,
    with AWS CloudFormation or Terraform as preferred tools, to manage EKS cluster
    configurations and resources in a declarative manner.
  prefs: []
  type: TYPE_NORMAL
- en: An effective GitOps strategy on AWS encompasses the integration of AWS CodeBuild
    and AWS CodeDeploy within the CI/CD pipeline, automating the build, test, and
    deployment phases directly from Git repositories. Moreover, the AWS App Mesh service
    can be integrated into GitOps workflows to manage microservices more effectively,
    providing end-to-end visibility and network traffic control across applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For both Azure and AWS, implementing GitOps for Kubernetes deployments revolves
    around four key principles: version control, automated deployments, merge/pull
    requests for change management, and observability. By adhering to these principles,
    organizations can achieve automated, predictable, and secure application deployments
    at scale. Utilizing GitOps not only simplifies Kubernetes cluster management but
    also aligns operational practices with development workflows, fostering a culture
    of collaboration and continuous improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have gained a thorough understanding of how GitOps can be effectively
    implemented within the Azure and AWS cloud environments. The chapter covered the
    necessary tools and processes, such as AKS, Azure DevOps, AWS EKS, and AWS CodePipeline,
    to establish robust CI/CD pipelines and manage deployments seamlessly. With practical
    examples and expert advice, this chapter ensured that readers can apply these
    concepts to achieve more automated, consistent, and secure cloud-native deployments.
    Emphasizing the importance of a solid foundation in Git, Docker, and Kubernetes,
    the chapter prepared readers to embrace the full potential of GitOps in their
    cloud computing ventures. In the next chapter, we will explore the integration
    of GitOps with Terraform and Flux, focusing on infrastructure. We’ll cover the
    essential steps to align infrastructure as code with real-time operations, using
    Terraform for provisioning and Flux for CD. The discussion will also highlight
    best practices and common challenges in this process.
  prefs: []
  type: TYPE_NORMAL
