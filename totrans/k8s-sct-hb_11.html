<html><head></head><body>
<div id="_idContainer052">
<h1 class="chapter-number" id="_idParaDest-201"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-202"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.2.1">Exploring External Secret Stores</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Previously, we worked with the cloud providers AWS, Azure, and GCP. </span><span class="koboSpan" id="kobo.3.2">We ran our application and integrated it with the secret providers offered on these platforms. </span><span class="koboSpan" id="kobo.3.3">We used the Secrets management facilities of each cloud provider and benefited from the ecosystem of tools that the cloud providers provides us with. </span><span class="koboSpan" id="kobo.3.4">This made it feasible to tackle concerns such as auditing high availability and disaster recovery. </span><span class="koboSpan" id="kobo.3.5">In this chapter, we shall explore external secret stores that are not part of a cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">provider’s offerings.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Overview of external secret </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">store providers</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">The different types of external secret stores, such as HashiCorp Vault, and CyberArk </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Secrets Manager</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Managing Secrets in an external secret store </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">for Kubernetes</span></span></li>
</ul>
<h1 id="_idParaDest-203"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">To link concepts with hands-on examples, we are leveraging a series of tools and platforms commonly used to interact with the Google Cloud API </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">and Kubernetes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.16.1">kubectl</span></strong><span class="koboSpan" id="kobo.17.1">: This is the command-line tool used for communicating with a Kubernetes cluster through the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">API (</span></span><a href="https://kubernetes.io/docs/reference/kubectl/"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://kubernetes.io/docs/reference/kubectl/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.20.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.21.1">minikube</span></strong><span class="koboSpan" id="kobo.22.1">: This is a local Kubernetes distribution used for Kubernetes learning and development. </span><span class="koboSpan" id="kobo.22.2">To install minikube on your system, you can follow the instructions from the official </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">documentation (</span></span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.26.1">Vault CLI</span></strong><span class="koboSpan" id="kobo.27.1">: This is used to interact with a HashiCorp Vault </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">installation (</span></span><a href="https://developer.hashicorp.com/vault/docs/install"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://developer.hashicorp.com/vault/docs/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.30.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">jq</span></strong><span class="koboSpan" id="kobo.32.1">: This is a lightweight and flexible command-line JSON processor. </span><span class="koboSpan" id="kobo.32.2">It will help us extract the information needed from </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">kubectl</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.34.1">commands (</span></span><a href="https://jqlang.github.io/jq/"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://jqlang.github.io/jq/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Helm</span></strong><span class="koboSpan" id="kobo.38.1">: This is a package manager for Kubernetes that we will be using to simplify the deployment and management of Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">resources (</span></span><a href="https://helm.sh"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://helm.sh</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">).</span></span></li>
</ul>
<h1 id="_idParaDest-204"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.42.1">Overview of external secret providers</span></h1>
<p><span class="koboSpan" id="kobo.43.1">By default, Secrets </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.44.1">on Kubernetes are stored in </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">etcd</span></strong><span class="koboSpan" id="kobo.46.1"> as</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.47.1"> mentioned in </span><a href="B20970_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.49.1">, </span><em class="italic"><span class="koboSpan" id="kobo.50.1">Understanding Kubernetes Secrets Management</span></em><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">Storing Secrets on etcd comes with certain security concerns, as mentioned in </span><a href="B20970_07.xhtml#_idTextAnchor142"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.52.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.53.1">, </span><em class="italic"><span class="koboSpan" id="kobo.54.1">Challenges and Risks in Managing Secrets</span></em><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">Alternative forms of secret storage can help us harden our security and also segregate the concerns that come with secret usage. </span><span class="koboSpan" id="kobo.55.3">We will focus on the components that make it feasible to have external </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">secret providers.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">First, let us have a look at the available external secret </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">store providers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.59.1">AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">Secrets Manager</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">Key Vault</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">GCP </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">Secret Manager</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.65.1">HashiCorp Vault</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.66.1">CyberArk Conjur</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">The way these providers offer integration with Kubernetes might differ. </span><span class="koboSpan" id="kobo.67.2">A very popular approach to achieving integration with a secret store provider is through the Secrets Store </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">CSI Driver.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.69.1">Secrets Store CSI Driver</span></h2>
<p><span class="koboSpan" id="kobo.70.1">The Secrets Store CSI Driver </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.71.1">makes </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.72.1">it feasible to integrate</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.73.1"> Kubernetes Secrets through a </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">container storage interface</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">CSI</span></strong><span class="koboSpan" id="kobo.77.1">) volume. </span><span class="koboSpan" id="kobo.77.2">The Kubernetes Secrets Store interface is based on the Kubernetes CSI plugin. </span><span class="koboSpan" id="kobo.77.3">Through CSI, we can integrate external store providers to Kubernetes by implementing</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.78.1"> a CSI plugin, which can extend our cluster’s storage capabilities without having to change the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">core code.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.80.1">External secret store providers with CSI plugins</span></h2>
<p><span class="koboSpan" id="kobo.81.1">There are a</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.82.1"> handful of CSI </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">provider plugins:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.84.1">AWS provider</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.85.1">Azure provider</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.86.1">GCP provider</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.87.1">Vault provider</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.88.1">In the previous chapters, we focused on the CSI Secrets Store CSI Driver that came along with the cloud provider solutions. </span><span class="koboSpan" id="kobo.88.2">We mention a new provider, the Vault provider, which is HashiCorp’s </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">secret storage.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">All the secret providers on the list give the option of high availability, and all secret providers provide auditing and logging. </span><span class="koboSpan" id="kobo.90.2">Those elements ensure data governance and security. </span><span class="koboSpan" id="kobo.90.3">Apart from the CSI Driver solution, there are also other approaches available for Secrets management integration. </span><span class="koboSpan" id="kobo.90.4">One of them is the Secrets Injector component, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">cover next.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.92.1">Secrets Injector</span></h2>
<p><span class="koboSpan" id="kobo.93.1">The </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.94.1">Secrets Injector component offers </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.95.1">another way to inject Secrets on an application and Secrets hosted on an external secret </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">store provider.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">Secret managers such as HashiCorp Vault and CyberArk Conjur support secret storage usage through the Sidecar Injector. </span><span class="koboSpan" id="kobo.97.2">Those sidecar injectors focus on the aspects of authorization and authentication when it comes to receiving the Secrets from the secret storage. </span><span class="koboSpan" id="kobo.97.3">Also, they tackle the integration with the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">Kubernetes workloads.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">However, take note that injecting Secrets is not an action that always requires a sophisticated binary that interacts with Kubernetes. </span><span class="koboSpan" id="kobo.99.2">For example, let us consider GCP Secret Manager. </span><span class="koboSpan" id="kobo.99.3">There is no official binary that will receive the Secrets from Secret Manager and then attach them to the Pod. </span><span class="koboSpan" id="kobo.99.4">This does not prevent us from implementing a solution that will securely achieve the same result. </span><span class="koboSpan" id="kobo.99.5">We can utilize Workload Identity, as mentioned in </span><a href="B20970_10.xhtml#_idTextAnchor193"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.100.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.101.1">, </span><em class="italic"><span class="koboSpan" id="kobo.102.1">Exploring Cloud Secret Store on GCP</span></em><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">Through Workload Identity, our Kubernetes workloads can interact with Secret Manager. </span><span class="koboSpan" id="kobo.103.3">We can</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.104.1"> then use the client libraries of GCP Secret Manager, and through an initialization container, the Secrets can be mounted locally to </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">the Pod.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">This recipe can</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.107.1"> be applied to any other form of storage. </span><span class="koboSpan" id="kobo.107.2">The key element to note is the usage of Workload Identity; the security remained intact by utilizing it. </span><span class="koboSpan" id="kobo.107.3">We did not have to store any Secrets on etcd that would make it feasible to interact with Secret Manager. </span><span class="koboSpan" id="kobo.107.4">Instead, Kubernetes workloads would get assigned certain permissions to make it feasible to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Secret Manager.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">In other forms of Secrets management, such as HashiCorp Vault, authentication and interaction with the secret storage are a bit different from what we have seen so far, yet the security qualities remain the same. </span><span class="koboSpan" id="kobo.109.2">Access to the Secrets is achieved in a secure and authorized way where the principle of least permissions is followed. </span><span class="koboSpan" id="kobo.109.3">We will examine this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">following chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">To summarize, we had an overview of the external Secrets Provider that we can use to inject our Secrets into Kubernetes. </span><span class="koboSpan" id="kobo.111.2">Going forward, we will focus on the HashiCorp Vault and </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">its capabilities.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.113.1">HashiCorp Vault</span></h1>
<p><span class="koboSpan" id="kobo.114.1">In the </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.115.1">rapidly evolving landscape of distributed computing, securing sensitive information is paramount. </span><span class="koboSpan" id="kobo.115.2">Kubernetes, a leader in container orchestration, requires robust solutions to manage Secrets—sensitive data necessary for the proper configuration and operation of applications. </span><span class="koboSpan" id="kobo.115.3">HashiCorp Vault stands out as a central figure in addressing these challenges, providing a comprehensive suite of tools for secure Secrets management across </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">Kubernetes clusters.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">HashiCorp Vault offers a centralized, encrypted solution, ensuring that Secrets remain confidential and are never exposed in application code or configuration files. </span><span class="koboSpan" id="kobo.117.2">Its integration with Kubernetes not only simplifies Secrets management but also fortifies the security of containerized applications, introducing features such as dynamic Secrets, secure secret injection into Pods, and a Kubernetes-native authentication method. </span><span class="koboSpan" id="kobo.117.3">These features foster secure communications and secret retrieval between HashiCorp Vault and Kubernetes, enhancing flexibility, security, and efficiency in </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">managing Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">HashiCorp Vault’s capability </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.120.1">to dynamically generate short-lived credentials on demand distinguishes it from native Kubernetes Secrets, which are often stored unencrypted in etcd and become unwieldy as applications scale. </span><span class="koboSpan" id="kobo.120.2">HashiCorp Vault’s approach minimizes the attack surface, enhances security, and addresses the potential mismanagement </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">of Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Moreover, HashiCorp Vault’s extensive audit logging ensures transparency and accountability, aiding compliance and facilitating swift responses to security incidents. </span><span class="koboSpan" id="kobo.122.2">By integrating HashiCorp Vault into Kubernetes deployments, organizations position themselves to achieve a robust, secure, and compliant containerized application environment, overcoming the limitations of native Kubernetes Secrets and elevating their Secrets management practices to the highest </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">security standards.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">There is an open source and an enterprise version, and we will focus on the open source </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">version next.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.126.1">Using HashiCorp Vault as a secret storage</span></h2>
<p><span class="koboSpan" id="kobo.127.1">HashiCorp Vault </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.128.1">can be used as a secret storage; it can contain the Secrets of our application. </span><span class="koboSpan" id="kobo.128.2">This makes it feasible to host Kubernetes Secrets on Vault. </span><span class="koboSpan" id="kobo.128.3">This can be done in two ways: either having the Vault hosted outside of Kubernetes or hosting the Vault </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">with Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Let us examine how we can integrate an external HashiCorp Vault with Kubernetes. </span><span class="koboSpan" id="kobo.130.2">For our needs, we shall use a </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">minikube installation.</span></span></p>
<h3><span class="koboSpan" id="kobo.132.1">External Vault storage</span></h3>
<p><span class="koboSpan" id="kobo.133.1">We will </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.134.1">proceed with creating a Vault instance, which </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.135.1">will be run through a Docker container. </span><span class="koboSpan" id="kobo.135.2">We can run Vault using </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">Docker Compose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
services:
  vault_node_1:
    image: vault:1.13.3
    container_name: vault_node_1
    ports:
      - "8200:8200"
    environment:
      VAULT_DEV_LISTEN_ADDRESS: "0.0.0.0:8200"
      VAULT_DEV_ROOT_TOKEN_ID: mytoken
      VAULT_LOG_LEVEL: debug
    volumes:
      - haproxy.cfg:/haproxy.cfg</span></pre> <p><span class="koboSpan" id="kobo.138.1">We can run Vault using the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.140.1">
$ docker compose up</span></pre> <p><span class="koboSpan" id="kobo.141.1">Another </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.142.1">solution is to run Vault by using a plain </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">Docker command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.144.1">
$ docker run -p 8200:8200 --rm -v haproxy.cfg:/haproxy.cfg  --name vault_node_1  -e VAULT_DEV_ROOT_TOKEN_ID=mytoken -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 -e VAULT_LOG_LEVEL=debug vault:1.13.3</span></pre> <p><span class="koboSpan" id="kobo.145.1">There is no difference in the outcome of those two commands. </span><span class="koboSpan" id="kobo.145.2">Compose has the convenience of being just one file, but standalone docker commands also work as well. </span><span class="koboSpan" id="kobo.145.3">It is a matter </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">of preference.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">It is important to understand that we run Vault in development mode for debugging purposes. </span><span class="koboSpan" id="kobo.147.2">This is not a secure way to run Vault, which we will see in the </span><em class="italic"><span class="koboSpan" id="kobo.148.1">Development mode versus production mode</span></em><span class="koboSpan" id="kobo.149.1"> section of this chapter. </span><span class="koboSpan" id="kobo.149.2">Development mode will be used to make our example use </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">case simpler.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">Let us examine Vault. </span><span class="koboSpan" id="kobo.151.2">We specified the root token; this is a token with root permissions. </span><span class="koboSpan" id="kobo.151.3">We also set the level of logging to </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">debug</span></strong><span class="koboSpan" id="kobo.153.1">. </span><span class="koboSpan" id="kobo.153.2">This is to help us with troubleshooting our installation. </span><span class="koboSpan" id="kobo.153.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">VAULT_DEV_LISTEN_ADDRESS</span></strong><span class="koboSpan" id="kobo.155.1"> is the address to bind when in development mode. </span><span class="koboSpan" id="kobo.155.2">For now, this is sufficient to proceed with integrating </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">with Kubernetes.</span></span></p>
<h4><span class="koboSpan" id="kobo.157.1">Installing Vault on Kubernetes</span></h4>
<p><span class="koboSpan" id="kobo.158.1">To be able to</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.159.1"> integrate Vault with Kubernetes, we need to install the Vault binaries. </span><span class="koboSpan" id="kobo.159.2">The easiest way to do so is through a </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">Helm chart.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">First, we shall acquire a reference for our </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">Vault installation:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.163.1">
$ EXTERNAL_VAULT_ADDR=$(minikube ssh "dig +short host.docker.internal" | tr -d '\r')</span></pre> <p><span class="koboSpan" id="kobo.164.1">Then we will install Vault </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">on Kubernetes:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.166.1">
$ helm repo add hashicorp https://helm.releases.hashicorp.com
$ helm repo update
$ helm install vault hashicorp/vault --set "global.externalVaultAddr=http://$EXTERNAL_VAULT_ADDR :8200" --set="csi.enabled=true"</span></pre> <p><span class="koboSpan" id="kobo.167.1">We installed the Vault package on Kubernetes and set an external Vault address that Kubernetes will point to. </span><span class="koboSpan" id="kobo.167.2">Also, we enabled the CSI since we will show the CSI capabilities in another example. </span><span class="koboSpan" id="kobo.167.3">To check that our installation was successful, we can check whether the deployment of </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">vault-agent-injector</span></strong><span class="koboSpan" id="kobo.169.1"> is in our cluster. </span><span class="koboSpan" id="kobo.169.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">kubectl</span></strong><span class="koboSpan" id="kobo.171.1">, we can identify whether a </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">vault-agent-injector</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.173.1">deployment exists:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.174.1">
$ kubectl get deployment vault-agent-injector
NAME                   READY   UP-TO-DATE   AVAILABLE   AGE
vault-agent-injector   1/1     1            1           3h40m</span></pre> <p><span class="koboSpan" id="kobo.175.1">Let us understand how the Vault Agent </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">Injector works.</span></span></p>
<h4><span class="koboSpan" id="kobo.177.1">Vault Agent Injector</span></h4>
<p><span class="koboSpan" id="kobo.178.1">If we </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.179.1">examine the Vault Agent Injector, we shall see that it uses a specific service account, </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">vault-agent-injector</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">This component is responsible for changing the Pod specifications so agent containers can be included. </span><span class="koboSpan" id="kobo.181.3">These Vault Agent containers render Secrets from Vault to a shared </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">memory volume.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">On an initialization of a</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.184.1"> Pod that uses Vault Secrets, the following </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">actions occur:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.186.1">The agent will identify the Pod that uses the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">Vault Secrets.</span></span></li>
<li><span class="koboSpan" id="kobo.188.1">The Pod specification will be changed and will include the Vault </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Agent containers.</span></span></li>
<li><span class="koboSpan" id="kobo.190.1">The Vault init container will fetch the Secrets and attach them to the Pod as shared </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">memory volume.</span></span></li>
<li><span class="koboSpan" id="kobo.192.1">If the Secrets change in the Vault, the Vault Sidecar Injector will change </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">the Secrets.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.194.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">vault-agent-injector</span></strong><span class="koboSpan" id="kobo.196.1"> Pod is assigned the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">vault-agent-injector-clusterrole </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">role</span></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">We can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">vault-agent-injector-clusterrole</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.202.1">cluster role:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.203.1">
$ kubectl get clusterrole vault-agent-injector-clusterrole -o yaml
kind: ClusterRole
metadata:
...
</span><span class="koboSpan" id="kobo.203.2">  name: vault-agent-injector-clusterrole
rules:
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  verbs:
  - get
  - list
  - watch
  - patch</span></pre> <p><span class="koboSpan" id="kobo.204.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">vault-agent-injector</span></strong><span class="koboSpan" id="kobo.206.1"> is registered to Kubernetes as a </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">mutating admission webhook</span></strong><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">Once a Pod</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.209.1"> is created with certain Vault annotations, </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">vault-agent-injector</span></strong><span class="koboSpan" id="kobo.211.1"> will intercept the creation request and rewrite the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">Pod definition.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">The </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.214.1">Vault annotations would be like </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
vault.hashicorp.com/agent-inject: 'true'
vault.hashicorp.com/role: 'webapp_admin_r'
vault.hashicorp.com/agent-inject-secret-credentials.txt: 'secret/data/webapp/admin'</span></pre> <p><span class="koboSpan" id="kobo.217.1">As we can see, we enable the injection method. </span><span class="koboSpan" id="kobo.217.2">Then, we specify the Vault role that will be used to fetch the Secrets and the Secrets that will </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">be fetched:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.219.1"><img alt="Figure 11.1 – Vault Injector and application hosted on Kubernetes" src="image/B20970_11_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.220.1">Figure 11.1 – Vault Injector and application hosted on Kubernetes</span></p>
<p><span class="koboSpan" id="kobo.221.1">By rewriting the Pod definition, the Pod will now contain Vault Agent containers. </span><span class="koboSpan" id="kobo.221.2">The Vault Agent containers will then interact with Vault to retrieve the Secrets and inject them into </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">the Pod.</span></span></p>
<h4><span class="koboSpan" id="kobo.223.1">Vault service account and Kubernetes authentication</span></h4>
<p><span class="koboSpan" id="kobo.224.1">For Vault</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.225.1"> to interact with Kubernetes, it must use a service account. </span><span class="koboSpan" id="kobo.225.2">By installing the Vault Helm package, a service account will also be created. </span><span class="koboSpan" id="kobo.225.3">The service account is </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">vault</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">We need to create a token for that service account. </span><span class="koboSpan" id="kobo.229.2">From </span><a href="B20970_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.230.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.231.1">, </span><em class="italic"><span class="koboSpan" id="kobo.232.1">Walking through Kubernetes Secrets Management Concepts</span></em><span class="koboSpan" id="kobo.233.1">, we know that in new versions of Kubernetes, we must create a secret for the service account </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">by ourselves.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Let’s create the secret for the service account. </span><span class="koboSpan" id="kobo.235.2">We will create a YAML file with the </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">following specifications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
apiVersion: v1
kind: Secret
metadata:
  name: vault-sa-token
  annotations:
    kubernetes.io/service-account.name: vault
type: kubernetes.io/service-account-token</span></pre> <p><span class="koboSpan" id="kobo.238.1">Next, we shall apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">YAML file:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.240.1">
$ kubectl apply –f vault-secret.yaml</span></pre> <p><span class="koboSpan" id="kobo.241.1">The secret will be created, and we should be able to use it for Vault. </span><span class="koboSpan" id="kobo.241.2">Now we should configure Vault to enable the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">Kubernetes authentication.</span></span></p>
<h4><span class="koboSpan" id="kobo.243.1">Kubernetes authentication</span></h4>
<p><span class="koboSpan" id="kobo.244.1">We can authenticate </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.245.1">Vault by using a Kubernetes service account token. </span><span class="koboSpan" id="kobo.245.2">This is the Kubernetes auth method. </span><span class="koboSpan" id="kobo.245.3">Essentially, we configure a Kubernetes service account token on Vault. </span><span class="koboSpan" id="kobo.245.4">Then, this service account token is used to interact with the Kubernetes API. </span><span class="koboSpan" id="kobo.245.5">To enable this, we need to have the auth method enabled </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">on Vault.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">The following steps should </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">be executed:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.249.1">
# retrieve Kubernetes secret for the service account
$ VAULT_HELM_SECRET_NAME=$(kubectl get secrets --output=json | jq -r '.items[].metadata | select(.name|startswith("vault")).name')
# retrieve service account token
$ TOKEN_REVIEW_JWT=$(kubectl get secret $VAULT_HELM_SECRET_NAME --output='go-template={{ .data.token }}' | base64 --decode)
# retrieve Kubernetes certificate
$ KUBE_CA_CERT=$(kubectl config view --raw --minify --flatten --output='jsonpath={.clusters[].cluster.certificate-authority-data}' | base64 --decode)
# retrieve the Kubernetes host
$ KUBE_HOST=$(kubectl config view --raw --minify --flatten --output='jsonpath={.clusters[].cluster.server}')
# point to local vault address
$ export VAULT_ADDR=http://0.0.0.0:8200
# login to vault using the root token
$ vault login mytoken
# enabled kubernetes authentication on vault
$ vault auth enable kubernetes
# write Kubernetes authentication configuration
$ vault write auth/kubernetes/config token_reviewer_jwt="$TOKEN_REVIEW_JWT" kubernetes_host="$KUBE_HOST" kubernetes_ca_cert="$KUBE_CA_CERT" issuer="https://kubernetes.default.svc.cluster.local"</span></pre> <p><span class="koboSpan" id="kobo.250.1">Let us see how</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.251.1"> this works behind </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the scenes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.253.1">A service account is configured on Vault. </span><span class="koboSpan" id="kobo.253.2">It has the permissions to interact with the Kubernetes API and execute </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">TokenReview requests.</span></span></li>
<li><span class="koboSpan" id="kobo.255.1">A role is created on Vault with permissions to interact with a secret residing in Vault. </span><span class="koboSpan" id="kobo.255.2">The role is mapped to a Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">service account.</span></span></li>
<li><span class="koboSpan" id="kobo.257.1">A Pod is </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.258.1">created and gets assigned the service account we created in the previous step. </span><span class="koboSpan" id="kobo.258.2">The Vault Injector issues a request to Vault using the service account JWT in order to fetch the secret </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">from Vault.</span></span></li>
<li><span class="koboSpan" id="kobo.260.1">Vault issues a TokenReview request to the Kubernetes API in order to validate the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">JWT token.</span></span></li>
<li><span class="koboSpan" id="kobo.262.1">Kubernetes validates </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">the token.</span></span></li>
<li><span class="koboSpan" id="kobo.264.1">Vault checks whether the service account mapped to the token is mapped to a role with access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">secret requested.</span></span></li>
<li><span class="koboSpan" id="kobo.266.1">Vault responds with the </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">secret value.</span></span></li>
<li><span class="koboSpan" id="kobo.268.1">The Vault Injector injects the secret into </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the Pod.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.270.1">The following is a diagram of the flow we discussed </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">so far:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.272.1"><img alt="Figure 11.1 – Kubernetes auth flow" src="image/B20970_11_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.273.1">Figure 11.2 – Kubernetes auth flow</span></p>
<p><span class="koboSpan" id="kobo.274.1">We configured Kubernetes authentication. </span><span class="koboSpan" id="kobo.274.2">One of the problems we will face is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">$KUBE_HOST</span></strong><span class="koboSpan" id="kobo.276.1"> points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">localhost</span></strong><span class="koboSpan" id="kobo.278.1">; thus, the certificate is mapped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">localhost</span></strong><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">This can be an issue since Vault can access minikube through the Docker host address, thus a different address from </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">localhost</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">For this reason, we shall use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">proxy</span></strong><span class="koboSpan" id="kobo.284.1"> file we mounted previously. </span><span class="koboSpan" id="kobo.284.2">The port will have to change with the port of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">$KUBE_HOST</span></strong><span class="koboSpan" id="kobo.286.1">, which </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">changes dynamically.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">On another </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.289.1">terminal, we shall execute the following commands and enable </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">port forwarding:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.291.1">
$ KUBE_HOST=$(kubectl config view --raw --minify --flatten --output='jsonpath={.clusters[].cluster.server}')
$ port=$(echo $KUBE_HOST | awk -F/ '{print $3}' | cut -d: -f2)
$ docker exec -it vault_node_1 sh
# apk add haproxy
# haproxy -f ./haproxy.cfg</span></pre> <p><span class="koboSpan" id="kobo.292.1">Since this form of authentication involves many steps, auditing will help to increase </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">our observability:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.294.1">
$ vault audit enable file file_path=/tmp/vault_audit.log</span></pre> <p><span class="koboSpan" id="kobo.295.1">The audit log file at </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">/tmp/vault_audit.log</span></strong><span class="koboSpan" id="kobo.297.1"> can </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">be tailed:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.299.1">
$ docker exec -it  vault_node_1  tail –f /tmp/vault_audit.log</span></pre> <p><span class="koboSpan" id="kobo.300.1">Since authentication is enabled and we have configured the service account needed, we should proceed and provide permissions for Vault to certain </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">service accounts.</span></span></p>
<h4><span class="koboSpan" id="kobo.302.1">Vault policies and bindings</span></h4>
<p><span class="koboSpan" id="kobo.303.1">The </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.304.1">benefit of using a secret provider such as Vault is the fact that we can store our Secrets and provide </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">fine-grained policies.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">For example, we shall store the following secret </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">in Vault:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.308.1">
$ vault kv put secret/webapp/admin username='john.doe' password='strong-password'</span></pre> <p><span class="koboSpan" id="kobo.309.1">We would like to have a restrictive read-only policy for </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the secret.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">Thus, we shall implement a policy with read-only permissions to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">secret/webapp/admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1"> secret:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.314.1">
$ vault policy write webapp_admin_r  - &lt;&lt;EOF path "secret/data/webapp/admin" { capabilities = ["read"] } EOF</span></pre> <p><span class="koboSpan" id="kobo.315.1">The </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.316.1">policy is in place, so if we want certain workloads to be able to use this policy, we need to declaratively specify so. </span><span class="koboSpan" id="kobo.316.2">In our case, we shall have a Kubernetes service account mapped to a Pod that would require Secrets from Vault. </span><span class="koboSpan" id="kobo.316.3">The service account name would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">simple-app</span></strong><span class="koboSpan" id="kobo.318.1">. </span><span class="koboSpan" id="kobo.318.2">Our next step would be to bind the policy we created previously with that </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">service account:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.320.1">
$ vault write auth/kubernetes/role/webapp_admin_r \
     bound_service_account_names=simple-app \
     bound_service_account_namespaces=default \
     policies=webapp_admin_r \
     ttl=24h</span></pre> <p><span class="koboSpan" id="kobo.321.1">Now we should create that service account </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">on Kubernetes:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.323.1">
$ kubectl create sa simple-app</span></pre> <p><span class="koboSpan" id="kobo.324.1">This service account would be used by Vault Injector to inject the Secrets into the application. </span><span class="koboSpan" id="kobo.324.2">Provisioning the service account alone is not sufficient enough to interact with Vault. </span><span class="koboSpan" id="kobo.324.3">A cluster role binding </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">is required:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: role-tokenreview-binding
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
  - kind: ServiceAccount
    name: simple-app
    namespace: default</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">auth-delegator</span></strong><span class="koboSpan" id="kobo.328.1"> is a </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.329.1">role that allows delegated authentication and authorization checks. </span><span class="koboSpan" id="kobo.329.2">This way, the service account we configured on Vault can issue a TokenReview request for a JWT token that is bound to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">simple-app</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.331.1">service account.</span></span></p>
<h4><span class="koboSpan" id="kobo.332.1">Using Vault Secrets in an application</span></h4>
<p><span class="koboSpan" id="kobo.333.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">simple-app</span></strong><span class="koboSpan" id="kobo.335.1"> service account will have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">auth-delegator</span></strong><span class="koboSpan" id="kobo.337.1"> cluster role. </span><span class="koboSpan" id="kobo.337.2">The role enables </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.338.1">delegated authentication and checks. </span><span class="koboSpan" id="kobo.338.2">Vault would be able to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">delegated authentication.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">We shall create the application that will fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the secret:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
apiVersion: v1
kind: Pod
metadata:
  name: webapp
  labels:
    app: webapp
  annotations:
    vault.hashicorp.com/agent-inject: 'true'
    vault.hashicorp.com/role: 'webapp_admin_r'
    vault.hashicorp.com/agent-inject-secret-credentials.txt: 'secret/data/webapp/admin'
spec:
  serviceAccountName: simple-app
  containers:
  - name: app
    image: nginx</span></pre> <p><span class="koboSpan" id="kobo.343.1">The</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.344.1"> highlighted annotations used are crucial for </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">vault-agent-injector</span></strong><span class="koboSpan" id="kobo.346.1"> to rewrite the Pod configuration so that the Vault initialization containers will </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">take effect.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Once our application is up and running, we can now check </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">the credentials:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.350.1">
$ kubectl exec -it webapp -c app -- cat /vault/secrets/credentials.txt
data: map[password:strong-password username:john.doe]
metadata: map[created_time:2023-10-08T19:23:50.814986175Z custom_metadata:&lt;nil&gt; deletion_time: destroyed:false version:1]</span></pre> <p><span class="koboSpan" id="kobo.351.1">Overall, we managed to interact with Vault in a secure way without having to mount any Vault-specific credentials to Kubernetes Secrets and thus on etcd. </span><span class="koboSpan" id="kobo.351.2">Instead, we relied on using the Kubernetes auth method supported by Vault. </span><span class="koboSpan" id="kobo.351.3">Now we can finally inject our credentials into the application by using the Vault sidecar container. </span><span class="koboSpan" id="kobo.351.4">However, Vault also supports another method of injecting Secrets into Kubernetes: the familiar CSI </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">Driver method.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.353.1">Vault and CSI Driver</span></h2>
<p><span class="koboSpan" id="kobo.354.1">Thanks to</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.355.1"> previous chapters, we are familiar with the Secret Store CSI Driver. </span><span class="koboSpan" id="kobo.355.2">Vault also enables us to use this approach. </span><span class="koboSpan" id="kobo.355.3">Using the CSI Driver is a different</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.356.1"> approach to mounting the Secrets from Vault on a Pod; however, it benefits from the same components. </span><span class="koboSpan" id="kobo.356.2">Since we have the Kubernetes auth method configured, we have the Vault authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">requirements tackled.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">However, we do need to have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">secrets-store-csi-driver</span></strong><span class="koboSpan" id="kobo.360.1"> package installed. </span><span class="koboSpan" id="kobo.360.2">We shall execute the following </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">Helm commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.362.1">
$ helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
$ helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver --namespace kube-system</span></pre> <p><span class="koboSpan" id="kobo.363.1">The next</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.364.1"> step is to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">SecretProviderClass</span></strong><span class="koboSpan" id="kobo.366.1"> pointing to the Secrets located </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">in Vault:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
apiVersion: secrets-store.csi.x-k8s.io/v1alpha1
kind: SecretProviderClass
metadata:
  name: vault-up-creds
  namespace: default
spec:
  provider: vault
  parameters:
    roleName: 'devweb-app'
    objects: |
    - objectName: "username"
      secretPath: "secret/data/devwebapp/config"
      secretKey: "username"
    - objectName: "password"
      secretPath: "secret/data/devwebapp/config"
      secretKey: "password"</span></pre> <p><span class="koboSpan" id="kobo.369.1">The next step</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.370.1"> is to provision the app, which will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">CSI provider:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      serviceAccountName: simple-app
      containers:
      - name: nginx-container
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - name: 'vault-up-creds'
      mountPath: '/mnt/secrets-store'
      readOnly: true
    volumes:
    - name: vault-up-creds
      csi:
        driver: 'secrets-store.csi.k8s.io'
        readOnly: true
        volumeAttributes:
          secretProviderClass: 'vault-up-creds'</span></pre> <p><span class="koboSpan" id="kobo.373.1">We managed to </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.374.1">securely integrate Vault with Kubernetes. </span><span class="koboSpan" id="kobo.374.2">We </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.375.1">achieved this using the CSI and Vault Injector methods. </span><span class="koboSpan" id="kobo.375.2">There is another method to integrate Kubernetes workloads with Vault and this is by running an installation of Vault </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">on Kubernetes.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.377.1">Vault hosted on Kubernetes</span></h2>
<p><span class="koboSpan" id="kobo.378.1">In certain</span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.379.1"> cases, a Vault cluster might be hosted on Kubernetes. </span><span class="koboSpan" id="kobo.379.2">It is an approach with several benefits. </span><span class="koboSpan" id="kobo.379.3">From a maintenance perspective, you take advantage of Kubernetes, and from a latency perspective, it can be faster, provided that the previous Vault installation was deployed on </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">another network.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">We shall do the installation </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">through minikube.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">We shall configure the values for the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">Vault installation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
cat &gt; helm-vault-raft-values.yml &lt;&lt;EOF
server:
  affinity: ""
  ha:
    enabled: true
    replicas: 3
    raft:
      enabled: true
EOF</span></pre> <p><span class="koboSpan" id="kobo.386.1">Due to running Vault on minikube, we do not have the option to run on multiple nodes. </span><span class="koboSpan" id="kobo.386.2">Thus, we disable the network affinity. </span><span class="koboSpan" id="kobo.386.3">Also, we shall run Vault with high availability enabled using </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">three replicas:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.388.1">
$ helm repo add hashicorp https://helm.releases.hashicorp.com
$ helm repo update
$ helm install vault hashicorp/vault --values helm-vault-raft-values.yml</span></pre> <p><span class="koboSpan" id="kobo.389.1">By running Vault in a high availability mode, the Raft consensus algorithm </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">is used.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">Take note that Vault is installed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">StatefulSet</span></strong><span class="koboSpan" id="kobo.393.1"> and the default number is </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1"> nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">If we check the logs, we shall see that Vault is </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">not initialized:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.398.1">
$ kubectl logs -f vault-0
2023-10-11T21:01:25.268Z [INFO]  core: security barrier not initialized</span></pre> <p><span class="koboSpan" id="kobo.399.1">We now need to </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">initialize Vault:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.401.1">
kubectl exec vault-0 -- vault operator init -key-shares=1 -key-threshold=1 -format=json &gt; cluster-keys.json</span></pre> <p><span class="koboSpan" id="kobo.402.1">This will create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">cluster-keys.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Let us</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.406.1"> see the contents of the </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">cluster key:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
{
  "unseal_keys_b64": [
    "the-unseal-key"
  ],
  "unseal_keys_hex": [
    "the-unseal-key-hex"
  ],
  "unseal_shares": 1,
  "unseal_threshold": 1,
  "recovery_keys_b64": [],
  "recovery_keys_hex": [],
  "recovery_keys_shares": 0,
  "recovery_keys_threshold": 0,
  "root_token": "root-token"
}</span></pre> <p><span class="koboSpan" id="kobo.409.1">Our next step is to unseal the vault using the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">unseal key:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.411.1">
$ VAULT_UNSEAL_KEY=$(jq -r ".unseal_keys_b64[]" cluster-keys.json)
$ kubectl exec vault-0 -- vault operator unseal $VAULT_UNSEAL_KEY</span></pre> <p><span class="koboSpan" id="kobo.412.1">Then we need to join the nodes one </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">by one:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.414.1">
$ kubectl exec -ti vault-1 -- vault operator raft join http://vault-0.vault-internal:8200
$ kubectl exec -ti vault-2 -- vault operator raft join http://vault-0.vault-internal:8200</span></pre> <p><span class="koboSpan" id="kobo.415.1">By joining</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.416.1"> the nodes on the cluster, the leader election process should start </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">taking place.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">Now we have to unseal the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">other nodes:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.420.1">
$ kubectl exec vault-1 -- vault operator unseal $VAULT_UNSEAL_KEY
$ kubectl exec vault-2 -- vault operator unseal $VAULT_UNSEAL_KEY</span></pre> <p><span class="koboSpan" id="kobo.421.1">Now that unsealing has been done, we can start adding data </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">to Vault.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">A port forward on Kubernetes should </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">be effective:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.425.1">
$ kubectl port-forward vault-0 8200:8200</span></pre> <p><span class="koboSpan" id="kobo.426.1">Next, execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.428.1">
#point Vault CLI to localhost
$ export VAULT_ADDR=http://0.0.0.0:8200
# extract vault root token
$ VAULT_ROOT_TOKEN=$(jq -r ".root_token" cluster-keys.json)
#login with root token
$ vault login $VAULT_ROOT_TOKEN
# use the kv-v2 secrets engine on path secret
$ vault secrets enable -path=secret kv-v2
# put secret
$ vault kv put secret/webapp/config username="static-user" password="static-password"</span></pre> <p><span class="koboSpan" id="kobo.429.1">Let us stop forwarding to </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">vault-0</span></strong><span class="koboSpan" id="kobo.431.1"> and forward to </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">another node:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.433.1">
$ kubectl port-forward vault-1 8200:8200</span></pre> <p><span class="koboSpan" id="kobo.434.1">We also evaluate whether we can fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">the Secrets:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.436.1">
$ vault kv get secret/webapp/config</span></pre> <p><span class="koboSpan" id="kobo.437.1">As expected, we </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.438.1">got </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">our Secrets:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.440.1">
$ vault kv get secret/webapp/config
...
</span><span class="koboSpan" id="kobo.440.2">====== Data ======
Key         Value
---         -----
password    static-password
username    static-user</span></pre> <p><span class="koboSpan" id="kobo.441.1">The Secrets were stored and replicated through </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">the node.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">Take note that in this example we enabled the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">kv-v2</span></strong><span class="koboSpan" id="kobo.445.1"> engine. </span><span class="koboSpan" id="kobo.445.2">The engine allows us to have multiple versions of Secrets. </span><span class="koboSpan" id="kobo.445.3">We will examine this functionality in the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">following section.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">We read through an overview of running Vault on Kubernetes, which covered aspects of running Vault in production mode. </span><span class="koboSpan" id="kobo.447.2">Therefore, it is worth noting the differences between running Vault in development mode and in </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">production mode.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.449.1">Development mode versus production mode</span></h2>
<p><span class="koboSpan" id="kobo.450.1">We have</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.451.1"> run Vault so far in development mode. </span><span class="koboSpan" id="kobo.451.2">Development mode has </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">certain characteristics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.453.1">Lack of </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">high availability</span></span></li>
<li><span class="koboSpan" id="kobo.455.1">Unsealed </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">by default</span></span></li>
<li><span class="koboSpan" id="kobo.457.1">Single </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">unseal key</span></span></li>
<li><span class="koboSpan" id="kobo.459.1">Initialized </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">by default</span></span></li>
<li><span class="koboSpan" id="kobo.461.1">Data stored </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">in memory</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.463.1">When it comes to production, things should </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">be different.</span></span></p>
<h3><span class="koboSpan" id="kobo.465.1">Production mode</span></h3>
<p><span class="koboSpan" id="kobo.466.1">In production mode, high availability </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.467.1">should be in place. </span><span class="koboSpan" id="kobo.467.2">This is achieved with the Raft protocol. </span><span class="koboSpan" id="kobo.467.3">When Vault is run in production, we do not have a standalone Vault instance but a Vault cluster based on the Raft protocol. </span><span class="koboSpan" id="kobo.467.4">This comes with the benefit of high availability; if a Vault node goes down, the requests can be served by another node that is available. </span><span class="koboSpan" id="kobo.467.5">Also, we can have performance standby nodes, nodes that are used to serve read requests, thus achieving horizontal scalability on </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">read operations.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">Another thing that is much different in production mode is the initialization. </span><span class="koboSpan" id="kobo.469.2">When a Vault cluster is created it must </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">be initialized.</span></span></p>
<h4><span class="koboSpan" id="kobo.471.1">Seal and unseal</span></h4>
<p><span class="koboSpan" id="kobo.472.1">To be able</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.473.1"> to use a Vault installation, Vault needs to be initialized so that the storage backend will be prepared to </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">receive data.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">During the initialization, the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">following happens:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.477.1">A root key </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">is generated</span></span></li>
<li><span class="koboSpan" id="kobo.479.1">The root key is stored in the </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">storage backend</span></span></li>
<li><span class="koboSpan" id="kobo.481.1">The root key </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">is encrypted</span></span></li>
<li><span class="koboSpan" id="kobo.483.1">The root key is stored in its </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">encrypted form</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.485.1">Since the root key is encrypted, it cannot be used; it needs to be decrypted. </span><span class="koboSpan" id="kobo.485.2">In order to decrypt a root key, an unseal key </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">is needed.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">The unseal key is not distributed as a single key. </span><span class="koboSpan" id="kobo.487.2">It uses Shamir’s secret-sharing algorithm (</span><a href="https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing"><span class="koboSpan" id="kobo.488.1">https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing</span></a><span class="koboSpan" id="kobo.489.1">). </span><span class="koboSpan" id="kobo.489.2">The unseal key is divided into parts called </span><em class="italic"><span class="koboSpan" id="kobo.490.1">shares</span></em><span class="koboSpan" id="kobo.491.1">, and those shares are spread throughout the cluster. </span><span class="koboSpan" id="kobo.491.2">For the key to be reassembled, it requires several shares to be reassembled, which is called</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.492.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">threshold</span></strong><span class="koboSpan" id="kobo.494.1">. </span><span class="koboSpan" id="kobo.494.2">Supposing an attacker steals some shares. </span><span class="koboSpan" id="kobo.494.3">It will not be possible to reconstruct the unseal key if the shares stolen are less than the threshold. </span><span class="koboSpan" id="kobo.494.4">By using Shamir’s secret sharing algorithm, Vault becomes more resilient to attacks that aim to acquire an </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">unseal key.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">When we unseal a vault, we use the unseal keys to retrieve the root key unencrypted. </span><span class="koboSpan" id="kobo.496.2">Then, the root key will reside unencrypted in the Vault memory. </span><span class="koboSpan" id="kobo.496.3">Vault, by using the root key, will be able to decrypt the encryption key needed to store data </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">in Vault.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">When we run Vault in production mode, the initialization is manual. </span><span class="koboSpan" id="kobo.498.2">The initialization is  executed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">vault operator init</span></strong><span class="koboSpan" id="kobo.500.1"> command. </span><span class="koboSpan" id="kobo.500.2">We can specify the number of shares—the unseal keys. </span><span class="koboSpan" id="kobo.500.3">As a result, we shall have printed some unseal keys and a root token. </span><span class="koboSpan" id="kobo.500.4">The unseal keys will be used to reassemble the root token. </span><span class="koboSpan" id="kobo.500.5">The root token is a token to which the root policy is attached. </span><span class="koboSpan" id="kobo.500.6">It is a token that can perform operations using the </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">root key.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">In the case of an intrusion, it is feasible to seal the vault. </span><span class="koboSpan" id="kobo.502.2">By sealing, the root key will be purged from Vault’s memory, and the vault will no longer be able to decrypt the data residing in its storage. </span><span class="koboSpan" id="kobo.502.3">Furthermore, operations and Vault services </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">will stop.</span></span></p>
<h4><span class="koboSpan" id="kobo.504.1">High availability</span></h4>
<p><span class="koboSpan" id="kobo.505.1">As we</span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.506.1"> have seen by installing Vault on Kubernetes, we had three instances deployed by default in StatefulSets. </span><span class="koboSpan" id="kobo.506.2">This is because of Raft. </span><span class="koboSpan" id="kobo.506.3">Vault is a distributed system and Raft is the consensus algorithm used. </span><span class="koboSpan" id="kobo.506.4">The minimum number of nodes is three. </span><span class="koboSpan" id="kobo.506.5">With three nodes, a failure of one node can be tolerated, provided the other two nodes continue operating. </span><span class="koboSpan" id="kobo.506.6">To calculate the node tolerance, use the formula </span><em class="italic"><span class="koboSpan" id="kobo.507.1">(n-1)/2</span></em><span class="koboSpan" id="kobo.508.1">, where </span><em class="italic"><span class="koboSpan" id="kobo.509.1">n</span></em><span class="koboSpan" id="kobo.510.1"> is the number of total nodes. </span><span class="koboSpan" id="kobo.510.2">For example, on a Vault installation consisting of five nodes, Vault will continue to be operational if two nodes fail. </span><span class="koboSpan" id="kobo.510.3">Once Vault is up and the nodes achieve consensus, data is written to the leader. </span><span class="koboSpan" id="kobo.510.4">The leader must replicate the data written to </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">the followers.</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.512.1"><img alt="Figure 11.2 – Replication of data" src="image/B20970_11_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.513.1">Figure 11.3 – Replication of data</span></p>
<p><span class="koboSpan" id="kobo.514.1">Take note that if a write operation is tried on a follower, Vault will respond to the caller with the leader address. </span><span class="koboSpan" id="kobo.514.2">This way, the data will be written to </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">the leader.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.516.1"><img alt="Figure 11.3 – Client redirect" src="image/B20970_11_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.517.1">Figure 11.4 – Client redirect</span></p>
<p><span class="koboSpan" id="kobo.518.1">Raft on Vault</span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.519.1"> tackles the problem of state synchronization, thus enabling the option of integrated storage. </span><span class="koboSpan" id="kobo.519.2">However, Vault can be backed by various forms of </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">external storage.</span></span></p>
<h4><span class="koboSpan" id="kobo.521.1">Storage</span></h4>
<p><span class="koboSpan" id="kobo.522.1">Vault has </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.523.1">various options for storage. </span><span class="koboSpan" id="kobo.523.2">There are options for external storage, which include databases such as Cassandra, DynamoDB, and more. </span><span class="koboSpan" id="kobo.523.3">Those options provide all the benefits that come with the underlying external storage. </span><span class="koboSpan" id="kobo.523.4">For example, in the case of DynamoDB, Vault can benefit from the backups, auditing, high availability, and all the other features that come </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">with DynamoDB.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">The other storage that is recommended is integrated storage. </span><span class="koboSpan" id="kobo.525.2">Integrated storage is maintained by HashiCorp. </span><span class="koboSpan" id="kobo.525.3">It is collocated with the host; this makes operations more efficient due to avoiding network hops. </span><span class="koboSpan" id="kobo.525.4">Also, by using integrated storage, the operational complexity is reduced and extra expertise on external storage is </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">not required.</span></span></p>
<h4><span class="koboSpan" id="kobo.527.1">KV-2 vs KV-1 storage engine</span></h4>
<p><span class="koboSpan" id="kobo.528.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">kv</span></strong><span class="koboSpan" id="kobo.530.1"> Secrets engine</span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.531.1"> is used to store Secrets in the physical storage in Vault. </span><span class="koboSpan" id="kobo.531.2">The latest version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">kv</span></strong><span class="koboSpan" id="kobo.533.1">, KV version 2, offers versioning on secret storage. </span><span class="koboSpan" id="kobo.533.2">By default, 10 versions of a secret are retained. </span><span class="koboSpan" id="kobo.533.3">The number is configurable. </span><span class="koboSpan" id="kobo.533.4">The older versions of a secret can be retrieved. </span><span class="koboSpan" id="kobo.533.5">Versioning increases storage costs. </span><span class="koboSpan" id="kobo.533.6">Deleting a version marks it as deleted, but the version is not physically deleted; it can be undeleted. </span><span class="koboSpan" id="kobo.533.7">To force a version’s physical deletion, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">destroy</span></strong><span class="koboSpan" id="kobo.535.1"> command needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">be used.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">Here is an example of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">destroy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.540.1">
$ vault kv destroy -mount=secret -versions=5 secret/webapp/admin</span></pre> <p><span class="koboSpan" id="kobo.541.1">The first version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">kv</span></strong><span class="koboSpan" id="kobo.543.1"> engine, KV version 1, does not have the versioning feature; thus, the storage needs are less than for KV </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">version 2.</span></span></p>
<h4><span class="koboSpan" id="kobo.545.1">Policies</span></h4>
<p><span class="koboSpan" id="kobo.546.1">The </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.547.1">principle of least permissions is crucial to ensuring the security of our Secrets. </span><span class="koboSpan" id="kobo.547.2">This is achieved by </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">Vault policies.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">By using policies, we can specify access privileges. </span><span class="koboSpan" id="kobo.549.2">Take, for example, the policies we created previously to fetch the Secrets from Vault on a Kubernetes application. </span><span class="koboSpan" id="kobo.549.3">We created the policy </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">devwebapp</span></strong><span class="koboSpan" id="kobo.551.1">, which will provide read capabilities to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">secret/devwebapp/config</span></strong><span class="koboSpan" id="kobo.553.1"> path. </span><span class="koboSpan" id="kobo.553.2">This policy was attached to the service account of the Kubernetes application that would use that secret. </span><span class="koboSpan" id="kobo.553.3">Thus, the tokens generated for that service account would be able to read only the </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">secret specified.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">To summarize, we had an overview of HashiCorp Vault and how it can be integrated with Kubernetes. </span><span class="koboSpan" id="kobo.555.2">Next, we will focus on another secret manager provider: </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">CyberArk Conjur.</span></span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.557.1">CyberArk Conjur</span></h1>
<p><span class="koboSpan" id="kobo.558.1">Conjur from</span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.559.1"> CyberArk is a Secrets management solution. </span><span class="koboSpan" id="kobo.559.2">It has a commercial and an open </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">source version.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">Conjur as a solution comes with the</span><a id="_idIndexMarker647"/> <span class="No-Break"><span class="koboSpan" id="kobo.562.1">following benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.563.1">Role-based access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.564.1">control</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.565.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.566.1">RBAC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.568.1">Logging </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">and auditing</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">Integration </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">with Kubernetes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.572.1">High availability</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.573.1">Let us take a closer</span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.574.1"> look at Conjur and see how it achieves </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">these qualities.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.576.1">How Conjur works</span></h2>
<p><span class="koboSpan" id="kobo.577.1">Conjur requires </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.578.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">following components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.580.1">Reverse </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">Nginx proxy</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.582.1">Conjur application</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.583.1">Database</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.584.1">The reverse proxy is used to handle the TLS termination. </span><span class="koboSpan" id="kobo.584.2">It sits in front of the Conjur application. </span><span class="koboSpan" id="kobo.584.3">The Conjur application is a Ruby-based application and is responsible for securely storing Secrets. </span><span class="koboSpan" id="kobo.584.4">This application is backed by a </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">PostgreSQL database.</span></span></p>
<h3><span class="koboSpan" id="kobo.586.1">High availability</span></h3>
<p><span class="koboSpan" id="kobo.587.1">Conjur uses </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.588.1">Raft to make high availability possible. </span><span class="koboSpan" id="kobo.588.2">It has a leader–follower architecture. </span><span class="koboSpan" id="kobo.588.3">The master will serve inbound traffic. </span><span class="koboSpan" id="kobo.588.4">In case of a master failure, a follower instance will be promoted </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">to master.</span></span></p>
<h3><span class="koboSpan" id="kobo.590.1">Server keys</span></h3>
<p><span class="koboSpan" id="kobo.591.1">Conjur </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.592.1">uses a data key, a Conjur UI key, and SSL keys. </span><span class="koboSpan" id="kobo.592.2">Those keys are generated during the Conjur server initialization plaintext. </span><span class="koboSpan" id="kobo.592.3">They should be encrypted to harden the initialization. </span><span class="koboSpan" id="kobo.592.4">This happens through the usage of a </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">master key.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">By using the master key, the keys </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">are encrypted.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">Before using the Conjur services, we need to unlock the keys using the master key. </span><span class="koboSpan" id="kobo.596.2">Once the encrypted keys are unlocked using the master key, they will reside on the Linux keyring and memory-based file system. </span><span class="koboSpan" id="kobo.596.3">Conjur offers the option to use AWS KMS or a hardware security module as a </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">master key.</span></span></p>
<h3><span class="koboSpan" id="kobo.598.1">Storage</span></h3>
<p><span class="koboSpan" id="kobo.599.1">For storing </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.600.1">Secrets, Conjur is backed by a database. </span><span class="koboSpan" id="kobo.600.2">Conjur uses PostgreSQL to store the Secrets. </span><span class="koboSpan" id="kobo.600.3">Conjur benefits from all the features that come with a PostgreSQL database. </span><span class="koboSpan" id="kobo.600.4">A PostgreSQL database comes with many features, such as replication, auditing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">fine-grained permissions.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">For example, a secret stored on Conjur can be found on the PostgreSQL database by querying the </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">Secrets table:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.604.1">
# SELECT*FROM secrets;
resource_id           |version |value|expires_at
----------------------+--------+-----+------------
acccount:variable:test|1       |\x4..|
(1 row)</span></pre> <p><span class="koboSpan" id="kobo.605.1">This secret is unusable since it is encrypted. </span><span class="koboSpan" id="kobo.605.2">In case of a breach, the names of the Secrets would be leaked but not the actual value of the Secrets since the decryption key </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">is needed.</span></span></p>
<h3><span class="koboSpan" id="kobo.607.1">Versioning</span></h3>
<p><span class="koboSpan" id="kobo.608.1">Conjur also</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.609.1"> has the secret versioning feature. </span><span class="koboSpan" id="kobo.609.2">It keeps the last 20 versions of </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">a secret.</span></span></p>
<h3><span class="koboSpan" id="kobo.611.1">Policies</span></h3>
<p><span class="koboSpan" id="kobo.612.1">By using</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.613.1"> Conjur policies, we can define security rules that describe which roles have permissions to perform certain operations on a </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">Conjur resource.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">Here’s an example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">Conjur policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.617.1">
- !policy
  id: ExamplePolicy
  body:
  - !host webApp
  - !variable secretVar
  - !permit
    role: !host webApp
    privileges: [read, execute]
    resource: !variable secretVar</span></pre> <p><span class="koboSpan" id="kobo.618.1">As we can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">ExamplePolicy</span></strong><span class="koboSpan" id="kobo.620.1"> policy provides to the non-human identity </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">webApp</span></strong><span class="koboSpan" id="kobo.622.1"> the </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.623.1">permission to read the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">secretVar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.625.1"> variable.</span></span></p>
<h3><span class="koboSpan" id="kobo.626.1">Audit logs</span></h3>
<p><span class="koboSpan" id="kobo.627.1">As </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.628.1">we have seen in previous chapters, audit logs are crucial when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">Secrets management.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">From the documentation, we can see what an audit log in JSON format </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
{
  "</span><strong class="bold"><span class="koboSpan" id="kobo.633.1">subject@43868</span></strong><span class="koboSpan" id="kobo.634.1">": {
    "resource": "demo:group:security_ops"
  },
  "policy@43868": {
    "version": "1",
    "id": "demo:policy:root"
  },
  "</span><strong class="bold"><span class="koboSpan" id="kobo.635.1">auth@43868"</span></strong><span class="koboSpan" id="kobo.636.1">: {
    "user": "demo:user:admin"
  },
  "</span><strong class="bold"><span class="koboSpan" id="kobo.637.1">action@43868</span></strong><span class="koboSpan" id="kobo.638.1">": {
    "operation": "add"
  },
  "PROGRAM": "conjur",
  "PID": "e9c07c05-4dc2-4809-b7e1-43f5d3a20599",
  "MSGID": "policy",
  "MESSAGE": "demo:user:admin added resource demo:group:security_ops",
  "LEVEL": "notice",
  "ISODATE": "2020-04-14T20:40:24.806+00:00",
  "FACILITY": "auth"
}</span></pre> <p><span class="koboSpan" id="kobo.639.1">The </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.640.1">preceding log has all the information that we need to identify what happened on our Conjur server. </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">action</span></strong><span class="koboSpan" id="kobo.642.1"> displays the action that took place, </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">auth</span></strong><span class="koboSpan" id="kobo.644.1"> displays the entity that executed the action that took place, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">subject</span></strong><span class="koboSpan" id="kobo.646.1"> displays the </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">resource affected.</span></span></p>
<h3><span class="koboSpan" id="kobo.648.1">Kubernetes integration</span></h3>
<p><span class="koboSpan" id="kobo.649.1">Conjur has </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.650.1">many options for enabling Kubernetes integration. </span><span class="koboSpan" id="kobo.650.2">One of them is the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">Authenticator Client.</span></span></p>
<h4><span class="koboSpan" id="kobo.652.1">Kubernetes Authenticator Client</span></h4>
<p><span class="koboSpan" id="kobo.653.1">Conjur has</span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.654.1"> the Kubernetes Authenticator Client. </span><span class="koboSpan" id="kobo.654.2">The Kubernetes application that uses Conjur Secrets has a sidecar container with a Conjur client. </span><span class="koboSpan" id="kobo.654.3">The client using the service account will authenticate with Conjur. </span><span class="koboSpan" id="kobo.654.4">Then, Conjur will issue a temporary token. </span><span class="koboSpan" id="kobo.654.5">The sidecar container will use that temporary token to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">the Secrets.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">In this section, we learned more about the secret manager Conjur. </span><span class="koboSpan" id="kobo.656.2">We identified its features and how it can integrate with Kubernetes. </span><span class="koboSpan" id="kobo.656.3">Those features, along with the features that we focused on in the previous chapters, form the standards for managing Secrets using an external </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">secret store.</span></span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.658.1">Qualities for securely managing Secrets</span></h1>
<p><span class="koboSpan" id="kobo.659.1">As we </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.660.1">have seen, there are certain qualities when it comes to storing external Secrets. </span><span class="koboSpan" id="kobo.660.2">In this chapter, we took a deep dive into the HashiCorp Vault and how it integrates with Kubernetes. </span><span class="koboSpan" id="kobo.660.3">We also had a look at another Secrets management </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">provider, Conjur.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">A secret manager needs to have </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">certain qualities:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.664.1">High availability</span></span></li>
<li><span class="koboSpan" id="kobo.665.1">Encryption </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">of data</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.667.1">Secure access</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.668.1">Versioning</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.669.1">RBAC</span></span></li>
<li><span class="koboSpan" id="kobo.670.1">Integration </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">with Kubernetes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.672.1">Auditing</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.673.1">Those qualities are essential to ensuring the secure and robust storage of an </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">application’s Secrets.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.675.1">High availability</span></h2>
<p><span class="koboSpan" id="kobo.676.1">High availability</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.677.1"> is required to ensure our data is safe. </span><span class="koboSpan" id="kobo.677.2">It can protect us from losing any data in case of a service outage. </span><span class="koboSpan" id="kobo.677.3">It ensures business continuity. </span><span class="koboSpan" id="kobo.677.4">External secret stores such as Vault and Conjur achieve high availability by utilizing Raft, the popular consensus method. </span><span class="koboSpan" id="kobo.677.5">By having a consensus method, the cluster approach for availability is feasible; we can add multiple nodes to different data centers, which will form a cluster and share workloads. </span><span class="koboSpan" id="kobo.677.6">Thanks to this choice, in case of a failure, data is distributed in a way that can </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">tolerate failures.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.679.1">Encryption of data</span></h2>
<p><span class="koboSpan" id="kobo.680.1">The data in an </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.681.1">external secret store should be encrypted. </span><span class="koboSpan" id="kobo.681.2">The encryption keys that encrypt the data in the external secret store should also be encrypted. </span><span class="koboSpan" id="kobo.681.3">As we have seen previously, providers achieve this by implementing mechanisms such as Shamir’s secret sharing or by using a master key to encrypt the data encryption keys. </span><span class="koboSpan" id="kobo.681.4">Then, the data encryption keys are used to encrypt the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">actual data.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.683.1">Secure access</span></h2>
<p><span class="koboSpan" id="kobo.684.1">Access is</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.685.1"> secured with proper authentication methods and the principle of least privilege. </span><span class="koboSpan" id="kobo.685.2">We can achieve this with policies. </span><span class="koboSpan" id="kobo.685.3">External secret stores such as Vault and Conjur give us the option of policies. </span><span class="koboSpan" id="kobo.685.4">With policies, we can specify the operations that an identity can perform on a secret resource. </span><span class="koboSpan" id="kobo.685.5">This allows us to create fine-grained permissions that minimize the risks that come with overprivileged accounts that interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">Secrets storage.</span></span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.687.1">Versioning</span></h2>
<p><span class="koboSpan" id="kobo.688.1">All the </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.689.1">secret store providers we worked with throughout this book offered versioning. </span><span class="koboSpan" id="kobo.689.2">Versioning is crucial in preventing accidental deletion and enabling smooth rotation. </span><span class="koboSpan" id="kobo.689.3">Secrets, by their nature, are sensitive, which makes rotation a necessity. </span><span class="koboSpan" id="kobo.689.4">Having a versioning of Secrets enables developer teams to proceed with the secret rotation operations in a robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">resilient way.</span></span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.691.1">Integration with Kubernetes</span></h2>
<p><span class="koboSpan" id="kobo.692.1">As we </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.693.1">can see, integration with Kubernetes is achieved using the least permissions needed, and we did not store any sensitive keys in etcd. </span><span class="koboSpan" id="kobo.693.2">Instead, HashiCorp Vault or Conjur were managed through Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">service accounts.</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">Secrets were injected into our applications without having to store them in etcd. </span><span class="koboSpan" id="kobo.695.2">Also, we did not have to store any Secrets that could communicate with the </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">secret storage.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.697.1">Auditing</span></h2>
<p><span class="koboSpan" id="kobo.698.1">Auditing is</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.699.1"> crucial for Secrets management. </span><span class="koboSpan" id="kobo.699.2">Through auditing, we achieve a record of activity towards the resources that reside on an external secret store. </span><span class="koboSpan" id="kobo.699.3">In all the options for external Secrets storage, auditing capabilities are present. </span><span class="koboSpan" id="kobo.699.4">In case of a breach or any malevolent action, auditing can help us identify the exposure and take remediation actions. </span><span class="koboSpan" id="kobo.699.5">Auditing can also help in debugging as well as </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.700.1">ensure that the system </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">operates properly.</span></span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.702.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.703.1">In this chapter, we took a deep dive into HashiCorp Vault, how it integrates with Kubernetes, and the different methods that can be used to access the Vault Secrets through Kubernetes workloads. </span><span class="koboSpan" id="kobo.703.2">We used Secrets from Vault either through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">vault-agent-injector</span></strong><span class="koboSpan" id="kobo.705.1"> method or through the CSI Driver. </span><span class="koboSpan" id="kobo.705.2">Furthermore, we performed an installation of Vault on Kubernetes and identified the qualities for a Vault production deployment. </span><span class="koboSpan" id="kobo.705.3">We also learned about another Secrets provider, CyberArk Conjur, and its capabilities. </span><span class="koboSpan" id="kobo.705.4">In the next chapter, we will focus on the overall use cases of Secrets and the different approaches that we can follow for integrating with external secret stores. </span><span class="koboSpan" id="kobo.705.5">Also, we will take a deep dive into the approaches to integration with external </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">secret stores.</span></span></p>
</div>
</body></html>