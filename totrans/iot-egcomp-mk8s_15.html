<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer410">
<h1 class="chapter-number" id="_idParaDest-241"><a id="_idTextAnchor243"/>15</h1>
<h1 id="_idParaDest-242"><a id="_idTextAnchor244"/>Implementing Strict Confinement for Isolated Containers</h1>
<p>In the previous chapter, we looked at how to build secure containers using Kata Containers and how to improve workload isolation with hardware virtualization technology. We also discussed the best practices for securing your production-grade cluster with containers. The MicroK8s add-on option has also made it easier to activate Kata Containers, which can significantly increase the security and isolation of your container operations.</p>
<p>In this chapter, we will take a look at another approach to isolation using snap confinement options to run containers in complete isolation, meaning no access to files, networks, processes, or any other system resource without requesting specific access via an interface. Confinement models describe how much access a particular snap has to a user’s machine. There are currently three choices available, as follows: </p>
<ul>
<li>The <em class="italic">strict</em> confinement level<a id="_idIndexMarker1211"/> operates in complete isolation, with access limited to a level that is always regarded as safe. As a result, without requesting particular access via an interface, strictly limited snaps cannot access your files, network, processes, or any other system resource. </li>
<li>The <em class="italic">classic</em> confinement level<a id="_idIndexMarker1212"/> is similar to conventional Linux packages and can access a system’s resources.</li>
<li>The <em class="italic">devmode</em> confinement level<a id="_idIndexMarker1213"/> runs in a limited environment with full access to system resources and generates debug output to locate unidentified interfaces. This is specifically designed for snap creators and developers.</li>
</ul>
<p>As we discussed in <a href="B18115_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing MicroK8s</em>, MicroK8s is a snap, and we employed the classic confinement model throughout this book. The interface of each snap is carefully chosen by the author to enable specialized access to a resource in accordance with the snap’s requirements. For example, network access, desktop access, and audio access are all provided by common interfaces.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Overview of Snap, Snapcraft, and Ubuntu Core</li>
<li>Setting up Ubuntu Core on a Raspberry Pi board</li>
<li>Setting up MicroK8s on Ubuntu Core</li>
<li>Deploying a sample containerized application</li>
</ul>
<h1 id="_idParaDest-243"><a id="_idTextAnchor245"/>Overview of Snap, Snapcraft, and Ubuntu Core</h1>
<p>Before going into detail about how strict confinement snaps offer isolation to applications, we will delve into a little bit of history on how embedded Linux development was handled before the advent of snaps.</p>
<p>Traditionally, getting software to embedded Linux systems has proven difficult. There were different Linux packaging formats (RPM, DEB, and so on) and there is no standardization of formats. Furthermore, software packages frequently necessitate sophisticated code to manage installation and updates that are incompatible with one another, have unmet dependencies, or write to the entire system.</p>
<p>Snaps<a id="_idIndexMarker1214"/> were envisioned to answer the concerns of embedded Linux developers seeking a secure environment and precise configuration to run their applications. They allow software publishers and developers to manage the binary that is supplied and the exact version that their users have access to. </p>
<p>Snaps are easy to create, build, and deploy as compared to standard Linux software distribution. Snaps get automatically <a id="_idIndexMarker1215"/>updated <strong class="bold">over the air</strong> (<strong class="bold">OTA</strong>) and via deltas, keeping the functionality of an embedded Linux device always fresh and reducing the risk of breaking. Snaps are compatible with all major Linux distributions and may be used on any type of device from desktop to cloud and IoT devices. </p>
<p>Snapcraft (<a href="https://snapcraft.io/">https://snapcraft.io/</a>) is a<a id="_idIndexMarker1216"/> framework for creating and distributing snaps by bringing together<a id="_idIndexMarker1217"/> different components of the application into a single, cohesive bundle. Developers submit their snaps to a central repository known as Snap Store—a universal app store that allows users to publish, browse, install, distribute, and deploy apps in the cloud, on desktops, and on IoT devices from any Linux distribution. </p>
<p>The Ubuntu Core embedded <a id="_idIndexMarker1218"/>OS (<a href="https://ubuntu.com/core">https://ubuntu.com/core</a>) is built on snaps and is free and open source. In Ubuntu Core, everything is a snap. Even the kernel is a snap. In Ubuntu <a id="_idIndexMarker1219"/>Core, only snaps that use the strict confinement model can be installed. It is a cutting-edge new operating system (OS) designed from the ground up with zero-trust security in mind. It efficiently decouples the base system and OS from the installed apps by containerizing the Linux kernel and runtime environments. Containerization allows you to separate and provide lockdown functionality, with applications running in a security sandbox by default (kernel features such as AppArmor, seccomp, security policies, and device permissions are leveraged).</p>
<p>MicroK8s and Ubuntu Core share characteristics including self-healing, high availability, automatic OTA updates, reliability, and security. Running MicroK8s on Ubuntu Core provides Kubernetes with the benefits of a solid computing foundation. Furthermore, combining Ubuntu Core and MicroK8s offers a streamlined, embedded Kubernetes experience for IoT and Edge applications, with a small footprint and performance efficiency optimizations.</p>
<p>In the next section, we will go over the procedures for setting up a Kubernetes Raspberry Pi cluster with snap strict confinement.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor246"/>Setting up Ubuntu Core on a Raspberry Pi board</h1>
<p>Now that we are <a id="_idIndexMarker1220"/>clear on the snap confinement concepts, we will delve into the steps of creating a Kubernetes Raspberry Pi cluster that uses snap strict confinement.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor247"/>What we are trying to achieve </h2>
<p>We’ll list down the steps that we’re seeking to work through in this section as follows: </p>
<ol>
<li>Setting up an <a id="_idIndexMarker1221"/>Ubuntu Core image to SD card</li>
<li>Creating an Ubuntu SSO account</li>
<li>Generating an SSH key pair</li>
<li>Booting Ubuntu Core on Raspberry Pi</li>
</ol>
<p>The Raspberry Pi cluster that we will build in this step is depicted in <em class="italic">Figure 15.1</em> as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer388">
<img alt="Figure 15.1 – The Raspberry Pi cluster that uses snap strict confinement " height="567" src="image/Figure_15.01_B18115.jpg" width="1117"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Raspberry Pi cluster that uses snap strict confinement</p>
<p>Now that we know what we want to do, let’s look at the requirements.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor248"/>Requirements</h2>
<p>The following are the prerequisites<a id="_idIndexMarker1222"/> for building the Ubuntu Core Raspberry Pi Kubernetes cluster:</p>
<ul>
<li>A microSD card (4 GB minimum; 8 GB recommended)</li>
<li>A computer with a microSD card drive</li>
<li>Raspberry Pi 2, 3, or 4 (1 or more)</li>
<li>A micro-USB power cable (USB-C for the Pi 4)</li>
<li>A Wi-Fi network or an Ethernet cable with an internet connection</li>
<li>(Optional) A monitor with an HDMI interface</li>
<li>(Optional) An HDMI cable for Pi 2 and 3 and a micro-HDMI cable for Pi 4</li>
<li>(Optional) A USB <a id="_idIndexMarker1223"/>keyboard</li>
</ul>
<p>Now that we’ve established the requirements, we’ll move on to the step-by-step instructions on how to create a Kubernetes Raspberry Pi cluster that uses snap strict confinement.</p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor249"/>Step 1 – Setting up an Ubuntu Core image to an SD card</h2>
<p>The<a id="_idIndexMarker1224"/> first step is to install an Ubuntu Core image to the microSD card. To do that, we will be using the <strong class="bold">Raspberry Pi Imager tool</strong> to install <a id="_idIndexMarker1225"/>an OS image to a microSD card that can then be used with Raspberry Pi.</p>
<p>Download and install <strong class="bold">Raspberry Pi Imager</strong> from the Raspberry Pi website on a computer equipped with an SD card reader. </p>
<p>As <a id="_idIndexMarker1226"/>depicted in <em class="italic">Figure 15.2</em>, run Raspberry Pi Imager with the microSD card and open the <strong class="bold">CHOOSE OS</strong> menu as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer389">
<img alt="Figure 15.2 – Raspberry Pi Imager " height="448" src="image/Figure_15.02_B18115.jpg" width="764"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – Raspberry Pi Imager</p>
<p>From the OS menu, choose <strong class="bold">Other general purpose OS</strong> from the options listed, as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer390">
<img alt="Figure 15.3 – Raspberry Pi Imager OS options " height="438" src="image/Figure_15.03_B18115.jpg" width="747"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – Raspberry Pi Imager OS options</p>
<p>Choose the <strong class="bold">Ubuntu Core</strong> <strong class="bold">64-bit version</strong> that works with Raspberry Pi 2,3, 3, and 4 from the<a id="_idIndexMarker1227"/> options listed (refer to <em class="italic">Figure 15.4</em>) as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer391">
<img alt="Figure 15.4 – Choose Ubuntu Core 64-bit version " height="453" src="image/Figure_15.04_B18115.jpg" width="681"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – Choose Ubuntu Core 64-bit version</p>
<p>As <a id="_idIndexMarker1228"/>depicted in <em class="italic">Figure 15.5</em>, open the <strong class="bold">Storage</strong> menu after selecting <strong class="bold">Ubuntu Core 64-bit image</strong>. Choose the micro SD card that you’ve inserted as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer392">
<img alt="Figure 15.5 – Raspberry Pi Imager write operation " height="448" src="image/Figure_15.05_B18115.jpg" width="680"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – Raspberry Pi Imager write operation</p>
<p>Finally, click on <strong class="bold">Write</strong> to start the operation and Raspberry Pi Imager will wipe your micro SD<a id="_idIndexMarker1229"/> card data; you will be prompted to confirm this procedure.</p>
<p>Post confirmation, Raspberry Pi Imager will start flashing OS images to the micro SD card. It will take a while to finish.</p>
<p>Once finished, continue with the creation of an Ubuntu Single Sign-On (SSO) account.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor250"/>Step 2 – Creating an Ubuntu SSO account</h2>
<p>An Ubuntu <strong class="bold">SSO</strong> account<a id="_idIndexMarker1230"/> needs to be created so that Secure shell (SSH) public keys can be stored and linked to an email address. This allows Ubuntu Core devices to only permit SSH connections from the devices that have public keys that match those in your SSO account.</p>
<p>Go to <a href="https://login.ubuntu.com/">https://login.ubuntu.com/</a> and fill in the relevant information, and after the SSO account has been <a id="_idIndexMarker1231"/>created, generate the SSH key pair as explained in the following section.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor251"/>Step 3 – Generating an SSH key pair</h2>
<p><strong class="bold">SSH</strong>, as we<a id="_idIndexMarker1232"/> know, is a popular way to connect to remote Linux servers. The authentication process involves the pairing of a private local key with a public remote key, which is used to secure communication from your device to Linux <a id="_idIndexMarker1233"/>servers that are hosting the application.</p>
<p>Using the free and open source OpenSSH software included in Windows 10, SSH keys can be generated. SSH keys can also be generated through the PuTTYgen utility, which has support for various platforms. We’re going to use the built-in Windows OpenSSH client for the following steps.</p>
<p>From the PowerShell window, enter the following command:</p>
<p class="source-code">ssh-keygen</p>
<p>The first step asks where you would like to save the key, and you can accept the default answer by pressing <strong class="source-inline">Return</strong>, as shown in the command execution output in <em class="italic">Figure 15.6</em>. The passphrase is requested in the second step. When a passphrase is entered, it is required to use the passphrase each time the key is accessed. The passphrase is optional; pressing <strong class="source-inline">Return</strong> twice will create a key pair without requiring a passphrase, as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer393">
<img alt="Figure 15.6 – SSH key generation " height="328" src="image/Figure_15.06_B18115.jpg" width="590"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – SSH key generation</p>
<p>The private <a id="_idIndexMarker1234"/>key and the public key can be found in the same folder once the process is complete, as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer394">
<img alt="Figure 15.7 – Private and public keys generated " height="78" src="image/Figure_15.07_B18115.jpg" width="558"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – Private and public keys generated</p>
<p>We can now use the generated public and private keys for Ubuntu Core installation. The following step is to add the public key to an Ubuntu SSO account so that it could be used to permit connections from the devices that have public keys.</p>
<p>From the Ubuntu SSO account login, under the <strong class="bold">SSH keys</strong> section, copy the contents of the <strong class="source-inline">ubuntu-core-rpi.pub</strong> (public key) file to import the public key as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer395">
<img alt="Figure 15.8 – Import SSH keys " height="583" src="image/Figure_15.08_B18115.jpg" width="1153"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – Import SSH keys</p>
<p>The <a id="_idIndexMarker1235"/>following screenshot shows that the public key has been imported successfully:</p>
<div>
<div class="IMG---Figure" id="_idContainer396">
<img alt="Figure 15.9 – SSH keys imported " height="473" src="image/Figure_15.09_B18115.jpg" width="863"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – SSH keys imported</p>
<p>Now that we have imported SSH keys to the Ubuntu SSO account, the following step is to power Raspberry Pi and boot Ubuntu Core.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor252"/>Step 4 – Booting Ubuntu Core on Raspberry Pi</h2>
<p>Extract the SD card <a id="_idIndexMarker1236"/>from your laptop and insert it into Raspberry <a id="_idIndexMarker1237"/>Pi. Before powering the Pi, connect an HDMI screen and a USB keyboard. Power on the Pi and you will be able to see the boot process on the screen. It typically takes less than 5 minutes to complete the booting process.</p>
<p>When the boot process is complete, you will see instructions for configuring the network and creating an administrator account on Ubuntu Core. In this configuration, you will be able to configure Wi-Fi settings, and the following step will require you to provide the email address associated with your SSO account. Once configured, the device will automatically update and, if necessary, restart.</p>
<p>After you provide your email and the Pi connects to your account, you will be able to use any SSH client, for example, PuTTY, to connect to your Pi.</p>
<p><em class="italic">Success! You are now connected to Ubuntu Core running on your Raspberry Pi.</em></p>
<p>We’ve finished configuring the settings and we are ready to go on to the following step of installing and configuring the MicroK8s snap with strict confinement.</p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor253"/>Setting up MicroK8s on Ubuntu Core</h1>
<p>SSH into your<a id="_idIndexMarker1238"/> control plane node and install the latest version of the MicroK8s snap with strict confinement as in the following command:</p>
<p class="source-code">sudo snap install microk8s --channel=latest/edge/strict</p>
<p>The following is the output after the execution of the preceding command, which confirms that the MicroK8s snap with strict confinement was successfully configured:</p>
<div>
<div class="IMG---Figure" id="_idContainer397">
<img alt="Figure 15.10 – Successful MicroK8s snap installation  " height="105" src="image/Figure_15.10_B18115.jpg" width="953"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – Successful MicroK8s snap installation </p>
<p>Now that we have installed the MicroK8s snap, let’s run the <strong class="source-inline">microk8s status</strong> command to verify its running state as follows:</p>
<p class="source-code">microk8s status</p>
<p>The<a id="_idIndexMarker1239"/> following is the output after the execution of the preceding command, which confirms that the MicroK8s snap with strict confinement is running successfully:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer398">
<img alt="Figure 15.11 – MicroK8s snap is running " height="202" src="image/Figure_15.11_B18115.jpg" width="634"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11 – MicroK8s snap is running</p>
<p>Strict confinement <em class="italic">locks down</em> the apps in the snap using Linux kernel security capabilities. Access will be extremely constrained for a highly contained application without any stated interfaces. MicroK8s running successfully indicates that all necessary interfaces are specified and application access requirements are met.</p>
<p>To view the MicroK8s snap interfaces, use the following command:</p>
<p class="source-code">snap connections microk8s</p>
<p>The following is the output after the execution of the preceding command, which lists interfaces of the MicroK8s snap:</p>
<div>
<div class="IMG---Figure" id="_idContainer399">
<img alt="Figure 15.12 – MicroK8s snap interfaces " height="303" src="image/Figure_15.12_B18115.jpg" width="1036"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.12 – MicroK8s snap interfaces</p>
<p>In the end, all snaps would need to aim for a strict confinement level, using only the APIs required for the application to run properly, and nothing else. Additionally, Ubuntu Core necessitates that snaps are on a strict confinement model.</p>
<p>Read more about interfaces and confinement in the Snapcraft<a id="_idIndexMarker1240"/> documentation at <a href="https://docs.snapcraft.io">https://docs.snapcraft.io</a>.</p>
<p>Now that we<a id="_idIndexMarker1241"/> have installed MicroK8s, let’s verify whether the node status is <strong class="source-inline">Ready</strong> using the <strong class="source-inline">kubectl get nodes</strong> command as follows:</p>
<p class="source-code">kubectl get nodes</p>
<p>If the installation is successful, then you should see the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer400">
<img alt="Figure 15.13 – Verifying whether the node is in a Ready state " height="82" src="image/Figure_15.13_B18115.jpg" width="639"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.13 – Verifying whether the node is in a Ready state</p>
<p>Since MicroK8s is packaged as a snap, it will automatically upgrade to newer point releases. Also, the strictly confined MicroK8s version of the snap is currently on a dedicated snap channel that is synchronized with the latest version of upstream of Kubernetes, that is, an open source version of Kubernetes managed and maintained by the Cloud Native Computing Foundation.</p>
<p>Based on MicroK8s releases, channels are formed of a track (or series) and an anticipated level of stability (<em class="italic">stable</em>, <em class="italic">candidate</em>, <em class="italic">beta</em>, and <em class="italic">edge</em>). For more information about releases and channels, run the following command:</p>
<p class="source-code">snap info microk8s</p>
<p>The following is the output after the execution of the preceding command, which shows the list of channels (<em class="italic">stable</em>, <em class="italic">candidate</em>, <em class="italic">beta</em>, and <em class="italic">edge</em>) and their release dates:</p>
<div>
<div class="IMG---Figure" id="_idContainer401">
<img alt="Figure 15.14 – MicroK8s list of channels (stable, candidate, beta, and edge) and the release dates " height="258" src="image/Figure_15.14_B18115.jpg" width="847"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.14 – MicroK8s list of channels (stable, candidate, beta, and edge) and the release dates</p>
<p>Repeat<a id="_idIndexMarker1242"/> the MicroK8s installation process on the other nodes as well.</p>
<p>The output of the command for the MicroK8s installation on the worker node is as follows:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer402">
<img alt="Figure 15.15 – Successful MicroK8s snap installation on the worker1 node  " height="76" src="image/Figure_15.15_B18115.jpg" width="885"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.15 – Successful MicroK8s snap installation on the worker1 node </p>
<p>The following <strong class="source-inline">microk8s status</strong> command execution output confirms that MicroK8s is running successfully on the worker node as well:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer403">
<img alt="Figure 15.16 – Verifying whether MicroK8s is running " height="203" src="image/Figure_15.16_B18115.jpg" width="623"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.16 – Verifying whether MicroK8s is running</p>
<p>Now that MicroK8s is running, the following step is to check whether the <strong class="source-inline">kubectl get nodes</strong> command displays the node in a <strong class="source-inline">Ready</strong> state as indicated in the command execution output as follows:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer404">
<img alt="Figure 15.17 – Verifying whether the node is in a Ready state " height="76" src="image/Figure_15.17_B18115.jpg" width="665"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.17 – Verifying whether the node is in a Ready state</p>
<p>We<a id="_idIndexMarker1243"/> have completed the installation of MicroK8s on all boards. The following step is to add the worker node to the control plane node. Open the PuTTY shell to the control plane node and run the following command to generate the connection string:</p>
<p class="source-code">sudo microk8s.add-node</p>
<p>The following is the output after the execution of the preceding command. It validates that the command was successfully executed and provides instructions for generating the connection string: </p>
<div>
<div class="IMG---Figure" id="_idContainer405">
<img alt="Figure 15.18 – Generating the connection string for adding nodes " height="203" src="image/Figure_15.18_B18115.jpg" width="822"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.18 – Generating the connection string for adding nodes</p>
<p>As<a id="_idIndexMarker1244"/> indicated by the preceding command execution output, the connection string is generated in the form of <strong class="source-inline">&lt;control plane_ip&gt;:&lt;port&gt;/&lt;token&gt;</strong>.</p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor254"/>Adding the worker node</h2>
<p>We now have the<a id="_idIndexMarker1245"/> connection string to join with the control plane node. Open the PuTTY shell to the worker node and run the <strong class="source-inline">join</strong> command to add it to the cluster, as can be seen in the following command:</p>
<p class="source-code">microk8s join &lt;control plane_ip&gt;:&lt;port&gt;/&lt;token&gt;</p>
<p>The command was successfully executed, and the node has joined the cluster, as shown in the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer406">
<img alt="Figure 15.19 – Add worker#1 node to the cluster " height="306" src="image/Figure_15.19_B18115.jpg" width="799"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.19 – Add worker#1 node to the cluster</p>
<p>As indicated by the command execution output shown in <em class="italic">Figure 15.19</em>, you should be able to see the new node in a few seconds on the control plane node.</p>
<p>Use the following command to verify whether the new node is added to the cluster:</p>
<p class="source-code">kubectl get nodes</p>
<p>The <a id="_idIndexMarker1246"/>following command execution output shows that the control plane and <strong class="source-inline">worker1</strong> nodes are part of the cluster:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer407">
<img alt="Figure 15.20 – The cluster is ready and the control plane and worker1 nodes are part of the cluster " height="96" src="image/Figure_15.20_B18115.jpg" width="638"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.20 – The cluster is ready and the control plane and worker1 nodes are part of the cluster</p>
<p>At this point, you have a fully functional multi-node Kubernetes cluster with strict confinement enabled. To summarize, we have installed the MicroK8s snap on the Raspberry<a id="_idIndexMarker1247"/> Pi boards running Ubuntu Core and joined multiple deployments to form the cluster. We’ve seen how to add nodes to the cluster as well. In the following section, we are going to deploy a sample application on the MicroK8s cluster that we just created.</p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor255"/>Deploying a sample containerized application</h1>
<p>In this<a id="_idIndexMarker1248"/> section, we will be deploying one of the nginx deployments from the Kubernetes examples repository on our MicroK8s cluster setup, as follows:</p>
<p class="source-code">kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml</p>
<p>The following is the output after the execution of the preceding command. It indicates that there is no error in the deployment, and in the following steps, we can verify whether the deployment is successful using the <strong class="source-inline">get pods</strong> command as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer408">
<img alt="Figure 15.21 – Sample application deployment " height="71" src="image/Figure_15.21_B18115.jpg" width="1070"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.21 – Sample application deployment</p>
<p>Check the status of the pods to verify whether the application has been deployed and is running as follows:</p>
<p class="source-code">kubectl get pods -l app=nginx</p>
<p>The following is the output after the execution of the preceding command, which indicates that pods are created and that their status is <strong class="source-inline">Running</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer409">
<img alt="Figure 15.22 – Checking whether pods have a Running status " height="103" src="image/Figure_15.22_B18115.jpg" width="702"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.22 – Checking whether pods have a Running status</p>
<p><em class="italic">Great! We have just deployed and examined our sample application deployment on the Raspberry multi-node cluster running Ubuntu Core.</em></p>
<p>To<a id="_idIndexMarker1249"/> summarize, embedded Linux development utilizing snaps, Snapcraft, and Ubuntu Core is a lot quicker, safer, and more reliable than the current options available in the market. As it can package, distribute, and update any app through the global Snap Store, Snapcraft makes it simpler to find new software for your embedded devices. Additionally, the application updates either completely succeed or are not deployed at all. During both application and system updates, your embedded device running Ubuntu Core stays fully functional.</p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor256"/>Summary</h1>
<p>In this chapter, we learned how to install the MicroK8s snap with the strict confinement option, monitored the installation’s progress, and managed the Kubernetes cluster running on Ubuntu Core. We also deployed a sample application and examined whether the application is able to run on a strict confinement-enabled Kubernetes cluster.</p>
<p>We also introduced a new embedded OS, Ubuntu Core, which complies with enterprise standards by enabling automated updates, app stores, and software management. We also learned that it is built from the ground up to be the most secure platform for connected devices. Furthermore, Ubuntu Core provides a modular design based on snaps, bullet-proof application updates, a seamless developer experience via Snapcraft, and built-in security to handle the challenges of embedded Linux development.</p>
<p>In this and earlier chapters, we have covered most of the implementation aspects that are required for your IoT/Edge computing applications using MicroK8s in detail; this includes running your applications on a multi-node Raspberry Pi cluster, configuring load balancing mechanisms, installing/configuring different CNI plugins for network connectivity, configuring logging, monitoring, and alerting options for your cluster, and building/deploying machine learning models and serverless applications. </p>
<p>Additionally, we have looked at setting up storage replication for your stateful applications, implementing a service mesh for your cross-cutting concerns, setting up a high-availability cluster to withstand component failure and continue to serve workloads without interruption, configuring containers with workload isolation, and running secured containers with isolation from a host system. In the following chapter, we’ll look at how MicroK8s is uniquely positioned for accelerating IoT and Edge deployments and also key trends that are shaping up our new future.</p>
</div>
</div>
</body></html>