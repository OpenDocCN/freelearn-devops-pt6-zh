<html><head></head><body>
		<div id="_idContainer013">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Introducing the New Operating Model</h1>
			<p>Many think that Kubernetes won the container orchestration war because of its outstanding ability to manage containers. But Kubernetes is much more than that. In addition to handling container orchestration at scale, Kubernetes introduced a new IT operating model. There is always a trap with anything new. We tend to use a new tool the old way because of our tendencies. Understanding how Kubernetes disrupted IT operations is critical for not falling into these traps and achieving successful adoption. This chapter will dive deep into the significant aspects of the new operating model.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>The Kubernetes journey</li>
				<li>Characteristics of the new operating model</li>
				<li>The next Kubernetes use case</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>The Kubernetes journey</h1>
			<p>The Kubernetes<a id="_idIndexMarker000"/> journey to become the leading container orchestration platform has seen many fascinating moments. Kubernetes was an open source initiative by a few Google engineers based on an internal project called Borg. From day one, Kubernetes had the advantage of heavy production usage at Google and more than a decade of active development as Borg. Soon, it became more than a small set of Google engineers, with overwhelming community support. The container orchestration war was a tough fight between Docker, Mesosphere DC/OS, Kubernetes, Cloud Foundry, and <a id="_idIndexMarker001"/>AWS <strong class="bold">Elastic Container Service</strong> (<strong class="bold">ECS</strong>) from 2015. Kubernetes was outperforming its peers slowly and steadily.</p>
			<p>Initially, Docker, Mesosphere, and Cloud Foundry announced native support for Kubernetes. Finally, in 2017, AWS announced ECS for Kubernetes. Eventually, all the cloud providers came up with a managed Kubernetes offering. The rivals had no choice other than to provide native support for Kubernetes because of its efficacy and adoption. These were the winning moments for Kubernetes in the container orchestration war. Furthermore, it continued to grow to become the core of the cloud-native <a id="_idIndexMarker002"/>ecosystem, with many tools and patterns evolving around it. The following diagram illustrates the container orchestration war:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B17830_01_01.jpg" alt="Figure 1.1 – The container orchestration war&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The container orchestration war</p>
			<p>Next, let's learn about the characteristics of the new operating model.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Characteristics of the new operating model</h1>
			<p>Understanding<a id="_idIndexMarker003"/> how Kubernetes can positively impact IT operations will provide a solid base for the efficient adoption of DevOps in application and infrastructure automation. The following are some of the significant characteristics of the Kubernetes operating model:</p>
			<ul>
				<li>Team collaboration and workflows</li>
				<li>Control theory</li>
				<li>Interoperability</li>
				<li>Extensibility</li>
				<li>New architecture focus</li>
				<li>Open source, community, and governance</li>
			</ul>
			<p>Let's look at<a id="_idIndexMarker004"/> these characteristics in detail in the following sections.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Before we dive deep, it's critical to understand that you are expected to have a basic prior understanding of Kubernetes architecture and its building block resources, such as Pods, Deployments, Services, and namespaces. New to Kubernetes? Looking for a guide to understand the basic concepts? Please<a id="_idIndexMarker005"/> go through the documentation at <a href="https://kubernetes.io/docs/concepts/overview/">https://kubernetes.io/docs/concepts/overview/</a>.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Team collaboration and workflows</h2>
			<p>All Kubernetes <a id="_idIndexMarker006"/>resources, such as Pods, volumes, Services, Deployments, and Secrets are persistent entities stored in <strong class="source-inline">etcd</strong>. Kubernetes has well-modeled RESTful APIs to perform <strong class="source-inline">CRUD</strong> operations over these resources. The Create, Update, and Deletion operations to the <strong class="source-inline">etcd</strong> persistence store is a state change request. The state change is realized asynchronously with the Kubernetes control plane. There are a couple <a id="_idIndexMarker007"/>of characteristics of these Kubernetes APIs that are very useful for efficient team collaboration and workflows:</p>
			<ul>
				<li>Declarative configuration management</li>
				<li>Multi-persona collaboration</li>
			</ul>
			<h3>Declarative configuration management</h3>
			<p>We express our <a id="_idIndexMarker008"/>automation intent to the Kubernetes API as data points, known as the <strong class="bold">record of intent</strong>. The<a id="_idIndexMarker009"/> record does not carry any information about the steps to achieve the intention. This model enables a pure declarative configuration to automate workloads. It is easier to manage automation configuration as data points in <strong class="source-inline">Git</strong> than code. Also, expressing the automation intension as data is less prone to bugs, and easy to read and maintain. Provided we have a clear Git history, a simple intent expression, and release management, collaboration over the configuration is easy. The following is a simple record of intent for an <strong class="source-inline">NGINX</strong> Pod deployment:</p>
			<pre class="source-code">apiVersion: v1_</pre>
			<pre class="source-code">kind: Pod</pre>
			<pre class="source-code">metadata:</pre>
			<pre class="source-code">  name: proxy</pre>
			<pre class="source-code">spec:</pre>
			<pre class="source-code">  containers:</pre>
			<pre class="source-code">    - name: proxy-image</pre>
			<pre class="source-code">      image: Nginx</pre>
			<pre class="source-code">      ports:</pre>
			<pre class="source-code">        - name: proxy-port</pre>
			<pre class="source-code">          containerPort: 80</pre>
			<pre class="source-code">          protocol: TCP</pre>
			<p>Even though <a id="_idIndexMarker010"/>many new-age automation tools are primarily declarative, they are weak in collaboration because of missing well-modeled RESTful APIs. The following multi-persona collaboration section will discuss this aspect more. The combination of declarative configuration and multi-persona collaboration makes Kubernetes a unique proposition.</p>
			<h3>Multi-persona collaboration</h3>
			<p>With <a id="_idIndexMarker011"/>Kubernetes or other automation tools, we abstract the data center fully into a single window. Kubernetes has a separate API mapping to each infrastructure concern, unlike other automation tools. Kubernetes groups these concerns under the construct called API groups, of which <a id="_idIndexMarker012"/>there are around 20. API groups break the monolith infrastructure resources into minor responsibilities, providing segregation for different personas to operate an infrastructure based on responsibility. To simplify, we can logically divide the APIs into five sections:</p>
			<ul>
				<li><strong class="bold">Workloads</strong> are <a id="_idIndexMarker013"/>objects that can help us to manage and run containers in the Kubernetes cluster. Resources such as Pods, Deployments, Jobs, and StatefulSets belong to the <strong class="source-inline">workload</strong> category. These resources mainly come under the <strong class="source-inline">apps</strong> and <strong class="source-inline">core</strong> API groups.</li>
				<li><strong class="bold">Discovery and load balancers</strong> is a<a id="_idIndexMarker014"/> set of resources that helps us stitch workloads with load balancers. People responsible for traffic management can have access to these sets of APIs. Resources such as Services, NetworkPolicy, and Ingress appear under this category. They fall under the <strong class="source-inline">core</strong> and <strong class="source-inline">networking.k8s.io</strong> API groups.</li>
				<li><strong class="bold">Config and storage</strong> are <a id="_idIndexMarker015"/>resources helpful to manage initialization and dependencies for our workloads, such as ConfigMaps, Secrets, and volumes. They fall under the <strong class="source-inline">core</strong> and <strong class="source-inline">storage.k8s.io API</strong> groups. The application operators can have access to these APIs.</li>
				<li><strong class="bold">Cluster resources</strong> help <a id="_idIndexMarker016"/>us to manage the Kubernetes cluster configuration itself. Resources such as Nodes, Roles, <strong class="source-inline">RoleBinding</strong>, <strong class="source-inline">CertificateSigningCertificate</strong>, <strong class="source-inline">ServiceAccount</strong>, and namespaces fall under this category, and cluster operators should access these APIs. These resources come under many API groups, such as  <strong class="source-inline">core</strong>, <strong class="source-inline">rbac</strong>, <strong class="source-inline">rbac.authorization.k8s.io</strong>, and <strong class="source-inline">certificates.k8s.io</strong>.</li>
				<li><strong class="bold">Metadata</strong> resources<a id="_idIndexMarker017"/> are helpful to specify the behavior of a workload and other resources within the cluster. A HorizontalPodAutoScaler is a typical example of metadata resources defining workload behavior under different load conditions. These resources can fall under the <strong class="source-inline">core</strong>, <strong class="source-inline">autoscaling</strong>, and <strong class="source-inline">policy</strong> API groups. People responsible for application policies or automating architecture characteristics can access these APIs.</li>
			</ul>
			<p>Note that the <a id="_idIndexMarker018"/>core API group holds resources from all the preceding categories. Explore all the Kubernetes resources yourself with the help of the <strong class="source-inline">kubectl</strong> comments. A few comment examples are as follows:</p>
			<pre class="source-code"># List all resources </pre>
			<pre class="source-code">kubectl api-resources</pre>
			<pre class="source-code"># List resources in the "apps" API group </pre>
			<pre class="source-code">kubectl api-resources --api-group=apps</pre>
			<pre class="source-code"># List resources in the "networking.k8s.io" API group</pre>
			<pre class="source-code">kubectl api-resources --api-group=networking.k8s.io</pre>
			<p>The <a id="_idIndexMarker019"/>following screenshots give you a quick glimpse of resources under the <strong class="source-inline">apps</strong> and <strong class="source-inline">networking.k8s.io</strong> API groups, but I would highly recommend playing around to look at all resources and their API groups:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17830_01_02.jpg" alt="Figure 1.2 – Resources under the apps API group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Resources under the apps API group</p>
			<p>The following are the resources under the <strong class="source-inline">network.k8s.io</strong> API group:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B17830_01_03.jpg" alt="Figure 1.3 – Resources under the network.k8s.io API group&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Resources under the network.k8s.io API group</p>
			<p>We can assign RBAC for teams based on individual resources or API groups. The following diagram represents the developers, application operators, and cluster operators collaborating over different concerns:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B17830_01_04.jpg" alt="Figure 1.4 – Team collaboration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Team collaboration</p>
			<p>This representation <a id="_idIndexMarker020"/>may vary for you, based on an organization's structure, roles, and responsibilities. Traditional automation tools are template-based, and it's difficult for teams to collaborate. It leads to situations where policies are determined and implemented by two different teams. Kubernetes changed this operating model by enabling different personas to collaborate directly by bringing down the friction in collaboration.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Control theory</h2>
			<p>Control theory<a id="_idIndexMarker021"/> is a concept from engineering and mathematics, where we maintain the desired state in a dynamic system. The<a id="_idIndexMarker022"/> state of a dynamic system changes over time with the environmental changes. Control theory executes a continuous feedback loop to observe the output state, calculate the divergence, and then control input to maintain the system's desired state. Many engineering systems around us work using control theory. An air conditioning system with a continuous feedback loop to maintain temperature is a typical example. The following illustration provides a simplistic view of<a id="_idIndexMarker023"/> control theory flow:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B17830_01_05.jpg" alt="Figure 1.5 – Control theory flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Control theory flow</p>
			<p>Kubernetes <a id="_idIndexMarker024"/>has a state-of-the-art implementation of control theory. We submit our intention of the application's desired state to the API. The rest of the automation flow is handled by Kubernetes, marking an end to the human workflow once the API is submitted. Kubernetes controllers run a continuous reconciliation loop asynchronously to ensure that the desired state is maintained across all Kubernetes resources, such as Pods, Nodes, Services, Deployments, and Jobs. The controllers<a id="_idIndexMarker025"/> are the central brain of Kubernetes, with a collection of controllers responsible for managing different Kubernetes resources. Observe, analyze, and react are the three main functions of an individual controller:</p>
			<ul>
				<li><strong class="bold">Observe</strong>: Events <a id="_idIndexMarker026"/>relevant to the controller's resources are received by the observer. For example, a deployment controller will receive all the deployment resource's <strong class="source-inline">create</strong>, <strong class="source-inline">delete</strong>, and <strong class="source-inline">update</strong> events.</li>
				<li><strong class="bold">Analyze</strong>: Once<a id="_idIndexMarker027"/> the observer receives the event, the analyzer jumps in to compare the current and desired state to find the delta.</li>
				<li><strong class="bold">React</strong>: Performs <a id="_idIndexMarker028"/>the needed action to bring the resources back into the desired state.</li>
			</ul>
			<p>The control theory implementation in Kubernetes changed the way IT performs in day one and day two <a id="_idIndexMarker029"/>operations. Once we express our intention as data points, the human workflow is over. The machine takes over the operations in asynchronous mode. Drift management is no longer part of the human workflow. In addition to the existing controllers, we can extend Kubernetes with new controllers. We can easily encode any operational knowledge required to manage our workload into a custom controller (operators) and hand <a id="_idIndexMarker030"/>over the custom day two operations to machines:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B17830_01_06.jpg" alt="Figure 1.6 – The Kubernetes controller flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – The Kubernetes controller flow</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Interoperability</h2>
			<p>The Kubernetes API <a id="_idIndexMarker031"/>is more than just an interface<a id="_idIndexMarker032"/> for our interaction with the cluster. It is the glue holding all the pieces together. <strong class="source-inline">kubectl</strong>, the schedulers, <strong class="source-inline">kubelet</strong>, and the controllers create and maintain resources with the help of <strong class="source-inline">kube-apiserver</strong>. <strong class="source-inline">kube-apiserver</strong> is the only component that talks to the <strong class="source-inline">etcd</strong> state store. <strong class="source-inline">kube-apiserver</strong> implements a well-defined API interface, providing state observability from any Kubernetes component and outside the cluster. This architecture of <strong class="source-inline">kube-apiserver</strong> makes it interoperable with the ecosystem. Other infrastructure automation tools such as Terraform, Ansible, and Puppet do not have a well-defined API to observe the state. </p>
			<p>Take observability as an example. Many observability tools evolved around Kubernetes because of the interoperable characteristic of <strong class="source-inline">kube-apiserver</strong>. For contemporary digital organizations, continuous observability of state and a feedback loop based on it is critical. End-to-end visibility in the infrastructure and applications from the perspective of different stakeholders provides a way to realize operational excellence. Another example of interoperability is using various configuration management tools, such as<a id="_idIndexMarker033"/> Helm as an alternative to <strong class="source-inline">kubectl</strong>. As the <em class="italic">record of intent</em> is pure YAML or JSON data points, we can easily interchange one tool with another. The following diagram provides a view of <strong class="source-inline">kube-apiserver</strong> interactions with other Kubernetes components:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B17830_01_07.jpg" alt="Figure 1.7 – Kubernetes API interactions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Kubernetes API interactions</p>
			<p>Interoperability means <a id="_idIndexMarker034"/>many things to IT operations. Some of the<a id="_idIndexMarker035"/> benefits are as follows:</p>
			<ul>
				<li>Easy co-existence with the organization ecosystem.</li>
				<li>Kubernetes itself will evolve and be around for longer.</li>
				<li>Leveraging an existing skill set by choosing known ecosystem tools. For example, we can use Terraform for Kubernetes configuration management to take advantage <a id="_idIndexMarker036"/>of a team's knowledge in Terraform.</li>
				<li>Hypothetically keeping the option open for migrating away from Kubernetes in the future. (Kubernetes APIs are highly modular, and we can interchange the underlying<a id="_idIndexMarker037"/> components easily. Also, a pure declarative config is easy to migrate away from Kubernetes if required.)</li>
			</ul>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Extensibility</h2>
			<p>Kubernetes' ability<a id="_idIndexMarker038"/> to add new functionalities is remarkable. We can look at the extensibility<a id="_idIndexMarker039"/> in three different ways:</p>
			<ul>
				<li>Augmenting Kubernetes core components</li>
				<li>Interchangeability of components</li>
				<li>Adding new resource types</li>
			</ul>
			<h3>Augmented Kubernetes core components</h3>
			<p>This <a id="_idIndexMarker040"/>extending model will either add additional functionality to the core components or alter core component functionality. We will look at a few examples of these extensions:</p>
			<ul>
				<li><strong class="bold">kubectl plugins</strong> are <a id="_idIndexMarker041"/>a way to attach sub-commands to the <strong class="source-inline">kubectl</strong> CLI. They are executables added to an operator's computer in a specific format without changing the <strong class="source-inline">kubectl</strong> source in any form. These extensions can combine a process that takes several steps into a single sub-command to increase productivity.</li>
				<li><strong class="bold">Custom schedulers</strong> are a<a id="_idIndexMarker042"/> concept that allows us to modify Kubernetes' resource scheduling behavior. We can even register multiple schedulers to run parallel to each other and configure them for different workloads. The default scheduler can cover most of the general use cases. Custom schedulers are needed if we have a workload with a unique scheduling behavior not available in the default scheduler.</li>
				<li><strong class="bold">Infrastructure plugins</strong> are <a id="_idIndexMarker043"/>concepts that help to extend underlying hardware. The device, storage, and network are the three different infrastructure plugins. Let's say a device supports GPU processing – we require a mechanism to advertise the GPU usage details to schedule workload based on GPU. </li>
			</ul>
			<h3>Interchangeability of components</h3>
			<p>The<a id="_idIndexMarker044"/> interoperability characteristics of Kubernetes provide the ability to interchange one core component with another. These types of extensions bring new capabilities to Kubernetes. For example, let's pick up the virtual <strong class="source-inline">kubelet</strong> project (<a href="https://github.com/virtual-kubelet/virtual-kubelet">https://github.com/virtual-kubelet/virtual-kubelet</a>). <strong class="source-inline">Kubelet</strong> is the interface between the Kubernetes control plane and the virtual machine nodes where the workloads are scheduled. <strong class="source-inline">Virtual kubelet</strong> mimics a node in the Kubernetes cluster to enable resource management with infrastructure other than a virtual machine node such as Azure Container Instances or AWS Fargate. Replacing the Docker runtime with another container runtime environment such as Rocket is another example of interchangeability.</p>
			<h3>Adding new resource types</h3>
			<p>We can <a id="_idIndexMarker045"/>expand the scope of the Kubernetes API and controller to create a new custom resource, also known as <strong class="bold">CustomResourceDefinition</strong> (<strong class="bold">CRD</strong>). It is<a id="_idIndexMarker046"/> one of the powerful constructs used for extending Kubernetes to manage resources other than containers. Crossplane, a platform for cloud resource management, falls under this category, which we will dive deep into in the upcoming chapters. Another use case is to automate our custom IT day one and day two processes, also known as the operator pattern. For example, tasks such as deploying, upgrading, and responding to failure can be encoded into a new Kubernetes operator.</p>
			<p>People call <a id="_idIndexMarker047"/>Kubernetes a platform to build platforms because of its extensive extendibility. They generally support new use cases or make Kubernetes fit into a specific ecosystem. Kubernetes presents itself to IT operations as a universal abstraction by extending and supporting every complex deployment environment.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Architecture focus</h2>
			<p>One of the<a id="_idIndexMarker048"/> focuses of architecture work is to make the application deployment architecture robust to various conditions such as virtual machine failures, data center failures, and diverse traffic conditions. Also, resource utilization should be optimum without any wastage of cost in over-provisioned infrastructure. Kubernetes makes it simple and unifies how to achieve architecture characteristics such as reliability, scalability, availability, efficiency, and elasticity. It relieves architects from focusing on infrastructure. Architects can now focus on building the required characters into the application, as achieving them at the infrastructure level is not complex anymore. It is a significant shift in the way traditional IT operates. Designing for failure, observability, and chaos engineering practices are becoming more popular as areas for architects to concentrate onin the world of containers.</p>
			<p>Portability is another architecture characteristic Kubernetes provides to workloads. Container workloads are generally portable, but dependencies are not. We tend to introduce dependencies with other cloud components. Building portability into application dependencies is another architecture trend in recent times. It's visible with the 2021 InfoQ architecture trends (<a href="https://www.infoq.com/articles/architecture-trends-2021/">https://www.infoq.com/articles/architecture-trends-2021/</a>). In the <a id="_idIndexMarker049"/>trend chart, design for portability, Dapar, the Open Application Model, and design for sustainability are some of the trends relevant to workload portability. We are slowly moving in the direction of portable cloud providers. </p>
			<p>With the deployment of workloads into Kubernetes, our focus on architecture in the new IT organization has changed forever.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Open source, community, and governance</h2>
			<p>Kubernetes <a id="_idIndexMarker050"/>almost relieves people from working with machines. Investing in such a high-level abstraction requires caution, and we will see whether the change will be long-lasting. Any high-level abstraction becoming a meaningful and long-lasting change requires a few characteristics. Being<a id="_idIndexMarker051"/> backed by almost all major cloud providers, Kubernetes has those characteristics. The following are the characteristics that make Kubernetes widely accepted and adopted.</p>
			<h3>Project ownership</h3>
			<p>Project ownership<a id="_idIndexMarker052"/> is critical for an open source project to succeed and drive universal adoption. A widely accepted foundation should manage open source projects rather than being dominated by an individual company, and the working group driving the future direction should have representations from a wide range of companies. It will reflect the neutrality of the project, where every stakeholder can participate and benefit from the initiative. Kubernetes fits very well into this definition. Even though Kubernetes originated from a project by a few Google engineers, it soon became part of the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>). If we <a id="_idIndexMarker053"/>look at the governing board and members of the CNCF, we can see that there is representation from all top technology firms (<a href="https://www.cncf.io/people/governing-board/">https://www.cncf.io/people/governing-board/</a> &amp; <a href="https://www.cncf.io/about/members/">https://www.cncf.io/about/members/</a>). Kubernetes also has special interest groups and working groups and is also represented by many technology companies, including all cloud providers.</p>
			<h3>Contribution</h3>
			<p>Kubernetes is<a id="_idIndexMarker054"/> one of the high-velocity projects in GitHub, with more than 3,000 contributors. With a high velocity of commits from the community, Kubernetes looks sustainable. Also, there is a high volume of documentation, books, and tutorials available. Above all, we have too many ecosystem tools and platforms evolving around Kubernetes. It makes developing and deploying workloads on Kubernetes easier.</p>
			<h3>Open standards</h3>
			<p>As the <a id="_idIndexMarker055"/>scope of Kubernetes abstraction is not tiny, it did not attempt to solve all the problems by itself. Instead, it depended on a few open standards to integrate existing widely accepted tools. It also encouraged the ecosystem to develop new tools aligning to open standards. For example, Kubernetes can work with any container runtimes such as Docker and Rocker, which comply with the standard <strong class="bold">Container Runtime Interface</strong> (<strong class="bold">CRI</strong>). Similarly, any <a id="_idIndexMarker056"/>networking solution that complies with <a id="_idIndexMarker057"/>the <strong class="bold">Container Networking Interface</strong> (<strong class="bold">CNI</strong>) can be a networking solution for Kubernetes. </p>
			<p>Kubernetes' method<a id="_idIndexMarker058"/> of open source governance provides a few advantages to IT operations:</p>
			<ul>
				<li>Kubernetes is sustainable and organizations can invest confidently.</li>
				<li>Wider adoption will maintain a strong talent pool.</li>
				<li>Strong community support.</li>
			</ul>
			<p>The preceding section concludes the critical aspects of the new Kubernetes IT operating model. While we have looked at the benefits of every individual characteristic, we also have advantages when we combine them. For example, platforms such as Crossplane are evolving by taking advantage of the multiple aspects discussed previously.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>The next Kubernetes use case</h1>
			<p>In the last<a id="_idIndexMarker059"/> few years, many organizations have taken advantage of the disruptive application deployment operating model provided by Kubernetes. The pattern of segregating the intent expression with data points and then a control plane taking over the rest of the automation is known as <strong class="bold">Infrastructure as Data</strong> (<strong class="bold">IaD</strong>), a <a id="_idIndexMarker060"/>term coined by Kelsey Hightower. Many from the Kubernetes community believe that containers are only the first use case for this pattern, and many more will follow in the coming years. A new use case is evolving, with the launch of Crossplane in late 2018 seen as the next big use case for Kubernetes. Crossplane brings the goodness of the Kubernetes operating model to the world of cloud infrastructure provisioning and management. This trend will see people move away<a id="_idIndexMarker061"/> from traditional <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>), using tools such as Terraform and Ansible, to IaD with Crossplane and Kubernetes. This move addresses the current limitations with the IaC model and unifies the approach of automating applications and infrastructure. </p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Summary</h1>
			<p>Kubernetes offers many new aspects to the IT operating model, aligned with modern digital organization expectations. Understanding how Kubernetes disrupts the day one and day two IT operations is key to its successful adoption. This chapter covered the details of the new operating model provided by Kubernetes. In the next chapter, we will look at the limitations of IaC for cloud infrastructure management and introduce Kubernetes control plane-based infrastructure management as the new-age alternative. </p>
		</div>
	</body></html>