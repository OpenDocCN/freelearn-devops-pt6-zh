- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting Started with Istio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Istio
- en: In the previous chapter, we discussed monolithic architecture and its drawbacks.
    We discussed microservice architecture and how it provides modularity to large
    complex applications. Microservice architectures are scalable, easier to deploy,
    resilient, and fault-tolerant via isolation and modularization, leveraging cloud
    containers and Kubernetes. Containers are the default packaging format for cloud-native
    applications, and Kubernetes is the de facto platform for container life cycle
    management and deployment orchestration. The ability of microservices to be distributed,
    highly scalable, and work in parallel with other microservices amplifies the communication
    challenges between microservices, and also operational challenges such as visibility
    in the communication and execution of microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了单体架构及其缺点。我们还讨论了微服务架构及其如何为大型复杂应用程序提供模块化。微服务架构具有可扩展性、易于部署、具备弹性，并通过隔离和模块化实现故障容忍，利用云容器和
    Kubernetes。容器是云原生应用程序的默认打包格式，而 Kubernetes 是容器生命周期管理和部署编排的事实标准平台。微服务能够分布式、高度可扩展，并与其他微服务并行工作，这加强了微服务之间的通信挑战，也带来了操作上的挑战，例如在微服务的通信和执行中的可见性问题。
- en: Microservices need to have secure communication with each other to avoid exploitation
    and attacks such as man-in-the-middle attacks. To solve such challenges in a cost-efficient
    and performant manner, there is a need for an application networking infrastructure,
    also called a Service Mesh. Istio is one such implementation of the Service Mesh
    that has been developed and supported by some great organizations, including Google,
    Red Hat, VMware, IBM, Lyft, Yahoo, and AT&T.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要彼此之间有安全的通信，以避免中间人攻击等利用和攻击。为了解决这些挑战并以成本高效和性能优越的方式进行处理，需求一个应用网络基础设施，通常称为服务网格。Istio
    就是这样一种服务网格实现，它由一些伟大的组织开发并支持，包括 Google、Red Hat、VMware、IBM、Lyft、Yahoo 和 AT&T。
- en: In this chapter, we will install and run Istio, and while doing that, we will
    go through its architecture and its various components as well. This chapter will
    help you understand the difference between Istio and other Service Mesh implementations.
    By the end, you should be able to configure and set up your environment and then
    install Istio, after getting a good understanding of how installation works. Once
    installed, you will then enable Istio sidecar injection to a sample application
    that comes along with Istio installation. We will take a step-by-step look at
    pre- and post-enablement of Istio for a sample application and get an idea of
    how Istio works.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装并运行 Istio，同时我们也将深入了解其架构和各个组件。本章将帮助你理解 Istio 与其他服务网格实现之间的区别。到章节末尾，你应该能够配置和设置你的环境，并在深入理解安装过程后成功安装
    Istio。安装完成后，你将启用 Istio sidecar 注入到一个与 Istio 安装一同提供的示例应用程序中。我们将一步一步地查看启用和禁用 Istio
    对示例应用程序的影响，并了解 Istio 是如何工作的。
- en: 'We will be doing this by exploring the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下主题进行探索：
- en: Why is Istio the most popular Service Mesh?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 Istio 是最流行的服务网格？
- en: Preparation of your workstation environment to install and run Istio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备工作站环境以安装和运行 Istio
- en: Installing Istio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Istio
- en: Installing observability tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装可观察性工具
- en: An introduction to Istio architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio 架构介绍
- en: Why is Istio the most popular Service Mesh?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 Istio 是最流行的服务网格？
- en: Istio stands for the Greek word *ιστίο*, pronounced as *Iss-tee-oh*. Istio means
    *sail*, which is a non-bending, non-compressing structure made of fabric or similar.
    It propels sailing ships via the lift and drag produced by the wind. What made
    the initial contributors select Istio as the name probably has something to do
    with the naming of Kubernetes, which also has a Greek origin, pronounced as *koo-burr-net-eez*
    and written as *κυβερνήτης*. Kubernetes means *helmsman* – that is, the person
    standing at the helm of a ship and steering it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 源自希腊词 *ιστίο*，发音为 *Iss-tee-oh*。Istio 意为 *帆*，它是一种不弯曲、不压缩的结构，通常由织物或类似材料制成。帆通过风产生的升力和阻力推动帆船前进。最初的贡献者选择
    Istio 作为名字，可能与 Kubernetes 的命名有关，Kubernetes 同样来源于希腊语，发音为 *koo-burr-net-eez*，写作
    *κυβερνήτης*，意思是 *舵手*——即站在船舵前并操控船只的人。
- en: Istio is an open source services mesh distributed under Apache License 2.0\.
    It is platform-independent, meaning it is independent of underlying Kubernetes
    providers. It also supports not only Kubernetes but also non-Kubernetes environments
    such as virtual machines. Having said that, Istio development is much more mature
    for the Kubernetes environment and is adapting and evolving very quickly for other
    environments. Istio has a very mature development community, a strong user base,
    and is highly extensible and configurable, providing solid operational control
    of traffic and security within a Service Mesh. Istio also provides behavioral
    insights using advanced and fine-grained metrics. It supports WebAssembly, which
    is very useful for extensibility and tailoring for specific requirements. Istio
    also offers support and easy configuration for multi-cluster and multi-network
    environments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 是一个开源的服务网格，采用 Apache License 2.0 进行分发。它是平台独立的，这意味着它不依赖于底层的 Kubernetes
    提供商。它不仅支持 Kubernetes，还支持非 Kubernetes 环境，如虚拟机。话虽如此，Istio 在 Kubernetes 环境中的开发更为成熟，并且正在迅速适应和发展以支持其他环境。Istio
    拥有一个非常成熟的开发社区、强大的用户基础，并且具有高度的可扩展性和可配置性，提供了对服务网格中的流量和安全的可靠操作控制。Istio 还通过先进和精细化的指标提供行为洞察。它支持
    WebAssembly，这对于可扩展性和针对特定需求的定制非常有用。Istio 还为多集群和多网络环境提供支持和简易配置。
- en: Exploring alternatives to Istio
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Istio 的替代方案
- en: There are various other alternatives to Istio, all with their own pros and cons.
    Here, we will list a few of the other Service Mesh implementations available.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 还有许多其他替代方案，每种方案都有其优缺点。在这里，我们将列出一些可用的其他服务网格实现。
- en: Kuma
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kuma
- en: At the time of writing (2022), **Kuma** is a **Cloud Native Computing Foundation**
    (**CNCF**) sandbox project and was originally created by Kong Inc., the company
    that also provides the Kong API management gateway both in open source and commercial
    variants. Kuma is advertised by Kong Inc. as a modern distributed control plane
    with bundled Envoy proxy integration. It supports multi-cloud and multi-zone connectivity
    for highly distributed applications. The Kuma data plane is composed of Envoy
    proxies, which are then managed by Kuma control planes, and it supports workloads
    deployed on not only Kubernetes but also virtual machines and bare-metal environments.
    Kong Inc also provides an enterprise Service Mesh offering called Kong Mesh, which
    extends CNCF’s Kuma and Envoy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时（2022年），**Kuma** 是 **Cloud Native Computing Foundation** (**CNCF**) 的沙盒项目，最初由
    Kong Inc. 创建，Kong Inc. 还提供 Kong API 管理网关的开源和商业版本。Kuma 被 Kong Inc. 宣传为一个现代化的分布式控制平面，内置了
    Envoy 代理集成。它支持多云和多区域连接，以适应高度分布式的应用程序。Kuma 数据平面由 Envoy 代理组成，然后由 Kuma 控制平面进行管理，支持不仅部署在
    Kubernetes 上的工作负载，还支持虚拟机和裸金属环境中的工作负载。Kong Inc. 还提供了一种企业级服务网格产品，名为 Kong Mesh，它扩展了
    CNCF 的 Kuma 和 Envoy。
- en: Linkerd
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linkerd
- en: '**Linkerd** was originally created by Buoyant, Inc. but was later made open
    source, and it is now licensed under Apache V2\. Buoyant, Inc. also provides a
    managed cloud offering of Linkerd, as well as an enterprise support offering for
    customers who want to run Linkerd themselves but need enterprise support. Linkerd
    makes running services easier and safer by providing runtime debugging, observability,
    reliability, and security. Like Istio, you don’t need to change your application
    source code; instead, you install a set of ultralight transparent Linkerd2-proxy
    next to every service.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linkerd** 最初由 Buoyant, Inc. 创建，后来被开源，现在采用 Apache V2 许可证。Buoyant, Inc. 还提供
    Linkerd 的托管云服务，并为那些希望自行运行 Linkerd 但需要企业级支持的客户提供企业支持服务。Linkerd 通过提供运行时调试、可观测性、可靠性和安全性，使服务的运行更加简单和安全。与
    Istio 类似，你无需更改应用程序源代码；相反，你只需在每个服务旁边安装一组超轻透明的 Linkerd2-proxy。'
- en: The Linkerd2-proxy is a micro-proxy written in Rust and deployed as a sidecar
    in the Pod along with the application. Linkerd proxies have been written specifically
    for Service Mesh use cases and are arguably faster than Envoy, which is used as
    a sidecar in Istio and many other Service Mesh implementations like Kuma. Envoy
    is a great proxy but designed for multiple use cases – for example, Istio uses
    Envoy as an Ingress and also Egress gateway, as well as a sidecar simultaneously
    to go along with applications. Many Linkerd implementations use Linkerd as a Service
    Mesh and Envoy-based Ingress controllers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd2-proxy 是一个用 Rust 编写的微代理，并作为 sidecar 与应用程序一起部署在 Pod 中。Linkerd 代理专门为 Service
    Mesh 用例编写，并且被认为比 Envoy 更快，Envoy 被用作 Istio 和许多其他 Service Mesh 实现（如 Kuma）中的 sidecar。Envoy
    是一个非常出色的代理，但它是为多个用例设计的——例如，Istio 使用 Envoy 作为 Ingress 和 Egress 网关，同时也作为 sidecar
    与应用程序一起运行。许多 Linkerd 实现使用 Linkerd 作为 Service Mesh，并且 Envoy 基于的 Ingress 控制器。
- en: Consul
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Consul
- en: '**Consul** is a Service Mesh solution from Hashicorp; it is open source but
    also comes with a cloud and enterprise support offering from Hashicorp. Consul
    can be deployed on Kubernetes as well as VM-based environments. On top of the
    Service Mesh, Consul also provides all functionality for service catalogs, TLS
    certificates, and service-to-service authorizations. The data plane of Consul
    provides two options; the user can either choose an Envoy-based sidecar model
    similar to Istio, or native integration via Consul Connect SDKs, which takes away
    the need to inject a sidecar and provides better performance than Envoy proxies.
    Another difference is that you need to run a consul agent as a daemon on every
    worker node in the Kubernetes cluster and every node in non-Kubernetes environments.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Consul** 是 Hashicorp 提供的 Service Mesh 解决方案；它是开源的，但也有来自 Hashicorp 的云和企业支持服务。Consul
    可以部署在 Kubernetes 以及基于虚拟机的环境中。在 Service Mesh 之上，Consul 还提供了服务目录、TLS 证书和服务间授权的所有功能。Consul
    的数据平面提供两种选择；用户可以选择类似于 Istio 的基于 Envoy 的 sidecar 模式，或者通过 Consul Connect SDK 的原生集成，这种方式无需注入
    sidecar，且提供比 Envoy 代理更好的性能。另一个区别是，你需要在每个 Kubernetes 集群中的工作节点和非 Kubernetes 环境中的每个节点上运行一个
    Consul agent 作为守护进程。'
- en: AWS App Mesh
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS App Mesh
- en: '**App Mesh** is a Service Mesh offering from AWS and, of course, is available
    for workloads deployed in AWS on **Elastic Container Service** (**ECS**), Elastic
    Container Service for Kubernetes, or self-managed Kubernetes clusters running
    in AWS. Like Istio, App Mesh also uses Envoy as a sidecar proxy in the Pod, while
    the control plane is provided as a managed service by AWS, similar to EKS. App
    Mesh provides integration with various other AWS services such as Amazon Cloudwatch
    and AWS X-Ray.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**App Mesh** 是 AWS 提供的 Service Mesh 解决方案，当然，它可以用于 AWS 上部署的工作负载，包括 **Elastic
    Container Service** (**ECS**)、Kubernetes 的 Elastic Container Service 或在 AWS 中运行的自管
    Kubernetes 集群。像 Istio 一样，App Mesh 也在 Pod 中使用 Envoy 作为 sidecar 代理，同时控制平面由 AWS 提供为托管服务，类似于
    EKS。App Mesh 提供与其他 AWS 服务的集成，如 Amazon Cloudwatch 和 AWS X-Ray。'
- en: OpenShift Service Mesh
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenShift Service Mesh
- en: '**Red Hat OpenShift Service Mesh** is based on Istio; in fact, Red Hat is also
    a contributor to Istio open source projects. The offering is bundled with Jaeger
    for distributed tracing and Kiali for visualizing the mesh, viewing configuration,
    and traffic monitoring. As with other products from Red Hat, you can buy enterprise
    support for OpenShift Service Mesh.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Red Hat OpenShift Service Mesh** 基于 Istio；事实上，Red Hat 也是 Istio 开源项目的贡献者。该产品捆绑了
    Jaeger 用于分布式追踪，以及 Kiali 用于可视化网格、查看配置和流量监控。与 Red Hat 的其他产品一样，你可以为 OpenShift Service
    Mesh 购买企业支持。'
- en: F5 NGINX Service Mesh
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F5 NGINX Service Mesh
- en: NGINX is part of F5, and hence, its Service Mesh offering is called **F5 NGINX
    Service Mesh**. It uses NGINX Ingress controller with NGINX App Protect to secure
    the traffic at the edge and then route to the mesh using Ingress controllers.
    NGINX Plus is used as a sidecar to the application, providing seamless and transparent
    load balancing, reverse proxy, traffic routing, and encryption. Metrics collection
    and analysis are performed using OpenTracing and Prometheus, while inbuilt Grafana
    dashboards are provided for the visualization of Prometheus metrics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 是 F5 的一部分，因此其 Service Mesh 解决方案称为 **F5 NGINX Service Mesh**。它使用 NGINX
    Ingress 控制器与 NGINX App Protect 一起在边缘加密流量，然后通过 Ingress 控制器将流量路由到网格。NGINX Plus 作为应用程序的
    sidecar 提供无缝透明的负载均衡、反向代理、流量路由和加密。使用 OpenTracing 和 Prometheus 进行指标收集和分析，同时提供内建的
    Grafana 仪表板来可视化 Prometheus 指标。
- en: This briefly covers Service Mesh implementation, and we will cover some of them
    in greater depth in *Appendix A*. For now, let’s return our focus to Istio. We
    will read more about the benefits of Istio in the upcoming sections and the rest
    of the book, but let’s first get things going by installing Istio and enabling
    it for an application that is packaged along with Istio.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分简要介绍了服务网格的实现，接下来我们将在 *附录 A* 中更详细地讨论其中的一些内容。目前，让我们重新聚焦到 Istio 上。接下来的章节以及全书将详细介绍
    Istio 的好处，但首先让我们通过安装 Istio 并启用一个与 Istio 一起打包的应用来开始。
- en: Preparing your workstation for Istio installation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Istio 安装做好准备
- en: We will be using minikube for installing and playing with Istio in the first
    few chapters. In later chapters, we will install Istio on AWS EKS to mimic real-life
    scenarios. First, let’s prepare your laptop/desktop with minikube. If you already
    have minikube installed in your environment, it is strongly recommended to upgrade
    to the latest version.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前几章中使用 minikube 来安装和使用 Istio。在后续章节中，我们将把 Istio 安装到 AWS EKS 上，以模拟现实场景。首先，让我们准备好你的笔记本电脑/台式机与
    minikube。如果你的环境中已经安装了 minikube，强烈建议升级到最新版本。
- en: If you don’t have minikube installed, then follow the instructions to install
    minikube. minikube is a local Kubernetes installed on your workstation that makes
    it easy for you to learn and play with Kubernetes and Istio, without needing a
    contingent of computers to install a Kubernetes cluster.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 minikube，请按照说明进行安装。minikube 是安装在工作站上的本地 Kubernetes，可以让你轻松学习和使用 Kubernetes
    以及 Istio，而不需要一大堆计算机来安装 Kubernetes 集群。
- en: System specifications
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统规格
- en: You will need Linux or macOS or Windows. This book will primarily follow macOS
    as the target operating system. Where there is a big difference in commands between
    Linux and macOS, you will find corresponding steps/commands in the form of little
    notes. You will need at least two CPUs, 2 GB of available RAM, and either Docker
    Desktop (if macOS or Windows) or Docker Engine for Linux. If you don’t have Docker
    installed, then just follow the instructions at [https://docs.docker.com/](https://docs.docker.com/)
    to install Docker on your computer, based on the respective operating system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要 Linux 或 macOS 或 Windows。本书主要以 macOS 作为目标操作系统。如果 Linux 和 macOS 之间的命令有很大差异，你将会在小贴士中看到对应的步骤/命令。你至少需要两个
    CPU，2 GB 可用内存，以及 Docker Desktop（如果是 macOS 或 Windows）或 Linux 的 Docker Engine。如果你还没有安装
    Docker，请根据相应的操作系统，访问 [https://docs.docker.com/](https://docs.docker.com/) 安装 Docker。
- en: Installing minikube and the Kubernetes command-line tool
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 minikube 和 Kubernetes 命令行工具
- en: 'We will be using **Homebrew** to install minikube. However, if you don’t have
    Homebrew installed, you can install Homebrew using the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Homebrew** 安装 minikube。然而，如果你没有安装 Homebrew，可以使用以下命令来安装 Homebrew：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s get started:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧：
- en: 'Install minikube using `brew` `install minikube`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `brew` `install minikube` 安装 minikube：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once installed, create a symlink to the newly installed binary in the Homebrew
    `Cellar` folder:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，在 Homebrew 的 `Cellar` 文件夹中创建一个指向新安装的二进制文件的符号链接：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To test the installation, use the following command to find the minikube version:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试安装情况，请使用以下命令查看 minikube 版本：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Attention, Linux users!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Linux 用户！
- en: 'If you are installing on Linux, you can use the following commands to install
    minikube:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Linux 上安装，可以使用以下命令安装 minikube：
- en: '`$ curl -``LO` [https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64](https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl -``LO` [https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64](https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64)'
- en: '`$ sudo install` `minikube-linux-amd64 /usr/local/bin/minikube`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo install` `minikube-linux-amd64 /usr/local/bin/minikube`。'
- en: The next step is to install kubectl if you do not have it already installed
    on your machine.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是安装 kubectl，如果你的机器上尚未安装它。
- en: '**kubectl** is a short form of the Kubernetes command-line tool and is pronounced
    as *kube-control*. kubectl allows you to run commands against Kubernetes clusters.
    You can install kubectl on Linux, Windows, or macOS. The following steps install
    kubectl on macOS using Brew:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl** 是 Kubernetes 命令行工具的简称，发音为 *kube-control*。kubectl 允许你对 Kubernetes
    集群运行命令。你可以在 Linux、Windows 或 macOS 上安装 kubectl。以下步骤将演示如何在 macOS 上通过 Brew 安装 kubectl：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use the following steps to install kubectl on Debian-based machines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下步骤在基于 Debian 的机器上安装 kubectl：
- en: '**sudo** **apt-get update**'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo** **apt-get update**'
- en: '**sudo apt-get install -y apt-transport-https** **ca-certificates curl**'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo apt-get install -y apt-transport-https** **ca-certificates curl**'
- en: '**sudo curl -****fsSLo /usr/share/keyrings/****kubernetes-archive-keyring.gpg
    https://packages.cloud.google.com/apt/doc/apt-key.gpg**'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo curl -****fsSLo /usr/share/keyrings/****kubernetes-archive-keyring.gpg
    https://packages.cloud.google.com/apt/doc/apt-key.gpg**'
- en: '**echo "****deb [signed-by=/usr/share/****keyrings/****kubernetes-archive-keyring.gpg]**
    **https://apt.kubernetes.io/ kubernetes-xenial main" | sudo** **tee /etc/apt/sources.list.d/kubernetes.list**'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**echo "****deb [signed-by=/usr/share/****keyrings/****kubernetes-archive-keyring.gpg]**
    **https://apt.kubernetes.io/ kubernetes-xenial main" | sudo** **tee /etc/apt/sources.list.d/kubernetes.list**'
- en: '**echo “deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg]
    https://apt.kubernetes.io/ kubernetes-xenial main” | sudo** **tee /etc/apt/sources.list.d/kubernetes.list**'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**echo “deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg]
    https://apt.kubernetes.io/ kubernetes-xenial main” | sudo** **tee /etc/apt/sources.list.d/kubernetes.list**'
- en: '**sudo** **apt-get update**'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo** **apt-get update**'
- en: '**sudo apt-get install -****y kubectl**'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo apt-get install -****y kubectl**'
- en: 'The following steps can be used to install kubectl on Red Hat machines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤可以用来在 Red Hat 机器上安装 kubectl：
- en: '**cat <<EOF | sudo** **tee /etc/yum.repos.d/kubernetes.repo**'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**cat <<EOF | sudo** **tee /etc/yum.repos.d/kubernetes.repo**'
- en: '**[****kubernetes]**'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**[****kubernetes]**'
- en: '**name=Kubernetes**'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**name=Kubernetes**'
- en: '**baseurl=https://packages.cloud.google.com** **/yum/repos/kubernetes-el7-x86_64**'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**baseurl=https://packages.cloud.google.com** **/yum/repos/kubernetes-el7-x86_64**'
- en: '**enabled=1**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**enabled=1**'
- en: '**gpgcheck=1**'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**gpgcheck=1**'
- en: '**repo_gpgcheck=1**'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**repo_gpgcheck=1**'
- en: '**gpgkey=https://packages.cloud.google.com/yum/doc/****yum-key.gpg****https://packages.cloud.google.com/yum/doc/****rpm-package-key.gpg**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**gpgkey=https://packages.cloud.google.com/yum/doc/****yum-key.gpg****https://packages.cloud.google.com/yum/doc/****rpm-package-key.gpg**'
- en: '**ckages.cloud.google.com/yum/doc/rpm-package-key.gpg**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ckages.cloud.google.com/yum/doc/rpm-package-key.gpg**'
- en: '**EOF**'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**EOF**'
- en: '**sudo yum install -****y kubectl**'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sudo yum install -****y kubectl**'
- en: You have now all that you need to run Kubernetes locally, so go ahead and type
    the following command. Make sure you are logged in as a user with administrative
    access.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了本地运行 Kubernetes 所需的一切，接下来输入以下命令。确保你以具有管理员权限的用户身份登录。
- en: 'You can use `minikube start` with the Kubernetes version as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `minikube start` 配合 Kubernetes 版本，方法如下：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see in the console output that minikube is using the HyperKit driver.
    `—driver=hyperkit`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在控制台输出中看到 minikube 正在使用 HyperKit 驱动程序。`—driver=hyperkit`。
- en: For Linux users
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 用户
- en: For Linux, you can use `minikube start --driver=docker`. In this case, minikube
    will run as a Docker container. For Windows, you can use `minikube start –driver=virtualbox`.
    To avoid typing `--driver` during every minikube start, you can configure the
    default driver by using `minikube config set driver DRIVERNAME`, where `DRIVERNAME`
    can be either Hyperkit, Docker, or VirtualBox.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux，你可以使用 `minikube start --driver=docker`。在这种情况下，minikube 将作为 Docker 容器运行。对于
    Windows，你可以使用 `minikube start –driver=virtualbox`。为了避免每次启动 minikube 时都输入 `--driver`，你可以通过使用
    `minikube config set driver DRIVERNAME` 来配置默认驱动程序，其中 `DRIVERNAME` 可以是 Hyperkit、Docker
    或 VirtualBox。
- en: 'You can verify that kubectl is working properly and that minikube has also
    started properly by using the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来验证 kubectl 是否正常工作，且 minikube 是否已正确启动：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the output, you can see that both the Kubernetes control plane and the DNS
    servers are running. This concludes the installation of minikube and `kubernetes-cli`.
    You now have a locally running Kubernetes cluster and a means to communicate with
    it via kubectl.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你可以看到 Kubernetes 控制平面和 DNS 服务器正在运行。这标志着 minikube 和 `kubernetes-cli` 的安装完成。你现在拥有一个本地运行的
    Kubernetes 集群，并且可以通过 kubectl 与其进行通信。
- en: Installing Istio
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Istio
- en: This section is the one you must have been eagerly waiting to read. The wait
    is over, and you are all set to install Istio. Just follow the instructions provided.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是你一直迫不及待想读的内容。等待已经结束，你已经准备好安装 Istio。只需按照提供的说明进行操作。
- en: 'The first step is to download Istio from [https://github.com/istio/istio/releases](https://github.com/istio/istio/releases).
    You can download using `curl` as well with the following command. It is a good
    idea to make a directory where you want to download the binaries and run the following
    command from within that directory. Let’s name that directory `ISTIO_DOWNLOAD`,
    from which we can run following commands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从 [https://github.com/istio/istio/releases](https://github.com/istio/istio/releases)
    下载 Istio。你也可以使用 `curl` 下载，方法如下。建议在一个你希望下载二进制文件的目录中运行以下命令。我们可以将该目录命名为 `ISTIO_DOWNLOAD`，然后在该目录中运行以下命令：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command downloads the latest version of Istio into the `ISTIO_DOWNLOAD`
    location. If we dissect this command, it has two parts:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将Istio的最新版本下载到`ISTIO_DOWNLOAD`位置。如果我们拆解这个命令，它有两部分：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first part of the command downloads a script from [https://raw.githubusercontent.com/istio/istio/master/release/downloadIstioCandidate.sh](https://raw.githubusercontent.com/istio/istio/master/release/downloadIstioCandidate.sh)
    (the location might change), and the second part of the script is then fed to
    `sh` for execution. The scripts analyze the processor architecture and operating
    system and, based on that, decide what are the appropriate values of the Istio
    version (`ISTIO_VERSION`), the operating system (`OSEXT`), and the processor architecture
    (`ISTIO_ARCH`). The script then populates these values into the following URL,
    [https://github.com/istio/istio/releases/download/${ISTIO_VERSION}/istio-${ISTIO_VERSION}-${OSEXT}-${ISTIO_ARCH}.tar.gz](https://github.com/istio/istio/releases/download/),
    and then downloads the `gz` file and decompresses it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的第一部分从[https://raw.githubusercontent.com/istio/istio/master/release/downloadIstioCandidate.sh](https://raw.githubusercontent.com/istio/istio/master/release/downloadIstioCandidate.sh)下载一个脚本（位置可能会变），然后第二部分的脚本被传递给`sh`执行。脚本分析处理器架构和操作系统，并根据这些信息决定适当的Istio版本（`ISTIO_VERSION`）、操作系统（`OSEXT`）和处理器架构（`ISTIO_ARCH`）。然后，脚本将这些值填充到以下URL中：[https://github.com/istio/istio/releases/download/${ISTIO_VERSION}/istio-${ISTIO_VERSION}-${OSEXT}-${ISTIO_ARCH}.tar.gz](https://github.com/istio/istio/releases/download/)，然后下载`gz`文件并解压。
- en: 'Let’s investigate what has been downloaded into the `ISTIO_DOWNLOAD` location:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一下下载到`ISTIO_DOWNLOAD`位置的内容：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is a brief description of the folders:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对文件夹的简要描述：
- en: '`bin` contains `istioctl`, also called `Istio-control`, which is the Istio
    command line to debug and diagnose Istio, as well as creating, listing, modifying,
    and deleting configuration resources.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`包含`istioctl`，也叫做`Istio-control`，它是Istio的命令行工具，用于调试和诊断Istio，还可以创建、列出、修改和删除配置资源。'
- en: '`samples` contains a sample application that we will be using for learning.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples`包含一个我们将用于学习的示例应用程序。'
- en: '`manifest` has Helm charts, which you don’t need to worry about for now. They
    have relevance when we want the installation process to pick up the charts from
    `manifest` rather than the default ones.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifest`包含Helm图表，现在你不需要担心这些。当我们希望安装过程从`manifest`中获取图表，而不是使用默认图表时，它们才会起作用。'
- en: 'Since we will be making use of `istioctl` to perform the installation, let’s
    add it to the executable path:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用`istioctl`来执行安装，所以让我们将其添加到可执行路径中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are one command away from installing Istio. Go ahead and type in the following
    command to complete the installation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们距离安装Istio只差一个命令了。继续输入以下命令以完成安装：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can pass `-y` to avoid the (Y/N) question. Just use `istioctl install --set`
    `profile=demo -y`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递`-y`来避免出现（Y/N）问题。只需使用`istioctl install --set` `profile=demo -y`。
- en: Viola! You have successfully completed the installation of Istio, including
    platform setup, in eight commands. If you have been using minikube and kubectl,
    then hopefully you should have been able to install in three commands. If you
    have installed this on an existing minikube setup, then it is advisable at this
    stage to install Istio on a new cluster, rather than an existing one with your
    other applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你已经通过八个命令成功完成了Istio的安装，包括平台设置。如果你已经在使用minikube和kubectl，那么希望你应该能在三个命令内完成安装。如果你是在现有的minikube设置上安装的，那么在这个阶段建议在一个新的集群上安装Istio，而不是在已有的集群中与其他应用一起安装。
- en: 'Let’s look at what has been installed. We’ll start first by analyzing the namespaces:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看已安装了什么。我们首先从分析命名空间开始：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that the installation has created a new namespace called `istio-system`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，安装过程中创建了一个名为`istio-system`的新命名空间。
- en: 'Let’s check what Pods and Services are in the `istio-system` namespace:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下`istio-system`命名空间中的Pods和Services：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While the preceding part of the output shows various Pods running under the
    `istio-system` namespace, the following will show Services in the `istio-system`
    namespace:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出部分显示了在`istio-system`命名空间下运行的各种Pods，接下来的部分将显示`istio-system`命名空间中的Services：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can check all resources by using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令查看所有资源：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `istio-system` namespace, Istio installs the `istiod` component, which
    is the control plane of Istio. There are various other custom configs such as
    Kubernetes Custom Resource Definitions, ConfigMaps, Admission Webhooks, Service
    Accounts, Role Bindings, as well as Secrets installed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`istio-system`命名空间中，Istio安装了`istiod`组件，这是Istio的控制平面。还有许多其他自定义配置，例如Kubernetes自定义资源定义、ConfigMaps、Admission
    Webhooks、服务帐户、角色绑定以及安装的Secrets。
- en: We will look into `istiod` and other control plane components in more detail
    in the next chapter. For now, let’s enable Istio for a sample application that
    is packaged with it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地了解`istiod`和其他控制平面组件。目前，让我们为带有Istio的示例应用启用Istio。
- en: Enabling Istio for a sample application
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为示例应用启用Istio
- en: To keep our work in a sample application segregated from other resources, we
    will first create a Kubernetes namespace called `bookinfons`. After creating the
    namespace, we will deploy the sample application in the `bookinfons` namespace.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的工作与其他资源隔离开来，我们将首先创建一个名为`bookinfons`的Kubernetes命名空间。创建命名空间后，我们将在`bookinfons`命名空间中部署示例应用。
- en: 'You need to run the second command from within the Istio installation directory
    – that is, `$ISTIO_DOWNLOAD/istio-1.13.1`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在Istio安装目录中运行第二个命令——即`$ISTIO_DOWNLOAD/istio-1.13.1`：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All the created resources are defined in `samples/bookinfo/platform/kube/bookinfo.yaml`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有创建的资源都定义在`samples/bookinfo/platform/kube/bookinfo.yaml`中。
- en: 'Check what Pods and Services have been created using the following commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令检查已创建的Pod和服务：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that there is one Pod each for `details`, `productpage`, and `ratings`,
    and three Pods for various versions of `review`. There is one service for each
    microservice. All of them are similar, except for the `kubectl review` service,
    which has three endpoints. Using the following command, let’s check how the `review`
    service definition is different from other Services:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个`details`、`productpage`和`ratings`都有一个Pod，而`review`有三个Pod版本。每个微服务都有一个服务。它们都很相似，除了`kubectl
    review`服务，它有三个端点。使用以下命令，让我们检查一下`review`服务的定义与其他服务的不同之处：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that the `bookinfo` application has successfully deployed, let’s access
    the product page of the `bookinfo` application using the following commands:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`bookinfo`应用已成功部署，让我们使用以下命令访问`bookinfo`应用的产品页面：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Go ahead and type in `http://localhost:9080/productpage` in your internet browser.
    If you don’t have one, you can do it via `curl`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请在你的浏览器中输入`http://localhost:9080/productpage`。如果你没有浏览器，你可以通过`curl`来访问：
- en: '![Figure 2.1 – The product page of the BookInfo app](img/B17989_02_01.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – BookInfo应用的产品页面](img/B17989_02_01.jpg)'
- en: Figure 2.1 – The product page of the BookInfo app
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – BookInfo应用的产品页面
- en: If you can see `productpage`, then you have successfully deployed the sample
    application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能看到`productpage`，那么你就成功部署了示例应用。
- en: What if I do not have a browser?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有浏览器怎么办？
- en: 'If you don’t have a browser, you can use this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有浏览器，你可以使用以下方法：
- en: '`curl -``sS localhost:9080/productpage`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl -``sS localhost:9080/productpage`'
- en: So, now that we have successfully deployed the sample application that comes
    along with Istio, let’s move on to enabling Istio for it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经成功部署了带有Istio的示例应用，让我们继续为其启用Istio。
- en: Sidecar injection
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侧车注入
- en: Sidecar injection is the means through which `istio-proxy` is injected into
    the Kubernetes Pod as a sidecar. Sidecars are additional containers that run alongside
    the main container in a Kubernetes Pod. By running alongside the main container,
    the sidecars can share the network interfaces with other containers in the Pod;
    this flexibility is leveraged by the `istio-proxy` container to mediate and control
    all communication to and from the main container. We will read more about sidecars
    in the *Chapter 3*. For now, we will keep the ball rolling by enabling Istio for
    the sample application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 侧车注入是将`istio-proxy`注入到Kubernetes Pod中的一种方式，作为侧车运行。侧车是与主容器一起在Kubernetes Pod中运行的附加容器。通过与主容器一起运行，侧车可以与Pod中其他容器共享网络接口；这种灵活性被`istio-proxy`容器用来调解和控制所有与主容器之间的通信。我们将在*第3章*中更详细地了解侧车。目前，我们将通过为示例应用启用Istio来继续进行。
- en: 'Let’s check out some interesting details before and after we enable Istio for
    this application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在启用Istio之前和之后检查一些有趣的细节：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s look at one of the Pods, `productpage`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下其中一个Pod，`productpage`：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Copy the output to a safe place. We will use this information to compare the
    findings once you have enabled Istio for the `bookinfo` application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出复制到安全的地方。我们将使用这些信息，在你为 `bookinfo` 应用启用 Istio 后进行对比。
- en: 'We will need to delete what we have deployed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要删除已部署的内容：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Wait for a few seconds and check that all the resources in the `bookinfons`
    namespace have been terminated. After that, enable `istio-injection` for `bookinfons`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟，检查 `bookinfons` 命名空间中的所有资源是否已终止。之后，启用 `bookinfons` 的 `istio-injection`：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Manual injection of sidecars
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 手动注入 sidecar
- en: 'The other option is to manually inject the sidecar by making use of `istioctl
    kube-inject` to augment the deployment descriptor file and then applying it using
    kubectl:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是手动注入 sidecar，通过使用 `istioctl kube-inject` 来增强部署描述符文件，然后使用 kubectl 应用它：
- en: '`$ istioctl kube-inject -f deployment.yaml -o deployment-injected.yaml | kubectl
    apply -``f –`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ istioctl kube-inject -f deployment.yaml -o deployment-injected.yaml | kubectl
    apply -f –`'
- en: 'Go ahead and deploy the `bookinfo` application:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 继续部署 `bookinfo` 应用程序：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s check what has been created:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下已经创建了什么：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see that the number of containers in Pods is now not one but instead
    two. Before we enabled `istio-injection`, the number of containers in Pods was
    one. We will discuss shortly what the additional container is. Let’s also check
    for any change in the number of Services:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Pods 中的容器数量现在不是一个，而是两个。在我们启用 `istio-injection` 之前，Pods 中的容器数量为一个。稍后我们将讨论额外的容器是什么。我们还将检查服务数量是否有所变化：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alright, so there is a change in Pod behavior but no noticeable change in service
    behavior. Let’s look deeper into one of the Pods:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Pod 行为发生了变化，但服务行为没有显著变化。让我们深入查看其中一个 Pod：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The complete output of this command can be found in `Output references/``Chapter
    2``/productpage pod.docx` on the GitHub repository of this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的完整输出可以在 `Output references/Chapter 2/productpage pod.docx` 中找到，位于本章的 GitHub
    仓库中。
- en: 'Note that the Pod description of the `productpage` Pod as well as every other
    Pod in the `bookinfons` have another container named `istio-proxy` and an init
    container named `istio-init`. They were absent when we initially created them
    but got added after we applied the `istio-injection=enabled` label, using the
    following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`productpage` Pod 及 `bookinfons` 中的每个 Pod 的描述中，都有一个名为 `istio-proxy` 的容器和一个名为
    `istio-init` 的初始化容器。它们在我们最初创建这些 Pod 时是不存在的，但在我们应用了 `istio-injection=enabled` 标签后添加了，使用的命令如下：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The sidecars can be injected either manually or automatically. Automatic is
    the easier way to inject sidecars. However, once we have familiarized ourselves
    with Istio, we will look at injecting sidecars manually by modifying application
    resource descriptor files in *Part 2* of the book. For now, let’s briefly look
    at how automatic sidecar injection works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Sidecar 可以手动或自动注入。自动注入是注入 sidecar 的更简单方式。然而，一旦我们熟悉了 Istio，我们将在本书的*第 2 部分*中讨论如何通过修改应用程序资源描述符文件手动注入
    sidecar。现在，让我们简单看一下自动 sidecar 注入是如何工作的。
- en: 'Istio makes use of Kubernetes **admission controllers**. Kubernetes admission
    controllers are responsible for intercepting a request to the Kubernetes API server.
    Interception happens post-authentication and authorization but pre-modification/creation/deletion
    of objects. You can find these admission controllers using the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 使用 Kubernetes **准入控制器**。Kubernetes 准入控制器负责拦截请求到 Kubernetes API 服务器。拦截发生在身份验证和授权之后，但在对象的修改/创建/删除之前。你可以使用以下命令找到这些准入控制器：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Istio makes use of mutating admission webhooks for automatic sidecar injection.
    Let’s find out what mutating admission webhooks are configured in our cluster:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 利用变更准入 webhook 实现自动 sidecar 注入。让我们来了解一下在我们的集群中配置了哪些变更准入 webhook：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following diagram describes the role of admission controllers during API
    calls to the Kubernetes API server. The mutating admission Webhook controllers
    are responsible for the injection of the sidecar.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了在 API 调用 Kubernetes API 服务器时准入控制器的作用。变更准入 Webhook 控制器负责 sidecar 的注入。
- en: '![Figure 2.2 – Admission controllers in Kubernetes](img/B17989_02_02.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Kubernetes 中的准入控制器](img/B17989_02_02.jpg)'
- en: Figure 2.2 – Admission controllers in Kubernetes
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Kubernetes 中的准入控制器
- en: We will cover sidecar injection in more detail in *Chapter 3*. For now, let’s
    switch our focus back to what has changed in Pod descriptors due to `istio-injection`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第 3 章*中更详细地讨论 sidecar 注入。现在，让我们将注意力转回到 `istio-injection` 导致的 Pod 描述符变化上。
- en: '`istio-iptables` was mentioned in the `istio-init` configuration of the product
    page Pod description using the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`istio-iptables` 在产品页面 Pod 描述文件的 `istio-init` 配置中提到，使用了以下命令：'
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is a snippet from the Pod descriptor:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Pod 描述文件中的一个片段：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`istio-iptables` is an initialization script responsible for setting up port
    forwarding via `iptables` for the Istio sidecar proxy. The following are various
    arguments that are passed during the execution of the script:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`istio-iptables` 是一个初始化脚本，负责通过 `iptables` 设置 Istio sidecar 代理的端口转发。以下是在执行脚本时传递的各种参数：'
- en: '**-p** specifies the Envoy port to which all TCP traffic will be redirected'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-p** 指定所有 TCP 流量将被重定向到的 Envoy 端口'
- en: '**-z** specifies the port to which all inbound traffic to the Pod should be
    redirected'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-z** 指定所有入站流量到 Pod 应该重定向到的端口'
- en: '**-u** is the UID of the user for which the redirection is not to be applied'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-u** 是不应用重定向的用户的 UID'
- en: '**-m** is the mode to be used for redirecting inbound connections'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-m** 是用于重定向入站连接的模式'
- en: '**-I** is a list of IP ranges in CIDR block destinations of outbound connections
    that need to be redirected to Envoy'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-I** 是需要重定向到 Envoy 的出站连接的 CIDR 块目标 IP 范围列表'
- en: '**-x** is a list of CIDR block destinations of outbound connections that need
    to be exempted from being redirected to Envoy'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-x** 是需要免除从重定向到 Envoy 的出站连接的 CIDR 块目标列表'
- en: '**-b** is a list of inbound ports for which traffic needs to be redirected
    to Envoy'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-b** 是需要重定向到 Envoy 的入站端口列表'
- en: '**-d** is a list of inbound ports that need to be excluded from being redirected
    to Envoy'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-d** 是需要从重定向到 Envoy 中排除的入站端口列表'
- en: 'To summarize the preceding argument in the `istio-init` container, the container
    is executing a script, `istio-iptables`, which is basically creating `iptables`
    rules at the Pod level – that is, applied to all containers within the Pod. The
    script configures an `iptables` rule that applies the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面在 `istio-init` 容器中的参数，容器正在执行一个脚本 `istio-iptables`，它基本上在 Pod 层面创建 `iptables`
    规则——也就是说，应用于 Pod 内的所有容器。该脚本配置了一个 `iptables` 规则，应用以下内容：
- en: All traffic should be redirected to port `15001`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有流量应该重定向到端口 `15001`
- en: Any traffic to the Pod should be redirected to port `15006`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何流量到 Pod 都应该重定向到端口 `15006`
- en: This rule doesn’t apply to UID `1337`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此规则不适用于 UID `1337`
- en: The mode for redirection to be used is REDIRECT
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向使用的模式是 REDIRECT
- en: All outbound connections to any destination (`*`) should be redirected to `15001`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有到任何目标 (`*`) 的出站连接应该重定向到 `15001`
- en: No outbound destination is exempt from this rule
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有出站目标可以免除此规则
- en: The redirection needs to happen for all inbound connections coming from any
    IP address, except when the destination ports are `15090`, `15021`, or `15020`
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向需要发生在来自任何 IP 地址的所有入站连接上，除非目标端口是 `15090`、`15021` 或 `15020`
- en: We will dig deeper into this in *Chapter 3*, but for now, remember that the
    init container basically sets up an `iptables` rule at the Pod level, which will
    redirect all traffic coming to the product page container at port `9080` to `15006`,
    while all traffic going out from product page container will be redirected to
    port `15001`. Both ports `15001` and `15006` are exposed by the `istio-proxy`
    container, which is created from `docker.io/istio/proxyv2:1.13.1`. The istio-proxy
    container runs alongside the product page container. Along with `15001` and `15006`,
    it also has ports `15090`, `15021`, and `15020`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第3章*中深入探讨，但现在记住，初始化容器基本上会在 Pod 层面设置一个 `iptables` 规则，该规则将所有到达产品页面容器端口 `9080`
    的流量重定向到 `15006`，而从产品页面容器发出的所有流量将被重定向到端口 `15001`。端口 `15001` 和 `15006` 都由 `istio-proxy`
    容器暴露，该容器来自 `docker.io/istio/proxyv2:1.13.1`。`istio-proxy` 容器与产品页面容器一起运行。除了 `15001`
    和 `15006`，它还暴露端口 `15090`、`15021` 和 `15020`。
- en: '`Istio-iptables.sh` can be found here: [https://github.com/istio/cni/blob/master/tools/packaging/common/istio-iptables.sh](https://github.com/istio/cni/blob/master/tools/packaging/common/istio-iptables.sh).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Istio-iptables.sh` 可以在这里找到：[https://github.com/istio/cni/blob/master/tools/packaging/common/istio-iptables.sh](https://github.com/istio/cni/blob/master/tools/packaging/common/istio-iptables.sh)。'
- en: 'You will also notice that both `istio-init` and `istio-proxy` are spun from
    the same Docker image, `docker.io/istio/proxyv2:1.13.1`. Inspect the Docker file
    here: [https://hub.docker.com/layers/proxyv2/istio/proxyv2/1.13.4/images/sha256-1245211d2fdc0f86cc374449e8be25166b9d06f1d0e4315deaaca4d81520215e?context=explore.](https://hub.docker.com/layers/proxyv2/istio/proxyv2/1.13.4/images/sha256-1245211d2fdc0f86cc374449e8be25166b9d06f1d0e4315deaaca4d81520215e?context=explore)
    The dockerfile gives more insight into how the image is constructed:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，`istio-init` 和 `istio-proxy` 都是从相同的 Docker 镜像 `docker.io/istio/proxyv2:1.13.1`
    中创建的。可以在这里查看 Docker 文件：[https://hub.docker.com/layers/proxyv2/istio/proxyv2/1.13.4/images/sha256-1245211d2fdc0f86cc374449e8be25166b9d06f1d0e4315deaaca4d81520215e?context=explore.](https://hub.docker.com/layers/proxyv2/istio/proxyv2/1.13.4/images/sha256-1245211d2fdc0f86cc374449e8be25166b9d06f1d0e4315deaaca4d81520215e?context=explore)
    Docker 文件能提供更多关于镜像构建方式的洞察：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The entry point is an Istio command/utility called `pilot-agent` that bootstraps
    Envoy to run as a sidecar when the *proxy sidecar* argument is passed in the `istio-proxy`
    container. `pilot-agent` also sets `iptables` during initialization when the *istio-iptables*
    argument is passed during initialization in the `istio-init` container.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点是一个名为 `pilot-agent` 的 Istio 命令/工具，它在传递 *proxy sidecar* 参数到 `istio-proxy`
    容器时，启动 Envoy 作为 sidecar 运行。`pilot-agent` 还在初始化时设置 `iptables`，当传递 *istio-iptables*
    参数时，它会在 `istio-init` 容器的初始化过程中执行。
- en: More information on pilot-agent
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 pilot-agent 的更多信息
- en: 'You can find more details about the pilot agent by executing `pilot-agent`
    from outside the container, picking any Pod that has the `istio-proxy` sidecar
    injected. In the following command, we have to use the Ingress gateway Pod in
    the `istio-system` namespace:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在容器外部执行 `pilot-agent`，并选择任何注入了 `istio-proxy` sidecar 的 Pod 来获得有关 pilot-agent
    的更多信息。在以下命令中，我们需要使用 `istio-system` 命名空间中的 Ingress 网关 Pod：
- en: '`$ kubectl exec -it po/istio-ingressgateway-569d7bfb4-8bzww -n istio-system
    -c istio-proxy -- /usr/local/bin/pilot-agent proxy` `router --help`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it po/istio-ingressgateway-569d7bfb4-8bzww -n istio-system
    -c istio-proxy -- /usr/local/bin/pilot-agent proxy` `router --help`'
- en: 'Like in the earlier section, you can still access the product page from your
    browser using `kubectl port-forward`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 和前面一样，你仍然可以通过 `kubectl port-forward` 从浏览器访问产品页面：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So far, we have looked at sidecar injection and what effects it has on Kubernetes
    resource deployments. In the following section, we will read about how Istio manages
    the Ingress and Egress of traffic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了 sidecar 注入以及它对 Kubernetes 资源部署的影响。在接下来的部分，我们将了解 Istio 如何管理流量的
    Ingress 和 Egress。
- en: Istio gateways
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Istio 网关
- en: 'Rather than using `port-forward`, we can also make use of the Istio Ingress
    gateway to expose the application. Gateways are used to manage inbound and outbound
    traffic to and from the mesh. Gateways provide control over inbound and outbound
    traffic. Go ahead and try the following command again to list the Pods in the
    `istiod` namespace and to discover about gateways already installed during the
    Istio installation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以使用 `port-forward`，还可以利用 Istio 的 Ingress 网关来暴露应用程序。网关用于管理进出服务网格的流量，提供对进出流量的控制。请尝试以下命令，列出
    `istiod` 命名空间中的 Pods，并查看在 Istio 安装过程中已经安装的网关：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can see that the gateways are also another set of Envoy proxies that are
    running in the mesh. They are similar to Envoy proxies deployed as a sidecar in
    the Pods, but in the gateway, they run as standalone containers in the Pod deployed
    via `pilot-agent`, with *proxy router* arguments. Let’s investigate the Kubernetes
    descriptors of the Egress gateway:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，网关也是一组在服务网格中运行的 Envoy 代理。它们类似于在 Pod 中作为 sidecar 部署的 Envoy 代理，但在网关中，它们作为独立容器运行在通过
    `pilot-agent` 部署的 Pod 中，并带有 *proxy router* 参数。让我们来研究一下 Egress 网关的 Kubernetes 描述符：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s look at the Gateway Services next:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下网关服务：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let’s try to make sense of ports for the Ingress gateway using the following
    command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用以下命令理解 Ingress 网关的端口：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can see that the Ingress gateway service takes `http2` and `https` traffic
    at ports `32295` and `31860` from outside the cluster. From inside the cluster,
    the traffic is handled at ports `80` and `443`. The `http2` and `https` traffic
    is then forwarded to ports `8080` and `8443` to underlying Ingress Pods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Ingress 网关服务从集群外部的端口 `32295` 和 `31860` 接受 `http2` 和 `https` 流量。从集群内部，流量通过端口
    `80` 和 `443` 处理。然后，`http2` 和 `https` 流量被转发到端口 `8080` 和 `8443`，转发到底层的 Ingress Pod。
- en: 'Let’s enable the Ingress gateway for the `bookinfo` service:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `bookinfo` 服务启用 Ingress 网关：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s look at the `bookinfo` virtual service definition:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `bookinfo` 的虚拟服务定义：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The virtual service is not restricted to any particular hostname. It routes
    `/productpage`, `login`, and `/logout`, and any other URI with the `/api/v1/products`
    or `/static` prefix to the `productpage` service at port `9080`. If you remember,
    `9080` was also the port exposed by the `productpage` service. The `spec.gateways`
    annotation implies that this virtual service config should be applied to `bookinfo-gateway`,
    which we will investigate next:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟服务不限制任何特定的主机名。它将`/productpage`、`login`和`/logout`，以及任何其他以`/api/v1/products`或`/static`为前缀的
    URI 路由到端口`9080`的 `productpage` 服务。如果您还记得，`9080`也是 `productpage` 服务暴露的端口。`spec.gateways`
    注解意味着该虚拟服务配置应该应用于 `bookinfo-gateway`，我们接下来会进行探讨：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The gateway resource describes a load balancer receiving incoming and outgoing
    connections to and from the mesh. The preceding example first defines that the
    configuration should be applied to the Pod with the `Istio: ingressgateway` labels
    (Ingress gateway Pods in the `istiod` namespace). The config is not bound to any
    hostnames, and it takes connection at port `80` for HTTP traffic.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '网关资源描述了一个负载均衡器，用于接收从网格进入和流出的连接。前面的示例首先定义了配置应该应用于带有`Istio: ingressgateway`标签的
    Pod（`istiod`命名空间中的 Ingress 网关 Pod）。该配置不绑定到任何主机名，并且在端口`80`上接收 HTTP 流量的连接。'
- en: So, to summarize, you have a load balancer configuration defined in the form
    of a gateway along with routing configuration to backend in the form of virtual
    services. These configs are applied to a proxy Pod, which in this case is `istio-ingressgateway-569d7bfb4-8bzww`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，您有一个以网关形式定义的负载均衡器配置，以及以虚拟服务形式定义的后端路由配置。这些配置应用于一个代理 Pod，在此案例中是 `istio-ingressgateway-569d7bfb4-8bzww`。
- en: Go ahead and check the logs of the proxy Pod while opening the product page
    in the browser.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开产品页面时，检查代理 Pod 的日志。
- en: 'First, find the IP and the port (the HTTP2 port in the Ingress gateway service):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找到 IP 和端口（Ingress 网关服务中的 HTTP2 端口）：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Fetch the products via following URL: [http://192.168.64.6:32295/api/v1/products](http://192.168.64.6:32295/api/v1/products).
    You can do this either in the browser or through `curl`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下 URL 获取产品：[http://192.168.64.6:32295/api/v1/products](http://192.168.64.6:32295/api/v1/products)。您可以通过浏览器或
    `curl` 执行此操作。
- en: 'Stream the log of the `istio-ingressgateway` Pod to `stdout`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `istio-ingressgateway` Pod 的日志流式传输到 `stdout`：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From the logs, you can infer that an inbound request `GET /api/v1/products HTTP/1.1`
    arrived at `192.168.64.6:32295`, which was then routed to `172.17.0.10:9080`.
    This is the endpoint – that is, the IP address of the `productpage` Pod.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志中，您可以推断出一个传入请求 `GET /api/v1/products HTTP/1.1` 到达了 `192.168.64.6:32295`，然后被路由到
    `172.17.0.10:9080`。这是终端节点，也就是 `productpage` Pod 的 IP 地址。
- en: The following diagram illustrates the composition of the `bookinfo` Pods with
    injected `istio-proxy` sidecars and the Istio Ingress gateway.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了带有注入的`istio-proxy`边车和 Istio Ingress 网关的 `bookinfo` Pods 的组成。
- en: '![Figure 2.3 – The BookInfo app with sidecar injection and the Istio Ingress
    gateway for traffic Ingress](img/B17989_02_03.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 带有边车注入和 Istio Ingress 网关的 BookInfo 应用程序](img/B17989_02_03.jpg)'
- en: Figure 2.3 – The BookInfo app with sidecar injection and the Istio Ingress gateway
    for traffic Ingress
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 带有边车注入和 Istio Ingress 网关的 BookInfo 应用程序
- en: Tip
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are getting TLS errors such as certificate expired or any other OpenSSL
    error, then just try restarting the BookInfo application and Istio components
    using the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到 TLS 错误，如证书过期或任何其他 OpenSSL 错误，那么请尝试使用以下命令重新启动 BookInfo 应用程序和 Istio 组件：
- en: '`$ kubectl rollout restart deployment --``namespace bookinfons`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl rollout restart deployment --``namespace bookinfons`'
- en: '`$ kubectl rollout restart deployment --``namespace istio-system`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl rollout restart deployment --``namespace istio-system`。'
- en: I hope by now you are familiarized with the basic concepts of Istio and its
    installation on your workstations. In the next section, we will continue with
    the installation of add-on components in Istio.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到目前为止，您已经熟悉了 Istio 的基本概念以及如何在工作站上安装它。在接下来的章节中，我们将继续介绍在 Istio 中安装附加组件。
- en: Observability tools
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察性工具
- en: Istio produces various metrics that can then be fed into various telemetry applications.
    The out-of-the-box installation is shipped with add-ons that include **Kiali**,
    **Jaeger**, **Prometheus**, and **Grafana**. Let’s take a look at them in the
    following sections.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 生成各种度量指标，这些指标可以输入到各种遥测应用程序中。开箱即用的安装包包含了附加组件，包括**Kiali**、**Jaeger**、**Prometheus**
    和 **Grafana**。接下来，我们将详细了解它们。
- en: Kiali
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kiali
- en: 'The first component to install will be Kiali, the default management UI for
    Istio. We’ll start by enabling the telemetry tools by running the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once all the resources have been created and Kiali has successfully deployed,
    you can then open the dashboard of Kiali by using the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Kiali is very handy when you want to visualize or troubleshoot the mesh topology
    as well as underlying mesh traffic. Let’s take a quick look at some of the visualizations.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The **Overview** page provides an overview of all the namespaces in the cluster.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The Kiali dashboard Overview section](img/B17989_02_04.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The Kiali dashboard Overview section
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: You can click on the three dots in the top-right corner to dive further into
    that namespace and also to change the configuration for it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Istio configuration for a namespace on the Kiali dashboard](img/B17989_02_05.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Istio configuration for a namespace on the Kiali dashboard
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: You can also check out individual applications, Pods, Services, and so on. One
    of the most interesting visualizations is **Graph**, which represents the flow
    of traffic in the mesh for a specified period.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – A versioned app graph on the Kiali dashboard](img/B17989_02_06.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – A versioned app graph on the Kiali dashboard
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot is of a versioned app graph, where multiple versions
    of an application are grouped together; in this case, it is a reviews app. We
    will look into this in much more detail in *Chapter 8*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Jaeger
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another add-on is Jaeger. You can open the Jaeger dashboard type with the following
    command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding command should open your browser on the Jaeger dashboard. Jaeger
    is an open source, end-to-end, distributed transaction monitoring software. The
    need for such a tool will become explicit when we build and deploy a hands-on
    application in *Chapter 4*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: In the Jaeger dashboard under `bookinfons` namespace.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The Jaeger dashboard Search section](img/B17989_02_07.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The Jaeger dashboard Search section
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then click on any of the entries for further details:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The Jaeger dashboard details section](img/B17989_02_08.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The Jaeger dashboard details section
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the overall invocation took 69.91 ms. The details were called
    by `productpage`, and it took 2.97 ms for them to return the response. You can
    then click further on any of the services to see a detailed trace.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will look into Prometheus, which is also an open source monitoring
    system and time series database. Prometheus is used to capture all metrics against
    time to track the health of the mesh and its constituents.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the Prometheus dashboard, use the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This should open the Prometheus dashboard in your browser. With our installation,
    Prometheus is configured to collect metrics from `istiod`, the Ingress and Egress
    gateways, and the istio-proxy.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are checking the total requests handled by Istio
    for the `productpage` application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们查看Istio处理的`productpage`应用的总请求。
- en: '![Figure 2.9 – The Istio total request on the Prometheus dashboard](img/B17989_02_09.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 在Prometheus仪表板上的Istio总请求](img/B17989_02_09.jpg)'
- en: Figure 2.9 – The Istio total request on the Prometheus dashboard
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 在Prometheus仪表板上的Istio总请求
- en: Another add-on to look at is Grafana, which, like Kiali, is another visualization
    tool.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要关注的附加工具是Grafana，和Kiali一样，它也是一个可视化工具。
- en: Grafana
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grafana
- en: 'To start the Grafana dashboard, use the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Grafana仪表板，请使用以下命令：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is a visualization of the total requests handled by Istio for
    `productpage`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Istio处理的`productpage`总请求的可视化：
- en: '![Figure 2.10 – The Grafana dashboard Explore section](img/B17989_02_10.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – Grafana仪表板Explore部分](img/B17989_02_10.jpg)'
- en: Figure 2.10 – The Grafana dashboard Explore section
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – Grafana仪表板的Explore部分
- en: The following is another visualization of the Istio performance metrics.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Istio性能指标的另一个可视化。
- en: '![Figure 2.11 – The Grafana Istio Performance Dashboard](img/B17989_02_11.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – Grafana Istio性能仪表板](img/B17989_02_11.jpg)'
- en: Figure 2.11 – The Grafana Istio Performance Dashboard
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – Grafana Istio性能仪表板
- en: 'Note that by just applying a label, `istio-injection: enabled`, we enabled
    the Service Mesh for the BookInfo application. Sidecars were injected automatically
    and mTLS was enabled by default for communication between different microservices
    of the application. Moreover, a plethora of monitoring tools provide information
    about the BookInfo application and its underlying microservices.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，仅通过应用标签`istio-injection: enabled`，我们便为BookInfo应用启用了服务网格。Sidecar自动注入，mTLS也默认启用于应用中不同微服务之间的通信。此外，众多监控工具提供有关BookInfo应用及其底层微服务的信息。'
- en: Istio architecture
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio架构
- en: Now that we have installed Istio, enabled it for the BookInfo application, and
    also analyzed it’s operations, it is time to simplify what we have seen so far
    with a diagram. The following figure is a representation of Istio architecture.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Istio，为BookInfo应用启用了它，并且也分析了它的操作，是时候通过图表简化我们迄今为止看到的内容了。以下图为Istio架构的表示。
- en: '![Figure 2.12 – Istio architecture](img/B17989_02_12.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – Istio架构](img/B17989_02_12.jpg)'
- en: Figure 2.12 – Istio architecture
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – Istio架构
- en: The Istio Service Mesh comprises a data plane and a control plane. The example
    we followed in this chapter installs both of them on one node. In a production
    or non-production environment, the Istio control plane will be installed on its
    own separate set of nodes. The **control plane** comprises istiod components as
    well as a few other Kubernetes configs, which, altogether, are responsible for
    managing and providing service discovery to the data plane, propagation of configuration
    related to security and traffic management, as well as providing and managing
    identity and certificates to data plane components.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Istio服务网格由数据平面和控制平面组成。本章中我们遵循的示例将它们都安装在一个节点上。在生产或非生产环境中，Istio控制平面将安装在独立的节点集上。**控制平面**由istiod组件以及一些其他Kubernetes配置组成，这些组件和配置共同负责管理并提供服务发现给数据平面，传播与安全性和流量管理相关的配置，并向数据平面组件提供和管理身份与证书。
- en: The **data plane** is another part of the Service Mesh that consists of Istio
    proxies deployed alongside the application container in the Pod. Istio proxies
    are basically Envoy. Envoy is an application-aware service proxy that mediates
    all network traffic between microservices, based on instructions from the control
    plane. Envoy also collects various metrics and reports back telemetry to various
    add-on tools.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据平面**是服务网格的另一个部分，由部署在Pod中的应用容器旁的Istio代理组成。Istio代理基本上是Envoy。Envoy是一个感知应用的服务代理，根据控制平面的指示调节微服务之间的所有网络流量。Envoy还收集各种指标并将遥测数据报告回各种附加工具。'
- en: Subsequent chapters will be dedicated to the control plane and data plane, in
    which we will dive deeper into understanding their functions and behavior.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将专注于控制平面和数据平面，我们将深入理解它们的功能和行为。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we prepared a local environment to install Istio using `istioctl`
    which is the Istio command-line utility. We then enabled sidecar injection by
    applying a label called `istio-injection: enabled` to the namespace that hosts
    the microservices.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们准备了一个本地环境来使用 `istioctl` 工具安装 Istio，这是 Istio 的命令行工具。然后，我们通过将 `istio-injection:
    enabled` 标签应用于托管微服务的命名空间，启用了 Sidecar 注入。'
- en: We briefly looked at Kubernetes admission controllers and how mutating admission
    webhooks inject sidecars to the deployment API calls to the Kubernetes API server.
    We also read about gateways and looked at the sample Ingress and Egress gateways
    that are installed with Istio. The gateway is a standalone istio-proxy, aka an
    Envoy proxy, and is used to manage Ingress and Egress traffic to and from the
    mesh. Following this, we looked at how various ports are configured to be exposed
    on the Ingress gateway and how traffic is routed to upstream services.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地了解了 Kubernetes 的准入控制器以及如何通过变更准入 Webhook 将 Sidecar 注入到部署 API 调用中，进而与 Kubernetes
    API 服务器进行交互。我们还了解了网关，并查看了与 Istio 一起安装的示例入口和出口网关。网关是一个独立的 istio-proxy，也叫 Envoy
    代理，主要用于管理进出服务网格的流量。接着，我们了解了如何配置各个端口以便在入口网关上公开，并且如何将流量路由到上游服务。
- en: Istio provides integration with various telemetry and observability tools. The
    first tool we looked at was Kiali, the visualization tool providing insight into
    traffic flows. It is also the management console for the Istio Service Mesh. Using
    Kiali, you can also perform Istio management functions such as checking/modifying
    various configurations and checking infrastructure status. After Kiali, we looked
    at Jaeger, Prometheus, and Grafana, all of which are open source and can be integrated
    easily with Istio.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 提供了与各种遥测和可观察性工具的集成。我们首先了解的工具是 Kiali，这是一个可视化工具，能提供流量流动的洞察。它同时也是 Istio 服务网格的管理控制台。通过
    Kiali，你还可以执行 Istio 管理功能，如检查/修改各种配置和检查基础设施状态。在 Kiali 之后，我们了解了 Jaeger、Prometheus
    和 Grafana，这些都是开源工具，可以与 Istio 无缝集成。
- en: The content of this chapter sets the foundations for and prepares you to deep
    dive into Istio in the upcoming chapters. In the next chapter, we will be reading
    about Istio’s control and data planes, taking a deep dive into their various components.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容为你深入学习 Istio 打下了基础，并为后续章节的学习做了准备。在下一章中，我们将阅读关于 Istio 的控制平面和数据平面的内容，深入了解它们的各个组件。
