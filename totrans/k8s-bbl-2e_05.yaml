- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Using Multi-Container Pods and Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多容器 Pod 和设计模式
- en: Running complex applications on Kubernetes will require that you run not one
    but several containers in the same Pods. The strength of Kubernetes also lies
    in its ability to create Pods made up of several containers. We will focus on
    those Pods in this chapter by studying the different aspects of hosting several
    containers in the same Pod, as well as having these different containers communicate
    with each other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行复杂应用程序需要在同一个 Pod 中运行多个容器，而不仅仅是一个。Kubernetes 的优势也在于它能够创建由多个容器组成的
    Pod。本章将重点研究这些 Pod，探讨在同一个 Pod 中托管多个容器的不同方面，以及如何让这些不同的容器彼此通信。
- en: 'So far, we’ve only created Pods running a single container: those were the
    simplest forms of Pods, and you’ll use these Pods to manage the simplest of applications.
    We also discovered how to update and delete them by running simple **create**,
    **read**, **update, and delete** (**CRUD**) operations against those Pods using
    the `kubectl` command-line tool.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了运行单一容器的 Pod：这些是最简单的 Pod 形式，你将使用这些 Pod 来管理最简单的应用程序。我们还发现了如何通过使用 `kubectl`
    命令行工具对这些 Pod 执行简单的 **创建**、**读取**、**更新和删除**（**CRUD**）操作来更新和删除它们。
- en: Besides mastering the basics of CRUD operations, you have also learned how to
    access a running Pod inside a Kubernetes cluster.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了掌握 CRUD 操作的基础知识，你还需要学会如何访问 Kubernetes 集群中正在运行的 Pod。
- en: While single-container Pods are more common, there are situations where using
    multiple containers in a single Pod is beneficial. For example, using a dedicated
    container to handle log gathering with the main container inside a Pod or another
    dedicated container to enable proxy communication between services. In this chapter,
    we will push all of this one step forward and discover how to manage Pods when
    they are meant to launch not one but several containers. The good news is that
    everything you learned previously will also be valid for multi-container Pods.
    Things won’t differ much in terms of raw Pod management because updating and deleting
    Pods is not different, no matter how many containers the Pod contains.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单容器 Pod 更为常见，但也有一些情况，使用单个 Pod 中的多个容器会更有益。例如，在 Pod 内使用专门的容器来处理日志收集，或者使用另一个专用容器来实现服务之间的代理通信。本章将进一步探讨如何管理多个容器的
    Pod，并学习如何处理这些 Pod。当 Pod 用于启动不止一个容器时，你所学到的一切都将适用于多容器 Pod。在原始的 Pod 管理方面没有太大不同，因为更新和删除
    Pod 的操作没有区别，无论 Pod 包含多少个容器。
- en: Besides those basic operations, we are also going to cover how to access a specific
    container inside a multi-container Pod and how to access its logs. When a given
    Pod contains more than one container, you’ll have to run some specific commands
    with specific arguments to access it, and that’s something we are going to cover
    in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本操作外，我们还将讲解如何访问多容器 Pod 中的特定容器以及如何访问其日志。当一个 Pod 包含多个容器时，你需要运行一些特定的命令和参数来访问它，这正是我们将在本章中讨论的内容。
- en: We will also discover some important design patterns such as Ambassador, Sidecar,
    and Adapter containers. You’ll need to learn these architectures to effectively
    manage multi-container Pods. You’ll also learn how to deal with volumes from Kubernetes.
    Docker also provides volumes, but in Kubernetes, they are used to share data between
    containers launched by the same Pod, and this is going to be an important part
    of this chapter. After this chapter, you’re going to be able to launch complex
    applications inside Kubernetes Pods.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探索一些重要的设计模式，例如大使（Ambassador）、边车（Sidecar）和适配器（Adapter）容器。你需要学习这些架构，以有效管理多容器
    Pod。你还将学习如何处理 Kubernetes 中的卷。Docker 也提供卷，但在 Kubernetes 中，卷用于在由同一个 Pod 启动的容器之间共享数据，这将是本章的一个重要部分。学习完本章后，你将能够在
    Kubernetes Pod 内启动复杂应用程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Understanding what multi-container Pods are
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多容器 Pod
- en: Sharing volumes between containers in the same Pod
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一个 Pod 中共享容器之间的卷
- en: The Ambassador Design Pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大使设计模式
- en: The Sidecar Design Pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边车设计模式
- en: The Adapter Design Pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: Sidecars versus Kubernetes Native Sidecars
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边车与 Kubernetes 本地边车
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will require the following prerequisites for this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下前置条件：
- en: A working `kubectl` command-line utility.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 `kubectl` 命令行工具。
- en: A local or cloud-based Kubernetes cluster to practice with.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个本地或基于云的Kubernetes集群用于实践。
- en: 'You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter05).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从官方GitHub仓库下载本章的最新代码示例：[https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter05)。
- en: Understanding what multi-container Pods are
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解什么是多容器Pod
- en: Multi-container Pods are a way to package tightly coupled applications together
    in Kubernetes. This allows multiple containers to share resources and easily communicate
    with each other, which is ideal for scenarios like sidecars and service mesh.
    In this section, we’ll learn about the core concepts of Pods for managing multiple
    containers at once by discussing some concrete examples of multi-container Pods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多容器Pod是将紧密耦合的应用程序打包在一起的方式，适用于Kubernetes。这使得多个容器可以共享资源并轻松地相互通信，非常适合像边车（sidecar）和服务网格（service
    mesh）这样的场景。在本节中，我们将通过讨论一些具体的多容器Pod示例，来了解管理多个容器时的Pod核心概念。
- en: Concrete scenarios where you need multi-container Pods
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要使用多容器Pod的具体场景
- en: You should group your containers into a Pod when they need to be tightly linked.
    More broadly, a Pod must correspond to an application or a process running in
    your Kubernetes cluster. If your application requires multiple containers to function
    properly, then those containers should be launched and managed through a single
    Pod.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器需要紧密关联时，你应该将它们分组为一个Pod。从更广义的角度来看，一个Pod必须对应于在Kubernetes集群中运行的一个应用程序或进程。如果你的应用程序需要多个容器才能正常工作，那么这些容器应该通过一个Pod来启动和管理。
- en: 'When the containers are supposed to work together, you should group them into
    a single Pod. Keep in mind that a Pod cannot span across multiple compute nodes.
    So, if you create a Pod containing several containers, then all these containers
    will be created on the same compute node. To understand where and when to use
    multi-container Pods, take the example of two simple applications:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些容器需要协同工作时，应该将它们分组为一个Pod。需要记住的是，Pod不能跨多个计算节点。因此，如果你创建了一个包含多个容器的Pod，那么所有这些容器都会被创建在同一个计算节点上。为了理解何时以及如何使用多容器Pod，可以通过以下两个简单应用程序的示例来进行说明：
- en: '**A log forwarder**: In this example, imagine that you have deployed a web
    server such as NGINX that stores its logs in a dedicated directory. You might
    want to collect and forward these logs. For that, you could deploy something like
    a Splunk forwarder as a container within the same Pod as your NGINX server.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志转发器**：在这个示例中，假设你已经部署了一个如NGINX这样的Web服务器，并将其日志存储在一个专用目录中。你可能希望收集并转发这些日志。为此，你可以将像Splunk转发器这样的工具作为容器，部署在与NGINX服务器相同的Pod中。'
- en: These log forwarding tools are used to forward logs from a source to a destination
    location, and it is very common to deploy agents such as Splunk, Fluentd, or Filebeat
    to grab logs from a container and forward them to a central location such as an
    Elasticsearch cluster. In the Kubernetes world, this is generally achieved by
    running a multi-container Pod with one container dedicated to running the application,
    and another one dedicated to grabbing the logs and sending them elsewhere. Having
    these two containers managed by the same Pod would ensure that they are launched
    on the same node as the log forwarder and at the same time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志转发工具用于将日志从源位置转发到目标位置，通常会部署像Splunk、Fluentd或Filebeat这样的代理，来从容器中获取日志并将其转发到一个中心位置，比如Elasticsearch集群。在Kubernetes环境中，这通常是通过运行一个多容器Pod来实现，其中一个容器专门用于运行应用程序，另一个容器专门用于获取日志并将其发送到其他地方。将这两个容器由同一个Pod管理，可以确保它们在同一个节点上启动，并且同时运行。
- en: '**A proxy server**: Imagine an NGINX reverse proxy container in the same Pod
    as your main application, efficiently handling traffic routing and security with
    custom rules. This concept extends to **service mesh**, where a dedicated proxy
    like Envoy can be deployed alongside your application container, enabling features
    like load balancing and service discovery within a microservices architecture.
    (We will learn about service mesh in detail in *Chapter 8*, *Exposing Your Pods
    with Services*.) By bundling the two containers in the same Pod, you’ll get two
    Pods running in the same node. You could also run a third container in the same
    Pod to forward the logs that are emitted by the two others to a central logging
    location! This is because Kubernetes has no limit on the number of containers
    you can have in the same Pod, as long as you have enough computing resources to
    run them all.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理服务器**：想象一个与主应用程序位于同一Pod中的NGINX反向代理容器，它高效地处理流量路由和安全性，使用自定义规则。这一概念扩展到**服务网格**，在这里像Envoy这样的专用代理可以与应用程序容器一起部署，从而在微服务架构中启用负载均衡和服务发现等功能。（我们将在*第8章*《通过服务暴露Pod》详细学习服务网格。）通过将这两个容器捆绑在同一个Pod中，你将得到两个Pod运行在同一个节点上。你也可以在同一个Pod中运行第三个容器，将其他两个容器发出的日志转发到中央日志位置！这是因为Kubernetes对同一个Pod中的容器数量没有限制，只要你有足够的计算资源来运行它们。'
- en: '![](img/B22019_05_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_05_01.png)'
- en: 'Figure 5.1: Sample multi-container Pod scenario'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：示例多容器Pod场景
- en: In general, every time several of your containers work together and are tightly
    coupled, you should have them in a multi-container Pod.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每当多个容器一起工作并紧密耦合时，你应该将它们放在一个多容器Pod中。
- en: Now, let’s discover how to create multi-container Pods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解如何创建多容器Pod。
- en: Creating a Pod made up of two containers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个由两个容器组成的Pod
- en: 'In the previous chapter, we discovered two syntaxes for manipulating Kubernetes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现了两种用于操作Kubernetes的语法：
- en: The imperative syntax
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式语法
- en: The declarative syntax
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式语法
- en: Most of the Kubernetes objects we are going to discover in this book can be
    created or updated using these two methods, but unfortunately, this is not the
    case for multi-container Pods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将要探索的大多数Kubernetes对象都可以通过这两种方法创建或更新，但不幸的是，多容器Pod的情况并非如此。
- en: When you need to create a Pod containing multiple containers, you will need
    to go through the declarative syntax. This means that you will have to create
    a YAML file containing the declaration of your Pods and all the containers it
    will manage, and then apply it through `kubectl apply -f file.yaml`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要创建一个包含多个容器的Pod时，你需要使用声明式语法。这意味着你需要创建一个YAML文件，包含Pod及其将管理的所有容器的声明，然后通过`kubectl
    apply -f file.yaml`来应用它。
- en: 'Consider the following YAML manifest file stored in `~/multi-container-pod.yaml`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下存储在`~/multi-container-pod.yaml`中的YAML清单文件：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This YAML manifest will create a Kubernetes Pod made up of two containers:
    one based on the `nginx:latest` image and the other one based on the `debian`
    image.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML清单将创建一个由两个容器组成的Kubernetes Pod：一个基于`nginx:latest`镜像，另一个基于`debian`镜像。
- en: 'To create it, use the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建它，请使用以下命令：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will result in the Pod being created. The kubelet on the elected node will
    have the container runtime (e.g., containerd, CRI-O, or Docker daemon) to pull
    both images and instantiate two containers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致Pod被创建。选定节点上的kubelet将拥有容器运行时（例如containerd、CRI-O或Docker守护进程）来拉取两个镜像并实例化两个容器。
- en: 'To check whether the Pod was correctly created, we can run `kubectl get pods`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查Pod是否正确创建，我们可以运行`kubectl get pods`：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do you remember the role of `kubelet` from *Chapter 2*, *Kubernetes Architecture
    – from Container Images to Running Pods*? This component runs on each node that
    is part of your Kubernetes cluster and is responsible for converting Pod manifests
    received from `kube-apiserver` into actual containers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得来自*第2章*《Kubernetes架构——从容器镜像到运行Pod》中`kubelet`的角色吗？这个组件运行在 Kubernetes 集群中的每个节点上，负责将从`kube-apiserver`接收到的Pod清单转换为实际的容器。
- en: All the containers that are declared in the same Pod will be scheduled, or launched,
    on the same node and Pods cannot span multiple machines.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在同一个Pod中声明的容器都会被调度或启动在同一个节点上，Pod不能跨多个机器。
- en: Containers in the same Pod are meant to live together. If you terminate a Pod,
    all its containers will be killed together, and when you create a Pod, the kubelet
    will, at the very least, attempt to create all its containers together.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相同 Pod 中的容器是共存的。如果终止 Pod，则所有其容器将一同终止；创建 Pod 时，kubelet 至少会尝试一起创建其所有容器。
- en: High availability is generally achieved by replicating multiple Pods over multiple
    nodes, which you will learn about later in this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过在多个节点上复制多个 Pods 来实现高可用性，这是您稍后在本书中将学习的内容。
- en: From a Kubernetes perspective, applying this file results in a fully working
    multi-container Pod made up of two containers, and we can make sure that the Pod
    is running with the two containers by running a standard `kubectl get pods` command
    to fetch the Pod list from `kube-apiserver`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Kubernetes 的角度来看，应用此文件会导致由两个容器组成的完全工作的多容器 Pod，并且可以通过运行标准的 `kubectl get pods`
    命令从 `kube-apiserver` 获取 Pod 列表来确保 Pod 正在运行。
- en: Do you see the column that states `2/2` in the previous `kubectl` command output?
    This is the number of containers inside the Pod. Here, this is saying that the
    two containers that are part of this Pod were successfully launched! We can see
    the logs from different containers as follows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到前一个 `kubectl` 命令输出中标有 `2/2` 的列了吗？这是 Pod 中的容器数量。在这里，它表示成功启动了两个容器！我们可以查看来自不同容器的日志如下。
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We learned how to create and manage multi-container Pods, and in the next section,
    we will learn how to troubleshoot when a multi-container Pod fails.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何创建和管理多容器 Pods，接下来，我们将学习当多容器 Pod 失败时如何进行故障排除。
- en: What happens when Kubernetes fails to launch one container in a Pod?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当 Kubernetes 无法启动 Pod 中的一个容器时会发生什么？
- en: Kubernetes keeps track of all the containers that are launched in the same Pod.
    But it often happens that a specific container cannot be launched. Let’s introduce
    a typo in the YAML manifest to demonstrate how Kubernetes reacts when some containers
    of a specific Pod cannot be launched.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 记录了在同一 Pod 中启动的所有容器。但经常发生特定容器无法启动的情况。让我们在 YAML 清单中引入一个打字错误，以演示当某些特定
    Pod 的容器无法启动时 Kubernetes 的反应。
- en: 'In the following example, we have defined a container image that does not exist
    at all for the NGINX container; note the `nginx:i-do-not-exist` tag:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们定义了一个容器镜像，对于 NGINX 容器根本不存在；请注意 `nginx:i-do-not-exist` 标签：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can apply the following container using the `kubectl apply -f failed-multi-container-pod.yaml`
    command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `kubectl apply -f failed-multi-container-pod.yaml` 命令应用以下容器：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, you can see that the Pod was effectively created. This is because even
    if there’s a non-existent image, the YAML remains valid from a Kubernetes perspective.
    So, Kubernetes simply creates the Pod and persists the entry into `etcd`, but
    we can easily imagine that the kubelet will encounter an error when it launches
    the container to retrieve the image from the container registry (e.g., Docker
    Hub).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到 Pod 已有效创建。这是因为即使存在不存在的镜像，从 Kubernetes 的角度来看，YAML 仍然有效。因此，Kubernetes
    简单地创建 Pod 并将条目持久化到 `etcd` 中，但我们可以轻松想象，当 kubelet 尝试从容器注册表（例如 Docker Hub）中检索镜像以启动容器时会遇到错误。
- en: 'Let’s check the status of the Pod using `kubectl get pod`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `kubectl get pod` 命令检查 Pod 的状态：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the status of the Pod is `ImagePullBackOff`. This means that
    Kubernetes is trying to launch the Pod but failing with an image access issue.
    To find out why it’s failing, you have to describe the Pod using the `kubectl
    describe pod failed-multi-container-pod` command as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，Pod 的状态为 `ImagePullBackOff`。这意味着 Kubernetes 正试图启动 Pod，但由于镜像访问问题而失败。要查明失败原因，您必须使用以下命令描述
    Pod：`kubectl describe pod failed-multi-container-pod`。
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s a little bit hard to read, but by following this log, you can see that
    `debian-container` is okay since `kubelet` has succeeded in creating it, as shown
    by the last line of the preceding output. But there’s a problem with the other
    container; that is, `nginx-container`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微有点难以阅读，但通过跟随此日志，您可以看到 `debian-container` 是正常的，因为 `kubelet` 已成功创建它，如前一输出的最后一行所示。但另一个容器存在问题，即
    `nginx-container`。
- en: Here, you can see that the output error is `ErrImagePull` and, as you can guess,
    it’s saying that the container cannot be launched because the image pull fails
    to retrieve the `nginx:i-do-not-exist` image tag.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到输出错误为 `ErrImagePull`，正如您猜测的那样，它表示无法启动容器，因为镜像拉取无法检索到 `nginx:i-do-not-exist`
    镜像标签。
- en: 'So, Kubernetes does the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Kubernetes 执行以下操作：
- en: First, it creates the entry in `etcd` if the Pod of the YAML file is valid.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果 YAML 文件中的 Pod 有效，它会在 `etcd` 中创建条目。
- en: Then, it simply tries to launch the container.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它只是尝试启动容器。
- en: If an error is encountered, it will try to launch the failing container again
    and again.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果遇到错误，它将反复尝试重新启动失败的容器。
- en: If any other container works properly, it’s fine. However, your Pod will never
    enter the `Running` status because of the failed container. After all, your app
    certainly needs the failing container to work properly; otherwise, that container
    should not be there at all!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他容器正常工作也没问题。然而，由于失败的容器，你的 Pod 永远无法进入 `Running` 状态。毕竟，你的应用程序肯定需要失败的容器才能正常工作；否则，这个容器根本不该存在！
- en: Now, let’s learn how to delete a multi-container Pod.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何删除一个多容器 Pod。
- en: Deleting a multi-container Pod
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除多容器 Pod
- en: When you want to delete a Pod containing multiple containers, you have to go
    through the `kubectl delete` command, just like you would for a single-container
    Pod.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想删除包含多个容器的 Pod 时，你必须通过`kubectl delete`命令，就像删除单容器 Pod 一样。
- en: 'Then, you have two choices:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你有两个选择：
- en: You can specify the path to the YAML manifest file that’s used by using the
    `-f` option.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 `-f` 选项来指定 YAML 清单文件的路径。
- en: You can delete the Pod without using its YAML path if you know its name.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道 Pod 的名称，可以不使用 YAML 路径直接删除它。
- en: 'The first way consists of specifying the path to the YAML manifest file. You
    can do so using the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式是指定 YAML 清单文件的路径。你可以使用以下命令来执行：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Otherwise, if you already know the Pod’s name, you can do this as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果你已经知道 Pod 的名称，可以按以下方式进行操作：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To figure out the name of the Pods, you can use the `kubectl get` commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要弄清楚 Pod 的名称，可以使用 `kubectl get` 命令：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we ran them, only `failed-multi-container-pod` was created in the cluster,
    so that’s why you can just see one line in the output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它们时，集群中只创建了 `failed-multi-container-pod`，所以你在输出中只看到一行。
- en: 'Here is how you can delete `failed-multi-container-pod` imperatively without
    specifying the YAML file that created it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在不指定创建它的 YAML 文件的情况下命令式地删除 `failed-multi-container-pod`：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After a few seconds, the Pod is removed from the Kubernetes cluster, and all
    its containers are removed from the container daemon and the Kubernetes cluster
    node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，Pod 会从 Kubernetes 集群中移除，所有容器也会从容器守护进程和 Kubernetes 集群节点中移除。
- en: The amount of time that’s spent before the command is issued and the Pod’s name
    is deleted and released is called the **grace period**. Let’s discover how to
    deal with it!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令发出之前，Pod 的名称被删除并释放的时间称为 **宽限期**。让我们来了解如何处理它！
- en: Understanding the Pod deletion grace period
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Pod 删除的宽限期
- en: One important concept related to deleting Pods is what is called the grace period.
    Both single-container Pods and multi-container Pods have this grace period, which
    can be observed when you delete them. This grace period can be ignored by passing
    the `--grace-period=0 --force` option to the `kubectl delete` command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 Pods 相关的一个重要概念是所谓的宽限期。单容器 Pod 和多容器 Pod 都有这个宽限期，在删除它们时可以观察到。通过传递 `--grace-period=0
    --force` 选项到 `kubectl delete` 命令，可以忽略这个宽限期。
- en: During the deletion of a Pod, certain `kubectl` commands display its status
    as `Terminating`. Notably, this `Terminating` status is not categorized within
    the standard Pod phases. Pods are allocated a designated grace period for graceful
    termination, typically set to 30 seconds. To forcefully terminate a Pod, the `--force`
    flag can be employed. When the deletion is forced by setting `--grace-period=0`
    with the `--force` flag, the Pod’s name is immediately released and becomes available
    for another Pod to take it. During an unforced deletion, the grace period is respected,
    and the Pod’s name is released after it is effectively deleted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除 Pod 的过程中，某些 `kubectl` 命令会显示其状态为 `Terminating`。值得注意的是，这个 `Terminating` 状态并不属于标准的
    Pod 阶段。Pod 会被分配一个专门的宽限期以实现优雅终止，通常设置为 30 秒。要强制终止 Pod，可以使用 `--force` 标志。当通过设置 `--grace-period=0`
    和 `--force` 标志来强制删除时，Pod 的名称会立即释放，并可供另一个 Pod 使用。在非强制删除的情况下，宽限期会被尊重，Pod 的名称会在其被有效删除后释放。
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command should be used carefully if you don’t know what you are doing.
    Forcefully deleting a Pod shouldn’t be seen as the norm because, as the output
    states, you cannot be sure that the Pod was effectively deleted. If, for some
    reason, the Pod cannot be deleted, it might run indefinitely, so do not run this
    command if you are not sure of what to do.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道自己在做什么，使用这个命令时需要小心。强制删除 Pod 不应被视为常规操作，因为正如输出所示，你无法确保 Pod 已被有效删除。如果由于某种原因
    Pod 无法被删除，它可能会无限期运行，因此如果你不确定该怎么做，请不要运行这个命令。
- en: Now, let’s discover how to access a specific container that is running inside
    a multi-container Pod.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解如何访问运行在多容器 Pod 中的特定容器。
- en: Accessing a specific container inside a multi-container Pod
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问多容器 Pod 中的特定容器
- en: 'When you have several containers in the same Pod, you can access each of them
    individually. Here, we will access the NGINX container of our multi-container
    Pods. Let’s start by recreating it because we deleted it in our previous example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在同一个 Pod 中有多个容器时，可以单独访问每个容器。在这里，我们将访问我们多容器 Pod 中的 NGINX 容器。让我们从重新创建它开始，因为我们在之前的例子中已经删除了它：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To access a running container, you need to use the `kubectl exec` command, just
    like you need to use `docker exec` to launch a command in an already created container
    when using Docker without Kubernetes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个正在运行的容器，你需要使用 `kubectl exec` 命令，就像在没有 Kubernetes 的 Docker 环境中使用 `docker
    exec` 在已创建的容器中启动命令一样。
- en: 'This command will ask for two important parameters:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会要求提供两个重要参数：
- en: The Pod that wraps the container you want to target
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包裹你想要访问的容器的 Pod
- en: The name of the container itself, as entered in the YAML manifest file
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器本身的名称，如 YAML 清单文件中所写的那样
- en: We already know the name of the Pod because we can easily retrieve it with the
    `kubectl get` command. In our case, the Pod is named `multi-container-pod`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 Pod 的名称，因为我们可以轻松地通过 `kubectl get` 命令检索它。在我们的例子中，Pod 被命名为 `multi-container-pod`。
- en: 'However, we don’t have the container’s name because there is no `kubectl get`
    containers command that would allow us to list the running containers. This is
    why we will have to use the `kubectl describe pods/multi-container-pod` command
    to find out what is contained in this Pod:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法获取容器的名称，因为没有 `kubectl get` 容器命令来列出正在运行的容器。这就是为什么我们必须使用 `kubectl describe
    pods/multi-container-pod` 命令来查看该 Pod 中包含了什么：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command will show the names of all the containers contained in the targeted
    Pod. Here, we can see that our Pod is running two containers, one called `debian-container`
    and another called `nginx-container`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将显示目标 Pod 中所有容器的名称。在这里，我们可以看到我们的 Pod 正在运行两个容器，一个名为 `debian-container`，另一个名为
    `nginx-container`。
- en: 'Additionally, the following is a command for listing all the container names
    contained in a dedicated Pod:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是列出某个专用 Pod 中所有容器名称的命令：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command will spare you from using the `describe` command. However, it
    makes use of `jsonpath`, which is an advanced feature of `kubectl`: this command
    might look strange but it mostly consists of a sort filter that’s applied against
    the command. The `jsonpath` expression `{.spec.containers[*].name}` can be used
    with the `kubectl get pod` command to retrieve the names of all containers within
    a specific Pod. The `.` denotes the entire response object, while `spec.containers`
    targets the containers section within the Pod specification. The `[*]` operator
    instructs `jsonpath` to iterate through all elements within the containers list,
    and `.name` extracts the `name` property from each container object. Essentially,
    this expression provides a comma-separated list of container names within the
    specified Pod.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将避免你使用 `describe` 命令。然而，它使用了 `jsonpath`，这是 `kubectl` 的高级功能：这个命令看起来可能有些奇怪，但它主要由一个排序过滤器组成，应用于该命令。`jsonpath`
    表达式 `{.spec.containers[*].name}` 可以与 `kubectl get pod` 命令一起使用，获取特定 Pod 中所有容器的名称。`.`
    表示整个响应对象，而 `spec.containers` 指向 Pod 规范中的容器部分。`[*]` 操作符指示 `jsonpath` 遍历容器列表中的所有元素，`.name`
    提取每个容器对象的 `name` 属性。本质上，这个表达式返回指定 Pod 中容器名称的逗号分隔列表。
- en: '`jsonpath` filters are not easy to get right, so, feel free to add this command
    as a bash alias or note it somewhere because it’s a useful one.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonpath` 过滤器不容易正确编写，因此，可以将此命令添加为 bash 别名或记下来，因为它非常有用。'
- en: 'In any case, we can now see that we have these two containers inside the `multi-container-pod`
    Pod:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们现在可以看到在 `multi-container-pod` Pod 中有这两个容器：
- en: '`nginx-container`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx-container`'
- en: '`busybox-container`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`busybox-container`'
- en: 'Now, let’s access `nginx-container`. You have the name of the targeted container
    in the targeted Pod, so use the following command to access the Pod:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们访问`nginx-container`。你可以在目标Pod中找到目标容器的名称，然后使用以下命令访问该Pod：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After running this command, you will find yourself inside `nginx-container`.
    Let’s explain this command a little bit. `kubectl exec` does the same as `docker
    exec`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你会发现自己已经进入了`nginx-container`。让我们稍微解释一下这个命令。`kubectl exec`的作用和`docker
    exec`一样：
- en: '`kubectl exec`: This is the command to execute commands in a Kubernetes container.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl exec`：这是在Kubernetes容器中执行命令的命令。'
- en: '`-it`: These are options for the execution. `-t` allocates a pseudo-TTY, and
    `-i` allows interaction with the container.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-it`：这些是执行命令的选项。`-t`分配一个伪终端，`-i`允许与容器进行交互。'
- en: '`multi-container-pod`: This is the name of the Pod in which you want to execute
    the command.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multi-container-pod`：这是你希望执行命令的Pod的名称。'
- en: '`--container nginx-container`: This specifies the container within the Pod
    where the command should be executed. In Pods with multiple containers, you need
    to specify the container you want to interact with.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--container nginx-container`：这指定了在Pod中执行命令的容器。在多容器的Pod中，你需要指定你想要交互的容器。'
- en: '`-- /bin/bash`: This is the actual command that will be executed in the specified
    container. It launches a Bash shell (`/bin/bash`) in interactive mode, allowing
    you to interact with the container’s command line.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-- /bin/bash`：这是将在指定容器中执行的实际命令。它启动一个交互模式的Bash shell（`/bin/bash`），允许你与容器的命令行进行交互。'
- en: When you run this command, you get the shell of the container, inside the multi-container
    Pod, at a point at which you will be ready to run commands inside this very specific
    container on your Kubernetes cluster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你将进入多容器Pod内容器的Shell，此时你准备好在Kubernetes集群中的这个特定容器内运行命令了。
- en: The main difference from the single container Pod situation is the `--container`
    option (the `-c` short option works, too). You need to pass this option to tell
    `kubectl` what container you want to reach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与单容器Pod的情况相比，主要的不同是`--container`选项（`-c`短选项也有效）。你需要传递这个选项，告诉`kubectl`你要访问哪个容器。
- en: Now, let’s discover how to run commands in the containers running in your Pods!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来学习如何在你的Pod中的容器中运行命令！
- en: Running commands in containers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器中运行命令
- en: One powerful aspect of Kubernetes is that you can, at any time, access the containers
    running on your Pods to execute some commands. We did this previously, but did
    you know you can also execute any command you want directly from the `kubectl`
    command-line tool?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的一个强大之处是，你可以随时访问运行在Pod中的容器，以执行一些命令。我们之前做过这个，但你知道吗，你也可以直接从`kubectl`命令行工具中执行任何你想要的命令？
- en: 'First, we are going to recreate the multi-container Pod:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重新创建多容器Pod：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To run a command in a container, you need to use `kubectl exec`, just like we
    did previously. But this time, you have to remove the `-ti` parameter to prevent
    `kubectl` from attaching to your running terminal session.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要在容器中运行命令，你需要使用`kubectl exec`，就像我们之前做的那样。但这次，你必须去掉`-ti`参数，以防止`kubectl`附加到你正在运行的终端会话。
- en: 'Here, we are running the `ls` command to list files in `nginx-container` from
    the `multi-container-pod` Pod:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在运行`ls`命令，以列出`nginx-container`容器中的文件，来自`multi-container-pod` Pod：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can omit the container name but if you do so, `kubectl` will use the default
    first one.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略容器名称，但如果这么做，`kubectl`将使用默认的第一个容器。
- en: Next, we will discover how to override the commands that are run by your containers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何覆盖容器运行的命令。
- en: Overriding the default commands run by the containers
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖容器运行的默认命令
- en: Overriding default commands is important in multi-container Pods because it
    lets you control each container’s behavior individually. This means you can customize
    how each container works within the Pod. For example, a web server container might
    normally run a `start server` command, but you could override a sidecar container’s
    command to handle logging instead. This approach can also help with resource management.
    If a container usually runs a heavy process, you can change it to a lighter one
    in the Pod to ensure other containers have enough resources. Finally, it helps
    with managing dependencies. For instance, a database container might typically
    start right away, but you could override its command to wait until a related application
    container is ready.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在多容器 Pod 中，覆盖默认命令非常重要，因为它可以让您单独控制每个容器的行为。这意味着您可以定制 Pod 中每个容器的工作方式。例如，一个 Web
    服务器容器通常会运行 `start server` 命令，但您可以覆盖旁车容器的命令，使其处理日志记录。此方法还可以帮助资源管理。如果一个容器通常运行一个资源密集型的进程，您可以将其更换为一个更轻的进程，从而确保其他容器有足够的资源。最后，这有助于依赖关系管理。例如，一个数据库容器可能通常会立即启动，但您可以覆盖它的命令，直到相关的应用容器准备好为止。
- en: 'When using Docker, you have the opportunity to write files called `Dockerfiles`
    to build container images. `Dockerfiles` make use of two keywords to tell us what
    commands and arguments the containers that were built with this image will launch
    when they’re created using the `docker run` command. These two keywords are `ENTRYPOINT`
    and `CMD`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 时，您可以编写名为 `Dockerfile` 的文件来构建容器镜像。`Dockerfile` 使用两个关键字来告诉我们，当通过 `docker
    run` 命令创建容器时，使用此镜像构建的容器将启动哪些命令和参数。这两个关键字是 `ENTRYPOINT` 和 `CMD`：
- en: '`ENTRYPOINT` is the main command the container will launch.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 是容器将要启动的主命令。'
- en: '`CMD` is used to replace the parameters that are passed to the `ENTRYPOINT`
    command.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD` 用于替换传递给 `ENTRYPOINT` 命令的参数。'
- en: 'For example, a classic `Dockerfile` that should be launched to run the `sleep`
    command for `30` seconds would be written like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个经典的 `Dockerfile`，应当启动并运行 `sleep` 命令 30 秒，代码如下：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Containerfile and Podman**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Containerfile 和 Podman**'
- en: A Containerfile acts as a recipe for building a container image similar to Dockerfiles.
    It contains a series of instructions specifying the operating system, installing
    dependencies, copying application code, and configuring settings. Podman, a tool
    similar to Docker, can interpret this Containerfile and construct the image based
    on the instructions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Containerfile 就像 Dockerfile 一样，是构建容器镜像的配方。它包含一系列指令，指定操作系统、安装依赖项、复制应用程序代码和配置设置。Podman
    是一个类似于 Docker 的工具，它可以解析此 Containerfile 并根据指令构建镜像。
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Thanks to the `CMD` instruction, you can override the default `30` seconds
    like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `CMD` 指令，您可以覆盖默认的 30 秒，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Kubernetes, on the other hand, allows us to override both `ENTRYPOINT` and
    `CMD` thanks to YAML Pod definition files. To do so, you must append two optional
    keys to your YAML configuration file: `command` and `args`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Kubernetes 允许我们通过 YAML Pod 定义文件来覆盖 `ENTRYPOINT` 和 `CMD`。为此，您需要在 YAML 配置文件中添加两个可选键：`command`
    和 `args`。
- en: This is a very big benefit that Kubernetes brings you because you can decide
    to append arguments to the command that’s run by your container’s `Dockerfile`,
    just like the `CMD` arguments do with bare Docker, or completely override `ENTRYPOINT`!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kubernetes 带来的一个非常大的好处，因为您可以决定向容器的 `Dockerfile` 运行命令附加参数，就像裸 Docker 中的 `CMD`
    参数一样，或者完全覆盖 `ENTRYPOINT`！
- en: 'Here, we are going to write a new manifest file that will override the default
    `ENTRYPOINT` and `CMD` parameters of the `busybox` image to make the `busybox`
    container sleep for 60 seconds. Here is how to proceed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个新的清单文件，覆盖 `busybox` 镜像的默认 `ENTRYPOINT` 和 `CMD` 参数，使得 `busybox` 容器休眠
    60 秒。操作步骤如下：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a bit tricky to understand because what `Dockerfile` calls `ENTRYPOINT`
    corresponds to the `command` argument in the YAML manifest file, and what `Dockerfile`
    calls `CMD` corresponds to the `args` configuration key in the YAML manifest file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难理解，因为 `Dockerfile` 中的 `ENTRYPOINT` 对应 YAML 清单文件中的 `command` 参数，而 `Dockerfile`
    中的 `CMD` 对应 YAML 清单文件中的 `args` 配置项。
- en: What if you omit one of them? Kubernetes will default to what is inside the
    container image. If you omit the `args` key in the YAML, then Kubernetes will
    go for the `CMD` provided in the `Dockerfile`, while if you omit the `command`
    key, Kubernetes will go for the `ENTRYPOINT` declared in the `Dockerfile`. Most
    of the time, or at least if you’re comfortable with your container’s `ENTRYPOINT`,
    you’re just going to override the `args` file (the `CMD Dockerfile` instruction).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遗漏其中之一会怎样？Kubernetes 会默认使用容器镜像中的内容。如果你在 YAML 中省略了 `args` 键，Kubernetes 会使用
    `Dockerfile` 中提供的 `CMD`，而如果你省略了 `command` 键，Kubernetes 会使用 `Dockerfile` 中声明的 `ENTRYPOINT`。大多数情况下，或者至少当你对容器的
    `ENTRYPOINT` 感到满意时，你只需要覆盖 `args` 文件（`CMD Dockerfile` 指令）。
- en: 'When we create the Pod, we can check the output as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 Pod 时，我们可以查看输出，如下所示：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Therefore, overriding default commands offers granular control over container
    behavior within multi-container Pods. This enables tailored functionality, resource
    optimization, and dependency management for seamless Pod operation. In this section,
    we learned that Kubernetes allows overriding defaults through the `command` and
    `args` fields in Pod YAML definitions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，覆盖默认命令为多容器 Pod 中的容器行为提供了更精细的控制。这使得在 Pod 操作中能够实现量身定制的功能、资源优化和依赖管理。在本节中，我们了解到
    Kubernetes 允许通过 Pod YAML 定义中的`command`和`args`字段来覆盖默认值。
- en: 'Now, let’s look at another feature: `initContainers`! In the next section,
    you’ll see another way to execute some additional side containers in your Pod
    to configure the main ones.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下另一个功能：`initContainers`！在下一节中，你将看到另一种方式，来在 Pod 中执行一些额外的侧容器以配置主容器。
- en: Introducing initContainers
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 initContainers
- en: '`initContainers` is a feature provided by Kubernetes Pods to run setup scripts
    before the actual containers start. You can think of them as additional side containers
    you can define in your Pod YAML manifest file: they will first run when the Pod
    is created. Then, once they complete, the Pod starts creating its main containers.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`initContainers`是 Kubernetes Pods 提供的一项功能，用于在实际容器启动之前运行设置脚本。你可以将它们看作是你可以在 Pod
    YAML 清单文件中定义的额外侧容器：它们会在 Pod 创建时首先运行。然后，一旦它们完成，Pod 开始创建其主容器。'
- en: 'You can execute not one but several `initContainers` in the same Pod, but when
    you define lots of them, keep in mind that they will run one after another, not
    in parallel. Once an `initContainer` completes, the next one starts, and so on.
    In general, `initContainers` are used for preparation tasks; some of them are
    outlined in the following list:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个 Pod 中执行不止一个 `initContainers`，但当你定义多个时，请记住它们会一个接一个地运行，而不是并行运行。一旦一个 `initContainer`
    完成，下一个就会开始，依此类推。一般来说，`initContainers` 用于准备工作；其中一些任务在以下列表中列出：
- en: '**Database initialization**: Set up and configure databases before the main
    application starts.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库初始化**：在主应用程序启动之前，设置并配置数据库。'
- en: '**Configuration file download**: Download essential configuration files from
    remote locations.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件下载**：从远程位置下载必要的配置文件。'
- en: '**Package installation**: Install dependencies required by the main application.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包安装**：安装主应用程序所需的依赖项。'
- en: '**Waiting for external service**: Ensure external services are available before
    starting the main container.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待外部服务**：在启动主容器之前，确保外部服务可用。'
- en: '**Running pre-checks**: Perform any necessary checks or validations before
    starting the main application.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行前检查**：在启动主应用程序之前，执行必要的检查或验证。'
- en: '**Secret management**: Download and inject secrets securely into the main container’s
    environment.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密管理**：安全地下载并注入机密到主容器的环境中。'
- en: '**Data migration**: Migrate data to a database or storage system before the
    main application starts.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据迁移**：在主应用程序启动之前，将数据迁移到数据库或存储系统。'
- en: '**Customizing file permissions**: Set appropriate file permissions for the
    main application.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义文件权限**：为主应用程序设置适当的文件权限。'
- en: 'Since `initContainers` can have their own container images. You can offload
    some configuration to them by keeping the main container images as small as possible,
    thus increasing the whole security of your setup by removing unnecessary tools
    from your main container images. Here is a YAML manifest that introduces an `initContainer`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `initContainers` 可以有自己的容器镜像，你可以通过保持主容器镜像尽可能小，来卸载一些配置，从而通过从主容器镜像中移除不必要的工具，增强整个设置的安全性。以下是一个引入
    `initContainer` 的 YAML 清单：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see from this YAML file, `initContainer` runs the BusyBox image,
    which will download the application (in this case, simple website content from
    [https://github.com/iamgini/website-demo-one-page](https://github.com/iamgini/website-demo-one-page))
    and copy the same application to a shared volume called `website-volume`. (You
    will learn about volumes and persistent storage in *Chapter 9*, *Persistent Storage
    in Kubernetes*, later in this book.) The same volume is also configured to mount
    under the NGINX container so that NGINX will use it as the default website content.
    Once the execution of `initContainer` is complete, Kubernetes will create the
    `nginx-container` container.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这个YAML文件中看到的，`initContainer`运行BusyBox镜像，它会下载应用程序（在此案例中为[https://github.com/iamgini/website-demo-one-page](https://github.com/iamgini/website-demo-one-page)中的简单网站内容），并将相同的应用程序复制到一个名为`website-volume`的共享卷中。（你将在*第9章*，*Kubernetes中的持久存储*中学习卷和持久存储。）同一个卷还被配置为挂载在NGINX容器下，以便NGINX使用它作为默认的网站内容。`initContainer`执行完毕后，Kubernetes将创建`nginx-container`容器。
- en: Keep in mind that if `initContainer` fails, Kubernetes won’t initiate the primary
    containers. It’s crucial not to perceive `initContainer` as an optional component
    or one that can afford to fail. If included in the YAML manifest file, they are
    mandatory and their failure prevents the launch of the main containers!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果`initContainer`失败，Kubernetes将不会启动主容器。重要的是不要把`initContainer`当作可选组件，或者认为它可以失败。如果在YAML清单文件中包含了它们，它们是必需的，而且它们的失败会阻止主容器的启动！
- en: 'Let’s create the Pod. After this, we will run the `kubectl get Pods -w` command
    for `kubectl` to watch for a change in the Pod list. The output of the command
    will be updated regularly, showing the change in the Pod’s status. Please take
    note of the `status` column, which says that an `initContainer` is running:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建Pod。创建后，我们将运行`kubectl get Pods -w`命令，以便`kubectl`可以监控Pod列表中的变化。该命令的输出将定期更新，显示Pod状态的变化。请注意`status`列，显示`initContainer`正在运行：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, `Init:0/1` indicates that `initContainer` is being launched.
    After its completion, the `Init:` prefix disappears for the next statuses, indicating
    that we are done with `initContainer` and that Kubernetes is now creating the
    main container – in our case, the NGINX one!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Init:0/1`表示`initContainer`正在启动。完成后，`Init:`前缀消失，显示下一个状态，表示我们已完成`initContainer`，Kubernetes现在正在创建主容器——在我们的例子中是NGINX容器！
- en: 'If you want to explore this further, you can expose the Pod with a NodePort
    service as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步探索，你可以通过以下方式使用NodePort服务暴露Pod：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, start a port forwarding service using `kubectl port-forward` command as
    follows so that we can access the service outside of the cluster:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`kubectl port-forward`命令启动端口转发服务，以便我们可以在集群外部访问该服务：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, access `http://localhost:8080` and you will see a one-page website with
    content copied from [https://github.com/iamgini/website-demo-one-page](https://github.com/iamgini/website-demo-one-page).
    We will learn about exposing services in *Chapter 8*, *Exposing Your Pods with
    Services*. Also remember to stop the port forward by pressing the *ctrl + c* to
    in your console before proceeding to the next section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问`http://localhost:8080`，你将看到一个一页式网站，内容来自于[https://github.com/iamgini/website-demo-one-page](https://github.com/iamgini/website-demo-one-page)。我们将在*第8章*，*通过服务暴露你的Pods*中学习如何暴露服务。并且在继续到下一部分之前，记得通过按下*ctrl
    + c*停止端口转发。
- en: Use `initContainer` wisely when you’re building your Pods! You are not forced
    to use `init` containers, but they can be really helpful for running configuration
    scripts or pulling something from external servers before you launch your actual
    containers!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Pods时，明智地使用`initContainer`！你不一定必须使用`init`容器，但它们在运行配置脚本或在启动实际容器之前从外部服务器拉取内容时非常有用！
- en: Now, let’s learn how to access the logs of a specific container inside a running
    Pod!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何访问正在运行的Pod中某个特定容器的日志！
- en: Accessing the logs of a specific container
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问特定容器的日志
- en: When using multiple containers in a single Pod, you can retrieve the logs of
    a dedicated container inside the Pod. The proper way to proceed is by using the
    `kubectl logs` command.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当在单个Pod中使用多个容器时，你可以检索Pod中某个专用容器的日志。正确的操作方式是使用`kubectl logs`命令。
- en: The most common way a containerized application exposes its logs is by sending
    them to `stdout`. The `kubectl logs` command is capable of streaming the `stdout`
    property of a dedicated container in a dedicated Pod and retrieving the application
    logs from the container. For it to work, you will need to know the name of both
    the precise container and its parent Pod, just like when we used `kubectl exec`
    to access a specific container.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化应用程序暴露日志的最常见方式是将日志发送到`stdout`。`kubectl logs`命令能够流式传输专门容器中`stdout`属性的内容，并从容器中检索应用程序日志。为了使其正常工作，你需要知道容器及其父Pod的精确名称，就像我们使用`kubectl
    exec`访问特定容器时一样。
- en: 'Please read the previous section, *Accessing a specific container inside a
    multi-container Pod*, to discover how to do this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读上一节，*访问多容器Pod中的特定容器*，了解如何执行此操作：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Please note the `--container` option (the `-c` short option works, too), which
    specifies the container you want to retrieve the logs for. Note that it also works
    the same for `initContainers`: you have to pass its name to this option to retrieve
    its logs.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`--container`选项（`-c`短选项也可以使用），它指定了你想要获取日志的容器。注意，这对于`initContainers`同样适用：你必须将其名称传递给此选项以检索其日志。
- en: Remember that if you do not pass the `--container` option, you will retrieve
    all the logs from all the containers that have been launched inside the Pod. Not
    passing this option is useful in the case of a single-container Pod, but you should
    consider this option every time you use a multi-container Pod.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你没有传递`--container`选项，你将检索Pod中所有容器的所有日志。如果Pod中只有一个容器，这时不传递该选项是有用的，但在使用多个容器的Pod时，你每次都应该考虑传递这个选项。
- en: 'There are other multiple useful options you need to be aware of when it comes
    to accessing the logs of a container in a Pod. You can decide to retrieve the
    logs written in the last two hours by using the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问Pod中容器日志时，还有其他一些有用的选项你需要了解。你可以通过以下命令来检索过去两小时内写入的日志：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, you can use the `--tail` option to retrieve the most recent lines of
    a log’s output. Here’s how to do this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以使用`--tail`选项来检索日志输出中最近的几行。以下是操作方法：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we are retrieving the 30 most recent lines in the log output of `nginx-container`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检索`nginx-container`日志输出中的30行最新内容。
- en: Now, you are ready to read and retrieve the logs from your Kubernetes Pods,
    regardless of whether they are made up of one or several containers!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好读取并检索Kubernetes Pod中的日志，无论它们由一个容器还是多个容器组成！
- en: In this section, we discovered how to create, update, and delete multi-container
    Pods. We also discovered how to force the deletion of a Pod. We then discovered
    how to access a specific container in a Pod, as well as how to retrieve the logs
    of a specific container in a Pod. Though we created an NGINX and a Debian container
    in our Pod, they are relatively poorly linked since they don’t do anything together.
    To remediate that, we will now learn how to deal with volumes so that we can share
    files between our two containers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建、更新和删除多容器Pod。我们还学习了如何强制删除Pod。然后我们发现了如何访问Pod中的特定容器，以及如何检索Pod中特定容器的日志。尽管我们在Pod中创建了NGINX和Debian容器，但它们之间的连接较弱，因为它们没有协同工作。为了改善这一点，我们将学习如何处理卷，以便在两个容器之间共享文件。
- en: Sharing volumes between containers in the same Pod
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在同一Pod中的容器之间共享卷
- en: 'In this section, we’ll learn what volumes are from a Kubernetes point of view
    and how to use them. Docker also has volumes, but they differ from Kubernetes
    volumes: they answer the same need but they are not the same.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从Kubernetes的角度了解卷是什么以及如何使用它们。Docker也有卷，但它们与Kubernetes卷不同：它们满足相同的需求，但并不相同。
- en: We will discover what Kubernetes volumes are, why they are useful, and how they
    can help us when it comes to Kubernetes volumes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解Kubernetes卷是什么，它们为什么有用，以及它们在处理Kubernetes卷时如何帮助我们。
- en: What are Kubernetes volumes?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Kubernetes卷？
- en: 'We are going to answer a simple problem. Our multi-container Pods are currently
    made up of two containers: an NGINX one and a Debian one. We are going to try
    sharing the log directory in the NGINX container with the Debian container by
    mounting the log directory of NGINX in the directory of the Debian container.
    This way, we will create a relationship between the two containers to have them
    share a directory.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解答一个简单的问题。我们的多容器 Pod 目前由两个容器组成：一个 NGINX 容器和一个 Debian 容器。我们将尝试通过将 NGINX 容器中的日志目录挂载到
    Debian 容器中的目录来共享日志目录。这样，我们将创建两个容器之间的关系，使它们共享一个目录。
- en: 'Kubernetes has two kinds of volumes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有两种类型的卷：
- en: Volumes, which we will discuss here.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷，这是我们将在这里讨论的内容。
- en: '`PersistentVolume`, which is a more advanced feature we will discuss later,
    in*Chapter 9*, *Persistent Storage in Kubernetes*.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistentVolume`，这是一个更高级的功能，我们将在*第 9 章*、*Kubernetes 中的持久存储*中讨论。'
- en: Keep in mind that these two are not the same. `PersistentVolume` is a resource
    of its own, whereas “volumes” is a Pod configuration. As the name suggests, `PersistentVolume`
    is persistent, whereas volumes are not supposed to be. But keep in mind that this
    is not always the case!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这两者并不相同。`PersistentVolume` 是一个独立的资源，而“卷”是 Pod 配置。顾名思义，`PersistentVolume`
    是持久的，而卷不应是持久的。但请记住，这并不总是如此！
- en: In straightforward terms, volumes in Kubernetes are intricately linked to the
    life cycle of a Pod. When you instantiate a Pod, you can define and connect volumes
    to the containers within it. Essentially, volumes represent storage tied to the
    existence of the Pod. Once the Pod is removed, any associated volumes are also
    deleted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，Kubernetes 中的卷与 Pod 的生命周期密切相关。当你实例化一个 Pod 时，可以定义并将卷连接到其中的容器。实质上，卷表示与 Pod
    存在性相关联的存储。一旦 Pod 被删除，任何关联的卷也会被删除。
- en: While volumes serve a broader range of purposes beyond this scenario, it’s worth
    noting that this description doesn’t universally apply. However, you can view
    volumes as an especially effective method for facilitating the sharing of directories
    and files among containers coexisting within a Pod.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管卷的用途远超这一场景，但需要注意的是，这一描述并不适用于所有情况。然而，你可以将卷视为一种特别有效的方式，用于促进同一 Pod 中多个容器之间共享目录和文件。
- en: Remember that volumes are bound to the Pod’s life cycle, not the container’s
    life cycle. If a container crashes, the volume will survive because if a container
    crashes, it won’t cause its parent Pod to crash, and thus, no volume will be deleted.
    So long as a Pod is alive, its volumes are, too.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，卷与 Pod 的生命周期绑定，而不是容器的生命周期。如果一个容器崩溃，卷会继续存在，因为容器崩溃不会导致其父 Pod 崩溃，因此不会删除任何卷。只要
    Pod 存活，其卷也会存在。
- en: Volumes are a core concept for managing data in containerized applications.
    They provide a way to persist data independent of the container’s life cycle.
    Kubernetes supports various volume types, including those mounted from the host
    file system, cloud providers, and network storage systems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 卷是管理容器化应用程序中数据的核心概念。它们提供了一种使数据独立于容器生命周期而持久化的方式。Kubernetes 支持各种类型的卷，包括从主机文件系统、云提供商和网络存储系统挂载的卷。
- en: 'However, Kubernetes expanded on this by introducing support for various drivers,
    enabling integration of Pod volumes with external solutions. For instance, an
    AWS EBS (Elastic Block Store) volume seamlessly serves as a Kubernetes volume.
    Some widely utilized solutions include the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kubernetes 通过引入对各种驱动程序的支持，扩展了这一点，使得 Pod 卷能够与外部解决方案进行集成。例如，AWS EBS（弹性块存储）卷可以无缝作为
    Kubernetes 卷。一些广泛使用的解决方案包括：
- en: '`hostPath`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostPath`'
- en: '`emptyDir`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyDir`'
- en: '`nfs`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nfs`'
- en: '`persistentVolumeClaim` (when you need to use a `PersistentVolume`, which is
    outside the scope of this chapter)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persistentVolumeClaim`（当你需要使用一个`PersistentVolume`，但这超出了本章的范围）'
- en: 'Please note that some of the old volume types are removed or deprecated in
    the latest Kubernetes version; refer to the documentation to learn more ([https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/)).
    Refer to the following list for examples:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最新的 Kubernetes 版本中，某些旧的卷类型已被移除或弃用；更多信息请参阅文档（[https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/)）。以下是一些示例：
- en: '`azureDisk` (removed)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azureDisk`（已移除）'
- en: '`gcePersistentDisk` (removed)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcePersistentDisk`（已移除）'
- en: '`glusterfs` (removed)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glusterfs`（已移除）'
- en: '`azureFile` (deprecated)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azureFile`（已弃用）'
- en: Please note that using external solutions to manage the Kubernetes volumes will
    require you to follow those external solutions’ requirements. For example, using
    an AWS EBS volume as a Kubernetes volume will require your Pods to be executed
    on a Kubernetes worker node, which would be an EC2 instance. The reason for this
    is that AWS EBS volumes can only be attached to EC2 instances. Thus, a Pod exploiting
    such a volume would need to be launched on an EC2 instance. Refer to [https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/)
    to learn more.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用外部解决方案来管理Kubernetes卷将要求您遵循这些外部解决方案的要求。例如，使用AWS EBS卷作为Kubernetes卷将要求您的Pod运行在Kubernetes工作节点上，这通常是一个EC2实例。原因在于AWS
    EBS卷只能附加到EC2实例。因此，利用此类卷的Pod需要在EC2实例上启动。有关更多信息，请参阅[https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/)。
- en: The following diagram shows the high-level idea about the `hostPath` and `emptyDir`
    volumes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了关于`hostPath`和`emptyDir`卷的高层次概念。
- en: '![](img/B22019_05_02.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_05_02.png)'
- en: 'Figure 5.2: hostPath and emptyDir volumes'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：hostPath和emptyDir卷
- en: 'We are going to discover the two basic volume drivers here: `emptyDir` and
    `hostPath`. We will also talk about `persistentVolumeClaim` because this one is
    going to be a little special in comparison to the other volumes and will be fully
    discovered in *Chapter 9*, *Persistent Storage in Kubernetes*.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里介绍两种基本的卷驱动器：`emptyDir`和`hostPath`。我们还将讨论`persistentVolumeClaim`，因为与其他卷相比，它有些特殊，并将在*第9章*《Kubernetes中的持久存储》中进行全面介绍。
- en: Now, let’s start discovering how to share files between containers in the same
    Pod using volumes with the `emptyDir` volume type!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始发现如何在同一个Pod中的容器之间使用`emptyDir`卷类型共享文件！
- en: Creating and mounting an emptyDir volume
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并挂载一个emptyDir卷
- en: As the name suggests, it is simply an empty directory that is initialized at
    Pod creation that you can mount to the location of each container running in the
    Pod.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，它只是一个在Pod创建时初始化的空目录，你可以将其挂载到Pod中每个容器的位置。
- en: It is certainly the easiest and simplest way to have your containers share data
    between them. Let’s create a Pod that will manage two containers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是最简单和最直接的方式，让你的容器之间共享数据。让我们创建一个Pod来管理两个容器。
- en: In the following example, we are creating a Pod that will launch two containers,
    and just like we had previously, it’s going to be an NGINX container and a Debian
    container. We are going to override the command that’s run by the Debian container
    when it starts to prevent it from completing. That way, we will get it running
    indefinitely as a long process and we will be able to launch additional commands
    to check whether our `emptyDir` has been initialized correctly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个Pod，该Pod将启动两个容器，和之前一样，它将是一个NGINX容器和一个Debian容器。我们将覆盖Debian容器启动时执行的命令，以防止它完成。通过这种方式，我们将让它作为一个长时间运行的进程持续运行，并能够启动额外的命令来检查我们的`emptyDir`是否已正确初始化。
- en: 'Both containers will have a common volume mounted at `/var/i-am-empty-dir-volume/`,
    which will be our `emptyDir` volume, initialized in the same Pod. Here is the
    YAML file for creating the Pod:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 两个容器将有一个共同的卷挂载在`/var/i-am-empty-dir-volume/`，这个就是我们的`emptyDir`卷，它在同一个Pod中初始化。以下是创建Pod的YAML文件：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the object we will create in our Kubernetes cluster will become more
    complex as we go through this example, and, as you can imagine, most complex things
    cannot be achieved with just imperative commands. That’s why you are going to
    see more and more examples relying on the YAML manifest file: you should start
    a habit of trying to read them to figure out what they do.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在Kubernetes集群中创建的对象会随着本示例的进行而变得更加复杂，正如你想象的那样，大多数复杂的事情无法仅通过命令式命令来实现。这就是为什么你会看到越来越多的示例依赖于YAML清单文件的原因：你应该养成尝试阅读它们以弄清楚它们所做的事情的习惯。
- en: 'We can now apply the manifest file using the following `kubectl apply -f` command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下`kubectl apply -f`命令来应用清单文件：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can check that the Pod is successfully running by issuing the `kubectl
    get Pods` command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行`kubectl get Pods`命令来检查Pod是否成功运行：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we are sure the Pod is running and that both the NGINX and Debian containers
    have been launched, we can check that the directory can be accessed in both containers
    by issuing the `ls` command.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确认Pod正在运行，并且NGINX和Debian容器都已启动，我们可以通过执行`ls`命令来检查在两个容器中是否可以访问该目录。
- en: 'If the command is not failing, as we saw previously, we can run the `ls` command
    in the containers by simply running the `kubectl exec` command. As you may recall,
    the command takes the Pod’s name and the container’s name as arguments. We are
    going to run it twice to make sure the volume is mounted in both containers:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令没有失败，正如我们之前看到的，我们可以通过运行 `kubectl exec` 命令在容器中执行 `ls` 命令。正如你记得的，命令需要 Pod
    的名称和容器的名称作为参数。我们将执行两次，以确保卷在两个容器中都已挂载：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the `ls /var` command is showing the name in both containers!
    This means that `emptyDir` was initialized and mounted in both containers correctly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`ls /var` 命令显示了两个容器中的文件名！这意味着 `emptyDir` 已经初始化并正确地挂载到两个容器中。
- en: Now, let’s create a file in one of the two containers. The file should be immediately
    visible in the other container, proving that the volume mount is working properly!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在两个容器中的其中一个创建一个文件。该文件应该立即在另一个容器中可见，证明卷挂载正常工作！
- en: 'In the following command, we are simply creating a `.txt` file called `hello-world.txt`
    in the mounted directory:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下命令中，我们只是简单地在挂载目录中创建一个名为 `hello-world.txt` 的 `.txt` 文件：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, we used `debian-container` to create the `/var/i-am-empty-dir-volume/hello-world.txt`
    file, which contains the `hello-world` string. Then, we simply used the `cat`
    command to access the file from both containers; you can see that the file is
    accessible in both cases. Again, remember that `emptyDir` volumes are completely
    tied to the life cycle of the Pod. If the Pod declares it is destroyed, then the
    volume is destroyed, too, along with all its content, and it will become impossible
    to recover!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `debian-container` 创建了 `/var/i-am-empty-dir-volume/hello-world.txt`
    文件，该文件包含了 `hello-world` 字符串。然后，我们只是使用 `cat` 命令从两个容器中访问该文件；你可以看到，在两种情况下，文件都可以访问。再次提醒，记住
    `emptyDir` 卷完全与 Pod 的生命周期绑定。如果 Pod 声明已销毁，那么卷也会被销毁，所有内容也会丢失，并且将无法恢复！
- en: 'Now, we will discover another volume type: the `hostPath` volume. As you can
    imagine, it’s going to be a directory that you can mount on your containers that
    is backed by a path on the host machine – the Kubernetes node running the Pod!'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍另一种卷类型：`hostPath` 卷。正如你所想，它将是一个目录，你可以将其挂载到容器上，该目录由宿主机上的路径支持——也就是运行 Pod
    的 Kubernetes 节点！
- en: Creating and mounting a hostPath volume
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并挂载一个 `hostPath` 卷
- en: 'As the name suggests, hostPath will allow you to mount a directory in the host
    machine to containers in your Pod! The host machine is the Kubernetes compute
    node (or controller node) executing the Pod. Here are some examples:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，hostPath 允许你将宿主机上的目录挂载到 Pod 中的容器上！宿主机是执行 Pod 的 Kubernetes 计算节点（或控制节点）。以下是一些示例：
- en: If your cluster is based on minikube (a single-node cluster), the host is your
    local machine.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的集群是基于 minikube（一个单节点集群），那么宿主机就是你的本地机器。
- en: On Amazon EKS, the host machine will be an EC2 instance.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Amazon EKS 上，宿主机将是一个 EC2 实例。
- en: In a `kubeadm` cluster, the host machine is generally a standard Linux machine.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `kubeadm` 集群中，宿主机通常是一个标准的 Linux 机器。
- en: The host machine is the machine running the Pod, and you can mount a directory
    from the file system of the host machine to the Kubernetes Pod!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 宿主机是运行 Pod 的机器，你可以将宿主机文件系统中的目录挂载到 Kubernetes Pod 中！
- en: In the following example, we will be working on a Kubernetes cluster based on
    minikube, so `hostPath` will be a directory that’s been created on your computer
    that will then be mounted in a Kubernetes Pod.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将在基于 minikube 的 Kubernetes 集群上进行操作，因此 `hostPath` 将是你在电脑上创建的目录，然后将其挂载到
    Kubernetes Pod 中。
- en: Using the `hostPath` volume type can be useful, but in the Kubernetes world,
    you can consider it an anti-pattern. The `hostPath` volume type, while convenient,
    is discouraged in Kubernetes due to reduced portability and potential security
    risks. It can also be incompatible with advanced security features like SELinux
    **multi-category security** (**MCS**), now supported by many Kubernetes distributions.
    For a more portable, secure, and future-proof approach, leverage **persistent
    volumes** (**PVs**) and **persistent volume claims** (**PVCs**) to manage persistent
    data within your containerized applications.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `hostPath` 卷类型可能会有用，但在 Kubernetes 的世界中，它可以被认为是一种反模式。虽然 `hostPath` 卷类型很方便，但由于其可移植性差和潜在的安全风险，它在
    Kubernetes 中是不推荐使用的。它也可能与像 SELinux **多类别安全** (**MCS**) 等高级安全功能不兼容，而这类功能现在已被许多
    Kubernetes 发行版支持。为了实现更具可移植性、安全性和未来兼容性的解决方案，建议使用 **持久化卷** (**PVs**) 和 **持久化卷声明**
    (**PVCs**) 来管理容器化应用中的持久数据。
- en: The whole idea behind Pods is that they are supposed to be easy to delete and
    reschedule on another worker node without problems. Using `hostPath` will create
    a tight relationship between the Pod and the worker node, and that could lead
    to major issues if your Pod were to fail and be rescheduled on a node where the
    required path on the host machine is not present.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 的整体理念是，它们应该能够轻松删除并重新调度到另一个工作节点上而不产生问题。使用`hostPath`会在 Pod 和工作节点之间创建紧密的关系，如果你的
    Pod 失败并被重新调度到一个主机上没有所需路径的节点，可能会导致重大问题。
- en: Now, let’s discover how to create `hostPath`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何创建 `hostPath`。
- en: Let’s imagine that we have a file on the worker node on `worker-node/nginx.conf`
    and we want to mount it on `/var/config/nginx.conf` on the `nginx` container.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在工作节点上的 `worker-node/nginx.conf` 有一个文件，我们希望将它挂载到 `nginx` 容器的 `/var/config/nginx.conf`
    中。
- en: 'Here is the YAML file to create the setup. As you can see, we declared a `hostPath`
    volume at the bottom of the file that defines a path that should be present on
    the host machine. Now, we can mount it on any container that needs to deal with
    the volume in the `containers` block:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于创建该设置的 YAML 文件。如你所见，我们在文件底部声明了一个 `hostPath` 卷，定义了应存在于主机上的路径。现在，我们可以将它挂载到任何需要处理该卷的容器上，位于
    `containers` 块中：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, mounting the value is just like what we did with the `emptyDir`
    volume in the previous section regarding the `emptyDir` volume type. By using
    a combination of volumes at the Pod level and `volumeMounts` at the container
    level, you can mount a volume on your containers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，挂载该值就像我们在上一节中使用 `emptyDir` 卷类型时所做的那样。通过在 Pod 级别使用卷组合，并在容器级别使用 `volumeMounts`，你可以在容器上挂载卷。
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also mount the directory on the Debian container so that it gets access
    to the directory on the host.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将目录挂载到 Debian 容器中，以便它能够访问主机上的目录。
- en: 'Before running the YAML manifest file, though, you need to create the path
    on your host and create the necessary file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 YAML 清单文件之前，你需要在主机上创建路径并创建必要的文件：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you are using a minikube cluster, remember to do this step inside the minikube
    VM as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 minikube 集群，请记住在 minikube 虚拟机中执行此步骤，具体如下：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If your minikube cluster is created using Podman containers (e.g., `minikube
    start --profile cluster2-podman --driver=podman`), then log in to the minikube
    Pod and create the file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 minikube 集群是使用 Podman 容器创建的（例如，`minikube start --profile cluster2-podman
    --driver=podman`），那么请登录到 minikube Pod 中并创建该文件：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that the path exists on the host machine, we can apply the YAML file to
    our Kubernetes cluster and, immediately after, launch a `kubectl get Pod` command
    to check that the Pod was created correctly:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 既然路径已经在主机上存在，我们可以将 YAML 文件应用到我们的 Kubernetes 集群中，并在之后立即运行`kubectl get Pod`命令来检查
    Pod 是否已正确创建：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Everything seems good! Now, let’s echo the file that should be mounted at `/foo/hello-world.txt`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好！现在，让我们输出应挂载到`/foo/hello-world.txt`的文件：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can see the local file (on the Kubernetes node) is available inside the container
    via the hostPath volume mount.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到本地文件（在 Kubernetes 节点上）通过 `hostPath` 卷挂载可在容器内使用。
- en: At the beginning of this chapter, we discovered the different aspects of multi-container
    Pods! We discovered how to create, update, and delete multi-container Pods, as
    well as how to use `initContainers`, access logs, override command-line arguments
    passed to containers directly from the Pod’s resources, and share directories
    between containers using the two basic volumes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始部分，我们发现了多容器 Pods 的不同方面！我们了解到如何创建、更新和删除多容器 Pods，以及如何使用 `initContainers`、访问日志、重写通过
    Pod 资源直接传递给容器的命令行参数，并使用两个基本卷在容器之间共享目录。
- en: Now, we are going to put a few architecting principles together and discover
    some notions related to multi-container Pods called “patterns.”
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将结合一些架构原则，并探索与多容器 Pods 相关的一些概念，称为“模式”。
- en: The ambassador design pattern
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使者设计模式
- en: When designing a multi-container Pod, you can decide to follow some architectural
    principles to build your Pod. Some typical needs are answered by these design
    principles, and the ambassador pattern is one of them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设计多容器 Pod 时，你可以决定遵循一些架构原则来构建你的 Pod。这些设计原则回答了某些典型需求，其中使者模式就是其中之一。
- en: Here, we are going to discover what the ambassador design pattern is, learn
    how to build an ambassador container in Kubernetes Pods, and look at a concrete
    example of them.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探索什么是使者设计模式，学习如何在 Kubernetes Pods 中构建使者容器，并查看它们的具体示例。
- en: What is the ambassador design pattern?
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Ambassador 设计模式？
- en: 'In essence, the ambassador design pattern applies to multi-container Pods.
    We can define two containers in the same Pod:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，Ambassador 设计模式适用于多容器 Pod。我们可以在同一个 Pod 中定义两个容器：
- en: The first container will be called the main container.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个容器将被称为主容器。
- en: The other container will be called the ambassador container.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个容器将被称为 Ambassador 容器。
- en: In this design pattern, we assume that the main container might have to access
    external services to communicate with them. For example, you can have an application
    that must interact with an SQL database that is living outside of your Pod, and
    you need to reach this database to retrieve data from it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计模式中，我们假设主容器可能需要访问外部服务进行通信。例如，你可能有一个应用程序，必须与位于 Pod 外部的 SQL 数据库进行交互，并且你需要访问这个数据库以从中检索数据。
- en: '![](img/B22019_05_03.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_05_03.png)'
- en: 'Figure 5.3: Ambassador design pattern in Kubernetes'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：Kubernetes 中的 Ambassador 设计模式
- en: This is the typical use case where you can deploy an adapter container alongside
    the main container, next to it, in the same Pod. The whole idea is to get the
    ambassador container to proxy the requests run by the main container to the database
    server.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的用例，你可以在主容器旁边部署一个适配器容器，两个容器位于同一个 Pod 中。整体思路是让 Ambassador 容器充当代理，将主容器发出的请求转发到数据库服务器。
- en: In this case, the ambassador container will be essentially an SQL proxy. Every
    time the main container wants to access the database, it won’t access it directly
    but rather create a connection to the ambassador container that will play the
    role of a proxy.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Ambassador 容器实际上将充当 SQL 代理。每当主容器想要访问数据库时，它不会直接访问，而是会创建与 Ambassador 容器的连接，后者将充当代理角色。
- en: Running an ambassador container is fine, but only if the external API is not
    living in the same Kubernetes cluster. To run requests on another Pod, Kubernetes
    provides strong mechanics called Services. We will have the opportunity to discover
    them in *Chapter 8*, *Exposing Your Pods with Services*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Ambassador 容器是可以的，但前提是外部 API 不在同一 Kubernetes 集群中。要在另一个 Pod 上运行请求，Kubernetes
    提供了强大的机制，称为服务（Services）。我们将在*第 8 章*，*通过服务暴露 Pod* 中有机会了解它们。
- en: 'But why would you need a proxy to access external databases? Here are some
    concrete benefits this design pattern can bring you:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么你需要通过代理访问外部数据库呢？以下是这种设计模式能为你带来的具体好处：
- en: Offloading SQL configuration
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载 SQL 配置
- en: Management of **Secure Sockets Layer**/**Transport Layer Security** (**SSL**/**TLS**)
    certificates
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全套接层**/**传输层安全**（**SSL**/**TLS**）证书的管理'
- en: Please note that having an ambassador proxy is not limited to an SQL proxy but
    this example is demonstrative of what this design pattern can bring you. Note
    that the ambassador proxy is only supposed to be called for outbound connections
    from your main container to something else, such as data storage or an external
    API. It should not be seen as an entry point to your cluster! Now, let’s quickly
    discover how to create an ambassador SQL proxy with a YAML file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，拥有 Ambassador 代理并不限于 SQL 代理，这个示例仅展示了这种设计模式能为你带来的好处。请注意，Ambassador 代理仅用于从主容器到其他地方（如数据存储或外部
    API）的出站连接，不能视为进入集群的入口点！现在，让我们快速了解如何通过 YAML 文件创建一个 Ambassador SQL 代理。
- en: Ambassador multi-container Pod – an example
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ambassador 多容器 Pod —— 一个示例
- en: 'Now that we know about ambassador containers, let’s learn how to create one
    with Kubernetes. The following YAML manifest file creates a Pod that creates two
    containers:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 Ambassador 容器，让我们学习如何通过 Kubernetes 创建一个。以下 YAML 清单文件创建一个 Pod，其中创建了两个容器：
- en: '`nginx-app`, derived from the `nginx:latest` image'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx-app`，基于 `nginx:latest` 镜像'
- en: '`sql-ambassador-proxy`, created from the `mysql-proxy:latest` container image'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql-ambassador-proxy`，基于 `mysql-proxy:latest` 容器镜像创建'
- en: The following example is only to demonstrate the concept of the ambassador SQL
    proxy. If you want to test the full functionality, you should have a working AWS
    **RDS** (**Relational Database Service**) instance reachable from your Kubernetes
    cluster and a proper application to test the database operations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例仅用于展示 Ambassador SQL 代理的概念。如果你想测试完整功能，你应该有一个可以从 Kubernetes 集群访问的 AWS **RDS**（**关系数据库服务**）实例，并有一个合适的应用程序来测试数据库操作。
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can imagine, it’s going to be the developer’s job to get the application
    code running in the NGINX container to query the ambassador instead of the Amazon
    RDS endpoint. As the ambassador container can be configured from environment variables,
    it’s going to be easy for you to just input the configuration variables in `ambassador-container`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，开发者的工作是让NGINX容器中的应用代码查询使者，而不是查询Amazon RDS端点。由于使者容器可以通过环境变量进行配置，所以你可以轻松地将配置变量输入到`ambassador-container`中。
- en: Do not get tricked by the order of the containers in the YAML file. The fact
    that the ambassador container appears first does not make it the *main* container
    of the Pod. This notion of the *main* container does not exist at all from a Kubernetes
    perspective – both are plain containers that run in parallel with no concept of
    a hierarchy between them. Here, we just access the Pod from the NGINX container,
    which makes it the most important one.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被YAML文件中容器的顺序所迷惑。使者容器出现得较早，并不意味着它是Pod中的*主*容器。从Kubernetes的角度来看，*主*容器这个概念根本不存在——这两个容器是平行运行的容器，它们之间没有层级关系。在这里，我们只是通过NGINX容器来访问Pod，这使得NGINX容器成为最重要的容器。
- en: Remember that the ambassador running in the same Pod as the NGINX container
    makes it accessible from NGINX on `localhost:3306.`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，和NGINX容器在同一个Pod中运行的使者容器使得它可以通过`localhost:3306`从NGINX访问。
- en: In the next section, we will learn about the sidecar pattern, another important
    concept in multi-container Pods.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习侧车模式，这是多容器Pod中的另一个重要概念。
- en: The sidecar design pattern
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧车设计模式
- en: The sidecar design pattern is good when you want to extend the features of your
    main container with features it would normally not be able to achieve on its own.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 侧车设计模式适用于当你想扩展主容器的功能，而这些功能是主容器本身通常无法实现的。
- en: Just like we did for the ambassador container, we’re going to explain exactly
    what the sidecar design pattern is by covering some examples.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为使者容器做的那样，我们将通过一些示例来详细解释侧车设计模式到底是什么。
- en: What is the sidecar design pattern?
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是侧车设计模式？
- en: Think of the sidecar container as an extension or a helper for your main container.
    Its main purpose is to extend the main container to bring it a new feature, but
    without changing anything about it. Unlike the ambassador design pattern, the
    main container may even not be aware of the presence of a sidecar.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将侧车容器视为主容器的扩展或助手。它的主要作用是扩展主容器，为其带来新的功能，但不改变主容器本身。与使者设计模式不同，主容器甚至可能不知道有一个侧车的存在。
- en: 'Just like the ambassador design pattern, the sidecar design pattern makes use
    of a minimum of two containers:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使者设计模式一样，侧车设计模式至少需要两个容器：
- en: The main container – the one that is running the application
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主容器——运行应用程序的容器。
- en: The sidecar container – the one that is bringing something additional to the
    first one
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧车容器——就是那个给第一个容器带来额外功能的容器。
- en: You may have already guessed, but this pattern is especially useful when you
    want to run monitoring or log forwarder agents. The following figure shows a simple
    sidecar design with a main app container and a sidecar container to collect the
    application logs.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，但这种模式在你想运行监控或日志转发代理时特别有用。下图展示了一个简单的侧车设计，包含一个主应用容器和一个收集应用日志的侧车容器。
- en: '![](img/B22019_05_04.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_05_04.png)'
- en: 'Figure 5.4: Sidecar design pattern in Kubernetes'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：Kubernetes中的侧车设计模式
- en: 'There are three things to understand when you want to build a sidecar that
    is going to forward your logs to another location:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想构建一个侧车来将日志转发到另一个位置时，有三件事需要理解：
- en: You must locate the directory where your main containers write their data (e.g.,
    logs).
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须找到主容器写入数据的目录（例如，日志）。
- en: You must create a volume to make this directory accessible to the sidecar container
    (e.g., a log forwarder sidecar).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须创建一个卷，使得这个目录对侧车容器可访问（例如，日志转发侧车）。
- en: You must launch the sidecar container with the proper configuration.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须以正确的配置启动侧车容器。
- en: Based on these concepts, the main container remains unchanged, and even if the
    sidecar fails, it wouldn’t have an impact on the main container, which could continue
    to work.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些概念，主容器保持不变，即使侧车失败，也不会影响主容器，主容器仍然可以继续工作。
- en: When to use a Sidecar design pattern?
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么时候使用侧车设计模式？
- en: 'When considering the usage of sidecar containers, they prove particularly beneficial
    in the following scenarios:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑使用sidecar容器时，它们在以下场景中尤其有用：
- en: '**Network proxies**: Network proxies can be configured to initialize before
    other containers in the Pod, ensuring their services are available immediately.
    The Istio “Envoy” proxy is a great example of a sidecar container used as a proxy.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络代理**：可以配置网络代理在Pod中其他容器之前初始化，确保它们的服务能立即可用。Istio的“Envoy”代理就是作为代理使用的sidecar容器的一个很好的例子。'
- en: '**Enhanced logging**: Log collection sidecars can start early and persist until
    the Pod terminates, capturing logs reliably even in case of Pod crashes.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的日志记录**：日志收集sidecar可以尽早启动并持续运行，直到Pod终止，即使在Pod崩溃的情况下，也能可靠地捕获日志。'
- en: '**Jobs**: Sidecars can be deployed alongside Kubernetes Jobs without affecting
    Job completion. No additional configuration is required for sidecars to run within
    Jobs.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：Sidecar可以与Kubernetes Jobs一同部署，而不会影响任务的完成。sidecar在Jobs内运行不需要额外的配置。'
- en: '**Credential management**: Many third-party credential management platforms
    utilize sidecar Pods to inject and manage credentials within workloads. They can
    also facilitate secure credential rotation and revocation.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭证管理**：许多第三方凭证管理平台利用sidecar Pods在工作负载中注入并管理凭证。它们还可以促进安全的凭证轮换和撤销。'
- en: Sidecar multi-container Pod – an example
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sidecar 多容器 Pod – 示例
- en: 'Just like the ambassador design pattern, the sidecar makes use of multi-container
    Pods. We will define two containers in the same Pod as follows – an NGINX container,
    which acts as the application container, and a `Fluentd container`, which acts
    as the sidecar to collect the logs from the NGINX web server:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大使设计模式一样，sidecar利用多容器Pod。我们将在同一个Pod中定义两个容器，分别是NGINX容器（作为应用容器）和`Fluentd容器`（作为sidecar容器，用于收集NGINX
    web服务器的日志）：
- en: '[PRE44]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Please note, for the Fluentd to work properly, we need to pass the configuration
    via ConfigMap; a typical configuration can be found in the following code (you
    will learn more about ConfigMaps in *Chapter 7*, *Configuring your Pods using
    ConfigMaps and Secrets):*
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使Fluentd正常工作，我们需要通过ConfigMap传递配置；一个典型的配置可以在以下代码中找到（你将在*第7章*中学到更多关于ConfigMap的内容，*使用ConfigMap和Secrets配置你的Pods*）：
- en: '[PRE45]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Fluentd** is a popular open-source log collection and forwarding agent, often
    used as a sidecar container in Kubernetes deployments. It efficiently collects
    logs from various sources, parses them for structure, and forwards them to centralized
    logging platforms like Elasticsearch, Google Cloud Logging, or Amazon CloudWatch
    Logs. This allows for streamlined log management, improved observability, and
    easier analysis of application health and performance. While this example demonstrates
    sending logs to a dummy Elasticsearch server (e.g., `elastic.lab.example.com`),
    Fluentd offers flexibility to integrate with various external logging solutions
    depending on your specific needs.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fluentd**是一个流行的开源日志收集和转发代理，常作为Kubernetes部署中的sidecar容器使用。它高效地收集来自不同来源的日志，解析其结构，并将其转发到集中式日志平台，如Elasticsearch、Google
    Cloud Logging或Amazon CloudWatch Logs。这使得日志管理更加简洁，提升了可观察性，并且简化了应用程序健康状况和性能的分析。尽管这个示例展示了将日志发送到一个虚拟的Elasticsearch服务器（例如`elastic.lab.example.com`），Fluentd仍然提供灵活性，可以根据具体需求集成各种外部日志解决方案。'
- en: In the following section of this chapter, we will discuss the adapter design
    pattern.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一个部分，我们将讨论适配器设计模式。
- en: The adapter design pattern
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器设计模式
- en: As its name suggests, the adapter design pattern is going to *adapt* an entry
    from a source format to a target format.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名字所示，适配器设计模式将把源格式中的输入*适配*为目标格式。
- en: 'As with the ambassador and sidecar design patterns, this one expects that you
    run at least two containers:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与大使和sidecar设计模式一样，这种模式要求你至少运行两个容器：
- en: The first one is the main container.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是主容器。
- en: The second one is the adapter container.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是适配器容器。
- en: This design pattern is helpful and should be used whenever the main containers
    emit data in a format, A, that should be sent to another application that is expecting
    the data in another format, B. As the name suggests, the adapter container is
    here to *adapt*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式非常有用，当主容器以格式A发出数据，而另一个应用程序期望数据以格式B接收时，就应该使用这种模式。正如其名字所示，适配器容器的作用就是进行*适配*。
- en: Again, this design pattern is especially well suited for log or monitoring management.
    Imagine a Kubernetes cluster where you have dozens of applications running; they
    are writing logs in Apache format, which you need to convert into JSON so that
    they can be indexed by a search engine. This is exactly where the adapter design
    pattern comes into play. Running an adapter container next to the application
    containers will help you get these logs adapted to the source format before they
    are sent somewhere else.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这种设计模式特别适合日志或监控管理。想象一个Kubernetes集群，里面运行着几十个应用程序；它们以Apache格式写入日志，你需要将这些日志转换为JSON格式，以便可以被搜索引擎索引。这正是适配器设计模式发挥作用的地方。在应用程序容器旁边运行适配器容器可以帮助你在日志被发送到其他地方之前将其适配为源格式。
- en: Just like for the sidecar design pattern, this one can only work if both the
    containers in your Pod are accessing the same directory using volumes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在sidecar设计模式中一样，这种方法只有在Pod中的两个容器通过卷访问同一个目录时才有效。
- en: Adapter multi-container Pod – an example
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器多容器Pod – 示例
- en: In this example, we are going to use a Pod that uses an adapter container with
    a shared directory mounted as a Kubernetes volume.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个Pod，它使用适配器容器，并将共享目录作为Kubernetes卷进行挂载。
- en: '![](img/B22019_05_05.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_05_05.png)'
- en: 'Figure 5.5: Adapter design pattern in Kubernetes'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：Kubernetes中的适配器设计模式
- en: 'This Pod is going to run two containers:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Pod将运行两个容器：
- en: '`alpine-writer`: Main app container, which writes logs to `/var/log/app`.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpine-writer`：主应用容器，负责将日志写入`/var/log/app`。'
- en: '`log-adapter`: Adapter container, which will read the log and convert it to
    another format (e.g., append a `PROCESSED` string at the end of each log).'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log-adapter`：适配器容器，它将读取日志并将其转换为另一种格式（例如，在每条日志末尾添加`PROCESSED`字符串）。'
- en: 'The following YAML file contains the definition for an adapter multi-container
    Pod with multiple containers:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的YAML文件包含了适配器多容器Pod的定义，里面有多个容器：
- en: '[PRE46]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Apply the YAML and check the Pod status as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 应用YAML并检查Pod状态，如下所示：
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once the Pod is created, the logs will be generated, and we can verify the
    logs from both containers. The following command will display the logs by the
    `alpine-writer` container:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Pod创建完成，日志将被生成，我们可以从两个容器中验证日志。以下命令将显示由`alpine-writer`容器生成的日志：
- en: '[PRE48]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can also check the converted logs by using `log-adapter`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用`log-adapter`来检查转换后的日志：
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By using the adapter containers, it is possible to handle complex operations
    without modifying your original application containers.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用适配器容器，能够在不修改原始应用容器的情况下处理复杂的操作。
- en: Before we conclude the chapter, in the next section, let us learn about one
    more feature in Kubernetes related to multi-container Pods.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，在下一部分，我们将了解Kubernetes中与多容器Pod相关的另一个特性。
- en: Sidecars versus Kubernetes Native Sidecars
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sidecars与Kubernetes原生Sidecars
- en: Traditionally, sidecars in Kubernetes have been regular containers deployed
    alongside the main application in a Pod, as we learned in the previous sections.
    This approach offers additional functionalities but has limitations. For instance,
    sidecars might continue running even after the main application exits, wasting
    resources. Additionally, Kubernetes itself isn’t inherently aware of sidecars
    and their relationship with the primary application.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Kubernetes中的sidecar是与主应用程序一起部署在Pod中的常规容器，正如我们在前面部分所学的那样。这种方法提供了额外的功能，但也有局限性。例如，即使主应用程序退出，sidecar仍可能继续运行，浪费资源。此外，Kubernetes本身并不固有地了解sidecar及其与主应用程序的关系。
- en: 'To address these limitations, Kubernetes v1.28 introduced a new concept: native
    sidecars. These leverage existing `init` containers with special configurations.
    This allows you to define a `restartPolicy` for containers within the Pod’s `initContainers`
    section. These special sidecar containers can be independently started, stopped,
    or restarted without affecting the main application or other init containers,
    offering more granular control over their life cycle.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些限制，Kubernetes v1.28引入了一个新概念：原生sidecar。它们利用现有的`init`容器并进行特殊配置。这允许你为Pod的`initContainers`部分中的容器定义`restartPolicy`。这些特殊的sidecar容器可以独立启动、停止或重启，而不会影响主应用程序或其他初始化容器，从而提供对其生命周期的更细粒度控制。
- en: 'The following Deployment definition file explains how native sidecar containers
    can be configured in Kubernetes:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的Deployment定义文件解释了如何在Kubernetes中配置原生sidecar容器：
- en: '[PRE50]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This approach ensures synchronized startup and shutdown of the sidecar with
    the main container, optimizing resource usage. More importantly, Kubernetes gains
    awareness of the sidecar’s role in the Pod, potentially enabling future features
    for tighter integration.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保了侧车容器与主容器的同步启动和关闭，优化了资源的使用。更重要的是，Kubernetes 会意识到侧车在 Pod 中的角色，未来可能会启用更紧密集成的功能。
- en: By leveraging multi-container Pods with init containers, sidecars, and the adapter
    or ambassador patterns, Kubernetes empowers you to build complex applications
    as modular units. This streamlines deployments and promotes efficient resource
    utilization within your containerized environment.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用带有初始化容器、侧车容器以及适配器或代理模式的多容器 Pod，Kubernetes 使你能够将复杂的应用程序构建为模块化单元。这简化了部署，并促进了在容器化环境中高效的资源利用。
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was quite a long one, but you should now have a good understanding
    of what Pods are and how to use them, especially when it comes to managing multiple
    containers in the same Pod.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容较长，但你现在应该对 Pod 有了较为深入的理解，特别是在同一 Pod 中管理多个容器时。
- en: We recommend that you focus on mastering the declarative way of creating Kubernetes
    resources. As you have noticed in this chapter, the key to achieving the most
    complex things with Kubernetes resides in writing YAML files. One example is that
    you simply cannot easily create a multi-container Pod without writing YAML files.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你专注于掌握声明式的方式来创建 Kubernetes 资源。正如你在本章中所注意到的，使用 Kubernetes 实现最复杂的任务的关键就在于编写
    YAML 文件。举个例子，你根本无法轻松创建一个多容器的 Pod，而不编写 YAML 文件。
- en: 'This chapter complements the previous one: *Chapter 4*, *Running Your Containers
    in Kubernetes*. You need to understand that everything we will do with Kubernetes
    will be Pod management because everything in Kubernetes revolves around them.
    Keep in mind that containers are never created directly, but always through a
    Pod object, and that all the containers within the same Pod are created on the
    same Kubernetes node. If you understand that, then you can continue to the next
    chapter!'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对上一章的补充：*第4章*，*在 Kubernetes 中运行容器*。你需要明白的是，我们在 Kubernetes 中做的所有操作都与 Pod 管理相关，因为
    Kubernetes 中的一切都围绕着 Pod 进行。请记住，容器从不直接创建，而是总是通过 Pod 对象来创建，并且同一 Pod 中的所有容器都在同一 Kubernetes
    节点上创建。如果你理解这一点，那么你可以继续阅读下一章！
- en: In the next chapter, we’re going to cover another important aspect of Kubernetes
    called namespaces.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Kubernetes 的另一个重要方面——命名空间。
- en: Further reading
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'How Pods manage multiple containers: https://kubernetes.io/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过 Pod 管理多个容器：[https://kubernetes.io/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers](https://kubernetes.io/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers)
- en: 'Kubernetes volumes: [https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 存储卷：[https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/)
- en: 'Sidecar containers: [https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/](https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/
    )'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧车容器：[https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/](https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/)
- en: Join our community on Discord
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
- en: '![](img/QR_Code1190011064790816561.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1190011064790816561.png)'
