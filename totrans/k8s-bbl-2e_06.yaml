- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namespaces, Quotas, and Limits for Multi-Tenancy in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve learned about Kubernetes’ key concepts by launching objects into
    our clusters and observing their behavior. You may have noticed that, in the long
    run, it would be difficult to maintain a cleanly organized cluster. As your clusters
    grow, it will become more and more difficult to maintain the ever-increasing number
    of resources managed in your cluster. That’s when Kubernetes namespaces come into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about **namespaces**. They help us keep our clusters
    well organized by grouping our resources by application or environment. Kubernetes
    namespaces are another key aspect of Kubernetes management, and it’s really important
    to master them!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Kubernetes namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How namespaces impact your resources and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring ResourceQuota and Limits at the namespace level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Kubernetes cluster (local or cloud-based, but this is not important)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working `kubectl` CLI configured to communicate with the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not have these technical requirements, please read *Chapter 2*, *Kubernetes
    Architecture – from Container Images to Running Pods*, and *Chapter 3*, *Installing
    Your First Kubernetes Cluster*, to get them.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Kubernetes namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more applications you deploy on your Kubernetes clusters, the greater the
    need to keep your cluster resources organized. You can use labels and annotations
    to manage the objects within your cluster, but you can take organization further
    by using **namespaces**. Namespaces in Kubernetes allow you to logically isolate
    parts of your cluster, helping you manage resources more effectively. However,
    to enforce resource allocation and limits, additional objects like `ResourceQuotas`
    are required. Once namespaces have been created, you can launch Kubernetes objects
    such as Pods, which will only exist in that namespace. So all the operations that
    are run against the cluster with `kubectl` will be scoped to that individual namespace,
    where you can perform as many operations as possible while eliminating the risk
    of impacting resources that are in another namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by finding out what exactly namespaces are and why they were created.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced multi-cluster and multi-tenancy scenarios in Kubernetes, projects
    like **Capsule** ([https://capsule.clastix.io/](https://capsule.clastix.io/))
    and **HyperShift** ([https://github.com/openshift/hypershift](https://github.com/openshift/hypershift))
    offer robust solutions. Capsule enables secure, multi-tenant Kubernetes clusters
    by allowing different teams or tenants to manage their own isolated namespaces.
    HyperShift simplifies the management of multiple clusters by providing a lightweight
    and scalable approach to securely isolate and manage Kubernetes resources across
    different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the next section on the importance of namespaces in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of namespaces in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, namespaces in Kubernetes are a way to help the cluster
    administrator keep everything clean and organized, while providing resource isolation.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest Kubernetes clusters can run hundreds or even thousands of applications.
    When everything is deployed in the same namespace, it can become very complex
    to know which particular resource belongs to which application.
  prefs: []
  type: TYPE_NORMAL
- en: If, by misfortune, you update or modify the wrong resource, you might end up
    breaking an app running in your cluster. To resolve that, you can use labels and
    selectors, but even then, as the number of resources grows, managing the cluster
    will quickly become chaotic if you don’t start using namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: We learned the basics of creating namespaces in *Chapter 8*, *Exposing Your
    Pods with Services*, but we didn’t learn that in much detail. Let’s now learn
    in detail how the namespaces are used to keep everything clean and organized while
    providing resource isolation.
  prefs: []
  type: TYPE_NORMAL
- en: How namespaces are used to split resources into chunks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right after you’ve installed Kubernetes, when your cluster is brand new, it
    is created with a few namespaces for the cluster components. So even if you didn’t
    notice previously, you are already using namespaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The main concept is to deploy your Pods and other objects in Kubernetes while
    specifying a namespace of your preference. This practice helps to keep your cluster
    tidy and well structured. It’s worth noting that Kubernetes comes with a default
    namespace, which is used if you don’t specify one explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The following image illustrates the namespaces and isolation at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22019_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Kubernetes namespaces and resource isolation'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a broader sense, Kubernetes namespaces serve several purposes for administrators,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoping resource names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware allocation and consumption limitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions and access control with Role-Based Access Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We recommend that you create one namespace per microservice or application,
    and then deploy all the resources that belong to a microservice within its namespace.
    However, be aware that Kubernetes does not impose any specific rules on you. For
    example, you could decide to use namespaces in these ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Differentiating between environments**: For example, one namespace is for
    a production environment, and the other one is for a development environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Differentiating between the tiers**: One namespace is for databases, one
    is for application Pods, and another is for middleware deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the default namespace**: For the smallest clusters that only deploy
    a few resources, you can go for the simplest setup and just use one big default
    namespace, deploying everything into it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either way, keep in mind that even though two Pods are deployed in different
    namespaces and exposed through services, they can still interact and communicate
    with each other. Even though Kubernetes services are created in a given namespace,
    they’ll receive a **fully qualified domain name** (**FQDN**) that will be accessible
    on the whole cluster. So even if an application running on namespace A needs to
    interact with an application in namespace B, it will have to call the service
    exposing app B by its FQDN. You don’t need to worry about cross-namespace communication,
    as this is allowed by default and can be controlled via network policies.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn about the default namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding default namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most Kubernetes clusters are created with a few namespaces by default. You
    can list your namespaces using `kubectl get namespaces` (or `kubectl get ns`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, we are using a minikube cluster. By reading this command’s output,
    we can see that the cluster we are currently using was set up with the following
    namespaces from the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default`: Kubernetes automatically provides this namespace, allowing you to
    begin using your new cluster without the need to create one manually. This namespace
    has been the default location to create all your resources thus far and is also
    utilized as the default namespace when no other is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-public`: This namespace is accessible to all clients, including those
    without authentication. Primarily designated for cluster-wide purposes, it ensures
    certain resources are publicly visible and readable across an entire cluster.
    However, it’s important to note that the public aspect of this namespace is more
    of a convention than a strict requirement. Currently unused, you can safely leave
    it as is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-system`: This namespace is reserved for objects created by the Kubernetes
    system itself. It’s where Kubernetes deploys the necessary objects for its operation.
    In typical Kubernetes setups, essential components like `kube-scheduler` and `kube-apiserver`
    are deployed as Pods within this namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components are vital for the proper functioning of the Kubernetes cluster
    they serve. Therefore, it’s advisable to refrain from making changes to this namespace,
    as any alterations could potentially disrupt the cluster’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '`kube-node-lease`: The purpose of this namespace is to store Lease objects
    linked to individual nodes. These node leases enable the kubelet to transmit heartbeats,
    facilitating the detection of node failures by the control plane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on which Kubernetes distribution you use, the pre-existing set of
    namespaces can change. But most of the time, these namespaces will be created
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s leave this namespace aside for now because we are going to get to the
    heart of the matter and start creating namespaces. We will look at the impact
    that these can have on your Pods, particularly at the level of the DNS resolution
    of your services.
  prefs: []
  type: TYPE_NORMAL
- en: How namespaces impact your resources and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to create, update, and delete namespaces,
    as well as the impacts that namespaces have on services and Pods.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to create resources by specifying a custom namespace
    so that we don’t rely on the default one.
  prefs: []
  type: TYPE_NORMAL
- en: Listing namespaces inside your cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw this in the previous section, *Understanding default namespaces*, but
    in this section, we will learn how to list and explore the namespaces that have
    been created in your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that all the commands that make use of the `namespaces` resource
    `kind` can also use the `ns` alias to benefit from a shorter format.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the data of a specific namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Retrieving the data of a specific namespace can be achieved using the `kubectl
    describe` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `get` command and redirect the YAML format to a file to
    get the data from a specific namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that a namespace can be in one of two states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active**: The namespace is active; it can be used to place new objects into
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminating**: The namespace is being deleted, along with all its objects.
    It can’t be used to host new objects while in this status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s learn how to create a new namespace imperatively.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a namespace using imperative syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To imperatively create a namespace, you can use the `kubectl create namespaces`
    command by specifying the name of the namespace to create. Here, we are going
    to create a new namespace called `custom-ns`. Please notice that all the operations
    related to namespaces in `kubectl` can be written with the shorter `ns` alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The new namespace, called `custom-ns`, should now be created in your cluster.
    You can check it by running the `kubectl get` command once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the namespace has been created and is in the `Active` state.
    We can now place resources in it.
  prefs: []
  type: TYPE_NORMAL
- en: Please avoid naming your cluster with a name starting with the `kube-` prefix,
    as this is the terminology for Kubernetes’ objects and system namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to create another namespace using declarative syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a namespace using declarative syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s discover how to create a namespace using declarative syntax. As always,
    you must use a YAML (or JSON) file. Here is a basic YAML file to create a new
    namespace in your cluster. Please pay attention to the `kind: Namespace` in the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the definition using the `kubectl create` command, by defining the YAML
    file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have created two custom namespaces. The first one, which was created
    imperatively, is called `custom-ns`, while the second one, which was created declaratively,
    is called `custom-ns-2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to remove these two namespaces using `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can delete a namespace using `kubectl delete`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note this can also be achieved using declarative syntax. Let’s delete
    the `custom-ns-2` namespace that was created using the previous YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running this command will take the namespace out of the `Active` status; it
    will enter the `Terminating` status. Right after the command, the namespace will
    be unable to host new objects, and after a few moments, it should completely disappear
    from the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We have to warn you about using the `kubectl delete namespace` command, as it
    is extremely dangerous. Deleting a namespace is permanent and definitive. All
    the resources that were created in the namespace will be destroyed. If you need
    to use this command, be sure to have YAML files to recreate the destroyed resources
    and even the destroyed namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discover how to create resources inside a specific namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a resource inside a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code shows how to create an NGINX Pod by specifying a custom
    namespace. Here, we are going to recreate a new `custom-ns` namespace and launch
    an NGINX Pod in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the `-n` option, which, in its long form, is the `--namespace`
    option. This is used to enter the name of the namespace where you want to create
    the resource (or get the details from). This option is supported by all the `kind`
    resources that can be scoped in a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another command to demonstrate this. The following command will create
    a new `configmap` in the `custom-ns` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify a namespace when using declarative syntax. Here is how
    to create a Pod in a specific namespace with declarative syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the `namespace` key under the `metadata` section, just under the
    Pod’s name, which says to create the Pod in the `custom-ns` namespace. Now, we
    can apply this file using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should have a namespace called `custom-ns` that contains two
    `nginx` Pods, as well as a `configmap` called `configmap-custom-ns`.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re using namespaces, you should always specify the `-n` flag to target
    the specific namespace of your choosing. Otherwise, you might end up running operations
    in the wrong namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to list the resources inside specific namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Listing resources inside a specific namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to list the resources within a namespace, you must add the `-n`
    option, just like when creating a resource. Use the following command to list
    the Pods in the `custom-ns` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that the `nginx` Pod that we created earlier is present in
    the namespace. From now on, all the commands that target this particular Pod should
    contain the `-n custom-ns` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is that the Pod does not exist in the default namespace,
    and if you omit passing the `-n` option, then the default namespace will be requested.
    Let’s try to remove `-n custom-ns` from the `get` command. We will see that the
    `nginx` Pod is not here anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can also run the `get` `configmap` command to check whether `configmap`
    is listed in the output. As you can see, the behavior is the same as when trying
    to list Pods. If you omit the `-n` option, the list operation will run against
    the `default` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The most important point to remember from all that we have discussed so far
    in this section is to never forget to add the `-n` option when working on a cluster
    that has multiple namespaces. This little carelessness could waste your time because,
    if you forget it, everything you do will be done on the `default` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of passing the namespace information in the command line every time,
    it is possible to set it in the kubeconfig context. In the next section, we will
    learn how to set the working namespace in the current context of `kubeconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the current namespace using kubectl config set-context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to set your current namespace in some situations. For example,
    if you are working on a specific project and using a specific namespace for your
    application and other resources, then you can set the namespace context as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check if any namespace is configured in the context as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get the details of the application or apply configuration without
    mentioning the `-n <namespace>` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Running the `kubectl config` command and sub-commands will only trigger modification
    or read operations against the `~/.kube/config` file, which is the configuration
    file that `kubectl` uses.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re using the `kubectl config set-context` command, you’re just updating
    that file to make it point to another namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to switch between namespaces with `kubectl` is important, but before
    you run any write operations such as `kubectl delete` or `kubectl create`, make
    sure that you are in the correct namespace. Otherwise, you should continue to
    use the `-n` flag. As this switching operation might be executed a lot of times,
    Kubernetes users tend to create Linux aliases to make them easier to use. Do not
    hesitate to define a Linux alias if you think it can be useful to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can set an alias in your `~/.bashrc` file (assuming that you
    are using Linux or macOS) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And use this alias next time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But again, it is highly recommended to use the `-n namespace` option to avoid
    any accidents in Kubernetes operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue our chapter and hands-on tutorials, let’s set the namespace
    in context back to normal by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s discover how to list all the resources inside a specific namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the resources inside a specific namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to list all the resources in a specific namespace, there is a very
    useful command that you can use called `kubectl get all -n custom-ns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this command can help you retrieve all the resources that are
    created in the namespace specified in the `-n` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing how names are scoped within a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s important to understand that namespaces offer an additional advantage:
    defining the scope for the names of the resources they contain.'
  prefs: []
  type: TYPE_NORMAL
- en: Take the example of Pod names. When you work without namespaces, you interact
    with the default namespace, and when you create two Pods with the same name, you
    get an error because Kubernetes uses the names of the Pods as their unique identifiers
    to distinguish them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to create two Pods in the default namespace. Both will be called
    `nginx`. Here, we can simply run the same command twice in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command produces an error, saying that the Pod already exists, which
    it does. If we run `kubectl get pods`, we can see that only one Pod exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try to list the Pods again but, this time, in the `custom-ns` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this namespace also has a Pod called `nginx`, and it’s not the
    same Pod that is contained in the `default` namespace. This is one of the major
    advantages of namespaces. By using them, your Kubernetes cluster can now define
    multiple resources with the same names, so long as they are in different namespaces.
    You can easily duplicate microservices or applications by using the namespace
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that you can override the key to the namespaces of the resources
    that you create declaratively. By adding the `-n` option to the `kubectl create`
    command, you force a namespace as the context for your command; `kubectl` will
    take the namespace that was passed in the command into account, not the one present
    in the YAML file. By doing this, it becomes very easy to duplicate your resources
    between different namespaces – for example, a production environment in a `production`
    namespace and a test environment in a `test` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding that not all resources are in a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Kubernetes, not all objects belong to a namespace. This is the case, for
    example, with nodes, which are represented at the cluster level by an entry of
    the `Node` kind but that does not belong to any particular namespace. You can
    list resources that do not belong to a namespace using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also list all the resources that belong to a namespace by passing `--namespaced`
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how namespaces affect a service’s DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving a service using namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discovered in *Chapter 8*, *Exposing Your Pods with Services*, Pods can
    be exposed through a type of object called Services. When created, services are
    assigned a DNS record that allows Pods in the cluster to access them.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when a Pod tries to call a service through DNS, it can only reach
    it if the service is in the same namespace as the Pod, which is limiting. Namespaces
    have a solution to this problem. When a service is created in a particular namespace,
    the name of its service is added to its DNS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By querying this domain name, you can easily query any service that is in any
    namespace in your Kubernetes cluster. So you are not limited to that level. Pods
    are still capable of achieving inter-communication, even if they don’t run in
    the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explore some of the best practices for Kubernetes
    namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for Kubernetes namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though there are no strict rules on namespace creation and management,
    let us learn some of the industry best practices related to namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Organization and separation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical Grouping**: Put together apps, services, and resources that go together
    based on what they do, where they are in development (like dev, test, and prod),
    or who owns them (e.g., different teams). This keeps things organized and makes
    managing resources easier.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: Use namespaces to keep deployments separate. This means apps
    in one namespace won’t mess with stuff in another, which reduces conflicts. You
    can also increase the security and isolation by applying appropriate **Role-Based
    Access Control** (**RBAC**) network policies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear and Descriptive**: Give your namespaces names that say what they’re
    for. This makes it easier to keep track of them, especially in big setups. Stick
    to common naming tricks like `dev-`, `test-`, or `prod-` for different environments.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stay Consistent**: Use the same naming style across your cluster. This makes
    it easier for your team to talk about and understand what’s going on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Limits**: Set limits on how much stuff a namespace can use. This
    stops one deployment from hogging everything and makes sure everyone gets their
    fair share. Please remember that it is also possible to set the resource limits
    at the Pod level for increased control.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limits for All**: Make rules for how much stuff each Pod and container in
    a namespace can ask for or use. This gives you more control over how resources
    are used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role-Based Access**: Use RBAC to control who can do what in each namespace.
    Give people and services the right permissions to manage stuff in their namespace.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping an eye out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Watch Things**: Keep an eye on how much stuff is used and if your apps are
    healthy in each namespace. This helps you spot problems and use resources better.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifecycle of a Namespace**: Check up on your namespaces regularly. Get rid
    of the ones that you don’t use anymore to keep things tidy and avoid security
    risks. Think about automating how you create and delete namespaces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other stuff to think about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not Perfect Isolation**: Even though namespaces help keep things separate,
    they’re not foolproof. You might need network rules for extra safety.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clusters versus Namespaces:** If your setup is complicated and needs a lot
    of separation, think about using different Kubernetes clusters instead of just
    namespaces.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these best practices, you can keep your Kubernetes setup organized,
    safe, and easy to handle using namespaces. Just remember to tweak things to fit
    your own setup for the best results. With that, we’re done with the basics of
    namespaces in Kubernetes. We have learned what namespaces are, how to create and
    delete them, how to use them to keep a cluster clean and organized, and how to
    update the `kubeconfig` context to make `kubectl` point to a specific namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ll look at a few more advanced options related to namespaces. It is
    a good time to introduce `ResourceQuota` and `Limit`, which you can use to limit
    the computing resources that an application deployed on Kubernetes can access!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ResourceQuota and Limit at the namespace level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to discover that namespaces can not only be used
    to sort resources in a cluster but also to limit the computing resources that
    Pods can access.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ResourceQuota` and `Limits` with namespaces, you can create limits regarding
    the computing resources your Pods can access. We’re going to learn how to proceed
    and exactly how to use these new concepts. In general, defining `ResourceQuota`
    and `Limits` is considered good practice for production clusters – that’s why
    you should use them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need to set ResourceQuotas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like applications or systems, Kubernetes Pods will require a certain amount
    of computing resources to work properly. In Kubernetes, you can configure two
    types of computing resources:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All your nodes (compute and controller) work together to provide CPU and memory,
    and in Kubernetes, adding more CPU and memory simply consists of adding more compute
    (or worker) nodes to make room for more Pods. Depending on whether your Kubernetes
    cluster is based on-premises or in the cloud, adding more compute nodes can be
    achieved by purchasing the hardware and setup to do so, or by simply calling the
    cloud API to create additional virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how Pods consume these resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you launch a Pod on Kubernetes, a control plane component, known as `kube-scheduler`,
    will elect a compute node and assign the Pods to it. Then, the `kubelet` on the
    elected compute node will attempt to launch the containers defined in the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: This process of compute node election is called **Pod scheduling** in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: When a Pod gets scheduled and launched on a compute node, it has, by default,
    access to all the resources that the compute node has. Nothing prevents it from
    accessing more and more CPU and memory as the application is used, and ultimately,
    if the Pods run out of memory or CPU resources to work properly, then the application
    simply crashes.
  prefs: []
  type: TYPE_NORMAL
- en: This can become a real problem because compute nodes can be used to run multiple
    applications – and, therefore, multiple Pods – at the same time. So if 10 Pods
    are launched on the same compute node but one of them consumes all the computing
    resources, then this will have an impact on all 10 Pods running on the compute
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem means that you have two things you must consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Each Pod should be able to require some computing resources to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cluster should be able to restrict the Pod’s consumption so that it doesn’t
    take all the resources available, sharing them with other Pods too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to address these two problems in Kubernetes, and we will discover
    how to use two options that are exposed to the Pod object. The first one is called
    **resource requests**, which is the option that’s used to let a Pod indicate what
    amount of computing resources it needs, while the other one is called **resource
    limit** and will be used to indicate the maximum computing resources the Pod will
    have access to.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore these options now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how Pods can require computing resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `request` and `limit` options will be declared within the YAML definition
    file of a Pod resource, or you can apply it to the running deployment using the
    `kubectl set resource` command. Here, we’re going to focus on the `request` option.
  prefs: []
  type: TYPE_NORMAL
- en: The resource request is simply the minimal amount of computing resources a Pod
    will need to work properly, and it is a good practice to always define a `request`
    option for your Pods, at least for those that are meant to run in production.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that you want to launch an NGINX Pod on your Kubernetes cluster. By
    filling in the `request` option, you can tell Kubernetes that your NGINX Pod will
    need, at the bare minimum, 512 MiB of memory and 25% of a CPU core to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the YAML definition file that will create this Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three things to note about this Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: It is created inside the `custom-ns` namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires `512Mi` of memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires `250m` of CPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what do these metrics mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory is expressed in bytes (one MiB is equal to 1,048,576 bytes), whereas
    CPU is expressed in **millicores** and allows fractional values. If you want your
    Pod to consume one entire CPU core, you can set the `cpu` key to `1000m`. If you
    want two cores, you must set it to `2000m`; for half of a core, it will be `500m`
    or `0.5`; and so on. However, to request a full CPU core, it’s simpler and more
    common practice to use the whole number (e.g., `2`) instead of `2000m`. So the
    preceding YAML definition says that the NGINX Pod we will create will forcibly
    need 512 MiB of memory, since memory is expressed in bytes, and one-quarter of
    a CPU core of the underlying compute node. There is nothing related to the CPU
    or memory frequency here.
  prefs: []
  type: TYPE_NORMAL
- en: When you apply this YAML definition file to your cluster, the scheduler will
    look for a compute node that is capable of launching your Pods. This means that
    you need a compute node where there is enough room in terms of available CPU and
    memory to meet your Pods’ requests.
  prefs: []
  type: TYPE_NORMAL
- en: But what if no compute node is capable of fulfilling these requirements? Here,
    the Pod will never be scheduled and never be launched. Unless you remove some
    running Pods to make room for this one or add a compute node that is capable of
    launching this Pod, it won’t ever be launched.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Pods cannot span multiple nodes. So if you set `8000m` (which
    represents eight CPU cores) but your cluster is made up of two compute nodes with
    four cores each, then no compute node will be able to fulfill the request, and
    your Pod won’t be scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: So use the `request` option wisely – consider it as the minimum amount of compute
    resources the Pod will need to work. You have the risk that your Pod will never
    be scheduled if you set too high a request, but on the other hand, if your Pod
    is scheduled and launched successfully, this amount of resources is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can limit resource consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how you can limit resource consumption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write a YAML definition file, you can define resource limits regarding
    what a Pod will be able to consume.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a resource request won’t suffice to do things properly. You should set
    a limit each time you set a resource. Setting a limit will tell Kubernetes to
    let the Pod consume resources up to that limit, and never above. This way, you
    ensure that your Pod won’t take all the resources of the compute for itself.
  prefs: []
  type: TYPE_NORMAL
- en: However, be careful – Kubernetes won’t behave the same, depending on what kind
    of limit is reached. If the Pod reaches its CPU limit, it is going to be throttled,
    and you’ll notice performance degradation. But if your Pod reaches its memory
    limit, then it might be terminated. The reason for this is that memory is not
    something that can be throttled, and Kubernetes still needs to ensure that other
    applications are not impacted and remain stable. So be aware of that.
  prefs: []
  type: TYPE_NORMAL
- en: Without a limit, the Pod will be able to consume all the resources of the compute
    node. Here is an updated YAML file corresponding to the NGINX Pod we saw earlier,
    but now, it has been updated to define a limit on memory and CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the Pod will be able to consume up to 1 GiB of memory and up to 1 entire
    CPU core of the underlying compute node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So when you set a request, set a limit too. Let us try this request and limit
    it in our next hands-on lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, let us check current system resource availability. Since
    we are using the minikube cluster for our demonstration, let us enable metrics
    for detailed resource usage information. You will use metrics in *Chapter 10*,
    *Running Production-Grade Kubernetes Workloads*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the metrics server Pods to enter a `Running` state before you continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us check the cluster usage using the metrics information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have about 800Mi memory and 180m CPU available to consume in
    our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `minikube` with Podman or the Docker driver, the `minikube`
    will show the actual host CPU and memory, not the memory of the `minikube` Kubernetes
    cluster node. In such cases, you can try another `minikube` cluster using VirtualBox
    (`minikube start --profile cluster2-vb --driver=virtualbox`) so that it will use
    the `minikube` VM CPU and memory resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a new namespace for the resource request and limit demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create a new YAML file where we have non-realistic memory requests
    such as `100Gi resources.requests.memory`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Pod using `kubectl apply`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the Pod status to see the Pod creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This says `Pending` and that the Pod is not running yet. Let us check the Pod
    details using the `kubectl describe` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You will see an error, as the scheduler cannot find any nodes in the cluster
    to accommodate your Pod with the memory requests, which means that the Pod will
    be scheduled until the Kubernetes cluster has a suitable node to place the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will update the YAML with reasonable memory, `1Gi resources.requests.memory`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create the Pod now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, the Kubernetes scheduler can find the suitable node, based on the resource
    request, and the Pod has already started running as usual.
  prefs: []
  type: TYPE_NORMAL
- en: So now that you are aware of this request and limit consideration, don’t forget
    to add it to your Pods!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding why you need ResourceQuota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can entirely manage your Pod’s consumptions by relying entirely on its request
    and limit options. All the applications in Kubernetes are just Pods, so setting
    these two options provides you with a strong and reliable way to manage resource
    consumption on your cluster, given that you never forget to set these.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to forget these two options and deploy a Pod on your cluster that
    won’t define any request or limit. Maybe it will be you, or maybe a member of
    your team, but the risk of deploying such a Pod is high because everyone can forget
    about these two options. And if you do so, the risk of application instability
    is high, as a Pod without a limit can eat all the resources on the compute node
    it is launched on.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides a way to mitigate this issue, thanks to two objects called
    `ResourceQuota` and `LimitRange`. These two objects are extremely useful because
    they can enforce these constraints at the namespace level.
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceQuota` is another resource kind, just like a Pod or ConfigMap. The
    workflow is quite simple and consists of two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You must create a new namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You must create a `ResourceQuota` and a `LimitRange` object inside that namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, all the Pods that are launched in that namespace will be constrained by
    these two objects.
  prefs: []
  type: TYPE_NORMAL
- en: These quotas are used, for example, to ensure that all the containers that are
    accumulated in a namespace do not consume more than 4 GiB of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is possible and even recommended to set restrictions on what can
    and cannot run within Pods. It is strongly recommended that you always define
    a `ResourceQuota` and a `LimitRange` object for each namespace you create in your
    cluster!
  prefs: []
  type: TYPE_NORMAL
- en: Without these quotas, the deployed resources could consume as much CPU or RAM
    as they want, which would ultimately make your cluster and all the applications
    running on it unstable, given that the Pods don’t hold requests and limits as
    part of their respective configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, `ResourceQuota` is used to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit CPU consumption within a namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit memory consumption within a namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the absolute number of objects such as Pods, Services, ReplicationControllers,
    Replicas, Deployments, etc. operating within a namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit consumption of storage resources based on the associated storage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of use cases, and you can discover all of them directly in the
    Kubernetes documentation. Now, let’s learn how to define `ResourceQuota` in a
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ResourceQuota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the usefulness of `ResourceQuota`, we are going to create one
    `ResourceQuota` object for the namespace `quota-ns`. This `ResourceQuota` will
    be used to create requests and limits that all the Pods within this namespace
    combined will be able to use. Here is the YAML file that will create `ResourceQuota`;
    please note the resource kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the `ResourceQuota` object is scoped to one namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'This one is stating that, in this namespace, the following will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: All the Pods combined won’t be able to request more than one CPU core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the Pods combined won’t be able to request more than 1 GiB of memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the Pods combined won’t be able to consume more than two CPU cores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the Pods combined won’t be able to consume more than 2 GiB of memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the `ResourceQuota` by applying the YAML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check the current resources in the `quota-ns` namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There is an nginx Pod (if you haven’t deleted the previous demo Pod) and usage
    is very low.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a new Pod YAML file but we request `3Gi` memory for the Pod as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us try to create this Pod and see what the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the error is very clear; we are requesting more resources than the quota,
    and Kubernetes will not allow the creation of a new Pod.
  prefs: []
  type: TYPE_NORMAL
- en: You can have as many Pods and containers in the namespace, so long as they respect
    these constraints. Most of the time, `ResourceQuotas` are used to enforce constraints
    on requests and limits, but they can also be used to enforce these limits per
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: While setting up `ResourceQuotas` at the namespace level, it’s crucial to prevent
    any single namespace from consuming all cluster resources; it’s also important
    to apply resource requests and limits at the Pod or Deployment level. This dual-layered
    approach ensures that resource-hogging is contained both within individual namespaces
    and at the application level. By enforcing these limits, you create a more predictable
    and stable environment, preventing any one component from disrupting the entire
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the preceding `ResourceQuota` has been updated to
    specify that the namespace where it is created cannot hold more than 10 ConfigMaps
    and 5 services, which is pointless but a good example to demonstrate the different
    possibilities with `ResourceQuota`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When applying a `ResourceQuota` YAML definition, ensure that the `ResourceQuota`
    is assigned to the correct namespace. If the namespace isn’t specified within
    the YAML file, remember to use the `--namespace` flag to specify where the `ResourceQuota`
    should be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ResourceQuota` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will learn about the storage `ResourceQuota` in
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Storage resource quotas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, resource quotas allow you to control the total storage resources
    requested within a namespace. You can set limits on both the sum of storage requests
    across all persistent volume claims and the number of persistent volume claims
    allowed. Additionally, quotas can be defined based on specific storage classes,
    enabling separate limits for different storage class types. For example, you can
    set quotas for gold and bronze storage classes separately. Starting from release
    1.8, quotas also support local ephemeral storage, allowing you to limit the sum
    of local ephemeral storage requests and limits across all Pods within a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to list `ResourceQuotas`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing ResourceQuota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ResourceQuota` objects can be accessed through `kubectl` using the quota’s
    resource name option. The `kubectl get` command will do this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how to delete `ResourceQuota` from a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting ResourceQuota
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove a `ResourceQuota` object from your cluster, use the `kubectl delete`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s introduce the notion of `LimitRange`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LimitRange
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LimitRange` is another object that is similar to `ResourceQuota`, as it is
    created at the namespace level. The `LimitRange` object is used to enforce default
    requests and limit values to individual containers. Even by using the `ResourceQuota`
    object, you could create one object that consumes all the available resources
    in the namespace, so the `LimitRange` object is here to prevent you from creating
    too small or too large containers within a namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a YAML file that will create `LimitRange`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `LimitRange` object consists of four important keys that
    all contain `memory` and `cpu` configuration. These keys are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default`: This helps you enforce default values for the `memory` and `cpu`
    limits of containers if you forget to apply them at the Pod level. Each container
    that is set up without limits will inherit these default ones from the `LimitRange`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultRequest`: This is the same as `default` but for the `request` option.
    If you don’t set a `request` option to one of your containers in a Pod, the ones
    from this key in the `LimitRange` object will be automatically used by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`: This value indicates the maximum limit (not request) container that
    a Pod can set. You cannot configure a Pod with a limit value that is higher than
    this one. It is the same as the `default` value in that it cannot be higher than
    the one defined here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: This value works like `max` but for requests. It is the minimum amount
    of computing resources that a Pod can request, and the `defaultRequest` option
    cannot be lower than this one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, note that if you omit the `default` and `defaultRequest` keys, then
    the `max` key will be used as the `default` key, and the `min` key will be used
    as the `default` key.
  prefs: []
  type: TYPE_NORMAL
- en: Defining `LimitRange` is a good idea if you want to protect yourself from forgetting
    to set requests and limits on your Pods. At least with `LimitRange`, these objects
    will have default limits and requests!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how to list `LimitRanges`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing LimitRanges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `kubectl` command line will help you list your `LimitRanges`. Don’t forget
    to add the `-n` flag to scope your request to a specific namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how to delete `LimitRange` from a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting LimitRange
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting `LimitRange` can be achieved using the `kubectl` command-line tool.
    Here is how to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As always, don’t forget to add the `-n` flag to scope your request to a specific
    namespace; otherwise, you may target the wrong one!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to namespaces, which are extremely important in
    Kubernetes. You cannot manage your cluster effectively without using namespaces
    because they provide logical resource isolation in your cluster. Most people use
    production and development namespaces, for example, or one namespace for each
    application. It is generally not rare to see clusters where hundreds of namespaces
    are created.
  prefs: []
  type: TYPE_NORMAL
- en: We discovered that most Kubernetes resources are scoped to a namespace, although
    some are not. Keep in mind that, by default, Kubernetes is set up with a few preconfigured
    namespaces, such as `kube-system`, and that it is generally a bad idea to change
    the things that run in these namespaces, especially if you do not know what you
    are doing.
  prefs: []
  type: TYPE_NORMAL
- en: We also discovered that namespaces can be used to set quotas and limit the resources
    that Pods can consume, and it is a really good practice to set these quotas and
    limits at the namespace level, using the `ResourceQuota` and `LimitRange` objects,
    to prevent your Pods from consuming too many computing resources. By implementing
    these measures, you’re laying the foundation for effective capacity management,
    a critical consideration for organizations aiming to maintain the stability and
    efficiency of all applications running on a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to handle configuration infomation and
    sensitive data in Kubernetes using ConfigMaps and Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Initial namespaces*: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#initial-namespaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource Management for Pods and Containers*: [https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource Quotas*: [https://kubernetes.io/docs/concepts/policy/resource-quotas/](https://kubernetes.io/docs/concepts/policy/resource-quotas/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Limit Ranges*: [https://kubernetes.io/docs/concepts/policy/limit-range/](https://kubernetes.io/docs/concepts/policy/limit-range/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource metrics pipeline*: [https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/](https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configure Default Memory Requests and Limits for a Namespace*: [https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/](https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code119001106479081656.png)'
  prefs: []
  type: TYPE_IMG
