<html><head></head><body>
		<div id="_idContainer179">
			<h1 class="chapter-number" id="_idParaDest-253"><a id="_idTextAnchor257"/>13</h1>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor258"/>Security with GitOps</h1>
			<p>Implementing GitOps offers several benefits for the security of software development processes. By using Git as a central source for configuration and code, the integrity and traceability of environments can be ensured. In this chapter, we will explore the various aspects of security in the context <span class="No-Break">of GitOps.</span></p>
			<p>We will begin by<a id="_idIndexMarker1137"/> examining the well-known <strong class="bold">Cockpit</strong> and <strong class="bold">Fleet</strong> approaches and use them<a id="_idIndexMarker1138"/> to highlight various security considerations when using Argo CD. Next, we<a id="_idIndexMarker1139"/> will focus on <strong class="bold">Kyverno</strong> as a <strong class="bold">policy engine</strong> that acts as a gatekeeper, defining<a id="_idIndexMarker1140"/> what is allowed on the cluster and which deployments are <span class="No-Break">even permitted.</span></p>
			<p>The topic of permissions plays a central role in the context of GitOps. Therefore, we will discuss the secure handling of secrets and introduce two tools that have already been successfully adopted in <span class="No-Break">the industry.</span></p>
			<p>From the perspective of the platform team, we will consider the provisioning of context information such as cert-manager, Ingress Controllers, and so on for developers. Here, we will use the proven <strong class="bold">Kubernetes Service Catalog</strong> principle and explore its secure<a id="_idIndexMarker1141"/> application <span class="No-Break">and updating.</span></p>
			<p>Finally, we will take a look at the <strong class="bold">KubeClarity</strong> tool, which provides clarity<a id="_idIndexMarker1142"/> about vulnerabilities in running applications on various levels, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Configuration</strong>: Misconfigurations of <span class="No-Break">Kubernetes resources</span></li>
				<li><strong class="bold">Images</strong>: Vulnerabilities in the container <span class="No-Break">images used</span></li>
				<li><strong class="bold">Code</strong>: Security vulnerabilities in the <span class="No-Break">application code</span></li>
			</ul>
			<p>In addition, we will briefly dive into the OS level or kernel level and look at the <strong class="bold">Falco</strong> tool. This tool can be used to detect<a id="_idIndexMarker1143"/> suspicious activity on the host, such as when operations are executed that should not <span class="No-Break">be executed.</span></p>
			<p>The goal of this chapter is to illuminate the different perspectives on different layers and thus gain a better understanding of how GitOps can help teams <span class="No-Break">improve security.</span></p>
			<p>We will cover the following main topics in <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>Hardening declarative GitOps CD <span class="No-Break">on Kubernetes</span></li>
				<li>Committing everything to Git? What <span class="No-Break">about Secrets?</span></li>
				<li>Leveraging a policy engine for <span class="No-Break">policy-as-code practices</span></li>
				<li>Automating security scanning <span class="No-Break">and compliance</span></li>
				<li>Keeping your platform <span class="No-Break">catalog up-to-date</span></li>
			</ul>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor259"/>Hardening declarative GitOps CD on Kubernetes</h1>
			<p>In this section, we’ll delve<a id="_idIndexMarker1144"/> into the practices essential for hardening declarative GitOps <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) on Kubernetes, focusing on enhancing<a id="_idIndexMarker1145"/> security and reducing the risk of misconfigurations – a leading cause of cloud breaches. The shift toward cloud-native technologies has simplified the complexity of systems, operational theories, and skillsets, offering a clearer and more secure framework for building and managing applications. However, the security of these systems extends beyond just the software development and supply chain aspects; it crucially involves addressing the <span class="No-Break">configuration vulnerabilities.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor260"/>Addressing configuration vulnerabilities</h2>
			<p>Cloud-native technologies<a id="_idIndexMarker1146"/> streamline skillsets, operational theories, and system complexities, enhancing the understandability and security of system architectures. However, the primary cloud security risk remains misconfiguration, often overlooked amid the focus on developmental and supply chain security. The adoption of the GitOps pattern, particularly for progressive application delivery, has become widespread, offering a more secure alternative to traditional direct-to-production build servers. This method employs a Git repository for changes, enabling pre-deployment security assessments and minimizing privilege escalation and <span class="No-Break">configuration drift.</span></p>
			<p>The Cloud Native<a id="_idIndexMarker1147"/> Computing Foundation commissioned <strong class="bold">ControlPlane</strong> [<em class="italic">1</em>] to conduct a detailed threat modeling analysis on Argo CD, a tool emblematic of the GitOps approach, focusing on its deployment in a multi-tenant Kubernetes environment. This analysis revealed 19 identified threats, with 6 classified as high priority, emphasizing the need for rigorous security measures. Recommendations for hardening include enhancing password<a id="_idIndexMarker1148"/> management, integrating <strong class="bold">single sign-on</strong>, and applying strict <strong class="bold">Role Based Access Contro</strong> (<strong class="bold">RBAC)</strong> principles to limit access to <span class="No-Break">sensitive information.</span></p>
			<p>The report from ControlPlane [<em class="italic">1</em>] also provides visual attack trees for the most critical threats, aiding stakeholders in understanding and mitigating risks, alongside a comprehensive overview of the Argo CD deployment architecture. It includes Terraform code for replicating the setup, ensuring that security controls can be effectively validated. These measures, grounded in the report’s findings, aim to fortify the security of Argo CD deployments, aligning them with organizational security standards and maximizing the benefits of using GitOps within <span class="No-Break">cloud-native ecosystems.</span></p>
			<p>We will integrate parts from the report<a id="_idIndexMarker1149"/> and combine them with the well-known Cockpit and Fleet approach. The report in question is from 2023, featuring <em class="italic">Argo CD version 2.67</em>, and some issues may have already been resolved with newer Argo CD releases. At the time of writing, <em class="italic">Argo CD version 2.10*</em> is considered stable. We will compare specific points from the report against <em class="italic">Argo CD </em><span class="No-Break"><em class="italic">Version 2.10*</em></span><span class="No-Break">.</span></p>
			<p>In this section, we will not go through the entire report but will select a few items to discuss. Each potential<a id="_idIndexMarker1150"/> threat will be abbreviated as <strong class="bold">ATM-ID</strong>, with priorities defined from low to high. These will be divided into three<a id="_idIndexMarker1151"/> categories. <em class="italic">Table 13.1</em> depicts the <strong class="bold">Change Impact Assessment</strong> (<strong class="bold">CIA</strong>) <span class="No-Break">as follows:</span></p>
			<table class="T---Table _idGenTablePara-1" id="table001-6">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="3">
							<p><span class="No-Break"><strong class="bold">Confidentiality</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Cluster takeover (Operations, Tenant) due to leak of <span class="No-Break">admin credentials</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Medium</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Sensitive information related to application or cluster state <span class="No-Break">is exfiltrated</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Low</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Non-sensitive <span class="No-Break">information leakage</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="3">
							<p><span class="No-Break"><strong class="bold">Integrity</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Compromise of source code repositories and <span class="No-Break">application deployments</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Medium</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Application sync fails due to <span class="No-Break">misconfiguration/invalid configuration</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Low</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Non-critical operation is blocked due to <span class="No-Break">misconfiguration/invalid configuration</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body" rowspan="3">
							<p><span class="No-Break"><strong class="bold">Availability</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Cluster (Operations, Tenant) subject to <strong class="bold">Denial of </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DoS</strong></span><span class="No-Break">)</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Medium</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Managed applications are blocked for a <span class="No-Break">significant period</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Low</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Managed app synchronization is blocked for a <span class="No-Break">short period</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.1 – Change Impact Assessment [1]</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor261"/>Enhancing password management and RBAC</h2>
			<p>Let’s now examine<a id="_idIndexMarker1152"/> where we can identify<a id="_idIndexMarker1153"/> parts of the threats within our Cockpit and Fleet approach. This will be indicated in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em> with an exclamation mark and <span class="No-Break">an ID:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer173">
					<img alt="Figure 13.1 – Cockpit and Fleet approach combined with a threat model" src="image/B22100_13_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Cockpit and Fleet approach combined with a threat model</p>
			<p>Now, the first<a id="_idIndexMarker1154"/> ID, <em class="italic">ATM-004</em>, is located<a id="_idIndexMarker1155"/> in <em class="italic">Table 13.2</em> under the category <em class="italic">Argo </em><span class="No-Break"><em class="italic">CDs RBAC</em></span><span class="No-Break">:</span></p>
			<table class="T---Table _idGenTablePara-1" id="table002-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">ID</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">UID</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Category</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Priority</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">ATM-004</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">KR-AR-002</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Argo <span class="No-Break">CD RBAC</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.2 – ATM-004: UI local users’ credentials never expire, and don’t have  strong authentication</p>
			<p>The risk here is that the Argo CD UI local users’ credentials never expire and are solely based on a username and password without secondary authentication. The priority is already set too high. Considering the Cockpit, which has access to the remaining clusters, in my opinion, it becomes even <span class="No-Break">more critical.</span></p>
			<p>The danger is that unauthorized changes could occur if the credentials were to <span class="No-Break">be compromised.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">OAuth2</strong> and <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) are protocols for secure authorization<a id="_idIndexMarker1156"/> and authentication. OAuth2 allows <a id="_idIndexMarker1157"/>secure resource access, while OIDC, built on OAuth2, adds user identity verification. They ensure secure data sharing without exposing credentials, enhancing application security through <span class="No-Break">token-based authentication.</span></p>
			<p class="callout"><strong class="bold">Dex</strong> is an open source identity<a id="_idIndexMarker1158"/> service that uses OIDC to authenticate users and provide access to various applications <span class="No-Break">and services.</span></p>
			<p class="callout"><strong class="bold">Microsoft Entra ID</strong>, formerly <strong class="bold">Azure Active Directory</strong> (<strong class="bold">AAD</strong>), is a cloud-based identity<a id="_idIndexMarker1159"/> and access management<a id="_idIndexMarker1160"/> service provided <span class="No-Break">by Microsoft.</span></p>
			<p>It is therefore recommended<a id="_idIndexMarker1161"/> to use the local admin account only<a id="_idIndexMarker1162"/> for initial configuration and then switch to single sign-on through the provided Dex server and an OIDC provider that supports OAuth2, such as Microsoft Entra ID, allowing the mapping of roles to corresponding groups. Subsequently, the admin access should be disabled, as admin access does not provide more extensive permissions than the highest mapping of the admin group to an <span class="No-Break">Azure group.</span></p>
			<p>This can then be adjusted in the <strong class="source-inline">argocd-rbac-cm</strong> configmap <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
apiVersion: v1
data:
  policy.csv: |
    p, role:org-admin, applications, *, */*, allow
    p, role:org-admin, clusters, get, *, allow
    p, role:org-admin, repositories, get, *, allow
    p, role:org-admin, repositories, create, *, allow
    p, role:org-admin, repositories, update, *, allow
    p, role:org-admin, repositories, delete, *, allow
    g, "GROUP_ID", role:org-admin
  policy.default: role:readonly
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/name: argocd-rbac-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-rbac-cm
  namespace: argocd</pre>			<p>Subsequently, the local<a id="_idIndexMarker1163"/> admin can be<a id="_idIndexMarker1164"/> disabled <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">argocd-cm</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
data:
  admin.enabled: "false"</pre>			<p>If we also consider that the admin password (<em class="italic">ATM-003</em>) exists as a Kubernetes Secret, then hopefully, it’s clear how dangerous it can be if an attacker gains access either to a Fleet cluster or, even worse, to the Cockpit, which enables access to the <em class="italic">ServiceAccounts</em> and thus to the <span class="No-Break">remaining clusters.</span></p>
			<table class="T---Table" id="table003-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">ID</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">UID</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Category</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Priority</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">ATM-003</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">KR-AR-001</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Argo <span class="No-Break">CD RBAC</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.3 – ATM-003: Initial admin password is stored as a Kubernetes Secret</p>
			<p>If attackers gain access to a Fleet cluster or, even worse, to the Cockpit, which controls the <em class="italic">ServiceAccounts</em> and thus allows access to the remaining clusters, there is a significant risk involved. This situation could lead to <em class="italic">unauthorized changes</em> in the Argo CD configuration due to unauthorized reading of the Argo CD initial admin password from <span class="No-Break">Kubernetes Secrets.</span></p>
			<p>Therefore, it is recommended to rotate the Argo CD admin password and delete the secret, as Argo CD only creates the secret for access purposes but does not need the secret itself. According to Argo CD’s documentation, the secret serves no other purpose than to store the initially generated password in clear text, and can safely be deleted at <span class="No-Break">any time.</span></p>
			<p>To modify the admin<a id="_idIndexMarker1165"/> password, follow the subsequent<a id="_idIndexMarker1166"/> steps. It’s recommended to pass this guidance on to every user or team managing a fleet cluster. The optimal approach is to transition to OIDC and then deactivate the admin account as previously outlined. However, if you need to change the password, you should adhere to the <span class="No-Break">following procedures:</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">These commands are run on a Unix-like operating system such as Ubuntu, Debian, or other Linux distributions, as well as <span class="No-Break">on macOS.</span></p>
			<ol>
				<li>First, forward to <span class="No-Break"><strong class="source-inline">argocd server</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">kubectl port-forward --namespace argocd service/argocd-server 8080:443</strong></pre></li>				<li>The password can<a id="_idIndexMarker1167"/> be easily accessed using the Argo CD <strong class="bold">command-line </strong><span class="No-Break"><strong class="bold">interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CLI</strong></span><span class="No-Break">):</span><pre class="source-code">
<strong class="bold">argocd admin initial-password -n argocd</strong></pre></li>				<li>Using the previous <strong class="source-inline">admin</strong> as username  and password, log in to Argo CD’s IP <span class="No-Break">or hostname:</span><pre class="source-code">
<strong class="bold">argocd login &lt;ARGOCD_SERVER&gt;</strong></pre></li>				<li>Change the password using the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">argocd account update-password</strong></pre></li>				<li>As an alternative to the previous steps, you can use a shorter method by combining the commands into one line, as in <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">kubectl port-forward svc/argocd-server -n argocd 8080:443 &amp; argocd login localhost:8080 --username admin --password $(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d) --insecure --grpc-web</strong></pre></li>				<li>Then, update the password <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">argocd account update-password</strong></pre></li>				<li>Now, kill the forwarding process running in the background <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">kill $(ps aux | grep 'kubectl port-forward svc/argocd-server -n argocd 8080:443' | grep -v grep | awk '{print $2}')</strong></pre></li>			</ol>
			<p>Now that we’ve updated<a id="_idIndexMarker1168"/> the password, let’s examine<a id="_idIndexMarker1169"/> the final part, <em class="italic">ATM-006</em> (<em class="italic">Table 13.4</em>), which becomes particularly significant in the context of the Cockpit and <span class="No-Break">Fleet approach:</span></p>
			<table class="T---Table" id="table004-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">ID</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">UID</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Category</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Priority</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">ATM-006</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">KR-ASM-001</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Argo CD <span class="No-Break">Secrets Management</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">High</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 13.4 – ATM-006: Never-expiring tenant cluster credentials are stored as Kubernetes Secrets</p>
			<p>The risk here is that Argo CD tenant cluster credentials are stored as Kubernetes Secrets, and the Argo CD <strong class="source-inline">argocd-manager</strong> service account token on the tenant cluster is configured never <span class="No-Break">to expire.</span></p>
			<p>Consequently, an attacker could perform unauthorized actions on the tenant cluster due to unauthorized access to the never-expiring tenant bearer token from the <span class="No-Break">Kubernetes Secret.</span></p>
			<p>Depending on the provider and Kubernetes distribution, different mitigation strategies can be applied. It is advised to use <strong class="bold">workload identities or managed identities</strong>, especially in services such<a id="_idIndexMarker1170"/> as Azure Kubernetes Service, allowing<a id="_idIndexMarker1171"/> clusters to access Azure resources without secrets. Alternatively, consider<a id="_idIndexMarker1172"/> leveraging an external <strong class="bold">key management service</strong> (e.g., <strong class="bold">AWS Key Management Service</strong>) to securely manage and expose<a id="_idIndexMarker1173"/> Argo CD tenant cluster credentials. It’s crucial to ensure that Argo CD’s tenant cluster bearer tokens are rotated regularly, aligning with organizational security policies. For manual rotation, deleting the corresponding Kubernetes Secret in the tenant cluster will trigger the creation of a <span class="No-Break">new token.</span></p>
			<p>However, the aim of this section<a id="_idIndexMarker1174"/> is not to address all security<a id="_idIndexMarker1175"/> vulnerabilities, as I consider it unnecessary  to cover them all due to their vast diversity. This section is intended to raise awareness of the potential security gaps that can arise when using GitOps and how to attempt to <span class="No-Break">counteract them.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em> should now make it clear that we have only mitigated three out of many possible <span class="No-Break">high-level attacks:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer174">
					<img alt="Figure 13.2 – Cockpit and Fleet approach combined with the threat model – the reduced attack vector view" src="image/B22100_13_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Cockpit and Fleet approach combined with the threat model – the reduced attack vector view</p>
			<p>Mechanisms commonly supported<a id="_idIndexMarker1176"/> by most systems, such as firewall<a id="_idIndexMarker1177"/> rules, should be implemented to restrict access to Cockpit clusters exclusively tospecified IP address ranges. Similarly, access to Fleet clusters can be limited using firewalls, potentially originating from the Cockpit cluster itself and confined to certain IP spaces. It’s crucial to secure cluster access, particularly to the Cockpit, with <strong class="bold">multi-factor authentication</strong> (<strong class="bold">MFA</strong>) to significantly reduce the initial<a id="_idIndexMarker1178"/> attack vector. Whenever feasible, perpetual tokens should be replaced with identity solutions to facilitate access without the need <span class="No-Break">for secrets.</span></p>
			<p>I strongly advise delving into the <em class="italic">Threat Model</em> document provided<a id="_idIndexMarker1179"/> by <strong class="bold">ControlPlane</strong>. It includes detailed <strong class="bold">attack trees</strong> that illustrate how exploiting<a id="_idIndexMarker1180"/> multiple vulnerabilities can have profound impacts. This comprehensive understanding is essential<a id="_idIndexMarker1181"/> for effectively safeguarding<a id="_idIndexMarker1182"/> <span class="No-Break">your infrastructure.</span></p>
			<p>The next section is about the fact that GitOps takes the approach that everything is in Git, but what about secrets? This section looks at how to store secrets securely <span class="No-Break">in Git.</span></p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor262"/>Committing everything to Git? What about Secrets?</h1>
			<p>In a GitOps workflow, the idea of committing every piece of configuration to Git repositories is central. It ensures that the entire state of your infrastructure is declaratively represented and can be versioned, audited, and reviewed. However, this approach presents a challenge when it comes to handling secrets, such as passwords, tokens, and private keys. Storing such sensitive information plainly in Git repositories is not secure. This is where tools such as Sealed Secrets and External Secrets come into play, providing secure mechanisms to manage secrets in a <span class="No-Break">GitOps workflow.</span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor263"/>Sealed Secrets</h2>
			<p>Sealed Secrets [<em class="italic">2</em>] is a Kubernetes controller<a id="_idIndexMarker1183"/> and toolset, designed to encrypt secrets that can safely be stored in Git repositories. When you apply the sealed secret to your cluster, the Sealed Secrets controller decrypts it and creates a regular Kubernetes secret. This process allows you to manage your secrets’ life cycle through Git without exposing the <span class="No-Break">sensitive content.</span></p>
			<p>Use it <span class="No-Break">as follows:</span></p>
			<ol>
				<li><strong class="bold">Deployment</strong>: Deploy the Sealed Secrets<a id="_idIndexMarker1184"/> controller in your Kubernetes cluster via GitOps and install the <strong class="source-inline">kubeseal</strong> CLI tool on your local machine, <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">helm repo add sealed-secrets https://bitnami-</strong>    <strong class="bold">labs.github.io/sealed-secrets</strong>
<strong class="bold">helm install sealed-secrets sealed-secrets/sealed-secrets</strong>
<strong class="bold">#Install e.g. CLI on MacOS</strong>
<strong class="bold">brew install kubeseal</strong></pre></li>				<li><strong class="bold">Key-pair</strong>: Generate a key-pair or use the certificate from the deployed Sealed <span class="No-Break">Secrets Operator:</span><pre class="source-code">
<strong class="bold">kubectl -n sealed-secrets get secret sealed-secrets-… -o json -o=jsonpath="{.data.tls\.crt}" | base64 -d &gt; sealed-secret.crt</strong></pre></li>				<li><strong class="bold">Sealing Secrets</strong>: Use the kubeseal CLI to encrypt your secret. The CLI generates a <em class="italic">SealedSecret</em> resource, which you can commit to your <span class="No-Break">Git repository:</span><pre class="source-code">
<strong class="bold">kubectl create secret generic my-secret --from-literal=password='myStrongPassword' --dry-run=client -o json | kubeseal --cert sealed-secret.crt &gt; mysealedsecret.yaml</strong></pre></li>				<li><strong class="bold">Applying Sealed Secrets</strong>: Commit <strong class="source-inline">mysealedsecret.yaml</strong> to your Git repository. When you apply this file to your cluster, the Sealed Secrets controller decrypts it and creates a standard <span class="No-Break">Kubernetes secret.</span></li>
				<li><strong class="bold">Automation with GitOps</strong>: Integrate this process<a id="_idIndexMarker1185"/> into your GitOps workflows. Whenever you update your sealed secrets in Git, your CI/CD pipeline can automatically apply them to <span class="No-Break">your cluster.</span></li>
			</ol>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor264"/>External Secrets</h2>
			<p>External Secrets [<em class="italic">3</em>] is an open source project<a id="_idIndexMarker1186"/> that integrates external<a id="_idIndexMarker1187"/> secret management systems such as <strong class="bold">AWS Secrets Manager</strong>, <strong class="bold">Azure Key Vault</strong>, and <strong class="bold">Google Secret Manager</strong> with Kubernetes. It allows<a id="_idIndexMarker1188"/> you to securely<a id="_idIndexMarker1189"/> inject secrets into your applications without having to expose them in your <span class="No-Break">Git repositories.</span></p>
			<p>Use it <span class="No-Break">as follows:</span></p>
			<ol>
				<li><strong class="bold">Deployment</strong>: Deploy the External Secrets Operator<a id="_idIndexMarker1190"/> in your <span class="No-Break">Kubernetes cluster:</span><pre class="source-code">
helm repo add external-secrets https://charts.external-secrets.io
helm install external-secrets external-secrets/external-secrets</pre></li>				<li><strong class="bold">Configuration</strong>: Define an <em class="italic">ExternalSecret</em> resource that specifies the external secret store and the secret key. The operator fetches the secret from the external store and creates a Kubernetes secret in <span class="No-Break">the cluster:</span><pre class="source-code">
   apiVersion: external-secrets.io/v1beta1
   kind: ExternalSecret
   metadata:
     name: my-external-secret
   spec:
     secretStoreRef:
       name: my-secret-store
       kind: SecretStore
     target:
       name: my-kubernetes-secret
     data:
     - secretKey: external-secret-key
       remoteRef:
         key: name-of-the-secret-in-external-store</pre></li>				<li><strong class="bold">Applying External Secrets</strong>: Commit the <em class="italic">ExternalSecret</em> resource to your Git repository. The External Secrets Operator will automatically create or update the Kubernetes secret in your cluster based on the <span class="No-Break">external source.</span></li>
				<li><strong class="bold">Integration with GitOps</strong>: Incorporate External Secrets into your GitOps pipelines. Changes to the <em class="italic">ExternalSecret</em> definitions in your Git repo trigger the operator to sync<a id="_idIndexMarker1191"/> the secrets, ensuring your cluster’s secrets are <span class="No-Break">always up-to-date.</span></li>
			</ol>
			<p>The choice of tools depends on various factors. For instance, if you don’t have a vault for storing secrets, keys, or certificates, then External Secrets might not be suitable. Initially, a connection from the External Secrets Operator<a id="_idIndexMarker1192"/> to the Secret Store or <strong class="bold">ClusterSecretStore</strong> must be established. In our projects, we utilize managed identities to ensure this. Otherwise, you typically need an ID and a secret, which can be challenging to manage securely with GitOps at scale, as the ID and secret must be securely transferred to the cluster, possibly through a CI/CD pipeline. A significant advantage of External Secrets is its ability to fetch secrets at runtime without dependency on <span class="No-Break">the cluster.</span></p>
			<p>However, access to a secrets manager through a vault is not always available. Therefore, the Sealed Secrets Operator, particularly in on-premises environments, is currently considered the <span class="No-Break">industry standard.</span></p>
			<p>Teams need to decide which option is the better choice. In my opinion, both options are solid and integrate very well into the GitOps ecosystem. This not only allows for the secure storage of secrets, keys, and certificates while embracing the GitOps approach but also opens up entirely new possibilities with GitOps at scale, such as deploying a pull secret across a specific registry. The platform team, by combining External Secrets and Kyverno, can deploy a secret across all clusters, and Kyverno distributes it across the namespaces. As a result, every team has the pull secret necessary to pull images from a central image registry. This enhances security since every image can be subjected to scanning, and it provides an overview of the images <span class="No-Break">in operation.</span></p>
			<p>By leveraging Sealed Secrets<a id="_idIndexMarker1193"/> and External Secrets, you can maintain the GitOps principle of storing all configurations in Git while securely managing your secrets. These tools help you automate the management of secrets, keeping your infrastructure secure and your <span class="No-Break">deployments consistent.</span></p>
			<p>Every tool that is added to the Kubernetes Service Catalog increases the likelihood that more security vulnerabilities will be introduced into the system. We will look at how to maintain your catalog<a id="_idIndexMarker1194"/> in the <span class="No-Break">next section.</span></p>
			<p>In the following section, we will delve into enhancing security through GitOps and a <strong class="bold">policy engine</strong>. This approach enables proactive measures during deployment, determining what is permissible to deploy and identifying associated risks. This preemptive strategy ensures that only secure, compliant configurations make their way into production, thereby reinforcing your <span class="No-Break">security posture.</span></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor265"/>Leveraging a policy engine for policy-as-code practices</h1>
			<p>In the contemporary landscape<a id="_idIndexMarker1195"/> of software development, the way we ensure security and compliance within our systems has significantly evolved. A pivotal aspect of this evolution is the adoption of policy-as-code practices, which enable the integration of governance and security policies directly into the development and operational processes. Within this context, policy<a id="_idIndexMarker1196"/> engines such as Kyverno [<em class="italic">4</em>] and <strong class="bold">Open Policy Agent</strong> (<strong class="bold">OPA</strong>) [<em class="italic">5</em>] play a crucial role. These tools empower organizations to define and enforce their security, compliance, and governance requirements as code, thereby ensuring consistent application and transparency across their infrastructures <span class="No-Break">and applications.</span></p>
			<p>Kyverno and OPA are both powerful, flexible tools designed specifically to implement policy as code in Kubernetes environments and beyond. Kyverno focuses on simplifying Kubernetes security by using a user-friendly, Kubernetes-native syntax that allows developers to define and enforce security policies directly within their CI/CD pipelines. On the other hand, OPA is a more general-purpose policy engine that employs a highly<a id="_idIndexMarker1197"/> flexible, domain-agnostic language called <strong class="bold">Rego</strong>, enabling the creation and implementation of fine-grained, context-aware policies across a variety of <span class="No-Break">software systems.</span></p>
			<p>Integrating these policy engines into a GitOps-based workflow architecture significantly enhances security, as it ensures the continuous enforcement and validation of compliance. By adopting GitOps, teams can manage their infrastructure and application setups as code, creating a versioned, repeatable, and automatable environment. Incorporating Kyverno or OPA into this process means that changes to infrastructure or applications are automatically validated against predefined policies before being implemented. This ensures that all deployments comply with organizational security standards and that potential security vulnerabilities or configuration errors are proactively<a id="_idIndexMarker1198"/> identified and remediated before they impact the <span class="No-Break">production environment.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor266"/>Integrating Kyverno and OPA</h2>
			<p>In this part, we explore <a id="_idIndexMarker1199"/>how integrating tools<a id="_idIndexMarker1200"/> such as Kyverno and OPA into the development and operational workflow not only enhances security and compliance but also promotes efficiency and speed in development cycles. <em class="italic">Automating</em> policy enforcement within the GitOps framework allows teams to deliver faster and more securely, leading to more robust, secure applications <span class="No-Break">and infrastructures.</span></p>
			<p>We will focus on Kyverno to facilitate a better understanding, as I believe it’s a tool that users can comprehend more easily without the need to learn Rego. However, before delving into that, let’s examine the layer at which Kyverno operates and its integration with GitOps. <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.3</em> will elaborate on <span class="No-Break">these subjects:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer175">
					<img alt="Figure 13.3 – Kyverno operation layer and GitOps" src="image/B22100_13_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Kyverno operation layer and GitOps</p>
			<p>As illustrated, Kyverno operates across both layers, effectively acting as a gatekeeper. When you attempt to deploy something that violates its rules, Kyverno intervenes, causing the deployment to fail. However, Kyverno’s capabilities extend beyond this; it can also validate already-running services within the Kubernetes cluster or mutate resources. This versatility justifies positioning Kyverno between these layers, making it an <span class="No-Break">advantageous choice.</span></p>
			<p>Leveraging GitOps, you can deploy the Kyverno instance across every cluster in the fleet, ensuring consistent policy enforcement. Additionally, the <em class="italic">define once, deploy everywhere</em> approach facilitates multi-cluster deployment, streamlining the management of policies across various environments. By collaborating with the security team, you can implement<a id="_idIndexMarker1201"/> different rulesets<a id="_idIndexMarker1202"/> tailored to specific environments, enhancing the security and compliance of your deployments. This synergy between Kyverno and GitOps not only simplifies governance but also fortifies the infrastructure’s overall <span class="No-Break">security posture.</span></p>
			<p>Now, let’s look at how it works in <span class="No-Break">the praxis.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor267"/>Hands on – let’s put theory into practice <em class="italic">[6]</em></h2>
			<p>First, we establish a streamlined <a id="_idIndexMarker1203"/>folder structure for the Kubernetes Service Catalog, as in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
.
├── applicationsets
│   └── security
│       └── kyverno-applicationset.yaml
├── kustomize
│   └── security
│       └── kyverno
│           └── policies
│               └── base
│                   ├── disallow-latest-tag.yaml
│                   ├── kustomization.yaml
│                   └── restrict-nodeport.yaml
└── security
    └── kyverno
        ├── Chart.yaml
        └── values.yaml</pre>			<p>By initiating the deployment of <strong class="source-inline">kyverno-applicationset.yaml</strong>, you will target every fleet cluster identified by the <strong class="source-inline">env=prod</strong> or <strong class="source-inline">env=development</strong> labels. This deployment not only sets up the Kyverno tool across these clusters but also applies a specific set of policies from the <strong class="source-inline">kustomize</strong> folder to each one. In our illustration, we utilize a basic base folder; however, you have the flexibility to configure distinct folders – for instance, for different stages. These can be aligned with the cluster labels, enabling you to deploy the appropriate ruleset to the corresponding cluster. Such an arrangement proves beneficial for implementing more lenient policies in development clusters and stricter ones in <span class="No-Break">production environments.</span></p>
			<p>Now, let’s examine an example policy<a id="_idIndexMarker1204"/> that will be deployed across every fleet cluster matching the specified labels. We’ll focus on the <span class="No-Break"><strong class="source-inline">disallow-latest-tag.yaml</strong></span><span class="No-Break"> policy.</span></p>
			<p>In the first part, we see the annotations, the <strong class="source-inline">Best Practices</strong> category, and then the version, the severity classification, which subject is affected, and the description of which negative consequences can result from it. I find it nice and compact, clear, and easy <span class="No-Break">to configure:</span></p>
			<pre class="source-code">
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: disallow-latest-tag-example
  annotations:
    policies.kyverno.io/title: Disallow Latest Tag Example
    policies.kyverno.io/category: Best Practices
    policies.kyverno.io/minversion: 1.6.0
    policies.kyverno.io/severity: medium
    policies.kyverno.io/subject: Pod
    policies.kyverno.io/description: &gt;-
      The ':latest' tag is mutable and can lead to unexpected errors if the
      image changes.. This policy validates that the image
      specifies a tag and that it is not called `latest`.</pre>			<p>In the subsequent section under specifications, we observe that the action is designated as <strong class="source-inline">Audit</strong> rather than <strong class="source-inline">Enforce</strong>, implying that it is not compulsory. Following this, two rules are established. The initial rule conducts a validation of the container’s tag using the <strong class="source-inline">*:*</strong> pattern, ensuring it adheres to specific criteria. Subsequently, the second rule escalates to the resource level, applying a broader scope by targeting the pods directly. It stipulates a constraint that the pattern with the <strong class="source-inline">latest</strong> tag must not be used, reinforcing<a id="_idIndexMarker1205"/> the governance over the <span class="No-Break">deployment practices:</span></p>
			<pre class="source-code">
spec:
  validationFailureAction: Audit
  background: true
  rules:
    - name: require-image-tag
      match:
        any:
          - resources:
              kinds:
                - Pod
      validate:
        message: "An image tag is required."
        pattern:
          spec:
            containers:
              - image: "*:*"
    - name: validate-image-tag
      match:
        any:
          - resources:
              kinds:
                - Pod
      validate:
        message: "Using a mutable image tag e.g. 'latest' is not allowed."
        pattern:
          spec:
            containers:
              - image: "!*:latest"</pre>			<p>In practice, it looks like this: when the rule<a id="_idIndexMarker1206"/> is applied and an attempt is made to deploy a pod and its contained container with the <strong class="source-inline">latest</strong> tag, the deployment is blocked. Let’s try to deploy a Nginx pod with the <strong class="source-inline">latest</strong> <span class="No-Break">image tag:</span></p>
			<pre class="source-code">
kubectl run nginx --image nginx:latest</pre>			<p>Now you can get a Kyverno <strong class="source-inline">policyreport</strong> like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
kubectl get policyreport fbe08ffd-bee6-497f-aee8-f96e9cd022f8  -n default -o yaml | grep image -A 8</pre>			<p>The output should be like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
- category: Best Practices
  message: 'validation error: Using a mutable image tag e.g. ''latest'' is not allowed.
    rule validate-image-tag failed at path /spec/containers/0/image/'
  policy: disallow-latest-tag
  result: fail
  rule: validate-image-tag
  scored: true
  severity: medium
  source: kyverno</pre>			<p>As you can see, we violated the best practices policy, specifically the <span class="No-Break"><strong class="source-inline">disallow-latest-tag</strong></span><span class="No-Break"> policy.</span></p>
			<p>I refer to this setup as a gatekeeper because it allows you to dictate, through simple rules, what can and cannot be deployed into the cluster. However, the capabilities of this setup extend further. For instance, you can configure Kyverno policies to enforce image signing or to ensure that only images from certain registries are allowed to be pulled, among other things. A policy engine is a powerful tool. In contrast to the gatekeeper, Kyverno or OPA also operates on already-deployed resources or resources that passed the gate and are therefore placed between the two layers, as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<p>When combined with the GitOps approach, it opens up new possibilities that transcend team boundaries, enhancing the security of projects. This integration not only streamlines the deployment processes but also ensures that the operational standards are consistently met, thereby bolstering<a id="_idIndexMarker1207"/> the overall security posture of <span class="No-Break">the infrastructure.</span></p>
			<p>In the next section, we will look at how to increase security on two different layers using two <span class="No-Break">different tools.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor268"/>Automating security scanning and compliance</h1>
			<p>In today’s fast-paced and security-conscious IT<a id="_idIndexMarker1208"/> environment, maintaining continuous security and compliance is crucial. Automated security scanning and compliance are integral components of a robust cybersecurity strategy, especially in Kubernetes clusters where applications and services are dynamically scaled and updated. Here, we’ll <a id="_idIndexMarker1209"/>discuss how the <strong class="bold">KubeClarity</strong> [<em class="italic">7</em>] or <strong class="bold">Falco</strong> [<em class="italic">8</em>] tool can be utilized to enhance<a id="_idIndexMarker1210"/> your security posture in Kubernetes environments. The following image illustrates the level at which <span class="No-Break">KubeClarity operates:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer176">
					<img alt="Figure 13.4 – KubeClarity operation layer" src="image/B22100_13_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – KubeClarity operation layer</p>
			<p>KubeClarity is an open source tool designed<a id="_idIndexMarker1211"/> for security scanning and compliance analysis in Kubernetes environments. It provides a comprehensive overview of the potential vulnerabilities<a id="_idIndexMarker1212"/> in your container images and <span class="No-Break">Kubernetes configurations.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor269"/>KubeClarity</h2>
			<p>Let’s first understand<a id="_idIndexMarker1213"/> how KubeClarity <span class="No-Break">enhances security:</span></p>
			<ul>
				<li><strong class="bold">Vulnerability scanning</strong>: KubeClarity scans container images for known vulnerabilities, utilizing various databases and vulnerability tracking sources. It provides detailed insights into the security flaws within your images, along with their severity levels, enabling you to <span class="No-Break">prioritize fixes.</span></li>
				<li><strong class="bold">Compliance assurance</strong>: The tool checks your Kubernetes configurations against best practices and compliance standards, ensuring that your deployments adhere to industry and organizational <span class="No-Break">security policies.</span></li>
				<li><strong class="bold">Continuous monitoring</strong>: KubeClarity continuously monitors your containerized applications for new vulnerabilities, providing real-time alerts and updates. This ongoing<a id="_idIndexMarker1214"/> vigilance helps maintain a secure <span class="No-Break">Kubernetes environment.</span></li>
			</ul>
			<p>By integrating KubeClarity within a GitOps framework, an organization can significantly enhance its security and compliance posture, ensuring that its Kubernetes clusters are fortified against evolving threats. This adoption of GitOps principles allows for the automation of security scans and compliance checks, making these processes more consistent, efficient, and scalable. The proactive approach to security facilitated by KubeClarity not only protects your infrastructure but also fosters trust with customers by demonstrating a commitment to maintaining a secure and compliant environment. The continuous monitoring and automatic alignment with security policies enabled by GitOps ensure that any deviations are quickly detected and rectified, maintaining a robust defense against <span class="No-Break">potential vulnerabilities.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor270"/>Falco</h2>
			<p>Falco is an open source tool for real-time<a id="_idIndexMarker1215"/> security monitoring and analysis, specifically designed for Kubernetes environments. It functions<a id="_idIndexMarker1216"/> as an <strong class="bold">intrusion detection system</strong> (<strong class="bold">IDS</strong>), enabling teams to detect anomalous activities in their applications and infrastructures that could indicate security breaches or other threats. The following picture illustrates the level at which <span class="No-Break">Falco operates.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer177">
					<img alt="Figure 13.5 – Falco operation layer" src="image/B22100_13_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Falco operation layer</p>
			<p>Falco operates at the system level (<span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.5</em>), monitoring the underlying Linux kernel functionality, or more precisely, the system-level activities of container orchestration platforms. It utilizes Linux<a id="_idIndexMarker1217"/> kernel capabilities, particularly <strong class="bold">extended BPF</strong> (<strong class="bold">Berkeley Packet Filter</strong>) or traditional <strong class="bold">system calls</strong> (<strong class="bold">syscalls</strong>) monitoring through a kernel<a id="_idIndexMarker1218"/> module, to observe and analyze system-wide events in real time. Falco can capture and evaluate<a id="_idIndexMarker1219"/> system calls from applications running inside containers, identifying unusual or <span class="No-Break">undesirable behavior.</span></p>
			<p>The advantages of integrating<a id="_idIndexMarker1220"/> Falco with GitOps are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Automated security monitoring</strong>: By integrating Falco into a GitOps pipeline, security policies can be defined as code and automatically applied to every change in the infrastructure or applications, enabling continuous and automated monitoring of <span class="No-Break">security standards.</span></li>
				<li><strong class="bold">Real-time alerts</strong>: Falco can be configured to send real-time alerts when a defined rule is violated. In a GitOps environment, these alerts can facilitate swift responses to potential <span class="No-Break">security incidents.</span></li>
				<li><strong class="bold">Consistency and compliance</strong>: With GitOps, Falco configurations can be versioned, reviewed, and automatically deployed, ensuring consistent enforcement of security policies across <span class="No-Break">different environments.</span></li>
				<li><strong class="bold">Transparency and traceability:</strong> All changes to Falco policies are recorded in Git, providing a clear audit trail. This promotes transparency regarding security monitoring and facilitates compliance with <span class="No-Break">regulatory requirements.</span></li>
			</ul>
			<p>Integrating Falco into the GitOps strategy allows teams not only to enhance their security posture but also to adopt a proactive approach to identifying and responding to security threats in their <span class="No-Break">Kubernetes environment.</span></p>
			<p>However, every tool also brings potential risks with it, even if it is intended to increase security, which is why maintenance should not be neglected and attention should be paid to this when designing or selecting the tools. This is exactly what we will discuss briefly in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor271"/>Keeping your platform catalog up-to-date</h1>
			<p>The content of this section<a id="_idIndexMarker1221"/> has been extensively covered already in <a href="B22100_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> under the <em class="italic">Bonus – maintenance with GitOps at scale and KSC</em> section. It serves as a reminder that with every tool added, the catalog grows, and a keen focus on security should <span class="No-Break">be maintained.</span></p>
			<p>When a <strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVE</strong>) threat is revealed and you opt for the Cockpit<a id="_idIndexMarker1222"/> and Fleet approach, adopting GitOps at scale also facilitates a vulnerability-management-at-scale strategy. Therefore, this aspect should be considered particularly early in the development of <span class="No-Break">a concept.</span></p>
			<p>Implementing such a strategy ensures that as your infrastructure expands, your approach to handling vulnerabilities scales accordingly. This proactive stance helps in quickly addressing security issues across the entire fleet, maintaining the integrity and security of your systems. Early integration of these practices into your conceptual framework is crucial to establishing a robust, scalable, and <span class="No-Break">secure infrastructure.</span></p>
			<p>To conclude the chapter, <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.6</em> illustrates the stages or gates that the packet (application or service) must pass through, highlighting where various security mechanisms can intervene to scan the packet as thoroughly <span class="No-Break">as possible:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer178">
					<img alt="Figure 13.6 – Security on multiple layers" src="image/B22100_13_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Security on multiple layers</p>
			<p>Nevertheless, a packet might pass through certain stages, hence the necessity for tools such as Falco and Kyverno to enable continuous scanning. These tools thrive on defined rules, which, fortunately, can be easily<a id="_idIndexMarker1223"/> deployed <span class="No-Break">with GitOps.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor272"/>Summary</h1>
			<p>In this chapter, it should have become clear that security doesn’t operate on just a single layer and shouldn’t be enforced by just one team. Security is a cultural issue that can be expanded with approaches such as GitOps and tools such as Argo CD at scale, which can include defining rulesets or policies. Security doesn’t stop with tools; it also encompasses how one handles sensitive data such as secrets and keeps third-party tools in the ecosystem up-to-date and secure. Effective security practices require collaboration across teams, continuous monitoring, and proactive management to ensure a robust and <span class="No-Break">resilient infrastructure.</span></p>
			<p>In the next chapter, we’ll explore the integration of FinOps with GitOps to achieve sustainable, cost-effective operations. We’ll cover core FinOps principles, cost forecasting, optimization, and understanding the carbon footprint. Additionally, we’ll look at future trends in GitOps, including <span class="No-Break">AI-driven automation.</span></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor273"/>References</h1>
			<ul>
				<li>[<span class="No-Break">1] </span><a href="https://github.com/argoproj/"><span class="No-Break">https://github.com/argoproj/</span></a></li>
				<li>[<span class="No-Break">2] </span><a href="https://github.com/bitnami-labs/sealed-secrets"><span class="No-Break">https://github.com/bitnami-labs/sealed-secrets</span></a></li>
				<li>[<span class="No-Break">3] </span><a href="https://external-secrets.io/latest/"><span class="No-Break">https://external-secrets.io/latest/</span></a></li>
				<li>[<span class="No-Break">4] </span><a href="https://kyverno.io"><span class="No-Break">https://kyverno.io</span></a></li>
				<li>[<span class="No-Break">5] </span><a href="https://www.openpolicyagent.org"><span class="No-Break">https://www.openpolicyagent.org</span></a></li>
				<li>[<span class="No-Break">6] </span><a href="https://github.com/PacktPublishing/GitOps-for-Kubernetes-Deployment/tree/main/chapter13"><span class="No-Break">https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes/tree/main/chapter13</span></a></li>
				<li>[<span class="No-Break">7] </span><a href="https://github.com/openclarity/kubeclarity"><span class="No-Break">https://github.com/openclarity/kubeclarity</span></a></li>
				<li>[<span class="No-Break">8] </span><a href="https://falco.org"><span class="No-Break">https://falco.org</span></a></li>
			</ul>
		</div>
	</body></html>