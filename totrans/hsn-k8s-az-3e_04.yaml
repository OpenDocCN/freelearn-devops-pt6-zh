- en: 1\. Introduction to containers and Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 容器和 Kubernetes 简介
- en: Kubernetes has become the leading standard in container orchestration. Since
    its inception in 2014, Kubernetes has gained tremendous popularity. It has been
    adopted by start-ups as well as major enterprises, with all major public cloud
    vendors offering a managed Kubernetes service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 已经成为容器编排的领先标准。自2014年推出以来，Kubernetes 已经获得了极大的流行。它被初创企业和主要企业广泛采用，所有主要的公共云供应商都提供了托管的
    Kubernetes 服务。
- en: Kubernetes builds upon the success of the Docker container revolution. Docker
    is both a company and the name of a technology. Docker as a technology is the
    most common way of creating and running software containers, called Docker containers.
    A container is a way of packaging software that makes it easy to run that software
    on any platform, ranging from your laptop to a server in a datacenter to a cluster
    running in the public cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 建立在 Docker 容器革命的成功基础之上。Docker 既是一个公司，也是一种技术。作为一种技术，Docker 是创建和运行软件容器（称为
    Docker 容器）的最常见方式。容器是一种打包软件的方式，使得能够在任何平台上运行这些软件，从您的笔记本电脑到数据中心的服务器，再到公共云中运行的集群。
- en: Although the core technology is open source, the Docker company focuses on reducing
    complexity for developers through a number of commercial offerings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管核心技术是开源的，Docker 公司专注于通过多种商业提供来简化开发者的复杂性。
- en: Kubernetes takes containers to the next level. Kubernetes is a container orchestrator.
    A container orchestrator is a software platform that makes it easy to run many
    thousands of containers on top of thousands of machines. It automates a lot of
    the manual tasks required to deploy, run, and scale applications. The orchestrator
    takes care of scheduling the right container to run on the right machine. It also
    takes care of health monitoring and failover, as well as scaling your deployed
    application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 将容器技术推向了新的高度。Kubernetes 是一个容器编排器。容器编排器是一个软件平台，使得在成千上万台机器上运行成千上万个容器变得非常容易。它自动化了部署、运行和扩展应用程序所需的许多手动任务。编排器负责在正确的机器上调度正确的容器运行。它还负责健康监控、故障转移以及扩展您部署的应用程序。
- en: The container technology Docker uses and Kubernetes are both open-source software
    projects. Open-source software allows developers from many companies to collaborate
    on a single piece of software. Kubernetes itself has contributors from companies
    such as Microsoft, Google, Red Hat, VMware, and many others.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使用的容器技术和 Kubernetes 都是开源软件项目。开源软件允许来自多家公司的开发者共同协作开发单一软件。Kubernetes 本身有来自微软、谷歌、红帽、VMware
    等公司的贡献者。
- en: The three major public cloud platforms—Azure, **Amazon Web Services** (**AWS**),
    and **Google Cloud Platform** (**GCP**)—all offer a managed Kubernetes service.
    They attract a lot of interest in the market since the virtually unlimited compute
    power and the ease of use of these managed services make it easy to build and
    deploy large-scale applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 三大公共云平台——Azure，**亚马逊网络服务**（**AWS**），以及**谷歌云平台**（**GCP**）——都提供了托管的 Kubernetes
    服务。这些托管服务因其几乎无限的计算能力和易用性而在市场上引起了极大的关注，使得构建和部署大规模应用变得非常容易。
- en: '**Azure Kubernetes Service** (**AKS**) is Azure''s managed service for Kubernetes.
    It reduces the complexity of building and managing Kubernetes clusters. In this
    book, you will learn how to use AKS to run your applications. Each chapter will
    introduce new concepts, which you will apply through the many examples in this
    book.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Kubernetes 服务**（**AKS**）是 Azure 的 Kubernetes 托管服务。它降低了构建和管理 Kubernetes
    集群的复杂性。在本书中，您将学习如何使用 AKS 来运行您的应用程序。每一章都将介绍新的概念，并通过本书中的许多示例进行应用。'
- en: As a user, however, it is still very useful to understand the technologies that
    underpin AKS. We will explore these foundations in this chapter. You will learn
    about Linux processes and how they are related to Docker and containers. You will
    see how various processes fit nicely into containers and how containers fit nicely
    into Kubernetes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为用户，了解支持 AKS 的技术仍然非常有用。我们将在本章中探讨这些基础知识。您将了解 Linux 进程及其与 Docker 和容器的关系。您将看到各种进程如何很好地适配到容器中，以及容器如何很好地适配到
    Kubernetes 中。
- en: This chapter introduces fundamental Docker concepts so that you can begin your
    Kubernetes journey. This chapter also briefly introduces the basics that will
    help you build containers, implement clusters, perform container orchestration,
    and troubleshoot applications on AKS. Having cursory knowledge of what's in this
    chapter will demystify much of the work needed to build your authenticated, encrypted,
    and highly scalable applications on AKS. Over the next few chapters, you will
    gradually build scalable and secure applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Docker的基础概念，以便你可以开始你的Kubernetes之旅。本章还简要介绍了帮助你构建容器、实现集群、进行容器编排并在AKS上排除故障的基本知识。掌握本章内容的基本知识，将揭开在AKS上构建经过认证、加密和高可扩展性应用所需工作的神秘面纱。在接下来的几章中，你将逐步构建可扩展和安全的应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The software evolution that brought us here
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们带到这里的软件演变
- en: The fundamentals of containers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器基础
- en: The fundamentals of Kubernetes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes基础
- en: The fundamentals of AKS
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AKS基础
- en: The aim of this chapter is to introduce the essentials rather than to provide
    a thorough information source describing Docker and Kubernetes. To begin with,
    we'll first take a look at how software has evolved to get us to where we are
    now.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是介绍基础知识，而不是提供一个详细的信息来源来描述Docker和Kubernetes。首先，我们将回顾软件是如何演变，最终带我们到今天的。
- en: The software evolution that brought us here
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们带到这里的软件演变
- en: There are two major software development evolutions that enabled the popularity
    of containers and Kubernetes. One is the adoption of a microservices architectural
    style. Microservices allow an application to be built from a collection of small
    services that each serve a specific function. The other evolution that enabled
    containers and Kubernetes is DevOps. DevOps is a set of cultural practices that
    allows people, processes, and tools to build and release software faster, more
    frequently, and more reliably.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的软件开发演变使得容器和Kubernetes得以流行。一个是微服务架构风格的采用。微服务允许将一个应用程序构建成由多个小服务组成，每个服务承担一个特定功能。另一个推动容器和Kubernetes发展的演变是DevOps。DevOps是一组文化实践，允许人们、流程和工具更快、更频繁、更可靠地构建和发布软件。
- en: Although you can use both containers and Kubernetes without using either microservices
    or DevOps, the technologies are most widely adopted for deploying microservices
    using DevOps methodologies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在不使用微服务或DevOps的情况下使用容器和Kubernetes，但这些技术最广泛的应用是在采用DevOps方法论的微服务部署中。
- en: In this section, we'll discuss both evolutions, starting with microservices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论这两种演变，从微服务开始。
- en: Microservices
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务
- en: Software development has drastically evolved over time. Initially, software
    was developed and run on a single system, typically a mainframe. A client could
    connect to the mainframe through a terminal, and only through that terminal. This
    changed when computer networks became common when the client-server programming
    model emerged. A client could connect remotely to a server and even run part of
    the application on their own system while connecting to the server to retrieve
    the data the application required.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发随着时间的推移发生了巨大的变化。最初，软件是在单一系统上开发和运行的，通常是大型主机。客户端通过终端连接到主机，并且只能通过该终端连接。随着计算机网络的普及，客户端-服务器编程模型出现了。这时，客户端可以远程连接到服务器，甚至在自己的系统上运行应用程序的一部分，同时连接到服务器获取应用程序所需的数据。
- en: The client-server programming model has evolved toward distributed systems.
    Distributed systems are different from the traditional client-server model as
    they have multiple different applications running on multiple different systems,
    all interconnected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器编程模型已经演变成分布式系统。分布式系统与传统的客户端-服务器模型不同，因为它们在多个不同的系统上运行多个不同的应用程序，并且所有系统都是相互连接的。
- en: Nowadays, a microservices architecture is common when developing distributed
    systems. A microservices-based application consists of a group of services that
    work together to form the application, while the individual services themselves
    can be built, tested, deployed, and scaled independently of each other. The style
    has many benefits but also has several disadvantages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，微服务架构在开发分布式系统时已变得非常常见。基于微服务的应用程序由一组服务组成，这些服务共同协作以构成应用程序，而单独的服务本身可以独立构建、测试、部署和扩展。该风格有许多优点，但也存在一些缺点。
- en: 'A key part of a microservices architecture is the fact that each individual
    service serves one and only one core function. Each service serves a single-bound
    business function. Different services work together to form the complete application.
    Those services work together over network communication, commonly using HTTP REST
    APIs or gRPC:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个关键特点是每个服务只执行一个核心功能。每个服务专注于单一的业务功能。不同的服务协同工作，形成完整的应用程序。这些服务通过网络通信协作，通常使用HTTP
    REST API或gRPC：
- en: '![Evolution from mainframe to client-server, to distributed systems to microservices](img/B17338_01_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![从主机到客户端-服务器，再到分布式系统，再到微服务的演变](img/B17338_01_01.jpg)'
- en: 'Figure 1.1: A standard microservices architecture'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：标准微服务架构
- en: This architectural approach is commonly adopted by applications that run using
    containers and Kubernetes. Containers are used as the packaging format for the
    individual services, while Kubernetes is the orchestrator that deploys and manages
    the different services running together.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构方法通常被容器和Kubernetes运行的应用程序采纳。容器作为单个服务的打包格式，而Kubernetes则是部署和管理多个协同工作的服务的协调器。
- en: Before we dive into container and Kubernetes specifics, let's first explore
    the benefits and downsides of adopting microservices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解容器和Kubernetes的具体内容之前，首先让我们探讨一下采用微服务的优缺点。
- en: Advantages of running microservices
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行微服务的优势
- en: There are several advantages to running a microservices-based application. The
    first is the fact that each service is independent of the other services. The
    services are designed to be small enough (hence micro) to handle the needs of
    a business domain. As they are small, they can be made self-contained and independently
    testable, and so are independently releasable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行基于微服务的应用程序有多个优势。首先，每个服务是独立的。服务被设计得足够小（因此称为微服务），以便能够处理业务领域的需求。由于它们很小，可以将其做成自包含的，并且能够独立测试，因此也可以独立发布。
- en: This leads to the benefit that each microservice is independently scalable as
    well. If a certain part of the application is getting more demand, that part of
    the application can be scaled independently from the rest of the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个好处，即每个微服务都是独立可扩展的。如果某个应用程序的部分需求增加，该部分可以与应用程序的其余部分独立扩展。
- en: The fact that services are independently scalable also means that they are independently
    deployable. There are multiple deployment strategies when it comes to microservices.
    The most popular are rolling deployments and blue/green deployments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的独立可扩展性也意味着它们可以独立部署。微服务有多种部署策略，其中最流行的是滚动部署和蓝绿部署。
- en: With a rolling upgrade, a new version of the service is deployed only to a part
    of the application. This new version is carefully monitored and gradually gets
    more traffic if the service remains healthy. If something goes wrong, the previous
    version is still running, and traffic can easily be cut over.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过滚动升级，新版本的服务只会部署到应用程序的一部分。这个新版本会被仔细监控，如果服务保持健康，逐渐增加流量。如果发生故障，之前的版本仍然在运行，流量可以轻松切换。
- en: With a blue/green deployment, you deploy the new version of the service in isolation.
    Once the new version of the service is deployed and tested, you cut over 100%
    of the production traffic to the new version. This allows for a clean transition
    between service versions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用蓝绿部署时，你将新版本的服务孤立部署。一旦新版本的服务部署并测试完毕，你就将100%的生产流量切换到新版本。这种方法实现了服务版本之间的平滑过渡。
- en: Another benefit of the microservices architecture is that each service can be
    written in a different programming language. This is described as polyglot—the
    ability to understand and use multiple languages. For example, the front-end service
    can be developed in a popular JavaScript framework, the back end can be developed
    in C#, and the machine learning algorithm can be developed in Python. This allows
    you to select the right language for the right service and allows developers to
    use the languages they are most familiar with.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的另一个好处是，每个服务可以用不同的编程语言编写。这被称为**多语言支持**——即能够理解和使用多种语言。例如，前端服务可以使用流行的JavaScript框架开发，后端可以用C#开发，机器学习算法可以用Python开发。这使得你能够为不同的服务选择合适的语言，并让开发人员使用他们最熟悉的语言。
- en: Disadvantages of running microservices
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行微服务的劣势
- en: There's a flip side to every coin, and the same is true for microservices. While
    there are multiple advantages to a microservices-based architecture, this architecture
    has its downsides as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个硬币都有两面，微服务也不例外。尽管基于微服务的架构有多个优点，但这种架构也有其缺点。
- en: Microservices designs and architectures require a high degree of software development
    maturity in order to be implemented correctly. Architects who understand the domain
    very well must ensure that each service is bounded and that different services
    are cohesive. Since services are independent of each other and versioned independently,
    the software contract between these different services is important to get right.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的设计和架构需要较高的软开发成熟度，才能正确实现。对领域有深刻理解的架构师必须确保每个服务是有边界的，且不同服务之间是紧密协作的。由于服务是相互独立的且独立版本化，确保不同服务之间的软合同是非常重要的。
- en: Another common issue with a microservices design is the added complexity when
    it comes to monitoring and troubleshooting such an application. Since different
    services make up a single application, and those different services run on multiple
    servers, both logging and tracing such an application is a complicated endeavor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务设计的另一个常见问题是，监控和排除此类应用程序故障时带来的额外复杂性。由于不同的服务组成了一个应用程序，而这些服务运行在多个服务器上，因此记录日志和追踪此类应用程序是一项复杂的工作。
- en: Linked to the disadvantages mentioned before is that, typically, in microservices,
    you need to build more fault tolerance into your application. Due to the dynamic
    nature of the different services in an application, faults are more likely to
    happen. In order to guarantee application availability, it is important to build
    fault tolerance into the different microservices that make up an application.
    Implementing patterns such as retry logic or circuit breakers is critical to avoid
    a single fault causing application downtime.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前提到的缺点相关的是，通常在微服务中，你需要为应用程序构建更多的容错机制。由于应用程序中不同服务的动态性质，故障更容易发生。为了保证应用程序的可用性，重要的是在构成应用程序的不同微服务中构建容错机制。实现重试逻辑或断路器等模式对于避免单一故障导致应用程序停机至关重要。
- en: In this section, you learned about microservices, their benefits, and their
    disadvantages. Often linked to microservices, but a separate topic, is the DevOps
    movement. We will explore what DevOps means in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了微服务、它们的优点和缺点。微服务通常与DevOps相关，但它是一个独立的主题。我们将在下一节探讨DevOps的含义。
- en: DevOps
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DevOps
- en: 'DevOps literally means the combination of development and operations. More
    specifically, DevOps is the union of people, processes, and tools to deliver software
    faster, more frequently, and more reliably. DevOps is more about a set of cultural
    practices than about any specific tools or implementations. Typically, DevOps
    spans four areas of software development: planning, developing, releasing, and
    operating software.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps字面意思是开发和运维的结合。更具体地说，DevOps是将人员、流程和工具结合起来，以更快、更频繁、更可靠地交付软件。DevOps更多的是一套文化实践，而不是任何特定的工具或实现。通常，DevOps涵盖软件开发的四个领域：规划、开发、发布和运行软件。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Many definitions of DevOps exist. The authors have adopted this definition,
    but you as a reader are encouraged to explore different definitions in the literature
    around DevOps.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps有多种定义。作者采用了这个定义，但作为读者，鼓励你在有关DevOps的文献中探索不同的定义。
- en: The DevOps culture starts with planning. In the planning phase of a DevOps project,
    the goals of a project are outlined. These goals are outlined both at a high level
    (called an epic) and at a lower level (as features and tasks). The different work
    items in a DevOps project are captured in the feature backlog. Typically, DevOps
    teams use an agile planning methodology working in programming sprints. Kanban
    boards are often used to represent project status and to track work. As a task
    changes status from *to do* to *doing* to *done*, it moves from left to right
    on a Kanban board.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps文化从规划开始。在DevOps项目的规划阶段，会明确项目的目标。这些目标既包括高层次的目标（称为史诗），也包括较低层次的目标（如功能和任务）。DevOps项目中的不同工作项会被记录在功能待办事项列表中。通常，DevOps团队采用敏捷规划方法，通过编程冲刺来工作。看板通常用于表示项目状态并跟踪工作。当任务状态从*待办*变为*进行中*再到*已完成*时，它会从看板的左侧移动到右侧。
- en: When work is planned, actual development can be done. Development in a DevOps
    culture isn't only about writing code but also about testing, reviewing, and integrating
    code with team members. A version control system such as Git is used for different
    team members to share code with each other. An automated **continuous integration** (**CI**)
    tool is used to automate most manual tasks such as testing and building code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作被规划好后，实际开发就可以进行。在DevOps文化中的开发不仅仅是编写代码，还包括测试、审查和与团队成员集成代码。版本控制系统，如Git，被用来让不同的团队成员共享代码。自动化的**持续集成**（**CI**）工具被用来自动化大多数手动任务，如测试和构建代码。
- en: When a feature is code-complete, tested, and built, it is ready to be delivered.
    The next phase in a DevOps project can start delivery. A **continuous delivery** (**CD**)
    tool is used to automate the deployment of software. Typically, software is deployed
    to different environments, such as testing, quality assurance, and production.
    A combination of automated and manual gates is used to ensure quality before moving
    to the next environment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个特性完成编码、测试并构建完成后，它就准备好交付了。DevOps项目的下一个阶段可以开始交付。使用**持续交付**（**CD**）工具来自动化软件的部署。通常，软件会部署到不同的环境中，如测试、质量保证和生产环境。在进入下一个环境之前，会使用自动化和手动检查相结合的方式确保质量。
- en: Finally, when a piece of software is running in production, the operations phase
    can start. This phase involves the maintaining, monitoring, and supporting of
    an application in production. The end goal is to operate an application reliably
    with as little downtime as possible. Any issues are to be identified as proactively
    as possible. Bugs in the software will be tracked in the backlog.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当软件在生产环境中运行时，运营阶段可以开始。这个阶段涉及到应用程序在生产中的维护、监控和支持。最终目标是以尽可能少的停机时间，可靠地运营一个应用程序。任何问题都要尽可能主动地进行识别。软件中的漏洞将在待办事项中进行跟踪。
- en: The DevOps process is an iterative process. A single team is never in a single
    phase of the process. The whole team is continuously planning, developing, delivering,
    and operating software.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps过程是一个迭代过程。单个团队永远不会处于过程的某一个单一阶段。整个团队在不断地规划、开发、交付和运营软件。
- en: 'Multiple tools exist to implement DevOps practices. There are point solutions
    for a single phase, such as Jira for planning or Jenkins for CI and CD, as well
    as complete DevOps platforms, such as GitLab. Microsoft operates two solutions
    that enable customers to adopt DevOps practices: Azure DevOps and GitHub. Azure
    DevOps is a suite of services to support all phases of the DevOps process. GitHub
    is a separate platform that enables DevOps software development. GitHub is known
    as the leading open-source software development platform, hosting over 40 million
    open-source projects.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种工具来实施DevOps实践。有针对单一阶段的工具，例如用于规划的Jira，或用于持续集成和持续交付的Jenkins，以及完整的DevOps平台，如GitLab。微软运营着两个使客户能够采用DevOps实践的解决方案：Azure
    DevOps和GitHub。Azure DevOps是一个支持DevOps过程所有阶段的服务套件。GitHub是一个独立的平台，用于支持DevOps软件开发。GitHub被公认为领先的开源软件开发平台，托管着超过4000万个开源项目。
- en: Both microservices and DevOps are commonly used in combination with containers
    and Kubernetes. Now that we've had this introduction to microservices and DevOps,
    we'll continue this first chapter with the fundamentals of containers and then
    the fundamentals of Kubernetes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和DevOps通常与容器和Kubernetes结合使用。现在我们已经了解了微服务和DevOps的基本概念，我们将继续本章的内容，介绍容器的基本概念，接着是Kubernetes的基本概念。
- en: Fundamentals of containers
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器基础
- en: A form of container technology has existed in the Linux kernel since the 1970s.
    The technology powering today's containers, called **cgroups** (abbreviated from
    **control groups**), was introduced into the Linux kernel in 2006 by Google. The
    Docker company popularized the technology in 2013 by introducing an easy developer
    workflow. Although the name Docker can refer to both the company as well as the
    technology, most commonly, though, we use Docker to refer to the technology.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一种容器技术自1970年代以来就存在于Linux内核中。今天容器背后的技术被称为**cgroups**（**控制组**的缩写），它在2006年由Google引入到Linux内核中。Docker公司在2013年通过引入一种简便的开发者工作流程，使这一技术普及开来。虽然“Docker”一词可以指代公司或技术，但通常我们用Docker指的是技术本身。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意事项
- en: Although the Docker technology is a popular way to build and run containers,
    it is not the only way to build and run them. Many alternatives exist for either
    building or running containers. One of those alternatives is containerd, which
    is a container runtime also used by Kubernetes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Docker as a technology is both a packaging format and a container runtime. Packaging
    is a process that allows an application to be packaged together with its dependencies,
    such as binaries and runtime. The runtime points at the actual process of running
    the container images.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important pieces in Docker''s architecture: the client, the
    daemon, and the registry:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client is a client-side tool that you use to interact with the Docker
    daemon, running locally or remotely.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker daemon is a long-running process that is responsible for building
    container images and running containers. The Docker daemon can run on either your
    local machine or a remote machine.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Docker registry is a place to store Docker images. There are public registries
    such as Docker Hub that contain public images, and there are private registries
    such as **Azure Container Registry** (**ACR**) that you can use to store your
    own private images. The Docker daemon can pull images from a registry if images
    are not available locally:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Three important componentsin Docker architecture: the client, the daemon,
    and the registry](img/B17338_01_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Fundamentals of Docker architecture'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with Docker by creating a free Docker account at Docker Hub
    ([https://hub.docker.com/](https://hub.docker.com/)) and using that login to open
    Docker Labs ([https://labs.play-with-docker.com/](https://labs.play-with-docker.com/)).
    This will give you access to an environment with Docker pre-installed that is
    valid for 4 hours. We will be using Docker Labs in this section as we build our
    own container and image.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although we are using the browser-based Docker Labs in this chapter to introduce
    Docker, you can also install Docker on your local desktop or server. For workstations,
    Docker has a product called Docker Desktop ([https://www.docker.com/products/docker-desktop](https://azure.microsoft.com/resources/designing-distributed-systems/))
    that is available for Windows and Mac to create Docker containers locally. On
    servers—both Windows and Linux—Docker is also available as a runtime for containers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Container images
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To start a new container, you need an image. An image contains all the software
    you need to run within your container. Container images can be stored locally
    on your machine, as well as in a container registry. There are public registries,
    such as the public Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)),
    or private registries, such as ACR. When you, as a user, don't have an image locally
    on your PC, you can pull an image from a registry using the `docker pull` command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will pull an image from the public Docker Hub
    repository and run the actual container. You can run this example in Docker Labs,
    which we introduced in the previous section, by following these instructions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将从公共Docker Hub仓库拉取一个镜像并运行实际的容器。你可以按照这些说明在Docker Labs中运行这个示例，正如我们在上一节中介绍的那样：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of these commands will look similar to *Figure 1.3*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的输出将类似于*图 1.3*：
- en: '![Pulling an image from the public Docker Hub repository and running the actual
    container](img/B17338_01_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![从公共Docker Hub仓库拉取镜像并运行实际的容器](img/B17338_01_03.jpg)'
- en: 'Figure 1.3: An example of running containers in Docker Labs'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：在 Docker Labs 中运行容器的示例
- en: What happened here is that Docker first pulled your image in multiple parts
    and stored it locally on the machine it was running on. When you ran the actual
    application, it used that local image to start a container. If we look at the
    commands in detail, you will see that `docker pull` took in a single parameter, `docker/whalesay`.
    If you don't provide a private container registry, Docker will look in the public
    Docker Hub for images, which is where Docker pulled this image from. The `docker
    run` command took in a couple of arguments. The first argument was `docker/whalesay`,
    which is the reference to the image. The next two arguments, `cowsay boo`, are
    commands that were passed to the running container to execute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，Docker首先将镜像分多个部分拉取并存储在运行它的机器上。当你运行实际的应用程序时，它使用这个本地镜像来启动一个容器。如果我们详细查看命令，你会看到`docker
    pull`接受了一个参数，`docker/whalesay`。如果没有提供私有容器仓库，Docker会在公共的Docker Hub中查找镜像，正是Docker从这里拉取了这个镜像。`docker
    run`命令接受了几个参数，第一个参数是`docker/whalesay`，即镜像的引用。接下来的两个参数，`cowsay boo`，是传递给正在运行的容器执行的命令。
- en: In the previous example, you learned that it is possible to run a container
    without building an image first. It is, however, very common that you will want
    to build your own images. To do this, you use a Dockerfile. A Dockerfile contains
    steps that Docker will follow to start from a base image and build your image.
    These instructions can range from adding files to installing software or setting
    up networking.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你学习了如何在不先构建镜像的情况下运行容器。然而，通常你会想要构建自己的镜像。为此，你需要使用一个Dockerfile。Dockerfile包含了一系列Docker会按照步骤来构建镜像的指令。这些指令可以包括从添加文件到安装软件或设置网络等操作。
- en: 'In the next example, you will build a custom Docker image. This custom image
    will display inspirational quotes in the whale output. The following Dockerfile
    will be used to generate this custom image. You will create it in your Docker
    playground:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，你将构建一个自定义Docker镜像。这个自定义镜像将在鲸鱼输出中显示励志名言。以下的Dockerfile将用于生成这个自定义镜像。你将在你的Docker练习环境中创建它：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are four lines in this Dockerfile. The first one will instruct Docker
    on which image to use as a source image for this new image. The next two steps
    are commands that are run to add new functionality to our image, in this case,
    updating your `apt` repository and installing an application called `fortunes`.
    The `fortunes` application is a small command-line tool that generates inspirational
    quotes. We will use that to include quotes in the output rather than user input.
    Finally, the `CMD` command tells Docker which command to execute when a container
    based on this image is run.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile包含四行指令。第一行会告诉Docker使用哪个镜像作为新镜像的基础镜像。接下来的两行是运行命令，用于向镜像添加新功能，在这个例子中是更新`apt`仓库并安装一个名为`fortunes`的应用程序。`fortunes`是一个小型命令行工具，可以生成励志名言。我们将使用它来在输出中包含名言，而不是用户输入。最后，`CMD`命令告诉Docker在基于此镜像运行容器时执行哪个命令。
- en: You typically save a Dockerfile in a file called `Dockerfile`, without an extension.
    To build an image, you need to execute the `docker build` command and point it
    to the Dockerfile you created. In building the Docker image, the Docker daemon
    will read the Dockerfile and execute the different steps in the Dockerfile. This
    command will also output the steps it took to run a container and build your image.
    Let's walk through a demo of building an image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会将Dockerfile保存在一个名为`Dockerfile`的文件中，不带扩展名。要构建镜像，你需要执行`docker build`命令并指向你创建的Dockerfile。在构建Docker镜像时，Docker守护进程会读取Dockerfile并执行其中的不同步骤。这个命令还会输出运行容器和构建镜像所经过的步骤。让我们通过一个演示来走一遍构建镜像的过程。
- en: 'In order to create this Dockerfile, open up a text editor via the `vi Dockerfile`
    command. **vi** is an advanced text editor on the Linux command line. If you are
    not familiar with it, let''s walk through how you would enter the text in there:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个Dockerfile，使用`vi Dockerfile`命令打开文本编辑器。**vi**是Linux命令行上的一个高级文本编辑器。如果你不熟悉它，我们将一步步演示如何在其中输入文本：
- en: After you've opened vi, hit the *I* key to enter insert mode.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你打开vi之后，按下*I*键进入插入模式。
- en: Then, either copy and paste or type the four code lines.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，复制并粘贴或手动输入这四行代码。
- en: Afterward, hit the *Esc* key, and type `:wq!` to write `(w)` your file and quit
    `(q)` the text editor.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按下*Esc*键，输入`:wq!`来写入`(w)`你的文件并退出`(q)`文本编辑器。
- en: The next step is to execute `docker build` to build the image. We will add a
    final bit to that command, namely adding a tag to our image so we can call it
    by a meaningful name. To build the image, you will use the `docker build -t smartwhale.`
    command (don't forget to add the final period here).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是执行`docker build`来构建镜像。我们会向该命令中添加最后的一部分，即为我们的镜像添加标签，这样我们就可以通过一个有意义的名称来调用它。要构建镜像，你需要使用`docker
    build -t smartwhale.`命令（别忘了在这里加上最后的句点）。
- en: 'You will now see Docker execute a number of steps—four in this case—to build
    the image. After the image is built, you can run your application. To run your
    container, you run `docker run smartwhale`, and you should see an output similar
    to *Figure 1.4*. However, you will probably see a different smart quote. This
    is due to the `fortunes` application generating different quotes. If you run the
    container multiple times, you will see different quotes appear, as shown in *Figure
    1.4*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将看到Docker执行一系列步骤——此处是四个步骤——来构建镜像。镜像构建完成后，你可以运行你的应用程序。要运行你的容器，你需要执行`docker
    run smartwhale`，然后你应该看到类似*图1.4*的输出。然而，你可能会看到不同的智能引号。这是因为`fortunes`应用程序会生成不同的引言。如果你多次运行容器，你将看到不同的引言，如*图1.4*所示：
- en: '![Running a custom container using the docker run command](img/B17338_01_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用docker run命令运行自定义容器](img/B17338_01_04.jpg)'
- en: 'Figure 1.4: Running a custom container'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：运行自定义容器
- en: That concludes our overview and demo of containers. In this section, you started
    with an existing container image and launched it on Docker Labs. Afterward, you
    took that a step further and built your own container image, then started containers
    using that image. You have now learned what it takes to build and run a container.
    In the next section, we will cover Kubernetes. Kubernetes allows you to run multiple
    containers at scale.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对容器的概述和演示。在这一部分，你从现有的容器镜像开始，并在Docker Labs上启动它。随后，你又进一步操作，构建了你自己的容器镜像，并使用该镜像启动了容器。你现在已经了解了构建和运行容器的步骤。在接下来的部分，我们将介绍Kubernetes。Kubernetes允许你在大规模环境下运行多个容器。
- en: Kubernetes as a container orchestration platform
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes作为容器编排平台
- en: Building and running a single container seems easy enough. However, things can
    get complicated when you need to run multiple containers across multiple servers.
    This is where a container orchestrator can help. A container orchestrator takes
    care of scheduling containers to be run on servers, restarting containers when
    they fail, moving containers to a new host when a host becomes unhealthy, and
    much more.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行一个单一容器似乎很简单。然而，当你需要在多个服务器上运行多个容器时，事情可能会变得复杂。这时，容器编排器可以派上用场。容器编排器负责调度容器在服务器上运行，在容器失败时重新启动容器，当主机变得不健康时，将容器迁移到新的主机，等等。
- en: The current leading orchestration platform is Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)).
    Kubernetes was inspired by Google's Borg project, which, by itself, was running
    millions of containers in production.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当前领先的编排平台是Kubernetes（[https://kubernetes.io/](https://kubernetes.io/)）。Kubernetes的灵感来源于Google的Borg项目，Borg本身在生产环境中运行了数百万个容器。
- en: Kubernetes takes a declarative approach to orchestration; that is, you specify
    what you need, and Kubernetes takes care of deploying the workload you specified.
    You don't need to start these containers manually yourself anymore, as Kubernetes
    will launch the containers you specified.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes采用声明式的编排方式；也就是说，你只需指定你需要什么，Kubernetes会负责部署你指定的工作负载。你不再需要手动启动这些容器，因为Kubernetes会自动启动你指定的容器。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Although Kubernetes used to support Docker as the container runtime, that support
    has been deprecated in Kubernetes version 1.20\. In AKS, **containerd** has become
    the default container runtime starting with Kubernetes 1.19\.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book, you will build multiple examples that run containers in
    Kubernetes, and you will learn more about the different objects in Kubernetes.
    In this introductory chapter, you will learn three elementary objects in Kubernetes
    that you will likely see in every application: a pod, a deployment, and a service.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Pods in Kubernetes
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **pod** in Kubernetes is the essential scheduling element. A pod is a group
    of one or more containers. This means a pod can contain either a single container
    or multiple containers. When creating a pod with a single container, you can use
    the terms container and pod interchangeably. However, the term pod is still preferred
    and is the term used throughout this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: When a pod contains multiple containers, these containers share the same file
    system and the same network namespace. This means that when a container that is
    part of a pod writes a file, other containers in that same pod can read that file
    as well. This also means that all containers in a pod can communicate with each
    other using localhost networking.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of design, you should only put containers that need to be tightly
    integrated in the same pod. Imagine the following situation: you have an old web
    application that does not support HTTPS. You want to upgrade that application
    to support HTTPS. You could create a pod that contains your old web application
    and includes another container that would do **Transport Layer Security** (**TLS**)
    offloading for that application, as described in *Figure 1.5*. Users would connect
    to your application using HTTPS, while the container in the middle converts HTTPS
    traffic to HTTP:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Using two containers in a single pod to support HTTPS traffic](img/B17338_01_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: An example of a multi-container pod that does HTTPS offloading'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This design principle is known as a sidecar. Microsoft has a free e-book available
    that describes multiple multi-container pod designs and designing distributed
    systems ([https://azure.microsoft.com/resources/designing-distributed-systems/](https://azure.microsoft.com/resources/designing-distributed-systems/)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: A pod, whether it be a single- or multi-container pod, is an ephemeral resource.
    This means that a pod can be terminated at any point and restarted on another
    node. When this happens, the state that was stored in that pod will be lost. If
    you need to store state in your application, you either need to store that state
    in external storage, such as an external disk or a file share, or store the state
    outside of Kubernetes in an external database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Deployments in Kubernetes
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **deployment** in Kubernetes provides a layer of functionality around pods.
    It allows you to create multiple pods from the same definition and to easily perform
    updates to your deployed pods. A deployment also helps with scaling your application,
    and potentially even autoscaling your application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, a deployment creates a **ReplicaSet**, which in turn will create
    the replica pods you requested. A ReplicaSet is another object in Kubernetes.
    The purpose of a ReplicaSet is to maintain a stable set of replica pods running
    at any given time. If you perform updates on your deployment, Kubernetes will
    create a new ReplicaSet that will contain the updated pods. By default, Kubernetes
    will do a rolling upgrade to the new version. This means that it will start a
    few new pods, verify those are running correctly, and if so, then Kubernetes will
    terminate the old pods and continue this loop until only new pods are running:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Relationship showing that a deployment creates a replicaset, which in turn
    creates multiple pods](img/B17338_01_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Figure1.6: The relationship between deployments, ReplicaSets, and pods'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Services in Kubernetes
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **service** in Kubernetes is a network-level abstraction. This allows you
    to expose multiple pods under a single IP address and a single DNS name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Each pod in Kubernetes has its own private IP address. You could theoretically
    connect to your applications using this private IP address. However, as mentioned
    before, Kubernetes pods are ephemeral, meaning they can be terminated and moved,
    which would change their IP address. By using a service, you can connect to your
    applications using a single IP address. When a pod moves from one node to another,
    the service ensures that traffic is routed to the correct endpoint. If there are
    multiple pods serving traffic behind one service, that traffic will be load balanced
    between the different pods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have introduced Kubernetes and three essential objects with
    Kubernetes. In the next section, we'll introduce AKS.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Azure Kubernetes Service
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AKS makes creating and managing Kubernetes clusters easier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: A typical Kubernetes cluster consists of a number of master nodes and a number
    of worker nodes. A node within Kubernetes is equivalent to a server or a **virtual
    machine** (**VM**). The master nodes contain the Kubernetes API and a database
    that contains the cluster state. The worker nodes are the machines that run your
    actual workload.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'AKS makes it easier to create a cluster. When you create an AKS cluster, AKS
    sets up the Kubernetes master for you. AKS will then create one or more **virtual
    machine scale sets** (**VMSS**) in your subscription and turn the VMs in these
    VMSSs into worker nodes of your Kubernetes cluster in your network. In AKS, you
    have the option to either use a free Kubernetes control plane or pay for a control
    plane that comes with a financially backed SLA. In either case, you also need
    to pay for the VMs hosting your worker nodes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Scheduling pods on nodes in AKS](img/B17338_01_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Scheduling of pods in AKS'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Within AKS, services running on Kubernetes are integrated with Azure Load Balancer
    and Kubernetes Ingresses can be integrated with Azure Application Gateway. The
    Azure Load Balancer is a layer-4 network load balancer service; Application Gateway
    is a layer-7 HTTP-based load balancer. The integration between Kubernetes and
    both services means that when you create a service or Ingress in Kubernetes, Kubernetes
    will create a rule in an Azure Load Balancer or Azure Application Gateway respectively.
    Azure Load Balancer or Application Gateway will then route the traffic to the
    right node in your cluster that hosts your pod.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, AKS adds a number of functionalities that make it easier to manage
    a cluster. AKS contains logic to upgrade clusters to newer Kubernetes versions.
    It also can easily scale your clusters, by either adding or removing nodes to
    the cluster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: AKS also comes with integration options that make operations easier. AKS clusters
    can be configured with integration with **Azure Active Directory** (**Azure AD**)
    to make managing identities and **role-based access control** (**RBAC**) straightforward.
    RBAC is the configuration process that defines which users get access to resources
    and which actions they can take against those resources. AKS can also easily be
    integrated into Azure Monitor for containers, which makes monitoring and troubleshooting
    your applications simpler. You will learn about all these capabilities throughout
    this book.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the concepts of containers and Kubernetes.
    You ran a number of containers, starting with an existing image and then using
    an image you built yourself. After that demo, you were introduced to three essential
    Kubernetes objects: the pod, the deployment, and the service.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This provides the context for the remaining chapters, where you will deploy
    containerized applications using Microsoft AKS. You will see how the AKS offering
    from Microsoft streamlines deployment by handling many of the management and operational
    tasks that you would have to do yourself if you managed and operated your own
    Kubernetes infrastructure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will use the Azure portal to create your first AKS
    cluster.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
