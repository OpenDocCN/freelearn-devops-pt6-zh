<html><head></head><body>
		<div id="_idContainer062">
			<h1 id="_idParaDest-128" class="chapter-number"><a id="_idTextAnchor127"/>6</h1>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Exposing Your Applications Using Ingress Controllers and Certificates</h1>
			<p>Ingress controllers fulfill traffic rules defined by an ingress object and are needed to expose traffic to APIs or microservices that your system uses. Ingress controllers are implemented in Kubernetes clusters. As an option to expose your deployments outside the cluster, instead of using dedicated load balancers for each deployment, the ingress controller shares a single load balancer for your deployments. By default, Kubernetes uses ClusterIP services to access deployments in the internal cluster network. Creating applications for edge computing involves configuring ingress controllers with lightweight solutions in mind: K3s and its default ingress controller, <strong class="bold">Traefik</strong> v1 using other ingress controllers such as <strong class="bold">NGINX</strong> or <strong class="bold">Contour</strong>, and security encryption for service communication. </p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Understanding ingress controllers and ingresses</li>
				<li>Installing Helm for ingress controller installations</li>
				<li>Installing and configuring cert-manager</li>
				<li>Using Traefik to expose your applications</li>
				<li>Using NGINX to expose your applications</li>
				<li>Troubleshooting your ingress controllers</li>
				<li>Pros and cons of Traefik, NGINX, and Contour</li>
				<li>Tips and best practices for ingress controllers</li>
			</ul>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Technical requirements</h1>
			<p>Before starting, you need the following to run the examples in this chapter:</p>
			<ul>
				<li>A Raspberry Pi cluster with K3s installed</li>
				<li>kubectl configured to access your cluster</li>
				<li>Helm installed and configured</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">If you don’t want to use Traefik and you want to omit the default installation of this ingress controller in your cluster, add the <strong class="source-inline">--no-deploy traefik --disable traefik</strong> flags when you are installing your master node. For other details of installing your K3s cluster, refer to <a href="B16945_03_Final_PG.xhtml#_idTextAnchor056"><em class="italic">Chapter 3</em></a>, <em class="italic">K3S Advanced Configurations and Management</em>, or visit <a href="https://rancher.com/docs/k3s/latest/en/installation/install-options/server-config/">https://rancher.com/docs/k3s/latest/en/installation/install-options/server-config/</a>. Remember to install a bare metal load balancer such as MetalLB, which is necessary to generate a load balancer service, which is needed to install ingress controllers.</p>
			<p>With these requirements, you are going to experiment with exposing your applications in different ways.</p>
			<p>For more detail and code snippets, check out this resource on GitHub: <a href="https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch6">https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch6</a></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Understanding ingress controllers</h1>
			<p>Kubernetes uses<a id="_idIndexMarker417"/> ingress controllers to expose your deployments outside the cluster. An ingress controller is the adaptation of a proxy to expose your applications, and Ingress is the Kubernetes object that uses this adaptation. An ingress controller works as a reverse<a id="_idIndexMarker418"/> proxy like <strong class="bold">NGINX</strong> to expose your application using HTTP/HTTPS protocols to a load balancer. This load balancer is the endpoint to expose your application outside the cluster. It’s in charge of receiving and controlling traffic for your application. The benefit of this is that you can share this load balancer, to expose as many applications as you want, but using all the features that your ingress controller provides. There are different ingress controller implementations, such as NGINX, Traefik, Emissary, and Envoy. </p>
			<p>Taking as a reference <em class="italic">Figure 6.1</em>, to expose your application, you must create a <strong class="bold">ClusterIP</strong> service that <a id="_idIndexMarker419"/>creates an internal DNS name for your Deployment or Pod. This service automatically forwards the traffic across the different replicas of your service, which perform load balancing. An Ingress uses the LoadBalancer service that your ingress controller provisioned when you installed it. This LoadBalancer has a public IP address if the cluster is not private. This IP receives traffic outside the cluster, then forwards this traffic to the ClusterIP service that your application is using. Internally, the Ingress object uses configuration files to act as a reverse proxy. For example, if you are using NGINX, the ingress object is going to use configurations that are used in a regular NGINX configuration file.</p>
			<p>In the context of Kubernetes, an ingress object tries to match the associated ClusterIP service of your application, using labels. This is how an ingress works internally. You can see an ingress as<a id="_idIndexMarker420"/> the common virtual hosts feature that NGINX and Apache provide for websites.</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B16945_Figure_6.1.jpg" alt="Figure 6.1 – Ingress in Kubernetes&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Ingress in Kubernetes</p>
			<p>Based on the official documentation of Kubernetes, a basic YAML file to create an ingress controller should look like this:</p>
			<p class="source-code">apiVersion: networking.k8s.io/v1</p>
			<p class="source-code">kind: Ingress</p>
			<p class="source-code">metadata:</p>
			<p class="source-code">  name: minimal-ingress</p>
			<p class="source-code">  annotations:</p>
			<p class="source-code">    kubernetes.io/ingress.class: nginx</p>
			<p class="source-code">    nginx.ingress.kubernetes.io/rewrite-target: /</p>
			<p class="source-code">spec:</p>
			<p class="source-code">  rules:</p>
			<p class="source-code">  - http:</p>
			<p class="source-code">      paths:</p>
			<p class="source-code">      - path: /testpath</p>
			<p class="source-code">        pathType: Prefix</p>
			<p class="source-code">        backend:</p>
			<p class="source-code">          service:</p>
			<p class="source-code">            name: test</p>
			<p class="source-code">            port:</p>
			<p class="source-code">              number: 80</p>
			<p>The most important sections for ingresses are the annotations and spec sections. The annotations will define the ingress controller to use, in this case, NGINX. This section could include additional configurations for the ingress, such as rewriting the URL or activating features such as authentication, and so on. This example defines the <strong class="source-inline">/testpath</strong> route to access your application. Now you have to apply the YAML file with kubectl. For example, if this file is called <strong class="source-inline">minimal-ingress.yaml</strong>, you have to run the following command to create the <strong class="source-inline">minimal-ingress</strong> controller:</p>
			<p class="source-code">$ kubectl apply -f minimal-ingress.yaml</p>
			<p>And that’s the way<a id="_idIndexMarker421"/> that ingress controllers and ingresses work. Now let’s install Helm to install an ingress controller in the next section.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Installing Helm for ingress controller installations</h1>
			<p>Before we <a id="_idIndexMarker422"/>start using an ingress <a id="_idIndexMarker423"/>controller, we need to install Helm. Helm is a package manager for Kubernetes, which you can use to install software. Helm uses Helm Charts, which contain the definitions to install and configure your deployments. </p>
			<p>To install Helm, follow the given steps:</p>
			<ol>
				<li>Download Helm with the next command:<p class="source-code"><strong class="bold">$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3</strong></p></li>
				<li>Change permissions and launch the installer by executing the following lines:<p class="source-code"><strong class="bold">$ chmod 700 get_helm.sh</strong></p><p class="source-code"><strong class="bold">$ ./get_helm.sh</strong></p></li>
			</ol>
			<p>Now you have <a id="_idIndexMarker424"/>Helm installed, let’s move on <a id="_idIndexMarker425"/>to install the NGINX ingress controller in the next section.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Installing cert-manager</h1>
			<p>cert-manager is<a id="_idIndexMarker426"/> software that you want to install if you want to add certificates or certificate issues as a resource type in Kubernetes. These certificates can be used by applications, but in this specific case, we are going to use cert-manager to add encrypted traffic to your app, using the HTTPS protocol.</p>
			<p>To install cert-manager, we are going to use Helm. To install Helm, you have to follow the given steps:</p>
			<ol>
				<li value="1">Add the Jetstack repo, which contains cert-manager:<p class="source-code"><strong class="bold">$ helm repo add jetstack https://charts.jetstack.io</strong></p></li>
				<li>Update your local Helm Chart repository cache. To do this, execute the following command:<p class="source-code"><strong class="bold">$ helm repo update</strong></p></li>
				<li>Now install cert-manager using Helm:<p class="source-code"><strong class="bold">$ helm install \</strong></p><p class="source-code"><strong class="bold">cert-manager jetstack/cert-manager \</strong></p><p class="source-code"><strong class="bold">--namespace cert-manager \</strong></p><p class="source-code"><strong class="bold">--create-namespace \</strong></p><p class="source-code"><strong class="bold">--version v1.5.4 \</strong></p><p class="source-code"><strong class="bold">--set prometheus.enabled=false \</strong></p><p class="source-code"><strong class="bold">--set webhook.timeoutSeconds=4 \</strong></p><p class="source-code"><strong class="bold">--set prometheus.enabled=false \</strong></p><p class="source-code"><strong class="bold">--set installCRDs=true</strong></p></li>
			</ol>
			<p>This is going to install cert-manager in the <strong class="source-inline">cert-manager</strong> namespace, with version <strong class="source-inline">1.5.4</strong>. This cert-manager installation doesn’t include Prometheus but includes cert-manager <strong class="bold">Customer Resource Definitions</strong> (<strong class="bold">CRDs</strong>) and configures <a id="_idIndexMarker427"/>timeout parameters for webhook validations when generating a certificate.</p>
			<ol>
				<li value="4">Create a <a id="_idIndexMarker428"/>self-signed issuer in cert-manager, to create certificates for your local domains. To do this, create the <strong class="source-inline">self-signed-issuer.yaml</strong> file with the following content:<p class="source-code"><strong class="bold">apiVersion: cert-manager.io/v1</strong></p><p class="source-code"><strong class="bold">kind: ClusterIssuer</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: self-signed-issuer</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  selfSigned: {}</strong></p></li>
				<li>Now create an issuer that uses Let’s Encrypt to create a certificate that could be used for public domains. To do this, create the <strong class="source-inline">letsencrypt-staging.yaml</strong> file with the following content:<p class="source-code"><strong class="bold">apiVersion: cert-manager.io/v1</strong></p><p class="source-code"><strong class="bold">kind: Issuer</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: letsencrypt-staging</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  acme:</strong></p><p class="source-code"><strong class="bold">    server: https://acme-staging-v02.api.letsencrypt.org/directory</strong></p><p class="source-code"><strong class="bold">    email: user@example.com</strong></p><p class="source-code"><strong class="bold">    privateKeySecretRef:</strong></p><p class="source-code"><strong class="bold">      name: letsencrypt-staging</strong></p><p class="source-code"><strong class="bold">    solvers:</strong></p><p class="source-code"><strong class="bold">    - http01:</strong></p><p class="source-code"><strong class="bold">        ingress:</strong></p><p class="source-code"><strong class="bold">          class:  nginx</strong></p></li>
			</ol>
			<p>This file is assuming, as an example, that you will use this issuer in a staging environment, but you can customize this file as you want.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Be aware that <strong class="source-inline">ClusterIssuer</strong> is cluster scoped and <strong class="source-inline">Issuer</strong> is namespace scoped.</p>
			<ol>
				<li value="6">Now apply these files to create the self-signed issuer for a staging environment, using the following command:<p class="source-code"><strong class="bold">$ kubectl apply -f self-signed-issuer.yaml -f letsencrypt-staging.yaml</strong></p></li>
			</ol>
			<p>Now you have cert-manager installed and ready to use. You can also create basic issuers for your <a id="_idIndexMarker429"/>applications. This part will be crucial to configure certificates for your domains if necessary. So now, let’s move towards installing our first ingress controller, NGINX.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor133"/>NGINX ingress installation</h1>
			<p>NGINX is the most <a id="_idIndexMarker430"/>widely used ingress controller on Kubernetes. It has all the necessary features that you need for basic and complex configurations to expose your application. It has all the experience and support of the community behind NGINX. It’s stable and you can still use it for devices using ARM processors.</p>
			<p>To install the NGINX ingress controller, follow the given steps:</p>
			<ol>
				<li value="1">Create a namespace to install the NGINX ingress controller:<p class="source-code"><strong class="bold">$ kubectl create ns nginx-ingress</strong></p></li>
				<li>Add the repository that contains the Helm Chart of the NGINX ingress controller and update the repository of charts that Helm is going to use:<p class="source-code"><strong class="bold">$ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx </strong></p><p class="source-code"><strong class="bold">$ helm repo update</strong> </p></li>
				<li>Install the NGINX ingress controller with the following command:<p class="source-code"><strong class="bold">$ helm install nginx-ingress ingress-nginx/ingress-nginx -n nginx-ingress</strong></p></li>
			</ol>
			<p>This will<a id="_idIndexMarker431"/> output that the installation was successful.</p>
			<ol>
				<li value="4">To check whether the <strong class="source-inline">nginx-ingress</strong> controller was installed, run the following command:<p class="source-code"><strong class="bold">$ helm list -n nginx-ingress</strong></p></li>
				<li>After installing the <strong class="source-inline">nginx-ingress</strong> controller, K3s will provide a load balancer. In this case, we assume that we are using MetalLB. To obtain the load balancer IP address provisioned by your ingress controller, run the following command:<p class="source-code"><strong class="bold">$ IP_LOADBALANCER=$(kubectl get svc nginx-ingress-ingress-nginx-controller --output jsonpath='{.status.loadBalancer.ingress[0].ip}' -n nginx-ingress)</strong></p></li>
			</ol>
			<p>Here, the <strong class="source-inline">IP_LOADBALANCER</strong> variable contains the IP of the load balancer created by the ingress controller, which is the endpoint for your applications. You can check the value by running the following command:</p>
			<p class="source-code"><strong class="bold">$ echo $IP_LOADBALANCER</strong></p>
			<p>Using as a reference the installation of the K3s cluster in <a href="B16945_05_Final_PG.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">K3s Homelab for Edge Computing Experiments</em><em class="italic">,</em> you will see an IP like this: <strong class="source-inline">192.168.0.240</strong>.</p>
			<ol>
				<li value="6">You can use that IP to create a DNS record to point the ingress to a domain, or to access your service using a path. Let’s say that, for example, the returned IP is <strong class="source-inline">192.168.0.241</strong>. You can access your service access in your browser with the URL <strong class="source-inline">http://192.168.0.240</strong>. Another option is to use a path to access your application; for example, the URL would be like this: <strong class="source-inline">http://192.168.0.240/myapp</strong>.</li>
				<li>Finally, if you want to uninstall <strong class="source-inline">nginx-ingress</strong>, run the following command:<p class="source-code"><strong class="bold">$ helm uninstall nginx-ingress -n nginx-ingress</strong></p></li>
			</ol>
			<p>Now that you have <a id="_idIndexMarker432"/>installed the NGINX ingress controller, let’s move on to study a basic example using this ingress controller.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Using NGINX to expose your applications</h1>
			<p>It’s time <a id="_idIndexMarker433"/>to start using NGINX as your ingress controller. We are <a id="_idIndexMarker434"/>going to expose your first application using NGINX. To begin, let’s deploy a simple application. To do this, follow the given steps:</p>
			<ol>
				<li value="1">Create a simple deployment using <strong class="source-inline">nginx</strong> image with the following command:<p class="source-code"><strong class="bold">$ kubectl create deploy myapp --image=nginx</strong></p></li>
				<li>Create a ClusterIP service for the <strong class="source-inline">myapp</strong> deployment:<p class="source-code"><strong class="bold">$ kubectl expose deploy myapp --type=ClusterIP --port=80</strong></p></li>
				<li>Create an Ingress using the domain <strong class="source-inline">192.168.0.240.nip.io</strong>. In this example, we are assuming that the endpoint for the ingress is <strong class="source-inline">192.168.0.240</strong>. This is the same IP as the load balancer created by the ingress controller. When you access your browser, the page <strong class="source-inline">https://192.168.0.241.nip.io</strong> is going to show the NGINX <strong class="bold">myapp </strong>Deployment, which you have already created. <a href="http://nip.io">nip.io</a> is a wildcard DNS for any IP address, so with this, you can get a free kind of domain to play with your ingress definitions. Let’s move on to<a id="_idIndexMarker435"/> create<a id="_idIndexMarker436"/> this ingress by creating the <strong class="source-inline">myapp-ingress.yaml</strong> file:<p class="source-code"><strong class="bold">apiVersion: networking.k8s.io/v1</strong></p><p class="source-code"><strong class="bold">kind: Ingress</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: myapp-ingress-tls-nginx</strong></p><p class="source-code"><strong class="bold">  annotations:</strong></p><p class="source-code"><strong class="bold">    kubernetes.io/ingress.class: "nginx"</strong></p><p class="source-code"><strong class="bold">    cert-manager.io/cluster-issuer: self-signed-issuer</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  tls:</strong></p><p class="source-code"><strong class="bold">  - hosts:</strong></p><p class="source-code"><strong class="bold">      - 192.168.0.241.nip.io</strong></p><p class="source-code"><strong class="bold">    secretName: myapp-tls-nginx</strong></p><p class="source-code"><strong class="bold">  rules:</strong></p><p class="source-code"><strong class="bold">  - host: 192.168.0.241.nip.io</strong></p><p class="source-code"><strong class="bold">    http:</strong></p><p class="source-code"><strong class="bold">      paths:</strong></p><p class="source-code"><strong class="bold">      - path: /</strong></p><p class="source-code"><strong class="bold">        pathType: Prefix</strong></p><p class="source-code"><strong class="bold">        backend:</strong></p><p class="source-code"><strong class="bold">          service:</strong></p><p class="source-code"><strong class="bold">            name: myapp</strong></p><p class="source-code"><strong class="bold">            port:</strong></p><p class="source-code"><strong class="bold">              number: 80</strong></p></li>
			</ol>
			<p>You can customize this file as you want. If you don’t want HTTPS for your application, omit the TLS section and the annotation <strong class="source-inline">cert-manager.io/cluster-issuer</strong>. If you are using a public domain, use the following annotation:</p>
			<p class="source-code"><strong class="bold">cert-manager.io/cluster-issuer: letsencrypt-staging</strong></p>
			<ol>
				<li value="4">If you<a id="_idIndexMarker437"/> are <a id="_idIndexMarker438"/>using a local domain, for example, <strong class="source-inline">myapp-test-nginx.test</strong>, you have to modify the <strong class="source-inline">/etc/hosts</strong> file and add a line like this:<p class="source-code"><strong class="bold">192.168.0.241 myapp-test-nginx.test</strong></p></li>
			</ol>
			<p>This is necessary to resolve the local domain for your app. Also, remember to modify <strong class="source-inline">tls.hosts</strong> and <strong class="source-inline">rules.hosts</strong> in the file in order to use a domain such as <strong class="source-inline">myapp-test-nginx.test</strong>. So, the second option will be like this:</p>
			<p class="source-code"><strong class="bold">apiVersion: networking.k8s.io/v1</strong></p>
			<p class="source-code"><strong class="bold">kind: Ingress</strong></p>
			<p class="source-code"><strong class="bold">metadata:</strong></p>
			<p class="source-code"><strong class="bold">  name: myapp-ingress-tls-nginx</strong></p>
			<p class="source-code"><strong class="bold">  annotations:</strong></p>
			<p class="source-code"><strong class="bold">    kubernetes.io/ingress.class: "nginx"</strong></p>
			<p class="source-code"><strong class="bold">    cert-manager.io/cluster-issuer: self-signed-issuer</strong></p>
			<p class="source-code"><strong class="bold">spec:</strong></p>
			<p class="source-code"><strong class="bold">  tls:</strong></p>
			<p class="source-code"><strong class="bold">  - hosts:</strong></p>
			<p class="source-code"><strong class="bold">      - myapp-test-nginx.test</strong></p>
			<p class="source-code"><strong class="bold">    secretName: myapp-tls-nginx</strong></p>
			<p class="source-code"><strong class="bold">  rules:</strong></p>
			<p class="source-code"><strong class="bold">  - host: myapp-test-nginx.test</strong></p>
			<p class="source-code"><strong class="bold">    http:</strong></p>
			<p class="source-code"><strong class="bold">      paths:</strong></p>
			<p class="source-code"><strong class="bold">      - path: /</strong></p>
			<p class="source-code"><strong class="bold">        pathType: Prefix</strong></p>
			<p class="source-code"><strong class="bold">        backend:</strong></p>
			<p class="source-code"><strong class="bold">          service:</strong></p>
			<p class="source-code"><strong class="bold">            name: myapp</strong></p>
			<p class="source-code"><strong class="bold">            port:</strong></p>
			<p class="source-code"><strong class="bold">              number: 80</strong></p>
			<ol>
				<li value="5">Create<a id="_idIndexMarker439"/> the<a id="_idIndexMarker440"/> ingress using the previous file using the following command:<p class="source-code"><strong class="bold">$ kubectl apply -f myapp-ingress-tls-nginx.yaml</strong></p></li>
				<li>Access the <strong class="source-inline">myapp</strong> deployment by using the URL <strong class="source-inline">https://192.168.0.241.nip.io</strong> or https://myapp-test-nginx.test in your browser page.</li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Because this is a self-signed certificate, you have to accept the security exception in your browser.</p>
			<p>Or, use <strong class="source-inline">curl</strong> to access the page with the following command:</p>
			<p class="source-code"><strong class="bold">$ curl -k https://192.168.0.240.nip.io</strong></p>
			<p class="source-code"><strong class="bold">or </strong></p>
			<p class="source-code"><strong class="bold">$ curl -k https://myapp-test-nginx.test</strong></p>
			<p>If you don’t want to use HTTPS, you can access the page with the URL <strong class="source-inline">http://192.168.0.241.nip.io</strong> or <strong class="source-inline">https://myapp-test-nginx.test</strong> in your browser or by using the <strong class="source-inline">curl</strong> command.</p>
			<ol>
				<li value="7">If you want to delete the ingress, run the following command:<p class="source-code"><strong class="bold">$ kubectl delete -f myapp-ingress.yaml</strong></p></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">When you delete the ingress, and you are using a self-signed issuer, the secret used for <em class="italic">Let’s Encrypt</em> will not be deleted. You have to delete it manually using the <strong class="source-inline">kubectl</strong> command. For example, you can run the following command to delete the secret from the previously created ingress: <strong class="source-inline">kubectl delete secrets myapp-tls-nginx</strong>.</p>
			<p>Now you<a id="_idIndexMarker441"/> have <a id="_idIndexMarker442"/>learned how to use NGINX. Next, it’s time to learn how to use Traefik to expose your applications in the next section.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Using Traefik to expose your applications</h1>
			<p>Traefik is the<a id="_idIndexMarker443"/> ingress controller included by default in K3s. It <a id="_idIndexMarker444"/>uses the same configurations as NGINX as shown in the previous example in the <strong class="source-inline">myapp-ingress.yaml</strong> file. Let’s assume that you already have created the <strong class="source-inline">myapp</strong> Deployment from the previous section. So, let’s get started with Traefik by following the given steps:</p>
			<ol>
				<li value="1">To find the load balancer IP address created by Traefik, run the following command:<p class="source-code"><strong class="bold">$ IP_LOADBALANCER=$(kubectl get svc traefik --output jsonpath='{.status.loadBalancer.ingress[0].ip}' -n kube-system)</strong></p></li>
			</ol>
			<p>Run the following command to see the current IP address assigned to the load balancer that the Traefik installation provisioned. This will be used to create an entry in the <strong class="source-inline">/etc/hosts</strong> file:</p>
			<p class="source-code"><strong class="bold">$ echo $IP_LOADBALANCER</strong></p>
			<p>Let’s say that returns <strong class="source-inline">192.168.0.240</strong>. You have to add the next line to the <strong class="source-inline">/etc/hosts</strong> file: </p>
			<p class="source-code"><strong class="bold">192.168.0.240 myapp-test-traefik.test</strong></p>
			<p>Now you <a id="_idIndexMarker445"/>are<a id="_idIndexMarker446"/> ready to create the Ingress object.</p>
			<ol>
				<li value="2">To expose <strong class="source-inline">myapp</strong> using <strong class="source-inline">nip</strong> and TLS, create the <strong class="source-inline">myapp-ingress-tls-traefik.yaml</strong> file with the following content:<p class="source-code"><strong class="bold">apiVersion: networking.k8s.io/v1</strong></p><p class="source-code"><strong class="bold">kind: Ingress</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: myapp-ingress-traefik</strong></p><p class="source-code"><strong class="bold">  annotations:</strong></p><p class="source-code"><strong class="bold">    kubernetes.io/ingress.class: "traefik"</strong></p><p class="source-code"><strong class="bold">    cert-manager.io/cluster-issuer: self-signed-issuer</strong></p><p class="source-code"><strong class="bold">    traefik.ingress.kubernetes.io/router.tls: "true"</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  tls:</strong></p><p class="source-code"><strong class="bold">  - hosts:</strong></p><p class="source-code"><strong class="bold">      - myapp-test-traefik.test</strong></p><p class="source-code"><strong class="bold">    secretName: myapp-tls-traefik</strong></p><p class="source-code"><strong class="bold">  rules:</strong></p><p class="source-code"><strong class="bold">  - host: myapp-test-traefik.test</strong></p><p class="source-code"><strong class="bold">    http:</strong></p><p class="source-code"><strong class="bold">      paths:</strong></p><p class="source-code"><strong class="bold">      - path: /</strong></p><p class="source-code"><strong class="bold">        pathType: Prefix</strong></p><p class="source-code"><strong class="bold">        backend:</strong></p><p class="source-code"><strong class="bold">          service:</strong></p><p class="source-code"><strong class="bold">            name: myapp</strong></p><p class="source-code"><strong class="bold">            port:</strong></p><p class="source-code"><strong class="bold">              number: 80</strong></p></li>
				<li>Apply the<a id="_idIndexMarker447"/> file <a id="_idIndexMarker448"/>with the following command:<p class="source-code"><strong class="bold">$ kubectl apply -f myapp-ingress-tls-traefik.yaml</strong></p></li>
				<li>(<em class="italic">Optional</em>) If you want to use the <strong class="source-inline">nip.io</strong> service, the YAML file will look like this:<p class="source-code"><strong class="bold">apiVersion: networking.k8s.io/v1</strong></p><p class="source-code"><strong class="bold">kind: Ingress</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: myapp-ingress-traefik</strong></p><p class="source-code"><strong class="bold">  annotations:</strong></p><p class="source-code"><strong class="bold">    kubernetes.io/ingress.class: "traefik"</strong></p><p class="source-code"><strong class="bold">    cert-manager.io/cluster-issuer: self-signed-issuer</strong></p><p class="source-code"><strong class="bold">    traefik.ingress.kubernetes.io/router.tls: "true"</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  tls:</strong></p><p class="source-code"><strong class="bold">  - hosts:</strong></p><p class="source-code"><strong class="bold">      - myapp-test-traefik.test</strong></p><p class="source-code"><strong class="bold">    secretName: myapp-tls-traefik</strong></p><p class="source-code"><strong class="bold">  rules:</strong></p><p class="source-code"><strong class="bold">  - host: myapp-test-traefik.test</strong></p><p class="source-code"><strong class="bold">    http:</strong></p><p class="source-code"><strong class="bold">      paths:</strong></p><p class="source-code"><strong class="bold">      - path: /</strong></p><p class="source-code"><strong class="bold">        pathType: Prefix</strong></p><p class="source-code"><strong class="bold">        backend:</strong></p><p class="source-code"><strong class="bold">          service:</strong></p><p class="source-code"><strong class="bold">            name: myapp</strong></p><p class="source-code"><strong class="bold">            port:</strong></p><p class="source-code"><strong class="bold">              number: 80</strong></p></li>
				<li>(<em class="italic">Optional</em>) Apply the file with the following command:<p class="source-code"><strong class="bold">$ kubectl apply -f myapp-ingress-tls-traefik.yaml</strong></p></li>
			</ol>
			<p>Now you <a id="_idIndexMarker449"/>have <a id="_idIndexMarker450"/>configured and used Traefik as your load balancer.</p>
			<p>Remember that if you didn’t use the <strong class="source-inline">–disable traefik</strong> parameter, Traefik will be installed in your K3s cluster. Now, it’s time to use Contour. So, let’s move on to the next section.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Contour ingress controller installation and use</h1>
			<p>Contour is an <a id="_idIndexMarker451"/>Envoy-based ingress controller. The advantage of using Envoy is that it’s fast and includes some powerful features that are found in service meshes, such as rate limits, advanced routing, metrics, and so on. If speed is key in your project, Contour will be the best solution in most cases. Contour is a lightweight solution and is optimized to run quickly. This makes Contour a good choice for edge computing. Now let’s move on to start using Contour.</p>
			<p>To install Contour, follow the next steps:</p>
			<ol>
				<li value="1">Install Contour using the quickstart configuration it provides:<p class="source-code"><strong class="bold">$ kubectl apply -f https://projectcontour.io/quickstart/contour.yaml</strong></p></li>
				<li>If you want to use <strong class="source-inline">nip.io</strong>, you have to first find the IP of the Contour load balancer and create an entry in the <strong class="source-inline">/etc/hosts</strong> file from your machine. To find the IP of Contour, run the following command:<p class="source-code"><strong class="bold">$ IP_LOADBALANCER=$(kubectl get svc envoy--output jsonpath='{.status.loadBalancer.ingress[0].ip}' -n projectcontour)</strong></p></li>
			</ol>
			<p>If you run the following command, it will show the load balancer IP that the Contour ingress controller installation provisioned, which will be used to create an entry in the <strong class="source-inline">/etc/hosts</strong> file:</p>
			<p class="source-code"><strong class="bold">$ echo $IP_LOADBALANCER</strong></p>
			<p>This will show the load balancer IP that the Contour installation created. This will be used to create an entry in the <strong class="source-inline">/etc/hosts</strong> file.</p>
			<p>Let’s say that returns <strong class="source-inline">192.168.0.242</strong>. You have to add the next line to the <strong class="source-inline">/etc/hosts</strong> file: </p>
			<p class="source-code"><strong class="bold">192.168.0.242 myapp-test-contour.test</strong></p>
			<p>Now you are ready to create the Ingress object.</p>
			<ol>
				<li value="3">Create a file with a basic configuration for contour. Let’s call this file <strong class="source-inline">myapp-ingress-tls-contour.yaml</strong>. This<a id="_idIndexMarker452"/> file will have the following content:<p class="source-code"><strong class="bold">apiVersion: networking.k8s.io/v1</strong></p><p class="source-code"><strong class="bold">kind: Ingress</strong></p><p class="source-code"><strong class="bold">metadata:</strong></p><p class="source-code"><strong class="bold">  name: myapp-ingress-tls-contour</strong></p><p class="source-code"><strong class="bold">  annotations:</strong></p><p class="source-code"><strong class="bold">    kubernetes.io/ingress.class: "contour"</strong></p><p class="source-code"><strong class="bold">    cert-manager.io/cluster-issuer: self-signed-issuer</strong></p><p class="source-code"><strong class="bold">spec:</strong></p><p class="source-code"><strong class="bold">  tls:</strong></p><p class="source-code"><strong class="bold">  - hosts:</strong></p><p class="source-code"><strong class="bold">      - myapp-test-contour.test</strong></p><p class="source-code"><strong class="bold">    secretName: myapp-tls-contour</strong></p><p class="source-code"><strong class="bold">  rules:</strong></p><p class="source-code"><strong class="bold">  - host: myapp-test-contour.test</strong></p><p class="source-code"><strong class="bold">    http:</strong></p><p class="source-code"><strong class="bold">      paths:</strong></p><p class="source-code"><strong class="bold">      - path: /</strong></p><p class="source-code"><strong class="bold">        pathType: Prefix</strong></p><p class="source-code"><strong class="bold">        backend:</strong></p><p class="source-code"><strong class="bold">          service:</strong></p><p class="source-code"><strong class="bold">            name: myapp</strong></p><p class="source-code"><strong class="bold">            port:</strong></p><p class="source-code"><strong class="bold">              number: 80</strong></p></li>
				<li>Apply the YAML file with the following command:<p class="source-code"><strong class="bold">$ kubectl apply –f myapp-ingress-tls-contour</strong></p></li>
			</ol>
			<p>Now we know how to use Contour using the Ingress object in Kubernetes. So, let’s see how to use<a id="_idIndexMarker453"/> Contour using its own objects in Kubernetes in the next section.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Using Contour with HTTPProxy and cert-manager</h2>
			<p>Contour can be <a id="_idIndexMarker454"/>used in<a id="_idIndexMarker455"/> the<a id="_idIndexMarker456"/> same<a id="_idIndexMarker457"/> way as the NGINX ingress controller, but you can also use the <strong class="source-inline">HTTPProxy</strong> object that Contour provides. The same example, <strong class="source-inline">myapp-ingress-tls-contour</strong>, can be created using Contour objects. Let’s see the equivalent for the Contour ingress controller. First, let’s create the certificate with the <strong class="source-inline">cert-manager</strong> object. Let’s call the file <strong class="source-inline">myapp-tls-contour.yaml</strong>. It will look like this:</p>
			<pre class="source-code">
<strong class="bold">apiVersion: cert-manager.io/v1</strong>
<strong class="bold">kind: Certificate</strong>
<strong class="bold">metadata:</strong>
<strong class="bold">  name: myapp-tls-contour</strong>
<strong class="bold">spec:</strong>
<strong class="bold">  commonName: myapp-test-contour.test</strong>
<strong class="bold">  dnsNames:</strong>
<strong class="bold">  - myapp-test-contour.test</strong>
<strong class="bold">  issuerRef:</strong>
<strong class="bold">    name: self-signed-issuer</strong>
<strong class="bold">    kind: ClusterIssuer</strong>
<strong class="bold">  secretName: httpbinproxy</strong></pre>
			<p>The <strong class="source-inline">myapp-tls-contour.yaml</strong> file definition creates the certificate to be used by the <strong class="source-inline">HTTPProxy</strong> object. Let’s create the <strong class="source-inline">myapp-ingress-http-proxy-tls-contour.yaml</strong> file with the equivalent configuration of the <strong class="source-inline">myapp-ingress-tls-contour.yaml</strong> file, but now using the <strong class="source-inline">HTTPProxy</strong> object and the previously generated<a id="_idIndexMarker458"/> certificate. This <a id="_idIndexMarker459"/>will <a id="_idIndexMarker460"/>look <a id="_idIndexMarker461"/>like this:</p>
			<pre class="source-code">
<strong class="bold">myapp-ingress-http-proxy-tls-contour.yaml</strong>
<strong class="bold">apiVersion: projectcontour.io/v1</strong>
<strong class="bold">kind: HTTPProxy</strong>
<strong class="bold">metadata:</strong>
<strong class="bold">  name: myapp-ingress-http-proxy-tls-contour</strong>
<strong class="bold">spec:</strong>
<strong class="bold">  virtualhost:</strong>
<strong class="bold">    fqdn: myapp-test-contour.test</strong>
<strong class="bold">    tls:</strong>
<strong class="bold">      secretName: myapp-tls-contour</strong>
<strong class="bold">    rateLimitPolicy:</strong>
<strong class="bold">      local:</strong>
<strong class="bold">        requests: 3</strong>
<strong class="bold">        unit: minute</strong>
<strong class="bold">        burst: 1</strong>
<strong class="bold">  routes:</strong>
<strong class="bold">  - services:</strong>
<strong class="bold">    - name: myapp</strong>
<strong class="bold">      port: 80</strong></pre>
			<p>Notice that this object sets a rate limit of 3 requests per minute with an additional request or soft limit to have, in total, 4 requests per minute. If the limit is exceeded, Contour will block the request. You can access the site with the following command:</p>
			<pre class="source-code">
<strong class="bold">$ curl -k https://myapp-test-contour.test</strong></pre>
			<p>The <strong class="source-inline">-k</strong> parameter omits the validation of the self-signed certificate created by cert-manager.</p>
			<p>As you can see, Contour can use the Kubernetes ingress object, and you can add more features as <a id="_idIndexMarker462"/>rate limits using the objects provided by Contour. Now, it’s time to troubleshoot<a id="_idIndexMarker463"/> your<a id="_idIndexMarker464"/> ingress<a id="_idIndexMarker465"/> controllers or ingress definitions. Let’s move on to the next section.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Troubleshooting your ingress controllers</h1>
			<p>These are some<a id="_idIndexMarker466"/> useful commands that you can use to troubleshoot your ingress controllers:</p>
			<ol>
				<li value="1">To check the NGINX ingress controller logs, run the following command:<p class="source-code"><strong class="bold">$ kubectl logs -f deploy/nginx-ingress-ingress-nginx-controller -n nginx-ingress</strong></p></li>
			</ol>
			<p>This will show the logs when an ingress uses NGINX as the ingress controller.</p>
			<ol>
				<li value="2">To check Traefik ingress controller logs, run the following command:<p class="source-code"><strong class="bold">$ kubectl logs -f deploy/traefik -n kube-system</strong></p></li>
				<li>To check Contour ingress controller logs, run the following command:<p class="source-code"><strong class="bold">$ kubectl logs -f deploy/contour -n projectcontour</strong></p></li>
			</ol>
			<p>These commands are useful for checking what is happening inside your ingress controller deployments. Now, here are some useful commands to check that your ingress definition is working properly: </p>
			<p class="source-code"><strong class="bold">$ kubectl get svc</strong></p>
			<p class="source-code"><strong class="bold">$ kubectl get ingresses</strong></p>
			<p>If you want to use the ingress controller’s own objects, such as <strong class="source-inline">HTTPProxy</strong> and so on, run the following command:</p>
			<p class="source-code"><strong class="bold">$ kubectl get OBJECT_NAME</strong></p>
			<p>Here, <strong class="source-inline">OBJECT_NAME</strong> should be, for example, <strong class="source-inline">HTTPProxy</strong>, <strong class="source-inline">Certificate</strong>, and so on. This depends on what object you want to check. For a full list of these objects, you can check the official documentation for NGINX, Traefik, and Contour.</p>
			<p>Now you have learned about troubleshooting your ingress controller deployment and your ingress <a id="_idIndexMarker467"/>definitions, let’s explore the pros and cons of the ingress controllers that we have used in this chapter.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Pros and cons of Traefik, NGINX, and Contour</h1>
			<p>All the<a id="_idIndexMarker468"/> ingress <a id="_idIndexMarker469"/>controllers have the basic features<a id="_idIndexMarker470"/> to expose your application, that is, they are compatible with the Ingress object in Kubernetes. So, let’s explore the pros and cons of each Ingress controller. Let’s get started with this quick comparison: </p>
			<ul>
				<li>NGINX Ingress is an ingress controller that uses NGINX to expose applications in your cluster.<ul><li>Pros: It is the most widely used ingress controller for Kubernetes. It has a lot of documentation. Developer and community support is widely available. The community behind it is bigger than Traefik and Contour.</li><li>Cons: It can be slow compared to Envoy-based ingress controllers such as <strong class="bold">Emissary</strong>, <strong class="bold">Gloo</strong>, and Contour.</li></ul></li>
				<li>Traefik is an ingress controller created by Traefik Labs. It has a lot of features, which can be used as plugins. It can be used to visualize your applications on a dashboard.<ul><li>Pros: It has a dashboard and a lot of documentation. It also has some service mesh capabilities.</li><li>Cons: It can be slow when compared against NGINX and Contour. The documentation is not focused on Kubernetes, and can be difficult to understand.</li></ul></li>
				<li>Contour is an ingress controller based on Envoy, a tool owned by VMware. It’s used in Tanzu, a platform for managing Kubernetes. This means that a big company supports Contour.<ul><li>Pros: It’s fast because of its architecture and the language used for its binary, which is C. It has enough features to expose your application. It can be used as a service mesh. Big projects such as Istio use Envoy as their default ingress controller. Contour has support for ARM devices.</li><li>Cons: Contour is not mature and has missing features. It has fewer features compared with NGINX and Traefik. </li></ul></li>
			</ul>
			<p>The use of ingress controllers could be focused on exposing your application. Depending on the feature you need, you can choose the previous ingress controllers. If you want to use a stable ingress controller, choose NGINX. If you are looking for auto-discovery features or<a id="_idIndexMarker471"/> a <a id="_idIndexMarker472"/>dashboard to visualize your endpoints, maybe<a id="_idIndexMarker473"/> you could use Traefik. And if you are looking for speed or a customizable ingress controller, choose Contour, or maybe you can create your own solution using Envoy.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Tips and best practices for ingress controllers</h1>
			<p>These are some<a id="_idIndexMarker474"/> ideas that you can explore when using ingress controllers:</p>
			<ul>
				<li><strong class="bold">Use routing features</strong>: Each of these ingress controllers has different ways to implement routing to expose your application. Read the official documentation of these ingress controllers to understand which has your desired features. </li>
				<li><strong class="bold">Create a proof of concept</strong> (<strong class="bold">POC</strong>) to evaluate which ingress controller is best for your use case.</li>
				<li><strong class="bold">Install Traefik 2.0</strong>: If you like Traefik, maybe you can install Traefik 2.0. K3s includes Traefik version 1.0, which only has the necessary features to expose your application. But if you need more advanced reverse proxy features for your applications, you can install Traefik 2.0, which includes a dashboard and other features that you may want to use.</li>
				<li><strong class="bold">Introduce rate limits</strong>: Implement rate limits to your applications. This is a nice feature when you want to prevent spikes or denial-of-service attacks.</li>
				<li><strong class="bold">Implement TLS</strong>: This is a common use case. It’s recommended to encrypt your traffic to prevent a hacker from stealing your information. It’s important to provide additional security for your applications.</li>
				<li><strong class="bold">Install basic authentication</strong>: This is the most basic kind of security for your endpoints. With this, you can set a user and password to access your applications.</li>
				<li><strong class="bold">Secure access with JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>): This is a nice feature to get more control and use tokens to access your endpoints. It is a better and more secure option than using a basic authentication method.</li>
			</ul>
			<p>Now you have other ideas to implement when you are using an ingress controller and creating ingress<a id="_idIndexMarker475"/> definitions to expose your applications. Now it is time for a quick summary of this chapter.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Summary</h1>
			<p>In this chapter, we learned how to use different ingress controllers, such as NGINX, Traefik, and Contour. These ingress controllers are the most used ones, starting with NGINX, then Traefik, and finally Contour, which is based on Envoy. This chapter showed you how to use NGINX, Traefik, and Contour to solve common daily tasks in real production environments. The examples covered the use of TLS, routes, and some basic limit rates to access your applications. This chapter covered the last topic necessary to start with practical applications of all these technologies in the next chapter.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Questions</h1>
			<p>Here are a few questions to validate your new knowledge:</p>
			<ul>
				<li>What is an ingress controller?</li>
				<li>When can you use an ingress controller?</li>
				<li>How can you create an ingress definition to expose your applications?</li>
				<li>How can you create your ingress definition for NGINX, Traefik, or Contour?</li>
				<li>How can you troubleshoot your ingress controllers and ingress definitions?</li>
				<li>How can you use MetalLB with your ingress controllers?</li>
			</ul>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Further reading</h1>
			<p>You can refer to the following references for more information on the topics covered in this chapter:</p>
			<ul>
				<li>Kubernetes Ingress documentation: <a href="https://kubernetes.io/docs/concepts/services-networking/ingress">https://kubernetes.io/docs/concepts/services-networking/ingress</a></li>
				<li>Install cert-manager with Helm: <a href="https://cert-manager.io/docs/installation/helm">https://cert-manager.io/docs/installation/helm</a></li>
				<li>Generating certificates for an ingress with cert-manager: <a href="https://cert-manager.io/docs/tutorials/acme/nginx-ingress">https://cert-manager.io/docs/tutorials/acme/nginx-ingress</a></li>
				<li>Kubernetes ingress controller official documentation: <a href="https://kubernetes.io/docs/concepts/services-networking/ingress">https://kubernetes.io/docs/concepts/services-networking/ingress</a></li>
				<li>Installing NGINX ingress controller: <a href="https://kubernetes.github.io/ingress-nginx/deploy/#using-helm">https://kubernetes.github.io/ingress-nginx/deploy/#using-helm</a></li>
				<li>Contour ingress controller getting started: <a href="https://projectcontour.io/getting-started">https://projectcontour.io/getting-started</a></li>
				<li>Contour rate limits: <a href="https://projectcontour.io/docs/v1.15.2/config/rate-limiting">https://projectcontour.io/docs/v1.15.2/config/rate-limiting</a></li>
				<li>Create a Kubernetes TLS Ingress from scratch in Minikube: <a href="https://www.youtube.com/watch?v=7K0gAYmWWho">https://www.youtube.com/watch?v=7K0gAYmWWho</a></li>
				<li>Traefik and Kubernetes: <a href="https://doc.traefik.io/traefik/v1.7/configuration/backends/kubernetes">https://doc.traefik.io/traefik/v1.7/configuration/backends/kubernetes</a></li>
				<li>JWT generator: <a href="https://jwt.io">https://jwt.io</a></li>
			</ul>
		</div>
	</body></html>