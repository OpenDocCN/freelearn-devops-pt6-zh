["```\noperator-sdk init --domain example.com --repo github.com/example/nginx-operator\n```", "```\n~/nginx-operator$ ls\ntotal 112K\ndrwxr-xr-x   12 mdame staff  384 Dec 22 21:07 . \ndrwxr-xr-x+ 282 mdame staff 8.9K Dec 22 21:06 .. \ndrwx------    8 mdame staff  256 Dec 22 21:07 config\ndrwx------    3 mdame staff   96 Dec 22 21:06 hack\n-rw-------    1 mdame staff  129 Dec 22 21:06 .dockerignore\n-rw-------    1 mdame staff  367 Dec 22 21:06 .gitignore\n-rw-------    1 mdame staff  776 Dec 22 21:06 Dockerfile\n-rw-------    1 mdame staff 8.7K Dec 22 21:07 Makefile\n-rw-------    1 mdame staff  228 Dec 22 21:07 PROJECT\n-rw-------    1 mdame staff  157 Dec 22 21:07 go.mod\n-rw-r--r--    1 mdame staff  76K Dec 22 21:07 go.sum\n-rw-------    1 mdame staff 2.8K Dec 22 21:06 main.go\n```", "```\noperator-sdk create api --group operator --version v1alpha1 --kind NginxOperator --resource --controller\n```", "```\n// NginxOperatorSpec defines the desired state of NginxOperator\n```", "```\ntype NginxOperatorSpec struct {\n```", "```\n  // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster\n```", "```\n  // Important: Run \"make\" to regenerate code after modifying this file\n```", "```\n  // Foo is an example field of NginxOperator. Edit nginxoperator_types.go to remove/update\n```", "```\n  Foo string `json:\"foo,omitempty\"`\n```", "```\n}\n```", "```\n// NginxOperatorStatus defines the observed state of NginxOperator\n```", "```\ntype NginxOperatorStatus struct {\n```", "```\n  // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster\n```", "```\n  // Important: Run \"make\" to regenerate code after modifying this file\n```", "```\n}\n```", "```\n//+kubebuilder:object:root=true\n```", "```\n//+kubebuilder:subresource:status\n```", "```\n// NginxOperator is the Schema for the nginxoperators API\n```", "```\ntype NginxOperator struct {\n```", "```\n  metav1.TypeMeta   `json:\",inline\"`\n```", "```\n  metav1.ObjectMeta `json:\"metadata,omitempty\"`\n```", "```\n  Spec   NginxOperatorSpec   `json:\"spec,omitempty\"`\n```", "```\n  Status NginxOperatorStatus `json:\"status,omitempty\"`\n```", "```\n}\n```", "```\n// NginxOperatorSpec defines the desired state of NginxOperator\n```", "```\ntype NginxOperatorSpec struct {\n```", "```\n   // Port is the port number to expose on the Nginx Pod\n```", "```\n   Port *int32 `json:\"port,omitempty\"`\n```", "```\n   // Replicas is the number of deployment replicas to scale\n```", "```\n   Replicas *int32 `json:\"replicas,omitempty\"`\n```", "```\n   // ForceRedploy is any string, modifying this field \n```", "```\n   // instructs  the Operator to redeploy the Operand\n```", "```\n   ForceRedploy string `json:\"forceRedploy,omitempty\"`\n```", "```\n}\n```", "```\n   // Port is the port number to expose on the Nginx Pod\n```", "```\n   // +kubebuilder:default=8080\n```", "```\n   // +kubebuilder:validation:Required\n```", "```\n   Port int `json:\"port\"`\n```", "```\n$ make manifests\n```", "```\napiVersion: apiextensions.k8s.io/v1\n```", "```\nkind: CustomResourceDefinition\n```", "```\nmetadata:\n```", "```\n  annotations:\n```", "```\n    controller-gen.kubebuilder.io/version: v0.7.0\n```", "```\n  creationTimestamp: null\n```", "```\n  name: nginxoperators.operator.example.comspec:\n```", "```\n  group: operator.example.com\n```", "```\n  names:\n```", "```\n    kind: NginxOperator\n```", "```\n    listKind: NginxOperatorList\n```", "```\n    plural: nginxoperators\n```", "```\n    singular: nginxoperator\n```", "```\n  scope: Namespaced\n```", "```\n  versions:\n```", "```\n  - name: v1alpha1\n```", "```\n    schema:\n```", "```\n      openAPIV3Schema:\n```", "```\n        description: NginxOperator is the Schema for the \n```", "```\n                     nginxoperators API\n```", "```\n        properties:\n```", "```\n          apiVersion:\n```", "```\n            description: 'APIVersion defines the versioned \n```", "```\n                          schema of this representation\n```", "```\n                          of an object. Servers should convert \n```", "```\n                          recognized schemas to the latest\n```", "```\n                          internal value, and may reject \n```", "```\n                          unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n```", "```\n            type: string\n```", "```\n          kind:\n```", "```\n            description: 'Kind is a string value representing \n```", "```\n                          the REST resource this\n```", "```\n                          object represents. Servers may infer \n```", "```\n                          this from the endpoint the client\n```", "```\n                          submits requests to. Cannot be \n```", "```\n                          updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n```", "```\n            type: string\n```", "```\n          metadata:\n```", "```\n            type: object\n```", "```\n          spec:\n```", "```\n            description: NginxOperatorSpec defines the desired \n```", "```\n                         state of NginxOperator\n```", "```\n            properties:\n```", "```\n              forceRedploy:\n```", "```\n                description: ForceRedploy is any string, \n```", "```\n                             modifying this field instructs\n```", "```\n                             the Operator to redeploy the \n```", "```\n                             Operand\n```", "```\n                type: string\n```", "```\n              port:\n```", "```\n                description: Port is the port number to expose \n```", "```\n                             on the Nginx Pod\n```", "```\n                type: integer\n```", "```\n              replicas:\n```", "```\n                description: Replicas is the number of \n```", "```\n                             deployment replicas to scale\n```", "```\n                type: integer\n```", "```\n            type: object\n```", "```\n          status:\n```", "```\n            description: NginxOperatorStatus defines the \n```", "```\n                         observed state of NginxOperator\n```", "```\n            type: object\n```", "```\n        type: object\n```", "```\n    served: true\n```", "```\n    storage: true\n```", "```\n    subresources:\n```", "```\n      status: {}\n```", "```\nstatus:\n```", "```\n  acceptedNames:\n```", "```\n    kind: \"\"\n```", "```\n    plural: \"\"\n```", "```\n  conditions: []\n```", "```\n  storedVersions: []\n```", "```\napiVersion: rbac.authorization.k8s.io/v1\n```", "```\nkind: ClusterRole\n```", "```\nmetadata:\n```", "```\n  creationTimestamp: null\n```", "```\n  name: manager-role\n```", "```\nrules:\n```", "```\n- apiGroups:\n```", "```\n  - operator.example.com\n```", "```\n  resources:\n```", "```\n  - nginxoperators\n```", "```\n  verbs:\n```", "```\n  - create\n```", "```\n  - delete\n```", "```\n  - get\n```", "```\n  - list\n```", "```\n  - patch\n```", "```\n  - update\n```", "```\n  - watch\n```", "```\n- apiGroups:\n```", "```\n  - operator.example.com\n```", "```\n  resources:\n```", "```\n  - nginxoperators/finalizers\n```", "```\n  verbs:\n```", "```\n  - update\n```", "```\n- apiGroups:\n```", "```\n  - operator.example.com\n```", "```\n  resources:\n```", "```\n  - nginxoperators/status\n```", "```\n  verbs:\n```", "```\n  - get\n```", "```\n  - patch\n```", "```\n  - update\n```", "```\nfunc nginxDeployment() *appsv1.Deployment {\n```", "```\n      dep := &appsv1.Deployment{\n```", "```\n            ObjectMeta: metav1.ObjectMeta{\n```", "```\n                  Name:      \"nginxDeployment\",\n```", "```\n                  Namespace: \"nginxDeploymentNS\",\n```", "```\n            },\n```", "```\n            Spec: appsv1.DeploymentSpec{\n```", "```\n               Replicas: &pointer.Int32Ptr(1),\n```", "```\n                Selector: &metav1.LabelSelector{\n```", "```\n                      MatchLabels: map[string]string{\"app\":\"nginx\"},\n```", "```\n                },\n```", "```\n                Template: corev1.PodTemplateSpec{\n```", "```\n                 ObjectMeta: metav1.ObjectMeta{\n```", "```\n                       Labels: map[string]string{\"app\":\"nginx\"},,          },      \n```", "```\n            Spec: corev1.PodSpec{ \n```", "```\n     Containers: []corev1.Container{{\n```", "```\n                                 Image:   \"nginx:latest\",\n```", "```\n                                 Name:    \"nginx\",\n```", "```\n                                 Command: []string{\"nginx\"                              Ports: []corev1.ContainerPort{{\n```", "```\n                                   ContainerPort: 8080,\n```", "```\n                                   Name:          \"nginx\",                                    }},                              }},\n```", "```\n                        },\n```", "```\n                  },            },\n```", "```\n      }\n```", "```\n      return dep\n```", "```\n}\n```", "```\napiVersion: apps/v1\n```", "```\nkind: Deployment\n```", "```\nmetadata:\n```", "```\n  name: \"nginx-deployment\"\n```", "```\n  namespace: \"nginx-operator-ns\"\n```", "```\n  labels:\n```", "```\n    app: \"nginx\"\n```", "```\nspec:\n```", "```\n  replicas: 1\n```", "```\n  selector:\n```", "```\n    matchLabels:\n```", "```\n      app: \"nginx\"\n```", "```\n  template:\n```", "```\n    metadata:\n```", "```\n      labels:\n```", "```\n        app: \"nginx\"\n```", "```\n    spec:\n```", "```\n      containers:\n```", "```\n        - name: \"nginx\"\n```", "```\n          image: \"nginx:latest\"\n```", "```\n          command: [\"nginx\"]\n```", "```\n$ go get -u github.com/go-bindata/go-bindata/...\n```", "```\n$ go-bindata -o assets/assets.go assets/...\n```", "```\n$ go-bindata -o assets/assets.go -ignore=\\assets\\/assets\\.go assets/… \n```", "```\nimport \"github.com/sample/nginx-operator/assets\"\n```", "```\n...\n```", "```\nasset, err := assets.Asset(\"nginx_deployment.yaml\")\n```", "```\nif err != nil {\n```", "```\n  // process object not found error\n```", "```\n}\n```", "```\npackage main\n```", "```\nimport (\n```", "```\n  ...\n```", "```\n  \"embed\"\n```", "```\n  ...\n```", "```\n)\n```", "```\n//go:embed assets/nginx_deployment.yaml\n```", "```\nvar deployment embed.FS\n```", "```\nimport (\n```", "```\n  appsv1 \"k8s.io/api/apps/v1\"\n```", "```\n  \"k8s.io/apimachinery/pkg/runtime\"\n```", "```\n  \"k8s.io/apimachinery/pkg/runtime/serializer\"\n```", "```\n)\n```", "```\n...\n```", "```\nvar (\n```", "```\n      appsScheme = runtime.NewScheme()\n```", "```\n      appsCodecs = serializer.NewCodecFactory(appsScheme)\n```", "```\n)\n```", "```\n...\n```", "```\nfunc main() {\n```", "```\nif err := appsv1.AddToScheme(appsScheme); err != nil {\n```", "```\n  panic(err)\n```", "```\n}\n```", "```\ndeploymentBytes, err := deployment.ReadFile(\"assets/nginx_deployment.yaml\")\n```", "```\nif err != nil {\n```", "```\n  panic(err)\n```", "```\n}\n```", "```\ndeploymentObject, err := runtime.Decode(appsCodecs.UniversalDecoder(appsv1.SchemeGroupVersion), deploymentBytes)\n```", "```\nif err != nil {\n```", "```\n  panic(err)\n```", "```\n}\n```", "```\ndep := deploymentObject.(*appsv1.Deployment)\n```", "```\n...\n```", "```\n}\n```", "```\n    import (\n      appsv1 \"k8s.io/api/apps/v1\"\n      \"k8s.io/apimachinery/pkg/runtime\"\n      \"k8s.io/apimachinery/pkg/runtime/serializer\"\n    )\n    ```", "```\n    var (\n         appsScheme = runtime.NewScheme()\n          appsCodecs = serializer.NewCodecFactory(appsScheme)\n    )\n    ```", "```\n    deploymentBytes, err := deployment.ReadFile(\"assets/nginx_deployment.yaml\") \n    if err != nil {\n      panic(err) \n    }\n    ```", "```\n    deploymentObject, err := runtime.Decode(appsCodecs.UniversalDecoder(appsv1.SchemeGroupVersion), deploymentBytes) \n    if err != nil {\n      panic(err)\n    }\n    ```", "```\n    dep := deploymentObject.(*appsv1.Deployment)\n    ```", "```\n./nginx-operator/\n| - assets/\n| - - assets.go\n| - - manifests/\n| - - - nginx_deployment.yaml\n```", "```\npackage assets\n```", "```\nimport (\n```", "```\n  \"embed\"\n```", "```\n  appsv1 \"k8s.io/api/apps/v1\"\n```", "```\n  \"k8s.io/apimachinery/pkg/runtime\"\n```", "```\n  \"k8s.io/apimachinery/pkg/runtime/serializer\"\n```", "```\n)\n```", "```\nvar (\n```", "```\n  //go:embed manifests/*\n```", "```\n  manifests embed.FS\n```", "```\n  appsScheme = runtime.NewScheme()\n```", "```\n  appsCodecs = serializer.NewCodecFactory(appsScheme)\n```", "```\n)\n```", "```\nfunc init() {\n```", "```\n  if err := appsv1.AddToScheme(appsScheme); err != nil {\n```", "```\n    panic(err)\n```", "```\n  }\n```", "```\n}\n```", "```\nfunc GetDeploymentFromFile(name string) *appsv1.Deployment {\n```", "```\n  deploymentBytes, err := manifests.ReadFile(name)\n```", "```\n  if err != nil {\n```", "```\n    panic(err)\n```", "```\n  }\n```", "```\n  deploymentObject, err := runtime.Decode(\n```", "```\n    appsCodecs.UniversalDecoder(appsv1.SchemeGroupVersion), \n```", "```\n    deploymentBytes,\n```", "```\n  )\n```", "```\n  if err != nil {\n```", "```\n    panic(err)\n```", "```\n  }\n```", "```\n  return deploymentObject.(*appsv1.Deployment)\n```", "```\n}\n```", "```\n    import \"github.com/sample/nginx-operator/assets\"\n    ...\n    nginxDeployment := assets.GetDeploymentFromFile(\"manifests/nginx_deployment.yaml\")\n    ```", "```\nfunc (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n```", "```\n  _ = log.FromContext(ctx)\n```", "```\n  // your logic here\n```", "```\n  return ctrl.Result{}, nil                                                                                                                                                                                   \n```", "```\n}\n```", "```\nfunc (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n```", "```\n  logger := log.FromContext(ctx)\n```", "```\n  operatorCR := &operatorv1alpha1.NginxOperator{}\n```", "```\n  err := r.Get(ctx, req.NamespacedName, operatorCR)\n```", "```\n  if err != nil && errors.IsNotFound(err) {\n```", "```\n    logger.Info(\"Operator resource object not found.\")\n```", "```\n    return ctrl.Result{}, nil\n```", "```\n  } else if err != nil {\n```", "```\n    logger.Error(err, \"Error getting operator resource object\")\n```", "```\n    return ctrl.Result{}, err\n```", "```\n  }\n```", "```\n  return ctrl.Result{}, nil\n```", "```\n}\n```", "```\ndeployment := &appsv1.Deployment{}\n```", "```\nerr = r.Get(ctx, req.NamespacedName, deployment)\n```", "```\nif err != nil && errors.IsNotFound(err) {\n```", "```\n  deployment.Namespace = req.Namespace\n```", "```\n  deployment.Name = req.Name\n```", "```\n  deploymentManifest := assets.GetDeploymentFromFile(\"manifests/nginx_deployment.yaml\")\n```", "```\n  deploymentManifest.Spec.Replicas = operatorCR.Spec.Replicas\n```", "```\ndeploymentManifest.Spec.Template.Spec.Containers[0].Ports[0].ContainerPort = *operatorCR.Spec.Port\n```", "```\n  err = r.Create(ctx, deploymentManifest)\n```", "```\n  if err != nil {\n```", "```\n    logger.Error(err, \"Error creating Nginx deployment.\")\n```", "```\n    return ctrl.Result{}, err\n```", "```\n  }\n```", "```\nreturn ctrl.Result{}, nil\n```", "```\n} else if err != nil {\n```", "```\n  logger.Error(err, \"Error getting existing Nginx deployment.\")\n```", "```\n  return ctrl.Result{}, err\n```", "```\n}\n```", "```\ndeployment := &appsv1.Deployment{}\n```", "```\ncreate := false\n```", "```\nerr = r.Get(ctx, req.NamespacedName, deployment)\n```", "```\n  if err != nil && errors.IsNotFound(err) {\n```", "```\n    create = true\n```", "```\n    deployment = assets.GetDeploymentFromFile(\"manifests/nginx_deployment.yaml\")\n```", "```\n} else if err != nil {\n```", "```\n  logger.Error(err, \"Error getting existing Nginx deployment.\")\n```", "```\n  return ctrl.Result{}, err\n```", "```\n}\n```", "```\nif operatorCR.Spec.Replicas != nil {\n```", "```\n  deployment.Spec.Replicas = operatorCR.Spec.Replicas\n```", "```\n}\n```", "```\nif operatorCR.Spec.Port != nil {\n```", "```\ndeployment.Spec.Template.Spec.Containers[0].Ports[0].ContainerPort = *operatorCR.Spec.Port\n```", "```\n}\n```", "```\nif create {\n```", "```\n  err = r.Create(ctx, deployment)\n```", "```\n} else {\n```", "```\n  err = r.Update(ctx, deployment)\n```", "```\n}\n```", "```\nreturn ctrl.Result{}, err\n```", "```\nfunc (r *NginxOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n```", "```\n   logger := log.FromContext(ctx)\n```", "```\n   operatorCR := &operatorv1alpha1.NginxOperator{}\n```", "```\n   err := r.Get(ctx, req.NamespacedName, operatorCR)\n```", "```\n   if err != nil && errors.IsNotFound(err) {\n```", "```\n      logger.Info(\"Operator resource object not found.\")\n```", "```\n      return ctrl.Result{}, nil\n```", "```\n   } else if err != nil {\n```", "```\n      logger.Error(err, \"Error getting operator resource object\")\n```", "```\n      return ctrl.Result{}, err\n```", "```\n   }\n```", "```\n   deployment := &appsv1.Deployment{}\n```", "```\n   create := false\n```", "```\n   err = r.Get(ctx, req.NamespacedName, deployment)\n```", "```\n   if err != nil && errors.IsNotFound(err) {\n```", "```\n      create = true\n```", "```\n      deployment = assets.GetDeploymentFromFile(\"assets/nginx_deployment.yaml\")\n```", "```\n   } else if err != nil {\n```", "```\n      logger.Error(err, \"Error getting existing Nginx deployment.\")\n```", "```\n      return ctrl.Result{}, err\n```", "```\n   }\n```", "```\n  deployment.Namespace = req.Namespace\n```", "```\n  deployment.Name = req.Name\n```", "```\n  if operatorCR.Spec.Replicas != nil {\n```", "```\n    deployment.Spec.Replicas = operatorCR.Spec.Replicas\n```", "```\n  }\n```", "```\n  if operatorCR.Spec.Port != nil { deployment.Spec.Template.Spec.Containers[0].Ports[0].ContainerPort = *operatorCR.Spec.Port\n```", "```\n  }\n```", "```\n  ctrl.SetControllerReference(operatorCR, deployment, r.Scheme)\n```", "```\n   if create {\n```", "```\n      err = r.Create(ctx, deployment)\n```", "```\n   } else {\n```", "```\n      err = r.Update(ctx, deployment)\n```", "```\n   }\n```", "```\n   return ctrl.Result{}, err\n```", "```\n}\n```", "```\n//+kubebuilder:rbac:groups=operator.example.com,resources=nginxoperators,verbs=get;list;watch;create;update;patch;delete\n```", "```\n//+kubebuilder:rbac:groups=operator.example.com,resources=nginxoperators/status,verbs=get;update;patch\n```", "```\n//+kubebuilder:rbac:groups=operator.example.com,resources=nginxoperators/finalizers,verbs=update\n```", "```\n//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete\n```", "```\nrules:\n```", "```\n- apiGroups:\n```", "```\n  - apps\n```", "```\n  resources:\n```", "```\n  - deployments\n```", "```\n  verbs:\n```", "```\n  - create\n```", "```\n  - delete\n```", "```\n  - get\n```", "```\n  - list\n```", "```\n  - patch\n```", "```\n  - update\n```", "```\n  - watch\n```", "```\n// SetupWithManager sets up the controller with the Manager.\n```", "```\nfunc (r *NginxOperatorReconciler) SetupWithManager(mgr ctrl.Manager) error {\n```", "```\n   return ctrl.NewControllerManagedBy(mgr).\n```", "```\n      For(&operatorv1alpha1.NginxOperator{}).\n```", "```\n      Complete(r)\n```", "```\n}\n```", "```\n// SetupWithManager sets up the controller with the Manager.\n```", "```\nfunc (r *NginxOperatorReconciler) SetupWithManager(mgr ctrl.Manager) error {\n```", "```\n   return ctrl.NewControllerManagedBy(mgr).\n```", "```\n      For(&operatorv1alpha1.NginxOperator{}).\n```", "```\n      Owns(&appsv1.Deployment{}).\n```", "```\n      Complete(r)\n```", "```\n}\n```"]