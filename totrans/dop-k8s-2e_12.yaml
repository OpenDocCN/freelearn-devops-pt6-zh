- en: Kubernetes on Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like AWS and GCP, Microsoft Azure's public cloud also has a hosted offering,
    which is Kubernetes. The **Azure Kubernetes Service** (**AKS**) was introduced
    in 2017\. Users of Azure can manage, deploy, and scale their containerized applications
    on AKS without worrying about the underlying infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll start by giving an introduction to Azure and then go
    through the major services that AKS uses. We''ll then learn how to launch an AKS
    cluster and play with it:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamental services in Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up AKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure cloud providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like GCP, Microsoft Azure provides **Platform as a Service** (**PaaS**). Users
    can deploy their applications to the Azure app service without having to know
    about detailed settings and VM management. Since 2010, Azure has been serving
    Microsoft software and third-party software to many users. Each Azure service
    provides different pricing tiers. In Azure, these pricing tiers are also called
    *SKUs* ([https://en.wikipedia.org/wiki/Stock_keeping_unit](https://en.wikipedia.org/wiki/Stock_keeping_unit)).
  prefs: []
  type: TYPE_NORMAL
- en: The **Azure Kubernetes Service** (**AKS**) was announced in 2017 as the new
    support for their original container orchestrator solution, **Azure Container
    Service** (**ACS**). Since then, container solutions in Azure focused more on
    Kubernetes support rather than other container orchestrators, such as Docker Enterprise
    and Mesosphere DC/OS. As a Kubernetes cloud provider, AKS provides some native
    support, such as Azure active directory for RBAC, Azure disks for storage class,
    Azure load balancers for services, and HTTP application routing for ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Resource groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A r**esource group** in Azure is a set of resources that represent a logical
    group. You can deploy and delete all the resources inside a group at once.** Azure
    resource manager** is a tool that's used to help you manage your resource groups.
    In line with the spirit of infrastructure as code ([https://en.wikipedia.org/wiki/Infrastructure_as_code](https://en.wikipedia.org/wiki/Infrastructure_as_code)),
    Azure provides a **resource manager template**, which is a file in JSON format
    that defines the configuration and the dependencies of the desired resources.
    Users can deploy the template to multiple resource groups for different environments
    repeatedly and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how these things look in the Azure portal. First, you'll need to have
    an Azure account. If you don't have one, go to [https://azure.microsoft.com/features/azure-portal/](https://azure.microsoft.com/features/azure-portal/)
    and sign up to get a free account. The Azure free account offers you 12 months
    of popular free services and $200 credit for 30 days. Credit card information
    is needed for account registration, but you won't be charged unless you upgrade
    your account type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in, click on Create a resource on the sidebar and go to Get started.
    We''ll see a web app there; click on it and input the app name. For resource creation,
    you''ll need to specify the Resource Group. We can either use an existing one
    or create a new one. Let''s create a new one for now, as we don''t have any resource
    groups yet. Change the Runtime Stack to your application runtime if needed. The
    screenshot for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34e44eb5-6cee-4034-ba74-561c0857afad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the page, beside the Create button, there is an Automation
    options button. If we click that, we''ll see that a resource template is created automatically.
    If we click Deploy, the custom parameters defined by the template will be shown.
    For now, we will just click on Create directly. Here is a screenshot of the resource
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c540cdf-d148-4dc5-8e4a-8947a9355356.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking Create, the console will bring us to the following view for
    us to explore. Let''s go to our newly created resource group, `devops-app`, under
    the Recent resources tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e89ab68-bb39-46fd-abc3-dcc4549b6666.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this resource group, we can see that there''s one application running in
    the App Services and one service plan. We can also see lots of functionalities
    in the sidebar. The resource group aims to give users a comprehensive view of
    a group of resources, so we don''t need to go to a different console to find them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7f3fdb9-61df-4a95-8a39-b39850d8b759.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the `devops-app` Resource group, it''ll bring us to the app
    service console, which is the PaaS offering in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3273794e-e707-49ec-8e76-8b0cfdf074e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the sample web app has been deployed to the Azure app service.
    If we visit the endpoint specified in the URL (which in this case is [https://devops-app.azurewebsites.net/](https://devops-app.azurewebsites.net/)),
    we can find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed27caa1-f71c-4ab3-86ff-0deb3099e3cd.png)'
  prefs: []
  type: TYPE_IMG
- en: We could also upload our own web app, or integrate with our version control
    software, such as GitHub or Bitbucket, and build our whole pipeline with Azure.
    For more information, please visit the deployment center page ([https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment](https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also easily delete resource groups in the Resource groups console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a19f2512-3930-4952-9348-87bc18657af1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After confirmation, the related resources will be cleaned up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/750d3964-3702-4c9f-b965-fc1f7e67f6b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Azure virtual network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Azure **Virtual Network** (**VNet**) creates an isolated private network
    segment in Azure. This concept is similar to VPC in AWS and GCP. Users specify
    a range of contiguous IPs (that is, CIDR: [https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)) and
    locations (otherwise known as regions in AWS). We can find a full list of locations
    at [https://azure.microsoft.com/global-infrastructure/locations/](https://azure.microsoft.com/global-infrastructure/locations/).
    We can also create multiple subnets inside a virtual network, or enable an Azure
    firewall upon creation. The Azure firewall is a network security service with
    high availability and scalability. It can control and filter traffic with user-specified
    rules. It also provides inbound DNAT and outbound SNAT support. Depending on the
    platform you're using, you can install the Azure CLI (the documentation for which
    can be found here: [https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest)) via
    the instructions at the following link: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest).
    Alternatively, you can use cloud shell ([https://shell.azure.com/](https://shell.azure.com/))
    directly. Azure cloud shell is a cloud-based admin shell that you can use to manage
    your cloud resources, which already has the Azure CLI installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll demonstrate how to use the Azure CLI to create
    an Azure virtual network via an Azure cloud shell. Simply log in to your account
    and attach cloud storage to persist the data. Then, we''re good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1977197-b1a1-48eb-83d5-467273385610.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking the Create button and waiting for a few seconds, a cloud shell
    console will be launched in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec96efff-d94c-40eb-b3d0-6f73400be4e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Azure CLI commands start with `az` as the group name. You could type `az
    --help` to see a list of subgroups or use `az $subgroup_name --help` any time
    to find more information about a subcommand for a subgroup. A subgroup might contain
    multiple subgroups. At the end of the command is the operation that you want to
    carry out with the resource and a set of parameters about the configuration. This
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we''ll create a virtual network named `devops-vnet`.
    First, we''ll have to create a new resource group, since we deleted the only one
    we had in the previous section. Now, let''s create a resource group called `devops`
    in the central US location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, the subgroup name is `group` and the operation command
    is `create`. Next, we''ll use `network.vnet` subgroups to create our virtual network
    resources with the CIDR `10.0.0.0/8`, and leave the rest of the settings as their
    default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We could always view a list of our settings using `az` with the `list` command,
    such as `az network vnet list`, or go to the Azure portal to check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0438a145-36fa-4913-8f55-f2d44d14b3b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Network security groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A network security group is associated with a virtual network and contains
    a set of security rules. A security rule defines the policies of the inbound and
    outbound traffic of subnets or virtual machines. Using the network security group,
    a user can define whether the inbound traffic is allowed to access the resources
    of a group, and also whether the outbound traffic is allowed. A security rule
    contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A priority (this can range from 100 to 4096; the lower the number, the higher
    the priority)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A source or destination (a CIDR block, a group of IPs, or another security group)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A protocol (TCP/UDP/ICMP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A direction (inbound/outbound)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A port range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action (allow/deny)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a network security group called `test-nsg`. Note that the user-defined
    rules are attached after the security group is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We find that Azure creates a set of default rules for each network security
    group. It denies all inbound traffic and allows access to outbound traffic by
    default. We can see that the source and destination cannot be a CIDR block, but
    instead have to be a service tag such as `VirtualNetwork`. These service tags
    are actually a set of predefined IP address prefixes. Azure manages the service
    tags and publishes them weekly. You can find the published service tags in the
    Microsoft download center ([https://www.microsoft.com/en-us/download/details.aspx?id=56519](https://www.microsoft.com/en-us/download/details.aspx?id=56519)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Direction** | **Priority** | **Source** | **Source ports** | **Destination**
    | **Dest ports** | **Protocol** | **Access** |'
  prefs: []
  type: TYPE_TB
- en: '| Inbound | `65000` | `VirtualNetwork` | `0`-`65535` | `VirtualNetwork` | `0`-`65535`
    | All | Allow |'
  prefs: []
  type: TYPE_TB
- en: '| Inbound | `65001` | `AzureLoadBalancer` | `0`-`65535` | `0.0.0.0/0` | `0`-`65535`
    | All | Allow |'
  prefs: []
  type: TYPE_TB
- en: '| Inbound | `65500` | `0.0.0.0/0` | `0`-`65535` | `0.0.0.0/0` | `0`-`65535`
    | All | Deny |'
  prefs: []
  type: TYPE_TB
- en: '| Outbound | `65000` | `VirtualNetwork` | `0`-`65535` | `VirtualNetwork` |
    `0`-`65535` | All | Allow |'
  prefs: []
  type: TYPE_TB
- en: '| Outbound | `0.0.0.0/0` | `0-65535` | `0`-`65535` | `Internet` | `0`-`65535`
    | All | Allow |'
  prefs: []
  type: TYPE_TB
- en: '| Outbound | `0.0.0.0/0` | `0-65535` | `0`-`65535` | `0.0.0.0/0` | `0`-`65535`
    | All | Deny |'
  prefs: []
  type: TYPE_TB
- en: 'We can now create a network security group that accepts all rules and has the
    highest priority, and attach it to the NSG we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Application security groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Application security groups are a logical collection of VM NICs, which can
    be a source of destinations in the network security group rules. They make network
    security groups even more flexible. For example, let''s assume that we have two
    VMs that will access the PostgreSQL database via `5432` ports. We want to make
    sure that only those VMs have access to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45569aa3-6d64-4810-804b-8343bb44ff42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create two application security groups named `web` and `db`. Then, we
    join the VMs to the web group and the database to the db group, and create the
    following network security group rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Direction** | **Priority** | **Source** | **Source ports** | **Destination**
    | **Dest ports** | **Protocol** | **Access** |'
  prefs: []
  type: TYPE_TB
- en: '| Inbound | 120 | * | * | `db` | `0`-`65535` | All | Deny |'
  prefs: []
  type: TYPE_TB
- en: '| Inbound | 110 | `web` | * | `db` | `5432` | TCP | Allow |'
  prefs: []
  type: TYPE_TB
- en: According to this table, the priority of the second rule is higher than the
    first one. Only the web group has access to the db group with port `5432`. All
    other inbound traffic will be denied.
  prefs: []
  type: TYPE_NORMAL
- en: Subnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A subnet can be associated to a network security group. A subnet can also be
    associated with a route table so that it has specific routes.
  prefs: []
  type: TYPE_NORMAL
- en: Just like AWS, Azure also provides route table resources for route management.
    By default, Azure already provides default routing for virtual networks and subnets.
    We don't need to worry about the routes when we use the AKS service.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a virtual network, a `default` subnet will be created by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than the default subnet, let''s create one more subnet with the prefix
    `10.0.1.0/24`. Note that the CIDR of the subnet needs to be in the same CIDR prefix
    network block as the VNet in which the subnet is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now list the subnets in this VNet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`jq` ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`jq` is a JSON command-line processor that is installed in the cloud shell
    by default. It''s a very convenient tool to list the desired fields inside a JSON
    output. If you''re not familiar with `jq`, take a look at the manual at the following
    link: [https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/).'
  prefs: []
  type: TYPE_NORMAL
- en: Azure virtual machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Virtual Machines** (**VM**) in Azure are like Amazon EC2s. To launch an instance,
    we have to know which VM image we want to launch. We can use the `az vm image
    list` command to list a set of images that we can use. In the following example,
    we''ll use a CentOS image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could use `az vm create` to launch our VM. Specifying `--generate-ssh-keys`
    will create an ssh for you to access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `publicIpAddress` of the newly created VM is `40.77.97.79`.
    Let''s connect to it with the username we specified earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It isn''t appropriate to allow SSH into the instance all the time. Let''s take
    a look at how to fix this. First, we''ll have to know the network interfaces that
    attach to this VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After we find the `id` of the NIC, we can find the associated network security
    group based on the NIC ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the name of the NSG is `newVMNSG`. Let''s list the rules
    that attach to this NSG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a `default-allow-ssh` rule with the ID `/subscriptions/f825790b-ac24-47a3-89b8-9b4b3974f0d5/resourceGroups/devops/providers/Microsoft.Network/networkSecurityGroups/newVMNSG/securityRules/default-allow-ssh`
    attached to the NSG. Let''s delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we delete the rule, we can no longer access the VM via SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Storage account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A storage account is a home for the storage objects provided by Azure storage
    solutions, such as files, tables, and disks. Users can create one or multiple
    storage accounts based on their usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of storage accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose v2 accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General-purpose v1 accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blob storage accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v1 is the legacy type of storage account and blob storage accounts only allow
    us to use blob storage. v2 accounts are the most recommended account type in Azure
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality of load balancers in Azure is similar to other public cloud
    offerings, which are used to route traffic to the backend. They also provide a
    health check to the endpoint and drain the connection if they find any unhealthy
    backends. The main difference between Azure load balancers to other load balancers
    is that Azure load balancers can have multiple IP addresses and multiple ports.
    This means that AKS doesn't need to create a new load balancer when a new LoadBalancer
    Service is created. Instead, it creates a new frontend IP inside the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Azure disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of Azure disks: managed disks and unmanaged disks. Before
    Azure managed disks, users had to create storage accounts to use unmanaged disks.
    A storage account might exceed the scalability target ([https://docs.microsoft.com/en-us/azure/storage/common/storage-scalability-targets](https://docs.microsoft.com/en-us/azure/storage/common/storage-scalability-targets))
    and impact the performance of I/O. With managed disks, we don''t need to create
    storage accounts by ourselves; Azure manages the accounts behind the scene. There
    are different types of performance tiers: standard HDD disks, standard SSD disks,
    and Premium SSD disks. HDD disks ([https://en.wikipedia.org/wiki/Hard_disk_drive](https://en.wikipedia.org/wiki/Hard_disk_drive))
    are a cost-effective option, while SSDs ([https://en.wikipedia.org/wiki/Solid-state_drive](https://en.wikipedia.org/wiki/Solid-state_drive))
    have better performance. For an I/O-intensive workload, the Premium tier is the
    best option. With premium SSD disks attaching to the VM, the VM can reach up to
    80,000 IOPS and 2,000 MB/s for disk throughput. Azure disks also offer four types
    of replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Locally-Redundant Storage (LRS)**: Data is only persisted in one single zone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone-Redundant Storage (ZRS)**: Data is persisted across three zones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geo-Redundant Storage (GRS)**: Cross-regional replication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-Access Geo-Redundant Storage (RA-GRS)**: Cross-regional replication
    with read replica'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Kubernetes service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure Kubernetes service is a hosted Kubernetes service in Azure. A cluster
    contains a set of nodes (such as Azure VMs). Just like a normal Kubernetes node,
    kube-proxy and kubelet are installed on the node. kube-proxy, which communicates
    with the Azure virtual NIC, manages the route in and out for services and pods.
    kubelet receives the request from the master, schedules the pods, and reports
    the metrics. In Azure, we could mount various Azure storage options such as Azure
    disk and Azure files as the **Persistent Volume** (**PV**) for persisting the
    data for containers. An illustration of this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27c939a1-a801-42c4-8239-1a2f2d8fc04f.png)'
  prefs: []
  type: TYPE_IMG
- en: Want to build a cluster from scratch?
  prefs: []
  type: TYPE_NORMAL
- en: If you would prefer to build a cluster on your own, be sure to check out the
    AKS-engine project ([https://github.com/Azure/aks-engine](https://github.com/Azure/aks-engine)),
    which builds Kubernetes infrastructure in Azure using the Azure resource manager.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your first Kubernetes cluster on AKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An AKS cluster can be launched in its own VPC (basic networking configuration)
    or in an existing VPC (advanced networking configuration); both can be launched
    via Azure CLI. There are a set of arguments that we can specify during cluster
    creation, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arguments** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `--name` | The cluster name. |'
  prefs: []
  type: TYPE_TB
- en: '| `--enable-addons` | Enables the Kubernetes addons module in a comma-separated
    list. |'
  prefs: []
  type: TYPE_TB
- en: '| `--generate-ssh-keys` | Generates SSH key files if they do not already exist.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--node-count` | The number of nodes. The default value is three. |'
  prefs: []
  type: TYPE_TB
- en: '| `--network-policy` | (Preview) Enables or disables the network policy. The
    default is that it is disabled. |'
  prefs: []
  type: TYPE_TB
- en: '| `--vnet-subnet-id` | The subnet ID in a VNet to deploy the cluster. |'
  prefs: []
  type: TYPE_TB
- en: '| `--node-vm-size` | The size of the VMs. The default is `Standard_DS2_v2`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--service-cidr` | A CIDR notation IP range from which to assign service
    cluster IPs. |'
  prefs: []
  type: TYPE_TB
- en: '| `--max-pods` | The default is `110` or `30` for an advanced network configuration
    (using an existing VNet). |'
  prefs: []
  type: TYPE_TB
- en: 'In the following example, we''ll first create a cluster with two nodes and
    enable `addons` for monitoring to enable Azure monitor for the cluster, and `http_application_routing`
    to enable HTTP application routing for ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After the cluster is launched, we can use the get-credentials subcommand to
    configure our `kubeconfig`. The context name will be the cluster name, which in
    this case is `myAKS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see whether the nodes have joined the cluster. Make sure that all of
    the nodes are in the `Ready` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to deploy a `ReplicaSet` via the example we used in `Chapter3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a service to access the `ReplicaSet`. We will use the `chapter3/3-2-3_Service/3-2-3_service.yaml`
    file and add the `type: LoadBalancer` line in the `spec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then watch the service until the `EXTERNAL-IP` changes to an external
    IP address. Here, we get `40.122.78.184`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's visit the site!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/261dd126-0f77-457d-bae6-f0bfb5885faf.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we have demonstrated how to deploy an nginx service
    to AKS and use its load balancer. How about if we already have a set of resources
    in an existing VNet, and we want to launch an AKS cluster inside the VNet to communicate
    with existing resources? Then, we need to use advanced networking in AKS. The
    fundamental difference between basic and advanced networking is that basic networking
    uses kubenet ([https://github.com/vplauzon/aks/tree/master/aks-kubenet](https://github.com/vplauzon/aks/tree/master/aks-kubenet))
    as a network plugin, while advanced networking uses the Azure CNI plugin ([https://github.com/Azure/azure-container-networking/tree/master/cni](https://github.com/Azure/azure-container-networking/tree/master/cni)). Compared
    to basic networking, advanced networking has more limitations. For example, the
    default maximum number of pods on a node is 30, instead of 110\. This is because
    only 30 additional IP addresses are configured by Azure CNI for the NIC on a node.
    The pod IPs are the secondary IPs on the NICs, so the private IPs are assigned
    the pods that are accessible inside the virtual network. When using kubenet, the
    cluster IPs are assigned to the pods, which don't belong to the virtual network
    but are instead managed by AKS. The cluster IPs won't be accessible outside of
    the cluster. Unless you have special requirements, such as if you want to gain
    access to the pods from outside the cluster or you want connectivity between existing
    resources and the cluster, the basic networking configuration should be able to
    fulfill most scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create an AKS cluster with advanced networking. We need
    to specify the existing subnet for the cluster. First, let''s list the subnet
    IDs in the VNet `devops-vnet` file that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the default subnet. Note that one subnet should only locate one
    AKS cluster in advanced networking. Also, the service CIDR we specified, which
    is used to assign cluster IPs, cannot overlap the subnet CIDR in which the cluster
    is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to configure `kubeconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we repeat the preceding code for `chapter3/3-2-3_Service/3-2-3_rs1.yaml`
    and `chapter3/3-2-3_Service/3-2-3_service.yaml`, we should be able to achieve
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Node pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like GKE, a node pool is a group of VMs of the same size. At the time of
    writing this book, multiple node pool support is on its way. Follow the discussion
    at [https://github.com/Azure/AKS/issues/759](https://github.com/Azure/AKS/issues/759),
    or watch for the official announcement.
  prefs: []
  type: TYPE_NORMAL
- en: Azure offers virtual machine scale sets as its autoscaling group solution. In
    Kubernetes 1.12, VMSS support became generally available. With VMSS, the VMs can
    be scaled out by VM metrics. For more information, check out the official documentation: [https://kubernetes.io/blog/2018/10/08/support-for-azure-vmss-cluster-autoscaler-and-user-assigned-identity/](https://kubernetes.io/blog/2018/10/08/support-for-azure-vmss-cluster-autoscaler-and-user-assigned-identity/)[.](https://kubernetes.io/blog/2018/10/08/support-for-azure-vmss-cluster-autoscaler-and-user-assigned-identity/)
  prefs: []
  type: TYPE_NORMAL
- en: Cluster upgrade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you upgrade the cluster, make sure your subscription has enough resources,
    since nodes will be replaced by rolling deployments. The additional node will
    be added to the cluster. To check the quota limit, use the `az vm list-usage --location
    $location` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see which Kubernetes version we''re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Azure CLI provides the `get-upgrades` subcommand to check which version
    the cluster can upgrade to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that we can upgrade to versions 1.10.8 and 1.10.9\. In Azure, minor
    versions cannot be skipped, meaning we can''t upgrade from 1.9.11 to 1.11.x. We
    have to upgrade the cluster to 1.10 first, and then upgrade to 1.11\. Upgrading
    from AKS is extremely easy, just like from GKE. Let''s say that we want to upgrade
    to 1.10.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After the operation is done, we can check the current version of the cluster.
    The cluster has now been upgraded to the desired version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The nodes should be upgraded to 1.10.9 as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring and logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We deployed the monitoring addons when we created the cluster. This lets us
    observe cluster metrics and logs easily via Azure monitoring. Let's visit the
    Kubernetes services in the Azure portal. You'll find the Monitoring tag with the
    insights, metrics, and logs sub-tabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The insights page shows the general cluster metrics, such as the node CPU,
    the memory utilization, and the node''s general health:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f57daa80-6e68-48f2-a061-29c55561bfad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also observe the container information from insights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db7761b-7654-460f-8292-715b38dcc1eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can find all the resource metrics that are supported on the Metrics page.
    For the AKS cluster, it''ll show some core metrics ([https://kubernetes.io/docs/tasks/debug-application-cluster/core-metrics-pipeline/](https://kubernetes.io/docs/tasks/debug-application-cluster/core-metrics-pipeline/)).
    This is handy because it means we don''t need to launch another monitoring system,
    such as Prometheus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bf0080e-55e5-4b5f-bc9b-ff980df4373a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the logs page, you can find cluster logs in Azure log analytics. You can
    run a query to search the logs via the supported syntax. For more information,
    you can find the Azure monitoring documentation at [https://docs.microsoft.com/en-us/azure/azure-monitor/log-query/log-query-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/log-query/log-query-overview):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04d132c3-f1d5-4c96-bd35-2ae51a05f7d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes cloud provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like other cloud providers, the cloud controller manager for Azure ([https://github.com/kubernetes/cloud-provider-azure](https://github.com/kubernetes/cloud-provider-azure))
    implements a bunch of integrations with Kubernetes. Azure cloud controller manager
    interacts with Azure and provides a seamless user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AKS is integrated with Azure active directory ([https://azure.microsoft.com/en-ca/services/active-directory/](https://azure.microsoft.com/en-ca/services/active-directory/))
    via OpenID connect tokens ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens)).
    The **Role-Based Access Control** (**RBAC**) feature can only be enabled during
    cluster creation, so let's start over to create an RBAC-enabled cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the cluster, we''ll have to prepare two application registrations
    in the Azure active directory first. The first acts as a server for the users''
    group membership. The second is like a client that integrates with kubectl. Let''s
    go to the Azure active registry service in the Azure portal first. Go to the Properties
    tab and record the Directory ID. We''ll need this later when we create the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6177fa43-1dab-4b5e-926b-cc4504dd4f50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go to the Application registrations of the Azure active registry service
    in the Azure portal first. The tab on the side shows two application registration
    options. One is the original design and the other is the preview version for the
    new console. Their functionalities are basically the same. We''ll show the GA
    version first and the preview version after:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e73b3c05-b8e1-41c8-bf3b-a18d59701a1a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the App registrations page, click New application registration. Add a name
    with any URL.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try an operation via `az ad app create --display-name myAKSAD --identifier-uris
    http://myAKSAD`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use `myAKSAD` as the name. After creation, we record the APPLICATION
    ID first. Here, we get `c7d828e7-bca0-4771-8f9d-50b9e1ea0afc`. After that, click
    Manifest and change the `groupMemebershipClaims` to `All`, which will get the
    group claims in the JWT token for all users that belong:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0b69bc5-c68d-4f4e-8d9b-a2a2ed96c47c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After saving the settings, go to these Settings page then the Keys page to
    create a key. Here, we specified expires as one year. This value was generated
    by the portal directly. We''ll need this password later when we create the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/740c5961-a7e7-442a-8e95-dd235a007df4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll define a set of applications and delegated permissions for this
    registration. Hit the Required permissions tab and click Add, before selecting
    Microsoft Graph. Here, we''ll select **Read directory data** under the Application
    permissions category andSign in and read user profile and Read directory dat**a**
    under the delegated permissions so that the server can read the directory data
    and verify the users. After clicking the Save button, we''ll see the following
    screen in the Required permissions page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9a1efc2-4a7e-4d20-bd0f-568636b2caad.png)'
  prefs: []
  type: TYPE_IMG
- en: As the admin, we can grant permission for all users in this directory by clicking
    the Grant permission button. This will make a window pop up that will double-check
    this with you. Click Yes to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to create a second application registration for the client.
    The name we used here is `myAKSADClient`. Record its Application ID after creation.
    Here, we get `b4309673-464e-4c95-adf9-afeb27cc8d4c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5cb6563-0fa8-429b-8eba-a2643c58dd88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the required permissions, the client just needs to access the application,
    search the delegated permissions, and find the Access permission with the display
    name that you created for the server. Don''t forget to hit the Grant permission
    button after you are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87d75bf6-a5aa-47d6-a95b-4af0091e0f19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right now, it''s time to create our AKS cluster with Azure AD integration.
    Make sure that you have recorded the following information from the previous operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Information we recorded** | **Corresponding argument in aks create** |'
  prefs: []
  type: TYPE_TB
- en: '| The server application ID | `--aad-server-app-id` |'
  prefs: []
  type: TYPE_TB
- en: '| The server application key (password) | `--aad-server-app-secret` |'
  prefs: []
  type: TYPE_TB
- en: '| The client application ID | `--aad-client-app-id` |'
  prefs: []
  type: TYPE_TB
- en: '| The directory ID | `--aad-tenant-id` |'
  prefs: []
  type: TYPE_TB
- en: 'It is now time to launch the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In Kubernetes, a role binding or a cluster role binding binds the role to a
    group of users. A role or cluster role defines a set of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the cluster is successfully launched, to integrate with OpenID, we''ll
    have to create the role binding or cluster role binding first. Here, we''ll use
    the existing cluster role in the cluster, which is `cluster-admin`. We''ll bind
    the users to the `cluster-admin` cluster role so that the users can be authenticated
    and act as cluster admins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For a single user, we''ll have to find the username. You can find the Object
    ID for the target user under the users page in the Azure AD portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e26469b-53ee-4008-bc31-5b79e6916f1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use user subjects and specify the Object ID as the name, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can start over to access the cluster resources, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems like we need to log in before listing any resources. Go to the [https://microsoft.com/devicelogin](https://microsoft.com/devicelogin) page and
    input the code, as the prompt suggests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03a87e70-3c62-41ed-b9b2-055dbcbd4c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Log in to your Microsoft account and return to the terminal. The integration
    looks great!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than specifying a set of users, you could choose to specify users as
    a group via the Azure AD group object ID. Replace the subject in the cluster role
    binding configuration so that all the users in that group will have cluster admin
    access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: StorageClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we launched AKS, it created two default storage classes for us, default
    and managed-premium:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the details of these storage classes, we find that they''re
    of the `Standard_LRS` and `Premium_LRS` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create our own storage class to create persistent volumes dynamically.
    Let''s say that we want to create a two-zone redundant storage with standard and
    premium types. We need to specify the location and the `skuName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The mapping of the `skuName` field and the storage types is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Replication** | **skuName** |'
  prefs: []
  type: TYPE_TB
- en: '| Premium | LRS | `Premium_LRS` |'
  prefs: []
  type: TYPE_TB
- en: '| Premium | ZRS | `Premium_ZRS` |'
  prefs: []
  type: TYPE_TB
- en: '| Standard | GRS | `Standard_GRS` |'
  prefs: []
  type: TYPE_TB
- en: '| Standard | LRS | `Standard_LRS` |'
  prefs: []
  type: TYPE_TB
- en: '| Standard | RAGRS | `Standard_RAGRS` |'
  prefs: []
  type: TYPE_TB
- en: '| Standard | ZRS | `Standard_ZRS` |'
  prefs: []
  type: TYPE_TB
- en: L4 LoadBalancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create an AKS cluster in basic networking, Azure will provision a load
    balancer called kubernetes in a dedicated resource group. When we create a service
    with a LoadBalancer type, AKS will provision a frontend IP and link to the service
    object automatically. This is how we could access `nginx` using external IPs earlier
    in this chapter. There are a set of annotations you can set in your service, and
    the Azure cloud controller will provision it based on the specified annotations.
    You can find a list of supported annotations here: [https://github.com/kubernetes/kubernetes/blob/master/pkg/cloudprovider/providers/azure/azure_loadbalancer.go](https://github.com/kubernetes/kubernetes/blob/master/pkg/cloudprovider/providers/azure/azure_loadbalancer.go).
  prefs: []
  type: TYPE_NORMAL
- en: Ingress controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azure supports HTTP application routing as an addon (the source code can be
    found at the following link: [https://github.com/Azure/application-gateway-kubernetes-ingress](https://github.com/Azure/application-gateway-kubernetes-ingress)). Earlier,
    we created the cluster with the `http_application_routing under --enable-addons argument` argument*.* AKS
    would have deployed a set of services to support ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can also enable ingress controller via the `az aks enable-addons` command after
    the cluster is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the ingress examples from `Chapter6`. What we have to do is specify `annotationkubernetes.io/ingress.class:
    addon-http-application-routing` in the `ingress` resource and the host name that
    AKS created for routing your HTTP application. You can find the host name in the `addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName`
    session when you create or list your cluster, or by using the `az aks show --query`
    command to search for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Azure is a powerful and enterprise-grade cloud computing platform.
    Beside AKS, it also provides various services in different fields, such as analytics,
    virtual reality, and much more. In this chapter, we touched the surface of Azure
    virtual network, subnets, and load balancing. We also learned how to deploy and
    administrate the Kubernetes service in Azure. We walked through how Azure provides
    Kubernetes resources via the cloud controller manager for Azure. We got to know
    how the cloud controller manager for Azure provides a seamless experience for
    Azure users, such as by creating an Azure load balancer when a LoadBalancer service
    in Kubernetes is requested or pre-creating an Azure disk storage class.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter of this book. We have tried to walk through both basic
    and more advanced concepts in this Kubernetes learning journey. Because Kubernetes
    is evolving rapidly, we strongly encourage you to join the Kubernetes community
    ([https://kubernetes.io/community/](https://kubernetes.io/community/)) to get
    inspired, discuss, and contribute!
  prefs: []
  type: TYPE_NORMAL
