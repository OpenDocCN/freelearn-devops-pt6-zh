<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer283">
<h1 class="chapterNumber">16</h1>
<h1 class="chapterTitle" id="_idParaDest-513">An Introduction to Istio</h1>
<blockquote class="packt_quote">
<p class="quote"> “If it makes it easier for users to use on the frontend, it’s probably complex on the backend.”</p>
</blockquote>
<p class="normal">This chapter will introduce you to Istio, a Service mesh add-on for Kubernetes. A Service mesh is a tool for Kubernetes that improves the management, security, and visibility of microservices in a cluster. It simplifies complex networking tasks by handling service-to-service communication, load balancing, and traffic routing outside the application code. Istio also enhances security with features like encryption, authentication, and authorization. It provides detailed metrics and monitoring, allowing developers to understand how their services are performing.</p>
<p class="normal">Istio is a large, complex system that provides benefits to your workloads by offering enhanced security, discovery, observability, traffic management, and more – all without requiring application developers to write modules or applications to handle each task.</p>
<p class="normal">While Istio presents a steep learning curve, mastering it unlocks the potential to offer developers advanced functionalities, enabling intricate Service mesh deployments and a broad spectrum of capabilities, including the ability to do the following:</p>
<ul>
<li class="bulletList">Route traffic based on various requirements</li>
<li class="bulletList">Secure service-to-service communication</li>
<li class="bulletList">Traffic shaping</li>
<li class="bulletList">Circuit breaking</li>
<li class="bulletList">Service observability</li>
<li class="bulletList">The future: Ambient mesh</li>
</ul>
<p class="normal">Developers can use these tools with minimal or no changes to their code. When something is easy for users, it often means there’s a lot of complexity behind the scenes, and Istio is a good example of this. This chapter will show you how to set up Istio and Kiali, a tool for monitoring. We’ll also discuss Istio’s key features that help manage traffic, enhance security, and reveal workloads.</p>
<p class="normal">To fully explain Istio, we’d need a whole other book focused just on its custom resources and ways to use them. Our aim in this chapter and the next is to give you the basic knowledge you need to start using Istio confidently. We can’t go into every detail about each component, so we recommend visiting the Istio website at <a href="https://istio.io"><span class="url">https://istio.io</span></a> for additional information to build on what you will learn in this chapter.</p>
<p class="normal">This chapter will cover the following topics:</p>
<ul>
<li class="bulletList">Understanding the control plane and data plane</li>
<li class="bulletList">Why should you care about a Service mesh?</li>
<li class="bulletList">Introduction to Istio concepts</li>
<li class="bulletList">Understanding Istio components</li>
<li class="bulletList">Installing Istio</li>
<li class="bulletList">Introducing Istio resources</li>
<li class="bulletList">Deploying add-on components to provide observability</li>
<li class="bulletList">Deploying an application into the Service mesh</li>
<li class="bulletList">The future: Ambient mesh</li>
</ul>
<p class="normal">Before we dive into the chapter, let’s set the scene for what you’re about to learn. This chapter is designed to introduce you to deploying Istio and the main features it provides. It gives you the key details to understand how Istio functions and what its various parts are. By the end of this chapter and the next chapter, where you’ll add an application to the mesh, you should have a good grasp of how to set up and use a basic Istio Service mesh.</p>
<p class="normal">We will close out the chapter with a look at the future of the Service mesh, known as the ambient mesh. As of the publishing of this book, the ambient mesh is still in beta, and since a lot of things can change between beta and a GA release, we will only provide an overview of what the ambient mesh will bring when it’s released.</p>
<p class="normal">To wrap up this introduction, here’s a fun fact about Kubernetes: like many things in Kubernetes, Istio is named after something related to the sea. In Greek, “Istio” means “sail.”</p>
<h1 class="heading-1" id="_idParaDest-514">Technical requirements</h1>
<p class="normal">This chapter has the following technical requirements:</p>
<ul>
<li class="bulletList">A Docker host installed using the steps from <em class="chapterRef">Chapter 1</em>, <em class="italic">Docker and Container Essentials</em>, with a minimum of 8 GB of RAM, although 16 GB is recommended</li>
<li class="bulletList">A KinD cluster configured using the initial scripts from <em class="chapterRef">Chapter 2</em>, <em class="italic">Deploying Kubernetes Using KinD</em></li>
<li class="bulletList">Installation scripts from this book’s GitHub repository</li>
</ul>
<p class="normal">You can access the code for this chapter by going to this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16"><span class="url">https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16</span></a>.</p>
<p class="normal">To use Istio to expose workloads, we will remove NGINX from the KinD cluster, which will allow Istio to utilize ports <code class="inlineCode">80</code> and <code class="inlineCode">443</code> on the host.</p>
<h1 class="heading-1" id="_idParaDest-515">Understanding the Control Plane and Data Plane</h1>
<p class="normal">The Service mesh framework enhances how microservices communicate, making these interactions more secure, faster, and more reliable. It is separated into two main components: the control plane and the data plane, each playing a specific role in providing service-to-service communication in Kubernetes. These two layers are what make up the Service mesh as a whole and a basic understanding of each is key to understanding Istio.</p>
<h2 class="heading-2" id="_idParaDest-516">The Control Plane</h2>
<p class="normal">Let’s start with the Istio control plane. </p>
<p class="normal">The control plane in Istio<a id="_idIndexMarker1463"/> is the central authority that controls and directs how services in the mesh communicate with each other. A common analogy is to think of a city’s traffic control, managing roads and traffic signals to ensure safe and efficient traffic flow and order. It plays an important role in the orchestration of service-to-service communication, security, and observability across the entire mesh. We will discuss the different features that are controlled by the control plane when we discuss the main control plane daemon, <code class="inlineCode">istiod</code>, in the <em class="italic">Understanding the Istio components</em> section.</p>
<h2 class="heading-2" id="_idParaDest-517">The Data Plane</h2>
<p class="normal">The second component<a id="_idIndexMarker1464"/> is the data plane, which is the worker layer<a id="_idIndexMarker1465"/> that contains a set of proxies, known as Envoy proxies, deployed alongside your services. These proxies intercept and manage the network traffic between microservices without the need for you or your developers to do any additional work or recoding.</p>
<p class="normal">To build on the previous analogy we used for the control plane, think of the data plane as the roads in a city. Each service in the mesh receives a dedicated road where traffic is directed to the service by a traffic controller – in our case, the Istio control plane (istiod).</p>
<p class="normal">Up until now, you may have been<a id="_idIndexMarker1466"/> using Kubernetes without a Service mesh. So, you may be wondering why you should care about the features that Istio brings to your cluster. In the next section, we will go over Istio’s features so you will be able to explain to your developers and businesses why a Service mesh is an important add-on to clusters.</p>
<h1 class="heading-1" id="_idParaDest-518">Why should you care about a Service mesh?</h1>
<p class="normal">Service meshes, like Istio, provide<a id="_idIndexMarker1467"/> several features that developers would typically need to develop on their own, necessitating changes to their existing code. Without Istio, if developers require specific capabilities, such as secure communication between services coded in various programming languages like Java, Python, or Node.js, they would need to implement the necessary code, or libraries, for each language individually. This adds complexity to the code and can often lead to inefficient coding, causing performance issues with the application.</p>
<p class="normal">Adding security, like encryption, is just one example of what a developer may require to create an application. What about other features, like controlling data flow, testing how the application will react to failures, or how network delays may cause the application to behave in an unexpected way? These, and many other features, are all included with Istio – allowing developers to focus on their own business code, rather than writing additional code to control traffic or to simulate errors or delays.</p>
<p class="normal">Let’s take a look at some of the advantages that Istio offers.</p>
<h2 class="heading-2" id="_idParaDest-519">Workload observability</h2>
<p class="normal">Downtime or slowdowns<a id="_idIndexMarker1468"/> in an application may impact your organization’s reputation and potentially cause lost revenue.</p>
<p class="normal">Have you ever found it challenging to pinpoint the underlying issue in an application with many active services? Imagine the ability to quickly identify and resolve problems by monitoring the interactions and status of services in real time, or by replaying events from the past to discover where things went wrong hours or days before.</p>
<p class="normal">Managing complex applications<a id="_idIndexMarker1469"/> and multiple services can feel overwhelming. The features offered by Istio make this task far less intimidating. If only there was a way to make this easier for developers! Thanks to Istio and its ecosystem, this isn’t just wishful thinking. With powerful features like Prometheus for storing metrics, Kiali for deep insights, and Jaeger for detailed tracing, you’re equipped with a powerful toolkit for troubleshooting.</p>
<p class="normal">In this chapter, we’re going to set up all three add-ons, with a focus on using Kiali, which lets you observe communications between your services like never before.</p>
<h2 class="heading-2" id="_idParaDest-520">Traffic management</h2>
<p class="normal">Istio provides you with powerful<a id="_idIndexMarker1470"/> traffic management<a id="_idIndexMarker1471"/> capabilities for your workloads, offering the flexibility to adopt any deployment model you need, without the hassle of altering your network infrastructure. This control is entirely in your and your developers’ hands. Istio also includes tools that enable you to simulate various unpredictable scenarios that your application might encounter, such as HTTP errors, delays, timeouts, and retries.</p>
<p class="normal">We recognize that some of our readers might be new to the concept of deployment models. Grasping the different types available is crucial for understanding, and appreciating, the benefits that Istio brings to the table. With Istio, developers can effectively utilize deployment strategies like blue/green and canary deployments.</p>
<h3 class="heading-3" id="_idParaDest-521">Blue/green deployments</h3>
<p class="normal">In this model, you deploy<a id="_idIndexMarker1472"/> two versions to production, directing a certain percentage of traffic to each version of the application, usually sending a low amount of traffic to the “new” (green) release. As you verify that the new deployment is working as expected, you can cut over all of the traffic to the green deployment, or you use blue/green combined with a canary deployment to the new version until you are eventually sending 100% of the traffic to the new deployment.</p>
<h3 class="heading-3" id="_idParaDest-522">Canary deployments</h3>
<p class="normal">This term comes from the mining<a id="_idIndexMarker1473"/> days when miners would put a canary in the mining shaft to verify it was safe to work in the environment. In the case of a deployment, it allows you to deploy an early test version of the application before graduating the release to a new version. Essentially, this is similar to the blue/green deployment, but in a canary deployment, you would direct a very small percentage of traffic to the canary version of the application. Using a small percentage of traffic will minimize any impact that the canary deployment may introduce. As you become more confident that the “canary” version of the application is stable, you will move<a id="_idIndexMarker1474"/> over additional traffic until you are 100% on the new version.</p>
<h2 class="heading-2" id="_idParaDest-523">Finding issues before they happen</h2>
<p class="normal">We can go a step further<a id="_idIndexMarker1475"/> from deployment models; Istio also provides tools for you to develop resilience and testing for your workloads before you deploy them and learn about issues from customers or end-users.</p>
<p class="normal">Have you ever worried about how an application will react to certain unseen events?</p>
<p class="normal">Developers need to worry about events that they have little control over, including:</p>
<ul>
<li class="bulletList">Application timeouts</li>
<li class="bulletList">Delays in communication</li>
<li class="bulletList">HTTP error codes</li>
<li class="bulletList">Retries</li>
</ul>
<p class="normal">Istio provides objects to assist in dealing with these by allowing you to create an issue with the workload before you move to production. This allows developers to capture and resolve issues in their applications before releasing them to production, creating a better user experience.</p>
<h2 class="heading-2" id="_idParaDest-524">Security</h2>
<p class="normal">In today’s world, security<a id="_idIndexMarker1476"/> is an issue we should all be concerned about. Many of the methods to secure a workload are complex and may require a skillset that many developers do not have. This is truly where Istio shines, providing the tools to easily deploy security and minimize its impact on development.</p>
<p class="normal">The first, and most popular, security feature<a id="_idIndexMarker1477"/> in Istio is the ability to provide <strong class="keyWord">mutual Transport Layer Security</strong> (<strong class="keyWord">mTLS</strong>) between workloads. Using mTLS, Istio provides not only encryption for communication but workload identity too. When you visit a website that has an expired certificate or a self-signed certificate, your browser will warn you that the site can’t be trusted. That’s because your browser performs server authentication when establishing a TLS connection by verifying that the certificate presented by the server is trusted by the browser. mTLS verifies trust from the client to the server, but also from the server to the client. That’s the mutual part. The server validates that the certificate presented by the client is trusted as well as the client validating the server. When you first start a cluster and use the initial certificate created for you, you’re using mTLS. Istio makes this much easier because it will create all of the certificates and identities for you using its built-in sidecar.</p>
<p class="normal">You can configure mTLS <a id="_idIndexMarker1478"/>as a requirement (STRICT), or as an option (PERMISSIVE), for the entire mesh or individual namespaces. If you set either option to STRICT, any communication to the service will require mTLS and if a request fails to provide an identity, the connection will be denied. However, if you set the PERMISSIVE option, traffic that has an identity and requests mTLS will be encrypted, while any request that does not provide an identity or encryption request will still be allowed to communicate.</p>
<p class="normal">Another feature provided will give you the ability to secure what communication is allowed to a workload, similar to a firewall, but in a much simpler implementation. Using Istio, you can decide to only allow HTTP GET requests, or only HTTP POST requests, or both – from only defined sources.</p>
<p class="normal">Finally, you can use <strong class="keyWord">JSON Web Tokens</strong> (<strong class="keyWord">JWTs</strong>) for initial user authentication<a id="_idIndexMarker1479"/> to limit who is authorized to communicate with a workload. This allows you to secure the initial communication attempt<a id="_idIndexMarker1480"/> by only accepting JWTs that come from an approved token provider.</p>
<p class="normal">Now that we have discussed some of the reasons you would want to deploy Istio, let’s introduce you to some Istio concepts.</p>
<h1 class="heading-1" id="_idParaDest-525">Introduction to Istio concepts</h1>
<p class="normal">The principles of Istio can be divided into four main areas: traffic management, security, observability, and extensibility. For each of these areas, we’ll introduce the components and custom resources that developers can utilize to tap into the benefits of using Istio.</p>
<h2 class="heading-2" id="_idParaDest-526">Understanding the Istio components</h2>
<p class="normal">Similar to a standard Kubernetes<a id="_idIndexMarker1481"/> cluster, Istio refers to two separate planes, the control plane and the data plane. Historically, the data plane included four different services, Pilot, Galley, Citadel, and Mixer – all broken out in a true microservices design. This design was used for multiple reasons, including the flexibility to break out the responsibilities to multiple teams, the ability to use different programming languages, and the ability to scale each service independently of the others.</p>
<p class="normal">Istio has evolved quickly since its initial release. The team made the decision that breaking out the core services had little benefit and, in the end, made Istio more complex. This led the team to redesign Istio and starting with Istio 1.5, Istio includes the components that we will discuss in this section.</p>
<h3 class="heading-3" id="_idParaDest-527">Making the Control Plane simple with istiod</h3>
<p class="normal">Just as Kubernetes bundles multiple<a id="_idIndexMarker1482"/> controllers into a single<a id="_idIndexMarker1483"/> executable, kube-controller-manager, the Istio team decided to bundle the control plane components into a single<a id="_idIndexMarker1484"/> daemon called istiod. This single daemon grouped all of the control plane components into a single pod that can be easily scaled as performance is required.</p>
<p class="normal">The main advantages to the single daemon are listed in an Istio blog at <a href="https://istio.io/latest/blog/2020/istiod/"><span class="url">https://istio.io/latest/blog/2020/istiod/</span></a>. To summarize the team’s reasoning, the single process provides:</p>
<ul>
<li class="bulletList">Easier and quicker control plane installations</li>
<li class="bulletList">Easier configuration</li>
<li class="bulletList">Integration of virtual machines into the Service mesh more easily, requiring a single agent and Istio’s certificates</li>
<li class="bulletList">Easier scaling</li>
<li class="bulletList">Reduced control plan startup time</li>
<li class="bulletList">A reduced amount of overall required resources</li>
</ul>
<p class="normal">The control plane is responsible for controlling your Service mesh. It has a number of important features that are required to create and manage the components of Istio, and in the next section, we will explain the features that istiod provides.</p>
<h4 class="heading-4">Breaking down the istiod pod</h4>
<p class="normal">Moving to a single binary<a id="_idIndexMarker1485"/> didn’t reduce Istio’s functionality or features; it still provides all of the features that the separate components provided, they are all just in a single binary now. Each piece provides a key feature to the Service mesh, and in this section, we will explain these features:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Service Discovery</strong>: Ensures that Envoy<a id="_idIndexMarker1486"/> proxies, deployed alongside a Service in the same pod, have up-to-date information about the network locations, including the IP address and ports of services in the mesh. Service Discovery provides efficient service-to-service communication across the mesh. </li>
</ul>
<p class="normal-one">Services can frequently scale up or down, and pods may be terminated or launched as part of rolling updates or auto-scaling activities. Each change can potentially alter the endpoints. Service discovery automates the process of tracking these changes by watching for updates to services and their associated pods. When a change has occurred, the Service discovery component updates the internal registry of Service endpoints and pushes these updates to the Envoy sidecars.</p>
<p class="normal-one">Service Discovery is essential for maintaining the responsiveness and efficiency of the Service mesh, dynamically adapting to the ever-changing landscape of containerized application environments in real time.</p>
<ul>
<li class="bulletList"><strong class="keyWord">Configuration Distribution</strong>: Handles the configuration of traffic routing, security protocols, and policy enforcement across the data plane’s sidecars. Configuration distribution centralizes functions that used to be performed<a id="_idIndexMarker1487"/> by a component called Galley, including the authorization of configuration changes in the Service mesh. </li>
<li class="bulletList"><strong class="keyWord">Certificate Lifecycle Management</strong>: Manages the issuing, renewal, and revocation of digital certificates, which are used for secure service-to-service communication using mutual Transport Layer Security (mTLS) guaranteeing<a id="_idIndexMarker1488"/> that was previously handled by a component called Citadel, which provided identity verification and management of certificates, guaranteeing that all services within the mesh can trust connections, without requiring any additional components or configuration. mTLS reduces security threats by encrypting the transferring of data between services, providing the confidentiality and integrity of communication within the Service mesh.</li>
<li class="bulletList"><strong class="keyWord">Automated Envoy Proxy Deployment</strong>: Streamlines the deployment process by automatically deploying Envoy sidecar proxies within Kubernetes pods. This seamless integration optimizes the management of both <code class="inlineCode">Egress</code> and <code class="inlineCode">Ingress</code> traffic through the pods, serving as an invisible mediator that oversees network traffic. </li>
</ul>
<p class="normal-one">This automated process<a id="_idIndexMarker1489"/> ensures that each pod in the Service mesh receives its own Envoy proxy, providing advanced traffic capabilities including routing, load distribution, and security measures. The automation of Envoy proxy deployment removes the complexities involved in establishing and upkeeping the Service mesh, allowing developers and operators to spend time on their primary responsibilities.</p>
<ul>
<li class="bulletList"><strong class="keyWord">Traffic Routing and Control</strong>: Responsible for creating and sharing the rules for managing traffic to Envoy proxies, providing a pivotal role in executing advanced network operations, and providing a way for precise control over often complex network traffic flows.</li>
</ul>
<p class="normal-one">The functionalities provided by traffic routing and control, include:</p>
<ul>
<li class="bulletList level-2">Determining the path(s) for directing traffic</li>
<li class="bulletList level-2">Strategic retry mechanisms</li>
<li class="bulletList level-2">Failover schemes to ensure continuity</li>
<li class="bulletList level-2">The introduction of faults for the purpose of creating realistic testing environments</li>
</ul>
<p class="normal-one">Traffic routing and controls provide a number of advantages, including streamlining the management of network traffic, testing the network’s stability and response under certain conditions, and increasing workload resilience by simulating disruptions and how the application reacts before they occur in production.</p>
<ul>
<li class="bulletList"><strong class="keyWord">Security Policy Enforcement</strong>: Uses security rules to make sure only authorized users or services have access and can interact within the network securely.</li>
<li class="bulletList"><strong class="keyWord">Observability Data Collection</strong>: In a Service mesh, it’s essential to keep an eye on how things are running and to quickly identify and solve any problems. This is where observability data collection comes into play, gathering and analyzing telemetry information, including metrics, logs, and traces from the data plane, enhancing the mesh’s monitoring and operational insight<a id="_idIndexMarker1490"/> capabilities.</li>
</ul>
<p class="normal">Now that we have discussed what istiod provides, we will move on to how incoming traffic is managed in the Service mesh using the <code class="inlineCode">istio-ingressgateway</code> component.</p>
<h3 class="heading-3" id="_idParaDest-528">Understanding istio-ingressgateway</h3>
<p class="normal">Moving on from the base<a id="_idIndexMarker1491"/> istiod pod, we come to one of the most important components of Istio, <code class="inlineCode">istio-ingressgateway</code>. This gateway facilitates external clients’ and services’ access to the Service mesh, acting as the entry point into the Kubernetes cluster. It’s standard for every Istio-enabled cluster to be equipped with at least one instance of <code class="inlineCode">istio-ingressgateway</code>. However, Istio’s design does not confine you to just one; depending on your specific needs, it’s possible to deploy multiple ingress gateways to serve various purposes or handle different traffic patterns.</p>
<p class="normal">The <code class="inlineCode">istio-ingressgateway</code> provides access to applications using two methods:</p>
<ol>
<li class="numberedList" value="1">Standard Kubernetes Ingress object support</li>
<li class="numberedList">Istio Gateway and VirtualService objects</li>
</ol>
<p class="normal">Since we have already discussed and deployed NGINX as an Ingress controller, we will not cover using Envoy as a standard Ingress controller; instead, we will focus on the second method of using Gateways and Virtual Services for incoming requests.</p>
<p class="normal">Using Gateways to expose<a id="_idIndexMarker1492"/> our services provides more flexibility, customization, and security over a standard Ingress object.</p>
<h3 class="heading-3" id="_idParaDest-529">Understanding istio-egressgateway</h3>
<p class="normal">The <code class="inlineCode">istio-egressgateway</code><a id="_idIndexMarker1493"/> is designed to direct traffic from sidecars to either a single pod or a collection of pods, thereby centralizing the exiting (egress) traffic from the Service mesh. Normally, Istio sidecars manage both incoming and outgoing traffic for services within the mesh. While <code class="inlineCode">istio-ingressgateway</code> is utilized for managing incoming traffic to the mesh, implementing <code class="inlineCode">istio-egressgateway</code> allows for the regulation of outgoing traffic as well. The functionalities and details of both <code class="inlineCode">ingressgateway</code> and <code class="inlineCode">egressgateway</code> will be explored thoroughly in the <em class="italic">Introducing Istio resources</em> section.</p>
<p class="normal">Now, let’s jump into how you install Istio in a cluster.</p>
<h1 class="heading-1" id="_idParaDest-530">Installing Istio</h1>
<p class="normal">There are multiple methods<a id="_idIndexMarker1494"/> to deploy Istio. The most common methods today are to use either <code class="inlineCode">istioctl</code> or Helm, but there are additional options depending on your organization. You may elect to use one of the alternative installation methods of creating manifests via <code class="inlineCode">istoctl</code> or Helm.</p>
<p class="normal">A brief list of advantages and disadvantages for each method is detailed in <em class="italic">Table 16.1</em>:</p>
<table class="table-container" id="table001-9">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Deployment method</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Advantages</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Disadvantages</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">istioctl</code></p>
</td>
<td class="table-cell">
<p class="normal">Configuration validation and health checks</p>
<p class="normal">Does not require any privileged pods, increasing cluster security</p>
<p class="normal">Multiple configuration options</p>
</td>
<td class="table-cell">
<p class="normal">Each Istio version requires a new binary</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Istio operator</p>
</td>
<td class="table-cell">
<p class="normal">Configuration validation and health</p>
<p class="normal">Does not require multiple binaries for each Istio version</p>
<p class="normal">Multiple configuration options</p>
</td>
<td class="table-cell">
<p class="normal">Requires a privileged pod running in the cluster</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Manifests (via <code class="inlineCode">istioctl</code>)</p>
</td>
<td class="table-cell">
<p class="normal">Generates manifests that can be customized before deploying using <code class="inlineCode">kubectl</code></p>
<p class="normal">Multiple configuration options</p>
</td>
<td class="table-cell">
<p class="normal">Not all checks are performed, which could lead to deployment errors</p>
<p class="normal">Error checks and reporting are limited when compared to using <code class="inlineCode">istioctl</code> or the Istio operator</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Helm</p>
</td>
<td class="table-cell">
<p class="normal">Helm and charts are well known to most Kubernetes users</p>
<p class="normal">Leverages Helm standards, which allow for easy management of deployments</p>
</td>
<td class="table-cell">
<p class="normal">Offers the least validation checks of all deployment options</p>
<p class="normal">Most tasks will require additional work and complexity versus the other deployment models</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 16.1: Istio deployment methods</p>
<p class="normal">For this chapter, we will focus<a id="_idIndexMarker1495"/> on using the <code class="inlineCode">istioctl</code> binary for installation, and in the next section, we will deploy Istio using <code class="inlineCode">istioctl</code>.</p>
<h2 class="heading-2" id="_idParaDest-531">Downloading Istio</h2>
<p class="normal">We have included<a id="_idIndexMarker1496"/> a script that will deploy Istio, output the verification of the installation, remove NGINX Ingress, and expose <code class="inlineCode">istio-ingressgateway</code> as the Ingress to our KinD cluster. The manual process is provided below if you prefer to install it manually using <code class="inlineCode">istioctl</code>. The script, <code class="inlineCode">install-istio.sh</code>, is provided for readers who may use it in automation for their own testing and is located in the <code class="inlineCode">chapter16</code> directory.</p>
<p class="normal">The first thing that we need is to define the version of Istio we want to deploy. We can do this by setting an environment variable, and in our example, we want to deploy Istio 1.20.3. First, make sure you are in the <code class="inlineCode">chapter16</code> directory where you cloned the repo and execute the following command:</p>
<pre class="programlisting con"><code class="hljs-con">curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.20.3 TARGET_ARCH=x86_64 sh -
</code></pre>
<p class="normal">This will download the installation script and execute it using the <code class="inlineCode">ISTIO_VERSION</code> that we defined before executing the <code class="inlineCode">curl</code> command. After executing, you will have an <code class="inlineCode">istio-1.20.3</code> directory in your current working directory.</p>
<p class="normal">Finally, since we will be using <a id="_idIndexMarker1497"/>executables from the <code class="inlineCode">istio-1.12.3</code> directory, you should add it to your <code class="inlineCode">path</code> statement. To make this easier, you should be in the <code class="inlineCode">chapter16</code> directory from the book repository before setting the <code class="inlineCode">path</code> variable:</p>
<pre class="programlisting con"><code class="hljs-con">export PATH="$PATH:$PWD/istio-1.20.3/bin"
</code></pre>
<h2 class="heading-2" id="_idParaDest-532">Installing Istio using a profile</h2>
<p class="normal">To make deploying<a id="_idIndexMarker1498"/> Istio easier, the team<a id="_idIndexMarker1499"/> has included a number of pre-defined profiles. Each profile defines which components are deployed and the default configuration. There are seven profiles included, but only five profiles are used for most deployments.</p>
<table class="table-container" id="table002-7">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Profile</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Installed Components</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Default</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">istio-ingressgateway</code> and <code class="inlineCode">istiod</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Demo</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">istio-egressgateway</code>, <code class="inlineCode">istio-ingressgateway</code>, and <code class="inlineCode">istiod</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Minimal</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">istiod</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Preview</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">istio-ingressgateway</code> and <code class="inlineCode">istiod</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Ambient</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">istiod</code>, CNI, and Ztunnel</p>
<p class="normal">Note: In the 1.20.3 Istio release, ambient mesh is an alpha feature</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 16.2: Istio profiles</p>
<p class="normal">If none of the included profiles fit your deployment requirements, you can create a customized deployment. This is beyond the scope of this chapter since we will be using the included demo profile – however, you can read more<a id="_idIndexMarker1500"/> about customizing the configuration on Istio’s site: <a href="https://istio.io/latest/docs/setup/additional-setup/customize-installation/"><span class="url">https://istio.io/latest/docs/setup/additional-setup/customize-installation/</span></a>.</p>
<p class="normal">To deploy Istio using the demo profile using <code class="inlineCode">istioctl</code>, we simply need to execute a single command:</p>
<pre class="programlisting con"><code class="hljs-con">istioctl manifest install --set profile=demo
</code></pre>
<p class="normal">The installer will ask you to verify that you want to deploy Istio using the default profile, which will deploy all of the Istio components:</p>
<pre class="programlisting con"><code class="hljs-con">This will install the Istio 1.20.3 "demo" profile (with components: Istio core, Istiod, Ingress gateways, and Egress gateways) into the cluster. Proceed? (y/N)
</code></pre>
<p class="normal">Press the <em class="keystroke">y</em> key to say yes to proceed with the deployment. If you want to bypass the confirmation, you can add an option to the <code class="inlineCode">istioctl</code> command line, <code class="inlineCode">--skip-confirmation</code>, which tells <code class="inlineCode">istioctl</code> to bypass the confirmation.</p>
<p class="normal">If everything went well, you should see a confirmation that each component was installed, and a completion message that thanks you for installing Istio.</p>
<pre class="programlisting con"><code class="hljs-con"><img alt="" height="13" src="../Images/tick1.png" width="13"/> Istio core installed
<img alt="" height="13" src="../Images/tick1.png" width="13"/> Istiod installed
<img alt="" height="13" src="../Images/tick1.png" width="13"/> Egress gateways installed
<img alt="" height="13" src="../Images/tick1.png" width="13"/> Ingress gateways installed
<img alt="" height="13" src="../Images/tick1.png" width="13"/> Installation complete                                                                                                                                       Made this installation the default for injection and validation.
</code></pre>
<p class="normal">The <code class="inlineCode">istioctl</code> executable can be used to verify<a id="_idIndexMarker1501"/> the installation. To verify<a id="_idIndexMarker1502"/> the installation, you require a manifest. Since we used <code class="inlineCode">istioctl</code> to deploy Istio directly, we do not have a manifest, so we need to create one to check our installation.</p>
<pre class="programlisting con"><code class="hljs-con">istioctl manifest generate --set profile=demo &gt; istio-kind.yaml
</code></pre>
<p class="normal">Then run the <code class="inlineCode">istioctl verify-install</code> command.</p>
<pre class="programlisting con"><code class="hljs-con">istioctl verify-install -f istio-kind.yaml
</code></pre>
<p class="normal">This will verify each component, and once verified, it will provide a summary similar to the output below:</p>
<pre class="programlisting con"><code class="hljs-con">Checked 15 custom resource definitions
Checked 3 Istio Deployments
✔ Istio is installed and verified successfully
</code></pre>
<p class="normal">Now that we have verified the installation, let’s look at what <code class="inlineCode">istioctl</code> created:</p>
<ul>
<li class="bulletList">A new namespace called <code class="inlineCode">istio-system</code>.</li>
<li class="bulletList">Three deployments were created, and a corresponding service for each:<ul>
<li class="bulletList level-2"><code class="inlineCode">istio-ingressgateway</code></li>
<li class="bulletList level-2"><code class="inlineCode">istio-egressgateway</code></li>
<li class="bulletList level-2"><code class="inlineCode">istiod</code></li>
</ul>
</li>
<li class="bulletList">15 <strong class="keyWord">CustomResourceDefinitions</strong> (<strong class="keyWord">CRDs</strong>) to provide the Istio <a id="_idIndexMarker1503"/>resources, including:<ul>
<li class="bulletList level-2"><code class="inlineCode">destinationrules.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">envoyfilters.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">gateways.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">istiooperators.install.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">peerauthentications.security.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">proxyconfigs.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">requestauthentications.security.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">serviceentries.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">sidecars.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">telemetries.telemetry.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">virtualservices.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">wasmplugins.extensions.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">workloadentries.networking.istio.io</code></li>
<li class="bulletList level-2"><code class="inlineCode">workloadgroups.networking.istio.io</code></li>
</ul>
</li>
</ul>
<p class="normal">At this stage, there’s no need to be concerned<a id="_idIndexMarker1504"/> with the details<a id="_idIndexMarker1505"/> of the Custom Resources (CRs). As we progress through this chapter, we’ll delve into the specifics of the most commonly used resources. Following that, in the next chapter, we’ll cover how to deploy an application into the mesh, which will make use of several of the CRs that have been deployed.</p>
<div class="note">
<p class="normal">For any CRs that are not covered in this chapter or the next chapter, you can reference<a id="_idIndexMarker1506"/> the documentation on the istio.io site, located here: <a href="http://istio.io/latest/docs"><span class="url">istio.io/latest/docs</span></a></p>
</div>
<h2 class="heading-2" id="_idParaDest-533">Exposing Istio in a KinD cluster</h2>
<p class="normal">With Istio deployed, our next step<a id="_idIndexMarker1507"/> is to expose it to our network<a id="_idIndexMarker1508"/> so we can access the applications we’ll build. Since we’re running on KinD, this can be tricky. Docker is forwarding all traffic from port <code class="inlineCode">80</code> (HTTP) and <code class="inlineCode">443</code> (HTTPS) on our KinD server to the worker node. The worker node is in turn running the NGINX Ingress controller on ports <code class="inlineCode">443</code> and <code class="inlineCode">80</code> to receive that traffic. In a real-world scenario, we’d use an external load balancer, like MetalLB, to expose the individual services via a LoadBalancer. For our labs though, we’re going to instead focus on simplicity.</p>
<p class="normal">When you executed the previous script to install Istio, the last step ran a separate script called <code class="inlineCode">expose_istio.sh</code> that does two things. First, it will delete the <code class="inlineCode">ingress-nginx</code> namespace, removing NGINX and freeing up ports <code class="inlineCode">80</code> and <code class="inlineCode">443</code> on the Docker host. Second, it will patch the <code class="inlineCode">istio-ingressgateway</code> Deployment in the <code class="inlineCode">istio-system</code> namespace so that it runs on ports <code class="inlineCode">80</code> and <code class="inlineCode">443</code> on the worker node. </p>
<p class="normal">Since the script was executed<a id="_idIndexMarker1509"/> as part of the installation, you do not need<a id="_idIndexMarker1510"/> to execute it again.</p>
<p class="normal">Now that we have Istio fully deployed in our cluster and we know the custom resources that Istio includes, let’s move on to the next section, which will explain each resource and its use-cases.</p>
<h1 class="heading-1" id="_idParaDest-534">Introducing Istio resources</h1>
<p class="normal">Istio’s custom resources<a id="_idIndexMarker1511"/> provide powerful features to your cluster and each one could take up a chapter by itself.</p>
<p class="normal">In this section, we want to provide enough details so you will have a strong understanding of each object. After the object overview, we will deploy a basic application that will demonstrate many of the objects in a real-world application example.</p>
<h2 class="heading-2" id="_idParaDest-535">Authorization policies</h2>
<p class="normal">Authorization policies are<a id="_idIndexMarker1512"/> optional; however, if you do<a id="_idIndexMarker1513"/> not create any, all requests to resources will be allowed access to your cluster workloads. This may be the desired default action for some organizations, but most enterprises should deploy workloads based on the least required privileges. This means that you should only allow what access is required for accessing the application – nothing more and nothing less. Least privilege access is often overlooked by organizations since it adds some complexity to access and if not configured correctly, it may deny access to valid requests. While this is true, it is not a valid argument to leave your systems wide open to all access requests. </p>
<p class="normal">Istio’s authorization policies offer detailed access management for services within your mesh, allowing you to define access rights based on the identities of the callers and their permissions. They provide developers with the ability to control access to workloads based on actions including deny, allow, and custom. </p>
<p class="normal">Before explaining policies in more depth, we need<a id="_idIndexMarker1514"/> to start with a concept called <strong class="keyWord">implicit enablement</strong>. This means that when <strong class="keyWord">any</strong> authorization policy matches a request, Istio will change the default allow all to a deny for any request that doesn’t have a match in the policy.</p>
<p class="normal">Let’s use an example to explain this in more detail. We have an NGINX server running in a namespace where Istio has been enabled and we have a standard that access to port <code class="inlineCode">80</code> must be denied. </p>
<p class="normal">At a quick glance, this looks like it should be an easy policy, we would simply create a deny policy that contains port <code class="inlineCode">80</code>. So, we create the policy and deploy it to our cluster – and to verify the policy, we try to access the website on port <code class="inlineCode">80</code>. We open a browser and, as expected, we cannot access the site. Great! Now let’s verify that we can access the site on port <code class="inlineCode">443</code>. We change the URL to access the site using port <code class="inlineCode">443</code>, and to our surprise, it is also <em class="italic">denied</em>.</p>
<p class="normal">Wait, what!?!? The deny policy only denies port <code class="inlineCode">80</code> – why is port <code class="inlineCode">443</code> also being denied?</p>
<p class="normal">This is <strong class="keyWord">implicit enablement</strong> in action and it can be confusing<a id="_idIndexMarker1515"/> at first for anyone<a id="_idIndexMarker1516"/> who is new to Istio. As discussed at the beginning of this section, when a policy is created and a request matches that policy, Istio will change from an <em class="italic">allow all</em> security posture, to a <em class="italic">deny all</em> security posture. Even though we intended to deny access to only port <code class="inlineCode">80</code>, without an allow policy for port <code class="inlineCode">443</code>, access will also be denied.</p>
<p class="normal">To complete the requirement, and allow access to our NGINX site on port <code class="inlineCode">443</code>, we would need to create an allow policy that allows all incoming traffic to port <code class="inlineCode">443</code>. We will explain this in more depth in a minute.</p>
<p class="normal">Understanding how a policy’s actions are evaluated is very important, since a misconfigured policy may not provide the expected results. The high-level flow for policy evaluation is shown in <em class="italic">Figure 16.1</em>.</p>
<figure class="mediaobject"><img alt="" height="613" src="../Images/B21165_16_01.png" width="552"/></figure>
<p class="packt_figref">Figure 16.1: Istio policy evaluation flow</p>
<ol>
<li class="numberedList" value="1">If the evaluation<a id="_idIndexMarker1517"/> of a <strong class="keyWord">CUSTOM</strong> action defines a <strong class="keyWord">DENY</strong> to the request, the access<a id="_idIndexMarker1518"/> is denied, and the evaluation process stops.</li>
<li class="numberedList">Next, if a <strong class="keyWord">DENY</strong> policy matches the request, the request is denied access to the resource, and the evaluation process stops.</li>
<li class="numberedList">If there are no <strong class="keyWord">ALLOW</strong> policies that match the request, access will be denied to the request.</li>
<li class="numberedList">If an <strong class="keyWord">ALLOW</strong> policy matches the request, access to the resource is granted.</li>
</ol>
<p class="normal">Along with understanding the flow of policies, you need to understand how conflicting policies will be implemented. If a policy has any conflicting rules, like denying and allowing the same request, the deny policy will be evaluated first and the request will be denied<a id="_idIndexMarker1519"/> since the deny policy is evaluated before the allow policy. It’s also very important to note that if you allow a certain action, like an HTTP GET, the GET request would be allowed, but any other operation would be denied since it has not been allowed by the policy.</p>
<p class="normal">Authorization policies can get very<a id="_idIndexMarker1520"/> complex. The Istio team<a id="_idIndexMarker1521"/> has created a page with multiple examples on the Istio site at <a href="https://istio.io/latest/docs/reference/config/security/authorization-policy/"><span class="url">https://istio.io/latest/docs/reference/config/security/authorization-policy/</span></a>.</p>
<p class="normal">Policies can be broken down into scope, action, and rules:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Scope</strong>: The scope defines<a id="_idIndexMarker1522"/> what object(s) will be enforced by the policy. You can scope a policy to the entire mesh, a namespace, or any Kubernetes object label like a pod.</li>
<li class="bulletList"><strong class="keyWord">Actions</strong>: There can be one of three actions<a id="_idIndexMarker1523"/> defined, CUSTOM, ALLOW, or DENIED – each either denying or allowing a request based on the defined rules. ALLOW and DENY are the most commonly used actions, but CUSTOM actions are beneficial when you require complex logic that ALLOW or DENY cannot handle, using an external system for additional decision making.</li>
<li class="bulletList"><strong class="keyWord">Rules</strong>: Define what actions<a id="_idIndexMarker1524"/> will be allowed or denied by the request. Rules can become very complex, allowing you to define actions based on source and destination, different operations, keys, and more.</li>
</ul>
<p class="normal">To help understand the flow, let’s look at a few example authorization policies and what access will be applied when the policy is evaluated.</p>
<p class="normal">We will deploy a larger application later in the chapter. If you want to see how the example policies work in this section, you can deploy an NGINX web server using the script in the <code class="inlineCode">chapter16/testapp</code> directory called <code class="inlineCode">deploy-testapp.sh</code>. This will create all of the required Kubernetes and Istio objects to test the policies in a real cluster.</p>
<p class="normal">Once you have executed the script and the objects have been created, test that NGINX is working by curling to the <code class="inlineCode">nip.io</code> VirtualService that was created. On our server, it created <code class="inlineCode">testapp.10.3.1.248.nip.io</code>.</p>
<pre class="programlisting con"><code class="hljs-con">curl -v testapp.10.3.1.248.nip.io
</code></pre>
<p class="normal">This should display the NGINX welcome page. Now, we can create some example policies to show how authorization policies work. Each of the three examples is in the <code class="inlineCode">chapter16/testapp</code> directory named <code class="inlineCode">exampleX-policy.yaml</code>, where <code class="inlineCode">X</code> is equal to <code class="inlineCode">1</code>, <code class="inlineCode">2</code>, or <code class="inlineCode">3</code> – each<a id="_idIndexMarker1525"/> can be deployed<a id="_idIndexMarker1526"/> using the <code class="inlineCode">kubectl apply &lt;policyname&gt; -n testapp</code> command.</p>
<h3 class="heading-3" id="_idParaDest-536">Example 1: Denying and allowing all access</h3>
<p class="normal">For our first example, we will create<a id="_idIndexMarker1527"/> a policy that will deny all requests to the resources in the namespace <code class="inlineCode">testapp</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">AuthorizationPolicy</span>
<span class="hljs-attr">metadata:</span>
 <span class="hljs-attr">name:</span> <span class="hljs-string">testapp-policy-deny</span>
 <span class="hljs-attr">namespace:</span> <span class="hljs-string">testapp</span>
<span class="hljs-attr">spec:</span>
  {}
</code></pre>
<p class="normal">After deploying the policy, attempt to <code class="inlineCode">curl</code> to the <code class="inlineCode">nip.io</code> address again. You will notice that this time, you will be denied access and Istio will return an RBAC error:</p>
<pre class="programlisting con"><code class="hljs-con">RBAC: access denied
</code></pre>
<p class="normal">It can take a few seconds for Istio to enable new policies. If you did not receive the <code class="inlineCode">RBAC: access denied</code> error, wait a few seconds and try again.</p>
<p class="normal">This is a very simple policy that does not include a <code class="inlineCode">selector</code> and defines nothing in the <code class="inlineCode">spec</code> section. By omitting the <code class="inlineCode">selector</code> section, Istio will apply the policy to all workloads in the namespace, and by not including anything in the <code class="inlineCode">spec</code> section, Istio will deny all traffic. If we refer back to the policy flow diagram in <em class="italic">Figure 16.1</em>, this would flow down the bottom and evaluate as circle #3 – there is a <code class="inlineCode">selector</code> match, which is <em class="italic">all</em> workloads in the namespace, and there hasn’t been an ALLOW policy defined. This will lead to the request being denied.</p>
<p class="normal">We won’t deploy the next example; we are showing it to reinforce the example provided above. By adding a single entry to the policy, we can change it from denying all requests to allowing all requests.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">AuthorizationPolicy</span>
<span class="hljs-attr">metadata:</span>
 <span class="hljs-attr">name:</span> <span class="hljs-string">testapp-policy-deny</span>
 <span class="hljs-attr">namespace:</span> <span class="hljs-string">testapp</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> {}
</code></pre>
<p class="normal">When we add the <code class="inlineCode">rules</code> section to the policy definition, with a {}, we are creating a rule that means all traffic. Similar to the previous example, we have not added a <code class="inlineCode">selector</code>, which means the policy will apply to all deployments in the namespace. Since this rule is for all workloads and the rule includes all traffic, access would be allowed.</p>
<p class="normal">You might be starting to see why<a id="_idIndexMarker1528"/> we mentioned how not understanding how policies are evaluated in the flow may lead to unexpected access results. This is a prime example of how a single entry, <code class="inlineCode">rules</code>, changes the policy from denying all requests to allowing all requests.</p>
<p class="normal">Before moving on, delete the policy by executing:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl delete -f example1-policy.yaml -n testapp
</code></pre>
<h3 class="heading-3" id="_idParaDest-537">Example 2: Allowing only GET methods to a workload</h3>
<p class="normal">Policies can get very granular, allowing<a id="_idIndexMarker1529"/> only certain operations like GET from an HTTP request. This example will allow GET requests while denying all other request types for pods that are labeled with <code class="inlineCode">app=nginx-web</code> in the <code class="inlineCode">marketing</code> namespace. For this example, we will use the same NGINX deployment from the first example. Create the policy using the manifest in the <code class="inlineCode">chapter16/testapp</code> directory called <code class="inlineCode">exampe2-policy.yaml</code> using <code class="inlineCode">kubectl</code>:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl create -f example2-policy.yaml -n testapp
</code></pre>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">AuthorizationPolicy</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-get-allow</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">marketing</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-web</span>
  <span class="hljs-attr">action:</span> <span class="hljs-string">ALLOW</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">operation:</span>
         <span class="hljs-attr">methods:</span> [<span class="hljs-string">"GET"</span>]
</code></pre>
<p class="normal">If you attempt to <code class="inlineCode">curl</code> to the same <code class="inlineCode">nip.io</code> address as we used in example 1, you will see the NGINX welcome page. This is using an HTTP GET command. To prove that HTTP PUT commands will be blocked, we can use a <code class="inlineCode">curl</code> command to send a request to NGINX:</p>
<pre class="programlisting con"><code class="hljs-con">curl -X PUT -d argument=value -d value1=dummy-data  http://testapp.10.3.1.248.nip.io/
</code></pre>
<p class="normal">This will cause Istio to deny the request with an RBAC error:</p>
<pre class="programlisting con"><code class="hljs-con">RBAC: access denied
</code></pre>
<p class="normal">In the example, the policy accepts the GET request from any source, since we have only defined an action without a specific <code class="inlineCode">from</code> object. Since we have not added the PUT action in our policy, any attempt to send an HTTP PUT request will be denied by the policy.</p>
<p class="normal">Policies can get even more granular, accepting (or denying) a request based on the source of the request. In the next example, we will show another example of a policy but we will limit the source to a single IP address.</p>
<p class="normal">Before moving on, delete<a id="_idIndexMarker1530"/> the example policy using <code class="inlineCode">kubectl</code>:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl delete -f example2-policy.yaml -n testapp
</code></pre>
<h3 class="heading-3" id="_idParaDest-538">Example 3: Allowing requests from a specific source</h3>
<p class="normal">In our last policy example, we will limit<a id="_idIndexMarker1531"/> what source will be allowed access to a workload using a GET or POST method.</p>
<p class="normal">This will increase security by denying any request from a source that is not in the policy source list. We will not create this policy since many readers may be limited in the number of machines they have to use for testing.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">metadata:</span>
 <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-get-allow-source</span>
 <span class="hljs-attr">namespace:</span> <span class="hljs-string">marketing</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">action:</span> <span class="hljs-string">ALLOW</span>
  <span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">source:</span>
        <span class="hljs-attr">ipBlocks:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168.10.100</span>
</code></pre>
<p class="normal">Unlike the previous examples, this policy has a <code class="inlineCode">source:</code> section, which allows you to limit access based on different sources, like an IP address. This policy will allow the source IP <code class="inlineCode">192.168.10.100</code> access to all operations on the NGINX server, and all other sources will be denied access.</p>
<p class="normal">Moving on from authorization<a id="_idIndexMarker1532"/> policies, we will introduce our next custom resource, destination gateways.</p>
<h3 class="heading-3" id="_idParaDest-539">Gateways</h3>
<p class="normal">Earlier, we mentioned<a id="_idIndexMarker1533"/> that traffic will come<a id="_idIndexMarker1534"/> into a central point, <code class="inlineCode">istio-ingressgateway</code>. We didn’t explain how the traffic flows from the <code class="inlineCode">ingressgateway</code> to a namespace and workloads – this is where gateways come in.</p>
<p class="normal">A gateway can be configured at the namespace, so you can delegate the creation and configuration to a team. It is a load balancer that receives incoming and outgoing traffic that can be customized with options like accepted ciphers, TLS versions, certificate handling, and more.</p>
<p class="normal">Gateways work along with Virtual Services, which we will discuss in the next section, but until then, the following figure shows the interaction between the <code class="inlineCode">Gateway</code> and <code class="inlineCode">VirtualService</code> objects.</p>
<figure class="mediaobject"><img alt="" height="433" src="../Images/B21165_16_02.png" width="689"/></figure>
<p class="packt_figref">Figure 16.2: Gateway to Virtual Service communication flow</p>
<p class="normal">The list below explains<a id="_idIndexMarker1535"/> the communication<a id="_idIndexMarker1536"/> shown in <em class="italic">Figure 16.2</em> in more detail:</p>
<ol>
<li class="numberedList" value="1">An incoming request is sent to the Istio <code class="inlineCode">ingress-gateway</code> controller, located in the <code class="inlineCode">istio-system</code> namespace.</li>
<li class="numberedList">The <code class="inlineCode">sales</code> namespace has a gateway configured that is set to use the <code class="inlineCode">ingressgateway</code> with a host of <code class="inlineCode">entry.foowidgets.com</code>. This tells the <code class="inlineCode">ingressgateway</code> to send the request to the gateway object in the <code class="inlineCode">sales</code> namespace.</li>
<li class="numberedList">Finally, the traffic is routed to the service using a Virtual Service object that has been created using the gateway in the <code class="inlineCode">sales</code> namespace.</li>
</ol>
<p class="normal">To show an example <code class="inlineCode">Gateway</code> configuration, we have a namespace called <code class="inlineCode">sales</code> that has Istio enabled, running an application that can be accessed using the URL <code class="inlineCode">entry.foowidgets.com</code>, and we need to expose it for external access. To accomplish this, we would create a gateway using the example manifest below. (The example below is just for discussion; you do not need to deploy it on your KinD cluster.)</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">sales-gateway</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">sales</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span>
  <span class="hljs-attr">servers:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span>
      <span class="hljs-attr">number:</span> <span class="hljs-number">443</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span>
    <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">sales.foowidgets.com</span>
    <span class="hljs-attr">tls:</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">SIMPLE</span>
      <span class="hljs-attr">serverCertificate:</span> <span class="hljs-string">/etc/certs/servercert.pem</span>
      <span class="hljs-attr">privateKey:</span> <span class="hljs-string">/etc/certs/privatekey.pem</span>
</code></pre>
<p class="normal">This gateway configuration<a id="_idIndexMarker1537"/> will tell the ingress gateway to listen on port <code class="inlineCode">443</code> for requests that<a id="_idIndexMarker1538"/> are incoming for <code class="inlineCode">sales.foowidgets.com</code>. It also defines the certificates that will be used to secure the communication for incoming web requests.</p>
<p class="normal">You may be wondering, “How does it know to use the ingress gateway that we have running in our cluster?” If you look at the <code class="inlineCode">spec</code> section, and then the selector, we have configured the <code class="inlineCode">selector</code> to use an ingress gateway that has the label <code class="inlineCode">istio=ingressgateway</code>. This <code class="inlineCode">selector</code> and label tell the gateway object which ingress gateway will create our new gateway for incoming connections. When we deployed Istio earlier, the ingress gateways were labeled with the default label <code class="inlineCode">istio=ingressgateway</code>, as shown highlighted below, from a <code class="inlineCode">kubectl get pods --show-labels -n istio-system</code>.</p>
<pre class="programlisting con"><code class="hljs-con">app=istio-ingressgateway,chart=gateways,heritage=Tiller,install.operator.istio.io/owning-resource=unknown,istio.io/rev=default,istio=ingressgateway,operator.istio.io/component=IngressGateways,pod-template-hash=78c9969f6b,release=istio,service.istio.io/canonical-name=istio-ingressgateway,service.istio.io/canonical-revision=latest,sidecar.istio.io/inject=false
</code></pre>
<p class="normal">You may be wondering how the gateway will be used to direct traffic to a particular workload since there are no configuration options in the gateway telling it where to direct traffic. That’s because the gateway just configures the ingress gateways to accept traffic for a destination URL and the required ports – it does not control how the traffic will flow<a id="_idIndexMarker1539"/> to a service; that’s the job<a id="_idIndexMarker1540"/> of the next object, the <code class="inlineCode">Virtual Service</code> object.</p>
<h3 class="heading-3" id="_idParaDest-540">Virtual services</h3>
<p class="normal">Gateways and virtual services<a id="_idIndexMarker1541"/> combine to provide the correct<a id="_idIndexMarker1542"/> traffic route to a service, or services. Once you have a gateway deployed, you need to create a virtual service object to tell the gateway how to route traffic to your service(s).</p>
<p class="normal">Building on the gateway example, we need to tell the gateway how to route traffic to our web server running on port <code class="inlineCode">443</code>. The server has been deployed using NGINX in the <code class="inlineCode">marketing</code> namespace and it has a label of <code class="inlineCode">app-nginx</code> and a service named <code class="inlineCode">frontend</code>. To route traffic to the NGINX service, we would deploy the manifest below. (The example below is just for discussion; you do not need to deploy it on your KinD cluster.)</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">sales-entry-web-vs</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">sales</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">hosts:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">entry.foowidgets.com</span>
  <span class="hljs-attr">gateways:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">sales-gateway</span>
  <span class="hljs-attr">http:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">route:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span>
        <span class="hljs-attr">port:</span>
          <span class="hljs-attr">number:</span> <span class="hljs-number">443</span>
        <span class="hljs-attr">host:</span> <span class="hljs-string">entry</span>
</code></pre>
<p class="normal">Breaking down the manifest, we specify the host(s) that this <code class="inlineCode">VirtualService</code> object will route; in our example, we only have one host, <code class="inlineCode">entry.foowidgets.com</code>. The next field defines which gateway will be used for the traffic; in the previous section, we defined a gateway called <code class="inlineCode">marketing-gateway</code>, which was configured to listen on port <code class="inlineCode">443</code>.</p>
<p class="normal">Finally, the last section defines which service the traffic will be routed to. The route, destination, and port are all fairly straightforward to understand, but the <code class="inlineCode">host</code> section can be misleading. This field actually defines the service that you will route the traffic to. In the example, we are going to route the traffic to a service called <code class="inlineCode">entry</code>, so our field is defined with <code class="inlineCode">host: entry</code>.</p>
<p class="normal">With this knowledge of using gateways and virtual services to route traffic in the Service mesh, we can move on to the next topic, destination rules.</p>
<h2 class="heading-2" id="_idParaDest-541">Destination rules</h2>
<p class="normal">Virtual services provide a basic<a id="_idIndexMarker1543"/> method to direct traffic<a id="_idIndexMarker1544"/> to a service, but Istio offers an additional object to create complex traffic direction by using <code class="inlineCode">Destination</code> rules. <code class="inlineCode">Destination</code> rules are applied after Virtual Services. Traffic is initially routed using a Virtual Service and, if defined, a <code class="inlineCode">Destination</code> rule can be used to route the request to its final destination.</p>
<p class="normal">This may be confusing at first, but it becomes easier when you see an example, so let’s dive into an example that can route traffic to different versions of a deployment.</p>
<p class="normal">As we learned, incoming requests will use the Virtual Service initially, and then a destination rule, if defined, will route the request to the destination. In this example, we have already created a Virtual Service but we actually have two versions of the application labeled <code class="inlineCode">v1</code> and <code class="inlineCode">v2</code> and we want to direct traffic between both versions of the application using round-robin. To accomplish this, we would create a <code class="inlineCode">DestinationRule</code> using the manifest below. (The example below is just for discussion; you do not need to deploy it on your KinD cluster.)</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">host:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">trafficPolicy:</span>
    <span class="hljs-attr">loadBalancer:</span>
      <span class="hljs-attr">simple:</span> <span class="hljs-string">ROUND_ROBIN</span>
  <span class="hljs-attr">subsets:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span>
    <span class="hljs-attr">labels:</span>
      <span class="hljs-attr">version:</span> <span class="hljs-string">nginx-v1</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span>
    <span class="hljs-attr">labels:</span>
      <span class="hljs-attr">version:</span> <span class="hljs-string">nginx-v2</span>
</code></pre>
<p class="normal">Using this example, incoming requests to the NGINX server will be split between the two versions of the application equally since we defined the <code class="inlineCode">loadBalancer</code> policy as <code class="inlineCode">ROUND_ROBIN</code>. But what if we wanted to route traffic to the version that had the least number of connections? Destination rules have other options for <code class="inlineCode">loadBalancer</code>, and to route connections<a id="_idIndexMarker1545"/> to the version with the least connections, we would set the <code class="inlineCode">LEAST_CONN</code> <code class="inlineCode">loadBalancer</code> policy.</p>
<p class="normal">Next, we will discuss some of the security features Istio provides, starting with an object called Peer Authentication.</p>
<h3 class="heading-3" id="_idParaDest-542">Peer authentication</h3>
<p class="normal">Istio’s peer authentication<a id="_idIndexMarker1546"/> object controls how the Service mesh controls the mutual TLS settings for workloads, either for the entire Service mesh or just a namespace. Each policy can be configured with a value that will either allow both encrypted communication and non-encrypted communication between pods or require encryption between pods.</p>
<table class="table-container" id="table003-7">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">mTLS mode</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Pod communication</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">STRICT</code></p>
</td>
<td class="table-cell">
<p class="normal">mTLS required</p>
</td>
<td class="table-cell">
<p class="normal">Any non-encrypted traffic sent to a pod will be denied</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">PERMISSIVE</code></p>
</td>
<td class="table-cell">
<p class="normal">mTLS optional</p>
</td>
<td class="table-cell">
<p class="normal">Both encrypted and non-encrypted traffic will be accepted by the pod</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 16.3: PeerAuthentication options</p>
<p class="normal">If you wanted to set <code class="inlineCode">PeerAuthentication</code> for the entire mesh, you would create a <code class="inlineCode">PeerAuthentication</code> in the <code class="inlineCode">istio-system</code> namespace. For example, to require mTLS between all pods, you would create the policy shown below:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PeerAuthentication</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mtls-policy</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-system</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">mtls:</span>
    <span class="hljs-attr">mode:</span> <span class="hljs-string">STRICT</span>
</code></pre>
<p class="normal">To allow both encrypted and non-encrypted traffic, the policy mode just needs to be set to <code class="inlineCode">PERMISSIVE</code>, by changing the mode to <code class="inlineCode">mode: PERMISSIVE</code>.</p>
<p class="normal">Rather than setting the mode for the entire mesh, many enterprises only set the mode to <code class="inlineCode">STRICT</code> for namespaces that require additional security. In the example below, we set the mode to <code class="inlineCode">STRICT</code> for the <code class="inlineCode">sales</code> namespace.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PeerAuthentication</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">mtls-policy</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">sales</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">mtls:</span>
    <span class="hljs-attr">mode:</span> <span class="hljs-string">STRICT</span>
</code></pre>
<p class="normal">Since this policy is configured for the <code class="inlineCode">sales</code> namespace, rather than the <code class="inlineCode">istio-system</code> namespace, Istio will only enforce a strict mTLS policy for the namespace rather than the entire Service mesh.</p>
<p class="normal">This is a great security feature<a id="_idIndexMarker1547"/> provided by the mesh, but encryption won’t stop a request from hitting our workload; it simply encrypts it. The next object we will discuss will add a level of security to a workload by requiring authentication before being allowed access.</p>
<h3 class="heading-3" id="_idParaDest-543">Request authentication and authorization policies</h3>
<p class="normal">Security requires<a id="_idIndexMarker1548"/> two pieces. First, the authentication<a id="_idIndexMarker1549"/> piece, which is “who you are.” The second piece is authorization, which is the actions that are allowed once authentication has been provided, or “what you can do.”</p>
<p class="normal"><code class="inlineCode">RequestAuthentication</code> objects are only one part required to secure a workload. To fully secure the workload, you need to create the <code class="inlineCode">RequestAuthentication</code> object and an <code class="inlineCode">AuthorizationPolicy</code>. The <code class="inlineCode">RequestAuthentication</code> policy will determine what identities are allowed access to the workload, and the <code class="inlineCode">AuthorizationPolicy</code> will determine what permissions are allowed.</p>
<p class="normal">A <code class="inlineCode">RequestAuthorization</code> policy without an <code class="inlineCode">AuthorizationPolicy</code> can lead to unintentionally allowing access to the resource. If you only create a <code class="inlineCode">RequestAuthorization</code> policy, the access in <em class="italic">Table 16.4</em> shows who would be allowed access.</p>
<table class="table-container" id="table004-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Token action</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Access provided</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Invalid token provided</p>
</td>
<td class="table-cell">
<p class="normal">Access will be denied</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">No token provided</p>
</td>
<td class="table-cell">
<p class="normal">Access will be granted</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Valid token provided</p>
</td>
<td class="table-cell">
<p class="normal">Access will be granted</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 16.4: RequestAuthentication access</p>
<p class="normal">As you can see, once we create a policy, any invalid JWT will be denied access to the workload, and any valid token will be allowed access to the workload. However, when no token is provided, many people think that access would be denied, but in reality, access would be allowed. A <code class="inlineCode">RequestAuthentication</code> policy only verifies the tokens, and if no token is present, the <code class="inlineCode">RequestAuthentication</code> rule will not deny the request.</p>
<p class="normal">An example manifest<a id="_idIndexMarker1550"/> is shown below. We will use this manifest in the examples section of the chapter, but we wanted to show it in this section to explain the fields.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">security.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RequestAuthentication</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">demo-requestauth</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">demo</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">frontend</span>
  <span class="hljs-attr">jwtRules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">issuer:</span> <span class="hljs-string">testing@secure.istio.io</span>
    <span class="hljs-attr">jwksUri:</span> <span class="hljs-string">https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json</span>
</code></pre>
<p class="normal">This manifest will create a policy<a id="_idIndexMarker1551"/> that configures a workload with the label <code class="inlineCode">matching app=frontend</code> in the <code class="inlineCode">demo</code> namespace to accept JWTs from the issuer <code class="inlineCode">testing@secure.istio.io</code> with a URL to confirm the tokens at <a href="https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json"><span class="url">https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json</span></a>.</p>
<p class="normal">This URL contains the key used to validate the tokens:</p>
<pre class="programlisting con"><code class="hljs-con">{ "keys":[ {"e":"AQAB","kid":"DHFbpoIUqrY8t2zpA2qXfCmr5VO5ZEr4RzHU_-envvQ","kty":"RSA","n":"xAE7eB6qugXyCAG3yhh7pkDkT65pHymX-P7KfIupjf59vsdo91bSP9C8H07pSAGQO1MV_xFj9VswgsCg4R6otmg5PV2He95lZdHtOcU5DXIg_pbhLdKXbi66GlVeK6ABZOUW3WYtnNHD-91gVuoeJT_DwtGGcp4ignkgXfkiEm4sw-4sfb4qdt5oLbyVpmW6x9cfa7vs2WTfURiCrBoUqgBo_-4WTiULmmHSGZHOjzwa8WtrtOQGsAFjIbno85jp6MnGGGZPYZbDAa_b3y5u-YpW7ypZrvD8BgtKVjgtQgZhLAGezMt0ua3DRrWnKqTZ0BJ_EyxOGuHJrLsn00fnMQ"}]}
</code></pre>
<p class="normal">When a token is presented, it will be verified that it came from the issuer defined in the <code class="inlineCode">jwtRules</code> section of the <code class="inlineCode">RequestAuthenctication</code> object.</p>
<p class="normal">We’ll walk through an example of how token authentication works in depth in the next chapter.</p>
<h3 class="heading-3" id="_idParaDest-544">Service entries</h3>
<p class="normal">Once a workload is part<a id="_idIndexMarker1552"/> of a Service mesh, its sidecar proxy will handle all outbound communication to services within the mesh. If the workload attempts to communicate with an external service that is not part of the mesh, this communication may fail if not properly configured. Fortunately, Istio provides mechanisms to define and manage external services, allowing workloads to communicate with services outside the mesh. One such mechanism is the <code class="inlineCode">ServiceEntry</code> object, which allows you to define services that are external to the mesh and configure how these services should be accessed.</p>
<p class="normal">If you have a requirement for a workload in your Service mesh to communicate with a service outside of the Service mesh, you need to create an entry in the mesh for the external resource. This can be done in two ways, and the first method leads us to our next custom resource, the <code class="inlineCode">ServiceEntry</code> object, which allows you to add external entries to the Service mesh. When you create a <code class="inlineCode">ServiceEntry</code> for an external service, it will appear as if it was part of the actual Service mesh. This allows traffic to be routed to manually specified services from inside the Service mesh. Without a <code class="inlineCode">ServiceEntry</code>, any attempt to communicate with the external resource would fail since Istio would attempt to look up the service in the Service mesh entries and it would fail to find the resource (since it is not part of the mesh).</p>
<p class="normal">To create a <code class="inlineCode">ServiceEntry</code>, you need to create a new object that contains the hosts and ports for the external service. The example below will create a new entry that adds the host <code class="inlineCode">api.foowidgets.com</code> on port <code class="inlineCode">80</code>, using HTTP, to the Service mesh.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceEntry</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">api-server</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">sales</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">hosts:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">api.foowidgets.com</span>
  <span class="hljs-attr">ports:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>
    <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span>
</code></pre>
<p class="normal">ServiceEntries are a great resource to explicitly add external resources to a Service mesh. We mentioned that there are two ways to add external resources to the Service mesh, Service entries being one – and the other being the <code class="inlineCode">Sidecars</code> object. The choice of which object to use is very specific to your own use-cases and organizational standards. Service entries are very specific and you must create an entry for each external resource you need to communicate with. Sidecars are different, and instead of defining<a id="_idIndexMarker1553"/> what is external to the Service mesh, you define what is in the Service mesh.</p>
<h3 class="heading-3" id="_idParaDest-545">Sidecars</h3>
<p class="normal">First, we know this<a id="_idIndexMarker1554"/> can be confusing – this object is not the sidecar itself; it is an object that allows you to define what items your sidecar considers to be “in the mesh.” Depending on the size of your cluster, you may have thousands of services in the mesh and if you do not create a sidecar object, your Envoy sidecar will assume that your service needs to communicate with every other service.</p>
<p class="normal">Typically, you may only need your namespace to communicate with services in the same namespace or a small number of other namespaces. Since tracking every service in the mesh requires resources, it’s considered good practice to create a sidecar object to reduce the required memory in each Envoy sidecar.</p>
<p class="normal">To create a sidecar object that limits the services in your Envoy proxy, you would deploy the manifest shown below:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Sidecar</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">sales-sidecar</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">sales</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">egress:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">"./*"</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">"istio-system/*"</span>
</code></pre>
<p class="normal">The <code class="inlineCode">spec</code> in this manifest contains a list of hosts for the mesh, the <code class="inlineCode">./*</code> references the namespace where the object was created, and all sidecars should contain the namespace where Istio was deployed, which would be <code class="inlineCode">istio-system</code>, by default.</p>
<p class="normal">If we had three namespaces that needed to communicate across the mesh, we would simply need to add the additional namespaces to the hosts’ entries:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1beta1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Sidecar</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">sales-sidecar</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">sales</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">egress:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">./*</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">istio-system/*</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">sales2</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">sales3</span>
</code></pre>
<p class="normal">Failing to limit the mesh objects may result in your Envoy sidecar crashloops due to resources. You may<a id="_idIndexMarker1555"/> experience an <strong class="keyWord">out of memory</strong> (<strong class="keyWord">OOM</strong>) event, or simply crashloops that do not show any details of the root cause. If you experience these scenarios, deploying a sidecar<a id="_idIndexMarker1556"/> object may resolve the issue.</p>
<h3 class="heading-3" id="_idParaDest-546">Envoy filters</h3>
<p class="normal">Envoy filters provide you with the ability<a id="_idIndexMarker1557"/> to create custom configurations that are generated by Istio. Remember that Pilot (part of istiod) is responsible for sidecar management. When any configuration is sent to Istio, Pilot will convert the configuration for Envoy to utilize. Since you are “limited” by the options in the Istio custom resource, you may not have all of the potential configuration options that are required for a workload, and that’s where Envoy filters come in.</p>
<p class="normal">Filters are very powerful, and potentially dangerous, configuration objects. They allow you to customize values that you cannot customize from a standard Istio object, allowing you to add filters, listeners, fields, and more. This brings a quote used in Spider-Man from the late Stan Lee to mind, “With great power comes great responsibility.” Envoy filters provide you with extended configuration options, but if a filter is misused, it could bring down the entire Service mesh.</p>
<p class="normal">Envoy filters are complex and, for the purposes of this book, are not a topic that needs deep understanding to understand Istio in general. You can read more about Envoy filters<a id="_idIndexMarker1558"/> on the Istio site at <a href="https://istio.io/latest/docs/reference/config/networking/envoy-filter/"><span class="url">https://istio.io/latest/docs/reference/config/networking/envoy-filter/</span></a>.</p>
<h3 class="heading-3" id="_idParaDest-547">WASM plugins</h3>
<p class="normal">Similar to Envoy filters, the <code class="inlineCode">WasmPlugins</code> object<a id="_idIndexMarker1559"/> is used to extend the capabilities of the Envoy sidecar. While they are similar in what they provide, they each provide different degrees of customization.</p>
<p class="normal">Typically, <code class="inlineCode">WasmPlugins</code> are regarded as more straightforward to develop and implement, making them less complex and dangerous compared to Envoy filters. This simplicity, however, comes at the cost of reduced functionality relative to what Envoy filters can offer.</p>
<p class="normal">Envoy filters provide detailed, fine-grained control over the proxy settings, enabling the creation of more sophisticated operations than is possible with <code class="inlineCode">WasmPlugins</code>. This level of control contributes to their complexity and the potential risk they pose if improperly configured or used, which could lead to disruptions within your Service mesh.</p>
<p class="normal">The choice between <code class="inlineCode">EnvoyFilters</code> and <code class="inlineCode">WasmPlugins</code> ultimately depends on your specific needs<a id="_idIndexMarker1560"/> and preferences. It’s important to consider various factors when deciding which option to adopt, weighing the trade-offs between ease of use, functionality, and the potential impact on your Service mesh.</p>
<h1 class="heading-1" id="_idParaDest-548">Deploying add-on components to provide observability</h1>
<p class="normal">By now, you know how to deploy Istio and understand some of the most used objects, but you haven’t seen one of the most useful features yet – observability. At the beginning of the chapter, we mentioned that observability is one of our favorite features provided by Istio, and in this chapter, we will explain how to deploy a popular<a id="_idIndexMarker1561"/> Istio add-on called Kiali.</p>
<h2 class="heading-2" id="_idParaDest-549">Installing Istio add-ons</h2>
<p class="normal">When you deploy Istio, you provide<a id="_idIndexMarker1562"/> a Service mesh and all of the features to your developers. While this is powerful by itself, you need to add a few extra components to truly provide a complete solution. There are four add-ons that you should add to your Service mesh – while there are alternatives to some of the solutions, we are using the most commonly used add-ons, specifically:</p>
<ul>
<li class="bulletList">Prometheus</li>
<li class="bulletList">Grafana</li>
<li class="bulletList">Jaeger</li>
<li class="bulletList">Kiali (which we will cover in the next section)</li>
</ul>
<p class="normal">We have discussed Prometheus and Grafana in previous chapters, but Jaeger is a new component that we have not mentioned before.</p>
<p class="normal">Jaeger is an open-source offering that provides tracing between services in Istio. Tracing may be a new term to some readers. At a high level, traces are a representation of the execution path to a service. These allow us to view the actual path of the communication between services, providing an easy-to-understand view that provides metrics about performance and latency, allowing you to resolve issues quickly.</p>
<p class="normal">To deploy all of the add-ons, we have included a script to deploy Prometheus in the <code class="inlineCode">chapter16/add-ons</code> directory, called <code class="inlineCode">deploy-add-ons.sh</code>. Execute the script to deploy the add-ons in your cluster.</p>
<p class="normal">Many add-on example deployments do not maintain state, so for our deployment we have added persistency, leveraging the provisioner built into KinD, by adding persistent disks to each deployment.</p>
<p class="normal">The script executes the steps outlined below:</p>
<ol>
<li class="numberedList" value="1">Deploys each add-on using standard Kubernetes manifests in the <code class="inlineCode">istio-system</code> namespace.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Each deployment creates a PVC and mounts it as the data location to maintain persistency across reboots.</li>
</ol>
</li>
<li class="numberedList">Finds your host’s IP address to create new Gateway and VirtualService entries for each add-on.</li>
<li class="numberedList">Creates a shared Istio Gateway that will be used by each of the add-ons.</li>
<li class="numberedList">Creates VirtualServices that contain your <code class="inlineCode">nip.io</code> URLs. The three URLs that will be created are:<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1"><code class="inlineCode">prom.&lt;Host IP&gt;.nip.io</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">grafana.&lt;Host IP&gt;.nip.io</code></li>
<li class="alphabeticList level-2"><code class="inlineCode">kiali.&lt;Host IP&gt;.nip</code>.<code class="inlineCode">io</code></li>
</ol>
</li>
</ol>
<p class="normal">The final output from the script will contain the URLs that were created for you.</p>
<p class="normal">With the add-ons deployed, we can move <a id="_idIndexMarker1563"/>on to the next section, which will cover the main tool for observability, Kiali.</p>
<h2 class="heading-2" id="_idParaDest-550">Installing Kiali</h2>
<p class="normal">Kiali provides a powerful management console<a id="_idIndexMarker1564"/> for our Service mesh. It provides graphical views of our services, pods, traffic security, and more. Since it’s a very useful tool for both developers and operators, the remainder of this chapter will focus on deploying and using Kiali.</p>
<p class="normal">There are a few options to deploy Kiali, but we will use the most common installation method, using a Helm chart. To deploy the chart and create the required objects to access the Kiali UI, we have provided a script in the <code class="inlineCode">chapter16/kiali</code> directory called <code class="inlineCode">deploy-kiali.sh</code>. Execute the script to deploy Kiali.</p>
<p class="normal">The script will deploy Kiali into your cluster, in the <code class="inlineCode">istio-system</code> namespace, pre-configured to integrate with the add-ons we deployed in the previous section. It will also expose Kiali’s UI using a <code class="inlineCode">nip.io</code> URL, which will be provided at the end of the script execution.</p>
<p class="normal">This deploys an anonymous access<a id="_idIndexMarker1565"/> dashboard; however, Kiali can accept other authentication mechanisms to secure the dashboard. In the next chapter, we will modify the Kiali deployment to accept JWTs, using OpenUnison as the provider.</p>
<h1 class="heading-1" id="_idParaDest-551">Deploying an application into the Service mesh</h1>
<p class="normal">We could define the components and objects of Istio all day, but if you are like us, you will find examples and use-cases more beneficial to understanding advanced concepts like the features provided by Istio. In this section, we will explain many of the custom resources in detail, providing examples that you can deploy in your KinD cluster.</p>
<h2 class="heading-2" id="_idParaDest-552">Deploying your first application into the mesh</h2>
<p class="normal">Finally! We have Istio<a id="_idIndexMarker1566"/> and the add-on components installed<a id="_idIndexMarker1567"/> and we can move on to installing a real application in the Service mesh to verify everything is working.</p>
<p class="normal">For this section, we will deploy an example<a id="_idIndexMarker1568"/> application from Google called the Boutique app. In the next chapter, we will deploy a different application and explain all of the details and communication between the services, but the Boutique app is a great application to test out the mesh before we get into that level of information.</p>
<p class="normal">In the <code class="inlineCode">chaper16/example-app</code> directory, there is an installation script called <code class="inlineCode">deploy-example.sh</code> that will deploy the application to the cluster. It will install the base application and the required Istio objects to make the application accessible to the outside world. The script execution is detailed below:</p>
<ol>
<li class="numberedList" value="1">A new namespace named <code class="inlineCode">demo</code> is created with a label containing <code class="inlineCode">istio-injection=enabled</code>.</li>
<li class="numberedList">Using the <code class="inlineCode">kubernetes-objects.yaml</code> manifest, the base application will be deployed.</li>
<li class="numberedList">The Istio objects will be created using templates to create the names in the <code class="inlineCode">nip.io</code> domain for easy access to the application. The objects created in Istio include the <code class="inlineCode">Gateway</code> and <code class="inlineCode">VirtualService</code> objects.</li>
<li class="numberedList">The created <code class="inlineCode">nip.io</code> domain will be output to the screen. On our server, it was <code class="inlineCode">kiali.10.3.1.248.nip.io</code>.</li>
</ol>
<p class="normal">Once executed, you will have a working demo application in the <code class="inlineCode">demo</code> namespace. We will use this application to demonstrate the observability features of Istio and Kiali.</p>
<p class="normal">Quickly verify that the application<a id="_idIndexMarker1569"/> and Istio objects have been deployed<a id="_idIndexMarker1570"/> correctly by the script by using a browser to open the <code class="inlineCode">nip.io</code> URL. You should see the Kiali home screen, which we will discuss in the next section.</p>
<h2 class="heading-2" id="_idParaDest-553">Using Kiali to observe mesh workloads</h2>
<p class="normal">Kiali provides observability<a id="_idIndexMarker1571"/> in your Service mesh. It provides<a id="_idIndexMarker1572"/> a number of advantages to you and your developers, including a visual map of the traffic flow between objects, verifying mTLS between the services, logs, and detailed metrics.</p>
<h3 class="heading-3" id="_idParaDest-554">The Kiali overview screen</h3>
<p class="normal">If you navigate to the homepage<a id="_idIndexMarker1573"/> of Kiali, by using the URL provided when you executed the <code class="inlineCode">create-ingress</code> script, this will open the Kiali overview page where you will see a list of namespaces in the cluster.</p>
<figure class="mediaobject"><img alt="" height="482" src="../Images/B21165_16_03.png" width="878"/></figure>
<p class="packt_figref">Figure 16.3: The Kiali homepage</p>
<p class="normal">Kiali will show all namespaces<a id="_idIndexMarker1574"/> in the cluster, even if they do not have Istio enabled. In our current deployment, it will show all namespaces, regardless of any RBAC that has been implemented since it’s running without any authentication. As mentioned in the <em class="italic">Installing Kiali</em> section, we will secure Kiali with JWTs in the next chapter.</p>
<h3 class="heading-3" id="_idParaDest-555">Using the Graph view</h3>
<p class="normal">The first part of the dashboard<a id="_idIndexMarker1575"/> that we will visit is the <strong class="screenText">Graph</strong> view, which provides a graphical view of our application. Initially, it may look like a simple static graphical representation of the objects that make up the workload, but this is simply the default view when you open the <strong class="screenText">Graph</strong> view; it isn’t limited to a simple static view, as you will see in this section.</p>
<p class="normal">Since we deployed the example application into the <code class="inlineCode">demo</code> namespace, scroll down a bit and look for the block that contains the <code class="inlineCode">demo</code> namespace, click the three dots on the tile, and then select <strong class="screenText">Graph</strong>:</p>
<figure class="mediaobject"><img alt="" height="461" src="../Images/B21165_16_04.png" width="587"/></figure>
<p class="packt_figref">Figure 16.4: Using Kiali to show a graph of a namespace</p>
<p class="normal">This will take you to a new dashboard<a id="_idIndexMarker1576"/> view that shows the demo application objects:</p>
<figure class="mediaobject"><img alt="" height="461" src="../Images/B21165_16_05.png" width="877"/></figure>
<p class="packt_figref">Figure 16.5: Kiali graph example</p>
<p class="normal">There are a lot of objects<a id="_idIndexMarker1577"/> on the graph, and if you are new to Kiali, you may be wondering what each of the icons represents. Kiali provides a legend to help you identify what role each icon plays.</p>
<p class="normal">If you click on the icon in the lower left-hand section of the <strong class="screenText">graph</strong> pane, you will see the legend icon. Click it to see an explanation of each icon – an abbreviated legend list is shown below:</p>
<figure class="mediaobject"><img alt="" height="549" src="../Images/B21165_16_06.png" width="307"/></figure>
<p class="packt_figref">Figure 16.6: Kiali graph legend example</p>
<p class="normal">By default, this view only shows the paths<a id="_idIndexMarker1578"/> between the application objects in a static view. However, you are not limited only to the static view – this is where Kiali starts to shine. We can actually enable a live traffic view, enabling us to watch the traffic flow for all requests.</p>
<p class="normal">To enable this option, click the <strong class="screenText">Display</strong> option that is just above the Graph view, and in the list of options, enable traffic animation by checking the box, as shown in <em class="italic">Figure 16.7</em>.</p>
<figure class="mediaobject"><img alt="" height="511" src="../Images/B21165_16_07.png" width="877"/></figure>
<p class="packt_figref">Figure 16.7: Enabling traffic animation</p>
<p class="normal">It’s difficult to display in a static image, but once you have enabled the <strong class="screenText">Traffic Animation</strong> option, you will see the flow of all requests in real time.</p>
<p class="normal">You are not limited<a id="_idIndexMarker1579"/> to only traffic flow animations; you can use the <strong class="screenText">Display</strong> option to enable a number of other options in the <strong class="screenText">Graph</strong> view, including items like response time, throughput, traffic rate, and security.</p>
<p class="normal">In <em class="italic">Figure 16.8</em>, we have enabled throughput, traffic distribution, traffic rate, and security:</p>
<figure class="mediaobject"><img alt="" height="360" src="../Images/B21165_16_08.png" width="878"/></figure>
<p class="packt_figref">Figure 16.8: Kiali graph display options</p>
<p class="normal">As you can see in the image, the lines between objects now include additional information, including:</p>
<ul>
<li class="bulletList">A lock, which confirms that the communication is encrypted via the sidecar and mTLS</li>
<li class="bulletList">RPS, which is the requests per second</li>
</ul>
<p class="normal">As you can see, the Kiali <strong class="screenText">Graph</strong> view is a powerful tool for observing the end-to-end communication for your workload. This is just one of the additional benefits of using a Service mesh. The observability that a mesh provides is an incredibly valuable tool for finding issues that would have been very difficult to uncover in the past.</p>
<p class="normal">We are not limited<a id="_idIndexMarker1580"/> to only the <strong class="screenText">Graph</strong> view; we also have three additional views that offer additional insight into the application. On the left-hand side of the Kiali dashboard, you will see the other three views, <strong class="screenText">Applications</strong>, <strong class="screenText">Workloads</strong>, and <strong class="screenText">Services</strong>. You will also notice that there is one other option, <strong class="screenText">Istio Config</strong>, which allows you to view the objects in the namespace that control the Istio features for the namespace.</p>
<h3 class="heading-3" id="_idParaDest-556">Using the Applications view</h3>
<p class="normal">The Applications view<a id="_idIndexMarker1581"/> shows you the details for the workloads that have the same labeling, allowing you to break down the view into smaller sections.</p>
<p class="normal">Using the Boutique Applications view that we have opened in Kiali, click on the <strong class="screenText">Applications</strong> link in the left-hand options. This will take you to the overview page for the applications, broken down by labels.</p>
<figure class="mediaobject"><img alt="" height="351" src="../Images/B21165_16_09.png" width="883"/></figure>
<p class="packt_figref">Figure 16.9: Kiali Applications view</p>
<p class="normal">Each of the applications can provide additional information by clicking the name of the service. If we were to click the <strong class="screenText">adservice</strong> application, Kiali would open a page providing an overview of what the <strong class="screenText">adservice</strong> application interacts with. For each application, you can also look at the overview, traffic, inbound and outbound metrics, and traces.</p>
<p class="normal">The overview page presents<a id="_idIndexMarker1582"/> you with a dedicated view of the objects that communicate with <strong class="screenText">adservice</strong>. We saw a similar communications view in the <strong class="screenText">Graph</strong> view, but we also saw every other object – including objects that have nothing to do with <strong class="screenText">adservice</strong>.</p>
<p class="normal">The Applications view will streamline what we can see, making it easier to navigate the application.</p>
<figure class="mediaobject"><img alt="" height="164" src="../Images/B21165_16_10.png" width="612"/></figure>
<p class="packt_figref">Figure 16.10: Simplified communication view using the Applications view</p>
<p class="normal">As you can see, the Applications view contains the components from the Graph view. The communications path that involves <strong class="screenText">adservice</strong> starts with the frontend pod, which targets the <strong class="screenText">adservice</strong> service, which ultimately routes the traffic to the <strong class="screenText">adservice</strong> pod.</p>
<p class="normal">We can see additional details in the application<a id="_idIndexMarker1583"/> by clicking on one of the tabs at the top of the <strong class="screenText">Applications</strong> view. The first tab next to the overview is the <strong class="screenText">Traffic</strong> tab, which provides you with a view of the traffic for the application.</p>
<figure class="mediaobject"><img alt="" height="202" src="../Images/B21165_16_11.png" width="878"/></figure>
<p class="packt_figref">Figure 16.11: Viewing application traffic</p>
<p class="normal">The <strong class="screenText">Traffic</strong> tab will show inbound and outbound traffic to the application. In the <strong class="screenText">adservice</strong> example from the Boutique store, we can see that <strong class="screenText">adservice</strong> has received inbound requests from the frontend. Below the inbound traffic, we can see the outbound traffic and, in our example, Kiali is telling us that there is no outbound traffic. As we can see in the overview in <em class="italic">Figure 16.10</em>, the <strong class="screenText">adservice</strong> pod does not have any object that it connects to; therefore, we would not have any traffic to view. To get additional details on the traffic, you can click on the <strong class="screenText">View Metrics</strong> link under <strong class="screenText">Actions</strong> – this action is the same as if you were to click the <strong class="screenText">Inbound Metrics</strong> tab.</p>
<p class="normal">The <strong class="screenText">Inbound Metrics</strong> tab will provide you with additional details about the incoming traffic. <em class="italic">Figure 16.12</em> shows an abbreviated example for the <strong class="screenText">adservice</strong> traffic.</p>
<figure class="mediaobject"><img alt="" height="336" src="../Images/B21165_16_12.png" width="877"/></figure>
<p class="packt_figref">Figure 16.12: Viewing inbound metrics</p>
<p class="normal">The inbound metrics will display a number of different metrics, including request volume, request duration, request and response size, request and response throughput, gRPC received and sent, TCP opened and closed, and TCP received and sent. This page will update in real time, allowing you to view the metrics as they are captured.</p>
<p class="normal">Finally, the last tab<a id="_idIndexMarker1584"/> will allow you to look at the traces for the <strong class="screenText">adservice</strong> application. This is why we deployed Jaeger in our cluster when we installed Istio. Tracing is a fairly complex topic and is outside the scope of this chapter. To learn more about<a id="_idIndexMarker1585"/> tracing using Jaeger, head over to the Jaeger site at <a href="https://www.jaegertracing.io/"><span class="url">https://www.jaegertracing.io/</span></a>.</p>
<h3 class="heading-3" id="_idParaDest-557">Using the Workloads view</h3>
<p class="normal">The next view we will discuss<a id="_idIndexMarker1586"/> is the <strong class="screenText">Workloads</strong> view, which breaks down the views to the workload type, like deployments. If you click on the <strong class="screenText">Workloads</strong> link in Kiali, you will be taken to a breakdown of the Boutique workloads.</p>
<figure class="mediaobject"><img alt="" height="230" src="../Images/B21165_16_13.png" width="878"/></figure>
<p class="packt_figref">Figure 16.13: The Workloads view</p>
<p class="normal">You may notice that there is a warning under the <strong class="screenText">Details</strong> column that tells us we are missing a version of the deployments. This is one of the features of this view. It will offer details like a workload not being assigned a version, which is not an issue for standard functionality in the mesh, but it will limit the use of certain features, like routing and some telemetry. It’s a best practice to always version your application, but for the example, Boutique from Google, they do not include a version in the deployments.</p>
<p class="normal">The <strong class="screenText">Workloads</strong> view offers some <a id="_idIndexMarker1587"/>of the same details as the <strong class="screenText">Applications</strong> view, including traffic, inbound metrics, outbound metrics, and tracing – however, in addition to these details, we can now view the logs and details about Envoy.</p>
<p class="normal">If you click on the <strong class="screenText">Logs</strong> tab, you will see the logs for the <strong class="screenText">adservice</strong> container.</p>
<figure class="mediaobject"><img alt="" height="254" src="../Images/B21165_16_14.png" width="880"/></figure>
<p class="packt_figref">Figure 16.14: Viewing the container logs</p>
<p class="normal">This is a real-time view of the logs that are being generated by the <strong class="screenText">adservice</strong> container. In this view, you can create a filter to show or hide certain keywords, scroll back to previous events, change the default buffer size from 100 lines, copy the logs to your clipboard, or enter a fullscreen log view. Many users find this tab very useful since it doesn’t require them to use <code class="inlineCode">kubectl</code> to look at the logs; they can simply open up Kiali in a browser and quickly view the logs in the GUI.</p>
<p class="normal">The last tab we will discuss is the <strong class="screenText">Envoy</strong> tab, which provides additional details about the Envoy sidecar. The details in this tab are extensive – it contains all of the mesh objects that you have included in the namespace (recall that we created a sidecar object to limit the objects to only the namespace and the <code class="inlineCode">istio-system</code> namespace), all of the listeners, routes, the bootstrap configuration, config, and metrics.</p>
<p class="normal">By this point in the chapter, you can probably<a id="_idIndexMarker1588"/> see how Istio would require its own book to cover all of the base components. All of the tabs in the <strong class="screenText">Envoy</strong> tab provide a wealth of information, but it gets very detailed and we can’t fit them all in this chapter, so for the purposes of this chapter, we will only discuss the <strong class="screenText">Metrics</strong> tab.</p>
<p class="normal">Clicking on the <strong class="screenText">Metrics</strong> tab, you will see metrics pertaining to the uptime of Envoy, the allocated memory, heap size, active upstream connections, upstream total requests, downstream active connections, and downstream HTTP requests.</p>
<figure class="mediaobject"><img alt="" height="394" src="../Images/B21165_16_15.png" width="875"/></figure>
<p class="packt_figref">Figure 16.15: Envoy metrics</p>
<p class="normal">Like most metrics, these will be beneficial if you experience issues with the Envoy proxy container. The uptime will let you know how long the pod has been running, the allocated memory tells you how much memory has been allocated to the pod, which may help to identify why an OOM condition occurred, and active connections will identify if the service has issues if the connection<a id="_idIndexMarker1589"/> count is lower than expected, or at zero.</p>
<h3 class="heading-3" id="_idParaDest-558">Using the Services view</h3>
<p class="normal">Finally, we will discuss<a id="_idIndexMarker1590"/> the last view for the application, the Services view. Just as the name implies, this will provide a view of the services that are part of the workload. You can open the Services view by clicking on the <strong class="screenText">Services</strong> option in Kiali.</p>
<figure class="mediaobject"><img alt="" height="271" src="../Images/B21165_16_16.png" width="874"/></figure>
<p class="packt_figref">Figure 16.16: The Services view</p>
<p class="normal">Similar to the other views, this will provide the names of the services and the health of each of the services. If you click on any individual service, you will be taken to the details of the service. If you were to click <strong class="screenText">adservice</strong>, you would be taken to the overview for the service.</p>
<figure class="mediaobject"><img alt="" height="435" src="../Images/B21165_16_17.png" width="878"/></figure>
<p class="packt_figref">Figure 16.17: The services overview</p>
<p class="normal">The <strong class="screenText">Overview</strong> page should have some objects familiar to you. Just like the other views, it provides a view of just the objects that communicate with <strong class="screenText">adservice</strong>, and it has tabs for traffic, inbound metrics, and traces – however, in addition to these, it also shows the network information for the service. In our example, the service has been configured to use a <code class="inlineCode">ClusterIP</code> type, the service IP assigned is <code class="inlineCode">10.110.47.79</code>, it has an endpoint of <code class="inlineCode">10.240.189.149</code>, and it has the gRPC TCP port exposed on port <code class="inlineCode">9555</code>.</p>
<p class="normal">This is information you could retrieve<a id="_idIndexMarker1591"/> using <code class="inlineCode">kubectl</code>, but for many people, it’s quicker to grab the details from the Kiali dashboard.</p>
<h3 class="heading-3" id="_idParaDest-559">The Istio Config view</h3>
<p class="normal">The last view we have<a id="_idIndexMarker1592"/> is not related to the workload in particular. Instead, it’s a view for the Istio config for the namespace. This view will contain the Istio objects you have created. In our example, we have two objects, the gateway and the virtual service.</p>
<figure class="mediaobject"><img alt="" height="314" src="../Images/B21165_16_18.png" width="877"/></figure>
<p class="packt_figref">Figure 16.18: The Istio Config view</p>
<p class="normal">You can view the YAML for each object by clicking the name. This allows you to directly edit the object in the Kiali dashboard. Any changes that are saved will edit the object in the cluster, so be careful if you are using this method to modify the object.</p>
<p class="normal">This view offers one addition<a id="_idIndexMarker1593"/> that the other views do not – the ability to create a new Istio object using a wizard. To create a new object, click the <strong class="screenText">Actions</strong> dropdown in the upper right-hand corner of the Istio config view. This will bring up a list of objects that you can create, as shown in <em class="italic">Figure 16.19</em>.</p>
<figure class="mediaobject"><img alt="" height="576" src="../Images/B21165_16_19.png" width="301"/></figure>
<p class="packt_figref">Figure 16.19: Istio object creation wizard</p>
<p class="normal">As you can see in the figure, Kiali provides<a id="_idIndexMarker1594"/> a wizard to create 6 Istio objects including <strong class="screenText">AuthorizationPolicies</strong>, <strong class="screenText">Gateways</strong>, <strong class="screenText">PeerAuthentication</strong>, <strong class="screenText">RequestAuthentication</strong>, <strong class="screenText">ServiceEntries</strong>, and <strong class="screenText">Sidecars</strong>.</p>
<p class="normal">Each option has a wizard to guide you through the specific requirements for that object. For example, we could create a sidecar using the wizard, as shown in <em class="italic">Figure 16.20</em>.</p>
<figure class="mediaobject"><img alt="" height="529" src="../Images/B21165_16_20.png" width="878"/></figure>
<p class="packt_figref">Figure 16.20: Using the Istio object wizard</p>
<p class="normal">Once all fields have been entered<a id="_idIndexMarker1595"/> correctly, you can click <strong class="screenText">Preview</strong>, which will take you to the next screen, where you will see the object YAML source, as shown in <em class="italic">Figure 16.21</em>.</p>
<figure class="mediaobject"><img alt="" height="534" src="../Images/B21165_16_21.png" width="877"/></figure>
<p class="packt_figref">Figure 16.21: Wizard source YAML</p>
<p class="normal">If it looks good, click <strong class="screenText">Create</strong> to create the new object.</p>
<p class="normal">The wizards are a good tool<a id="_idIndexMarker1596"/> for people who are new to Istio, but be careful not to rely on them too much. You should always understand how to create a manifest for all of your objects. Creating objects using wizards like these can lead to problems down the road without the knowledge of how the object works or is created.</p>
<p class="normal">In the next section, we will introduce where Istio is heading in the future. As powerful as the sidecar is, it has its limitations, and it requires additional resources for each pod in the mesh. In 2023, Istio introduced<a id="_idIndexMarker1597"/> a new concept called ambient mesh as an early access feature, which removed the requirement for the Istio sidecar.</p>
<h1 class="heading-1" id="_idParaDest-560">The future: Ambient mesh</h1>
<p class="normal">Today, Service meshes, such as Istio, depend<a id="_idIndexMarker1598"/> on sidecar proxies connected to every service instance to handle traffic, security measures, and metric collection. Although this approach works well, it leads to extra resource usage and complexity, particularly in deployments in larger clusters.</p>
<p class="normal">In this chapter, we mentioned sidecars a lot – they’re the heart of the mesh, providing the layer that removes all of the complexities of using mesh features without requiring code changes to our applications.</p>
<p class="normal">Ambient mesh marks a significant change in the Service mesh design, attempting to make it easier to add Service mesh features to an already complicated system without the need for sidecar proxies for every service. Its goal is to cut down on the extra work and complexity while keeping the main advantages of a Service mesh, including monitoring, security, and traffic management.</p>
<p class="normal">As of Istio 1.20, the ambient mesh<a id="_idIndexMarker1599"/> has the <strong class="keyWord">Alpha</strong> status. The main reason that we haven’t added a chapter on using an ambient mesh is due to potential changes that will likely occur between the current alpha stage and when it goes to <strong class="keyWord">general availability</strong> (<strong class="keyWord">GA</strong>). However, since it is a giant leap forward and a major change in design, we wanted to bring it to your attention. You can read more about getting started with ambient mesh<a id="_idIndexMarker1600"/> on Istio’s site here: <a href="https://istio.io/latest/docs/ops/ambient/getting-started/"><span class="url">https://istio.io/latest/docs/ops/ambient/getting-started/</span></a>.</p>
<p class="normal">Reading the docs on Istio’s site will provide some great examples of how the ambient mesh deploys and works. Since many readers will be new to Istio, jumping into the docs for an overview may be a little much, so we wanted to provide our view on the key points of what the ambient mesh means to us.</p>
<p class="normal">As we mentioned, ambient mesh addresses a number of issues by removing the tasks that are usually managed by sidecar proxies. Rather than attaching a proxy to each service instance, the ambient mesh will integrate these functions directly into the network or in a common proxy layer. This design seeks to simplify processes and lessen the resources needed compared to the traditional sidecar method. This provides a number<a id="_idIndexMarker1601"/> of advantages, including:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Preservation of Essential Features</strong>: Despite its unique architecture, the ambient mesh will continue to deliver the base capabilities found in current Service meshes, including secure communications between services, traffic control, and the ability to monitor components.</li>
<li class="bulletList"><strong class="keyWord">Streamlined, Efficient Deployments</strong>: The ambient mesh eliminates the necessity for individual sidecar proxies, streamlining the setup and management of Service meshes. This will facilitate easier adoption and maintenance, especially for organizations with complex microservices structures.</li>
<li class="bulletList"><strong class="keyWord">Improved Resource</strong> <strong class="keyWord">Utilization</strong>: By minimizing the CPU and memory demands for service-to-service interactions, the ambient mesh allows the efficient use of resources.</li>
<li class="bulletList"><strong class="keyWord">Performance Enhancement</strong>: The ambient mesh enhances system performance by optimizing the routes used for service communication, reducing delays and boosting<a id="_idIndexMarker1602"/> efficiency.</li>
</ul>
<p class="normal">Imagine the resource and complexity savings in a large cluster where you may have thousands, or tens of thousands, of services running. Currently, that would require as many proxy instances running, each adding an extra layer in the communication and using its own resources – using extra CPU and RAM that are not actually “required” for the base applications. The ambient mesh will save you money by reducing the required resources, and by simplifying the architecture, it should be easier to find issues<a id="_idIndexMarker1603"/> when an application is not behaving as expected.</p>
<p class="normal">We hope that this chapter has provided a useful introduction to Istio and what’s in store for Istio’s future. In the next chapter, we will dive deeper into running applications in an enterprise using Istio.</p>
<h1 class="heading-1" id="_idParaDest-561">Summary</h1>
<p class="normal">In this chapter, we introduced you to the Service mesh world, using the popular open-source project Istio. In the first section of the chapter, we explained some of the advantages of using a Service mesh, which included security and observability for mesh services.</p>
<p class="normal">The second section of the chapter detailed the installation of Istio and the different installation profiles that are available. We deployed Istio into our KinD clusters and we also removed NGNIX to free up ports <code class="inlineCode">80</code> and <code class="inlineCode">443</code> to be used by Istio’s ingress gateway. This section also included the objects that are added to a cluster once you deploy Istio. We covered the most common objects using example manifests that reinforce how to use each object in your own deployments.</p>
<p class="normal">To close out the chapter, we detailed how to install Kiali, Prometheus, and Jaeger to provide powerful observability in our Service mesh. We also explained how to use Kiali to look into an application in the mesh to view the application metrics and logs.</p>
<p class="normal">In the next chapter, we will deploy a new application and bind it to the Service mesh, building on many of the concepts that were presented in this chapter.</p>
<h1 class="heading-1" id="_idParaDest-562">Questions</h1>
<ol>
<li class="numberedList" value="1">What Istio object(s) is used to route traffic between multiple versions of an application?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Ingress rule</li>
<li class="alphabeticList level-2">VirtualService</li>
<li class="alphabeticList level-2">DestinationRule</li>
<li class="alphabeticList level-2">You can’t route traffic between multiple versions, only a single instance</li>
</ol>
</li>
<li class="numberedList">What tool(s) are required to provide observability in the Service mesh?<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Prometheus</li>
<li class="alphabeticList level-2">Jaeger</li>
<li class="alphabeticList level-2">Kiali</li>
<li class="alphabeticList level-2">Kubernetes Dashboard</li>
</ol>
</li>
<li class="numberedList">True or false: Istio features require developers to change their code to leverage features like mutual TLS and authorization.<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">True</li>
<li class="alphabeticList level-2">False</li>
</ol>
</li>
<li class="numberedList">Istio made the control plane easier to deploy and configure by merging multiple components into a single executable called:<ol class="alphabeticList level-2" style="list-style-type: lower-alpha;">
<li class="alphabeticList level-2" value="1">Istio</li>
<li class="alphabeticList level-2">IstioC</li>
<li class="alphabeticList level-2">istiod</li>
<li class="alphabeticList level-2">Pilot</li>
</ol>
</li>
</ol>
<h1 class="heading-1" id="_idParaDest-563">Answers</h1>
<ol>
<li class="numberedList" value="1">b - VirtualService and c - DestinationRule</li>
<li class="numberedList">a Prometheus and c - Kiali</li>
<li class="numberedList">b - False</li>
<li class="numberedList">c - Pilot</li>
</ol>
</div>
</div></body></html>