- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracing Technicalities with Grafana Tempo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Grafana Tempo** is the third telemetry storage tool from Grafana that we’ll
    discuss; it provides the capability to store and query trace data. This chapter
    will introduce the **Tempo query language** (**TraceQL**). TraceQL can be used
    to select and filter traces generated by your applications to gather insights
    from across traces; the language is very similar to LogQL and PromQL but tailored
    to trace data. In this chapter, we will explore the major tracing protocols and
    how they can be used to output traces from applications; this will help you make
    informed choices on which protocol to use in an application, or which protocols
    to support when collecting data. We’ll then explore the architecture of Tempo
    to understand how it can fulfill the need for a scalable platform for tracing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Tempo and the TraceQL query language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring tracing protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Tempo architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will use the demo application and Grafana Cloud instance
    (set up in [*Chapter 3*](B18277_03.xhtml#_idTextAnchor063)). You'll find the code
    for the chapter in the GitHub repository at [https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6](https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6).
    You'll find the *Code in Action* videos at [https://packt.link/fJVXi](https://packt.link/fJVXi).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the OpenTelemetry Demo application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we have provided an updated `OTEL-Collector.yaml` with additional
    tracing configuration. This updated configuration is in the GitHub repository
    in the `chapter6` directory. Full details on the update process are available
    from the GitHub repository in `README.md`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this updated configuration to the OpenTelemetry Collector, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrade the Collector with Helm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate that the upgrade was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your traces will now have more labels, and will also produce service graphs
    and span metrics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that our local installation is updated, let’s begin by exploring the third
    query language, TraceQL.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Tempo and the TraceQL query language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tempo and TraceQL are the newest of the tools and query languages we will explore
    in depth in this book. Like LogQL, TraceQL was built using PromQL as an inspiration
    and offers developers and operators a familiar set of filtering, aggregation,
    and mathematical tools that aid in the observability flow between metrics, logs,
    and traces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a quick look at how Tempo sees trace data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace collection**: Introduced in [*Chapter 2*](B18277_02.xhtml#_idTextAnchor043),
    a trace (or distributed trace) is a collection of data that represents a request
    propagating through a system. Traces are often collected from multiple applications.
    Spans are sent by each application to some form of collection architecture and,
    ultimately, to Tempo for storage and querying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trace fields**: The following diagram introduces a simplified structure of
    a trace, similar to the simplified structure of logs, seen in [*Chapter 4*](B18277_04.xhtml#_idTextAnchor092),
    and traces, seen in [*Chapter 5*](B18277_05.xhtml#_idTextAnchor106):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A simplified view of a trace containing four spans](img/B18277_Figure_6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A simplified view of a trace containing four spans
  prefs: []
  type: TYPE_NORMAL
- en: Back in [*Chapter 2*](B18277_02.xhtml#_idTextAnchor043), we introduced the common
    fields of a trace. In the preceding figure, we can see that all four spans have
    the same `trace_id`, which is the unique identifier of the whole trace. Each span
    has a unique identifier, the `span_id`. Each span also records where it came from,
    using the `parent_id` field. Finally, the start and end times are recorded. This
    simplified view does exclude several of the fields seen in the **OpenTelemetry
    Protocol** (**OTLP**), **Zipkin**, and **Jaeger**, which are used to capture a
    lot of contextual information. We will discuss these later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen the structure of trace data, let’s now explore the Tempo
    interface and how we can query data.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Tempo features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will introduce the major features of Tempo, the tracing
    platform available in Grafana, and its query language, TraceQL. In *Chapters 4*
    and *5*, we introduced the LogQL and PromQL languages, which focus on being able
    to select log or metric data and offer detailed functionality to perform a powerful
    analysis of the selected data. Currently, PromQL only offers the ability to select
    trace data. While there are powerful tools to select this data, there are no tools
    to perform an analysis. Such functionality is an eventual aim for the product,
    but we wanted to highlight the current state of Tempo at `v2.3.x`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by exploring the user interface for Tempo and how it represents
    trace data.
  prefs: []
  type: TYPE_NORMAL
- en: The Tempo interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main view used to explore data in Tempo is split into two parts, the **query
    editor**, and the **trace view**. In the following screenshot, the query editor
    is on the left and the trace view is on the right. When you first enter the view,
    you will only see the query editor. The trace view is opened when a trace ID or
    span ID is clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The query editor (left) and the trace view (right)](img/B18277_Figure_6.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The query editor (left) and the trace view (right)
  prefs: []
  type: TYPE_NORMAL
- en: The results panel is contextual. If we use TraceQL to run a search, it will
    return a list of traces and spans that match; this is shown on the left in the
    preceding screenshot. However, if we search for a specific trace ID, we will be
    shown the trace view on the right, where we can explore the spans in the trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are examining the query panel, let’s look at two of the different
    search modes we can use, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Search modes](img/B18277_Figure_6.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Search modes
  prefs: []
  type: TYPE_NORMAL
- en: 'The two search modes shown in the preceding screenshot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Search mode**: Here, you are presented with drop-down menus to select
    the traces you are interested in. This is especially useful for people who are
    new to Tempo and want to get data quickly, but we will not explore this search
    mode in this book. Be aware that this mode is due to be deprecated in Grafana
    10.3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TraceQL mode**: This allows you to use TraceQL to search in a very granular
    way for the data you need. This is the default search mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As well as these, three search modes are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loki Search mode**: This should be familiar to you from [*Chapter 4*](B18277_04.xhtml#_idTextAnchor092);
    it is available in Tempo, so you can pivot between logs containing trace and span
    IDs and a full trace view very quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON File mode**: This allows for a trace saved in the JSON format to be
    imported and viewed directly. Combined with the export functionality, this allows
    for the simple preservation and sharing of interesting traces. Exploring the data
    in an exported JSON file is a good exercise for understanding the underlying data
    structures used in tracing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Graph mode**: One of the most powerful features of collecting distributed
    traces is the ability to visualize the connections between those services. This
    tool gives anyone a clear graphical representation of how applications in a system
    communicate with each other. This functionality leverages metrics and traces together
    to represent a system’s current state. The tool will also indicate erroring requests
    in red and successful requests in green.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the default view of a service graph:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Service graphs](img/B18277_Figure_6.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Service graphs
  prefs: []
  type: TYPE_NORMAL
- en: As well as representing the connections between services, the preceding screenshot
    shows the request rates and average latency of the responses. Above the service
    graph, the **Requests, Errors, and Duration** (**RED**) metrics are shown. We
    will discuss these metrics in greater detail in [*Chapter 9*](B18277_09.xhtml#_idTextAnchor183).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, this aspect of OpenTelemetry and Tempo is under active
    development, and the authors are looking forward to the features that are coming.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the interface for Tempo, let us understand how to use
    TraceQL to query trace data.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Tempo Query language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Prometheus and Loki, Tempo offers a query language, **TraceQL**. Now that
    you are familiar with the interface of Tempo and the structure of traces, let’s
    explore the features of TraceQL.
  prefs: []
  type: TYPE_NORMAL
- en: Field types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TraceQL uses two field types, **intrinsic fields** and **attribute fields**.
    Let’s look at these in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`status`: The value could be `error`, `ok`, or unset (`null`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statusMessage`: Optional text to clarify the status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration`: The time between the start and end of the span'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The operation or span name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind`: The value could be `server`, `client`, `producer`, `consumer`, `internal`,
    or `unspecified`, which is a fallback value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traceDuration`: Number of milliseconds between the start and end of all spans
    in the trace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootName`: The name of the first span of the trace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootServiceName`: The name of the first service of the trace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span.http.method` and `span.app.ads.ad_response_type`.*   `resource.container.id`
    and `resource.k8s.node.name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For efficient querying, it is best practice to always include `span.` and `resource.`
    in an attribute query. However, it is possible to use a leading `.` to query when
    you are unsure whether a field is a span or resource – for example, `.http.method`
    or `.k8s.node.name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking at an individual span, you can see the fields available under
    **Span Attributes** and **Resource Attributes**. This expanded view of a single
    trace shows the fields that are contained in the span:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Attributes for a span](img/B18277_Figure_6.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Attributes for a span
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a good grasp of the fields available when searching traces
    in Tempo, let’s have a look at how to search for traces and spans.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting traces and spans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'TraceQL offers tools to select data to show in a dashboard, or just to explore
    the current state of the system. These are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Syntax** | **Operators** | **Scope** |'
  prefs: []
  type: TYPE_TB
- en: '| Field selector | `{field = "` `value"}` | `=`, `!=`, `>`, `>=`, `<`, `<=`,
    `=~`, `!~` | Selects spans on the value of a field |'
  prefs: []
  type: TYPE_TB
- en: '| Field expressions | `{field1="value1" &&` `field2="value2"}` | `&&`, `&#124;&#124;`
    | Selects spans on the values of multiple fields |'
  prefs: []
  type: TYPE_TB
- en: '| Logical operators | `{field1="value1} && {``field1="value2}` | `&&`, `&#124;&#124;`
    | Selects spans where a logical check between sets of spans is `true`. This can
    check multiple fields. |'
  prefs: []
  type: TYPE_TB
- en: '| Structural operators | `{field1="value1"} > {``field2="value2}` | `>`, `>>`,
    `~` | Searches for spans in the second filter where they are related to the first
    filter.These are explained in more detail after this table. |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – The selection operators available in TraceQL
  prefs: []
  type: TYPE_NORMAL
- en: 'Structural operators offer the ability to carry out queries that take account
    of where conditions are met upstream (parent) or downstream (child) in a trace.
    Let’s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>` or the **child operator** refers to the direct child, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding line would search for any span from the product catalog service,
    where the frontend service was the immediate parent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`>>` or the **descendent operator** refers to any descendent, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would search for any span from the cart service where the frontend service
    was a parent in the trace but could have passed through another service first,
    such as the checkout service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`~` or the **sibling operator** refers to any spans that share the same parent,
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would search for any span that visited the frontend multiple times. In
    the demo application, the frontend service would be the parent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These operators allow us to select data. TraceQL also allows tools to carry
    out aggregation and mathematical functions on trace data.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregators and arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Aggregators and mathematical functions allow for more complex queries. These
    can display information aggregated across all traces. Some of these are described
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Syntax** | **Operators** | **Scope** |'
  prefs: []
  type: TYPE_TB
- en: '| Count aggregator | `&#124; count()` `>` `10` | `count()` | Refines the returned
    spans by the total count of spans in the span set |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric aggregators | `&#124;` `avg(duration) >` `20ms` | `avg()`, `max()`,
    `min()`, and `sum()` | Refines the returned spans by the field in the span set
    |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic operators | `{field1 < field2 *` `10}` | `+`, `-`, `*`, `/`, and
    `^` | Performs arithmetic on numeric fields |'
  prefs: []
  type: TYPE_TB
- en: Table 6.2 – Aggregation and mathematical operators in TraceQL
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that TraceQL is in active development at the time of writing,
    so this list of operators is expected to grow.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen how to search trace data, let’s discuss the important
    topic of moving seamlessly between data types to get a full picture.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting between data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When correctly instrumented, an application will produce data that can be used
    to move between traces, logs, and metrics to truly understand what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following span, where an error was seen in `checkoutservice`.
    This could be a problematic error in a real shop, as it suggests a customer got
    to the checkout and was unable to complete their sale for some reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Finding the logs for an error](img/B18277_Figure_6.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Finding the logs for an error
  prefs: []
  type: TYPE_NORMAL
- en: The query interface for Tempo offers a helpful link, `service_name` and `service_namespace`
    fields from the trace to query Loki. In a similar way, services can inject the
    trace context (`traceId` and `spanId`) into their log output where available.
    Loki can then be configured to provide contextual linking to Tempo, to see the
    trace view. Finally, as mentioned in [*Chapter 5*](B18277_05.xhtml#_idTextAnchor106),
    metrics can present exemplars, which allow users to see a sample trace from a
    metric graph.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve explored the ways of seeing the data produced by applications. In the
    next section, we will understand the different protocols that are available to
    produce trace data for Grafana Tempo.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring tracing protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18277_02.xhtml#_idTextAnchor043), we introduced the three
    main **tracing protocols**, OTLP, Zipkin, and Jaeger. In this section, we will
    explore some of the features of these protocols, how well-supported they are,
    and how to use them in the software services that you write. We will also discuss
    the different **headers** used by these protocols to propagate context to other
    services. A tracing protocol is made up of a set of headers that are added to
    the HTTP requests made by an instrumented application. These headers are what
    propagate the information of individual spans to downstream services. Once all
    of these spans are collected, they form a fully distributed trace.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main tracing protocols?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s look at the features and support of the main tracing protocols
    – OTLP, Zipkin, and Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: OTLP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OTLP tracing offers support for C++, .NET, Erlang, Go, Java, JavaScript, PHP,
    Python, Ruby, Rust, and Swift. There is good support for OTLP in popular development
    frameworks such as Spring, Django, ASP.NET, and Gin. With this wide support, it
    is best practice to search the documentation for your framework of choice on how
    to instrument an application; in most cases, instrumentation can be as simple
    as adding a few lines of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing is an inherently distributed process, and there have been several standards
    to propagate trace fields. This means that applications may need to use different
    HTTP or gRPC headers when handling traces, depending on other applications in
    their operating environment. OTLP provides native support for W3C TraceContext,
    B3, and Jaeger propagation headers, as well as support for W3C baggage headers,
    used to propagate other context information. The support of B3 and Jaeger headers
    means that applications instrumented with Zipkin and Jaeger libraries are natively
    supported. However, other trace headers such as AWS’s X-Ray protocol are not maintained
    as part of the mainline distribution. If these protocols are used, it is recommended
    to use the relevant vendor’s distribution of OpenTelemetry – for example, the
    *AWS Distro for OpenTelemetry* when X-Ray is used in a monitored environment ([https://aws.amazon.com/otel/](https://aws.amazon.com/otel/)).
  prefs: []
  type: TYPE_NORMAL
- en: In the data collection space, OTLP trace data has good support from the OpenTelemetry
    Collector, Grafana Agent, FluentBit via a plugin, and Telegraf via a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Zipkin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zipkin offers support for C#, Go, Java, JavaScript, Ruby, Scalar, and PHP via
    supported libraries, and C++, C, Clojure, Elixir, Lua, and Scala, via community-supported
    libraries. As with OTLP, there is also good support for Zipkin in popular development
    frameworks, so it is good practice to check the framework documentation when instrumenting
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Zipkin only natively supports the B3 propagation headers. However, as frameworks
    offer pluggable support for different trace protocols, support for alternative
    propagation headers is probably easy to implement in an application.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to data collection, Zipkin is supported by the OpenTelemetry Collector,
    Grafana Agent, and the native tools created by Zipkin.
  prefs: []
  type: TYPE_NORMAL
- en: Jaeger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have included Jaeger for historical reasons here, but it is not recommended
    for adoption. Jaeger was originally developed by *Uber*. Before January 2022,
    Jaeger offered SDKs for Java, Python, Node.js, Go, C#, and C++. These SDKs supported
    the OpenTracing APIs. OpenTelemetry was formed by the OpenTracing and OpenCensus
    projects merging. Jaeger now recommends the use of the OpenTelemetry SDKs for
    instrumenting applications. For applications already using the Jaeger client libraries,
    migration guides have been provided by OpenTelemetry: [https://opentelemetry.io/docs/migration/opentracing/](https://opentelemetry.io/docs/migration/opentracing/).'
  prefs: []
  type: TYPE_NORMAL
- en: Jaeger libraries supported the Jaeger, Zipkin, and W3C TraceContext headers,
    but they had no support for any other propagation formats.
  prefs: []
  type: TYPE_NORMAL
- en: There was not wide support in data collectors for Jaeger while it was actively
    supported; the intended way to use the protocol was to collect data in a Jaeger
    backend locally in an environment. The OpenTelemetry Collector and Grafana Agent
    do offer receivers for Jaeger traces and allow you to collect these traces as
    applications migrate to the OpenTelemetry protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the tracing protocols, let’s look at the headers
    that are used to propagate information between services that use distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Context propagation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Distributed tracing** is relatively new in web technologies, with the **World
    Wide Web Consortium** (**W3C**) making **Trace Context** a recommended standard
    in November 2021, while the **Baggage** format is still currently in a working
    draft state. Tracing records information in two distinct ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Traces and spans are sent to a collection agent by each application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications also share data using HTTP or gRPC headers, which are picked up
    by the receiving application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As tracing is a new technology, a couple of unofficial standard formats were
    used before the official W3C Trace Context headers were decided on. To provide
    some historical context on tracing, we’ll explore the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: Jaeger/Uber headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipkin B3 headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3C Trace Context headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3C baggage headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jaeger/Uber headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jaeger libraries historically used the following header formats; we’ve included
    these for historical reference, as these should be considered deprecated in favor
    of W3C Trace Context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two HTTP headers used in Jaeger are `uber-trace-id` and `uberctx`, which
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the `uber-trace-id` header is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down the various fields in the `uber-trace-id` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '`trace-id`: This field is a 64-bit or 128-bit random number and is hex-encoded.
    In the example this is `269daf90c4589ce1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span-id` and `parent-span-id`: These are 64-bit random numbers and are hex-encoded.
    These are `5c44cd976d8f8cd9` and `39e8e549de678267`, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags`: This field is used to convey additional information, such as whether
    the trace is being sampled. In this example, its value is `0x01`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `uberctx` baggage header, the fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`baggage-key`: This is a unique string that is used to name the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baggage-value`: This is a string that will be percent-encoded. Baggage as
    a concept will be explored further in the *W3C* *baggage* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipkin B3 headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Zipkin libraries use `B3` headers; unlike the Uber headers, Zipkin has historically
    separated each field into its own header, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break these headers down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`X-B3-TraceId`: Similar to the Jaeger format, `TraceId` is 64-bit or 128-bit
    hex-encoded. Here is an example of this header as it would be sent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`X-B3-ParentSpanId` and `X-B3-SpanId`: These are 64-bit and hex-encoded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-B3-Sampled`: This has a value of either `1` or `0`, although early implementations
    may use `true` or `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-B3-Flags`: This header is used to propagate debug decisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b3`: Zipkin predated the introduction of the W3C Trace Context standards.
    To aid in the transition to the newly agreed standard, Zipkin introduced the `b3`
    header. Later versions of Zipkin can propagate using both these headers and the
    W3C Trace Context headers for interoperability. The `b3` header exactly matches
    the `tracestate` header used in *W3C Trace Context* and represents the other headers
    combined into one mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3C Trace Context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'W3C specifies a standard pair of headers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break these headers down into their constituents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The various fields in `traceparent` are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `trace-id` is a hex-encoded 16-byte array (128-bit).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent-id` is a hex-encoded 8-byte array (64-bit); this field is equivalent
    to `span-id` or `SpanId` in Jaeger and B3, respectively, and represents the span
    ID used by the service that generated the header. It differs from the B3 `ParentSpanId`,
    as this can be used to represent a service further upstream that initiated a traced
    process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `version` field is another hex-encoded 8-bit field; it represents the version
    of the standard being used. Currently, only version 00 exists.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace-flags` is another hex-encoded 8-bit field. In version 00 of the W3C
    standard, the only available flag is one to denote whether sampling is occurring
    or not.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracestate` is used to encode vendor-specific information. While `traceparent`
    is a fixed format and required by any vendor adopting the standard, `tracestate`
    is available for vendors to ensure that trace data is propagated while giving
    space for them to use and encode that data as desired. The only requirement regarding
    this header field is that the contents will be a comma-separated list of key-value
    pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3C baggage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tenantId`, but when an application makes a request to a downstream application,
    that application may not need to know about `tenantId` for it to process the request.
    A baggage header allows us to propagate this `tenantId` field to the downstream
    application. The downstream application can then use this field in its observability
    instrumentation, while not polluting its data model with an unrelated field. This
    effectively separates *observability* concerns from *application* concerns. It’s
    important to note that data contained in baggage headers can be exposed to anyone
    inspecting network traffic, so it should not be used to share sensitive information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'W3C `baggage` headers look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All fields must be percent-encoded; the full header must have 64 members or
    fewer, and it has a maximum size of 8,192 bytes. Using baggage gives systems a
    standardized way to propagate contextual information.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now discussed how trace data is produced by applications and how it is
    shared, both with a collection agent and other applications. Let’s take some time
    to look at how data is processed and stored by Tempo.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Tempo architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Loki and Mimir, Tempo leverages object stores such as Amazon S3, Google
    Cloud Storage, and Microsoft Azure Blob Storage. With the horizontal scalability
    of components in both the read and write pathways, Tempo has a fantastic ability
    to scale as data volumes increase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture used by Tempo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The Tempo architecture](img/B18277_Figure_6.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The Tempo architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The *write* pathway for Tempo consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributor**: The distributor is responsible for accepting spans and routing
    them to the correct instance of the ingester service, based on the trace ID of
    the span.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingester**: The ingester is responsible for grouping spans into traces, batching
    multiple traces into blocks, and writing bloom filters and indexes for querying.
    Once a block is complete, the ingester also flushes the data to the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics generator**: The metrics generator is an optional component; it receives
    spans from the distributor and uses them to produce service graphs and span metrics
    (such as the rate and the error duration). These are then written to a metrics
    backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *read* pathway has these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query frontend**: The frontend is responsible for receiving a query and splitting
    it into smaller shards, based on the blocks (created by the ingester) that will
    be read to return the requested data. These shards are then queued with queriers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Querier**: This component is responsible for finding the requested data,
    either from the backend if the block has been flushed, or directly from the ingester
    if the block is still being collected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **compactor**, which is a standalone component, is responsible for optimizing
    the use of the backend storage.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re done exploring the system architecture of Tempo, you have seen
    all the major components of the tool, and how distributed tracing using Tempo
    can help provide great visibility of the components of the systems you run.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use TraceQL to query trace data stored in
    Tempo, which will help you build queries for dashboards using this rich data source.
    You have explored the Tempo user interface, so you will be confident in moving
    around the interface. Combined with the skills learned in *Chapters 4* and *5*
    you will be confident in moving between log, metric, and trace data in Grafana
    to be able to observe the systems you work with.
  prefs: []
  type: TYPE_NORMAL
- en: We took a detailed look at the different protocols and libraries you can use
    when instrumenting an application, and we saw the levels of support those tools
    have across different programming languages. We also explored the HTTP headers
    that are used to propagate trace data between applications. This will help you
    choose the best way to instrument an application and how to work with applications
    that are already instrumented with tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the Tempo architecture and how it can horizontally scale
    to support your organization with however many traces you need to sample. With
    this knowledge, you will understand how to operate a Tempo installation and monitor
    the various components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will conclude *Part 2* of the book by showing you how
    to collect data from your infrastructure layers, whether that is a cloud provider
    such as AWS, Azure, or GCP, or a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
