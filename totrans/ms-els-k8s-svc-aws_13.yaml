- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using IAM for Granting Access to Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS has over 200 services available, from SQL/NoSQL databases to machine learning
    and quantum computing. It’s likely that at some point you will want to use one
    of these services from within your application deployed on EKS.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter looks at how you can grant IAM permissions to Pods, how you use
    the associated credentials in your application to connect to an AWS service, and
    how to troubleshoot issues with the overall process. Specifically, we will cover
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what **IAM Roles for Service Accounts** (**IRSA**) is and what
    problems it solves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IRSA in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to troubleshoot IAM issues on EKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reader should be familiar with YAML, AWS IAM, and EKS architecture. Before
    getting started with this chapter, please ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You have network connectivity to your EKS cluster API endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS CLI, Docker, and the `kubectl` binaries are installed on your workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a basic understanding of AWS IAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding IRSA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, let’s look at how IAM role assignment works for standard EC2 instances.
    In AWS IAM, roles are used to allocate permissions (using one or more policies).
    A role can be assigned to an EC2 instance using an instance profile, which is
    simply a container for the IAM role that’s attached to a specific EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – EC2 role assignment](img/B18129_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – EC2 role assignment
  prefs: []
  type: TYPE_NORMAL
- en: 'When an EC2 instance is created and assigned a role, the AWS platform will
    automatically create an instance profile. When that instance boots up, it will
    make a network call to the `169.254.169.254`, and query what (if any) instance
    profile (or role) is assigned to that instance. If one has been assigned, it can
    retrieve the access credentials, an example of which is shown next. These credentials
    consist of the access and secret keys, which are used for all AWS API calls and
    identify the role and therefore the permissions granted to the role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you log in to an EC2 instance, you can review the instance profile attached
    to a running instance using the `aws sts` command, which is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: AWS introduced IMDSv2 to provide some security controls on container platforms,
    so let’s review the main changes.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IMDSv2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have discussed, the instance profile information is retrieved through
    the EC2 IMDS, which runs at address `169.254.169.254` in every VPC. This service
    is critical to the operation of EC2 instances and should not be blocked for the
    worker nodes, but it should be restricted for Pods. The original IMDS version,
    version 1, doesn’t allow any restrictions to be placed on who can use it.
  prefs: []
  type: TYPE_NORMAL
- en: IMDSv2 is an enhancement to IMDSv1 that uses session-oriented requests to add
    security controls to the service. IMDSv2 returns a token, which is used to make
    requests for metadata and credentials. As the token is never stored in IMDSv2,
    when the process or application using the token ends, the token is lost. The metadata
    service uses the TTL hop count in the IPv4/IPv6 packet to allow requests. By default,
    it is set to 1, which means requests can only come directly from the EC2\. Any
    Pods running on the host will increment the hop count to 2 (as they use the bridge
    network inside the hots), which prevents them from using the IMDSv2 service directly
    and retrieving host instance profile credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force the use of IMDSv2 and restrict the hop count, you can run the following
    command on all the worker nodes or add the configuration into your **infrastructure-as-code**
    (**IaC**) definition for the launch template used for the worker nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This only works, however, if the Pod uses IMDSv2\. In most cases, the Pod uses
    the AWS SDK to make AWS API calls, which defaults to IMDSv2 to retrieve the credentials.
    These will have the hop limit applied. However, if the Pod uses IMDSv1, it can
    still retrieve the host credentials. In this case, the best practice is only to
    give the worker nodes minimal permissions (to pull ECR containers, for example)
    or limit access to IMDSv1 using Calico network policies or `iptables` rules.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ve looked at the underlying mechanism of how instances and Pods can
    use IMDS to retrieve credentials assigned to a host (and how we can restrict them
    from doing so). Let’s look at how we can assign specific roles directly to Pods
    using IRSA.
  prefs: []
  type: TYPE_NORMAL
- en: How IRSA works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IRSA allows you to assign specific privileges to a specific Pod by associating
    a Kubernetes `AssumeRoleWithWebIdentity` API call to the AWS **Security Token
    Service** (**STS**), which will exchange the Kubernetes-generated credentials
    for AWS IAM-generated credentials. It does this by using the OIDC provider for
    a specific EKS cluster as the principal and assuming the role that is defined
    in the SA annotation (step **3**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – How IRSA works](img/B18129_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – How IRSA works
  prefs: []
  type: TYPE_NORMAL
- en: Now we understand at a high level how IRSA will work, let’s look at what we
    need to configure so that a Pod can use IRSA.
  prefs: []
  type: TYPE_NORMAL
- en: Using IRSA in your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the basic concepts behind IRSA, let’s look at how you
    can configure and use it in your applications. We will look at how to deploy a
    Pod manually and configure it to use IRSA and then we will look at how you can
    really simplify the process using `eksctl`.
  prefs: []
  type: TYPE_NORMAL
- en: How to deploy a Pod and use IRSA credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to make sure you have an OIDC provider configured for your
    cluster. If you used `eksctl`, this will be configured already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven’t enabled it, you can use the following `eksctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an identity for our cluster that we can use, in IAM, we can
    create the relevant policies and roles. Let’s assume we want to give our Pod access
    to all S3 buckets and objects in the account. So, we will use the following policy
    to provide S3 access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then create the policy in our AWS account using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the policy we need to create the role and allow the EKS cluster
    OIDC provider and Kubernetes SA combination to assume that role. The following
    commands will allow you to do this. Let’s initially set up some environment variables
    for the AWS account, the EKS OIDC provider, the Kubernetes namespace, and SA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create the trust relationship for the role that the Pod will assume
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All this is doing is defining the mapping for the EKS OIDC provider and Kubernetes
    namespace and SA, so we need to create the role with this trust relationship and
    attach the policy we created previously to allow S3 access using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now set up everything that’s needed in the AWS IAM, so now we just
    need to configure a Pod to use the SA in the namespace defined here. Let’s start
    by configuring the SA in the `default` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run a Pod using the SA with the following commands. This will use
    the `aws-cli` image and run the `aws s3 ls` command, which should be able to list
    the buckets, as the assigned SA has the necessary permissions exposed through
    the role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you change the `serviceAccount` value to `default`, you will see the command
    fail, as the default SA has no annotation and therefore no mapping to a valid
    IAM role. Now, let’s look at how we can make this process easier using IaC.
  prefs: []
  type: TYPE_NORMAL
- en: How to create an IRSA role programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the `eksctl create iamserviceaccount` command from the previous
    chapter to allow the Pods hosting the storage controllers to communicate with
    the AWS storage APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the generic command, we can see we have associated a Kubernetes
    SA in a specific namespace with a specific IAM policy. The policy defines what
    API action can be performed and the association of an SA to a Pod allows that
    Pod to perform that action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in comparison to the previous section, the only thing we need to pre-provision
    is the policy with the relevant permissions, so we can provide `policyARN`. The
    `eksctl` tool will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the EKS cluster OIDC provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the role with a trust policy using the derived OIDC details and the Kubernetes
    SA name and namespace provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the pre-created policy to the IAM role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Kubernetes SA with the right annotations in the right namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now run the `kubectl run` command we used previously in the namespace
    and then use the SA specified in the `eksctl` command, and it should all work.
    Let’s look at how we can troubleshoot IRSA if there are any issues.
  prefs: []
  type: TYPE_NORMAL
- en: How to troubleshoot IAM issues on EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you need to do is determine whether this is an IAM permissions
    issue. If we look at the error message in the following example, we can see a
    very clear `AccessDenied` error message for an AWS API operation – in this case,
    the `ListBuckets` operations. This is a clear indicator that it’s an IAM error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to determine which SA is being used and work backward from
    there. In the example, it’s pretty clear, as we have the `run` command. However,
    assuming we don’t have it, we can use the next command to figure it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the following command to make sure the annotation is in place
    and identify what role will be assumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, there is no annotation, so it’s clear this SA has no permissions.
    If there was a role assigned, we could use the following commands to determine
    whether it was a policy or permissions issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we can see the attached policy, in this case, just one, we can then iterate
    over it, but first, you must get the version of the policy using the `get-policy`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now extract the permissions using the `get-policy-version` command.
    In the following example, the `s3:ListAllMyBuckets` operation is missing, which
    is causing the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of other areas you can consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out whether the assigned role trusts the right EKS OIDC provider
    using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'IRSA leverages a mutating webhook for Pod identity. You can validate that this
    has been deployed using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some other errors are covered in the *Further reading* section. In this section,
    we have looked at what IRSA is, how it works and is configured, and how you can
    do some basic IRSA troubleshooting. We’ll now revisit the key learning points
    from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how AWS API permissions can be assigned to EC2
    instances (worker nodes) and Pods using instance profiles and IMDS. We also noted
    that by default, EKS Pods inherit the permissions assigned to the worker nodes
    they run on, and how this may not be a good thing, as we are not observing a *least-privilege*
    model since many Pods may not need any AWS API access.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how IMDSv2 can be used to reduce the use of worker permission and
    should be used with IRSA to limit the worker node permission inheritance. We then
    worked through how to configure and use IRSA from the command line and how IaC
    tools such as `eksctl` can simplify the process significantly. Finally, we looked
    at how to do some basic troubleshooting of AWS IAM permission issues, working
    backward from the Kubernetes SA.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can use AWS load balancers to make
    our Kubernetes services more resilient and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding the EC2 metadata service: [https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'EKS updates to support IMDSv2: [https://aws.amazon.com/about-aws/whats-new/2020/08/amazon-eks-supports-ec2-instance-metadata-service-v2/](https://aws.amazon.com/about-aws/whats-new/2020/08/amazon-eks-supports-ec2-instance-metadata-service-v2/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Troubleshooting IRSA errors: [https://aws.amazon.com/premiumsupport/knowledge-center/eks-troubleshoot-IRSA-errors/](https://aws.amazon.com/premiumsupport/knowledge-center/eks-troubleshoot-IRSA-errors/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
