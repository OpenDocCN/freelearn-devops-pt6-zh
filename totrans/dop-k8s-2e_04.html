<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Managing Stateful Workloads</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><span class="ChapterrefPACKT"><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="koboSpan" id="kobo.3.1">Chapter 3</span></a><span class="koboSpan" id="kobo.4.1">,</span></span> <em><span class="koboSpan" id="kobo.5.1">Getting Started with Kubernetes,</span></em><span class="koboSpan" id="kobo.6.1"> we introduced the basic functions of Kubernetes. </span><span class="koboSpan" id="kobo.6.2">Once you start to deploy containers with Kubernetes, you'll need to consider the application's data life cycle and CPU/memory resource management.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will discuss the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">How a container behaves with volumes</span></li>
<li><span class="koboSpan" id="kobo.9.1">Introducing Kubernetes' volume functionalities</span></li>
<li><span class="koboSpan" id="kobo.10.1">Best practices and pitfalls of Kubernetes' persistent volume</span></li>
<li><span class="koboSpan" id="kobo.11.1">Submitting a short-lived application as a Kubernetes Job</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes volume management</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes and Docker use a local disk by default. </span><span class="koboSpan" id="kobo.2.2">The Docker application may store and load any data onto the disk, for example, log data, temporary files, and application data. </span><span class="koboSpan" id="kobo.2.3">As long as the host has enough space and the application has the necessary permission, the data will exist as long as a container exists. </span><span class="koboSpan" id="kobo.2.4">In other words, when a container terminates, exits, crashes, or is reassigned to another host, the data will be lost.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Container volume life cycle</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In order to understand Kubernetes' volume management, you'll need to understand the Docker volume life cycle. </span><span class="koboSpan" id="kobo.2.2">The following example is how Docker behaves with a volume when a container restarts:</span></p>
<pre><strong><span class="koboSpan" id="kobo.3.1">//run CentOS Container</span><br/><span class="koboSpan" id="kobo.4.1">$ docker run -it centos</span><br/><span class="koboSpan" id="kobo.5.1"># ls</span><br/><span class="koboSpan" id="kobo.6.1">anaconda-post.log  dev  home  lib64       media  opt   root  sbin  sys  usr</span><br/><span class="koboSpan" id="kobo.7.1">bin                etc  lib   lost+found  mnt    proc  run   srv   tmp  var
</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.8.1">
//create one file (/I_WAS_HERE) at root directory</span><br/><span class="koboSpan" id="kobo.9.1"># touch /I_WAS_HERE</span><br/><span class="koboSpan" id="kobo.10.1"># ls /</span><br/><span class="koboSpan" id="kobo.11.1">I_WAS_HERE         bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  </span><br/><span class="koboSpan" id="kobo.12.1">var</span><br/><span class="koboSpan" id="kobo.13.1">anaconda-post.log  dev  home  lib64  media       opt  root  sbin  sys  usr</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">

//Exit container</span><br/><span class="koboSpan" id="kobo.15.1"># exit</span><br/><span class="koboSpan" id="kobo.16.1">exit</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.17.1">//re-run CentOS Container</span><br/><span class="koboSpan" id="kobo.18.1"># docker run -it centos</span></strong><br/><strong>
<br/><span class="koboSpan" id="kobo.19.1">//previous file (/I_WAS_HERE) was disappeared</span><br/><span class="koboSpan" id="kobo.20.1"># ls /</span><br/><span class="koboSpan" id="kobo.21.1">anaconda-post.log  dev  home  lib64       media  opt   root  sbin  sys  usr</span><br/></strong><strong><span class="koboSpan" id="kobo.22.1">bin                etc  lib   lost+found  mnt    proc  run   srv   tmp  var </span></strong> </pre>
<p><span class="koboSpan" id="kobo.23.1">In Kubernetes, you also need to take care of pod restart. </span><span class="koboSpan" id="kobo.23.2">In the case of a resource shortage, Kubernetes may stop a container and then restart a container on the same or another Kubernetes node.</span></p>
<p><span class="koboSpan" id="kobo.24.1">The following example shows how Kubernetes behaves when there is a resource shortage. </span><span class="koboSpan" id="kobo.24.2">One pod is killed and restarted when an out of memory error is received:</span></p>
<pre><strong><span class="koboSpan" id="kobo.25.1">//there are 2 pod on the same Node</span><br/><span class="koboSpan" id="kobo.26.1">$ kubectl get pods</span><br/><span class="koboSpan" id="kobo.27.1">NAME                          READY     STATUS    RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.28.1">Besteffort                    1/1       Running   0          1h</span><br/><span class="koboSpan" id="kobo.29.1">guaranteed                    1/1       Running   0          1h</span><br/></strong><br/><strong><span class="koboSpan" id="kobo.30.1">//when application consumes a lot of memory, one Pod has been killed</span><br/><span class="koboSpan" id="kobo.31.1">$ kubectl get pods</span><br/><span class="koboSpan" id="kobo.32.1">NAME                          READY     STATUS    RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.33.1">Besteffort                    0/1       Error     0          1h</span><br/><span class="koboSpan" id="kobo.34.1">guaranteed                    1/1       Running   0          1h</span></strong><br/><strong><br/><span class="koboSpan" id="kobo.35.1">//clashed Pod is restarting</span><br/><span class="koboSpan" id="kobo.36.1">$ kubectl get pods</span><br/><span class="koboSpan" id="kobo.37.1">NAME                          READY     STATUS             RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.38.1">Besteffort                    0/1       CrashLoopBackOff   0          1h</span><br/><span class="koboSpan" id="kobo.39.1">guaranteed                    1/1       Running            0          1h
</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.40.1">//few moment later, Pod has been restarted 
</span><br/><span class="koboSpan" id="kobo.41.1">$ kubectl get pods</span><br/><span class="koboSpan" id="kobo.42.1">NAME                          READY     STATUS    RESTARTS   AGE</span><br/><span class="koboSpan" id="kobo.43.1">Besteffort                    1/1       Running   1          1h</span><br/><span class="koboSpan" id="kobo.44.1">guaranteed                    1/1       Running   0          1h</span><br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Sharing volume between containers within a pod</span></h1>
                </header>
            
            <article>
                
<p><a href="a5cf080a-372a-406e-bb48-019af313c676.xhtml"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.2.1">Chapter 3</span></span></a><span class="koboSpan" id="kobo.3.1">, </span><em><span class="koboSpan" id="kobo.4.1">Getting Started with Kubernetes,</span></em><span class="koboSpan" id="kobo.5.1"> stated that multiple containers within the same Kubernetes pod can share the same pod IP address, network port, and IPC. </span><span class="koboSpan" id="kobo.5.2">Therefore, applications can communicate with each other through a localhost network. </span><span class="koboSpan" id="kobo.5.3">However, the filesystem is segregated.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The following diagram shows that </span><strong><span class="koboSpan" id="kobo.7.1">Tomcat</span></strong><span class="koboSpan" id="kobo.8.1"> and </span><strong><span class="koboSpan" id="kobo.9.1">nginx</span></strong><span class="koboSpan" id="kobo.10.1"> are in the same pod. </span><span class="koboSpan" id="kobo.10.2">Those applications can communicate with each other via localhost. </span><span class="koboSpan" id="kobo.10.3">However, they can't access each other's </span><kbd><span class="koboSpan" id="kobo.11.1">config</span></kbd><span class="koboSpan" id="kobo.12.1"> files:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img src="assets/495d3ce3-fbe2-4547-8a35-dec6534ab5d7.png" style="width:24.17em;height:12.25em;"/></span></div>
<p><span class="koboSpan" id="kobo.14.1">Some applications won't affect these scenarios and behavior, but some applications may have some use cases that require them to use a shared directory or file. </span><span class="koboSpan" id="kobo.14.2">Consequently, developers and Kubernetes administrators need to be aware of the different types of stateless and stateful applications.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Stateless and stateful applications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Stateless applications don't need to preserve the application or user data on the disk volume. </span><span class="koboSpan" id="kobo.2.2">Although stateless applications may write the data to the filesystem while a container exists, it is not important in terms of the application's life cycle.</span></p>
<p><span class="koboSpan" id="kobo.3.1">For example, the </span><kbd><span class="koboSpan" id="kobo.4.1">tomcat</span></kbd><span class="koboSpan" id="kobo.5.1"> container runs some web applications. </span><span class="koboSpan" id="kobo.5.2">It also writes an application log under </span><kbd><span class="koboSpan" id="kobo.6.1">/usr/local/tomcat/logs/</span></kbd><span class="koboSpan" id="kobo.7.1">, but it won't be affected if it loses a </span><kbd><span class="koboSpan" id="kobo.8.1">log</span></kbd><span class="koboSpan" id="kobo.9.1"> file.</span></p>
<p><span class="koboSpan" id="kobo.10.1">But what if you need to persist an application log for analysis or auditing? </span><span class="koboSpan" id="kobo.10.2">In this scenario, Tomcat can still be stateless but share the </span><kbd><span class="koboSpan" id="kobo.11.1">/usr/local/tomcat/logs</span></kbd><span class="koboSpan" id="kobo.12.1"> volume with another container such as Logstash (</span><a href="https://www.elastic.co/products/logstash" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.13.1">https://www.elastic.co/products/logstash</span></span></a><span class="koboSpan" id="kobo.14.1">). </span><span class="koboSpan" id="kobo.14.2">Logstash will then send a log to the chosen analytic store, such as Elasticsearch (</span><a href="https://www.elastic.co/products/elasticsearch" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.15.1">https://www.elastic.co/products/elasticsearch</span></span></a><span class="koboSpan" id="kobo.16.1">).</span></p>
<p><span class="koboSpan" id="kobo.17.1">In this case, the </span><kbd><span class="koboSpan" id="kobo.18.1">tomcat</span></kbd><span class="koboSpan" id="kobo.19.1"> container and </span><kbd><span class="koboSpan" id="kobo.20.1">logstash</span></kbd><span class="koboSpan" id="kobo.21.1"> container must be in the same Kubernetes pod and share the </span><kbd><span class="koboSpan" id="kobo.22.1">/usr/local/tomcat/logs</span></kbd><span class="koboSpan" id="kobo.23.1"> volume, as follows:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.24.1"><img src="assets/e69e5d06-bcea-44d3-9c22-a784dddfa08c.png" style="width:24.67em;height:17.25em;"/></span></div>
<p><span class="koboSpan" id="kobo.25.1">The preceding diagram shows how Tomcat and Logstash can share the </span><kbd><span class="koboSpan" id="kobo.26.1">log</span></kbd><span class="koboSpan" id="kobo.27.1"> file using the Kubernetes </span><kbd><span class="koboSpan" id="kobo.28.1">emptyDir</span></kbd><span class="koboSpan" id="kobo.29.1"> volume (</span><a href="https://kubernetes.io/docs/concepts/storage/volumes/"><span class="URLPACKT"><span class="koboSpan" id="kobo.30.1">https://kubernetes.io/docs/concepts/storage/volumes/#emptydir</span></span></a><span class="koboSpan" id="kobo.31.1">).</span></p>
<p><span class="koboSpan" id="kobo.32.1">Tomcat and Logstash didn't use the network via localhost, but they did share the filesystem between </span><kbd><span class="koboSpan" id="kobo.33.1">/usr/local/tomcat/logs</span></kbd><span class="koboSpan" id="kobo.34.1"> from the Tomcat container and </span><kbd><span class="koboSpan" id="kobo.35.1">/mnt</span></kbd><span class="koboSpan" id="kobo.36.1"> from the </span><kbd><span class="koboSpan" id="kobo.37.1">logstash</span></kbd><span class="koboSpan" id="kobo.38.1"> container, through Kubernetes' </span><kbd><span class="koboSpan" id="kobo.39.1">emptyDir</span></kbd><span class="koboSpan" id="kobo.40.1"> volume:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.41.1">$ cat tomcat-logstash.yaml</span><span class="Apple-converted-space"> </span><span class="Apple-converted-space"><br/></span></span><span><span class="koboSpan" id="kobo.42.1">apiVersion: apps/v1</span><br/></span><span><span class="koboSpan" id="kobo.43.1">kind: Deployment</span><br/></span><span><span class="koboSpan" id="kobo.44.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.45.1">name: tomcat</span><br/></span><span><span class="koboSpan" id="kobo.46.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.47.1">replicas: 1</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.48.1">selector:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.49.1">matchLabels:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.50.1">run: tomcat</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.51.1">template:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.52.1">metadata:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.53.1">labels:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.54.1">run: tomcat</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.55.1">spec:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.56.1">containers:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.57.1">- image: tomcat</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.58.1">name: tomcat</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.59.1">ports:</span><br/></span><span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.60.1">- containerPort: 8080</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.61.1">env:</span><br/></span><span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.62.1">- name: UMASK</span><br/></span><span><span class="Apple-converted-space">              </span><span class="koboSpan" id="kobo.63.1">value: "0022"</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.64.1">volumeMounts:</span><br/></span><span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.65.1">- mountPath: /usr/local/tomcat/logs</span><br/></span><span><span class="Apple-converted-space">              </span><span class="koboSpan" id="kobo.66.1">name: tomcat-log</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.67.1">- image: logstash</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.68.1">name: logstash</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.69.1">args: ["-e input { file { path =&gt; \"/mnt/localhost_access_log.*\" } } output { stdout { codec =&gt; rubydebug } elasticsearch { hosts =&gt; [\"http://elasticsearch-svc.default.svc.cluster.local:9200\"] } }"]</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.70.1">volumeMounts:</span><br/></span><span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.71.1">- mountPath: /mnt</span><br/></span><span><span class="Apple-converted-space">              </span><span class="koboSpan" id="kobo.72.1">name: tomcat-log</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.73.1">volumes:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.74.1">- name: tomcat-log</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.75.1">emptyDir: {}</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.76.1">Let's create </span><kbd><span class="koboSpan" id="kobo.77.1">tomcat</span></kbd><span class="koboSpan" id="kobo.78.1"> and </span><kbd><span class="koboSpan" id="kobo.79.1">logstash</span></kbd><span class="koboSpan" id="kobo.80.1"> pod, and then see whether Logstash can see the Tomcat application log under </span><kbd><span class="koboSpan" id="kobo.81.1">/mnt</span></kbd><span class="koboSpan" id="kobo.82.1">:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.83.1">//create Pod</span><br/><span class="koboSpan" id="kobo.84.1">$ kubectl create -f tomcat-logstash.yaml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.85.1">deployment.apps/tomcat created</span><br/></span><span><br/><br/><span class="koboSpan" id="kobo.86.1">//check Pod name</span><br/><span class="koboSpan" id="kobo.87.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.88.1">NAME</span><span class="Apple-converted-space">                      </span><span class="koboSpan" id="kobo.89.1">READY </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.90.1">STATUS</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.91.1">RESTARTS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.92.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.93.1">tomcat-7d99999565-6pm64 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.94.1">2/2 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.95.1">Running </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.96.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.97.1">1m</span><br/></span><span><br/><br/><span class="koboSpan" id="kobo.98.1">//connect to logstash container to see /mnt directory</span><br/><span class="koboSpan" id="kobo.99.1">$ </span></span><span class="koboSpan" id="kobo.100.1">kubectl exec -it tomcat-7d99999565-6pm64 -c logstash</span><span><span class="koboSpan" id="kobo.101.1"> /bin/bash</span><br/></span><span><span class="koboSpan" id="kobo.102.1">root@tomcat-7d99999565-6pm64:/# ls /mnt</span><br/></span><span><span class="koboSpan" id="kobo.103.1">catalina.2018-09-20.log</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.104.1">localhost.2018-09-20.log</span><span class="Apple-tab-span"> </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.105.1">manager.2018-09-20.log</span><br/></span><span><span class="koboSpan" id="kobo.106.1">host-manager.2018-09-20.log</span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.107.1">localhost_access_log.2018-09-20.txt</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.108.1">In this scenario, Elasticsearch must be stateful </span><span><span class="koboSpan" id="kobo.109.1">in the final destination</span></span><span><span class="koboSpan" id="kobo.110.1">, meaning that it uses a persistent volume. </span><span class="koboSpan" id="kobo.110.2">The Elasticsearch container must preserve the data even if the container is restarted. </span><span class="koboSpan" id="kobo.110.3">In addition, you do not</span></span><span class="koboSpan" id="kobo.111.1"> need </span><span><span class="koboSpan" id="kobo.112.1">to configure the Elasticsearch container within the same pod as</span></span><span class="koboSpan" id="kobo.113.1"> Tomcat/Logstash</span><span><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">Because Elasticsearch</span></span><span class="koboSpan" id="kobo.115.1"> should </span><span><span class="koboSpan" id="kobo.116.1">be a centralized log datastore, it can be separated from the Tomcat/Logstash pod and scaled independently.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Once you determine that your application needs a persistent volume, there are some different types of volumes and different ways to manage persistent volumes to look at.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kubernetes' persistent volume and dynamic provisioning</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Kubernetes supports a variety of persistent volumes, for example, public cloud storage such as AWS EBS and Google persistent disks. </span><span class="koboSpan" id="kobo.2.2">It also supports network (distributed) filesystems such as NFS, GlusterFS, and Ceph. </span><span class="koboSpan" id="kobo.2.3">In addition, it can also support a block device such as iSCSI and Fibre Channel. </span><span class="koboSpan" id="kobo.2.4">Based on </span><span><span class="koboSpan" id="kobo.3.1">the </span></span><span class="koboSpan" id="kobo.4.1">environment and infrastructure, a Kubernetes administrator can choose the best matching types of persistent volume.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The following example is using a GCP persistent disk as a persistent volume. </span><span class="koboSpan" id="kobo.5.2">The first step is to create a GCP persistent disk and name it </span><kbd><span class="koboSpan" id="kobo.6.1">gce-pd-1</span></kbd><span class="koboSpan" id="kobo.7.1">.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.8.1">If you use AWS EBS, Google persistent disk, or Azure disk storage, the Kubernetes node must be in the same cloud platform. In addition, Kubernetes has a limit on maximum volumes per node. </span><span class="koboSpan" id="kobo.8.2">Please look at </span><span><span class="koboSpan" id="kobo.9.1">the </span></span><span class="koboSpan" id="kobo.10.1">Kubernetes documentation at </span><a href="https://kubernetes.io/docs/concepts/storage/storage-limits/"><span class="koboSpan" id="kobo.11.1">https://kubernetes.io/docs/concepts/storage/storage-limits/</span></a><span class="koboSpan" id="kobo.12.1">. </span></div>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img src="assets/8c4fd27c-12fe-4a90-94c8-a7f3290615f3.png"/></span></div>
<p><span class="koboSpan" id="kobo.14.1">Then, specify the name </span><kbd><span class="koboSpan" id="kobo.15.1">gce-pd-1</span></kbd><span class="koboSpan" id="kobo.16.1"> in the </span><kbd><span class="koboSpan" id="kobo.17.1">Deployment</span></kbd><span class="koboSpan" id="kobo.18.1"> definition:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.19.1">$ cat tomcat-pv.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.20.1">apiVersion: apps/v1</span><br/></span><span><span class="koboSpan" id="kobo.21.1">kind: Deployment</span><br/></span><span><span class="koboSpan" id="kobo.22.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.23.1">name: tomcat</span><br/></span><span><span class="koboSpan" id="kobo.24.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.25.1">replicas: 1</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.26.1">selector:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.27.1">matchLabels:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.28.1">run: tomcat</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.29.1">template:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.30.1">metadata:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.31.1">labels:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.32.1">run: tomcat</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.33.1">spec:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.34.1">containers:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.35.1">- image: tomcat</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.36.1">name: tomcat</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.37.1">ports:</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.38.1">- containerPort: 8080</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.39.1">volumeMounts:</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.40.1">- mountPath: /usr/local/tomcat/logs</span><br/></span></strong><span><strong><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.41.1">name: tomcat-log</span></strong><br/></span><strong><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.42.1">volumes:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.43.1">- name: tomcat-log</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.44.1">gcePersistentDisk:</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.45.1">pdName: gce-pd-1</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.46.1">fsType: ext4</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.47.1">This will mount the persistent disk from </span><span><span class="koboSpan" id="kobo.48.1">the </span></span><span class="koboSpan" id="kobo.49.1">GCE persistent disk to </span><kbd><span class="koboSpan" id="kobo.50.1">/usr/local/tomcat/logs</span></kbd><span class="koboSpan" id="kobo.51.1">, which can persist Tomcat application logs.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Abstracting the volume layer with a persistent volume claim</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Directly specifying a persistent volume in a configuration file makes a tight couple with a particular infrastructure. </span><span class="koboSpan" id="kobo.2.2">For the preceding example (</span><kbd><span class="koboSpan" id="kobo.3.1">tomcat-log</span></kbd><span class="koboSpan" id="kobo.4.1"> volume), </span><kbd><span class="koboSpan" id="kobo.5.1">pdName</span></kbd><span class="koboSpan" id="kobo.6.1"> is </span><kbd><span class="koboSpan" id="kobo.7.1">gce-pd-1</span></kbd><span class="koboSpan" id="kobo.8.1"> and Volume type is </span><kbd><span class="koboSpan" id="kobo.9.1">gcePersistentDisk</span></kbd><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">From a container management point of view, </span><span><span class="koboSpan" id="kobo.11.1">the </span></span><span class="koboSpan" id="kobo.12.1">pod definition shouldn't be locked into the specific environment because the infrastructure could be different based on the environment. </span><span class="koboSpan" id="kobo.12.2">The ideal pod definition should be flexible or abstract the actual infrastructure and specify only volume name and mount point.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Consequently, Kubernetes provides an abstraction layer that associates the pod with the persistent volume, which is called the </span><strong><span class="koboSpan" id="kobo.14.1">Persistent Volume Claim</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong><span class="koboSpan" id="kobo.16.1">PVC</span></strong><span class="koboSpan" id="kobo.17.1">). </span><span class="koboSpan" id="kobo.17.2">This allows us to decouple from the infrastructure. </span><span class="koboSpan" id="kobo.17.3">The Kubernetes administrator just needs to pre-allocate the size of the persistent volume in advance. </span><span class="koboSpan" id="kobo.17.4">Then Kubernetes will bind the persistent volume and the PVC as follows:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"><img src="assets/fe65323a-e6db-489a-b13f-98f0f3c2be7c.png" style="width:27.25em;height:16.08em;"/></span></div>
<p><span class="koboSpan" id="kobo.19.1">The following example is a definition of a pod that uses a PVC; let's reuse the previous example (</span><kbd><span class="koboSpan" id="kobo.20.1">gce-pd-1</span></kbd><span class="koboSpan" id="kobo.21.1">) to register with Kubernetes first:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.22.1">$ cat pv-gce-pd-1.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.23.1">apiVersion: "v1"</span><br/></span><span><span class="koboSpan" id="kobo.24.1">kind: "PersistentVolume"</span><br/></span><span><span class="koboSpan" id="kobo.25.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.26.1">name: pv-1</span><br/></span><span><span class="koboSpan" id="kobo.27.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.28.1">storageClassName: "my-10g-pv-1"</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.29.1">capacity:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.30.1">storage: "10Gi"</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.31.1">accessModes:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.32.1">- "ReadWriteOnce"</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.33.1">gcePersistentDisk:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.34.1">fsType: "ext4"</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.35.1">pdName: "gce-pd-1"</span><br/></span><span><br/><span class="koboSpan" id="kobo.36.1">$ kubectl create -f pv-gce-pd-1.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.37.1">persistentvolume/pv-1 created</span><br/></span><span><br/><span class="koboSpan" id="kobo.38.1">$ kubectl get pv</span><br/></span><span><span class="koboSpan" id="kobo.39.1">NAME</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.40.1">CAPACITY </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.41.1">ACCESS MODES </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.42.1">RECLAIM POLICY </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.43.1">STATUS</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.44.1">CLAIM </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.45.1">STORAGECLASS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.46.1">REASON</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.47.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.48.1">pv-1</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.49.1">10Gi </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.50.1">RWO</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.51.1">Retain </span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.52.1">Available </span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.53.1">my-10g-pv-1</span><span class="Apple-converted-space">              </span><span class="koboSpan" id="kobo.54.1">11s</span></span><span><span class="Apple-converted-space"> </span></span></strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign">
<p><span class="koboSpan" id="kobo.55.1">Note that we assign </span><kbd><span class="koboSpan" id="kobo.56.1">storageClassName</span></kbd><span class="koboSpan" id="kobo.57.1"> as </span><kbd><span class="koboSpan" id="kobo.58.1">my-10g-pv-1</span></kbd><span class="koboSpan" id="kobo.59.1">, as an identifier that the PVC can bind to by specifying the same name.</span></p>
<p><span><span class="koboSpan" id="kobo.60.1">Next, we create a PVC that associates</span></span><span class="koboSpan" id="kobo.61.1"> with the </span><span><span class="koboSpan" id="kobo.62.1">persistent volume (</span></span><kbd><span class="koboSpan" id="kobo.63.1">pv-1</span></kbd><span><span class="koboSpan" id="kobo.64.1">).</span></span></p>
</div>
<div class="packt_tip"><span class="koboSpan" id="kobo.65.1">The </span><kbd><span class="koboSpan" id="kobo.66.1">storageClassName</span></kbd><span class="koboSpan" id="kobo.67.1"> parameter </span><span><span class="koboSpan" id="kobo.68.1">lets Kubernetes use static provisioning. </span><span class="koboSpan" id="kobo.68.2">This is because some Kubernetes environments, </span></span><span class="koboSpan" id="kobo.69.1">such </span><span><span class="koboSpan" id="kobo.70.1">as</span></span> <strong><span class="koboSpan" id="kobo.71.1">Google Container Engine</span></strong> <span><span class="koboSpan" id="kobo.72.1">(</span></span><strong><span class="koboSpan" id="kobo.73.1">GKE</span></strong><span><span class="koboSpan" id="kobo.74.1">), are already set up with dynamic provisioning. </span><span class="koboSpan" id="kobo.74.2">If we don't specify</span></span> <kbd><span class="koboSpan" id="kobo.75.1">storageClassName</span></kbd><span><span class="koboSpan" id="kobo.76.1">, Kubernetes will allocate a new</span></span> <kbd><span class="koboSpan" id="kobo.77.1">PersistentVolume</span></kbd><span><span class="koboSpan" id="kobo.78.1"> and then bind to </span></span><kbd><span class="koboSpan" id="kobo.79.1">PersistentVolumeClaim</span></kbd><span><span class="koboSpan" id="kobo.80.1">. </span></span></div>
<pre><strong><span><span class="koboSpan" id="kobo.81.1">//create PVC specify storageClassName as "my-10g-pv-1"</span><br/><span class="koboSpan" id="kobo.82.1">$ cat pvc-1.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.83.1">apiVersion: v1</span><br/></span><span><span class="koboSpan" id="kobo.84.1">kind: PersistentVolumeClaim</span><br/></span><span><span class="koboSpan" id="kobo.85.1">metadata:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.86.1">name: pvc-1</span><br/></span><span><span class="koboSpan" id="kobo.87.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.88.1">storageClassName: "my-10g-pv-1"</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.89.1">accessModes:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.90.1">- ReadWriteOnce</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.91.1">resources:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.92.1">requests:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.93.1">storage: 10Gi</span><br/><br/></span><span><span class="koboSpan" id="kobo.94.1">$ kubectl create -f pvc-1.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.95.1">persistentvolumeclaim/pvc-1 created</span><br/><br/><br/><span class="koboSpan" id="kobo.96.1">//check PVC status is "Bound"</span><br/></span><span><span class="koboSpan" id="kobo.97.1">$ kubectl get pvc</span><br/></span><span><span class="koboSpan" id="kobo.98.1">NAME</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.99.1">STATUS</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.100.1">VOLUME</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.101.1">CAPACITY </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.102.1">ACCESS MODES </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.103.1">STORAGECLASS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.104.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.105.1">pvc-1 </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.106.1">Bound </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.107.1">pv-1</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.108.1">10Gi </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.109.1">RWO</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.110.1">my-10g-pv-1</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.111.1">7s</span><br/><br/><br/><span class="koboSpan" id="kobo.112.1">//check PV status is also "Bound"</span><br/></span><span><span class="koboSpan" id="kobo.113.1">$ kubectl get pv</span><br/></span><span><span class="koboSpan" id="kobo.114.1">NAME</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.115.1">CAPACITY </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.116.1">ACCESS MODES </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.117.1">RECLAIM POLICY </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.118.1">STATUS</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.119.1">CLAIM </span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.120.1">STORAGECLASS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.121.1">REASON</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.122.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.123.1">pv-1</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.124.1">10Gi </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.125.1">RWO</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.126.1">Retain </span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.127.1">Bound </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.128.1">default/pvc-1 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.129.1">my-10g-pv-1</span><span class="Apple-converted-space">              </span><span class="koboSpan" id="kobo.130.1">2m</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.131.1">Now the </span><kbd><span class="koboSpan" id="kobo.132.1">tomcat</span></kbd><span class="koboSpan" id="kobo.133.1"> setting has been decoupled from the GCE persistent volume, and bound to the abstracted volume, </span><kbd><span class="koboSpan" id="kobo.134.1">pvc-1</span></kbd><span class="koboSpan" id="kobo.135.1">:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.136.1">$ cat tomcat-pvc.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.137.1">apiVersion: apps/v1</span><br/></span><span><span class="koboSpan" id="kobo.138.1">kind: Deployment</span><br/></span><span><span class="koboSpan" id="kobo.139.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.140.1">name: tomcat</span><br/></span><span><span class="koboSpan" id="kobo.141.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.142.1">replicas: 1</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.143.1">selector:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.144.1">matchLabels:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.145.1">run: tomcat</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.146.1">template:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.147.1">metadata:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.148.1">labels:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.149.1">run: tomcat</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.150.1">spec:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.151.1">containers:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.152.1">- image: tomcat</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.153.1">name: tomcat</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.154.1">ports:</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.155.1">- containerPort: 8080</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.156.1">volumeMounts:</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.157.1">- mountPath: /usr/local/tomcat/logs</span><br/></span><span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.158.1">name: tomcat-log</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.159.1">volumes:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.160.1">- name: tomcat-log</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.161.1">persistentVolumeClaim:</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.162.1">claimName: "pvc-1"</span></span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dynamic provisioning and StorageClass</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">PVC a degree of flexibility for persistent volume management. </span><span class="koboSpan" id="kobo.2.2">However, pre-allocating some persistent volume pools might not be cost-efficient, especially in a public cloud.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Kubernetes also assists in this kind of situation by supporting dynamic provisioning for persistent volumes. </span><span class="koboSpan" id="kobo.3.2">The Kubernetes administrator defines the provisioner of the persistent volume, which is called </span><kbd><span class="koboSpan" id="kobo.4.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Then, the </span><span><span class="koboSpan" id="kobo.6.1">PVC </span></span><span class="koboSpan" id="kobo.7.1">asks </span><kbd><span class="koboSpan" id="kobo.8.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.9.1"> to dynamically allocate a persistent volume, and then associates it with the PVC as follows:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1"><img src="assets/bc67e1e5-9606-478f-867d-b539c1ae2f16.png" style="width:25.83em;height:19.83em;"/></span></div>
<p><span class="koboSpan" id="kobo.11.1">In the following example, AWS EBS is used as the </span><kbd><span class="koboSpan" id="kobo.12.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">When creating the PVC, the </span><kbd><span class="koboSpan" id="kobo.14.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.15.1"> dynamically creates an EBS then registers it as </span><span><strong><span class="koboSpan" id="kobo.16.1">Persistent Volume</span></strong><span class="koboSpan" id="kobo.17.1"> </span></span><span class="koboSpan" id="kobo.18.1">(</span><strong><span><span class="koboSpan" id="kobo.19.1">PV</span></span></strong><span class="koboSpan" id="kobo.20.1">), and then attaches it to the PVC:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.21.1">$ cat storageclass-aws.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.22.1">kind: StorageClass</span><br/></span><span><span class="koboSpan" id="kobo.23.1">apiVersion: storage.k8s.io/v1</span><br/></span><span><span class="koboSpan" id="kobo.24.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.25.1">name: aws-sc</span><br/></span><span><span class="koboSpan" id="kobo.26.1">provisioner: kubernetes.io/aws-ebs</span><br/></span><span><span class="koboSpan" id="kobo.27.1">parameters:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.28.1">type: gp2</span><br/><br/><br/><span class="koboSpan" id="kobo.29.1">$ kubectl create -f </span></span><span><span class="koboSpan" id="kobo.30.1">storageclass-aws.yml</span><br/><span class="koboSpan" id="kobo.31.1">storageclass "aws-sc" created</span><br/><br/><br/><span class="koboSpan" id="kobo.32.1">$ kubectl get storageclass</span><br/><span class="koboSpan" id="kobo.33.1">NAME.     </span><span class="koboSpan" id="kobo.33.2">TYPE</span><br/><span class="koboSpan" id="kobo.34.1">aws-sc.   </span><span class="koboSpan" id="kobo.34.2">kubernetes.io/aws-ebs</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.35.1">Once </span><kbd><span class="koboSpan" id="kobo.36.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.37.1"> has been successfully created, then, create a PVC without PV, but specify the </span><kbd><span class="koboSpan" id="kobo.38.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.39.1"> name. </span><span class="koboSpan" id="kobo.39.2">In this example, this would be </span><kbd><span class="koboSpan" id="kobo.40.1">aws-sc</span></kbd><span class="koboSpan" id="kobo.41.1">, as follows</span><span><span class="koboSpan" id="kobo.42.1">:</span></span></p>
<pre><strong><span><span class="koboSpan" id="kobo.43.1">$ cat pvc-aws.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.44.1">apiVersion: v1</span><br/></span><span><span class="koboSpan" id="kobo.45.1">kind: PersistentVolumeClaim</span><br/></span><span><span class="koboSpan" id="kobo.46.1">metadata:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.47.1">name: pvc-aws-1</span><br/></span><span><span class="koboSpan" id="kobo.48.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.49.1">storageClassName: "aws-sc"</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.50.1">accessModes:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.51.1">- ReadWriteOnce</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.52.1">resources:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.53.1">requests:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.54.1">storage: 10Gi</span><br/><br/><br/></span><span><span class="koboSpan" id="kobo.55.1">$ kubectl create -f pvc-aws.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.56.1">persistentvolumeclaim/pvc-aws-1 created</span><br/></span><span><br/><br/><span class="koboSpan" id="kobo.57.1">$ kubectl get pv</span><br/></span><span><span class="koboSpan" id="kobo.58.1">NAME </span><span class="Apple-converted-space">                                      </span><span class="koboSpan" id="kobo.59.1">CAPACITY </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.60.1">ACCESS MODES </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.61.1">RECLAIM POLICY </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.62.1">STATUS</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.63.1">CLAIM </span><span class="Apple-converted-space">              </span><span class="koboSpan" id="kobo.64.1">STORAGECLASS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.65.1">REASON</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.66.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.67.1">pvc-03557eb8-bc8b-11e8-994f-42010a800085 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.68.1">10Gi </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.69.1">RWO</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.70.1">Delete </span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.71.1">Bound </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.72.1">default/pvc-aws-1 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.73.1">aws-sc </span><span class="Apple-converted-space">                  </span><span class="koboSpan" id="kobo.74.1">1s</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.75.1">The following screenshot shows the EBS after submitting to StorageClass to create a PVC. </span><span class="koboSpan" id="kobo.75.2">AWS console shows a new EBS which is created by StorageClass:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.76.1"><img src="assets/3cd3cac5-a5bd-4a17-901c-ad5687be8449.png"/></span></div>
<p><span class="koboSpan" id="kobo.77.1">Note that managed Kubernetes services such as Amazon EKS (</span><a href="https://aws.amazon.com/eks/"><span class="koboSpan" id="kobo.78.1">https://aws.amazon.com/eks/</span></a><span class="koboSpan" id="kobo.79.1">), Google Kubernetes Engine (</span><a href="https://cloud.google.com/container-engine/" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.80.1">https://cloud.google.com/container-engine/</span></span></a><span class="koboSpan" id="kobo.81.1">), and Azure Kubernetes Service (</span><a href="https://azure.microsoft.com/en-us/services/kubernetes-service/"><span class="koboSpan" id="kobo.82.1">https://azure.microsoft.com/en-us/services/kubernetes-service/</span></a><span class="koboSpan" id="kobo.83.1">) create </span><kbd><span class="koboSpan" id="kobo.84.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.85.1"> by default. </span><span class="koboSpan" id="kobo.85.2">For example, Google Kubernetes Engine sets up a default storage class as a Google Cloud persistent disk. </span><span class="koboSpan" id="kobo.85.3">For more information, please refer to </span><span class="ChapterrefPACKT"><a href="f55d3fa8-e791-4473-83ba-ed8c4f848a90.xhtml"><span class="koboSpan" id="kobo.86.1">Chapter 10</span></a><span class="koboSpan" id="kobo.87.1">,</span></span> <em><span class="koboSpan" id="kobo.88.1">Kubernetes on AWS</span></em><span class="koboSpan" id="kobo.89.1">, </span><a href="d4de05e3-eb24-4e8e-bfd3-e68819b5e66c.xhtml"><span class="koboSpan" id="kobo.90.1">Chapter 11</span></a><em><span class="koboSpan" id="kobo.91.1">, Kubernetes on</span></em><span class="koboSpan" id="kobo.92.1"> </span><em><span class="koboSpan" id="kobo.93.1">GCP</span></em><span class="koboSpan" id="kobo.94.1">,</span><span><span class="koboSpan" id="kobo.95.1"> and </span><a href="89891610-4ca4-4216-9d76-2613d186421c.xhtml"><span class="koboSpan" id="kobo.96.1">Chapter 12</span></a><span class="koboSpan" id="kobo.97.1">, </span><em><span class="koboSpan" id="kobo.98.1">Kubernetes on Azure</span></em></span><span class="koboSpan" id="kobo.99.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.100.1">//default Storage Class on GKE
$ kubectl get sc
NAME                 TYPE
standard (default)   kubernetes.io/gce-pd   </span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problems with ephemeral and persistent volume settings</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You may determine your application as stateless because </span><span><span class="koboSpan" id="kobo.3.1">the </span></span><kbd><span class="koboSpan" id="kobo.4.1">datastore</span></kbd><span class="koboSpan" id="kobo.5.1"> function is handled by another pod or system. </span><span class="koboSpan" id="kobo.5.2">However, there are some pitfalls in that sometimes; applications actually store important files that you aren't aware of. </span><span class="koboSpan" id="kobo.5.3">For example, Grafana (</span><a href="https://grafana.com/grafana" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.6.1">https://grafana.com/grafana</span></span></a><span class="koboSpan" id="kobo.7.1">) connects time series datasources such as Graphite (</span><a href="https://graphiteapp.org" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.8.1">https://graphiteapp.org</span></span></a><span class="koboSpan" id="kobo.9.1">) and InfluxDB (</span><a href="https://www.influxdata.com/time-series-database/" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.10.1">https://www.influxdata.com/time-series-database/</span></span></a><span class="koboSpan" id="kobo.11.1">), so people may misunderstand that Grafana is a stateless application.</span></p>
<p><span class="koboSpan" id="kobo.12.1">Actually, Grafana itself also uses databases to store user, organization, and dashboard metadata. </span><span class="koboSpan" id="kobo.12.2">By default, Grafana uses SQLite3 components and stores the database as </span><kbd><span class="koboSpan" id="kobo.13.1">/var/lib/grafana/grafana.db</span></kbd><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">Therefore, when a container is restarted, the Grafana settings will all </span><span><span class="koboSpan" id="kobo.15.1">be</span></span><span><span class="koboSpan" id="kobo.16.1"> </span></span><span><span class="koboSpan" id="kobo.17.1">reset.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">The following example demonstrates how Grafana behaves with an ephemeral volume:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.19.1">$ cat grafana.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.20.1">apiVersion: apps/v1</span><br/></span><span><span class="koboSpan" id="kobo.21.1">kind: Deployment</span><br/></span><span><span class="koboSpan" id="kobo.22.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.23.1">name: grafana</span><br/></span><span><span class="koboSpan" id="kobo.24.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.25.1">replicas: 1</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.26.1">selector:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.27.1">matchLabels:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.28.1">run: grafana</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.29.1">template:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.30.1">metadata:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.31.1">labels:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.32.1">run: grafana</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.33.1">spec:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.34.1">containers:</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.35.1">- image: grafana/grafana</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.36.1">name: grafana</span><br/></span><span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.37.1">ports:</span><br/></span><span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.38.1">- containerPort: 3000</span><br/></span><span><span class="koboSpan" id="kobo.39.1">---</span><br/></span><span><span class="koboSpan" id="kobo.40.1">apiVersion: v1</span><br/></span><span><span class="koboSpan" id="kobo.41.1">kind: Service</span><br/></span><span><span class="koboSpan" id="kobo.42.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.43.1">name: grafana</span><br/></span><span><span class="koboSpan" id="kobo.44.1">spec:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.45.1">ports:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.46.1">- protocol: TCP</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.47.1">port: 3000</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.48.1">nodePort: 30300</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.49.1">type: NodePort</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.50.1">selector:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.51.1">run: grafana</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.52.1">Next, navigate to the Grafana web console to create the Grafana </span><kbd><span class="koboSpan" id="kobo.53.1">Organizations</span></kbd><span class="koboSpan" id="kobo.54.1"> named </span><kbd><span class="koboSpan" id="kobo.55.1">kubernetes org</span></kbd><span class="koboSpan" id="kobo.56.1">, as follows: </span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.57.1"><img src="assets/b5eb22b7-fce0-4566-8f1a-15bad07ff121.png" style="width:43.83em;height:20.92em;"/></span></div>
<p><span class="koboSpan" id="kobo.58.1">Then, look at the </span><kbd><span class="koboSpan" id="kobo.59.1">Grafana</span></kbd><span class="koboSpan" id="kobo.60.1"> directory. </span><span class="koboSpan" id="kobo.60.2">Here, there is a database file (</span><kbd><span class="koboSpan" id="kobo.61.1">/var/lib/grafana/grafana.db</span></kbd><span class="koboSpan" id="kobo.62.1">) with a timestamp that has been updated after creating a Grafana </span><kbd><span class="koboSpan" id="kobo.63.1">Organizations</span></kbd><span class="koboSpan" id="kobo.64.1">:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.65.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.66.1">NAME</span><span class="Apple-converted-space">                      </span><span class="koboSpan" id="kobo.67.1">READY </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.68.1">STATUS</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.69.1">RESTARTS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.70.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.71.1">grafana-6bf966d7b-7lh89 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.72.1">1/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.73.1">Running </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.74.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.75.1">3m</span><br/></span><span><br/><br/><span class="koboSpan" id="kobo.76.1">//access to Grafana container</span><br/><span class="koboSpan" id="kobo.77.1">$ kubectl exec -it grafana-6bf966d7b-7lh89 /bin/bash</span><br/></span><span><span class="koboSpan" id="kobo.78.1">grafana@grafana-6bf966d7b-7lh89:/$ ls -l /var/lib/grafana/</span><br/></span><span><span class="koboSpan" id="kobo.79.1">total 404</span><br/></span><span><span class="koboSpan" id="kobo.80.1">-rw-r--r-- 1 grafana grafana 401408 Sep 20 03:30 grafana.db</span><br/></span><span><span class="koboSpan" id="kobo.81.1">drwxrwxrwx 2 grafana grafana </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.82.1">4096 Sep</span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.83.1">7 14:59 plugins</span><br/></span><span><span class="koboSpan" id="kobo.84.1">drwx------ 4 grafana grafana </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.85.1">4096 Sep 20 03:30 sessions</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.86.1">When the pod is deleted, the </span><kbd><span class="koboSpan" id="kobo.87.1">Deployment</span></kbd><span class="koboSpan" id="kobo.88.1"> will start a new pod and check whether a Grafana </span><kbd><span class="koboSpan" id="kobo.89.1">Organizations</span></kbd><span class="koboSpan" id="kobo.90.1"> exists or not:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.91.1">grafana@grafana-6bf966d7b-7lh89:/$ exit</span><br/></span><span><span class="koboSpan" id="kobo.92.1">//delete grafana pod</span><br/><span class="koboSpan" id="kobo.93.1">$ kubectl delete pod grafana-6bf966d7b-7lh89</span><br/></span><span><span class="koboSpan" id="kobo.94.1">pod "grafana-6bf966d7b-7lh89" deleted</span><br/></span><span><br/><br/><span class="koboSpan" id="kobo.95.1">//Kubernetes Deployment made a new Pod</span><br/><span class="koboSpan" id="kobo.96.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.97.1">NAME</span><span class="Apple-converted-space">                      </span><span class="koboSpan" id="kobo.98.1">READY </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.99.1">STATUS</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.100.1">RESTARTS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.101.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.102.1">grafana-6bf966d7b-wpdmk </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.103.1">1/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.104.1">Running </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.105.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.106.1">9s</span><br/></span><span><br/><br/><span class="koboSpan" id="kobo.107.1">//contents has been recreated</span><br/><span class="koboSpan" id="kobo.108.1">$ kubectl exec -it grafana-6bf966d7b-wpdmk /bin/bash</span><br/></span><span><span class="koboSpan" id="kobo.109.1">grafana@grafana-6bf966d7b-wpdmk:/$ ls -l /var/lib/grafana</span><br/></span><span><span class="koboSpan" id="kobo.110.1">total 400</span><br/></span><span><span class="koboSpan" id="kobo.111.1">-rw-r--r-- 1 grafana grafana 401408 Sep 20 03:33 grafana.db</span><br/></span><span><span class="koboSpan" id="kobo.112.1">drwxrwxrwx 2 grafana grafana </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.113.1">4096 Sep</span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.114.1">7 14:59 plugins</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.115.1">It looks like the </span><kbd><span class="koboSpan" id="kobo.116.1">sessions</span></kbd><span class="koboSpan" id="kobo.117.1"> directory has disappeared and </span><kbd><span class="koboSpan" id="kobo.118.1">grafana.db</span></kbd><span class="koboSpan" id="kobo.119.1"> has also been recreated by the Docker image again. </span><span class="koboSpan" id="kobo.119.2">If you access the web console, the Grafana </span><kbd><span class="koboSpan" id="kobo.120.1">organization</span></kbd><span class="koboSpan" id="kobo.121.1"> will also disappear:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.122.1"><img src="assets/b0906787-27fb-4d3b-b177-b42955fa24ef.png" style="width:41.33em;height:24.92em;"/></span></div>
<p><span class="koboSpan" id="kobo.123.1">How about just attaching a persistent volume to Grafana? </span><span class="koboSpan" id="kobo.123.2">You'll soon find that mounting a </span><span><span class="koboSpan" id="kobo.124.1">persistent volume</span></span><span class="koboSpan" id="kobo.125.1"> on a pod controlled by a </span><kbd><span class="koboSpan" id="kobo.126.1">Deployment</span></kbd><span class="koboSpan" id="kobo.127.1"> doesn't scale properly as every new pod attempts to mount the same persistent volume. </span><span class="koboSpan" id="kobo.127.2">In most cases, only the first pod can mount the persistent volume. </span><span class="koboSpan" id="kobo.127.3">Other pods will try to mount the volume, and they will give up and freeze </span><span><span class="koboSpan" id="kobo.128.1">if they can't</span></span><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">This happens if the persistent volume is capable of only RWO (read write once; only one pod can write).</span></p>
<p><span class="koboSpan" id="kobo.130.1">In the following example, Grafana uses a persistent volume to mount </span><kbd><span class="koboSpan" id="kobo.131.1">/var/lib/grafana</span></kbd><span class="koboSpan" id="kobo.132.1">; however, it can't scale because the Google persistent disk is RWO:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.133.1">$ cat grafana-pv.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.134.1">apiVersion: apps/v1</span><br/><span class="koboSpan" id="kobo.135.1">kind: Deployment</span><br/><span class="koboSpan" id="kobo.136.1">metadata:</span><br/><span class="koboSpan" id="kobo.137.1">  name: grafana</span><br/><span class="koboSpan" id="kobo.138.1">spec:</span><br/><span class="koboSpan" id="kobo.139.1">  replicas: 1</span><br/><span class="koboSpan" id="kobo.140.1">  selector:</span><br/><span class="koboSpan" id="kobo.141.1">    matchLabels:</span><br/><span class="koboSpan" id="kobo.142.1">      run: grafana</span><br/><span class="koboSpan" id="kobo.143.1">  template:</span><br/><span class="koboSpan" id="kobo.144.1">    metadata:</span><br/><span class="koboSpan" id="kobo.145.1">      labels:</span><br/><span class="koboSpan" id="kobo.146.1">        run: grafana</span><br/><span class="koboSpan" id="kobo.147.1">    spec:</span><br/><span class="koboSpan" id="kobo.148.1">      containers:</span><br/><span class="koboSpan" id="kobo.149.1">        - image: grafana/grafana:3.1.1</span><br/><span class="koboSpan" id="kobo.150.1">          name: grafana</span><br/><span class="koboSpan" id="kobo.151.1">          ports:</span><br/><span class="koboSpan" id="kobo.152.1">            - containerPort: 3000</span><br/><span class="koboSpan" id="kobo.153.1">          volumeMounts:</span><br/><span class="koboSpan" id="kobo.154.1">          - mountPath: /var/lib/grafana</span><br/><span class="koboSpan" id="kobo.155.1">            name: grafana-data</span><br/><span class="koboSpan" id="kobo.156.1">      volumes:</span><br/><span class="koboSpan" id="kobo.157.1">      - name: grafana-data</span><br/><span class="koboSpan" id="kobo.158.1">        gcePersistentDisk:</span><br/><span class="koboSpan" id="kobo.159.1">          pdName: gce-pd-1</span><br/><span class="koboSpan" id="kobo.160.1">          fsType: ext4</span><br/><br/></span><span><span class="koboSpan" id="kobo.161.1">$ kubectl create -f grafana-pv.yml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.162.1">deployment.apps/grafana created</span><br/></span><span><br/><span class="koboSpan" id="kobo.163.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.164.1">NAME </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.165.1">READY </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.166.1">STATUS</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.167.1">RESTARTS </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.168.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.169.1">grafana-6cf5467c9d-nw6b7 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.170.1">1/1 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.171.1">Running </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.172.1">0</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.173.1">41s</span><br/><br/><br/><span class="koboSpan" id="kobo.174.1">//can't scale up, becaues 3 Pod can't mount the same volume</span><br/></span><span><span class="koboSpan" id="kobo.175.1">$ kubectl scale deploy grafana --replicas=3</span><br/></span><span><span class="koboSpan" id="kobo.176.1">The Deployment "grafana" is invalid: spec.template.spec.volumes[0].gcePersistentDisk.readOnly: Invalid value: false: must be true for replicated pods &gt; 1; GCE PD can only be mounted on multiple machines if it is read-only</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.177.1">Even if the persistent volume has the </span><span><span class="koboSpan" id="kobo.178.1">RWX</span></span><span><span class="koboSpan" id="kobo.179.1"> </span></span><span><span class="koboSpan" id="kobo.180.1">capability (read write many; many pods can mount to read and write simultaneously), such as NFS, it won't complain if multiple pods try to bind the same volume. </span><span class="koboSpan" id="kobo.180.2">However, we still</span></span><span class="koboSpan" id="kobo.181.1"> need </span><span><span class="koboSpan" id="kobo.182.1">to consider</span></span><span class="koboSpan" id="kobo.183.1"> whether </span><span><span class="koboSpan" id="kobo.184.1">multiple application instances can use the same folder/file or not. </span><span class="koboSpan" id="kobo.184.2">For example, if it replicates Grafana to two or more pods, it will be conflicted, with multiple Grafana instances that try to write to the same</span></span> <kbd><span class="koboSpan" id="kobo.185.1">/var/lib/grafana/grafana.db</span></kbd><span><span class="koboSpan" id="kobo.186.1">, and then the data could be corrupted, as shown in the following diagram:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.187.1"><img src="assets/eeb24510-e346-4bd1-941b-f4f4b1fe91e1.png" style="width:29.58em;height:15.83em;"/></span></div>
<p><span class="koboSpan" id="kobo.188.1">In this scenario, Grafana must use backend databases such as MySQL or PostgreSQL, instead of SQLite3, as follows. </span><span class="koboSpan" id="kobo.188.2">It allows multiple Grafana instances to read/write Grafana metadata properly:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.189.1"><img src="assets/f7cb8468-f326-4dde-8750-2f76fad6baa3.png" style="width:27.50em;height:13.67em;"/></span></div>
<p><span class="koboSpan" id="kobo.190.1">Because RDBMS basically supports connecting with multiple application instances via a network, this scenario is perfectly suited to being used by multiple pods. </span><span class="koboSpan" id="kobo.190.2">Note that Grafana supports using RDBMS as a backend metadata store; however, not all applications support RDBMS.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.191.1">For the Grafana configuration that uses MySQL/PostgreSQL, please see the online documentation at</span><br/>
<a href="http://docs.grafana.org/installation/configuration/#database" target="_blank"><span class="URLPACKT"><span class="koboSpan" id="kobo.192.1">http://docs.grafana.org/installation/configuration/#database</span></span></a><span class="koboSpan" id="kobo.193.1">.</span></div>
<p><span class="koboSpan" id="kobo.194.1">Therefore, the Kubernetes administrator needs to </span><span><span class="koboSpan" id="kobo.195.1">carefully</span></span><span><span class="koboSpan" id="kobo.196.1"> </span></span><span><span class="koboSpan" id="kobo.197.1">monitor how an application behaves with volumes, and understand</span></span><span class="koboSpan" id="kobo.198.1"> that </span><span><span class="koboSpan" id="kobo.199.1">in some use cases, just using a persistent volume may not help because of issues that might arise when scaling pods.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">If multiple pods need to access the centralized volume, then consider using the database as previously shown, if applicable. </span><span class="koboSpan" id="kobo.200.2">On the other hand, if multiple pods need an individual volume, consider using </span><kbd><span class="koboSpan" id="kobo.201.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.202.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Replicating pods with a persistent volume using StatefulSet</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.3.1"> was introduced in Kubernetes 1.5; this consists of a bond between the pod and the persistent volume. </span><span class="koboSpan" id="kobo.3.2">When scaling a pod that increases or decreases, pod and persistent volume are created or deleted together.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In addition, the pod-creation process is serial. </span><span class="koboSpan" id="kobo.4.2">For example, when requesting Kubernetes to scale two additional </span><kbd><span class="koboSpan" id="kobo.5.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.6.1">s, Kubernetes creates </span><strong><span class="koboSpan" id="kobo.7.1">Persistent Volume Claim 1</span></strong><span class="koboSpan" id="kobo.8.1"> and </span><strong><span class="koboSpan" id="kobo.9.1">Pod 1</span></strong><span class="koboSpan" id="kobo.10.1"> first, and then creates </span><strong><span class="koboSpan" id="kobo.11.1">Persistent Volume Claim 2</span></strong><span class="koboSpan" id="kobo.12.1"> and </span><strong><span class="koboSpan" id="kobo.13.1">Pod 2</span></strong><span class="koboSpan" id="kobo.14.1">, but not simultaneously. </span><span class="koboSpan" id="kobo.14.2">This helps the administrator if an application registers to a registry during the application bootstrap:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1"><img src="assets/871b9722-059b-4ee2-8a53-00e066f19cd2.png" style="width:31.92em;height:21.42em;"/></span></div>
<p><span class="koboSpan" id="kobo.16.1">Even if one pod is dead, </span><kbd><span class="koboSpan" id="kobo.17.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.18.1"> preserves the position of the pod (Kubernetes metadata, such as the pod name) and the persistent volume. </span><span class="koboSpan" id="kobo.18.2">Then it attempts to recreate a container that it reassigns to the same pod and mounts the same persistent volume.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.19.1">If you run the headless service with </span><kbd><span class="koboSpan" id="kobo.20.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.21.1">, Kubernetes also assigns and preserves the FQDN for the pod as well.</span><br/><span class="koboSpan" id="kobo.22.1">
Headless services will be described in detail in </span><a href="fc67e008-b601-45a6-8297-d2fa28360b1f.xhtml"><span class="koboSpan" id="kobo.23.1">Chapter 6</span></a><em><span class="koboSpan" id="kobo.24.1">, Kubernetes Network</span></em><span class="koboSpan" id="kobo.25.1">.</span></div>
<p><span class="koboSpan" id="kobo.26.1">This helps to keep track of and maintain the number of pods/persistent volumes and the application remains online using the Kubernetes scheduler:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.27.1"><img src="assets/ddea9f11-3327-4aee-abc7-42a522b8a9db.png" style="width:63.33em;height:20.50em;"/></span></div>
<p><kbd><span class="koboSpan" id="kobo.28.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.29.1"> with a persistent volume requires dynamic provisioning and </span><kbd><span class="koboSpan" id="kobo.30.1">StorageClass</span></kbd><span class="koboSpan" id="kobo.31.1"> because </span><kbd><span class="koboSpan" id="kobo.32.1">StatefulSet</span></kbd><span class="koboSpan" id="kobo.33.1"> can be scalable. </span><span class="koboSpan" id="kobo.33.2">Kubernetes needs to know how to provision the persistent volume when adding more pods.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Submitting Jobs to Kubernetes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In general, the application is designed to be long-lived in the same way as the daemon process. </span><span class="koboSpan" id="kobo.2.2">A typical long-lived application opens the network port and keeps it running. </span><span class="koboSpan" id="kobo.2.3">It is required to keep running the application. </span><span class="koboSpan" id="kobo.2.4">If it fails, you will need to restart to recover the state. </span><span class="koboSpan" id="kobo.2.5">Therefore, using Kubernetes deployment is the best option for the long-lived application.</span></p>
<p><span class="koboSpan" id="kobo.3.1">On the other hand, some applications are designed to be short-lived, such as a command script. </span><span class="koboSpan" id="kobo.3.2">It is expected to exit the application even if it is successful in order to finish the tasks. </span><span class="koboSpan" id="kobo.3.3">Therefore, a Kubernetes deployment is not the right choice, because a deployment tries to keep the process running.</span></p>
<p><span><span class="koboSpan" id="kobo.4.1">No worries; Kubernetes also supports short-lived applications. </span><span class="koboSpan" id="kobo.4.2">Y</span></span><span><span class="koboSpan" id="kobo.5.1">ou can submit a container as a </span><strong><span class="koboSpan" id="kobo.6.1">Job</span></strong><span class="koboSpan" id="kobo.7.1"> or </span><strong><span class="koboSpan" id="kobo.8.1">Scheduled Job</span></strong><span class="koboSpan" id="kobo.9.1">, and Kubernetes will dispatch it to an appropriate node and execute your container. </span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Kubernetes supports several types of Jobs</span><span><span class="koboSpan" id="kobo.11.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Single Job</span></li>
<li><span class="koboSpan" id="kobo.13.1">Repeatable </span><span><span class="koboSpan" id="kobo.14.1">J</span></span><span class="koboSpan" id="kobo.15.1">ob</span></li>
<li><span class="koboSpan" id="kobo.16.1">Parallel </span><span><span class="koboSpan" id="kobo.17.1">J</span></span><span class="koboSpan" id="kobo.18.1">ob</span></li>
<li><span class="koboSpan" id="kobo.19.1">Scheduled </span><span><span class="koboSpan" id="kobo.20.1">J</span></span><span class="koboSpan" id="kobo.21.1">ob</span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">The last one is also called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">CronJob</span></strong></span><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">Kubernetes supports these different types of Jobs that are used differently to pods to utilize your resources.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Submitting a single Job to Kubernetes</span></h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span><span class="koboSpan" id="kobo.2.1">A Job-like pod is suitable to run for batch programs such as collecting data, querying the database, generating a report, and so on. </span><span class="koboSpan" id="kobo.2.2">Although this is referred to as short-lived, it doesn't matter how long is spent on it. </span><span class="koboSpan" id="kobo.2.3">This may need to run for a few seconds, or perhaps a few days, in order to complete. </span><span class="koboSpan" id="kobo.2.4">It will eventually exit an application, which means it has an end state.</span></span></p>
</div>
</div>
</div>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span><span class="koboSpan" id="kobo.3.1">Kubernetes is capable of monitoring a short-lived application as a Job, and in the case of failure, Kubernetes will</span></span><span class="koboSpan" id="kobo.4.1"> create a new pod for </span><span><span class="koboSpan" id="kobo.5.1">the Job that tries to</span></span><span class="koboSpan" id="kobo.6.1"> accomplish your application to complete.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In order to submit a Job to Kubernetes, you need to write a Job template that specifies the pod configuration. </span><span class="koboSpan" id="kobo.7.2">The following example demonstrates how to check the </span><kbd><span class="koboSpan" id="kobo.8.1">dpkg</span></kbd><span class="koboSpan" id="kobo.9.1"> installed in Ubuntu Linux:</span></p>
<pre><strong><span class="koboSpan" id="kobo.10.1">$ cat job-dpkg.yaml</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">apiVersion: batch/v1</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">kind: Job</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">metadata:</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">  name: package-check</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">spec:</span><br/><span class="koboSpan" id="kobo.16.1">  activeDeadlineSeconds: 60</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">  template:</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">    spec:</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">      containers:</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">      - name: package-check</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">        image: ubuntu</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">        command: ["dpkg-query", "-l"]</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">      restartPolicy: Never</span></strong></pre></div>
</div>
</div>
<p><span class="koboSpan" id="kobo.24.1">Job definition is similar to pod definition, but the important settings are </span><kbd><span class="koboSpan" id="kobo.25.1">activeDeadlineSeconds</span></kbd><span class="koboSpan" id="kobo.26.1"> and </span><kbd><span class="koboSpan" id="kobo.27.1">restartPolicy</span></kbd><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">The </span><kbd><span><span class="koboSpan" id="kobo.29.1">activeDeadlineSeconds </span></span></kbd><span><span class="koboSpan" id="kobo.30.1">parameter</span></span><span><span class="koboSpan" id="kobo.31.1"> sets the maximum timescale for the pod to run. </span><span class="koboSpan" id="kobo.31.2">If exceeded, the pod will be terminated. </span><span class="koboSpan" id="kobo.31.3">The</span></span> <kbd><span class="koboSpan" id="kobo.32.1">restartPolicy</span></kbd><span><span class="koboSpan" id="kobo.33.1"> </span></span><span><span class="koboSpan" id="kobo.34.1">parameter</span></span><span><span class="koboSpan" id="kobo.35.1"> </span></span><span><span class="koboSpan" id="kobo.36.1">defines how Kubernetes behaves in the case of failure. </span><span class="koboSpan" id="kobo.36.2">For example, when the pod is crashed if you specify</span></span> <kbd><span class="koboSpan" id="kobo.37.1">Never</span></kbd><span><span class="koboSpan" id="kobo.38.1">, Kubernetes doesn't restart; if you specify</span></span> <kbd><span class="koboSpan" id="kobo.39.1">OnFailure</span></kbd><span><span class="koboSpan" id="kobo.40.1">, Kubernetes attempts to resubmit the Job until successfully completed.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Use the </span><kbd><span class="koboSpan" id="kobo.42.1">kubectl</span></kbd><span class="koboSpan" id="kobo.43.1"> command to submit a Job to see how Kubernetes manages the pod:</span></p>
<pre><strong><span class="koboSpan" id="kobo.44.1">$ kubectl create -f job-dpkg.yaml </span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">job.batch/package-check created</span></strong></pre>
<p><span class="koboSpan" id="kobo.46.1">Because this Job (the </span><kbd><span class="koboSpan" id="kobo.47.1">dpkg-query -l</span></kbd><span class="koboSpan" id="kobo.48.1"> command) is short-lived, it will </span><kbd><span class="koboSpan" id="kobo.49.1">exit()</span></kbd><span class="koboSpan" id="kobo.50.1"> eventually. </span><span class="koboSpan" id="kobo.50.2">Therefore, if the </span><kbd><span class="koboSpan" id="kobo.51.1">dpkg-query</span></kbd><span class="koboSpan" id="kobo.52.1"> command completes </span><span><span class="koboSpan" id="kobo.53.1">gracefully</span></span><span class="koboSpan" id="kobo.54.1">, Kubernetes doesn't attempt to restart, even if no active pod exists. </span><span class="koboSpan" id="kobo.54.2">So, when you type </span><kbd><span class="koboSpan" id="kobo.55.1">kubectl get pods</span></kbd><span class="koboSpan" id="kobo.56.1">, the pod status will be </span><kbd><span class="koboSpan" id="kobo.57.1">completed</span></kbd><span class="koboSpan" id="kobo.58.1"> after finishing:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.59.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.60.1">NAME</span></span>                  <span><span class="koboSpan" id="kobo.61.1">READY </span></span>    <span><span class="koboSpan" id="kobo.62.1">STATUS</span></span>      <span><span class="koboSpan" id="kobo.63.1">RESTARTS </span></span>  <span><span class="koboSpan" id="kobo.64.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.65.1">package-check-7tfkt </span></span>  <span><span class="koboSpan" id="kobo.66.1">0/1 </span></span>      <span><span class="koboSpan" id="kobo.67.1">Completed </span></span>  <span><span class="koboSpan" id="kobo.68.1">0</span></span>          <span><span class="koboSpan" id="kobo.69.1">6m</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.70.1">Although no active pod exists, you still have an opportunity to check the application log by typing the </span><kbd><span class="koboSpan" id="kobo.71.1">kubectl logs</span></kbd><span class="koboSpan" id="kobo.72.1"> command as follows:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.73.1">$ kubectl logs package-check-7tfkt</span><br/></span><span><span class="koboSpan" id="kobo.74.1">Desired=Unknown/Install/Remove/Purge/Hold</span><br/></span><span><span class="koboSpan" id="kobo.75.1">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend</span><br/></span><span><span class="koboSpan" id="kobo.76.1">|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)</span><br/></span><span><span class="koboSpan" id="kobo.77.1">||/ Name</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.78.1">Version</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.79.1">Architecture Description</span><br/></span><span><span class="koboSpan" id="kobo.80.1">+++-=======================-======================-============-========================================================================</span><br/></span><span><span class="koboSpan" id="kobo.81.1">ii</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.82.1">adduser </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.83.1">3.116ubuntu1 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.84.1">all</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.85.1">add and remove users and groups</span><br/></span><span><span class="koboSpan" id="kobo.86.1">ii</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.87.1">apt </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.88.1">1.6.3ubuntu0.1 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.89.1">amd64</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.90.1">commandline package manager</span><br/></span><span><span class="koboSpan" id="kobo.91.1">ii</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.92.1">base-files</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.93.1">10.1ubuntu2.2</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.94.1">amd64</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.95.1">Debian base system miscellaneous files</span><br/></span><span><span class="koboSpan" id="kobo.96.1">ii</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.97.1">base-passwd </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.98.1">3.5.44 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.99.1">amd64</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.100.1">Debian base system master password and group files</span><br/><span class="koboSpan" id="kobo.101.1">...</span></span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Submitting a repeatable Job</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Users can also decide the number of tasks that should be finished in a single Job. </span><span class="koboSpan" id="kobo.2.2">This is helpful for solving some random sampling problems. </span><span class="koboSpan" id="kobo.2.3">Let's reuse the previous template and add </span><kbd><span class="koboSpan" id="kobo.3.1">spec.completions</span></kbd><span class="koboSpan" id="kobo.4.1"> to see the differences:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.5.1">$ cat repeat-job.yaml</span></span> </strong><br/><strong><span><span class="koboSpan" id="kobo.6.1">apiVersion: batch/v1</span><br/></span><span><span class="koboSpan" id="kobo.7.1">kind: Job</span><br/></span><span><span class="koboSpan" id="kobo.8.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.9.1">name: package-check-repeat</span><br/></span><span><span class="koboSpan" id="kobo.10.1">spec:</span><br/><span class="koboSpan" id="kobo.11.1">  activeDeadlineSeconds: 60</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.12.1">completions: 3</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.13.1">template:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.14.1">spec:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.15.1">containers:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.16.1">- name: package-check-repeat</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.17.1">image: ubuntu</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.18.1">command: ["dpkg-query", "-l"]</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.19.1">restartPolicy: Never</span><br/><br/><br/></span><span><span class="koboSpan" id="kobo.20.1">$ kubectl create -f repeat-job.yaml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.21.1">job.batch/package-check-repeat created</span><br/><br/></span><span><br/></span><span><span class="koboSpan" id="kobo.22.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.23.1">NAME </span><span class="Apple-converted-space">                        </span><span class="koboSpan" id="kobo.24.1">READY </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.25.1">STATUS</span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.26.1">RESTARTS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.27.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.28.1">package-check-7tfkt</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.29.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.30.1">Completed </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.31.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.32.1">52m</span><br/></span><span><span class="koboSpan" id="kobo.33.1">package-check-repeat-vl988 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.34.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.35.1">Completed </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.36.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.37.1">7s</span><br/></span><span><span class="koboSpan" id="kobo.38.1">package-check-repeat-flhz9 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.39.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.40.1">Completed </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.41.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.42.1">4s</span><br/></span><span><span class="koboSpan" id="kobo.43.1">package-check-repeat-xbf8b </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.44.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.45.1">Completed </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.46.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.47.1">2s</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.48.1">As you can see, three pods are created to complete this Job. </span><span class="koboSpan" id="kobo.48.2">This is useful if you need to run your program repeatedly at particular times. </span><span class="koboSpan" id="kobo.48.3">However, as you may have noticed from the Age column in the preceding result, these pods ran sequentially one by one. </span><span class="koboSpan" id="kobo.48.4">In the preceding result, the ages are 7 seconds, 4 seconds, then 2 seconds. </span><span class="koboSpan" id="kobo.48.5">This means that the second Job was started after the first Job was completed, and the third Job was started after the second Job was completed.</span></p>
<p><span class="koboSpan" id="kobo.49.1">If it is the case that a Job runs for a longer period (such as a few days), but if there is no correlation needs between the 1</span><sup><span class="koboSpan" id="kobo.50.1">st</span></sup><span class="koboSpan" id="kobo.51.1">, 2</span><sup><span class="koboSpan" id="kobo.52.1">nd</span></sup><span class="koboSpan" id="kobo.53.1">, and 3</span><sup><span class="koboSpan" id="kobo.54.1">rd</span></sup><span class="koboSpan" id="kobo.55.1"> Job, then it does not make sense to run them sequentially. </span><span class="koboSpan" id="kobo.55.2">In this case, use a parallel Job.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Submitting a parallel Job</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If your batch Job doesn't have a state or dependency between Jobs, you may consider submitting Jobs in parallel. </span><span class="koboSpan" id="kobo.2.2">To do so, similar to the </span><kbd><span class="koboSpan" id="kobo.3.1">spec.completions</span></kbd><span class="koboSpan" id="kobo.4.1"> parameter, the Job template has a </span><kbd><span class="koboSpan" id="kobo.5.1">spec.parallelism</span></kbd><span class="koboSpan" id="kobo.6.1"> parameter to specify how many Jobs you want to run in parallel:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.7.1">$ cat parallel-job.yaml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.8.1">apiVersion: batch/v1</span><br/></span><span><span class="koboSpan" id="kobo.9.1">kind: Job</span><br/></span><span><span class="koboSpan" id="kobo.10.1">metadata:</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.11.1">name: package-check-parallel</span><br/></span><span><span class="koboSpan" id="kobo.12.1">spec:</span><br/><span class="koboSpan" id="kobo.13.1">  activeDeadlineSeconds: 60</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.14.1">parallelism: 3</span><br/></span><span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.15.1">template:</span><br/></span><span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.16.1">spec:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.17.1">containers:</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.18.1">- name: package-check-parallel</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.19.1">image: ubuntu</span><br/></span><span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.20.1">command: ["dpkg-query", "-l"]</span><br/></span><span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.21.1">restartPolicy: Never</span><br/></span><span><br/><br/><span class="koboSpan" id="kobo.22.1">//submit a parallel job</span><br/><span class="koboSpan" id="kobo.23.1">$ kubectl create -f parallel-job.yaml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.24.1">job.batch/package-check-parallel created</span><br/><br/><br/><span class="koboSpan" id="kobo.25.1">//check the result</span><br/></span><span><span class="koboSpan" id="kobo.26.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.27.1">NAME </span><span class="Apple-converted-space">                          </span><span class="koboSpan" id="kobo.28.1">READY </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.29.1">STATUS</span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.30.1">RESTARTS </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.31.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.32.1">package-check-7tfkt</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.33.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.34.1">Completed </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.35.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.36.1">1h</span><br/></span><span><span class="koboSpan" id="kobo.37.1">package-check-parallel-k8hpz </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.38.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.39.1">Completed </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.40.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.41.1">4s</span><br/></span><span><span class="koboSpan" id="kobo.42.1">package-check-parallel-m272g </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.43.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.44.1">Completed </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.45.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.46.1">4s</span><br/></span><span><span class="koboSpan" id="kobo.47.1">package-check-parallel-mc279 </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.48.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.49.1">Completed </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.50.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.51.1">4s</span><br/></span><span><span class="koboSpan" id="kobo.52.1">package-check-repeat-flhz9 </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.53.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.54.1">Completed </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.55.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.56.1">13m</span><br/></span><span><span class="koboSpan" id="kobo.57.1">package-check-repeat-vl988 </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.58.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.59.1">Completed </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.60.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.61.1">13m</span><br/></span><span><span class="koboSpan" id="kobo.62.1">package-check-repeat-xbf8b </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.63.1">0/1 </span><span class="Apple-converted-space">      </span><span class="koboSpan" id="kobo.64.1">Completed </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.65.1">0</span><span class="Apple-converted-space">          </span><span class="koboSpan" id="kobo.66.1">13m</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.67.1">As you see from the </span><kbd><span class="koboSpan" id="kobo.68.1">AGE</span></kbd><span class="koboSpan" id="kobo.69.1"> column through the </span><kbd><span class="koboSpan" id="kobo.70.1">kubectl get pods</span></kbd><span class="koboSpan" id="kobo.71.1"> command, it indicates that the three pods ran at the same time.</span></p>
<p><span class="koboSpan" id="kobo.72.1">In this setting, Kubernetes can dispatch to an available node to run your application and that easily scales your Jobs. </span><span class="koboSpan" id="kobo.72.2">This is useful if you want to run something like a worker application to distribute a bunch of pods to different nodes.</span></p>
<p><span class="koboSpan" id="kobo.73.1">Lastly, if you no longer need to check the Job's results anymore, delete the resource by using </span><span><span class="koboSpan" id="kobo.74.1">the </span></span><kbd><span class="koboSpan" id="kobo.75.1">kubectl delete</span></kbd><span class="koboSpan" id="kobo.76.1"> command as </span><span><span class="koboSpan" id="kobo.77.1">follows:</span></span></p>
<pre><strong><span><span class="koboSpan" id="kobo.78.1">$ kubectl get jobs</span><br/></span><span><span class="koboSpan" id="kobo.79.1">NAME </span><span class="Apple-converted-space">                    </span><span class="koboSpan" id="kobo.80.1">DESIRED </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.81.1">SUCCESSFUL </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.82.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.83.1">package-check</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.84.1">1 </span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.85.1">1</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.86.1">1h</span><br/></span><span><span class="koboSpan" id="kobo.87.1">package-check-parallel </span><span class="Apple-converted-space">  </span><span class="koboSpan" id="kobo.88.1">&lt;none&gt;</span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.89.1">3</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.90.1">9m</span><br/></span><span><span class="koboSpan" id="kobo.91.1">package-check-repeat </span><span class="Apple-converted-space">    </span><span class="koboSpan" id="kobo.92.1">3 </span><span class="Apple-converted-space">        </span><span class="koboSpan" id="kobo.93.1">3</span><span class="Apple-converted-space">            </span><span class="koboSpan" id="kobo.94.1">23m</span><br/><br/><br/><span class="koboSpan" id="kobo.95.1">// delete a job one by one</span><br/></span><span><span class="koboSpan" id="kobo.96.1">$ kubectl delete jobs package-check-parallel</span><br/></span><span><span class="koboSpan" id="kobo.97.1">job.batch "package-check-parallel" deleted</span><br/></span><span><br/><span class="koboSpan" id="kobo.98.1">$ kubectl delete jobs package-check-repeat</span><br/></span><span><span class="koboSpan" id="kobo.99.1">job.batch "package-check-repeat" deleted</span><br/></span><span><br/><span class="koboSpan" id="kobo.100.1">$ kubectl delete jobs package-check</span><br/></span><span><span class="koboSpan" id="kobo.101.1">job.batch "package-check" deleted</span><br/><br/><br/><span class="koboSpan" id="kobo.102.1">//there is no pod </span><br/></span><span><span class="koboSpan" id="kobo.103.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.104.1">No resources found.</span></span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Scheduling running a Job using CronJob</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If you are familiar with </span><strong><span class="koboSpan" id="kobo.3.1">UNIX CronJob</span></strong><span class="koboSpan" id="kobo.4.1"> or </span><strong><span class="koboSpan" id="kobo.5.1">Java Quartz</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><a href="http://www.quartz-scheduler.org"><span class="koboSpan" id="kobo.7.1">http://www.quartz-scheduler.org</span></a><span class="koboSpan" id="kobo.8.1">), Kubernetes CronJob is a very straightforward tool that you can use to define a particular timing to run your Kubernetes Job repeatedly.</span></p>
<p><span class="koboSpan" id="kobo.9.1">The scheduling format is very simple; it specifies the following five items:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Minutes (0 to 59)</span></li>
<li><span class="koboSpan" id="kobo.11.1">Hours (0 to 23)</span></li>
<li><span class="koboSpan" id="kobo.12.1">Days of the month (1 to 31)</span></li>
<li><span class="koboSpan" id="kobo.13.1">Months (1 to 12)</span></li>
<li><span class="koboSpan" id="kobo.14.1">Days of the week (0: Sunday to 6: Saturday)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">For example, if you </span><span><span class="koboSpan" id="kobo.16.1">only</span></span><span><span class="koboSpan" id="kobo.17.1"> </span></span><span><span class="koboSpan" id="kobo.18.1">want to run your Job at 9:00 am on November 12th every year to send a birthday greeting to me, the schedule format would be</span></span> <kbd><span class="koboSpan" id="kobo.19.1">0 9 12 11 *</span></kbd></p>
<p><span class="koboSpan" id="kobo.20.1">You may also use a slash (</span><kbd><span class="koboSpan" id="kobo.21.1">/</span></kbd><span class="koboSpan" id="kobo.22.1">) to specify a step value. </span><span class="koboSpan" id="kobo.22.2">Running the previous Job example at five-minute intervals would have the following schedule format:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">*/5  * * * *</span></pre>
<p><span class="koboSpan" id="kobo.24.1">The following template is using a </span><kbd><span class="koboSpan" id="kobo.25.1">CronJob</span></kbd><span class="koboSpan" id="kobo.26.1"> to run the </span><kbd><span class="koboSpan" id="kobo.27.1">package-check</span></kbd><span class="koboSpan" id="kobo.28.1"> command every five minutes:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.29.1">$ cat cron-job.yaml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.30.1">apiVersion: batch/v1beta1</span><br/><span class="koboSpan" id="kobo.31.1">kind: CronJob</span><br/><span class="koboSpan" id="kobo.32.1">metadata:</span><br/><span class="koboSpan" id="kobo.33.1">  name: package-check-schedule</span><br/><span class="koboSpan" id="kobo.34.1">spec:</span><br/><span class="koboSpan" id="kobo.35.1">  schedule: "*/5 * * * *"</span><br/><span class="koboSpan" id="kobo.36.1">  concurrencyPolicy: "Forbid"</span><br/><span class="koboSpan" id="kobo.37.1">  jobTemplate:</span><br/><span class="koboSpan" id="kobo.38.1">    spec:</span><br/><span class="koboSpan" id="kobo.39.1">      template:</span><br/><span class="koboSpan" id="kobo.40.1">        spec:</span><br/><span class="koboSpan" id="kobo.41.1">          containers:</span><br/><span class="koboSpan" id="kobo.42.1">          - name: package-check-schedule</span><br/><span class="koboSpan" id="kobo.43.1">            image: ubuntu</span><br/><span class="koboSpan" id="kobo.44.1">            command: ["dpkg-query", "-l"]</span><br/><span class="koboSpan" id="kobo.45.1">          restartPolicy: Never</span><br/><br/></span><span><span class="koboSpan" id="kobo.46.1">$ kubectl create -f cron-job.yaml</span><span class="Apple-converted-space"> <br/></span></span><span><span class="koboSpan" id="kobo.47.1">cronjob.batch/package-check-schedule created</span></span></strong></pre>
<p><span class="koboSpan" id="kobo.48.1">You may notice that the template format is slightly different from the Job template here. </span><span class="koboSpan" id="kobo.48.2">However, there is one parameter we need to pay attention to: </span><kbd><span class="koboSpan" id="kobo.49.1">spec.concurrencyPolicy</span></kbd><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">With this, you can specify a behavior if the previous Job is not finished but the next Job's schedule is approaching. </span><span class="koboSpan" id="kobo.50.3">This determines how the next Job runs. </span><span class="koboSpan" id="kobo.50.4">You can set the following:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.51.1">Allow</span></strong><span class="koboSpan" id="kobo.52.1">: Allow execution of the next Job</span></li>
<li><strong><span class="koboSpan" id="kobo.53.1">Forbid</span></strong><span class="koboSpan" id="kobo.54.1">: Skip execution of the next Job</span></li>
<li><strong><span class="koboSpan" id="kobo.55.1">Replace</span></strong><span class="koboSpan" id="kobo.56.1">: Delete the current Job, then execute the next Job</span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">If you set </span><kbd><span class="koboSpan" id="kobo.58.1">Allow</span></kbd><span class="koboSpan" id="kobo.59.1">, there might be the potential risk of accumulating some unfinished Jobs in the Kubernetes cluster. </span><span class="koboSpan" id="kobo.59.2">Therefore, during the testing phase, you should set either </span><kbd><span class="koboSpan" id="kobo.60.1">Forbid</span></kbd><span class="koboSpan" id="kobo.61.1"> or </span><kbd><span class="koboSpan" id="kobo.62.1">Replace</span></kbd><span class="koboSpan" id="kobo.63.1"> to monitor Job execution and completion.</span></p>
<p><span class="koboSpan" id="kobo.64.1">After a few moments, the Job will be triggered by your desired timing—in this case, every five minutes. </span><span class="koboSpan" id="kobo.64.2">You may then see the Job entry with the </span><kbd><span class="koboSpan" id="kobo.65.1">kubectl get jobs</span></kbd><span class="koboSpan" id="kobo.66.1"> and </span><kbd><span class="koboSpan" id="kobo.67.1">kubectl get pods</span></kbd><span class="koboSpan" id="kobo.68.1"> commands, as follows:</span></p>
<pre><strong><span><span class="koboSpan" id="kobo.69.1">$ kubectl get jobs</span><br/></span><span><span class="koboSpan" id="kobo.70.1">NAME</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.71.1">DESIRED </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.72.1">SUCCESSFUL </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.73.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.74.1">package-check-schedule-1537169100 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.75.1">1 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.76.1">1</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.77.1">8m</span><br/></span><span><span class="koboSpan" id="kobo.78.1">package-check-schedule-1537169400 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.79.1">1 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.80.1">1</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.81.1">3m</span><br/></span><span><br/><span class="koboSpan" id="kobo.82.1">$ kubectl get pods</span><br/></span><span><span class="koboSpan" id="kobo.83.1">NAME</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.84.1">READY </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.85.1">STATUS</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.86.1">RESTARTS </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.87.1">AGE</span><br/></span><span><span class="koboSpan" id="kobo.88.1">package-check-schedule-1537169100-mnhxw </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.89.1">0/1 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.90.1">Completed </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.91.1">0</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.92.1">8m</span><br/></span><span><span class="koboSpan" id="kobo.93.1">package-check-schedule-1537169400-wvbgp </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.94.1">0/1 </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.95.1">Completed </span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.96.1">0</span><span class="Apple-converted-space"> </span><span class="koboSpan" id="kobo.97.1">3m</span></span></strong></pre>
<p><kbd><span class="koboSpan" id="kobo.98.1">CronJob</span></kbd><span class="koboSpan" id="kobo.99.1"> will remain until you delete it. </span><span class="koboSpan" id="kobo.99.2">This means that, every five minutes, </span><kbd><span class="koboSpan" id="kobo.100.1">CronJob</span></kbd><span class="koboSpan" id="kobo.101.1"> will create a new Job entry and related pods will also keep getting created. </span><span class="koboSpan" id="kobo.101.2">This will impact the consumption of Kubernetes resources. </span><span class="koboSpan" id="kobo.101.3">Therefore, by default, </span><kbd><span class="koboSpan" id="kobo.102.1">CronJob</span></kbd><span class="koboSpan" id="kobo.103.1"> will keep up to three successful Jobs (with </span><kbd><span class="koboSpan" id="kobo.104.1">spec.successfulJobsHistoryLimit</span></kbd><span class="koboSpan" id="kobo.105.1">) and one failed Job (with </span><kbd><span class="koboSpan" id="kobo.106.1">spec.failedJobsHistoryLimit</span></kbd><span class="koboSpan" id="kobo.107.1">). </span><span class="koboSpan" id="kobo.107.2">You can change these parameters based on your requirements.</span></p>
<p><span class="koboSpan" id="kobo.108.1">Overall, </span><kbd><span class="koboSpan" id="kobo.109.1">CronJob</span></kbd><span class="koboSpan" id="kobo.110.1"> allows Jobs to automatically run in your application with the desired timing. </span><span class="koboSpan" id="kobo.110.2">You can utilize </span><kbd><span class="koboSpan" id="kobo.111.1">CronJob</span></kbd><span class="koboSpan" id="kobo.112.1"> to run report-generation Jobs, daily or weekly batch Jobs, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we covered stateful applications that use persistent volumes. </span><span class="koboSpan" id="kobo.2.2">Compared to ephemeral volumes, they have some pitfalls when an application restarts or a pod scales. </span><span class="koboSpan" id="kobo.2.3">In addition, persistent volume management on Kubernetes has been enhanced to make it easier, as you can see from tools </span><span><span class="koboSpan" id="kobo.3.1">such</span></span><span><span class="koboSpan" id="kobo.4.1"> </span></span><span><span class="koboSpan" id="kobo.5.1">as</span></span> <kbd><span class="koboSpan" id="kobo.6.1">StatefulSet</span></kbd> <span><span class="koboSpan" id="kobo.7.1">and dynamic provisioning.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Furthermore, Jobs and CronJobs are special utilities for pods. </span><span class="koboSpan" id="kobo.8.2">Compared to deployment/ReplicaSets, this has a desired number of pods running, which is against Job's ideal situation in which the pods should be deleted once they finish their tasks. </span><span class="koboSpan" id="kobo.8.3">This kind of short-lived application can be managed by Kubernetes as well.</span></p>
<p><span class="koboSpan" id="kobo.9.1">In </span><a href="17a735e1-3810-4b77-a9ac-fac0120b0b90.xhtml"><span class="koboSpan" id="kobo.10.1">Chapter 5</span></a><span class="koboSpan" id="kobo.11.1">, </span><em><span class="koboSpan" id="kobo.12.1">Cluster Administration and Extension</span></em><span class="koboSpan" id="kobo.13.1">, we will discuss the cluster administration such as authentication, authorization, and admission control. </span><span class="koboSpan" id="kobo.13.2">We will also introduce the </span><strong><span class="koboSpan" id="kobo.14.1">Custom Resource Definition</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong><span><span class="koboSpan" id="kobo.16.1">CRD</span></span></strong><span class="koboSpan" id="kobo.17.1">) that how to control Kubernetes object by your own code.</span></p>


            </article>

            
        </section>
    </body></html>