<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer118">
<h1 class="chapter-number" id="_idParaDest-120"><a id="_idTextAnchor192"/>6</h1>
<h1 id="_idParaDest-121"><a id="_idTextAnchor193"/>Securing Kubernetes</h1>
<p>This chapter will cover how Kubernetes authentication and authorization patterns work and dive into Kubernetes <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>). We’ll also learn about managing the security of applications deployed on Kubernetes. </p>
<p>Since most of the Kubernetes security-related content released prior to November 2020 has gradually moved to the <strong class="bold">Certified Kubernetes Security Specialist</strong> (<strong class="bold">CKS</strong>) exam instead, this chapter will just cover the essentials to help you to learn about Kubernetes security. We’ll specifically focus on Kubernetes RBAC since it is close to 5% of the CKA exam content. </p>
<p>Nonetheless, a good understanding of the Kubernetes security fundamentals will be a great help for the CKA exam and prepare you for further development in the Kubernetes space.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Securing Kubernetes in layers</li>
<li>Kubernetes authentication and authorization</li>
<li>Kubernetes RBAC</li>
<li>Managing the security of Kubernetes applications<a id="_idTextAnchor194"/></li>
</ul>
<h1 id="_idParaDest-122"><a id="_idTextAnchor195"/>Technical requirements </h1>
<p>To get started, you will need to make sure that your local machine meets the technical requirements described as follows: </p>
<ul>
<li>A compatible Linux host – we recommend a Debian-based Linux distribution such as Ubuntu 18.04 or later. </li>
<li>Make sure that your host machine has at least 2 GB of RAM, 2 CPU cores, and about 20 GB of free disk space.</li>
</ul>
<h1 id="_idParaDest-123"><a id="_idTextAnchor196"/>Securing Kubernetes in layers</h1>
<p>Kubernetes security is a broad topic due to the sophistication of the platform. It includes secure Kubernetes <a id="_idIndexMarker417"/>nodes, networks, and Kubernetes objects <a id="_idIndexMarker418"/>such as Pods. The <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>) defines Kubernetes <a id="_idIndexMarker419"/>security in layers, which they call the <em class="italic">four Cs</em> of cloud-native security, taking the topic of security beyond Kubernetes and its ecosystem. The four Cs stand for <strong class="bold">Cloud</strong>, <strong class="bold">Cluster</strong>, <strong class="bold">Container</strong>, and <strong class="bold">Code</strong>, as shown in the following diagram: </p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<img alt="Figure 6.1 – The different layers in Kubernetes " height="720" src="image/Figure_6.1_B18201.jpg" width="1310"/>
</div>
</div>
<p class="IMG---Caption" xml:lang="en-US">Figure 6.1 – The different layers in Kubernetes</p>
<p>From the preceding diagram, we can see the following: </p>
<ul>
<li>The <strong class="bold">Cloud</strong> layer is based <a id="_idIndexMarker420"/>on the underlying infrastructure <a id="_idIndexMarker421"/>where the Kubernetes cluster is deployed – it is managed by the cloud provider when it is in the cloud or by the organization when it comes to a private data center.  </li>
<li>The <strong class="bold">Cluster</strong> layer is more about securing the Kubernetes cluster components, ensuring each <a id="_idIndexMarker422"/>component is secured and conjured correctly. Looking <a id="_idIndexMarker423"/>back at <a href="B18201_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Kubernetes Overview</em>, will help you understand how those components work together. </li>
<li>The <strong class="bold">Container</strong> layer includes <a id="_idIndexMarker424"/>container vulnerability scanning, <a id="_idIndexMarker425"/>hosted OS scaling, and container privileged users.</li>
<li>The <strong class="bold">Code</strong> layer is focused on the application code. Different from traditional application <a id="_idIndexMarker426"/>security approaches, it now works with DevSecOps and <a id="_idIndexMarker427"/>vulnerability assessment tools. This layer is relevant but outside of the scope of Kubernetes security. </li>
</ul>
<p>Cloud-native <a id="_idIndexMarker428"/>security or, more specifically, Kubernetes security <a id="_idIndexMarker429"/>requires organizations to address each layer. In this chapter, we’ll focus on the following topics: </p>
<ul>
<li>Kubernetes API security with an admission controller</li>
<li>Kubernetes <a id="_idIndexMarker430"/>authentication and authorization with RBAC, <strong class="bold">Attribute-Based Access Control</strong> (<strong class="bold">ABAC</strong>), and node authorization</li>
<li>Managing the security of Kubernetes applications with security contexts</li>
</ul>
<p>The preceding topics are either part of cluster-layer or container-layer security, and they help us run our Kubernetes application securely. We’ll cover Kubernetes network security and dive deeper into network policies in <a href="B18201_07.xhtml#_idTextAnchor235"><em class="italic">Chapter 7</em></a>, <em class="italic">Demystifying Kubernetes <a id="_idTextAnchor197"/>Networking</em>. </p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor198"/>Kubernetes authentication and authorization</h1>
<p>In <a href="B18201_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Kubernetes Overview</em>, we talked about a typical workflow of Kubernetes <a id="_idIndexMarker431"/>components collaborating with each other. In this workflow, when <a id="_idIndexMarker432"/>a request comes through the Kubernetes API server, it invokes an API call. This API request now needs to be authenticated and authorized by the API server before a request is made to a Kubernetes API <a id="_idIndexMarker433"/>resource. As a result, the request can either be <em class="italic">allowed</em> or <em class="italic">denied</em>. The <a id="_idIndexMarker434"/>authentication process can be depicted as in <em class="italic">Figure 6.2</em>: </p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<img alt="Figure 6.2 – API Kubernetes authentication  " height="756" src="image/Figure_6.2_B18201.jpg" width="1291"/>
</div>
</div>
<p class="IMG---Caption" xml:lang="en-US">Figure 6.2 – API Kubernetes authentication </p>
<p>You can refer to the following article to get an overview of how the Kubernetes authentication <a id="_idIndexMarker435"/>process works: <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">https://kubernetes.io/docs/reference/access-authn-authz/authentication/</a>.</p>
<p>Before getting into authentication and authorization, let’s take a look at the user accounts and service accounts<a id="_idTextAnchor199"/> in Kubernetes. </p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor200"/>Service accounts versus user accounts </h2>
<p>In Kubernetes, we <a id="_idIndexMarker436"/>have a distinction <a id="_idIndexMarker437"/>between normal user accounts and service accounts <a id="_idIndexMarker438"/>managed by Kubernetes. An account represents an identity for a user or a service process. The main difference <a id="_idIndexMarker439"/>between a user account and a service account is as follows:</p>
<ul>
<li><strong class="bold">User accounts</strong> are for normal human users. In Kubernetes, the RBAC subsystem is used to <a id="_idIndexMarker440"/>determine whether the user is <a id="_idIndexMarker441"/>authorized to perform a specific operation on a specific scope. We’ll look into this further in the <em class="italic">Kubernetes RBAC</em> section later in this chapter.</li>
<li><strong class="bold">Service accounts</strong> are for services or processes running in a Pod in the Kubernetes cluster. The <a id="_idIndexMarker442"/>service accounts are <a id="_idIndexMarker443"/>users managed by the Kubernetes API. In Kubernetes, it is possible to use client certificates, bearer tokens, or even an authenticating proxy to authenticate API requests through an API server. </li>
</ul>
<p>We’ll take a closer look at the following things from hereon: </p>
<ul>
<li>Kubernetes service accounts and how to work with them</li>
<li>How to organize cluster access using <strong class="source-inline">kubeconfig</strong> as a Kubernetes user </li>
<li>How to configure access to multiple clusters as a Kubernetes user </li>
</ul>
<p>Let’s take a look at the Kubernetes<a id="_idTextAnchor201"/> service account first. </p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor202"/>Kubernetes service accounts </h2>
<p>Back in the previous chapter, we created a new Pod with <strong class="source-inline">kubectl</strong>, although there is a default service <a id="_idIndexMarker444"/>account in the <strong class="source-inline">default</strong> namespace, which the Pod was actually automatically assigned to. Now, let’s have a look at how to work with a servi<a id="_idTextAnchor203"/>ce account in Kubernetes.</p>
<h3>Managing service accounts</h3>
<p>You can use the <a id="_idIndexMarker445"/>following command to get the current service account in the <strong class="source-inline">default</strong> namespace:</p>
<p class="source-code">kubectl get serviceaccounts</p>
<p>Alternatively, you can simply use the shortcut command as follows: </p>
<p class="source-code">kubectl get sa</p>
<p>The output will return the default service account in the <strong class="source-inline">default</strong> namespace:</p>
<p class="source-code">NAME      SECRETS   AGE</p>
<p class="source-code">default   1         5d</p>
<p>The service account is a namespaced resource – you can use the following command to check out all the service accounts in the current cluster: </p>
<p class="source-code">k get sa -A</p>
<p>Alternatively, you can <a id="_idIndexMarker446"/>use the complete command as follows:</p>
<p class="source-code">k get serviceaccounts --all-namespaces</p>
<p>The output of the preceding commands will list the service account information by namespace, similar to the following in <em class="italic">Figure 6.3</em>:</p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<img alt="Figure 6.3 – The service account information by namespace " height="687" src="image/Figure_6.3_B18201.jpg" width="516"/>
</div>
</div>
<p class="IMG---Caption" xml:lang="en-US">Figure 6.3 – The service account information by namespace</p>
<p>This also means we can get the service account information by namespace using the <strong class="source-inline">kubectl get sa</strong> command <a id="_idIndexMarker447"/>and then by specifying the <strong class="source-inline">-n</strong> flag with <strong class="source-inline">namespace name</strong> to get the service account with that particular namespace. For example, using <strong class="source-inline">kubectl get sa -n</strong> with <strong class="source-inline">kube-system</strong> will only return the service account in <a id="_idTextAnchor204"/>the <strong class="source-inline">kube-system</strong> namespace. </p>
<h3>The kubectl create sa command</h3>
<p>You can use <a id="_idIndexMarker448"/>the <strong class="source-inline">kubectl create</strong> command <a id="_idIndexMarker449"/>to create a new service account, the following being an example: </p>
<p class="source-code">kubectl create serviceaccount melon-serviceaccount</p>
<p>The following output will show that the service account is created successfully: </p>
<p class="source-code">serviceaccount/melon-serviceaccount created</p>
<p>We can also create the service account in a different namespace using the <strong class="source-inline">kubectl create</strong> command by specifying the <strong class="source-inline">-n</strong> flag. Additionally, we also need to make sure that the namespace exists prior to creating a service account in that namespace. The following is an example of using a <strong class="source-inline">kubectl create</strong> command to create a service account named <strong class="source-inline">melonsa</strong> in a namespace called <strong class="source-inline">melon-ns</strong>: </p>
<p class="source-code">kubectl create ns melon-ns</p>
<p class="source-code">kubectl create sa melonsa -n melon-ns</p>
<p>The preceding output displays that you have created the service account successfully. You can also use the following command to check that the service account has just been created: </p>
<p class="source-code">k get –n melon-ns serviceaccounts</p>
<p>The following output lists the service account and how long it’s been created: </p>
<p class="source-code">NAME                   SECRETS   AGE </p>
<p class="source-code">melon-ssa   1         46s</p>
<p>Similarly, if you want to check out the service account in another namespace, you can use <a id="_idIndexMarker450"/>the <strong class="source-inline">kubectl get sa &lt;service account name&gt;</strong> command and then add the <strong class="source-inline">-n</strong> flag, for example, <a id="_idTextAnchor205"/><strong class="source-inline">k get sa melonsa -n melon-ns</strong>. </p>
<h3>Assigning a service account to a Pod </h3>
<p>The purpose of <a id="_idIndexMarker451"/>having a service account is to <a id="_idIndexMarker452"/>provide an identity to serve the process running in the Pod. To determine the service account that a Pod will use, you can specify a <strong class="source-inline">serviceAccountName</strong> field in the Pod YAML specification called <strong class="source-inline">sa-pod.yaml</strong>, as shown here:</p>
<pre class="source-code">
apiVersion: v1
kind: Pod
metadata:
   name: melon-serviceaccount-pod
spec:
<strong class="bold">   serviceAccountName: melon-serviceaccount</strong>
   containers:
   - name: melonapp-svcaccount-container
     image: busybox
     command: ['sh', '-c','echo stay tuned!&amp;&amp; sleep 3600']</pre>
<p>Then, when <a id="_idIndexMarker453"/>we use the <strong class="source-inline">kubectl apply -f sa-pod.yaml</strong> command <a id="_idIndexMarker454"/>to deploy this YAML file, we’ll <a id="_idTextAnchor206"/>be able to see a Pod spinning up. </p>
<h3>The kubectl delete sa command</h3>
<p>You can delete <a id="_idIndexMarker455"/>a service account using the <strong class="source-inline">kubectl delete sa &lt;account name &gt;</strong> command:</p>
<p class="source-code">kubectl delete sa melon-serviceaccount</p>
<p>The output <a id="_idIndexMarker456"/>comes back showing that the service account was deleted: </p>
<p class="source-code">serviceaccount "melon-serviceaccount" deleted</p>
<p>Hopefully, you now have a better idea of how to work with a Kubernetes service account using <a id="_idIndexMarker457"/>what you learned in this section. Now, let’s <a id="_idIndexMarker458"/>take a look at how to organiz<a id="_idTextAnchor207"/>e the cluster access using <strong class="source-inline">kubeconfig</strong>.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor208"/>Organizing the cluster access using kubeconfig</h2>
<p>As a Kubernetes <a id="_idIndexMarker459"/>user, when you <a id="_idIndexMarker460"/>deploy the Kubernetes cluster with <strong class="source-inline">kubeadm</strong>, you will find a file called <strong class="source-inline">config</strong> in the <strong class="source-inline">$HOME/.kube</strong> directory:</p>
<p class="source-code">cloudmelon@cloudmelonplayground:~$ cd $HOME/.kube</p>
<p class="source-code">cloudmelon@cloudmelonplayground:~/.kube$ ls</p>
<p class="source-code">cache/  <strong class="bold">config</strong></p>
<p>In other cases, this <strong class="source-inline">kubeconfig</strong> file can be set up as a KUBECONFIG environment variable <a id="_idIndexMarker461"/>or a <strong class="source-inline">--kubeconfig</strong> flag. You can find detailed instructions in the official documentation: <a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/</a>.</p>
<p>The <strong class="source-inline">kubeconfig</strong> files help organize information clusters, users, and namespaces. From the <strong class="source-inline">kubectl</strong> utility point of view, it reads <strong class="source-inline">kubeconfig</strong> files to locate the information of the cluster and communicate with the API server of that Kubernetes cluster.</p>
<p>The following is an example of a <strong class="source-inline">kubeconfig</strong> file:</p>
<pre class="source-code">
apiVersion: v1
<strong class="bold">clusters:</strong>
- cluster:
    certificate-authority: /home/cloudmelon/.minikube/ca.crt
    extensions:
    - extension:
        last-update: Wed, 11 May 2022 23:47:43 UTC
        provider: minikube.sigs.k8s.io
        version: v1.25.2
      name: cluster_info
    server: https://192.168.49.2:8443
  name: minikube
<strong class="bold">contexts:</strong>
- context:
    cluster: minikube
    extensions:
    - extension:
        last-update: Wed, 11 May 2022 23:47:43 UTC
        provider: minikube.sigs.k8s.io
        version: v1.25.2
      name: context_info
    namespace: default
    user: minikube
  name: minikube
<strong class="bold">current-context: minikube</strong>
kind: Config
preferences: {}
<strong class="bold">users:</strong>
- name: minikube
  user:
    client-certificate: /home/cloudmelon/.minikube/profiles/minikube/client.crt
    client-key: /home/cloudmelon/.minikube/profiles/minikube/client.key</pre>
<p>You can <a id="_idIndexMarker462"/>see <strong class="source-inline">config</strong> by using <a id="_idIndexMarker463"/>the following command: </p>
<p class="source-code">kubectl config view</p>
<p>The output should look as follows: </p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<img alt="Figure 6.4 – The kubectl config view output " height="464" src="image/Figure_6.4_B18201.jpg" width="567"/>
</div>
</div>
<p class="IMG---Caption" xml:lang="en-US">Figure 6.4 – The kubectl config view output</p>
<p>You can use the <strong class="source-inline">kubectl config</strong> command to display <strong class="source-inline">current-context</strong>: </p>
<p class="source-code">kubectl config current-context</p>
<p>The returned <a id="_idIndexMarker464"/>output will be the current <a id="_idIndexMarker465"/>context – in my case, it is <strong class="source-inline">minikube</strong>. You may notice that it is the same as <strong class="source-inline">current-context</strong> shown in the aforementioned <strong class="source-inline">config</strong> file: </p>
<p class="source-code">minikube</p>
<p>To know more <a id="_idIndexMarker466"/>about how to organize the cluster access using <strong class="source-inline">kubeconfig</strong>, refer to the official article to learn more:</p>
<p><a href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/">https://kubernetes.io/docs/concepts/con<span id="_idTextAnchor209"/><span id="_idTextAnchor210"/>fi<span id="_idTextAnchor211"/>guration/organize-cluster-access-kubeconfig/</a></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor212"/>Configuring access to multiple clusters</h2>
<p>As a Kubernetes user, when it comes to multiple clusters, we can also use the <strong class="source-inline">kubectl config</strong> command <a id="_idIndexMarker467"/>to configure the current context to switch between different Kubernetes clusters. To find all the commands provided by <strong class="source-inline">kubectl config</strong>, use this command: </p>
<p class="source-code">kubectl config --help</p>
<p>The following is an example of how <strong class="source-inline">kubeconfig</strong> contains the access information of two different Kubernetes clusters: </p>
<pre class="source-code">
apiVersion: v1
<strong class="bold">clusters:</strong>
<strong class="bold">- cluster:</strong>
    certificate-authority-data: 
 &lt; authority data &gt;
    server: https://xx.xx.xx.xx
  name: gke_cluster
- <strong class="bold">cluster</strong>:
    certificate-authority-data: 
 &lt; authority data &gt;
    server: https://xx.xx.xx.xx
  name: arctestaks
<strong class="bold">contexts:</strong>
<strong class="bold">- context:</strong>
    cluster: gke_cluster
    user: gke_cluster
  name: gke_cluster
- context:
    cluster: arctestaks
    user: clusterUser_akscluster
  name: akscluster
current-context: akscluster
kind: Config
preferences: {}
<strong class="bold">users:</strong>
- name: gke_cluster
  user:
    auth-provider:
      config:
        access-token: 
 &lt; token data &gt;
        cmd-args: config config-helper --format=json
        cmd-path: C:\Program Files (x86)\Google\Cloud SDK\google-cloud-sdk\bin\gcloud.cmd
        expiry: '2022-05-12T00:28:06Z'
        expiry-key: '{.credential.token_expiry}'
        token-key: '{.credential.access_token}'
      name: gcp
- name: clusterUser_akscluster
  user:
    client-certificate-data: &lt;data&gt;
    client-key-data: &lt;data&gt;
    token: 
 &lt; token &gt;</pre>
<p>We could use the <strong class="source-inline">kubectl config current-context</strong> command to see the cluster that I <a id="_idIndexMarker468"/>am working on and it would be displayed as the following:</p>
<p class="source-code"> gke-cluster</p>
<p>The preceding output indicates that I am on a Kubernetes cluster called <strong class="source-inline">gke-cluster</strong> and that I am using the following command to switch my default context to another Kubernetes cluster called <strong class="source-inline">akscluster</strong>: </p>
<p class="source-code">kubectl config use-context akscluster     </p>
<p>We could use the <strong class="source-inline">kubectl config current-context</strong> command to check my current working Kubernetes cluster and it would be displayed as the following:</p>
<p class="source-code">aks-cluster</p>
<p>Switching context is an important technique that you can apply during your actual CKA exam and it’s important to perform tasks in the targeting Kubernetes cluster so that you’ll be scored accurately. It also comes in handy in your real life working as a Kubernetes administrator, as often, you’ll be working on multiple Kubernetes clusters. </p>
<p>To know more about how to configure access to multiple clusters, check the official article: <a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">https://kubernetes.io/docs/tasks/access-applicat<span id="_idTextAnchor213"/>ion-cluster/configure-access-multiple-clusters/</a></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor214"/>Kubernetes authorization</h2>
<p>In Kubernetes, a request must be authenticated before it can be authorized with permissions granted to access the Kubernetes cluster resources. </p>
<p>There are four authorization modes in Kubernetes:</p>
<ul>
<li><strong class="bold">RBAC authorization</strong>: Kubernetes RBAC is more about regulating access to Kubernetes <a id="_idIndexMarker469"/>resources <a id="_idIndexMarker470"/>according to the roles with specific permissions to perform a specific task, such as reading, creating, or modifying through an API request. We’ll focus on Kubernetes RBAC in this section. </li>
<li><strong class="bold">Node authorization</strong>: As the name suggests, this grants permissions to the API requests <a id="_idIndexMarker471"/>made by <strong class="source-inline">kubelets agent</strong>. This <a id="_idIndexMarker472"/>is a special - purpose authorization mode not covered in the CKA exam. You can check out the official documentation about node authorization <a id="_idIndexMarker473"/>to find out more: <a href="https://kubernetes.io/docs/reference/access-authn-authz/node/">https://kubernetes.io/docs/reference/access-authn-authz/node/</a>.</li>
<li><strong class="bold">ABAC authorization</strong>: ABAC is an access control granted to users by policies and attributes <a id="_idIndexMarker474"/>such as user <a id="_idIndexMarker475"/>attributes, resource attributes, and objects. This topic is not covered in the current CKA exam. If you want to learn more about using the ABAC mode, you <a id="_idIndexMarker476"/>can refer to the official article: <a href="https://kubernetes.io/docs/reference/access-authn-authz/abac/">https://kubernetes.io/docs/reference/access-authn-authz/abac/</a>.</li>
<li><strong class="bold">Webhook authorization</strong>: Webhook authorization through WebHooks is an HTTP POST <a id="_idIndexMarker477"/>triggered by an event. An example of this is that the Webhook will react to a URL when triggered by certain actions. This topic is not covered in the current CKA exam. You can explore the following article if you want to know more <a id="_idIndexMarker478"/>about it: <a href="https://kubernetes.io/docs/reference/access-authn-authz/webhook/">https://kubernetes.io/docs/reference/access-authn-authz/webhook/</a>.</li>
</ul>
<p>Let’s take a look at what the key areas co<a id="_idTextAnchor215"/>vered in the CKA<a id="_idTextAnchor216"/> exam are, starting with Kubernetes RBAC.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor217"/>Kubernetes RBAC</h1>
<p>Kubernetes RBAC <a id="_idIndexMarker479"/>aims to regulate access to Kubernetes resources according to the ro<a id="_idTextAnchor218"/>les with specific permissions to perform a specific task. </p>
<p>Once specified, RBAC checks the <strong class="source-inline">rbac.authorization.k8s.io</strong> API group membersh<a id="_idTextAnchor219"/>ip to see whether it is allowed through the Kubernetes API.</p>
<p>Let’s take a l<a id="_idTextAnchor220"/>ook at the different Roles and RoleBindings in Kubernetes.</p>
<h3>Roles versus ClusterRoles and their RoleBindings </h3>
<p>In Kubernetes, we <a id="_idIndexMarker480"/>have Roles and ClusterRoles. A Kubernetes <a id="_idIndexMarker481"/>RBAC Role or ClusterRole represents a role <a id="_idIndexMarker482"/>with a set of permissions. In a nutshell, they differ by the scope of these permissions:</p>
<ul>
<li>A <strong class="bold">Role</strong> represents <a id="_idIndexMarker483"/>permissions within a particular namespace</li>
<li>A <strong class="bold">ClusterRole</strong> represents <a id="_idIndexMarker484"/>permissions within the cluster – it could be cluster-wide, across multiple namespaces, or individual namespaces </li>
</ul>
<p>With Roles and ClusterRoles, we <a id="_idIndexMarker485"/>have the concept of <strong class="bold">RoleBinding</strong> and <strong class="bold">ClusterRoleBinding</strong>. The <a id="_idIndexMarker486"/>bindings bind the role to a list of subjects such as users, groups, or service accounts, as can be seen in the following figure: </p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<img alt="Figure 6.5 – Kubernetes RBAC  " height="689" src="image/Figure_6.5_B18201.jpg" width="1022"/>
</div>
</div>
<p class="IMG---Caption" xml:lang="en-US">Figure 6.5 – Kubernetes RBAC </p>
<p>Let’s define a <a id="_idIndexMarker487"/>new role called <strong class="source-inline">dev-user</strong> in a <a id="_idIndexMarker488"/>namespace called <strong class="source-inline">dev</strong>. We can use the following <a id="_idIndexMarker489"/>command to do this: </p>
<p class="source-code">kubectl create role dev-user --verb=get --verb=list --resource=pods --namespace=dev</p>
<p>The preceding command is the same as the following YAML definition: </p>
<pre class="source-code">
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: dev-user
rules:
- apiGroups: [""] 
  resources: ["pods"]
  verbs: ["get", "list"]</pre>
<p>The output of the preceding command is the following:</p>
<p class="source-code">role.rbac.authorization.k8s.io/dev-user created</p>
<p>Then, we <a id="_idIndexMarker490"/>can use the <strong class="source-inline">kubectl get role</strong> command <a id="_idIndexMarker491"/>to check the role that we have just <a id="_idIndexMarker492"/>created:</p>
<p class="source-code">cloudmelon@cloudmelonplayground:~$ <strong class="bold">k get role -n dev</strong></p>
<p class="source-code">NAME       CREATED AT</p>
<p class="source-code">dev-user   2022-05-13T04:14:59Z</p>
<p>We then need to create the RoleBinding to bind this role to the subjects as follows: </p>
<p class="source-code">kubectl create rolebinding dev-pods-binding --role=dev-user - -user=melon-dev --namespace=dev</p>
<p>Alternatively, we could also use the following YAML file: </p>
<pre class="source-code">
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: dev-pods-binding
  namespace: dev
subjects:
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name:melon-dev
roleRef:
<strong class="bold">  kind: Role </strong>
  name: dev-user 
  apiGroup: rbac.authorization.k8s.io</pre>
<p>Let’s define a new ClusterRole called <strong class="source-inline">secret-reader</strong> – note that the ClusterRole is not namespaced. We could use the following YAML definition: </p>
<pre class="source-code">
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]</pre>
<p>Then, we <a id="_idIndexMarker493"/>need to create the RoleBinding to <a id="_idIndexMarker494"/>bind this role to the subjects, as shown in the <a id="_idIndexMarker495"/>following YAML definition: </p>
<pre class="source-code">
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-secrets
  namespace: development
subjects:
- kind: Group
  name: manager
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io</pre>
<p>We can <a id="_idIndexMarker496"/>use the following command to get all <a id="_idIndexMarker497"/>the roles <a id="_idIndexMarker498"/>across all the namespaces: </p>
<pre class="source-code">
cloudmelon@cloudmelonplayground:~$ <strong class="bold">kubectl get roles -A</strong>
NAMESPACE          NAME                                 CREATED AT
<strong class="bold">dev                dev-user                                        </strong>
kube-public        kubeadm:bootstrap-signer-clusterinfo             
kube-public        system:controller:bootstrap-signer               
kube-system        extension-apiserver-authentication-reader        
kube-system        kube-proxy                                       
kube-system        kubeadm:kubelet-config-1.23                      
kube-system        kubeadm:nodes-kubeadm-config                     
kube-system        system::leader-locking-kube-controller-manager   
kube-system        system::leader-locking-kube-scheduler            
kube-system        system:controller:bootstrap-signer               
kube-system        system:controller:cloud-provider                 
kube-system        system:controller:token-cleaner                  
kube-system        system:persistent-volume-provisioner             </pre>
<p>We can use the following command to get all the RoleBindings across all the namespaces: </p>
<pre class="source-code">
cloudmelon@cloudmelonplayground:~$ <strong class="bold">kubectl get rolebindings -A</strong>
NAMESPACE          NAME                                                
ROLE                                                  AGE
<strong class="bold">dev                dev-pods-binding                                    </strong>
<strong class="bold">Role/dev-user                                         15s</strong>
kube-public        kubeadm:bootstrap-signer-clusterinfo                
Role/kubeadm:bootstrap-signer-clusterinfo             6d
kube-public        system:controller:bootstrap-signer                  
Role/system:controller:bootstrap-signer               6d
kube-system        kube-proxy                                          
Role/kube-proxy                                       6d
kube-system        kubeadm:kubelet-config-1.23                         
Role/kubeadm:kubelet-config-1.23                      6d
kube-system        kubeadm:nodes-kubeadm-config                        
Role/kubeadm:nodes-kubeadm-config                     6d
kube-system        metrics-server-auth-reader                          
Role/extension-apiserver-authentication-reader        3h
kube-system        system::extension-apiserver-authentication-reader   Role/extension-apiserver-authentication-reader        
6d
kube-system        system::leader-locking-kube-controller-manager      Role/system::leader-locking-kube-controller-manager   6d
kube-system        system::leader-locking-kube-scheduler               
Role/system::leader-locking-kube-scheduler            6d
kube-system        system:controller:bootstrap-signer                  
Role/system:controller:bootstrap-signer               6d
kube-system        system:controller:cloud-provider                    
Role/system:controller:cloud-provider                 6d
kube-system        system:controller:token-cleaner                     
Role/system:controller:token-cleaner                  6d
kube-system        system:persistent-volume-provisioner                
Role/system:persistent-volume-provisioner             6d</pre>
<p>Knowing <a id="_idIndexMarker499"/>the ways that Roles and RoleBindings work in Kubernetes, let’s now take<a id="_idTextAnchor221"/> a look at how to implement your own Kubernetes RBAC Roles and RoleBindings. </p>
<h3>Implementing Kubernetes RBAC </h3>
<p>To enable RBAC, set <strong class="source-inline">apiserver –authorization-mode</strong> to RBAC, which defaults to <strong class="source-inline">AlwaysAllow</strong>. The other possible values include <strong class="source-inline">node</strong>, <strong class="source-inline">ABAC</strong>, <strong class="source-inline">Always deny,</strong> and <strong class="source-inline">webhook</strong>. In the following command, we’re showing an example of setting it to use Kubernetes RBAC: </p>
<p class="source-code">kube-apiserver –authorization-mode=RBAC</p>
<p>To know more about how to set up authorization mode, visit the following link: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/</a></p>
<p>Let’s start by creating a new deployment using our current context, which is <strong class="source-inline">minikube</strong>: </p>
<p class="source-code">kubectl create deployment mybusybox –-image=busybox </p>
<p>Then, switch to the context for <strong class="source-inline">dev-user</strong>:</p>
<p class="source-code">kubectl config use-context dev-user</p>
<p>As our <strong class="source-inline">dev-user</strong> only has <strong class="source-inline">list</strong> and <strong class="source-inline">get</strong> permissions, let’s try to use this profile to delete the deployment: </p>
<p class="source-code">cloudmelon@cloudmelonplayground:~$ kubectl delete deployment mybusybox</p>
<p class="source-code">Error from server (Forbidden): deployments.apps is forbidden: User "dev-user" cannot delete resource "deployments" in API group "apps" in the namespace "t</p>
<p>Now that we have learned how to manage our own Kubernetes RBAC roles,<a id="_idTextAnchor222"/> let’s take a look at how to manage the security of Kubernetes applications. </p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor223"/>Managing the security of Kubernetes applications </h1>
<p>A <strong class="source-inline">securityContext</strong> field defines the privilege and access control settings for a Pod in the Pod YAML specification. We need to configure the security context in case a Pod or container needs to interact with the security mechanisms of the underlying operating system unconventionally, and in this section, we’ll introduce how to configure a security context for a Pod or container. </p>
<p>As a part of your prep work, you can create a new user and a new group as shown in the following:</p>
<p class="source-code">sudo useradd -u 2000 container-user-0</p>
<p class="source-code">sudo groupadd -g 3000 container-group-0</p>
<p>We will now log in to the worker node and create a new <strong class="source-inline">.txt</strong> file called <strong class="source-inline">message.txt</strong>: </p>
<p class="source-code">sudo mkdir -p /etc/message</p>
<p class="source-code">echo "hello Packt" | sudo tee -a /etc/message/message.txt</p>
<p>From here, you’ll see the message that we input from the terminal: </p>
<p class="source-code"> hello Packt</p>
<p>Now, we need to adjust the permission to limit the permission for testing purposes, which is shown as the following:</p>
<p class="source-code">sudo chown 2000:3000 /etc/message/message.txt</p>
<p class="source-code">sudo chmod 640 /etc/message/message.txt</p>
<p>Finally, we could deploy a new Pod in our current Kubernetes cluster to test it out. The <strong class="source-inline">securityContext</strong> field is defined as part of a Pod’s YAML spec called <strong class="source-inline">pod-permission.yaml</strong>. With a section called <strong class="source-inline">securityContext</strong>, we can specify the security permissions information, as in the following YAML file: </p>
<pre class="source-code">
  apiVersion: v1
  kind: Pod
  metadata:
    name: melon-securitycontext-pod
  spec:
<strong class="bold">    securityContext:</strong>
<strong class="bold">      runAsUser: 2000</strong>
<strong class="bold">      fsGroup: 3000</strong>
    containers:
    - name: melonapp-secret-container
      image: busybox
      command: ['sh', '-c','cat /message/message.txt &amp;&amp; sleep 3600']
      volumeMounts:
      - name: message-volume
        mountPath: /message
    volumes:
    - name: message-volume
      hostPath:
        path: /etc/message
  </pre>
<p>In the preceding YAML definition file, the <strong class="source-inline">runAsUser</strong> field means that for any container in this Pod, all processes run with a user ID of <strong class="source-inline">2000</strong>. The <strong class="source-inline">fsGroup</strong> field is <strong class="source-inline">2000</strong>, which means that all the processes of the container are also part of the supplementary group, <strong class="source-inline">ID 2000</strong>. The owner for volume/message and any files created in that volume will be the <strong class="source-inline">ID 2000</strong> group.</p>
<p>Let’s go ahead and deploy this YAML file as follows: </p>
<p class="source-code">kubectl apply -f pod-permission.yaml</p>
<p>Then, we’ll see the Pod is spinning up but will quickly encounter the following error: </p>
<p class="source-code">NAME                        READY   STATUS          RESTARTS    </p>
<p class="source-code">AGE</p>
<p class="source-code">melon-securitycontext-pod 0/1     <strong class="bold">CrashLoopBackOff</strong>   1 5m</p>
<p>From the preceding example, we can see the Pod is <strong class="source-inline">BackOff</strong> due to the lack of permission. Now, let’s pull a similar example to see whether we can fix this. Let’s configure a YAML file with a similar configuration to the following:</p>
<pre class="source-code">
securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000</pre>
<p>Let’s deploy this using the following YAML example: </p>
<pre class="source-code">
apiVersion: v1
kind: Pod
metadata:
  name: security-context-message
<strong class="bold">spec:</strong>
<strong class="bold">  securityContext:</strong>
<strong class="bold">    runAsUser: 1000</strong>
<strong class="bold">    runAsGroup: 3000</strong>
<strong class="bold">    fsGroup: 2000</strong>
  volumes:
  - name: sec-ctx-msg
    emptyDir: {}
  containers:
  - name: sec-ctx-msg
    image: busybox:1.28
    command: [ "sh", "-c", "sleep 1h" ]
    volumeMounts:
    - name: sec-ctx-msg
      mountPath: /message
    securityContext:
      allowPrivilegeEscalation: false</pre>
<p>We can see this example is now up and running in my local Kubernetes cluster: </p>
<p class="source-code">cloudmelon@cloudmelonplayground:/$ kubectl get pod security-context-demo</p>
<p class="source-code">NAME                    READY   STATUS    RESTARTS   AGE</p>
<p class="source-code">security-context-message  1/1     Running   0          3m4s</p>
<p>Let’s get inside this running pod:</p>
<p class="source-code">kubectl exec -it security-context-message -- sh</p>
<p>Then, we’ll get into the interactive shell, input <strong class="source-inline">id</strong>, and we’ll get the following output: </p>
<p class="source-code">/ $ id</p>
<p class="source-code">uid=1000 gid=3000 groups=2000</p>
<p>From the output, we can see that <strong class="source-inline">uid</strong> is <strong class="source-inline">1000</strong>, the same as the <strong class="source-inline">runAsUser</strong> field; the <strong class="source-inline">gid</strong> is <strong class="source-inline">3000</strong>, the same as the <strong class="source-inline">runAsGroup</strong> field; and the <strong class="source-inline">fsGroup</strong> is <strong class="source-inline">2000</strong>. </p>
<p>To learn <a id="_idIndexMarker500"/>more about the security context, check out the official documentation her<a id="_idTextAnchor224"/>e: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/">https://kubernetes.io/docs/tasks/configure-pod-container/security-context/</a></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor225"/>Summary</h1>
<p>This chapter gave an overview of Kubernetes security with a focus on three key topics about container security, RBAC, and the security context. You can use this chapter to assist you with laying the foundations for your CKS exam. With the addition of the next chapter, <em class="italic">Demystifying Kubernetes Networking</em>, you will get a complete view of working with Kubernetes networking security-related concepts and practice examples to help in your daily work as a Kubernetes administ<a id="_idTextAnchor226"/>rator, and this will all cover 20% of the CKA exam content. Let’s stay tuned! </p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor227"/>Mock CKA scenario-based practice test </h1>
<p>You have two virtual ma<a id="_idTextAnchor228"/>chines, <strong class="source-inline">master-0</strong> and <strong class="source-inline">worker-0</strong> – please complete the following mock scenarios. </p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor229"/>Scenario 1 </h2>
<p>Cr<a id="_idTextAnchor230"/>eate a new service account named <strong class="source-inline">packt-sa</strong> in a new namespace called <strong class="source-inline">packt-ns</strong>. </p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor231"/>Scenario 2</h2>
<p>Create a Role named <strong class="source-inline">packtrole</strong> and bind it with the RoleBinding <strong class="source-inline">packt-clusterbinding</strong>. Map the <strong class="source-inline">packt-sa</strong> service account with <strong class="source-inline">list</strong> and <strong class="source-inline">get</strong> permissions.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor232"/>Scenario 3 </h2>
<p>Create a new pod named <strong class="source-inline">packt-pod</strong> with the <strong class="source-inline">busybox:1.28</strong> image in the <strong class="source-inline">packt-ns</strong> namespace. Expose port <strong class="source-inline">80</strong>. Then, assign the <strong class="source-inline">packt-sa</strong> service account to t<a id="_idTextAnchor233"/>he Pod. </p>
<p>You can find all the scenario resolutions in <a href="B18201_Appendix_A.xhtml#_idTextAnchor386"><em class="italic">Appendix</em></a><em class="italic"> - Mock CKA scenario-based practice test resolutions</em> of this book.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor234"/>FAQs</h1>
<ul>
<li><em class="italic">Where can I find the latest updates about Kubernetes security while working with Kubernetes?</em> </li>
</ul>
<p>The Kubernetes Security <strong class="bold">Special Interest Group</strong> (<strong class="bold">SIG</strong>) has a GitHub repository, which you can find here: <a href="https://github.com/kubernetes/community/tree/master/sig-security">https://github.com/kubernetes/community/tree/master/sig-security</a>.</p>
<ul>
<li><em class="italic">What is the recommended Kubernetes official article for configuring the ephemeral storage?</em></li>
</ul>
<p>I recommend bookmarking the official documentation about Kubernetes RBAC, which you can find here: <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a>.</p>
</div>
</div></body></html>