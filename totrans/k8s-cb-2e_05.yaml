- en: Building Continuous Delivery Pipelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建持续交付管道
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Moving monolithic to microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体架构迁移到微服务
- en: Working with the private Docker registry
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与私有 Docker 注册表的配合
- en: Integrating with Jenkins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Jenkins 集成
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Kubernetes is a perfect match for applications featuring the microservices architecture.
    However, most of the old applications are built in the monolithic style. We will
    give you an idea about how to move from the monolithic to the microservices world.
    As for microservices, deployment will become a burden if you are doing it manually.
    We will learn how to build up our own continuous delivery pipeline by coordinating
    Jenkins, the Docker registry, and Kubernetes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 非常适合具有微服务架构的应用程序。然而，大多数旧应用程序是以单体式架构构建的。我们将给你一个关于如何从单体架构过渡到微服务世界的思路。至于微服务，如果你手动进行部署，它将变得很繁琐。我们将学习如何通过协调
    Jenkins、Docker 注册表和 Kubernetes 来构建自己的持续交付管道。
- en: Moving monolithic to microservices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体架构迁移到微服务
- en: Typically, application architecture is the monolithic design that contains a
    **Model-View- Controller** (**MVC**) and every component within a single, big
    binary. A monolithic design has some benefits, such as less latency within components,
    being all in one straightforward package, and being easy to deploy and test.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序架构是单体设计，包含 **模型-视图-控制器**（**MVC**）并将所有组件打包成一个大型二进制文件。单体设计有一些好处，例如组件之间的延迟较低，所有功能都在一个简单的包中，且容易部署和测试。
- en: However, a monolithic design has some downsides because the binary will be getting
    bigger and bigger. You always need to take care of the side effects when adding
    or modifying the code, therefore making release cycles longer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单体设计有一些缺点，因为二进制文件会变得越来越大。每次添加或修改代码时，你总是需要注意副作用，因此发布周期会变得更长。
- en: 'Containers and Kubernetes give more flexibility when using microservices for
    your application. The microservices architecture is very simple and can be divided
    into some modules or some service classes together with MVC:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器和 Kubernetes 在你的应用程序中使用微服务时提供了更多的灵活性。微服务架构非常简单，可以将其分为一些模块或一些服务类，并结合 MVC
    进行组织：
- en: '![](img/9459422c-7fe8-4107-9f7c-2d0718edd145.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9459422c-7fe8-4107-9f7c-2d0718edd145.png)'
- en: Monolithic and microservices design
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单体与微服务设计
- en: Each microservice provides a **Remote Procedure Call** (**RPC**) using RESTful
    or some standard network APIs to other microservices. The benefit is that each
    microservice is independent. There are minimal side effects when adding or modifying
    the code. Release the cycle independently, so it perfectly ties in with the Agile
    software development methodology and allows for the reuse of these microservices
    to construct another application that builds the microservices ecosystem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务通过 RESTful 或一些标准网络 API 提供 **远程过程调用**（**RPC**）给其他微服务。其好处在于每个微服务是独立的，添加或修改代码时副作用最小。可以独立发布周期，因此它与敏捷软件开发方法论完美契合，并允许这些微服务的重用来构建另一个应用程序，从而建立微服务生态系统。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Prepare the simple microservices program. In order to push and pull your microservices,
    please register to Docker hub ([https://hub.docker.com/](https://hub.docker.com/))
    to create your free Docker ID in advance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 准备简单的微服务程序。为了推送和拉取你的微服务，请提前注册 Docker hub ([https://hub.docker.com/](https://hub.docker.com/))
    并创建一个免费的 Docker ID。
- en: If you push the Docker image to Docker hub, it will be public; anyone can pull
    your image. Therefore, don't put any confidential information into the image.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 Docker 镜像推送到 Docker hub，它将是公开的；任何人都可以拉取你的镜像。因此，请不要将任何机密信息放入镜像中。
- en: 'Once you successfully log in to your Docker ID, you will be redirected to your
    Dashboard page as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你成功登录到 Docker ID，你将被重定向到你的 Dashboard 页面，如下所示：
- en: '![](img/2fa69dc3-7110-456f-9da3-b049acaa6b28.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fa69dc3-7110-456f-9da3-b049acaa6b28.png)'
- en: After logging in to Docker hub
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 登录 Docker hub 后
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Prepare both microservices and the frontend WebUI as a Docker image. Then, deploy
    them using the Kubernetes replication controller and service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好微服务和前端 WebUI 作为 Docker 镜像。然后，使用 Kubernetes 复制控制器和服务进行部署。
- en: Microservices
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'Build a microservice which provides a simple math function by using following
    steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤构建一个提供简单数学功能的微服务：
- en: 'Here is the simple microservice using Python `Flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/)):'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个使用 Python `Flask` 的简单微服务 ([http://flask.pocoo.org/](http://flask.pocoo.org/))：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Prepare a `Dockerfile` as follows in order to build the Docker image:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个如下所示的 `Dockerfile` 来构建 Docker 镜像：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, use the `docker build` command to build the Docker image as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `docker build` 命令构建 Docker 镜像，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, use the `docker login` command to log in to Docker hub:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `docker login` 命令登录到 Docker hub：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, use the `docker push` command to register to your Docker hub repository
    as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `docker push` 命令将镜像注册到您的 Docker hub 仓库，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Upon access to Docker hub, you can see your microservice in the repository:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Docker hub 后，您可以在仓库中看到您的微服务：
- en: '![](img/0126d63d-fb96-4007-aacc-43f4518fb247.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0126d63d-fb96-4007-aacc-43f4518fb247.png)'
- en: Your microservice Docker image on Docker hub
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您的微服务 Docker 镜像在 Docker hub 上
- en: Frontend WebUI
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端 WebUI
- en: 'Build WebUI that uses preceding microservice by following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建使用前述微服务的 WebUI：
- en: 'Here is the simple frontend WebUI that also uses Python `Flask`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个简单的前端 WebUI，它也使用 Python `Flask`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Kubernetes service generates the Kubernetes service name and port number as
    an environment variable to the other pods. Therefore, the environment variable's
    name and the Kubernetes service name must be consistent. In this scenario, the
    `my-calc` service name must be `my-calc-service`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务会生成 Kubernetes 服务名称和端口号作为环境变量，传递给其他 pods。因此，环境变量的名称和 Kubernetes
    服务名称必须一致。在这种情况下，`my-calc` 服务名称必须是 `my-calc-service`。
- en: 'The frontend WebUI uses the `Flask` HTML template; it is similar to PHP and
    JSP in that `entry.py` will pass the parameter to the template (`index.html`)
    to render the HTML:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端 WebUI 使用 `Flask` HTML 模板；它类似于 PHP 和 JSP，`entry.py` 会将参数传递给模板（`index.html`）以渲染
    HTML：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Dockerfile` is exactly the same as the microservice `my-calc`. So, eventually,
    the file structure will be as follows. Note that `index.html` is a jinja2 template
    file; therefore, put it under the `/templates` directory:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 与微服务 `my-calc` 完全相同。因此，最终，文件结构将如下所示。请注意，`index.html` 是一个 jinja2
    模板文件，因此将其放在 `/templates` 目录下：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, build a Docker image and push to Docker hub as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，构建 Docker 镜像并推送到 Docker hub，如下所示：
- en: In order to push your image to Docker hub, you need to log in using the Docker
    login command. It is needed only once; the system checks `~/.docker/config.json`
    to read from there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将您的镜像推送到 Docker hub，您需要使用 Docker 登录命令进行登录。只需要登录一次；系统会检查 `~/.docker/config.json`
    来读取凭证。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon access to Docker hub, you can see your WebUI application in the repository:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Docker hub 后，您可以在仓库中看到您的 WebUI 应用程序：
- en: '![](img/0c2579a3-2e7c-470e-a056-0ecec6d0a1ca.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c2579a3-2e7c-470e-a056-0ecec6d0a1ca.png)'
- en: Microservices and frontend WebUI image on Docker Hub
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和前端 WebUI 镜像在 Docker Hub 上
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Let's prepare two YAML configurations to launch a microservice container and
    frontend WebUI container using Kubernetes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备两个 YAML 配置文件，使用 Kubernetes 启动微服务容器和前端 WebUI 容器。
- en: Microservices
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'Microservices (`my-calc`) uses the Kubernetes deployment and service, but it
    needs to communicate to other pods only. In other words, there''s no need to expose
    it to the outside Kubernetes network. Therefore, the service type is set as `ClusterIP`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务（`my-calc`）使用 Kubernetes 部署和服务，但它只需要与其他 pod 进行通信。换句话说，不需要将其暴露到外部 Kubernetes
    网络中。因此，服务类型设置为 `ClusterIP`：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `kubectl` command to load the `my-calc` pods as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 命令加载 `my-calc` pod，如下所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Frontend WebUI
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端 WebUI
- en: 'Frontend WebUI also uses the deployment and service, but it exposes the port
    (TCP port `30080`) in order to access it from an external web browser:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前端 WebUI 也使用部署和服务，但它暴露端口（TCP 端口 `30080`），以便从外部网页浏览器访问：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s try to access `my-frontend-service` using a web browser. You can access
    any Kubernetes node''s IP address; specify the port number 30080\. If you are
    using minikube, simply type `minikube service my-frontend-service` to access.
    Then you can see the `my-frontend `application as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用网页浏览器访问 `my-frontend-service`。您可以访问任何 Kubernetes 节点的 IP 地址；指定端口号 30080。如果您使用的是
    minikube，只需输入 `minikube service my-frontend-service` 进行访问。然后，您可以看到 `my-frontend`
    应用程序，如下所示：
- en: '![](img/c7aed4df-0a7b-4e57-812a-91e75552352e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7aed4df-0a7b-4e57-812a-91e75552352e.png)'
- en: Access to the frontend WebUI
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 访问前端 WebUI
- en: 'When you click on the addition button, it will forward a parameter to microservices
    (`my-calc`). Microservices compute the addition (yes, just an addition!) and then
    return the result back to the frontend WebUI as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击加号按钮时，它将参数传递给微服务（`my-calc`）。微服务计算加法（没错，就是加法！），然后将结果返回到前端 WebUI，如下所示：
- en: '![](img/75836636-1a08-480c-8683-294f03a36740.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75836636-1a08-480c-8683-294f03a36740.png)'
- en: Getting a result from microservices and rendering the HTML
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从微服务中获取结果并渲染 HTML
- en: 'So now, it is easy to scale the pod for the frontend WebUI and microservices
    independently. For example, scale WebUI pod from `2` to `8` and microservice pod
    from `2` to `16`, as shown:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，可以独立地扩展前端 WebUI 和微服务的 Pod。例如，将 WebUI Pod 从 `2` 扩展到 `8`，将微服务 Pod 从 `2` 扩展到
    `16`，如图所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, if there's a need to fix some bugs, for example, if there's a frontend
    need to validate
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要修复一些 bug，例如，如果前端需要进行验证
- en: the input parameter to check whether it is numeric or a string (yes, if you
    type string and
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数以检查它是数字还是字符串（是的，如果您输入字符串并
- en: then submit, it will show an error!), it will not affect the build and deploy
    the cycle against
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后提交，它会显示错误！），它不会影响构建和部署周期。
- en: 'microservices:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务：
- en: '![](img/085ae157-527d-4a9f-b15d-174e0acfe8b0.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/085ae157-527d-4a9f-b15d-174e0acfe8b0.png)'
- en: Frontend and microservice pods and services
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和微服务 Pod 和服务
- en: In addition, if you want to add another microservice, for example, subtraction
    microservices, you may need to create another Docker image and deploy with another
    deployments and service, so it will be independent from the current microservices. Then,
    you can keep accumulating your own microservice ecosystem to reuse in another
    application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想添加另一个微服务，例如减法微服务，您可能需要创建另一个 Docker 镜像，并使用另一个部署和服务进行部署，这样它将与当前的微服务独立。然后，您可以不断积累自己的微服务生态系统，以便在其他应用程序中重用。
- en: Working with the private Docker registry
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私有 Docker 注册表
- en: Once you start to build your microservice application via Docker, you'll need
    to have a Docker registry to put your container image in. Docker hub offers you
    free public repositories, however, in some cases you might want to make your image
    private due to business needs or organization policy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始通过 Docker 构建微服务应用程序，您将需要一个 Docker 注册表来存放您的容器镜像。Docker hub 为您提供免费的公共仓库，但在某些情况下，由于业务需求或组织政策，您可能希望将您的镜像设为私有。
- en: 'Docker hub offers the **private repository**, which only allows authenticated
    users to push and pull your images, and is not visible to other users. However,
    there is only one quota (repository) for a free plan. You may pay to increase
    the number of private repositories, but if you adopt the microservices architecture,
    you will need a large number of private repositories:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker hub 提供**私有仓库**，仅允许经过身份验证的用户推送和拉取您的镜像，并且对其他用户不可见。然而，免费计划只有一个配额（仓库）。您可以付费增加私有仓库的数量，但如果您采用微服务架构，您将需要大量的私有仓库：
- en: '![](img/f17ae140-cc38-4932-95b1-cfadf4a27a26.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f17ae140-cc38-4932-95b1-cfadf4a27a26.png)'
- en: Docker hub private repositories price list
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Docker hub 私有仓库价格表
- en: Docker hub with a paid plan is the easiest way to set up your private registry,
    but there are some other ways to set up your own private Docker registry, which
    the unlimited Docker image quota locates inside your network. In addition, you
    can also use other cloud-provided registry services to manage your private registry.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用付费计划的 Docker hub 是设置私有注册表的最简单方式，但也有一些其他方法可以设置自己的私有 Docker 注册表，且不受限制的 Docker
    镜像配额位于您的网络内。此外，您还可以使用其他云提供的注册表服务来管理您的私有注册表。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will show you three different ways to set up your own private
    registries:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将向您展示设置自己私有注册表的三种不同方式：
- en: Using Kubernetes to run a private registry image ([https://hub.docker.com/_/registry/](https://hub.docker.com/_/registry/))
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 运行私有注册表镜像 ([https://hub.docker.com/_/registry/](https://hub.docker.com/_/registry/))
- en: Using Amazon elastic container registry ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/))
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon 弹性容器注册表 ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/))
- en: Using Google container registry ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/))
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google 容器注册表 ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/))
- en: When using a Kubernetes to set up a private registry, you may use your own Kubernetes
    cluster on the private or public cloud, which allows you to have full control
    and utilize most of your physical resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 设置私有注册表时，您可以使用您自己的 Kubernetes 集群，无论是在私有云还是公共云中，这样您可以完全控制并利用大部分物理资源。
- en: On the other hand, when using a public cloud-provided service, such as AWS or
    GCP, you can be relieved of the management of servers and storage. Whatever you
    need, those public clouds provide you with elastic resources. We'll just have
    to set the credentials to Kubernetes and let the nodes know. The following recipes
    will go through these three different options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用公共云提供的服务，如 AWS 或 GCP 时，你可以省心地管理服务器和存储。无论你需要什么，这些公共云都为你提供弹性资源。我们只需要将凭据设置到
    Kubernetes 并让节点知晓。接下来的几种方案将介绍这三种不同的选择。
- en: Using Kubernetes to run a Docker registry server
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 运行 Docker 注册表服务器
- en: If you want to launch a private registry server using Kubernetes, you need your
    own Kubernetes cluster. You will have set up your own Kubernetes while exploring
    this book. If you haven't done yet, please read [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building Your Own Kubernetes Cluster*, to choose the easiest way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Kubernetes 启动一个私有注册表服务器，你需要有自己的 Kubernetes 集群。在本书的学习过程中，你将设置自己的 Kubernetes。如果你还没有设置，请阅读[第一章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)《*构建你的
    Kubernetes 集群*》，选择最简单的方式。
- en: Please note that Docker registry will store some of your Docker images. You
    must have a `PersistentVolume` to manage your storage via Kubernetes. In addition,
    we should expect that multiple pods will read and write to the same `PersistentVolume`
    due to scalability. Therefore, you must have the **ReadWriteMany** (**RWX**)access
    mode of `PersistentVolume`, such as GlusterFS or NFS.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker 注册表会存储一些你的 Docker 镜像。你必须有一个 `PersistentVolume` 来通过 Kubernetes 管理存储。此外，由于可扩展性，我们应该预期多个
    Pod 会同时读取和写入同一个 `PersistentVolume`。因此，你必须拥有 `PersistentVolume` 的 **ReadWriteMany**
    (**RWX**) 访问模式，例如 GlusterFS 或 NFS。
- en: 'Details of `PersistentVolume` are described in the *Working with volumes* section
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*. Let''s create a `PersistentVolume` that uses NFS and the name `pvnfs01`
    to allocate `100` GB:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistentVolume` 的详细信息在[第二章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)《*深入理解
    Kubernetes 概念*》的 *工作与卷* 部分进行了描述。我们来创建一个使用 NFS 的 `PersistentVolume`，名称为 `pvnfs01`，并分配
    `100` GB：'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you can''t prepare RWX `PersistentVolume`, you may still be able to set
    up Docker registry by Kubernetes, but you can launch only one pod (replicas: one).
    As an alternative, you may use AWS S3 or GCP PD as private registry backend storage;
    please visit [https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)
    to learn how to configure backend storage for your registry.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法准备 RWX `PersistentVolume`，你仍然可以通过 Kubernetes 设置 Docker 注册表，但你只能启动一个 Pod（副本数：1）。作为替代，你可以使用
    AWS S3 或 GCP PD 作为私有注册表的后端存储；请访问 [https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)
    了解如何为你的注册表配置后端存储。
- en: 'Next, create `PersistentVolumeClaim` that decouples NFS `PersistentVolume`
    and pod configuration. Let''s create one `PersistentVolumeClaim` named `pvc-1`. Make
    sure `accessModes` is `ReadWriteMany` and that `STATUS` became `Bound` after creation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `PersistentVolumeClaim`，它将 NFS `PersistentVolume` 和 Pod 配置解耦。我们来创建一个名为
    `pvc-1` 的 `PersistentVolumeClaim`。确保 `accessModes` 设置为 `ReadWriteMany`，并且在创建后
    `STATUS` 变为 `Bound`：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is enough to set up your private registry. It has some prerequisites; alternatively,
    using the public cloud is much simpler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足以设置你的私有注册表了。它有一些前提条件；作为替代，使用公共云则简单得多。
- en: Using Amazon elastic container registry
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Amazon 弹性容器注册表
- en: Amazon **elastic container registry** (**ECR**) was introduced as a part of
    Amazon **elastic container service** (**ECS**). This recipe won't touch on ECS
    itself; instead, just use ECR as a private registry.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon **弹性容器注册表** (**ECR**) 是作为 Amazon **弹性容器服务** (**ECS**) 的一部分推出的。本方案不会涉及
    ECS 本身；我们只是使用 ECR 作为私有注册表。
- en: 'In order to use Amazon ECR, you have to have an AWS account and install AWS
    CLI on your machine. It will be described in more detail in [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS. *You''ll have to create an IAM user with `ACCESS
    KEY ID` and `SECRET ACCESS KEY`, and associated `AmazonEC2ContainerRegistryFullAccess` policies,
    which allow full administrator access to Amazon ECR:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Amazon ECR，你必须拥有 AWS 账户并在你的机器上安装 AWS CLI。具体步骤将在[第六章](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml)《*在
    AWS 上构建 Kubernetes*》中详细说明。你需要创建一个 IAM 用户，拥有 `ACCESS KEY ID` 和 `SECRET ACCESS KEY`，并且关联
    `AmazonEC2ContainerRegistryFullAccess` 策略，这将授予你对 Amazon ECR 的完全管理员访问权限：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then configure the default settings in AWS CLI via the `aws configure` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过 `aws configure` 命令配置 AWS CLI 的默认设置：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then we can start to play with Amazon ECR.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以开始使用 Amazon ECR。
- en: Using Google cloud registry
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google云注册表
- en: '**Google container registry** ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/))
    is a part of the GCP. Similar to AWS, having a GCP account is required, as well
    as Cloud SDK ([https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)),
    which is the command-line interface in GCP. More details about GCP will be described
    in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml), *Building Kubernetes
    on GCP*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google容器注册表**（[https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/)）是GCP的一部分。与AWS类似，使用GCP账户是必需的，还需要Cloud
    SDK（[https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)），它是GCP中的命令行界面。关于GCP的更多细节将在[第7章](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml)中介绍，*在GCP上构建Kubernetes*。'
- en: 'On GCP, we''ll just need to create a project and enable billing and the container
    registry API for our project. Otherwise, any operation in `gcloud` will display
    an error:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCP上，我们只需要创建一个项目并为项目启用计费和容器注册表API。否则，任何在`gcloud`中的操作都会显示错误：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In order to enable billing and container registry API, visit the GCP web console
    ([https://console.cloud.google.com](https://console.cloud.google.com)), navigate
    to the billing page and container registry page, then just enable those. Once
    activation is done, you can use the `gcloud container` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用计费和容器注册表API，访问GCP Web控制台（[https://console.cloud.google.com](https://console.cloud.google.com)），导航到计费页面和容器注册表页面，然后启用这些功能。激活完成后，你可以使用`gcloud
    container`命令：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we can start to use Google container registry.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始使用Google容器注册表了。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We have set up the preparation steps. Let's see how to configure your private
    registry step by step.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了准备步骤。接下来，让我们一步一步地看看如何配置你的私有注册表。
- en: Launching a private registry server using Kubernetes
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes启动私有注册表服务器
- en: 'In order to launch a private registry, it is necessary to configure these files
    in order to configure a private registry with appropriate security settings:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动私有注册表，需要配置这些文件，以便使用适当的安全设置配置私有注册表：
- en: SSL certificate
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL证书
- en: HTTP secret
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP密钥
- en: HTTP basic authentication file
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP基本认证文件
- en: Creating a self-signed SSL certificate
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自签名的SSL证书
- en: There is a pitfall—people tend to set up a plain HTTP (disable TLS) registry
    without authentication in the beginning. Then it also needs to configure a Docker
    client (Kubernetes node) to allow an insecure registry and so on. It is a bad
    practice that requires many steps to set up an insecure environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个陷阱——人们往往在开始时设置一个没有身份验证的纯HTTP（禁用TLS）注册表。然后还需要配置Docker客户端（Kubernetes节点），允许不安全的注册表等。这是一种不良做法，设置一个不安全环境需要很多步骤。
- en: 'The best practice is always using the official SSL certificate that is issued
    by the certificate authority. However, a self-signed certificate is always handy,
    especially in the testing phase. An official certificate can wait until we have
    FQDN defined. Therefore, this recipe will show you how to use OpenSSL to create
    a self-signed SSL certificate via the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是始终使用由证书授权机构颁发的官方SSL证书。然而，自签名证书总是非常方便，特别是在测试阶段。官方证书可以等到我们定义了FQDN后再使用。因此，本教程将向你展示如何使用OpenSSL通过以下步骤创建自签名的SSL证书：
- en: 'Create a `secrets` directory:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`secrets`目录：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the `openssl` command to specify the options to generate a certificate
    (`domain.crt`) and a private key (`domain.key`) under the secrets directory. Note
    that you may type `.` to skip to input location and email info:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`openssl`命令，指定选项生成证书（`domain.crt`）和私钥（`domain.key`），并将其保存在secrets目录下。注意，你可以输入`.`跳过输入位置和电子邮件信息：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check whether both certificate and private keys are generated under the `secrets`
    directory:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`secrets`目录下是否生成了证书和私钥：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating HTTP secret
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTTP密钥
- en: 'Regarding HTTP secret, it will be randomly generated by the private registry
    instance upon startup by default. However, it is a problem if you run multiple
    pods, because each pod may have a different HTTP secret that occur an error when
    Docker client push or pull the image. So we explicitly state that all pods will
    use the same HTTP secret, via the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HTTP密钥，它将在默认情况下由私有注册表实例在启动时随机生成。然而，如果你运行多个pod，这就成了一个问题，因为每个pod可能有不同的HTTP密钥，导致Docker客户端推送或拉取镜像时出现错误。所以我们明确声明，所有pod将使用相同的HTTP密钥，方法如下：
- en: 'Use the `openssl` command to create a `http.secret` file under the `secrets`
    directory:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`openssl`命令在`secrets`目录下创建`http.secret`文件：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Check the `secrets` directory, which has three files now:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`secrets`目录，目前该目录下有三个文件：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating the HTTP basic authentication file
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTTP基本认证文件
- en: 'Finally, regarding the HTTP basic authentication file, if you set up a private
    registry, authentication is needed when you interact with the Docker registry.
    You''ll have to do `docker login` to get a token when pushing and pulling images.
    In order to create an HTTP basic authentication file, use the `htpasswd` command
    that is provided by Apache2 as this is easiest. Let''s create a HTTP basic authentication
    file via the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于HTTP基本认证文件，如果你设置了私有仓库，交互时需要进行身份验证。你必须执行`docker login`以获取令牌，才能在推送和拉取镜像时使用。为了创建HTTP基本认证文件，使用由Apache2提供的`htpasswd`命令，因为这是最简单的。让我们通过以下步骤创建一个HTTP基本认证文件：
- en: 'Run Docker with Apache2 Docker image (`httpd`) to run the `htpasswd` command
    with the `bcrypt` (`-B`) option and generate a basic authentication file (`registry_passwd`)
    under the `secrets` directory:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Apache2 Docker镜像（`httpd`）运行Docker，执行`htpasswd`命令并使用`bcrypt`（`-B`）选项生成基本认证文件（`registry_passwd`），该文件将位于`secrets`目录下：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check the `secrets` directory so that now you have four files:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`secrets`目录，此时你应该有四个文件：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a Kubernetes secret to store security files
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Kubernetes密钥以存储安全文件
- en: 'There are four files. We use **Kubernetes Secret** so that all pods can access
    it via an environment variable or mount a volume and access as a file. For more
    details about secrets, please refer to the *Working with secrets* section in [Chapter
    2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes Concepts*.
    You can use the `kubectl` command to load these four files to store to the Kubernetes
    secret via the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 共有四个文件。我们使用**Kubernetes Secret**，使所有Pod能够通过环境变量访问，或者挂载卷并将其作为文件访问。有关密钥的更多详情，请参阅[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)《Kubernetes概念详解》中的*与密钥配合使用*部分。你可以使用`kubectl`命令通过以下步骤将这四个文件加载到Kubernetes密钥中：
- en: 'Run the `kubectl create` command with the `--from-file` parameter to specify
    the secrets directory:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`kubectl create`命令，并使用`--from-file`参数指定密钥目录：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check the status via the `kubectl describe` command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`kubectl describe`命令检查状态：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Configuring a private registry to load a Kubernetes secret
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置私有仓库以加载Kubernetes密钥
- en: 'On the other hand, the private registry itself supports reading the HTTP secret
    as an environment variable in string format. It also can support specifying the
    file path for the SSL certificate and HTTP basic authentication file as environment
    variables:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，私有仓库本身支持将HTTP密钥作为字符串格式的环境变量读取。它还可以支持将SSL证书和HTTP基本认证文件的文件路径指定为环境变量：
- en: '| **Environment variable name** | **Description** | **Sample value** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **环境变量名称** | **描述** | **示例值** |'
- en: '| `REGISTRY_HTTP_SECRET` | HTTP secret string | `valueFrom`:    `secretKeyRef:`` 
          name: registry-secrets``        key: http.secret` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_SECRET` | HTTP密钥字符串 | `valueFrom`: `secretKeyRef:` `name:
    registry-secrets` `key: http.secret` |'
- en: '| `REGISTRY_HTTP_TLS_CERTIFICATE` | File path for certificate  (`domain.crt`)
    | `/mnt/domain.crt` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_TLS_CERTIFICATE` | 证书文件路径（`domain.crt`） | `/mnt/domain.crt`
    |'
- en: '| `REGISTRY_HTTP_TLS_KEY` | File path for private key (`domain.key`) | `/mnt/domain.key`
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_TLS_KEY` | 私钥文件路径（`domain.key`） | `/mnt/domain.key` |'
- en: '| `REGISTRY_AUTH_HTPASSWD_REALM` | The realm in which the registry server authenticates
    | `basic-realm` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_AUTH_HTPASSWD_REALM` | 注册表服务器进行身份验证的领域 | `basic-realm` |'
- en: '| `REGISTRY_AUTH_HTPASSWD_PATH` | File path for `htpasswd` file (`registry_passwd`)
    | `/mnt/registry_passwd` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_AUTH_HTPASSWD_PATH` | `htpasswd`文件路径（`registry_passwd`） | `/mnt/registry_passwd`
    |'
- en: '| `REGISTRY_HTTP_HOST` | Specify one of Kubernetes node IP and `nodePort` |
    `10.138.0.3:30500` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_HOST` | 指定Kubernetes节点的IP和`nodePort` | `10.138.0.3:30500`
    |'
- en: Ideally, you should have a load balancer and set up a Kubernetes Service type
    as `LoadBalancer`. And then `REGISTRY_HTTP_HOST` could be the load balancer IP
    and port number. For simplicity, we'll just use `NodePort` in this recipe. For
    more information about `LoadBalancer`, refer to the *Working with services* section
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*, and the *Forwarding container ports* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该有一个负载均衡器，并将Kubernetes服务类型设置为`LoadBalancer`。然后`REGISTRY_HTTP_HOST`可以是负载均衡器的IP和端口号。为了简便起见，本示例中我们将使用`NodePort`。有关`LoadBalancer`的更多信息，请参阅[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)《Kubernetes概念详解》中的*与服务配合使用*部分，以及[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)《玩转容器》中的*转发容器端口*部分。
- en: 'We''ll conduct a deployment to a Kubernetes YAML file for creating a registry,
    and include the preceding variables inside it, so the registry pods can use them. Now
    we have `PersistentVolumeClaim` as `pvc-1` that supplies the container image store,
    and mounts SSL certificate files (`domain.crt` and `domain.key`) and an HTTP basic
    authentication file (`registry_passwd`) via Secret `registry-secrets`. As well
    as reading the HTTP Secret string as an environment variable by Secret `registry-secrets`.
     The entire YAML configuration is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一个部署到 Kubernetes YAML 文件中，以创建一个注册表，并将前面的变量包含在其中，这样注册表的 Pod 就可以使用它们。现在我们有
    `PersistentVolumeClaim` 作为 `pvc-1`，它为容器镜像存储提供支持，并通过 Secret `registry-secrets`
    挂载 SSL 证书文件（`domain.crt` 和 `domain.key`）以及 HTTP 基本认证文件（`registry_passwd`）。还通过
    Secret `registry-secrets` 读取 HTTP Secret 字符串作为环境变量。整个 YAML 配置如下：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now your own private registry is ready to use!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你自己的私有注册表已经准备好使用了！
- en: Create a repository on the AWS elastic container registry
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 弹性容器注册表上创建仓库
- en: 'In order to push a container image to Amazon ECR, you need to create a repository
    beforehand. Unlike Docker hub or private registry, Amazon ECR doesn''t create
    a repository automatically when it is the first time to push the image. Therefore,
    if you want to push three container images, you have to create three repositories
    in advance:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将容器镜像推送到 Amazon ECR，你需要提前创建一个仓库。与 Docker Hub 或私有注册表不同，Amazon ECR 在第一次推送镜像时不会自动创建仓库。因此，如果你想推送三个容器镜像，你需要提前创建三个仓库：
- en: 'It is simple to type the `aws ecr create-repository` command to specify the
    repository name:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `aws ecr create-repository` 命令来指定仓库名称是很简单的：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's it! You need to remember the `repositoryUri` (in the previous case, `************.dkr.ecr.us-east-1.amazonaws.com/my-nginx`) that
    will be used as the private image URL.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你需要记住 `repositoryUri`（在前面的例子中是 `************.dkr.ecr.us-east-1.amazonaws.com/my-nginx`），它将作为私有镜像
    URL 使用。
- en: The previous URL is masked as an ID as `************`. It is tied with your
    AWS account ID.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 URL 被掩码为 ID `************`，它与您的 AWS 账户 ID 绑定。
- en: 'On the other hand, if you see something like the following error message, your
    IAM user doesn''t have the permission of the `CreateRepository` operation. In
    this case, you need to attach an IAM policy from `AmazonEC2ContainerRegistryFullAccess`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你看到如下错误信息，说明你的 IAM 用户没有 `CreateRepository` 操作的权限。在这种情况下，你需要附加 `AmazonEC2ContainerRegistryFullAccess`
    的 IAM 策略：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Determining your repository URL on Google container registry
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定在 Google 容器注册表上的仓库 URL
- en: 'In order to push a container image to Google container registry, there is an
    important consideration regarding the repository URL. First of all, there are
    several Google container registry region hosts available:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将容器镜像推送到 Google 容器注册表，需要考虑仓库 URL 的一个重要问题。首先，有多个 Google 容器注册表区域主机可用：
- en: '`gcr.io` (currently USA region)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcr.io`（当前为美国地区）'
- en: '`us.gcr.io` (USA region)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us.gcr.io`（美国地区）'
- en: '`eu.gcr.io` (Europe region)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eu.gcr.io`（欧洲地区）'
- en: '`asia.gcr.io` (Asia region)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asia.gcr.io`（亚洲地区）'
- en: Note that these region hosts are network latency purpose, doesn't mean to restrict
    to a particular region. They are still accessible worldwide.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些区域主机是为了网络延迟优化，并不意味着限制在特定区域内。它们在全球范围内仍然可访问。
- en: 'Second of all, while you tag the container image, you also need to specify
    your `project-id` on which you''ve enabled billing and API. Therefore, the entire
    repository URL could be:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在为容器镜像打标签时，你还需要指定你已启用计费和 API 的 `project-id`。因此，整个仓库 URL 可能是：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In my case, I used the region USA default, the project ID is `kubernetes-cookbook`,
    and the image name is `my-nginx`; therefore, my repository URL is:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，我使用了默认的美国区域，项目 ID 为 `kubernetes-cookbook`，镜像名称为 `my-nginx`；因此，我的仓库 URL
    是：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Other than that, Google container registry is ready to use now!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Google 容器注册表现在已准备就绪！
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you start to use private registry with Kubernetes, you must configure a
    credential properly. Amazon ECR and Google cloud registry need special consideration.
    Let's configure a credential for private registry, Amazon ECR and Google cloud
    registry.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在 Kubernetes 中使用私有注册表时，必须正确配置凭证。Amazon ECR 和 Google Cloud 注册表需要特别的考虑。让我们为私有注册表、Amazon
    ECR 和 Google Cloud 注册表配置凭证。
- en: Push and pull an image from your private registry
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从你的私有注册表推送和拉取镜像
- en: 'Now you can push your container image to your private registry. Because we
    have set up an HTTP basic authentication, you need to do `docker login` first.
    Otherwise you get a `no basic auth credentials` error:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将容器镜像推送到你的私有仓库。因为我们已经设置了 HTTP 基本认证，所以需要先进行 `docker login`。否则，你会遇到 `no basic
    auth credentials` 错误：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Therefore, you need `docker login` to specify the username and password, which
    you set onto the `registry_passwd` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要使用 `docker login` 来指定用户名和密码，这些密码会被设置到 `registry_passwd` 文件中：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On the other hand, as for pulling an image from a private registry, Kubernetes
    nodes also needs to have a credential for your private registry. But using the `docker
    login` command on every node is not realistic. Instead, Kubernetes supports storing
    this credential as a Kubernetes secret and each node will use this credential
    while pulling an image.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于从私有仓库拉取镜像，Kubernetes 节点也需要为你的私有仓库提供凭证。但在每个节点上使用 `docker login` 命令并不现实。相反，Kubernetes
    支持将凭证存储为 Kubernetes 秘密，并且每个节点在拉取镜像时都会使用这些凭证。
- en: 'To do that, we need to create a `docker-registry` resource that needs to specify:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要创建一个 `docker-registry` 资源，该资源需要指定：
- en: '`--docker-server`: In this example, `10.138.0.3:30500`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-server`：在本示例中，`10.138.0.3:30500`'
- en: '`--docker-username`: In this example, `user01`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-username`：在本示例中，`user01`'
- en: '`--docker-password`: In this example, `my-super-secure-password`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-password`：在本示例中，`my-super-secure-password`'
- en: '`--docker-email`: Your email address'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-email`：你的电子邮件地址'
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, you can pull your private image from the private registry that is
    specifying the `my-private-credential` secret. To do that, set `spec.imagePullSecrets`
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以从指定 `my-private-credential` 秘密的私有仓库中拉取私有镜像。为此，设置 `spec.imagePullSecrets`
    如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Congratulations! Now you can feel free to push your private images to your private
    registry run by Kubernetes. Also, pull an image from Kubernetes too. At any time,
    you can scale out based on client traffic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你可以自由地将私有镜像推送到由 Kubernetes 运行的私有仓库中。同时，也可以从 Kubernetes 中拉取镜像。在任何时候，你都可以根据客户端流量进行横向扩展。
- en: Push and pull an image from Amazon ECR
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Amazon ECR 推送和拉取镜像
- en: 'Amazon ECR has an authentication mechanism to provide access to your private
    repositories. AWS CLI has a functionality to generate an access token using the `aws
    ecr get-login` command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECR 具有身份验证机制，用于提供对私有仓库的访问。AWS CLI 提供了一个功能，可以通过 `aws ecr get-login` 命令生成访问令牌：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It outputs the `docker login` command with the ID and password:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它会输出带有 ID 和密码的 `docker login` 命令：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Therefore, just copy and paste to your terminal to acquire a token from AWS.
    Then try `docker push` to upload your Docker image to ECR:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需将命令复制并粘贴到终端中，即可从 AWS 获取令牌。然后尝试使用 `docker push` 将 Docker 镜像上传到 ECR：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the other hand, pulling an image from ECR to Kubernetes follows exactly
    the same steps as the private registry that uses a Kubernetes secret to store
    the token:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，从 ECR 拉取镜像到 Kubernetes 的步骤与使用 Kubernetes 秘密存储令牌的私有仓库完全相同：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, `spec.imagePullSecrets` needs to specify `my-ecr-secret`. As well as the
    image URL, it also specifies the ECR repository:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`spec.imagePullSecrets` 需要指定 `my-ecr-secret`。除了镜像 URL，它还指定了 ECR 仓库：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that this token is short-lived: it''s valid up to 12 hours. So, 12 hours
    later, you need to run `aws ecr get-login` again to acquire a new token, then
    update the secret `my-ecr-secret`. It is absolutely not ideal to do this.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个令牌是短期有效的：它的有效期为 12 小时。因此，12 小时后，你需要再次运行 `aws ecr get-login` 来获取新的令牌，然后更新
    `my-ecr-secret` 秘密。这样做显然不是最理想的。
- en: The good news is that Kubernetes supports the updating of the ECR token automatically
    via `CloudProvider`. However, it requires that your Kubernetes runs on an AWS
    environment such as EC2\. In addition, the EC2 instance has to have an IAM role
    that is equivalent or higher than the `AmazonEC2ContainerRegistryReadOnly` policy.
    It will be described in [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Kubernetes 支持通过 `CloudProvider` 自动更新 ECR 令牌。然而，它要求你的 Kubernetes 运行在 AWS
    环境中，如 EC2 实例上。此外，EC2 实例需要拥有与 `AmazonEC2ContainerRegistryReadOnly` 策略相同或更高权限的 IAM
    角色。这将在 [第6章](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml) 中描述，*在 AWS 上构建 Kubernetes*。
- en: If you really want to use your Kubernetes cluster outside of AWS by pulling
    an image from the ECR repository, there is a challenge in that you need to update
    the ECR token every 12 hours. Maybe you can do this using a cron job or by adopting
    some automation tools.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想在 AWS 之外使用 Kubernetes 集群，通过从 ECR 仓库拉取镜像，面临的挑战是你需要每 12 小时更新一次 ECR 令牌。也许你可以通过定时任务（cron
    job）或者采用一些自动化工具来实现这一点。
- en: For more detail, please visit the AWS online document at [https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多详情，请访问 AWS 在线文档 [https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html)。
- en: Push and pull an image from Google cloud registry
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Google 云注册表推送和拉取镜像
- en: According to GCP documentation ([https://cloud.google.com/container-registry/docs/advanced-authentication](https://cloud.google.com/container-registry/docs/advanced-authentication)),
    there are several way to push/pull to a container registry.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 GCP 文档 ([https://cloud.google.com/container-registry/docs/advanced-authentication](https://cloud.google.com/container-registry/docs/advanced-authentication))，有几种方法可以推送/拉取到容器注册表。
- en: Using gcloud to wrap the Docker command
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 gcloud 封装 Docker 命令
- en: 'The `gcloud` command has a wrapper function to run a `docker` command to push
    and pull. For example, if you want to push the image `gcr.io/kubernetes-cookbook/my-nginx`,
    use the `gcloud` command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcloud` 命令具有一个封装功能，可以运行 `docker` 命令来推送和拉取。例如，如果你想推送镜像 `gcr.io/kubernetes-cookbook/my-nginx`，可以使用
    `gcloud` 命令：'
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is sufficient to push the image from your machine, however, it is not ideal
    if you integrate with Kubernetes. This is because it is not easy to wrap the `gcloud`
    command on the Kubernetes node.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的机器推送镜像已足够，但如果与 Kubernetes 集成则不理想。这是因为在 Kubernetes 节点上封装 `gcloud` 命令并不容易。
- en: Fortunately, there is a solution that creates a GCP service account and grants
    a permission (role) to it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个解决方案可以创建一个 GCP 服务账户并授予它权限（角色）。
- en: Using the GCP service account to grant a long-lived credential
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GCP 服务账户授予长期凭证
- en: 'We need to integrate to pull an image from the Kubernetes node, which requires
    a long-lived credential that can be stored to the Kubernetes secret. To do that,
    perform the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要集成以从 Kubernetes 节点拉取镜像，这需要一个长期凭证，可以将其存储到 Kubernetes 密钥中。为此，请执行以下步骤：
- en: 'Create a GCP service account (`container-sa`):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 GCP 服务账户（`container-sa`）：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assign `container-sa` (use full name) to the `roles/storage.admin` role:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `container-sa`（使用全名）分配给 `roles/storage.admin` 角色：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Generate a key file (`container-sa.json`) for `container-sa`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `container-sa` 生成一个密钥文件 (`container-sa.json`)：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use `docker login` to check whether the key file is working or not:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker login` 检查密钥文件是否有效：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Use `docker pull` to check whether you can pull from container registry or
    not:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `docker pull` 检查是否可以从容器注册表拉取：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Looks all fine! Now you can use the Kubernetes secret the exact same way with
    the private registry or AWS ECR.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很完美！现在你可以像使用私人注册表或 AWS ECR 一样使用 Kubernetes 密钥。
- en: 'Create a Kubernetes secret (`my-gcr-secret`) to specify `_json_key` and `container-sa.json`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Kubernetes 密钥 (`my-gcr-secret`)，以指定 `_json_key` 和 `container-sa.json`：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Specify `my-gcr-secret` to `imagePullSecrets` to launch a pod:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `my-gcr-secret` 指定给 `imagePullSecrets` 以启动一个 pod：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Congratulations! Now you can use Google container registry for your private
    registry that is fully managed by GCP. And Kubernetes can pull your private image
    from there.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你可以使用 Google 容器注册表作为完全由 GCP 管理的私人注册表，Kubernetes 可以从那里拉取你的私人镜像。
- en: Integrating with Jenkins
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Jenkins 集成
- en: In software engineering, **continuous integration** (**CI**) ([https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration))
    and **continuous delivery** (**CD**) ([https://en.wikipedia.org/wiki/Continuous_delivery](https://en.wikipedia.org/wiki/Continuous_delivery)),
    abbreviated as CI/CD, have the ability to simplify the procedure of the traditional
    development process with continuous developing, testing, and delivering mechanisms
    in order to reduce the panic of serious conflict, namely, to deliver small changes
    one at a time and to narrow down the problems immediately, if any. Furthermore,
    through automatic tools, a product delivered by the CI/CD system can achieve better
    efficiency and shorten time-to-market.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，**持续集成**（**CI**） ([https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration))
    和 **持续交付**（**CD**） ([https://en.wikipedia.org/wiki/Continuous_delivery](https://en.wikipedia.org/wiki/Continuous_delivery))，简称
    CI/CD，具有简化传统开发流程的能力，通过持续开发、测试和交付机制，减少严重冲突的恐慌，即一次交付小的变更，并能立即缩小问题范围（如果有的话）。此外，通过自动化工具，CI/CD
    系统交付的产品可以提高效率并缩短市场时间。
- en: Jenkins is one of the well-known CI systems, which can be configured as a continuous
    delivery system. Jenkins can pull your project codes from the source code control
    system, run the tests, and then deploy based on your configuration. In this recipe,
    we will show you how to integrate Jenkins to Kubernetes to achieve continuous
    delivery.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 是一个著名的 CI 系统，可以配置为持续交付系统。Jenkins 可以从源代码控制系统拉取你的项目代码，运行测试，然后根据你的配置进行部署。在本食谱中，我们将向你展示如何将
    Jenkins 与 Kubernetes 集成以实现持续交付。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you start this recipe, prepare a Docker hub account ([https://hub.docker.com](https://hub.docker.com))
    or you may use your private registry that is described in the previous section.
    But the important part is you must have a credential to pull and push to the registry.
    If you use Docker hub, make sure `docker login` with your credentials works.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本食谱之前，准备一个 Docker hub 账户（[https://hub.docker.com](https://hub.docker.com)），或者你也可以使用前一节描述的私有注册表。但重要的是，你必须有拉取和推送到注册表的凭据。如果使用
    Docker hub，请确保 `docker login` 使用你的凭据能够正常工作。
- en: 'Next, make sure your Kubernetes is ready. But we will use RBAC authentication
    for access from the Jenkins pod to the Kubernetes master API. If you use `minikube`,
    you need to add the `--extra-config=apiserver.Authorization.Mode=RBAC` option
    when starting a minikube:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保你的 Kubernetes 已经准备就绪。我们将使用 RBAC 认证来访问 Jenkins pod 到 Kubernetes master
    API。如果你使用 `minikube`，启动 minikube 时需要添加 `--extra-config=apiserver.Authorization.Mode=RBAC`
    选项：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, you can set up your own Jenkins server through Kubernetes as well; the
    details are in this section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过 Kubernetes 设置自己的 Jenkins 服务器；具体细节请见本节。
- en: 'Some minikube versions have a `kube-dns` issue that can''t resolve the external
    domain name, such as [https://github.com/](https://github.com/) and [https://jenkins.io/](https://jenkins.io/), that
    can''t process this recipe. Replacing the `kube-dns` add-on with the `coredns`
    add-on could resolve the issue after launching `minikube` with the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 minikube 版本存在 `kube-dns` 问题，无法解析外部域名，如 [https://github.com/](https://github.com/)
    和 [https://jenkins.io/](https://jenkins.io/)，导致无法执行本食谱。可以通过以下命令将 `kube-dns` 插件替换为
    `coredns` 插件来解决该问题：
- en: '`$ minikube addons disable kube-dns`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube addons disable kube-dns`'
- en: '`$ minikube addons enable coredns`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube addons enable coredns`'
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are two important parts to go through in the Jenkins setup:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 设置中有两个重要部分需要处理：
- en: Jenkins needs to run a `docker` command to build your application to compose
    your container image
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins 需要运行 `docker` 命令来构建你的应用程序以组成容器镜像。
- en: Jenkins need to communicate with the Kubernetes master to control deployment
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins 需要与 Kubernetes master 通信以控制部署。
- en: To achieve step 1, there is a tricky part that needs something like a **Docker-in-Docker**
    (**dind**). This is because Jenkins is run by Kubernetes as a pod (Docker container),
    and Jenkins also needs to invoke a `docker` command to build your application.
    It can be achieved by mounting `/var/run/docker.sock` from the Kubernetes node
    to the Jenkins pod that can communicate with Jenkins, the Kubernetes node, and
    the Docker daemon.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现步骤 1，有一个棘手的部分需要类似于 **Docker-in-Docker**（**dind**）的解决方案。这是因为 Jenkins 作为一个
    pod（Docker 容器）由 Kubernetes 运行，Jenkins 还需要调用 `docker` 命令来构建你的应用程序。可以通过将 Kubernetes
    节点的 `/var/run/docker.sock` 挂载到可以与 Jenkins、Kubernetes 节点和 Docker 守护进程通信的 Jenkins
    pod 来实现。
- en: Docker-in-Docker and mounting `/var/run/docker.sock` have been described at
    [https://blog.docker.com/2013/09/docker-can-now-run-within-docker/](https://blog.docker.com/2013/09/docker-can-now-run-within-docker/) and [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/.](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Docker-in-Docker 和挂载 `/var/run/docker.sock` 的方案已在 [https://blog.docker.com/2013/09/docker-can-now-run-within-docker/](https://blog.docker.com/2013/09/docker-can-now-run-within-docker/)
    和 [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
    中有所描述。
- en: In order to achieve step 2, we will set up a Kubernetes service account and
    assign one `ClusterRole` so that the Jenkins service account can have a necessary privilege.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现步骤 2，我们将设置一个 Kubernetes 服务账户并分配一个 `ClusterRole`，以便 Jenkins 服务账户能够获得必要的权限。
- en: Let's do it step by step.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来。
- en: Setting up a custom Jenkins image
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自定义的 Jenkins 镜像
- en: 'Run Jenkins by Kubernetes, we use an official image ([https://hub.docker.com/u/jenkins/](https://hub.docker.com/u/jenkins/))
    but customize it to install the following applications on it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 运行 Jenkins，我们使用官方镜像（[https://hub.docker.com/u/jenkins/](https://hub.docker.com/u/jenkins/)），但对其进行自定义以安装以下应用程序：
- en: Docker CE
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker CE
- en: kubectl binary
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl 二进制文件
- en: Jenkins Docker plugin
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins Docker 插件
- en: 'To do that, prepare `Dockerfile `to maintain your own Jenkins image:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，准备一个 `Dockerfile` 来维护你自己的 Jenkins 镜像：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use `docker build` to build your Jenkins image and then  `docker push` command
    to upload to your own registry in Docker hub, as shown:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker build` 构建你的 Jenkins 镜像，然后使用 `docker push` 命令上传到你自己的 Docker Hub 注册中心，如下所示：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Or, alternatively, you could upload that to your private registry or any other
    cloud-provided registry.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以将其上传到你的私有注册中心或任何其他云提供的注册中心。
- en: Hurray! We have our build system image ready now.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 好极了！现在我们的构建系统镜像已经准备好了。
- en: Setting up Kubernetes service account and ClusterRole
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Kubernetes 服务账户和 ClusterRole
- en: Imagine that after using Jenkins successfully to build your application container,
    you then use `kubectl` to update deployment to roll out a new binary. To do that,
    invoke a `kubectl` command from the inside of a Jenkins pod. In this scenario,
    we need a credential to communicate to the Kubernetes master.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在成功使用 Jenkins 构建了你的应用容器后，你随后使用 `kubectl` 更新部署以发布新的二进制文件。为了做到这一点，你需要从 Jenkins
    pod 内部调用 `kubectl` 命令。在这种情况下，我们需要凭证来与 Kubernetes 主节点进行通信。
- en: Fortunately, Kubernetes supports this kind of scenario, which uses a service
    account. It is described in detail in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*. So, this recipe will use the simplest way,
    which uses the `default` namespace and `cluster-admin ClusterRole`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kubernetes 支持这种场景，使用服务账户来完成。详细说明可以在 [第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*高级集群管理*
    中找到。所以，本示例将使用最简单的方式，使用 `default` 命名空间和 `cluster-admin ClusterRole`。
- en: 'To check whether RBAC is enabled and also if the `cluster-admin ClusterRole`
    exists or not, type the `kubectl get clusterrole` command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否启用了 RBAC，并且 `cluster-admin ClusterRole` 是否存在，可以输入 `kubectl get clusterrole`
    命令：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, create a service account, `jenkins-sa`, which will be used by a Jenkins
    pod. Prepare the following YAML configuration, and type the `kubectl create` command
    to create it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个服务账户 `jenkins-sa`，该账户将由 Jenkins pod 使用。准备以下 YAML 配置，并输入 `kubectl create`
    命令来创建：
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we can associate the `jenkins-sa` service account with a `cluster-admin`
    `ClusterRole`. Prepare a `ClusterRoleBinding` configuration and run the `kubectl
    create` command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 `jenkins-sa` 服务账户与 `cluster-admin` `ClusterRole` 关联。准备一个 `ClusterRoleBinding`
    配置并运行 `kubectl create` 命令：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the result, if a pod is launched with the service account `jenkins-sa`, this
    Pod has the privilege to control a Kubernetes cluster because of the `cluster-admin
    ClusterRole`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，如果使用服务账户 `jenkins-sa` 启动了一个 pod，那么该 Pod 拥有控制 Kubernetes 集群的权限，因为它具有 `cluster-admin
    ClusterRole`。
- en: It should create a custom `ClusterRole` that has minimal privilege for Jenkins
    usage. But this recipe is to focus on the Jenkins setup itself. If you want to
    create a custom `ClusterRole`, please go to [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该会创建一个自定义的 `ClusterRole`，该角色具有 Jenkins 使用所需的最小权限。但本示例的重点是 Jenkins 的设置。如果你想创建自定义的
    `ClusterRole`，请参阅 [第 8 章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*高级集群管理*。
- en: Launching the Jenkins server via Kubernetes deployment
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Kubernetes 部署启动 Jenkins 服务器
- en: 'Based on the previous recipes, now you have:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的示例，现在你有了：
- en: A custom Jenkins container image
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自定义的 Jenkins 容器镜像
- en: A service account
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务账户
- en: Finally, you can launch your custom Jenkins server on your Kubernetes cluster.
    Remember that we need to run a `docker` command in the Docker environment, which
    needs to mount `/var/run/docker.sock` from the local Kubernetes node.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在 Kubernetes 集群上启动自定义的 Jenkins 服务器。记住，我们需要在 Docker 环境中运行 `docker` 命令，这需要从本地
    Kubernetes 节点挂载 `/var/run/docker.sock`。
- en: 'In addition, we need to use a `jenkins-sa `service account to launch a Jenkins
    pod. It needs to specify `spec.template.spec.serviceAccountName: jenkins-sa` in
    the deployment configuration.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们还需要使用 `jenkins-sa` 服务账户来启动 Jenkins pod。在部署配置中，需要指定 `spec.template.spec.serviceAccountName:
    jenkins-sa`。'
- en: It is also recommended to have a `PersistentVolume` to preserve Jenkins home
    (`/var/jenkins_home`), in case a pod is restarted. We just simply use the `hostPath
    /data/jenkins-data` directory (assuming you use minikube). You may change to another
    path or other types of `PersistentVolume` to fit with your environment.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议使用一个 `PersistentVolume` 来保存 Jenkins 主目录（`/var/jenkins_home`），以防 pod 被重启。我们简单地使用
    `hostPath /data/jenkins-data` 目录（假设你使用的是 minikube）。你可以根据你的环境更改为其他路径或其他类型的 `PersistentVolume`。
- en: 'Overall, the deployments YAML configuration for Jenkins is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Jenkins 的部署 YAML 配置如下：
- en: '[PRE56]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After a few minutes, Kubernetes pulls your custom Jenkins image and runs a
    Jenkins pod which is capable of running a `docker` command and a `kubectl` command
    without any configuration due to mounting the `/var/run/docker.sock` and `jenkins-sa` service
    account:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，Kubernetes 会拉取你的自定义 Jenkins 镜像并运行一个 Jenkins pod，该 pod 能够运行 `docker` 命令和
    `kubectl` 命令，无需任何配置，因为已经挂载了 `/var/run/docker.sock` 和 `jenkins-sa` 服务账户：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You are all set! Now you can configure a Jenkins job to build your application,
    build a container, and deploy to Kubernetes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪！现在你可以配置 Jenkins 作业来构建你的应用程序，构建容器并部署到 Kubernetes。
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Now we start to configure Jenkins to build your application. However, to access
    the WebUI of your custom Jenkins, you need to access the Kubernetes service that
    binds to your Jenkins pod. It is easier to use `kubectl port-forward` to access
    remotely to configure Jenkins:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始配置 Jenkins 来构建你的应用程序。然而，为了访问你自定义 Jenkins 的 WebUI，你需要访问绑定到 Jenkins pod
    的 Kubernetes 服务。使用 `kubectl port-forward` 远程访问来配置 Jenkins 会更方便：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The initial configuration of Jenkins is done via the following steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 的初始配置通过以下步骤完成：
- en: Access the `http://127.0.0.1:58080` Jenkins WebUI; it asks you to input `initialAdminPassword`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `http://127.0.0.1:58080` Jenkins WebUI，它会要求你输入 `initialAdminPassword`。
- en: 'Use `kubectl exec` to acquire the `initialAdminPassword`. Then copy and paste
    to the Jenkins WebUI to proceed with the initial configuration to install the
    suggested plugin and create an admin user:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl exec` 获取 `initialAdminPassword`。然后将其复制并粘贴到 Jenkins WebUI 进行初始配置，安装推荐的插件并创建一个管理员用户：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You will see a Jenkins top page. Then click Manage Jenkins, then Configure
    System:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到 Jenkins 的首页。然后点击“管理 Jenkins”，再点击“配置系统”：
- en: '![](img/7ba133a9-48d4-4227-a747-9eeeb386699e.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ba133a9-48d4-4227-a747-9eeeb386699e.png)'
- en: Navigate to Jenkins configuration
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 Jenkins 配置
- en: 'Scroll to the bottom and find a Cloud section. Click Add a new cloud to select
    Docker:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到页面底部，找到云部分。点击“添加新云”并选择 Docker：
- en: '![](img/7ee5f4ab-dbfb-4e9c-a3ad-cf7b4f5c1ef2.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ee5f4ab-dbfb-4e9c-a3ad-cf7b4f5c1ef2.png)'
- en: Adding a Docker setting
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Docker 设置
- en: 'Put Name as your desired name (example: `my-docker`) and specify the Docker
    Host URI and Docker domain socket as `unix:///var/run/docker.sock`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称设置为你想要的名称（例如：`my-docker`），并指定 Docker 主机 URI 和 Docker 域套接字为 `unix:///var/run/docker.sock`：
- en: '![](img/53073463-06d0-4b8c-8e2e-7f27070df8c2.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53073463-06d0-4b8c-8e2e-7f27070df8c2.png)'
- en: Configure Docker on Jenkins
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Jenkins 上的 Docker
- en: Using Jenkins to build a Docker image
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins 构建 Docker 镜像
- en: 'Let''s configure a Jenkins job to build a sample microservice application,
    which was introduced in the previous recipe (`my-calc`). Perform the following
    steps to configure and build a Docker image:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置一个 Jenkins 作业来构建一个示例微服务应用程序，该应用程序在前面的配方中有介绍（`my-calc`）。执行以下步骤来配置和构建 Docker
    镜像：
- en: 'On the left navigation, click New Item:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航栏中，点击“新建项目”：
- en: '![](img/7eafbe4f-c882-454c-8ff4-994766bc6922.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eafbe4f-c882-454c-8ff4-994766bc6922.png)'
- en: Navigating to create a new item
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到创建新项目
- en: 'Put your in desired item name (example: `my-calc`), select Freestyle project,
    then click OK:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你想要的项目名称（例如：`my-calc`），选择“自由风格项目”，然后点击“确定”：
- en: '![](img/911c131b-08a8-48e4-a814-5971bd062314.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/911c131b-08a8-48e4-a814-5971bd062314.png)'
- en: Creating a new Jenkins Job
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Jenkins 作业
- en: 'In the Source Code Management tab, select Git and set the Repository URL as [https://github.com/kubernetes-cookbook/my-calc.git](https://github.com/kubernetes-cookbook/my-calc.git),
    or you may use your own repository which has a `Dockerfile`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码管理选项卡中，选择 Git 并将仓库 URL 设置为 [https://github.com/kubernetes-cookbook/my-calc.git](https://github.com/kubernetes-cookbook/my-calc.git)，或者你也可以使用你自己的仓库，其中包含
    `Dockerfile`：
- en: '![](img/a9dbdb04-69e8-428c-98ee-6e5682bab7c7.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9dbdb04-69e8-428c-98ee-6e5682bab7c7.png)'
- en: Source Code Management settings
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理设置
- en: 'On the Build Environment tab, click Add build step to add Build / Publish Docker
    Image:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建环境选项卡中，点击“添加构建步骤”以添加构建/发布 Docker 镜像：
- en: '![](img/680b49b0-db5f-4d42-95fe-77730fdef7ad.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/680b49b0-db5f-4d42-95fe-77730fdef7ad.png)'
- en: Build Environment settings
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 构建环境设置
- en: 'In the Build / Publish Docker Image panel:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“构建/发布 Docker 镜像”面板中：
- en: Directory for `Dockerfile` as current (`.`)
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Dockerfile` 的目录设置为当前目录（`.`）
- en: Choose my-docker in the Cloud that we've set up
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们设置的云中的 my-docker
- en: 'Put image as your Docker repository, but append `:${BUILD_NUMBER}` (example:
    `hidetosaito/my-calc:${BUILD_NUMBER}`)'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像地址设置为你的 Docker 仓库，但在末尾添加 `:${BUILD_NUMBER}`（例如：`hidetosaito/my-calc:${BUILD_NUMBER}`）
- en: Enable Push image
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用推送镜像
- en: Click Add to add your Docker hub ID credential
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加”以添加你的 Docker hub ID 凭证
- en: 'Then, click Save:'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击“保存”：
- en: '![](img/ba62d487-3f1e-44b8-ab7e-f6aa82789d55.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba62d487-3f1e-44b8-ab7e-f6aa82789d55.png)'
- en: Docker build/publish settings
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Docker构建/发布设置
- en: 'Finally, you can click Build Now to trigger a build; for testing purposes you
    can click five times to see how it works:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以点击“立即构建”来触发构建；为了测试，你可以点击五次看看它是如何工作的：
- en: '![](img/fcf5a03d-8960-48c0-91f2-20dc0cec5646.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcf5a03d-8960-48c0-91f2-20dc0cec5646.png)'
- en: Trigger a build
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 触发构建
- en: 'Note that you can see a Console that knows it performs a Docker build and push:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你可以看到一个控制台，它知道正在执行Docker构建和推送：
- en: '![](img/b4447718-f02a-4986-8ed3-6588a887ebc0.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4447718-f02a-4986-8ed3-6588a887ebc0.png)'
- en: Showing a build log
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 显示构建日志
- en: 'Access your Docker hub repository; it has been pushed five times (because of
    clicking on build five times):'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问你的Docker hub仓库；它已经被推送了五次（因为点击了五次构建）：
- en: '![](img/277bd7dc-f403-4ab2-a8b6-8fd847de4e6a.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/277bd7dc-f403-4ab2-a8b6-8fd847de4e6a.png)'
- en: Docker hub repository
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Docker hub仓库
- en: That's it! You can achieve continuous integration to build a Docker image so
    that when you update a source in GitHub, you can continuously build and push the
    latest image to your Docker hub repository by Jenkins.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你可以通过持续集成构建Docker镜像，当你在GitHub上更新源代码时，Jenkins可以持续构建并将最新的镜像推送到你的Docker hub仓库。
- en: Deploying the latest container image to Kubernetes
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将最新的容器镜像部署到Kubernetes
- en: 'After each build, Jenkins keeps pushing your container image on your Docker
    hub repository at the end of the CI process. Next, update the Jenkins job configuration
    to use the latest image to deploy to Kubernetes, via the following steps:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 每次构建后，Jenkins都会在CI流程结束时将你的容器镜像推送到Docker hub仓库。接下来，更新Jenkins任务配置，使用最新镜像部署到Kubernetes，步骤如下：
- en: 'The first time, we pre-deploy microservice application manually via `kubectl
    deploy --record`. Note that you may change `spec.template.spec.containers.image:
    hidetosaito/my-calc` to your repository:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第一次，我们通过`kubectl deploy --record`手动预部署了微服务应用。请注意，你可能需要将`spec.template.spec.containers.image:
    hidetosaito/my-calc`修改为你自己的仓库：'
- en: '[PRE60]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Open Jenkins Job configuration; on the Build tab, right after the Docker build
    settings, click Add build step and choose Execute shell:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Jenkins任务配置；在构建选项卡上，点击Docker构建设置后的“添加构建步骤”，然后选择“执行Shell”：
- en: '![](img/c473e1c8-40ee-4416-bb22-facf3f7438e8.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c473e1c8-40ee-4416-bb22-facf3f7438e8.png)'
- en: Adding a build step
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 添加构建步骤
- en: 'Add this shell script and click Save:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这个Shell脚本并点击保存：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Trigger a new build; you can see that after Docker push, it runs the preceding
    script:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发一次新构建；你可以看到在Docker push后，它会运行前面的脚本：
- en: '![](img/7b881532-d1b1-4322-b3ef-d27217f4b377.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b881532-d1b1-4322-b3ef-d27217f4b377.png)'
- en: Kubernetes rollout result
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes部署结果
- en: Now you can extend continuous integration to continuous delivery! You may extend
    to add a unit test or integration test and roll back mechanisms onto the above
    script to make your CI/CD work stronger.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将持续集成扩展到持续交付！你可以在上述脚本中增加单元测试、集成测试和回滚机制，以增强你的CI/CD流程。
