- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Cloud Secret Store on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very common way to store Secrets in the cloud is to utilize the infrastructure
    that is provided by cloud providers. The major cloud providers have two essential
    pieces of infrastructure that help us with efficient Secrets management on Kubernetes:
    Secret Storage and KMS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall examine AWS Secrets Manager, **Elastic Kubernetes
    Service** (**EKS**) integration, and secret encryption with KMS. Specifically,
    we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of AWS Secrets Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets Store CSI Driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS EKS clusters and AWS Secrets Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KMS for AWS Kubernetes encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we should be able to use AWS Secrets Manager as an
    external Kubernetes secret store, encrypt Secrets on Kubernetes using AWS KMS,
    and search audit logs on secret operations using AWS CloudTrail and AWS CloudWatch.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To link concepts with practice, we will use a series of tools and platforms
    that are commonly used to interact with the AWS API and Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: An AWS Free Tier account is required. The free tier is available to new AWS
    customers for a limited period. Once the period expires or the usage exceeds the
    free tier usage limits, pay-as-you-go service rates apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **AWS CLI** ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/))
    is a unified tool for managing your AWS services. Commands executed through the
    AWS CLI are transformed into API calls toward the AWS API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terraform** ([https://www.terraform.io/](https://www.terraform.io/)) is infrastructure-as-code
    software that can be used to provision and manage infrastructure in the cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubectl** ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/))
    is a command-line tool used for communicating with a Kubernetes cluster through
    the Kubernetes API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of AWS Secrets Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A secret is a concept that exists outside the realm of Kubernetes. Any type
    of application will at some point require sensitive information to be integrated
    with each deployment. An application deployed in the cloud requires secure secret
    handling. For this reason, cloud providers offer components for secret storage.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Kubernetes, we saw in [*Chapter 1*](B20970_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes Secrets Management*, that secret information is stored
    on etcd. Essentially, etcd is the default secret store of Kubernetes. The crucial
    question is whether it is possible to have external storage for Secrets on Kubernetes
    apart from etcd.
  prefs: []
  type: TYPE_NORMAL
- en: This is feasible provided you actively use a cloud provider’s secret storage,
    or you consider taking advantage of it and utilizing it on Kubernetes. Thanks
    to the Container Storage Interface and the workload identity, we can utilize the
    available secret stores.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Secrets Manager ([https://aws.amazon.com/secrets-manager/](https://aws.amazon.com/secrets-manager/))
    is the secret store provided by AWS. With AWS Secrets Manager, we can store several
    types of credentials, such as database credentials, application credentials, and
    secure tokens. We will now focus on the features that make AWS Secrets Manager
    a good option for handling Secrets, starting with encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS Secrets Manager has encryption at rest as well as in transit. It uses AWS
    KMS to perform envelope encryption. The values stored in AWS Secrets Manager are
    encrypted using a data key, and the data key is encrypted using AWS KMS. The data
    encryption key is an AES-256 key. When a value changes on AWS Secrets Manager,
    a new data encryption key is generated and is used to encrypt the new value. We
    can also configure AWS Secrets Manager to use a different KMS key. AWS Secrets
    Manager also provides encryption in transit. The API calls toward Secrets Manager
    happen through secure private endpoints, and each call is required to be signed
    using X.509 certificates or a Secrets Manager secret access key.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Versioning is another benefit of using AWS Secrets Manager. If we create a secret
    in AWS Secrets Manager, the secret will be stored, and a version will be assigned
    to it. This will be the first version of the secret. Once we update that secret,
    we will have an updated version of the secret, and the old version will still
    be available. When we access the secret, the latest version of it will be retrieved.
    The previous version can be configured to be automatically deleted at a certain
    date. This will make it impossible to retrieve it. If we want to retrieve the
    previous version, we must remove it from pending deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS Secrets Manager also permits rotation. An AWS Lambda function can be configured
    to execute a scheduled key rotation; the AWS documentation has a detailed guide
    ([https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html)).
    On invocation, the Lambda function will rotate the key based on a custom code
    snippet that we provided; the function templates can be found on GitHub ([https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas](https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas)).
    During the rotation, the latest version of the key will be tested. On failure,
    the rotation will be retried.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from tackling the storage needs of sensitive information, AWS Secrets
    Manager is a managed AWS component. Every AWS component comes with certain features:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS IAM integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and auditing on usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High availability and disaster recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with other AWS components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of these features.
  prefs: []
  type: TYPE_NORMAL
- en: AWS IAM integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With AWS **Identity and Access Management** (**IAM**), we can specify entities
    that can access services and resources in AWS. Those entities can be AWS users
    or AWS roles.
  prefs: []
  type: TYPE_NORMAL
- en: AWS users are intended to be associated with an actual human user who wants
    to interact with an AWS service and provision resources. AWS roles are a more
    flexible identity. AWS roles are used to delegate access to services, EC2 machines,
    and Kubernetes workloads.
  prefs: []
  type: TYPE_NORMAL
- en: The identities on AWS can be granted fine-grained permissions on AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and auditing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AWS comes with CloudWatch, which is a monitoring and observability solution.
    CloudWatch collects real-time logs and metrics from other AWS components. In our
    case, with CloudWatch we can identify Kubernetes operations through logging; also,
    we can create custom alerts and dashboards based on the metrics provided out of
    the box.
  prefs: []
  type: TYPE_NORMAL
- en: CloudTrail is an AWS service targeted toward auditing. With CloudTrail, we can
    track actions taken by an AWS user or an AWS role. Those operations will be recorded
    and will be accessible through AWS CloudTrail. Take, for example, a secret retrieval
    by a role attached to an EC2 machine. The code running on the EC2 machine is granted
    permission to receive the secret, the secret is retrieved, and this action is
    logged to AWS CloudTrail. The EC2 machine has a role assigned with permissions
    to interact with AWS Secrets Manager; the role is an AWS identity, just like an
    AWS console user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the CloudTrail screen displaying auditing
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – AWS CloudTrail screen](img/B20970_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – AWS CloudTrail screen
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to CloudTrail, we can identify the action that took place in AWS Secrets
    Manager, the identity that executed it, and at what time.
  prefs: []
  type: TYPE_NORMAL
- en: High availability and disaster recovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secrets provisioned on Secrets Manager are regionally highly available. This
    means that the secret operations will span the three availability zones that an
    AWS region consists of. If an availability zone becomes unavailable, requests
    for a secret will be served by another availability zone.
  prefs: []
  type: TYPE_NORMAL
- en: Also, with AWS Secrets Manager, we can achieve disaster recovery. By default,
    when we create a secret, we choose an availability zone, where this secret will
    reside. To protect our workloads from situations where a region is lost, we provision
    our infrastructure in a way that disaster recovery is feasible. AWS Secrets Manager
    makes this easy by enabling us to replicate a secret to another region.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with other AWS components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A benefit of using the components provided by the cloud providers is how well
    they are integrated. AWS Secrets Manager can be integrated with other AWS components
    easily. In our case, we are interested in EKS, which is the managed version of
    Kubernetes on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: We had an overview of AWS Secrets Manager and saw how it can be integrated with
    other AWS components. We shall proceed with integrating AWS Secrets Manager with
    EKS. To achieve this, we will have an overview of the tool that facilitates this
    integration, Secrets Store CSI Driver.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Store CSI Driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes CSI is a standardized interface for Kubernetes that enables us to
    utilize different storage providers with Kubernetes. Instead of being limited
    to using the default storage on Kubernetes, we have an interface providing a specification
    upon which we can build storage drivers. This way we can use several types of
    storage by implementing a new driver that complies with the CSI interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some popular drivers for CSI:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Elastic File System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure File
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud Filestore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is feasible for several forms of storage and is also applicable to the
    Secrets storage components provided by the cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: CSI drivers are provided for secret storage by the cloud providers. Secrets
    Store CSI Driver is a CSI interface that targets Secrets management. We can use
    it to mount Secrets on Kubernetes through another form of storage. Instead of
    consuming Secrets from etcd, thanks to Secrets Store CSI Driver, we can consume
    the Secrets from various external sources, and in our case, those sources are
    the very Secrets Storage solutions that are provided by the cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on AWS Secrets Manager and examine how we can
    integrate a Kubernetes cluster into AWS to consume Secrets from the native cloud
    provider solution for Secrets management by using the corresponding Secrets Store
    CSI Driver.
  prefs: []
  type: TYPE_NORMAL
- en: How Secrets Store CSI Driver works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an application to be hosted on Kubernetes. That application will have
    to use a secret that resides on the Secrets storage solution of the cloud provider.
    The application will reside on a Pod since the Pod is the main compute building
    block of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Once a Pod is created, started, or restarted, Secrets Store CSI Driver through
    the Secret Store CSI provider will communicate with the cloud provider’s Secrets
    storage and retrieve the credentials. The credentials will be mounted to the Pod
    as a volume. The volume mounted will be attached to a directory specified.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is how Secret Store CSI Driver works.
  prefs: []
  type: TYPE_NORMAL
- en: Secret Store CSI Driver is a **DaemonSet**. A DaemonSet exists on Kubernetes
    on every node. A DaemonSet can consist of more than one Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Secret Store CSI Driver, we have the following Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node-driver-registrar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secrets-store`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`liveness-probe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: node-driver-registrar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`node-driver-registrar` will register the CSI driver with the kubelet. A registration
    socket is created and exposed via the host path in the kubelet plugin registry.'
  prefs: []
  type: TYPE_NORMAL
- en: secrets-store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `secrets-store` component is responsible for mounting secret volumes during
    Pod creation as well as unmounting volumes during Pod deletion. It is based on
    gRPC implementing the CSI node service from the CSI specification.
  prefs: []
  type: TYPE_NORMAL
- en: liveness-probe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This Pod monitors the health of the CSI driver. The health liveness probe will
    detect any issues with the driver and will restart the Pod in order to fix the
    issue. In the following diagram, we can see how all the components come together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Secrets Store CSI and AWS Secrets Manager integration](img/B20970_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Secrets Store CSI and AWS Secrets Manager integration
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the CSI driver, we shall proceed with integrating it
    with EKS.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating AWS Secrets Manager with EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To integrate AWS Secrets Manager with Kubernetes, we shall utilize the Secrets
    Store CSI Driver . As expected, AWS provides us with Secrets Store CSI Driver
    ([https://github.com/aws/secrets-store-csi-driver-provider-aws](https://github.com/aws/secrets-store-csi-driver-provider-aws)).
    To integrate the driver with Kubernetes, we will create a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: EKS cluster on AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As defined earlier, **EKS** in AWS stands for **Elastic Kubernetes Service**.
    We have the option to set up a Kubernetes cluster on the AWS cloud just like every
    other cloud. We will focus on the managed service offering for the purpose of
    this chapter because it requires less maintenance and setup overhead.
  prefs: []
  type: TYPE_NORMAL
- en: If there is already an existing EKS cluster available, the Terraform setup instructions
    can be ignored since the corresponding command-line arguments for AWS will be
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Kubernetes cluster on AWS can require different amounts of effort
    based on the installation you want to achieve. One option is to create fully private
    clusters with no connectivity to the internet and everything being served internally
    from AWS. Another option is a cluster on a public network. A quite common option
    nowadays is to deploy the nodes of the cluster on subnets that are private and
    ensure that the connectivity to the internet happens through a NAT gateway. This
    is the option we shall follow.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Terraform project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Terraform project on AWS requires us to store the state. We can store the
    state locally on our filesystem, but this is not a viable option for infrastructure
    as code targeting a production environment. Our option is to use a **Secure Storage
    Service** (**S3**) bucket to store the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, the Terraform code base will use the default credentials that are
    configured for the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to initialize the Terraform project using `init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will initialize our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Terraform, we have the option of `plan`, which is similar to the `dry-run`
    command from kubectl. Instead of creating the resources, we use `plan` and identify
    what the state of the infrastructure would be like if the Terraform scripts had
    been applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply the infrastructure, we shall use the `apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Terraform basics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using Terraform, infrastructure is defined in `.tf` files. A Terraform
    project involves the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have seen `init`, which is used to initialize the project and download
    the existing state; `plan`, which is used to evaluate the changes we perform;
    and `apply`, which is the command used to carry out the changes. To destroy the
    provisioned resource, we can use the `destroy` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'These operations can be carried out on the project or can target a specific
    resource defined in the Terraform files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of existing resources, there is the option to import those resources
    in the Terraform state and provide them with a resource definition on the `.``tf`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is a recommended structure for Terraform projects. `main.tf` is the primary
    entry point to define resources. As the complexity of the infrastructure increases,
    more `.tf` files can be used. `variables.tf` contains variables that we want to
    be dynamic when provisioning the infrastructure and `outputs.tf` should contain
    the information we want to extract when we provision infrastructure with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: The Terraform project is set up, so we shall proceed with setting the VPC through
    Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the VPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our cluster nodes will reside on AWS VPC. We shall use the VPC module from
    the `terraform-aws-modules` project (https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, we will span a VPC among three availability zones,
    thus enabling us to have a highly available cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We shall create a private subnet in each zone as well as public subnets.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes workloads will be hosted on the private subnets and external
    traffic will reach the Kubernetes workloads through the public network. To provide
    access to the internet from within the Kubernetes cluster, a NAT gateway will
    be configured.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the VPC configured we can now proceed and configure the EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the EKS cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have provisioned the VPC, so now we shall proceed with provisioning the
    EKS cluster. We will pick the EKS module from the `terraform-aws-modules` project
    ([https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest](https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will create an EKS cluster. The master is managed by AWS. By creating the
    cluster, we specified that the nodes span the private subnets we specified previously
    in the VPC section. We will also create a separate log group for the EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To make it easy to interact with the EKS master, we shall configure the cluster
    endpoint to be publicly accessible. The option can be fine-tuned and specify a
    restricted number of IPs to be able to interact with the cluster through the kubectl
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Once the cluster is up and running, we can test and even run some kubectl commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To authenticate to the cluster, we shall use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will differ depending on the cluster name and the region we choose.
    Once this is done, we can use kubectl to point to the recently provisioned cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have provisioned the EKS cluster, we can proceed to work with AWS
    Secrets Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Secrets on Secrets Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a secret using AWS Secrets Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `replica` block, we specify the region in which we will replicate the
    secret. This will give us disaster recovery capabilities. Also, the `recovery_window_in_days`
    block defines within how many days we can recover a secret after we set it for
    deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a version for the secret we specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is our first interaction with AWS Secrets Manager. We have created a secret
    and a version of the secret containing a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also create a role with the required IAM bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Pay close attention to the role. It is very different from what we are used
    to. This role is created with EKS in mind. This role is a workload identity mapped
    to a role in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The role is limited in what it can do. We cannot use the role to perform operations
    on other AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can provision the Secrets using the AWS CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will create a secret and a version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create the role and the policy using the AWC CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have a role that can be attached to Kubernetes and retrieve Secrets from
    Secrets Manager. Our next step is to install the CSI plugin.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Secrets Manager provider for CSI on EKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now time to install the AWS Secrets Manager CSI provider on EKS. The first
    thing to do is to add the Secrets Store CSI Driver plugin to the EKS installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by installing the driver on EKS, since the `secrets-store-csi`
    driver is not available as an add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will install the `secret-store-csi-driver` DaemonSet. We can
    validate the installation of `secret-store-csi-driver` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can proceed with fetching the credentials from the secret store through Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Secrets from Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we want to map the secret through a secret provider class. In the object,
    we specify the name of the secret we want to fetch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We map a Kubernetes secret to a secret provided by AWS Secrets Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a Kubernetes service account with permission to retrieve this secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `eks.amazonaws.com/role-arn` section, we specify the AWS role with the
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the service account is annotated with an AWS role, which is the
    AWS role we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: This service account, provided it is attached to a Pod, will assume this role
    identity by using the Kubernetes OIDC provider. More on OIDC and Kubernetes service
    accounts can be found in the official documentation ([https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Pod is created, it will use that service account and mount that secret
    upon it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this by printing the secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, we created a Pod with a service account, which was mapped to an
    AWS role. This service account had permission to interact with AWS Secrets Manager.
    As a result, we see the secret that we mounted previously. In the next section,
    we will focus on how we can track the actions that take place in AWS Secrets Manager,
    through auditing.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully created Secrets and made sure we received them securely
    by utilizing AWS IAM. Since secure access has been tackled and we have fine-grained
    permissions, we are interested in also logging the usage of and access to our
    Secrets management instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to evaluate the secret access that occurs in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets access logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Secrets Manager logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When auditing occurs, a log message is printed in the output of a program. This
    is integrated with CloudWatch, the logging solution provided by AWS, and CloudTrail,
    the auditing solution that AWS provides.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes logs on CloudWatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using CloudWatch, we can browse the Kubernetes logs. Suppose we created
    a secret called `audit-test`. We can search for any operations on Logs Insights
    ([https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights](https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights)).
    We can use the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result entries will show the actual results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@``message` | `{"kind":"Event",...,"verb":"get","user":{"username":"kubernetes-admin",
    "uid":"aws-iam-authenticator:274402012893:AIDAILH3OPGRUQEOHAR3O", "groups":["system:masters","system:authenticated"],
    "extra":{"accessKeyId": ["AKIAI5INYQBL233Y7J6Q"],"arn": ["arn:aws:iam::274402012893:
    user/ gkatzioura"],"canonicalArn": ["arn:aws:iam:: 274402012893: user/gkatzioura"],
    "principalId": ["AIDAILH3OPGRUQEOHAR3O"],"sessionName": [""]}},"sourceIPs":["90.221.185.67"],"userAgent":
    "kubectl/v1.25.4 (darwin/arm64) kubernetes/872a965","objectRef":{"resource": "secrets","namespace":"default",
    "``name":"audit-test", "apiVersion":"v1"},"responseStatus":{"metadata":...}` |'
  prefs: []
  type: TYPE_TB
- en: '| `@``timestamp` | `1692687754591` |'
  prefs: []
  type: TYPE_TB
- en: This result looks familiar. It is the log we saw previously in [*Chapter 2*](B20970_02.xhtml#_idTextAnchor031),
    *Walking through Kubernetes Secrets Management Concepts*, when we were auditing
    Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Also, CloudWatch gives us the option to create alarms. If there are unexpected
    log entries that indicate access or access attempts to a secret, we can configure
    CloudWatch to create an alert and notify us through the communication channel
    of our choice, for example, email.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Secrets Manager logs on AWS CloudTrail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS CloudTrail is a service specifically for audit logs. With CloudTrail, we
    can identify the retrieval of Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use this URL to view the Secrets that have been recently
    retrieved in our AWS account: [https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue](https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate to the URL, the retrieval information from AWS Secrets Manager
    will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The user identity is the AWS role we created previously. The event name is a
    `GetSecretValue` event. `r``equestParameters` is the resource the operation is
    executed on.
  prefs: []
  type: TYPE_NORMAL
- en: KMS for AWS Secrets encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes gives us the option to specify certain encryption providers when
    storing the Secrets on etcd. AWS KMS can be used as an encryption provider to
    encrypt the Secrets hosted on etcd.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning KMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We shall provision a KMS key using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That key is now ready to be used standalone or with other AWS components.
  prefs: []
  type: TYPE_NORMAL
- en: Using KMS with EKS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having created the EKS cluster, we can now specify the credentials that will
    decrypt the Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to fetch the credentials from Kubernetes, the Secrets will be decrypted
    using the KMS we specified. We can use AWS CloudTrail to identify the usage. We
    can access CloudTrail events by following this link: [https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt](https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt).'
  prefs: []
  type: TYPE_NORMAL
- en: If we navigate to the page, the decryption operation will be displayed onscreen.
    Also, it will display the user responsible for the decryption operation that took
    place, which in our case is the role associated with the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information will be in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We managed to store our Secrets encrypted on `etcd` using AWS KMS. Our secret
    residing on etcd will be encrypted and we should be able to monitor any encryption/decryption
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we created a VPC network that spans three availability zones.
    On top of that network, we provisioned an EKS cluster. We managed to integrate
    the EKS cluster with AWS Secrets Manager. This was done securely by implementing
    a fine-grained role on AWS mapped to our Kubernetes workloads. We then proceeded
    to identify the operations that took place with regard to the Secrets stored on
    AWS Secrets Manager by checking CloudWatch and CloudTrail logs. Lastly, we encrypted
    the Secrets residing on an EKS cluster by using a managed KMS. In the next chapter,
    we shall focus on another popular cloud provider and its secret-handling capabilities:
    Microsoft Azure.'
  prefs: []
  type: TYPE_NORMAL
