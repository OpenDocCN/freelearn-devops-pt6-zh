- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Microservices Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Istio secures communication between microservices without microservices requiring
    any code changes. In *Chapter 4*, we briefly touched upon the topic of security.
    We configured transport layer security by exposing our sockshop application over
    HTTPS. We created certificates and configured the Istio Ingress gateway to bind
    those certificates to hostnames in SIMPLE TLS mode. We also implemented TLS-based
    security for multiple hosts managed by a single Ingress gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive deeper into some advanced topics of security.
    We will start by understanding Istio security architecture. We will implement
    mutual TLS for service communication with other services in the mesh, and we will
    also implement mutual TLS with downstream clients outside the mesh. We will then
    perform various hands-on exercises to create custom security policies for authentication
    and authorization. We will go through these topics in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Istio security architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating using mutual TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure a custom authentication and authorization policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The technical prerequisites for this chapter are the same as *Chapters 4* and
    *5*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Istio security architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, we discussed how the Istio control plane is responsible for
    the injection of sidecars and establishing trust so that sidecars can communicate
    with the control plane securely and security policies are eventually enforced
    by the sidecar. When deployed in Kubernetes, Istio relies on Kubernetes service
    accounts to identify the roles of workloads in a Service Mesh. The Istio CA watches
    the Kubernetes API server for the addition/deletion/modification of any service
    accounts in the namespace with Istio injection enabled. It creates a key and certificates
    for each service account and, during Pod creation, the certificate and key are
    mounted onto the sidecar. The Istio CA is responsible for managing the life cycle
    of the certificates distributed to the sidecars, including the rotation and management
    of private keys. Using the **Secure Production Identity Framework for Everyone**
    (**SPIFFE**) format identities, Istio provides a strong identity to each service
    along with service naming, which represents the role that can be taken up by the
    identity assigned to the service.
  prefs: []
  type: TYPE_NORMAL
- en: SPIFFE is a set of open source standards for software identity. SPIFFE provides
    platform-agnostic interoperable software identities along with interfaces and
    documents required to obtain and validate cryptographic identity in a fully automated
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In Istio, each workload is automatically assigned an identity represented in
    the X.509 certificate format. The creation and signing of **certificate signing
    request** (**CSRs**) are managed by the Istio control plane, as discussed in *Chapter
    3*. The X.509 certificate follows the SPIFFE format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s redeploy the `envoydummy` service and inspect the `envoydummy` Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: step CLI
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install step `CLI` to be able to run the preceding command.
    To install it, please follow the documentation at [https://smallstep.com/docs/step-cli](https://smallstep.com/docs/step-cli).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output of the preceding command, you will notice that the `spiffe://cluster.local/ns/utilities/sa/default`.
    This is the SPIFFE ID, which functions as the unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spifee` is the URI scheme'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cluster.local` is the trust domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/ns/utilities/sa/default` is the URI identifying the service account associated
    with the workload:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ns` stands for namespace'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sa` stands for service account'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value default for service accounts comes from the service account attached
    to the workload. In our example of `envoydummy`, we didn’t associate any service
    accounts so, by default, Kubernetes associated the `default` service account.
    You can find the service account name associated with a Pod using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that `default` is the default name for service accounts associated
    with all Pods in all namespaces, such as `sock-shop`, `utilities`, and so on.
    Kubernetes creates a service account named `default` in every namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes service accounts
  prefs: []
  type: TYPE_NORMAL
- en: A service account is an identity assigned to workloads in Kubernetes. When processes
    running inside a workload try to access other Kubernetes resources, they are identified
    and authenticated as per the details of their service accounts. You can find more
    details about service accounts at [https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/).
  prefs: []
  type: TYPE_NORMAL
- en: Secure Naming is a technology that decouples the name of services from the identities
    the services are running as. In the previous example, `spiffe://cluster.local/ns/utilities/sa/default`
    is the identity of the service presented during mutual TLS presented by the istio-proxy
    sidecar in `envoydummy-2-7488b58cd7-m5vpv workload`. From the SPIFFE ID, the other
    party (istio-proxy in another Pod) in the MTLS session can validate that the endpoint
    has the identity of a service account named `default` in the `utilities` namespace.
    The Istio control plane propagates the secure naming information to all sidecars
    in the mesh and during mutual TLS, the sidecar not only verifies that the identity
    is correct but also that the respective service is assuming the correct identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the Istio security architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Istio security architecture](img/B17989_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Istio security architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the key concepts to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: The Istio CA manages keys and certificates and the SANs in certificates are
    in SPIFFE format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Istiod distributes authentication and authorization security policies to all
    sidecars in the mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidecars enforce authentication and authorization as per security policies distributed
    by Istiod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to clean up `Chapter6/01-envoy-dummy.yaml` to avoid conflict in upcoming
    exercises.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will read about how to secure data in transit between
    microservices in a Service Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication using mutual TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mutual TLS** (**mTLS)** is a technique for authenticating two parties at
    each end of a network connection. Through mTLS, each party can verify that the
    other party is what they are claiming to be. Certificate authorities play a critical
    role in mTLS, and hence we had the previous section on Istio security architecture
    describing certificate authorities and secure naming in Istio.'
  prefs: []
  type: TYPE_NORMAL
- en: mTLS is one of the most frequently used authentication mechanisms for implementing
    the zero-trust security framework, in which no party trusts another party by default,
    irrespective of where the other party is placed in the network. Zero trust assumes
    that there are no traditional network edges and boundaries and hence every party
    needs to be authenticated and authorized. This helps to eliminate many security
    vulnerabilities that arise because of the assumption-based trust model.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two subsections, we will look at how Istio helps you implement
    mTLS for service-to-service authentication inside a mesh, also called east-west
    traffic, and mTLS between client/downstream systems that are outside the mesh,
    with services in the mesh called north-south communication.
  prefs: []
  type: TYPE_NORMAL
- en: Service-to-service authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Istio provides service-to-service authentication by using mTLS for transport
    authentication. During traffic processing, Istio performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All outbound traffic from Pods is rerouted to istio-proxy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: istio-proxy starts an mTLS handshake with the server-side istio-proxy. During
    the handshake, it also does a secure naming check to verify that the service account
    presented in the server certificate can run the Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server-side istio-proxy verifies the client-side istio-proxy in the same
    fashion and if all is okay, a secure channel is established between the two proxies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Istio provides the following two options when implementing mTLS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissive mode**: In permissive mode, Istio allows traffic in both mTLS
    and non-mTLS mode. This feature is primarily to improve the onboarding of clients
    to mTLS. Clients who are not yet ready to communicate over mTLS can continue communicating
    over TLS with the view that they will eventually migrate to mTLS whenever they
    are ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strict mode**: In strict mode, Istio enforces strict mTLS and any non-mTLS
    traffic is not allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutual TLS traffic can be established between clients outside of a mesh trying
    to access a workload within the mesh, as well as clients within the mesh trying
    to access other workloads in the mesh. For the former, we will discuss the details
    in the next section. For the latter set of clients, we will go through some examples
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set up service-to-service communication using mTLS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a namespace called `chapter6` with Istio injection enabled and deploy
    the `httpbin` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Most of the config in this deployment is the usual, except that we have also
    created a default Kubernetes service account called `httpbin` in the `Chapter6`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `httpbin` identity is then assigned to an `httpbin` Pod by following these
    specs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a client in the form of a `curl` Pod to access the `httpbin`
    service. Create a `utilities` namespace with Istio injection disabled, and create
    a `curl` Deployment with its own service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure the `istio-injection` label is not applied. If it is, you can remove
    it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `curl` Pod, try to access the `httpbin` Pod and you should get a response
    back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, we have the `httpbin` Pod running in the mesh, but by default, in *permissive*
    TLS mode. We will now create a `PeerAuthentication` policy to enforce `STRICT`
    mTLS. The `PeerAuthentication` policy defines how traffic will be tunneled via
    sidecars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `PeerAuthentication` policy, we defined the following configuration
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mtls`: This defines the mTLS setting. If not specified, the value is inherited
    from the default mesh-wide setting. It has one field called `mode`, which can
    have the following values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNSET`: With this value, the mTLS settings are inherited from the parent and
    if the parent does not have any settings, then the value is set to `PERMISSIVE`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MTLS`: With this value, the sidecar accepts both mTLS and non-mTLS connections.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STRICT`: This enforces strict mTLS – any non-mTLS connection will be dropped.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISABLE`: mTLS is disabled and connections are not tunneled.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector`: This defines the criteria that need to be satisfied by a workload
    to be part of this per authentication policy. It has a field named `matchLabels`,
    which takes label information in the `key:value` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize the configuration, we have created `httpbin-strict-tls`, which
    is a `PeerAuthentication` policy in the `Chapter6` namespace. The policy enforces
    string mTLS for all workloads that have a label of `app=httpbin`. The configuration
    is available at `Chapter6/02-httpbin-strictTLS.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the changes via the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now try to connect to the `httpbin` service from the `curl` Pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`curl` is not able to connect because the `curl` Pod is running in a namespace
    with Istio injection disabled, whereas the `httpbin` Pod is running in the mesh
    with the `PeerAuthentication` policy enforcing `STRICT` mTLS. One option is to
    manually establish an mTLS connection, which is equivalent to modifying your application
    code to perform mTLS. In this case, as we are trying to simulate service communication
    within the mesh, we can simply turn on Istio injection and let Istio take care
    of client-side mTLS as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable Istio injection for the `curl` Pod using the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the resource created by `Chapter6/01-curl-deployment.yaml`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the value of Istio injection to be enabled.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the updated configuration.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the `curl` Pod is in the `RUNNING` state, along with the istio-proxy sidecar,
    you can perform `curl` on the `httpbin` service and you will see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the response from the `httpbin` service, you will notice all the headers
    that were received by the `httpbin` Pod. The most interesting header is `X-Forwarded-Client-Cert`,
    also called `XFCC`. There are two parts of the `XFCC` header value that shed light
    on mTLS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`By`: This is filled with the SAN, which is the SPIFFE ID of the istio-proxy’s
    client certificate of the `httpbin` Pod (`spiffe://cluster.local/ns/chapter6/sa/httpbin`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URI`: This contains the SAN, which is the SPIFFE ID of the `curl` Pod’s client
    certificate presented during mTLS (`spiffe://cluster.local/ns/utilities/sa/curl`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also `Hash`, which is the SHA256 digest of istio-proxy’s client certificate
    of the `httpbin` Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can selectively apply mTLS configuration at the port level also. In the
    following configuration, we are implying that mTLS is enforced strictly for all
    ports except port `8080`, which should allow permissive connections. The configuration
    is available at `Chapter6/03-httpbin-strictTLSwithException.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, in this section, we learned how to perform mTLS between services inside
    the mesh. mTLS can be enabled at the service level as well as at the port level.
    In the next section, we will read about performing mTLS with clients outside the
    mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to clean up `Chapter6/01-httpbin-deployment.yaml`, `Chapter6/01-curl-deployment.yaml`
    and `Chapter6/02-httpbin-strictTLS.yaml` to avoid conflict in upcoming exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with clients outside the mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For clients outside the mesh, Istio supports mTLS with the Istio Ingress gateway.
    In *Chapter 5*, we configured HTTPS at the Ingress gateway. In this section, we
    will extend that configuration to also support mTLS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now configure mTLS for the `httpbin` Pod. Notice that the first five
    steps are very similar to *steps 1-5* of *Exposing Ingress over HTTPS* of *Chapter
    5*. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a CA. Here, we are creating a CA with a `sock.inc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a CSR for `httpbin.org`. Here, we are generating a `httpbin.org`,
    which also generates a private key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sign the CSR using the CA created in *step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the certificate and private key as a Kubernetes secret along with the
    CA certificate against which client certificates must be verified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the Ingress gateway to enforce mTLS for all incoming connections
    and use the secret created in *step 4* as the secret containing TLS certificate
    and the CA certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the `httpbin` Pod, the Ingress gateway, and the virtual service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To perform mTLS, you also need to generate client certificates that can be
    used to prove the client’s identity. For that, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the connection to `httpbin.org` by passing client certificates in the
    request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to clean up using `kubectl delete -n istio-system secret httpbin-credential`
    and `kubectl delete -``f Chapter6/02-httpbin-deployment-MTLS.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RequestAuthentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like service-to-service authentication, Istio can also authenticate an end user
    or validate that an end user has been authenticated based on assertions presented
    by the end user. The `RequestAuthentication` policy is used to specify what authentication
    methods are supported by a workload. This policy identifies the authenticated
    identity but doesn’t enforce whether the request should be allowed or denied.
    Rather, it provides information about the authenticated identity to the authorization
    policy, which we will go through in the next section. In this section, we will
    learn how to make use of the Istio `RequestAuthentication` policy to validate
    an end user who has been authenticated by Auth0 and is providing a bearer token
    as security credentials to Istio. If you are not familiar with OAuth then you
    can read more about it at [https://auth0.com/docs/authenticate/protocols/oauth](https://auth0.com/docs/authenticate/protocols/oauth).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow the hands-on steps to configure Auth0 and perform an OAuth flow
    while at the same time demystifying all that is happening under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign up for Auth0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Auth0 signup](img/B17989_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Auth0 signup
  prefs: []
  type: TYPE_NORMAL
- en: 'After signing up, create an application in Auth0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Create application in Auth0](img/B17989_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Create application in Auth0
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the application, you will need to create an API. You can provide
    the Ingress URL as the identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Create an API in Auth0](img/B17989_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Create an API in Auth0
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare permissions the consumer of this API needs to have to be able to access
    the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – API scopes in Auth0](img/B17989_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – API scopes in Auth0
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable RBAC for the API from **General Settings**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Enable RBAC for the API in Auth0](img/B17989_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Enable RBAC for the API in Auth0
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the API, go back to the application and authorize the application
    for access to the EnvoyDummy API, and while doing so, please also configure scopes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Grant permission to the application in Auth0](img/B17989_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Grant permission to the application in Auth0
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step, go to the application page to get the request you can use
    to get the access token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Quickstart example to get the access token in Auth0](img/B17989_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Quickstart example to get the access token in Auth0
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `curl` string, including `client_id`, `client_secret`, and so on, and
    with this, we have completed all the steps in Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using the `curl` string you copied in the previous steps, get the access
    token from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have received the access token, we will apply the `RequestAuthentication`
    policy. The `RequestAuthentication` policy specifies the details of how to validate
    the JWT provided during authentication. Following is the **RequestAuthentication**
    policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration, also available in `Chapter6/01-requestAuthentication.yaml`,
    we are declaring a `auth0` in the `chapter6` namespace with the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`issuer`: This is the value of the domain of the Auth0 application. You can
    fetch the value from the following screen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Application domain](img/B17989_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Application domain
  prefs: []
  type: TYPE_NORMAL
- en: '`jwksUri`: This is the JWKS endpoint, which can be used by Istio to verify
    the signature. Auth0 exposes a JWKS endpoint for each tenant, which is found at
    `https://DOMAIN/.well-known/jwks.json`. This endpoint will contain the JWK used
    to verify all Auth0-issued JWTs for this tenant. Replace the `DOMAIN` value with
    the value in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using the `RequestAuthentication` policy, it is best practice to also
    configure the `RequestAuthentication` and `AuthorizationPolicy` together and enforce
    a rule that any request with an empty principal should not be allowed. Following
    is an example of a sample authorization policy – you will read more about authorization
    policies in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Configuring RequestAuthorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we configured a `RequestAuthentication` policy, which
    verifies a JWT token against the issuer and JWK details as per the JWKS location.
    We configured Auth0 as the authentication provider and the one that generates
    the bearer token. In this section, we will learn about how to make use of the
    information provided by authentication policies such as peer authentication and
    request authentication to authorize client access to the server (the requested
    resource, Pod, workload, service, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: We will first focus on implementing an authorization policy in conjunction with
    the `RequestAuthentication` policy from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To let `curl` access the envoy dummy using the access token issued by Auth0,
    we need to create an `AuthorizationPolicy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthorizationPolicy` contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action`: This defines the type of action to be taken when the request matches
    the defined rule. Possible values for `action` are `ALLOW`, `DENY`, and `AUDIT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selector`: This defines what workload this policy should be applied to. Here,
    you provide a set of labels that should match the workload’s label to be part
    of a selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rules`: Here, we are defining a set of rules that should be matched with the
    request. Rules contain the following sub-configurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: This provides the rule about the origin of the request.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to`: This provides rules about the request such as to what host it was addressed,
    what the method name is, and what resource identified by the URI is requested.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when`: This specifies a list of additional conditions. You can find a detailed
    list of all parameters at [https://istio.io/latest/docs/reference/config/security/conditions/](https://istio.io/latest/docs/reference/config/security/conditions/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we are defining an authorization policy that allows access
    to Pods with the label `name:envoydummy` if the request contains an authenticated
    JWT token with a claim of `read:profile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we apply the changes, make sure that you can access the dummy data and
    make sure you have the Ingress gateway and `envoydummy` Pods deployed in the `utilities`
    namespace – if not, you can do that by applying the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and apply both of the policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that you are able to access `mockshop.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The access is denied because we need to provide a valid access token as part
    of the request. Copy the access token you got from the previous request and try
    again in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the JWT verification succeeded, the request failed due to RBAC controls.
    The error is deliberate because instead of providing `read:dummyData` in `Chapter6/02-requestAuthorization.yaml`,
    we provide `read:profile`. The changes are updated in `Chapter6/03-requestAuthorization.yaml`.
    Apply the changes and test the APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize, we did the following, including the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: We configured Auth0 as the authentication provider and OAuth server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a `RequestAuthentication` policy to validate the bearer token provided
    in the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created an `AuthorizationPolicy` to verify claims presented in the JWT token
    and whether the claim matched the desired value, then let the request go through
    the upstream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will learn how to configure request authorization in conjunction with
    `PeerAuthentication`, which we configured in the *Service-to-service* *authentication*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will modify the `curl` Pod to use a different service account, and let’s
    call it `chapter6sa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you cannot change the service account of an existing Pod, you need to delete
    the previous deployment and redeploy with a new service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check that the `curl` Pod is running with the identity of the `chapter6sa`
    service account. After this, let’s create an `AuthorizationPolicy` to allow a
    request to the `httpbin` Pod if the principal of the requestor is `cluster.local/ns/utilities/sa/curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we looked at `AuthorizationPolicy` and you will be familiar with
    most of the configuration in this example. In this example, we are building `AuthorizationPolicy`
    on top of peer authentication rather than request authentication. The most interesting
    part is the `source` field in the `rules` section. In the `source` configuration,
    we define the source identities of the request. All fields in the source request
    need to match for the rule to be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fields can be defined in the `source` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`principals`: This is a list of accepted identities that are derived from the
    client certificate during mTLS. The values are in the `<TRUST_DOMAIN NAME >/ns/<NAMESPACE
    NAME>/sa/<SERVICE_ACCOUNT NAME>` format. In this example, the value of principals
    will be `cluster.local/ns/utilities/sa/curl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notPrincipals`: This is a list of identities from which the request will not
    be accepted. The values are derived the same way as `principals`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestPrincipals`: This is a list of accepted identities where the request
    principal is derived from JWT and is in the format `<ISS>/<SUB>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notRequestPrincipals`: This is a list of identities from which the request
    will not be accepted. The principal is derived from the JWT and is in the format
    `<ISS>/<SUB>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespaces`: This is a list of namespaces from which the request will be accepted.
    The namespaces are derived from the peer certificate details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notNamespaces`: This is a list of namespaces from which a request will not
    be allowed. The namespaces are derived from the peer certificate details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipBlocks`: This is a list of IPs or CIDR blocks from which a request will
    be accepted. The IP is populated from the source address of the IP packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notIpBlocks`: This is a list of IP blocks from which a request will be rejected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remoteIpBlocks`: This is a list of IP blocks, populated from the `X-Forwarded-For`
    header or proxy protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notRemoteIpBlocks`: This is a negative list of `remoteIpBlocks`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead and apply the configuration and test whether you are able to `curl`
    to `httpbin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Istio denies the request from the `curl` Pod to `httpbin` because the peer certificate
    presented by the `curl` Pod contains `cluster.local/ns/utilities/sa/chapter6sa`
    instead of `cluster.local/ns/utilities/sa/curl` as the principal. Although the
    `curl` Pod is part of the mesh and contains a valid certificate, it is not authorized
    to access the `httpbin` Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and fix the problem by assigning the correct service account to the
    `curl` Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following commands to fix the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We will implement one more authorization policy, but this time the policy will
    enforce that using the `utilities` or `curl` service account, the requestor can
    access only `/headers` of `httpbin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the authorization policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this policy, we have defined the `HTTP` method and `HTTP` paths in the `to`
    field on the rule. The `to` field contains a list of operations on which the rules
    will be applied. The operation field supports the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hosts`: This specifies a list of hostnames for which the request will be accepted.
    If it’s not set, then any host is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notHosts`: This is a negative list of hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: This is a list of ports for which a request will be accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notPorts`: This is a list of negative matches of ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`methods`: This is a list of methods as specified in the HTTP request. If not
    set, any method is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notMethods`: This is a list of negative matches of methods as specified in
    the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paths`: This is a list of paths as specified in the HTTP request. Paths are
    normalized as per [https://istio.io/latest/docs/reference/config/security/normalization/](https://istio.io/latest/docs/reference/config/security/normalization/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notPaths`: This is a list of negative matches of paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apply the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And then try to access `httpbin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Access to the request is denied because the authorization policy only allows
    the `/get` request made using the HTTP GET method. The following is the correct
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our lesson on how you can build custom policies for performing
    request authentication and request authorization. To get more familiar with them,
    I suggest going through the examples in this chapter a few times and maybe building
    your own variations to learn how to use these policies effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we read about how Istio provides authentication and authorization.
    We also read about how to implement service-to-service authentication using mutual
    TLS within a Service Mesh using the `PeerAuthentication` policy, as well as mutual
    TLS with clients external to a Service Mesh by using the *mutual* TLS mode at
    the Ingress gateway. We then read about end user authentication using the `RequestAuthentication`
    policy. We configured Auth0 to gain some real-life experience in using authentication
    and identity providers.
  prefs: []
  type: TYPE_NORMAL
- en: To finish off, we then read about `AuthorizationPolicy` and how it can be used
    to enforce various authorization checks to ensure that the authenticated identity
    is authorized to access the requested resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will read about how Istio helps in making microservices
    observable and how various observability tools and software can be integrated
    with Istio.
  prefs: []
  type: TYPE_NORMAL
