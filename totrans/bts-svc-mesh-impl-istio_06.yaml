- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Securing Microservices Communication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务通信的安全性
- en: Istio secures communication between microservices without microservices requiring
    any code changes. In *Chapter 4*, we briefly touched upon the topic of security.
    We configured transport layer security by exposing our sockshop application over
    HTTPS. We created certificates and configured the Istio Ingress gateway to bind
    those certificates to hostnames in SIMPLE TLS mode. We also implemented TLS-based
    security for multiple hosts managed by a single Ingress gateway.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 可以在微服务之间保障通信安全，而无需对微服务进行任何代码修改。在*第 4 章*中，我们简要介绍了安全性的话题。我们通过将我们的 sockshop
    应用暴露为 HTTPS 来配置传输层安全性。我们创建了证书，并配置 Istio Ingress 网关将这些证书绑定到主机名，采用 SIMPLE TLS 模式。我们还为由单个
    Ingress 网关管理的多个主机实现了基于 TLS 的安全性。
- en: 'In this chapter, we will dive deeper into some advanced topics of security.
    We will start by understanding Istio security architecture. We will implement
    mutual TLS for service communication with other services in the mesh, and we will
    also implement mutual TLS with downstream clients outside the mesh. We will then
    perform various hands-on exercises to create custom security policies for authentication
    and authorization. We will go through these topics in the following order:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨一些安全方面的高级主题。我们将首先了解 Istio 安全架构，然后实现服务与网格内其他服务之间的互相 TLS 认证，并实现与网格外下游客户端的互相
    TLS 认证。接着，我们将进行各种实践操作，创建自定义安全策略用于身份验证和授权。我们将按以下顺序进行这些主题的讲解：
- en: Istio security architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio 安全架构
- en: Authenticating using mutual TLS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互相 TLS 认证
- en: How to configure a custom authentication and authorization policy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置自定义的身份验证和授权策略
- en: Important note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The technical prerequisites for this chapter are the same as *Chapters 4* and
    *5*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术前提与*第 4 章*和*第 5 章*相同。
- en: Understanding Istio security architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Istio 安全架构
- en: In *Chapter 3*, we discussed how the Istio control plane is responsible for
    the injection of sidecars and establishing trust so that sidecars can communicate
    with the control plane securely and security policies are eventually enforced
    by the sidecar. When deployed in Kubernetes, Istio relies on Kubernetes service
    accounts to identify the roles of workloads in a Service Mesh. The Istio CA watches
    the Kubernetes API server for the addition/deletion/modification of any service
    accounts in the namespace with Istio injection enabled. It creates a key and certificates
    for each service account and, during Pod creation, the certificate and key are
    mounted onto the sidecar. The Istio CA is responsible for managing the life cycle
    of the certificates distributed to the sidecars, including the rotation and management
    of private keys. Using the **Secure Production Identity Framework for Everyone**
    (**SPIFFE**) format identities, Istio provides a strong identity to each service
    along with service naming, which represents the role that can be taken up by the
    identity assigned to the service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 3 章*中，我们讨论了 Istio 控制平面如何负责注入 sidecar 并建立信任，使得 sidecar 可以安全地与控制平面通信，同时安全策略最终由
    sidecar 强制执行。Istio 在 Kubernetes 中的部署依赖 Kubernetes 服务账户来识别服务网格中工作负载的角色。Istio CA
    监视 Kubernetes API 服务器，监听启用 Istio 注入的命名空间中任何服务账户的添加、删除或修改。它为每个服务账户创建密钥和证书，并在 Pod
    创建时将证书和密钥挂载到 sidecar 上。Istio CA 负责管理分发到 sidecar 上证书的生命周期，包括私钥的轮换和管理。通过使用**面向所有人的安全生产身份框架**（**SPIFFE**）格式身份，Istio
    为每个服务提供强大的身份及服务命名，表示分配给该服务的身份所能扮演的角色。
- en: SPIFFE is a set of open source standards for software identity. SPIFFE provides
    platform-agnostic interoperable software identities along with interfaces and
    documents required to obtain and validate cryptographic identity in a fully automated
    fashion.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SPIFFE 是一套针对软件身份的开源标准。SPIFFE 提供与平台无关的可互操作软件身份，并提供获取和验证加密身份所需的接口和文档，实现完全自动化的身份管理。
- en: In Istio, each workload is automatically assigned an identity represented in
    the X.509 certificate format. The creation and signing of **certificate signing
    request** (**CSRs**) are managed by the Istio control plane, as discussed in *Chapter
    3*. The X.509 certificate follows the SPIFFE format.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Istio 中，每个工作负载都会自动分配一个身份，表示为 X.509 证书格式。如*第 3 章*中所述，**证书签名请求**（**CSR**）的创建和签署由
    Istio 控制平面管理。X.509 证书遵循 SPIFFE 格式。
- en: 'Let’s redeploy the `envoydummy` service and inspect the `envoydummy` Pods:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新部署 `envoydummy` 服务并检查 `envoydummy` Pods：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: step CLI
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 CLI
- en: You will need to install step `CLI` to be able to run the preceding command.
    To install it, please follow the documentation at [https://smallstep.com/docs/step-cli](https://smallstep.com/docs/step-cli).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 `CLI` 步骤工具才能运行前面的命令。要安装它，请参考[https://smallstep.com/docs/step-cli](https://smallstep.com/docs/step-cli)中的文档。
- en: 'In the output of the preceding command, you will notice that the `spiffe://cluster.local/ns/utilities/sa/default`.
    This is the SPIFFE ID, which functions as the unique name:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面命令的输出中，你会注意到 `spiffe://cluster.local/ns/utilities/sa/default`。这是 SPIFFE ID，作为唯一标识符：
- en: '`spifee` is the URI scheme'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spiffe` 是 URI 协议'
- en: '`cluster.local` is the trust domain'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster.local` 是信任域'
- en: '`/ns/utilities/sa/default` is the URI identifying the service account associated
    with the workload:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ns/utilities/sa/default` 是标识与工作负载关联的服务账户的 URI：'
- en: '`ns` stands for namespace'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ns` 代表命名空间'
- en: '`sa` stands for service account'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sa` 代表服务账户'
- en: 'The value default for service accounts comes from the service account attached
    to the workload. In our example of `envoydummy`, we didn’t associate any service
    accounts so, by default, Kubernetes associated the `default` service account.
    You can find the service account name associated with a Pod using the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户的默认值来自于与工作负载关联的服务账户。在我们的 `envoydummy` 示例中，我们没有关联任何服务账户，因此，默认情况下，Kubernetes
    关联了 `default` 服务账户。你可以使用以下命令找到与 Pod 关联的服务账户名称：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will notice that `default` is the default name for service accounts associated
    with all Pods in all namespaces, such as `sock-shop`, `utilities`, and so on.
    Kubernetes creates a service account named `default` in every namespace:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，`default` 是与所有命名空间中的所有 Pod 关联的默认服务账户名称，例如 `sock-shop`、`utilities` 等。Kubernetes
    会在每个命名空间中创建一个名为 `default` 的服务账户：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Kubernetes service accounts
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务账户
- en: A service account is an identity assigned to workloads in Kubernetes. When processes
    running inside a workload try to access other Kubernetes resources, they are identified
    and authenticated as per the details of their service accounts. You can find more
    details about service accounts at [https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户是 Kubernetes 中分配给工作负载的身份。当工作负载内运行的进程尝试访问其他 Kubernetes 资源时，它们会根据其服务账户的详细信息进行身份验证和认证。你可以在[https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)中找到有关服务账户的更多详细信息。
- en: Secure Naming is a technology that decouples the name of services from the identities
    the services are running as. In the previous example, `spiffe://cluster.local/ns/utilities/sa/default`
    is the identity of the service presented during mutual TLS presented by the istio-proxy
    sidecar in `envoydummy-2-7488b58cd7-m5vpv workload`. From the SPIFFE ID, the other
    party (istio-proxy in another Pod) in the MTLS session can validate that the endpoint
    has the identity of a service account named `default` in the `utilities` namespace.
    The Istio control plane propagates the secure naming information to all sidecars
    in the mesh and during mutual TLS, the sidecar not only verifies that the identity
    is correct but also that the respective service is assuming the correct identity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安全命名是一种技术，它将服务的名称与服务运行的身份解耦。在前面的示例中，`spiffe://cluster.local/ns/utilities/sa/default`
    是服务在 mutual TLS 中由 `envoydummy-2-7488b58cd7-m5vpv` 工作负载中的 istio-proxy sidecar
    提供的身份。从 SPIFFE ID 中，MTLS 会话中的另一方（另一个 Pod 中的 istio-proxy）可以验证该端点是否具有名为 `default`
    的服务账户身份，并且该服务账户位于 `utilities` 命名空间中。Istio 控制平面将安全命名信息传播到网格中的所有 sidecar 容器，在 mutual
    TLS 过程中，sidecar 容器不仅验证身份是否正确，还验证相应的服务是否采用了正确的身份。
- en: 'The following diagram summarizes the Istio security architecture:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了 Istio 的安全架构：
- en: '![Figure 6.1 – Istio security architecture](img/B17989_06_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – Istio 安全架构](img/B17989_06_01.jpg)'
- en: Figure 6.1 – Istio security architecture
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Istio 安全架构
- en: 'These are the key concepts to remember:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是需要记住的关键概念：
- en: The Istio CA manages keys and certificates and the SANs in certificates are
    in SPIFFE format
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio CA 管理密钥和证书，并且证书中的 SANs 采用 SPIFFE 格式
- en: Istiod distributes authentication and authorization security policies to all
    sidecars in the mesh
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istiod 将认证和授权安全策略分发到网格中的所有 sidecar 容器
- en: Sidecars enforce authentication and authorization as per security policies distributed
    by Istiod
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sidecar 容器根据 Istiod 分发的安全策略强制执行认证和授权
- en: Reminder
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Make sure to clean up `Chapter6/01-envoy-dummy.yaml` to avoid conflict in upcoming
    exercises.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保清理 `Chapter6/01-envoy-dummy.yaml` 文件，以避免后续练习中的冲突。
- en: In the next section, we will read about how to secure data in transit between
    microservices in a Service Mesh.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习如何在服务网格中保护微服务之间的传输数据。
- en: Authentication using mutual TLS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用双向 TLS 进行身份验证
- en: '**Mutual TLS** (**mTLS)** is a technique for authenticating two parties at
    each end of a network connection. Through mTLS, each party can verify that the
    other party is what they are claiming to be. Certificate authorities play a critical
    role in mTLS, and hence we had the previous section on Istio security architecture
    describing certificate authorities and secure naming in Istio.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向 TLS** (**mTLS**) 是一种在网络连接两端验证双方身份的技术。通过 mTLS，双方可以验证对方是否如其所声明的那样。证书颁发机构在
    mTLS 中扮演着关键角色，因此我们在前一部分中介绍了 Istio 安全架构，讲解了证书颁发机构和 Istio 中的安全命名。'
- en: mTLS is one of the most frequently used authentication mechanisms for implementing
    the zero-trust security framework, in which no party trusts another party by default,
    irrespective of where the other party is placed in the network. Zero trust assumes
    that there are no traditional network edges and boundaries and hence every party
    needs to be authenticated and authorized. This helps to eliminate many security
    vulnerabilities that arise because of the assumption-based trust model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: mTLS 是实现零信任安全框架中最常用的身份验证机制之一，其中任何一方默认都不信任另一方，无论该方在网络中的位置如何。零信任假设没有传统的网络边界，因此每一方都需要进行身份验证和授权。这有助于消除基于假设信任模型所带来的许多安全漏洞。
- en: In the following two subsections, we will look at how Istio helps you implement
    mTLS for service-to-service authentication inside a mesh, also called east-west
    traffic, and mTLS between client/downstream systems that are outside the mesh,
    with services in the mesh called north-south communication.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个小节中，我们将了解 Istio 如何帮助你实现服务到服务的 mTLS 身份验证，也就是在网格内的东西-东西流量，以及在网格外的客户端/下游系统与网格内的服务之间的
    mTLS，即南北向通信。
- en: Service-to-service authentication
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务到服务的身份验证
- en: 'Istio provides service-to-service authentication by using mTLS for transport
    authentication. During traffic processing, Istio performs the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过使用 mTLS 进行传输认证来提供服务到服务的身份验证。在流量处理过程中，Istio 执行以下操作：
- en: All outbound traffic from Pods is rerouted to istio-proxy.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有来自 Pods 的外发流量都将被重新路由到 istio-proxy。
- en: istio-proxy starts an mTLS handshake with the server-side istio-proxy. During
    the handshake, it also does a secure naming check to verify that the service account
    presented in the server certificate can run the Pod.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: istio-proxy 与服务器端 istio-proxy 发起 mTLS 握手。在握手过程中，它还会进行安全命名检查，以验证服务器证书中呈现的服务账户是否可以运行该
    Pod。
- en: The server-side istio-proxy verifies the client-side istio-proxy in the same
    fashion and if all is okay, a secure channel is established between the two proxies.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端的 istio-proxy 以相同的方式验证客户端的 istio-proxy，如果一切正常，则在两个代理之间建立安全通道。
- en: 'Istio provides the following two options when implementing mTLS:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 在实现 mTLS 时提供以下两种选项：
- en: '**Permissive mode**: In permissive mode, Istio allows traffic in both mTLS
    and non-mTLS mode. This feature is primarily to improve the onboarding of clients
    to mTLS. Clients who are not yet ready to communicate over mTLS can continue communicating
    over TLS with the view that they will eventually migrate to mTLS whenever they
    are ready.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽松模式**：在宽松模式下，Istio 允许 mTLS 和非 mTLS 模式的流量。此功能主要是为了改善客户端向 mTLS 过渡的过程。尚未准备好通过
    mTLS 进行通信的客户端可以继续通过 TLS 进行通信，预计它们最终会在准备好时迁移到 mTLS。'
- en: '**Strict mode**: In strict mode, Istio enforces strict mTLS and any non-mTLS
    traffic is not allowed.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严格模式**：在严格模式下，Istio 强制执行严格的 mTLS，任何非 mTLS 流量都不被允许。'
- en: Mutual TLS traffic can be established between clients outside of a mesh trying
    to access a workload within the mesh, as well as clients within the mesh trying
    to access other workloads in the mesh. For the former, we will discuss the details
    in the next section. For the latter set of clients, we will go through some examples
    in this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 双向 TLS 流量可以在尝试访问网格内工作负载的网格外客户端与尝试访问网格内其他工作负载的网格内客户端之间建立。对于前者，我们将在下一部分中讨论详细信息。对于后者，我们将在本部分中通过一些示例进行讲解。
- en: 'Let’s set up service-to-service communication using mTLS:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 mTLS 设置服务到服务的通信：
- en: 'Create a namespace called `chapter6` with Istio injection enabled and deploy
    the `httpbin` service:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`chapter6`的命名空间，并启用Istio注入，然后部署`httpbin`服务：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Most of the config in this deployment is the usual, except that we have also
    created a default Kubernetes service account called `httpbin` in the `Chapter6`
    namespace:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部署中的大部分配置都是常规配置，唯一不同的是我们在`Chapter6`命名空间中创建了一个名为`httpbin`的默认Kubernetes服务账户：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `httpbin` identity is then assigned to an `httpbin` Pod by following these
    specs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下规范将`httpbin`身份分配给`httpbin` Pod：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will create a client in the form of a `curl` Pod to access the `httpbin`
    service. Create a `utilities` namespace with Istio injection disabled, and create
    a `curl` Deployment with its own service account:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个以`curl` Pod形式的客户端来访问`httpbin`服务。创建一个禁用Istio注入的`utilities`命名空间，并创建一个带有自己服务账户的`curl`
    Deployment：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make sure the `istio-injection` label is not applied. If it is, you can remove
    it using the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保没有应用`istio-injection`标签。如果有，可以使用以下命令将其移除：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the `curl` Pod, try to access the `httpbin` Pod and you should get a response
    back:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`curl` Pod，尝试访问`httpbin` Pod，应该能收到响应：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far, we have the `httpbin` Pod running in the mesh, but by default, in *permissive*
    TLS mode. We will now create a `PeerAuthentication` policy to enforce `STRICT`
    mTLS. The `PeerAuthentication` policy defines how traffic will be tunneled via
    sidecars:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在网格中运行了`httpbin` Pod，但默认情况下，它处于*宽松* TLS模式。现在我们将创建一个`PeerAuthentication`策略，以强制执行`STRICT`
    mTLS。`PeerAuthentication`策略定义了如何通过侧车隧道传输流量：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `PeerAuthentication` policy, we defined the following configuration
    parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PeerAuthentication`策略中，我们定义了以下配置参数：
- en: '`mtls`: This defines the mTLS setting. If not specified, the value is inherited
    from the default mesh-wide setting. It has one field called `mode`, which can
    have the following values:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mtls`：这定义了mTLS设置。如果未指定，则该值从默认的网格级别设置继承。它有一个名为`mode`的字段，可以具有以下值：'
- en: '`UNSET`: With this value, the mTLS settings are inherited from the parent and
    if the parent does not have any settings, then the value is set to `PERMISSIVE`.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNSET`：此值表示mTLS设置从父级继承，如果父级没有任何设置，则将值设置为`PERMISSIVE`。'
- en: '`MTLS`: With this value, the sidecar accepts both mTLS and non-mTLS connections.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MTLS`：此值使侧车接受mTLS和非mTLS连接。'
- en: '`STRICT`: This enforces strict mTLS – any non-mTLS connection will be dropped.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STRICT`：这会强制执行严格的mTLS—任何非mTLS连接都会被拒绝。'
- en: '`DISABLE`: mTLS is disabled and connections are not tunneled.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISABLE`：禁用mTLS，连接不进行隧道传输。'
- en: '`Selector`: This defines the criteria that need to be satisfied by a workload
    to be part of this per authentication policy. It has a field named `matchLabels`,
    which takes label information in the `key:value` format.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector`：这定义了工作负载必须满足的条件，才能成为此身份验证策略的一部分。它有一个名为`matchLabels`的字段，用于以`key:value`格式接受标签信息。'
- en: To summarize the configuration, we have created `httpbin-strict-tls`, which
    is a `PeerAuthentication` policy in the `Chapter6` namespace. The policy enforces
    string mTLS for all workloads that have a label of `app=httpbin`. The configuration
    is available at `Chapter6/02-httpbin-strictTLS.yaml`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下配置，我们创建了`httpbin-strict-tls`，这是`Chapter6`命名空间中的一个`PeerAuthentication`策略。该策略对所有具有`app=httpbin`标签的工作负载强制执行mTLS连接。该配置文件位于`Chapter6/02-httpbin-strictTLS.yaml`。
- en: 'Apply the changes via the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令应用更改：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now try to connect to the `httpbin` service from the `curl` Pod:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试从`curl` Pod连接到`httpbin`服务：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`curl` is not able to connect because the `curl` Pod is running in a namespace
    with Istio injection disabled, whereas the `httpbin` Pod is running in the mesh
    with the `PeerAuthentication` policy enforcing `STRICT` mTLS. One option is to
    manually establish an mTLS connection, which is equivalent to modifying your application
    code to perform mTLS. In this case, as we are trying to simulate service communication
    within the mesh, we can simply turn on Istio injection and let Istio take care
    of client-side mTLS as well.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`无法连接，因为`curl` Pod运行在禁用Istio注入的命名空间中，而`httpbin` Pod运行在启用了`PeerAuthentication`策略并强制执行`STRICT`
    mTLS的网格中。一种解决方案是手动建立mTLS连接，这相当于修改应用程序代码来执行mTLS。在这种情况下，由于我们正在模拟网格内的服务通信，我们可以简单地启用Istio注入，让Istio处理客户端的mTLS。'
- en: 'Enable Istio injection for the `curl` Pod using the following steps:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下步骤为`curl` Pod启用Istio注入：
- en: Delete the resource created by `Chapter6/01-curl-deployment.yaml`.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除由`Chapter6/01-curl-deployment.yaml`创建的资源。
- en: Modify the value of Istio injection to be enabled.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 Istio 注入的值以启用。
- en: Apply the updated configuration.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用更新的配置。
- en: 'Once the `curl` Pod is in the `RUNNING` state, along with the istio-proxy sidecar,
    you can perform `curl` on the `httpbin` service and you will see the following
    output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `curl` Pod 处于 `RUNNING` 状态，并且与 istio-proxy sidecar 一起，您可以对 `httpbin` 服务执行
    `curl`，并看到以下输出：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the response from the `httpbin` service, you will notice all the headers
    that were received by the `httpbin` Pod. The most interesting header is `X-Forwarded-Client-Cert`,
    also called `XFCC`. There are two parts of the `XFCC` header value that shed light
    on mTLS:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `httpbin` 服务的响应中，您会注意到所有由 `httpbin` Pod 接收到的头信息。最有趣的头信息是 `X-Forwarded-Client-Cert`，也叫
    `XFCC`。`XFCC` 头值的两个部分揭示了 mTLS 的信息：
- en: '`By`: This is filled with the SAN, which is the SPIFFE ID of the istio-proxy’s
    client certificate of the `httpbin` Pod (`spiffe://cluster.local/ns/chapter6/sa/httpbin`)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`By`：这里填写的是 SAN，即 `httpbin` Pod 的 istio-proxy 客户端证书的 SPIFFE ID（`spiffe://cluster.local/ns/chapter6/sa/httpbin`）'
- en: '`URI`: This contains the SAN, which is the SPIFFE ID of the `curl` Pod’s client
    certificate presented during mTLS (`spiffe://cluster.local/ns/utilities/sa/curl`)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URI`：它包含 SAN，这是在 mTLS 过程中呈现的 `curl` Pod 客户端证书的 SPIFFE ID（`spiffe://cluster.local/ns/utilities/sa/curl`）'
- en: There is also `Hash`, which is the SHA256 digest of istio-proxy’s client certificate
    of the `httpbin` Pod.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 `Hash`，它是 `httpbin` Pod 的 istio-proxy 客户端证书的 SHA256 摘要。
- en: 'You can selectively apply mTLS configuration at the port level also. In the
    following configuration, we are implying that mTLS is enforced strictly for all
    ports except port `8080`, which should allow permissive connections. The configuration
    is available at `Chapter6/03-httpbin-strictTLSwithException.yaml`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在端口级别选择性地应用 mTLS 配置。在以下配置中，我们暗示所有端口都严格执行 mTLS，除了 `8080` 端口，它应该允许宽松的连接。配置文件位于
    `Chapter6/03-httpbin-strictTLSwithException.yaml`：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, in this section, we learned how to perform mTLS between services inside
    the mesh. mTLS can be enabled at the service level as well as at the port level.
    In the next section, we will read about performing mTLS with clients outside the
    mesh.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在本节中，我们学习了如何在网格内的服务之间执行 mTLS。mTLS 可以在服务级别以及端口级别启用。在下一节中，我们将学习如何与网格外的客户端执行
    mTLS。
- en: Reminder
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Make sure to clean up `Chapter6/01-httpbin-deployment.yaml`, `Chapter6/01-curl-deployment.yaml`
    and `Chapter6/02-httpbin-strictTLS.yaml` to avoid conflict in upcoming exercises.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保清理 `Chapter6/01-httpbin-deployment.yaml`、`Chapter6/01-curl-deployment.yaml`
    和 `Chapter6/02-httpbin-strictTLS.yaml`，以避免在接下来的练习中发生冲突。
- en: Authentication with clients outside the mesh
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与网格外客户端的身份验证
- en: For clients outside the mesh, Istio supports mTLS with the Istio Ingress gateway.
    In *Chapter 5*, we configured HTTPS at the Ingress gateway. In this section, we
    will extend that configuration to also support mTLS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网格外的客户端，Istio 支持通过 Istio Ingress 网关进行 mTLS。在*第 5 章*中，我们已在 Ingress 网关上配置了 HTTPS。在本节中，我们将扩展该配置以同时支持
    mTLS。
- en: 'We will now configure mTLS for the `httpbin` Pod. Notice that the first five
    steps are very similar to *steps 1-5* of *Exposing Ingress over HTTPS* of *Chapter
    5*. The steps are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为 `httpbin` Pod 配置 mTLS。请注意，前五个步骤与*第 5 章*中*通过 HTTPS 暴露 Ingress*的*步骤 1-5*非常相似。步骤如下：
- en: 'Create a CA. Here, we are creating a CA with a `sock.inc`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 CA。在这里，我们正在用 `sock.inc` 创建一个 CA：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Generate a CSR for `httpbin.org`. Here, we are generating a `httpbin.org`,
    which also generates a private key:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `httpbin.org` 生成 CSR。在这里，我们正在为 `httpbin.org` 生成 CSR，这也会生成一个私钥：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Sign the CSR using the CA created in *step 1*:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*第 1 步*中创建的 CA 签署 CSR：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Load the certificate and private key as a Kubernetes secret along with the
    CA certificate against which client certificates must be verified:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将证书和私钥作为 Kubernetes 密钥与必须验证客户端证书的 CA 证书一起加载：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Configure the Ingress gateway to enforce mTLS for all incoming connections
    and use the secret created in *step 4* as the secret containing TLS certificate
    and the CA certificate:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Ingress 网关以强制所有传入连接使用 mTLS，并使用*第 4 步*中创建的密钥作为包含 TLS 证书和 CA 证书的密钥：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Deploy the `httpbin` Pod, the Ingress gateway, and the virtual service:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 `httpbin` Pod、Ingress 网关和虚拟服务：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To perform mTLS, you also need to generate client certificates that can be
    used to prove the client’s identity. For that, perform the following steps:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行 mTLS，您还需要生成客户端证书，以证明客户端的身份。为此，请执行以下步骤：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Test the connection to `httpbin.org` by passing client certificates in the
    request:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在请求中传递客户端证书来测试与 `httpbin.org` 的连接：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reminder
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Don’t forget to clean up using `kubectl delete -n istio-system secret httpbin-credential`
    and `kubectl delete -``f Chapter6/02-httpbin-deployment-MTLS.yaml`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了清理，使用`kubectl delete -n istio-system secret httpbin-credential` 和 `kubectl
    delete -f Chapter6/02-httpbin-deployment-MTLS.yaml`。
- en: Configuring RequestAuthentication
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置RequestAuthentication
- en: Like service-to-service authentication, Istio can also authenticate an end user
    or validate that an end user has been authenticated based on assertions presented
    by the end user. The `RequestAuthentication` policy is used to specify what authentication
    methods are supported by a workload. This policy identifies the authenticated
    identity but doesn’t enforce whether the request should be allowed or denied.
    Rather, it provides information about the authenticated identity to the authorization
    policy, which we will go through in the next section. In this section, we will
    learn how to make use of the Istio `RequestAuthentication` policy to validate
    an end user who has been authenticated by Auth0 and is providing a bearer token
    as security credentials to Istio. If you are not familiar with OAuth then you
    can read more about it at [https://auth0.com/docs/authenticate/protocols/oauth](https://auth0.com/docs/authenticate/protocols/oauth).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像服务到服务的身份验证一样，Istio也可以验证终端用户，或者基于终端用户提供的声明验证终端用户是否已被验证。`RequestAuthentication`策略用于指定工作负载支持的身份验证方法。该策略识别经过身份验证的身份，但不强制要求请求是否应该被允许或拒绝。相反，它将经过身份验证的身份信息提供给授权策略，我们将在下一节中介绍。在本节中，我们将学习如何利用Istio的`RequestAuthentication`策略来验证已经通过Auth0身份验证并提供承载令牌作为Istio安全凭证的终端用户。如果你不熟悉OAuth，可以在[https://auth0.com/docs/authenticate/protocols/oauth](https://auth0.com/docs/authenticate/protocols/oauth)查看更多信息。
- en: 'We will follow the hands-on steps to configure Auth0 and perform an OAuth flow
    while at the same time demystifying all that is happening under the hood:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照动手操作步骤配置Auth0，并执行OAuth流程，同时揭开所有幕后发生的事情：
- en: 'Sign up for Auth0:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册Auth0：
- en: '![Figure 6.2 – Auth0 signup](img/B17989_06_02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – Auth0注册](img/B17989_06_02.jpg)'
- en: Figure 6.2 – Auth0 signup
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – Auth0注册
- en: 'After signing up, create an application in Auth0:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册后，在Auth0中创建应用：
- en: '![Figure 6.3 – Create application in Auth0](img/B17989_06_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 在Auth0中创建应用](img/B17989_06_03.jpg)'
- en: Figure 6.3 – Create application in Auth0
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 在Auth0中创建应用
- en: 'After creating the application, you will need to create an API. You can provide
    the Ingress URL as the identifier:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用后，你需要创建一个API。你可以提供Ingress URL作为标识符：
- en: '![Figure 6.4 – Create an API in Auth0](img/B17989_06_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 在Auth0中创建API](img/B17989_06_04.jpg)'
- en: Figure 6.4 – Create an API in Auth0
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 在Auth0中创建API
- en: 'Declare permissions the consumer of this API needs to have to be able to access
    the API:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明API消费者需要具备的权限，才能访问该API：
- en: '![Figure 6.5 – API scopes in Auth0](img/B17989_06_05.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – Auth0中的API作用域](img/B17989_06_05.jpg)'
- en: Figure 6.5 – API scopes in Auth0
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – Auth0中的API作用域
- en: 'Enable RBAC for the API from **General Settings**:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**常规设置**启用API的RBAC：
- en: '![Figure 6.6 – Enable RBAC for the API in Auth0](img/B17989_06_06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 在Auth0中启用API的RBAC](img/B17989_06_06.jpg)'
- en: Figure 6.6 – Enable RBAC for the API in Auth0
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 在Auth0中启用API的RBAC
- en: 'After creating the API, go back to the application and authorize the application
    for access to the EnvoyDummy API, and while doing so, please also configure scopes:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建API后，返回应用程序并授权应用访问EnvoyDummy API，同时也请配置作用域：
- en: '![Figure 6.7 – Grant permission to the application in Auth0](img/B17989_06_07.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 在Auth0中授予应用权限](img/B17989_06_07.jpg)'
- en: Figure 6.7 – Grant permission to the application in Auth0
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 在Auth0中授予应用权限
- en: 'As the last step, go to the application page to get the request you can use
    to get the access token:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，进入应用页面，获取可以用来获取访问令牌的请求：
- en: '![Figure 6.8 – Quickstart example to get the access token in Auth0](img/B17989_06_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 在Auth0中获取访问令牌的快速入门示例](img/B17989_06_08.jpg)'
- en: Figure 6.8 – Quickstart example to get the access token in Auth0
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 在Auth0中获取访问令牌的快速入门示例
- en: Copy the `curl` string, including `client_id`, `client_secret`, and so on, and
    with this, we have completed all the steps in Auth0.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 复制`curl`字符串，包括`client_id`、`client_secret`等，至此我们完成了所有Auth0的步骤。
- en: 'Now, using the `curl` string you copied in the previous steps, get the access
    token from the terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用你在前面步骤中复制的`curl`字符串，从终端获取访问令牌：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we have received the access token, we will apply the `RequestAuthentication`
    policy. The `RequestAuthentication` policy specifies the details of how to validate
    the JWT provided during authentication. Following is the **RequestAuthentication**
    policy:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到访问令牌，我们将应用 `RequestAuthentication` 策略。`RequestAuthentication` 策略指定了如何验证身份验证过程中提供的
    JWT。以下是 **RequestAuthentication** 策略：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding configuration, also available in `Chapter6/01-requestAuthentication.yaml`,
    we are declaring a `auth0` in the `chapter6` namespace with the following specifications:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置中，也可以在 `Chapter6/01-requestAuthentication.yaml` 中找到，我们在 `chapter6` 命名空间中声明了一个
    `auth0`，其规格如下：
- en: '`issuer`: This is the value of the domain of the Auth0 application. You can
    fetch the value from the following screen:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`issuer`: 这是 Auth0 应用程序域的值。你可以从以下屏幕中获取该值：'
- en: '![Figure 6.9 – Application domain](img/B17989_06_09.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 应用程序域](img/B17989_06_09.jpg)'
- en: Figure 6.9 – Application domain
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 应用程序域
- en: '`jwksUri`: This is the JWKS endpoint, which can be used by Istio to verify
    the signature. Auth0 exposes a JWKS endpoint for each tenant, which is found at
    `https://DOMAIN/.well-known/jwks.json`. This endpoint will contain the JWK used
    to verify all Auth0-issued JWTs for this tenant. Replace the `DOMAIN` value with
    the value in the application.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jwksUri`: 这是 JWKS 端点，Istio 可以用它来验证签名。Auth0 为每个租户暴露一个 JWKS 端点，地址为 `https://DOMAIN/.well-known/jwks.json`。该端点将包含用于验证该租户所有
    Auth0 发放的 JWT 的 JWK。请将 `DOMAIN` 的值替换为应用程序中的值。'
- en: 'When using the `RequestAuthentication` policy, it is best practice to also
    configure the `RequestAuthentication` and `AuthorizationPolicy` together and enforce
    a rule that any request with an empty principal should not be allowed. Following
    is an example of a sample authorization policy – you will read more about authorization
    policies in the next section:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `RequestAuthentication` 策略时，最佳实践是将 `RequestAuthentication` 和 `AuthorizationPolicy`
    一起配置，并强制执行一个规则，要求任何没有主体的请求都不允许。以下是一个示例授权策略——你将在下一节中阅读更多关于授权策略的内容：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Configuring RequestAuthorization
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 RequestAuthorization
- en: In the previous section, we configured a `RequestAuthentication` policy, which
    verifies a JWT token against the issuer and JWK details as per the JWKS location.
    We configured Auth0 as the authentication provider and the one that generates
    the bearer token. In this section, we will learn about how to make use of the
    information provided by authentication policies such as peer authentication and
    request authentication to authorize client access to the server (the requested
    resource, Pod, workload, service, etc.).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们配置了一个 `RequestAuthentication` 策略，用于根据 JWKS 位置验证 JWT 令牌的颁发者和 JWK 细节。我们将
    Auth0 配置为身份验证提供程序，并生成承载令牌。在本节中，我们将学习如何使用身份验证策略提供的信息，例如对等身份验证和请求身份验证，以授权客户端访问服务器（请求的资源、Pod、工作负载、服务等）。
- en: We will first focus on implementing an authorization policy in conjunction with
    the `RequestAuthentication` policy from the previous section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先专注于实现与上一节中的 `RequestAuthentication` 策略结合的授权策略。
- en: 'To let `curl` access the envoy dummy using the access token issued by Auth0,
    we need to create an `AuthorizationPolicy`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `curl` 使用 Auth0 发放的访问令牌访问 envoy 模拟器，我们需要创建一个 `AuthorizationPolicy`：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`AuthorizationPolicy` contains the following data:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationPolicy` 包含以下数据：'
- en: '`action`: This defines the type of action to be taken when the request matches
    the defined rule. Possible values for `action` are `ALLOW`, `DENY`, and `AUDIT`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`: 这定义了当请求匹配定义的规则时应采取的操作类型。`action` 的可能值有 `ALLOW`、`DENY` 和 `AUDIT`。'
- en: '`selector`: This defines what workload this policy should be applied to. Here,
    you provide a set of labels that should match the workload’s label to be part
    of a selection.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`: 这定义了该策略应应用于哪些工作负载。在这里，你需要提供一组标签，这些标签应与工作负载的标签匹配，才能成为选择的一部分。'
- en: '`rules`: Here, we are defining a set of rules that should be matched with the
    request. Rules contain the following sub-configurations:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rules`: 在这里，我们定义了一组规则，这些规则应与请求匹配。规则包含以下子配置：'
- en: '`source`: This provides the rule about the origin of the request.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`: 这是关于请求来源的规则。'
- en: '`to`: This provides rules about the request such as to what host it was addressed,
    what the method name is, and what resource identified by the URI is requested.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to`: 这是关于请求的规则，比如请求是发往哪个主机、方法名是什么以及 URI 标识的资源是什么。'
- en: '`when`: This specifies a list of additional conditions. You can find a detailed
    list of all parameters at [https://istio.io/latest/docs/reference/config/security/conditions/](https://istio.io/latest/docs/reference/config/security/conditions/).'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when`：此字段指定一组附加条件。你可以在[https://istio.io/latest/docs/reference/config/security/conditions/](https://istio.io/latest/docs/reference/config/security/conditions/)找到所有参数的详细列表。'
- en: In this example, we are defining an authorization policy that allows access
    to Pods with the label `name:envoydummy` if the request contains an authenticated
    JWT token with a claim of `read:profile`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们定义了一个授权策略，允许访问带有标签`name:envoydummy`的Pods，如果请求包含带有`read:profile`声明的已认证JWT令牌。
- en: 'Before we apply the changes, make sure that you can access the dummy data and
    make sure you have the Ingress gateway and `envoydummy` Pods deployed in the `utilities`
    namespace – if not, you can do that by applying the following commands:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用更改之前，请确保你可以访问虚拟数据，并确保你已经在`utilities`命名空间中部署了Ingress网关和`envoydummy` Pods——如果没有，你可以通过以下命令来实现：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Go ahead and apply both of the policies:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 继续应用这两个策略：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Check that you are able to access `mockshop.com`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你是否能够访问`mockshop.com`：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The access is denied because we need to provide a valid access token as part
    of the request. Copy the access token you got from the previous request and try
    again in the following fashion:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 访问被拒绝，因为我们需要提供有效的访问令牌作为请求的一部分。复制你从上一个请求中获得的访问令牌，并按以下方式重试：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Although the JWT verification succeeded, the request failed due to RBAC controls.
    The error is deliberate because instead of providing `read:dummyData` in `Chapter6/02-requestAuthorization.yaml`,
    we provide `read:profile`. The changes are updated in `Chapter6/03-requestAuthorization.yaml`.
    Apply the changes and test the APIs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JWT验证成功，但由于RBAC控制，请求失败。该错误是故意的，因为我们在`Chapter6/02-requestAuthorization.yaml`中没有提供`read:dummyData`，而是提供了`read:profile`。这些更改已更新在`Chapter6/03-requestAuthorization.yaml`中。应用更改并测试API：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To summarize, we did the following, including the previous section:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们做了以下操作，包括前面的部分：
- en: We configured Auth0 as the authentication provider and OAuth server.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Auth0配置为身份验证提供者和OAuth服务器。
- en: We created a `RequestAuthentication` policy to validate the bearer token provided
    in the request.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`RequestAuthentication`策略，用于验证请求中提供的承载令牌。
- en: We created an `AuthorizationPolicy` to verify claims presented in the JWT token
    and whether the claim matched the desired value, then let the request go through
    the upstream.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`AuthorizationPolicy`，验证JWT令牌中呈现的声明以及声明是否匹配所需的值，然后允许请求通过上游。
- en: Next, we will learn how to configure request authorization in conjunction with
    `PeerAuthentication`, which we configured in the *Service-to-service* *authentication*
    section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将请求授权配置与我们在*服务到服务* *身份验证*部分配置的`PeerAuthentication`结合使用。
- en: 'We will modify the `curl` Pod to use a different service account, and let’s
    call it `chapter6sa`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`curl` Pod，使用另一个服务账户，并将其命名为`chapter6sa`：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you cannot change the service account of an existing Pod, you need to delete
    the previous deployment and redeploy with a new service account:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你无法更改现有Pod的服务账户，因此需要删除之前的部署，并使用新的服务账户重新部署：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can check that the `curl` Pod is running with the identity of the `chapter6sa`
    service account. After this, let’s create an `AuthorizationPolicy` to allow a
    request to the `httpbin` Pod if the principal of the requestor is `cluster.local/ns/utilities/sa/curl`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查`curl` Pod是否使用`chapter6sa`服务账户身份运行。之后，让我们创建一个`AuthorizationPolicy`，允许对`httpbin`
    Pod的请求，如果请求方的主体是`cluster.local/ns/utilities/sa/curl`：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Previously, we looked at `AuthorizationPolicy` and you will be familiar with
    most of the configuration in this example. In this example, we are building `AuthorizationPolicy`
    on top of peer authentication rather than request authentication. The most interesting
    part is the `source` field in the `rules` section. In the `source` configuration,
    we define the source identities of the request. All fields in the source request
    need to match for the rule to be successful.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看过`AuthorizationPolicy`，你会对这个示例中的大部分配置很熟悉。在这个示例中，我们在对等身份验证的基础上构建了`AuthorizationPolicy`，而不是请求身份验证。最有趣的部分是`rules`部分中的`source`字段。在`source`配置中，我们定义了请求的源身份。源请求中的所有字段需要匹配，规则才会成功。
- en: 'The following fields can be defined in the `source` configuration:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字段可以在`source`配置中定义：
- en: '`principals`: This is a list of accepted identities that are derived from the
    client certificate during mTLS. The values are in the `<TRUST_DOMAIN NAME >/ns/<NAMESPACE
    NAME>/sa/<SERVICE_ACCOUNT NAME>` format. In this example, the value of principals
    will be `cluster.local/ns/utilities/sa/curl`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`principals`：这是一个接受的身份列表，这些身份是通过mTLS的客户端证书派生的。值的格式为`<TRUST_DOMAIN NAME>/ns/<NAMESPACE
    NAME>/sa/<SERVICE_ACCOUNT NAME>`。在本例中，`principals`的值将是`cluster.local/ns/utilities/sa/curl`。'
- en: '`notPrincipals`: This is a list of identities from which the request will not
    be accepted. The values are derived the same way as `principals`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notPrincipals`：这是一个列出将不接受请求的身份的列表。值的派生方式与`principals`相同。'
- en: '`requestPrincipals`: This is a list of accepted identities where the request
    principal is derived from JWT and is in the format `<ISS>/<SUB>`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestPrincipals`：这是一个接受的身份列表，请求主体来自JWT，并且格式为`<ISS>/<SUB>`。'
- en: '`notRequestPrincipals`: This is a list of identities from which the request
    will not be accepted. The principal is derived from the JWT and is in the format
    `<ISS>/<SUB>`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notRequestPrincipals`：这是一个列出将不接受请求的身份的列表。主体来自JWT，格式为`<ISS>/<SUB>`。'
- en: '`namespaces`: This is a list of namespaces from which the request will be accepted.
    The namespaces are derived from the peer certificate details.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespaces`：这是一个列出请求将被接受的命名空间的列表。命名空间是从对等证书详细信息中派生的。'
- en: '`notNamespaces`: This is a list of namespaces from which a request will not
    be allowed. The namespaces are derived from the peer certificate details.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notNamespaces`：这是一个列出不允许请求的命名空间的列表。命名空间是从对等证书详细信息中派生的。'
- en: '`ipBlocks`: This is a list of IPs or CIDR blocks from which a request will
    be accepted. The IP is populated from the source address of the IP packet.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipBlocks`：这是一个列出将接受请求的IP或CIDR块的列表。IP是从IP数据包的源地址中填充的。'
- en: '`notIpBlocks`: This is a list of IP blocks from which a request will be rejected.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notIpBlocks`：这是一个列出将拒绝请求的IP块的列表。'
- en: '`remoteIpBlocks`: This is a list of IP blocks, populated from the `X-Forwarded-For`
    header or proxy protocol.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remoteIpBlocks`：这是一个IP块的列表，从`X-Forwarded-For`头部或代理协议中填充。'
- en: '`notRemoteIpBlocks`: This is a negative list of `remoteIpBlocks`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notRemoteIpBlocks`：这是`remoteIpBlocks`的负面列表。'
- en: 'Go ahead and apply the configuration and test whether you are able to `curl`
    to `httpbin`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续并应用配置，测试是否能够使用`curl`访问`httpbin`：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Istio denies the request from the `curl` Pod to `httpbin` because the peer certificate
    presented by the `curl` Pod contains `cluster.local/ns/utilities/sa/chapter6sa`
    instead of `cluster.local/ns/utilities/sa/curl` as the principal. Although the
    `curl` Pod is part of the mesh and contains a valid certificate, it is not authorized
    to access the `httpbin` Pod.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Istio拒绝`curl` Pod到`httpbin`的请求，因为`curl` Pod提供的对等证书包含`cluster.local/ns/utilities/sa/chapter6sa`，而不是`cluster.local/ns/utilities/sa/curl`作为主体。虽然`curl`
    Pod是网格的一部分并且包含有效证书，但它没有被授权访问`httpbin` Pod。
- en: Go ahead and fix the problem by assigning the correct service account to the
    `curl` Pod.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续并通过将正确的服务帐户分配给`curl` Pod来解决问题。
- en: Tip
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can use the following commands to fix the problem:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来解决这个问题：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We will implement one more authorization policy, but this time the policy will
    enforce that using the `utilities` or `curl` service account, the requestor can
    access only `/headers` of `httpbin`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现另一个授权策略，但这次策略将强制要求使用`utilities`或`curl`服务帐户时，请求者只能访问`httpbin`的`/headers`。
- en: 'Following is the authorization policy:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是授权策略：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this policy, we have defined the `HTTP` method and `HTTP` paths in the `to`
    field on the rule. The `to` field contains a list of operations on which the rules
    will be applied. The operation field supports the following parameters:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此策略中，我们在规则的`to`字段中定义了`HTTP`方法和`HTTP`路径。`to`字段包含将应用规则的操作列表。操作字段支持以下参数：
- en: '`hosts`: This specifies a list of hostnames for which the request will be accepted.
    If it’s not set, then any host is allowed.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`：此项指定将接受请求的主机名列表。如果未设置，则允许任何主机。'
- en: '`notHosts`: This is a negative list of hosts.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notHosts`：这是一个负面主机列表。'
- en: '`ports`: This is a list of ports for which a request will be accepted.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：这是一个列出将接受请求的端口的列表。'
- en: '`notPorts`: This is a list of negative matches of ports.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notPorts`：这是一个列出端口的负面匹配列表。'
- en: '`methods`: This is a list of methods as specified in the HTTP request. If not
    set, any method is allowed.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methods`：这是一个列出HTTP请求方法的列表。如果未设置，则允许任何方法。'
- en: '`notMethods`: This is a list of negative matches of methods as specified in
    the HTTP request.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notMethods`: 这是一个包含方法负匹配的列表，方法是按HTTP请求指定的。'
- en: '`paths`: This is a list of paths as specified in the HTTP request. Paths are
    normalized as per [https://istio.io/latest/docs/reference/config/security/normalization/](https://istio.io/latest/docs/reference/config/security/normalization/).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`: 这是一个按HTTP请求指定的路径列表。路径会根据[https://istio.io/latest/docs/reference/config/security/normalization/](https://istio.io/latest/docs/reference/config/security/normalization/)进行规范化。'
- en: '`notPaths`: This is a list of negative matches of paths.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notPaths`: 这是一个包含路径负匹配的列表。'
- en: 'Apply the changes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And then try to access `httpbin`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试访问`httpbin`：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Access to the request is denied because the authorization policy only allows
    the `/get` request made using the HTTP GET method. The following is the correct
    request:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于授权策略仅允许使用HTTP GET方法发出的`/get`请求，因此访问请求被拒绝。以下是正确的请求：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This concludes our lesson on how you can build custom policies for performing
    request authentication and request authorization. To get more familiar with them,
    I suggest going through the examples in this chapter a few times and maybe building
    your own variations to learn how to use these policies effectively.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课讲解了如何为请求认证和请求授权构建自定义策略。为了更熟悉这些内容，我建议多读几遍本章的示例，或者尝试自己构建一些变体，以学习如何有效使用这些策略。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we read about how Istio provides authentication and authorization.
    We also read about how to implement service-to-service authentication using mutual
    TLS within a Service Mesh using the `PeerAuthentication` policy, as well as mutual
    TLS with clients external to a Service Mesh by using the *mutual* TLS mode at
    the Ingress gateway. We then read about end user authentication using the `RequestAuthentication`
    policy. We configured Auth0 to gain some real-life experience in using authentication
    and identity providers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Istio如何提供身份验证和授权。我们还了解了如何使用`PeerAuthentication`策略在服务网格中实现服务到服务的身份验证，以及通过Ingress网关使用*mutual*
    TLS模式与服务网格外部的客户端进行互认证TLS。然后我们学习了如何使用`RequestAuthentication`策略进行终端用户身份验证。我们配置了Auth0，获得了使用身份验证和身份提供商的真实经验。
- en: To finish off, we then read about `AuthorizationPolicy` and how it can be used
    to enforce various authorization checks to ensure that the authenticated identity
    is authorized to access the requested resources.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们阅读了关于`AuthorizationPolicy`以及如何使用它来强制执行各种授权检查，以确保经过身份验证的身份被授权访问请求的资源。
- en: In the next chapter, we will read about how Istio helps in making microservices
    observable and how various observability tools and software can be integrated
    with Istio.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Istio如何帮助使微服务具备可观察性，以及如何将各种可观察性工具和软件与Istio集成。
