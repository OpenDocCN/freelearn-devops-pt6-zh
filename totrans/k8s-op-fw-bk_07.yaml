- en: '*Chapter 5*: Developing an Operator – Advanced Functionality'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 5 章*：开发一个 Operator —— 高级功能'
- en: While a cluster with Operators that are capable of basic installation and upgrade
    functionality is a considerable improvement over non-Operator-based Kubernetes
    clusters, there is still more that can be done to improve cluster administration
    and user experience. Advanced features can help users to achieve more sophisticated
    automation, guide failure recovery, and inform data-driven deployment decisions
    with features such as metrics and status updates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具有基本安装和升级功能的 Operator 集群相比于非 Operator 基础的 Kubernetes 集群有了显著的改进，但仍有更多的工作可以提高集群管理和用户体验。高级功能可以帮助用户实现更复杂的自动化，指导故障恢复，并通过度量和状态更新等功能来支持数据驱动的部署决策。
- en: 'These are some of the fundamental features for higher-level Operators within
    the **Capability Model** (as described in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015),
    *Introduction to the Operator Framework*). As such, this chapter will first explain
    the cost and benefits of implementing advanced functionality (in relation to the
    effort necessary to do so) before demonstrating ways to add these features in
    the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 **能力模型** 中更高级的 Operator 的一些基本功能（如 [*第 1 章*](B18147_01_ePub.xhtml#_idTextAnchor015)
    *Operator 框架介绍* 所述）。因此，本章将首先解释实现高级功能的成本与收益（相对于所需的努力），然后在接下来的章节中演示如何添加这些功能：
- en: Understanding the need for advanced functionality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解高级功能的需求
- en: Reporting status conditions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告状态条件
- en: Implementing metrics reporting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现度量报告
- en: Implementing leader election
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现领导者选举
- en: Adding health checks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加健康检查
- en: Conveniently, the code required to implement these features does not require
    any significant refactoring of the existing Operator code. In fact, the hierarchical
    nature of the Capability Model and the development patterns provided by the Operator
    SDK encourage this iterative construction. It is, therefore, the goal of this
    chapter to build upon the basic Operator code from [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, to create a more complex Operator
    capable of providing the features we just listed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，实现这些功能所需的代码不需要对现有 Operator 代码进行重大重构。实际上，能力模型的层次结构和 Operator SDK 提供的开发模式鼓励这种迭代式构建。因此，本章的目标是基于
    [*第 4 章*](B18147_04_ePub.xhtml#_idTextAnchor066) *使用 Operator SDK 开发 Operator*
    中的基本 Operator 代码，构建一个能够提供我们刚才列出功能的更复杂的 Operator。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples shown throughout this chapter build upon the project code that
    was started in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing
    an Operator with the Operator SDK*. Therefore, it is recommended to start with
    that chapter (and the prerequisites for it), which covers project initialization
    and basic Operator functionality. This is not required, however, and the sections
    in this chapter can be generally applied to any Operator SDK project. That is,
    any project initialized by the Operator SDK will work with the following steps
    and you do not need to specifically implement all of the code from previous chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的示例是在 [*第 4 章*](B18147_04_ePub.xhtml#_idTextAnchor066) *使用 Operator SDK
    开发 Operator* 中开始的项目代码基础上构建的。因此，建议从该章节（及其前提条件）开始，该章节涵盖了项目初始化和基本的 Operator 功能。但这不是必需的，本章中的各个部分通常可以应用于任何
    Operator SDK 项目。也就是说，任何由 Operator SDK 初始化的项目都可以按照以下步骤进行操作，你不需要专门实现前面章节中的所有代码。
- en: 'With that in mind, the requirements for this chapter are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，本章的要求如下：
- en: Any existing Operator SDK project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何现有的 Operator SDK 项目
- en: Go 1.16+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 1.16+
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3zbsvD0](https://bit.ly/3zbsvD0)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的《代码实战》视频可以通过以下链接观看：[https://bit.ly/3zbsvD0](https://bit.ly/3zbsvD0)
- en: Understanding the need for advanced functionality
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解高级功能的需求
- en: With a basic, functional Operator already built and ready for deployment, you
    may be asking, What else do I really need? Indeed, now that your operand is installable
    and its health is managed by your Operator, there may be nothing more to do. This
    is a perfectly acceptable level of functionality for an Operator to have. In fact,
    it may be preferable to start with a simple Operator and iterate as your development
    resources allow (recall discussing this in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建并准备好部署一个基本且功能完整的操作符后，您可能会问：我还需要做什么？事实上，现在您的操作数（operand）可以安装，并且其健康状况由操作符管理，可能不需要做更多事情了。这对于一个操作符来说是完全可以接受的功能水平。实际上，最好从一个简单的操作符开始，随着开发资源的增加逐步迭代（回想一下在[*第3章*](B18147_03_ePub.xhtml#_idTextAnchor050)中讨论的内容，*设计操作符
    – CRD、API 和目标协调*）。
- en: The point is that there is no shame during the development of your Operator
    in stopping here. The Capability Model defines lower-level Operators for a reason
    (in other words, if it was unacceptable to have an Operator that can only install
    an operand, then why would Level I be defined at all?).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，在开发您的操作符时，停在这里并不丢人。能力模型（Capability Model）定义低级操作符是有原因的（换句话说，如果只能安装操作数的操作符不可接受，那么为什么要定义第一级操作符呢？）。
- en: However, the Capability Model does define higher-level Operators for a reason
    too. It is not difficult to imagine, for example, that during the course of a
    user's interaction with your Operator, they may wish to see more detailed insights
    into how it performs within a production environment. This is a good use case
    for adding custom metrics to an Operator. Or, there may be a common failure state
    that is difficult to debug (wherein status conditions would help expose more information
    about the failure in an efficient way).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，能力模型（Capability Model）确实也定义了更高层次的操作符（Operator），其背后有原因。例如，很容易想象，在用户与您的操作符交互的过程中，他们可能希望查看更多有关其在生产环境中表现的详细信息。这是为操作符添加自定义指标的一个好例子。或者，也可能存在一个常见的故障状态，难以调试（在这种情况下，状态条件可以帮助以更高效的方式揭示更多关于故障的信息）。
- en: The following sections are just a few of the most common additional features
    that help elevate an Operator to a higher level of functionality. Some of these
    are also covered in additional detail by the Operator SDK documentation on *Advanced
    Topics* ([https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/](https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/)).
    It is, of course, not feasible to list every possible feature that you could add
    to your Operator. But hopefully, these examples serve as a good starting point
    for your own development.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几个部分只是一些最常见的附加功能，它们有助于将操作符提升到更高的功能水平。部分内容也在操作符SDK文档中的*高级主题*（[https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/](https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/)）中有更详细的介绍。当然，列出您可以为操作符添加的每个可能的功能是不现实的。但希望这些例子能为您的开发提供一个良好的起点。
- en: Reporting status conditions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告状态条件
- en: Status conditions were discussed in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*, as a way to efficiently
    communicate human-readable information about the Operator's health to administrators.
    By presenting directly in an Operator's **CustomResourceDefinition** (**CRD**),
    the information they provide is more easily highlighted and viewable in a more
    centralized starting point for debugging issues. In this way, they provide an
    advantage over error logs, which can contain lots of unrelated information and
    often lack direct context, making them hard to trace to a root cause.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 状态条件在[*第3章*](B18147_03_ePub.xhtml#_idTextAnchor050)中讨论过，*设计操作符 – CRD、API 和目标协调*，作为一种高效地将操作符健康状况的可读信息传达给管理员的方式。通过直接在操作符的**自定义资源定义**（**CRD**）中呈现，它们提供的信息更容易突出显示，并在更集中的调试起始点中查看。这样，它们相较于错误日志具有优势，后者可能包含大量无关信息，且往往缺乏直接的上下文，难以追溯到根本原因。
- en: Implementing conditions in an Operator is made easier by the `Condition` type
    was implemented in *KEP-1623* ([https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1623-standardize-conditions](https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1623-standardize-conditions))
    around Kubernetes 1.19\. That type is now part of the Kubernetes API in the `k8s.io/apimachinery/pkg/api/meta`
    module. This allows developers to work with a consistent understanding of how
    conditions should be reported in Kubernetes with all of the compatibility assurances
    of Kubernetes API support.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Operator 中实现条件变得更容易，因为 `Condition` 类型是在 Kubernetes 1.19 版本左右通过 *KEP-1623*（[https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1623-standardize-conditions](https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1623-standardize-conditions)）实现的。该类型现在是
    Kubernetes API 的一部分，位于 `k8s.io/apimachinery/pkg/api/meta` 模块中。这使得开发者能够以一致的方式理解在
    Kubernetes 中如何报告条件，并且享有 Kubernetes API 支持的兼容性保证。
- en: The Operator Framework has also implemented conditions based on the Kubernetes
    type, both in the Operator SDK and the `OperatorCondition` resource that the OLM
    creates. This section will cover both approaches.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 框架也基于 Kubernetes 类型实现了条件，既在 Operator SDK 中，也在 OLM 创建的 `OperatorCondition`
    资源中。本节将涵盖这两种方法。
- en: Operator CRD conditions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Operator CRD 状态
- en: 'As part of the Kubernetes API conventions covered in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050)*,*
    *Designing an Operator – CRD, API, and Target Reconciliation*, objects (including
    custom resources) should include both a `spec` and `status` field. In the case
    of Operators, we are using `spec` as an input for configuring the Operator''s
    parameters already. However, we have not yet modified the `status` field. We will
    now change that by adding a list of conditions as a new field in `api/v1alpha1/nginxoperator_types.go`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在[*第 3 章*](B18147_03_ePub.xhtml#_idTextAnchor050)中涵盖的 Kubernetes API 约定，*设计
    Operator - CRD、API 和目标协调*，对象（包括自定义资源）应包含 `spec` 和 `status` 字段。在 Operator 的情况下，我们已经使用
    `spec` 作为配置 Operator 参数的输入。然而，我们尚未修改 `status` 字段。现在，我们将通过在 `api/v1alpha1/nginxoperator_types.go`
    中添加条件列表作为新字段来修改它：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we will run `make generate` (to update the generated client code) and
    `make manifests` (to update the Operator''s CRD with the new field), or simply
    `make` (which runs all generators, though we don''t need some of them right now).
    The new field is now reflected in the CRD:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将运行 `make generate`（以更新生成的客户端代码）和 `make manifests`（以使用新字段更新 Operator 的
    CRD），或者直接运行 `make`（该命令会运行所有生成器，尽管我们现在不需要其中的一些）。新字段现在已在 CRD 中反映：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that this also imports all of the embedded validation requirements for
    the `Condition` type from the Kubernetes API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这也会导入来自 Kubernetes API 的 `Condition` 类型的所有嵌入式验证要求。
- en: 'Now that the Operator''s CRD has a field to report the latest status conditions,
    the code can be updated to implement them. For this, we can use the `SetStatusCondition()`
    helper function, which is available in the `k8s.io/apimachinery/pkg/api/meta`
    module. For this example, we will start with a single condition called `OperatorDegraded`,
    which will default to `False` to indicate that the Operator is successfully reconciling
    changes in the cluster. If the Operator does encounter an error, however, we will
    update this condition to `True` with a message indicating the error. This will
    involve some refactoring of the `Reconcile()` function in `controllers/nginxoperator_controller.go`
    to match the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Operator 的 CRD 已经有了一个用于报告最新状态条件的字段，代码可以更新以实现这些条件。为此，我们可以使用 `SetStatusCondition()`
    辅助函数，该函数可在 `k8s.io/apimachinery/pkg/api/meta` 模块中使用。对于本示例，我们将从一个名为 `OperatorDegraded`
    的单个条件开始，默认值为 `False`，表示 Operator 正在成功地协调集群中的更改。然而，如果 Operator 确实遇到错误，我们将更新此条件为
    `True`，并附带一个指示错误的消息。这将涉及对 `controllers/nginxoperator_controller.go` 中的 `Reconcile()`
    函数进行一些重构，以便与以下内容匹配：
- en: '[PRE65]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The preceding code will now attempt to report a degraded status condition if
    the controller is initially unable to access the Operator''s CRD. The code continues
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码现在将在控制器最初无法访问 Operator 的 CRD 时尝试报告降级状态条件。代码继续如下：
- en: '[PRE83]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This section of code works similarly to the previous, but now reporting a degraded
    condition if the Deployment manifest for the nginx operand is unavailable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式类似于之前的代码，但现在如果 nginx 操作数的 Deployment 清单不可用，它将报告降级状态：
- en: '[PRE100]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If the attempt to update the operand Deployment fails, this block will report
    that the Operator is degraded as well. If the controller is able to succeed past
    this point, then there is no degradation to report. For this reason, the next
    block of code will finish the function by updating the Operator''s CRD to show
    that there is no degraded condition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新操作数部署的尝试失败，则此块将报告操作员处于降级状态。如果控制器能够成功通过此点，则无需报告降级。因此，下一块代码将通过更新操作员的CRD来结束函数，显示没有降级条件。
- en: '[PRE124]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In this code, we have added four calls to `SetStatusCondition()`, in which
    the condition with the type of `"OperatorDegraded"` is updated with the current
    time and a brief reason:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们添加了四个`SetStatusCondition()`调用，其中类型为`"OperatorDegraded"`的条件会更新为当前时间和简短的原因：
- en: If the Operator is unable to access its custom resource (for any reason besides
    a simple `IsNotFound` error), set the condition to `True` with the reason, `OperatorResourceNotAvailable`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作员无法访问其自定义资源（除非是简单的`IsNotFound`错误），则将条件设置为`True`，并注明原因`OperatorResourceNotAvailable`。
- en: If we are unable to get the nginx Deployment manifest from the embedded YAML
    file, update the condition to `True` with the reason, `OperandDeploymentNotAvailable`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果无法从嵌入的YAML文件中获取nginx部署清单，则将条件更新为`True`，并注明原因`OperandDeploymentNotAvailable`。
- en: If the Deployment manifest is successfully found but a call to create or update
    it fails, set the condition to `True` with the reason, `OperandDeploymentFailed`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功找到部署清单，但创建或更新操作失败，则将条件设置为`True`，并注明原因`OperandDeploymentFailed`。
- en: Finally, if the `Reconcile()` function has completed with no critical errors,
    set the `OperatorDegraded` condition to `False`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果`Reconcile()`函数执行完成且没有严重错误，则将`OperatorDegraded`条件设置为`False`。
- en: True or False as a Success Indicator
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 成功与失败的指标
- en: Note that, as discussed in the status conventions in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*, the `False` condition
    indicates a successful run. We could just as easily have inverted this logic,
    naming the condition something like `OperatorSucceeded`, where the default case
    is `True` and any failures change the condition to `False`. Doing so would still
    be consistent with Kubernetes conventions, so the decision is ultimately up to
    the developer based on the intent they wish to convey.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，正如在[*第3章*](B18147_03_ePub.xhtml#_idTextAnchor050)《设计操作员——CRD、API 和目标协调》中讨论的那样，`False`条件表示成功运行。我们也可以反转这个逻辑，将条件命名为`OperatorSucceeded`，在这种情况下，默认条件为`True`，任何失败都会将条件更改为`False`。这样做仍然符合Kubernetes的约定，因此，最终的决定由开发者根据他们希望传达的意图来做出。
- en: 'In this example, we have used string literals for each `Reason` update. In
    a practical application, it is common to define various `Reason` constants in
    the Operator''s API, which allows for consistent reusability. For example, we
    could define the following in `api/v1alpha1/nginxoperator_types.go` and use them
    through their constant names:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们为每个`Reason`更新使用了字符串字面量。在实际应用中，通常会在操作员的API中定义各种`Reason`常量，以便保持一致性和可重用性。例如，我们可以在`api/v1alpha1/nginxoperator_types.go`中定义以下内容，并通过常量名称来使用它们：
- en: '[PRE133]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The exact naming scheme for a condition reason is up to the preference of the
    developer, with the only Kubernetes condition being that it must be CamelCase.
    For that reason, different condition types and reasons can be named whatever is
    relevant and preferred for that specific Operator. The only standard condition
    name that currently exists is `Upgradeable`, which is consumed by the OLM. We
    will show how to use that condition in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 条件原因的命名方案由开发者决定，唯一的Kubernetes条件要求是必须使用驼峰命名法（CamelCase）。因此，不同的条件类型和原因可以根据具体操作员的需求进行命名。当前唯一存在的标准条件名称是`Upgradeable`，该条件由OLM使用。我们将在下一节中展示如何使用该条件。
- en: 'With these conditions implemented, we will be able to see the following output
    when interacting with a custom resource for our Operator:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些条件后，我们将在与我们的操作员自定义资源交互时看到以下输出：
- en: '[PRE139]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: In the next section, we will show how to report Operator conditions directly
    to the OLM.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何将操作员条件直接报告给OLM。
- en: Using the OLM OperatorCondition
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OLM OperatorCondition
- en: We have already discussed how the OLM is capable of managing the currently installed
    list of Operators, including upgrading and downgrading. In [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*, we will
    show the OLM in action for some of these features. But, for the moment, we can
    implement condition reporting in our Operator so that the OLM is aware of certain
    states that could prevent the Operator from upgrading. Combined with status conditions
    that are unique to the Operator (as reported in its CRD), this can help inform
    the OLM of critical information regarding the Operator's current state.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 OLM 如何管理当前已安装的 Operator 列表，包括升级和降级。在 [*第七章*](B18147_07_ePub.xhtml#_idTextAnchor108)，《使用
    Operator 生命周期管理器安装和运行 Operators》中，我们将展示 OLM 在一些功能中的实际应用。但是，目前我们可以在我们的 Operator
    中实现条件报告，以便 OLM 能够了解可能会阻止 Operator 升级的某些状态。结合 Operator 特有的状态条件（如在其 CRD 中报告的状态），这可以帮助
    OLM 获取有关 Operator 当前状态的关键信息。
- en: 'To read Operator conditions, the OLM creates a custom resource called `OperatorCondition`.
    The OLM will automatically create an instance of this object for every Operator
    that it manages from a CRD. A sample `OperatorCondition` object looks like the
    following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取 Operator 条件，OLM 会创建一个名为 `OperatorCondition` 的自定义资源。OLM 会自动为它管理的每个 Operator
    创建该对象的实例，来自一个 CRD。一个示例 `OperatorCondition` 对象如下所示：
- en: '[PRE157]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This object uses the same `Condition` type from the Kubernetes API as shown
    earlier (when implementing status conditions in the Operator CRD). This means
    it also includes all of the same fields, such as `type`, `status`, `reason`, and
    `message`, which can be updated the same way we did before. The difference is
    that now, setting `type` to `Upgradeable` will instruct the OLM to block any attempts
    to upgrade the Operator.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象使用的是与之前相同的 Kubernetes API 中的 `Condition` 类型（当实现 Operator CRD 中的状态条件时）。这意味着它也包括相同的字段，如
    `type`、`status`、`reason` 和 `message`，这些字段可以像之前一样更新。不同之处在于，现在将 `type` 设置为 `Upgradeable`
    会指示 OLM 阻止任何升级 Operator 的尝试。
- en: 'The other difference is that the Operator needs to report this status change
    to a different CRD (rather than its own). To do that, there is a library available
    at [https://github.com/operator-framework/operator-lib](https://github.com/operator-framework/operator-lib),
    which includes helper functions to update the `OperatorCondition` CRD. Details
    on using this library are available in the Operator Framework enhancements repository
    at [https://github.com/operator-framework/enhancements/blob/master/enhancements/operator-conditions-lib.md](https://github.com/operator-framework/enhancements/blob/master/enhancements/operator-conditions-lib.md).
    One way this can be done is in our nginx Operator by modifying the `Reconcile()`
    function in `controllers/nginxoperator_controller.go` like so:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不同之处在于，Operator 需要将此状态更改报告给不同的 CRD（而不是其自身）。为此，可以使用 [https://github.com/operator-framework/operator-lib](https://github.com/operator-framework/operator-lib)
    上提供的库，其中包括更新 `OperatorCondition` CRD 的辅助函数。有关使用此库的详细信息，请参考 Operator Framework
    增强功能库，地址为 [https://github.com/operator-framework/enhancements/blob/master/enhancements/operator-conditions-lib.md](https://github.com/operator-framework/enhancements/blob/master/enhancements/operator-conditions-lib.md)。一种实现方法是通过修改
    `controllers/nginxoperator_controller.go` 中的 `Reconcile()` 函数，如下所示：
- en: '[PRE169]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'This code imports two new modules: the Operator Framework V2 API and the `operator-lib/conditions`
    library. It then instantiates a new `Factory` object, which uses the same Kubernetes
    client that is already available to the Operator. That factory can then create
    new `Condition` objects with `NewCondition()`, which accepts `ConditionType` (which
    is really just a string) and creates a condition with that type.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导入了两个新模块：Operator Framework V2 API 和 `operator-lib/conditions` 库。它接着实例化了一个新的
    `Factory` 对象，该对象使用了已经可用的 Kubernetes 客户端。然后，工厂可以使用 `NewCondition()` 创建新的 `Condition`
    对象，该函数接受 `ConditionType`（实质上是一个字符串），并基于此类型创建一个条件。
- en: In this example, `Condition` is created with the `apiv2.Upgradeable` type, which
    is a constant defined by the Operator Framework for the `Upgradeable` condition
    that is understood by the OLM.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`Condition` 是使用 `apiv2.Upgradeable` 类型创建的，这是 Operator Framework 为 `Upgradeable`
    状态定义的常量，该状态被 OLM 理解。
- en: Next, the `condition.Set()` function updates the `OperatorCondition` CRD object
    that the OLM created for our Operator. Specifically, this adds (or updates) the
    list of conditions with the new condition we just created and the status that
    is passed to it (in this case, `True`). There are also two functions available
    that can be optionally passed to `Set()` (`WithReason()` and `WithMessage()`),
    which set the reason and message for the condition.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`condition.Set()` 函数更新 OLM 为我们的 Operator 创建的 `OperatorCondition` CRD 对象。具体来说，它将新创建的条件以及传递给它的状态（在此情况下为
    `True`）添加到（或更新）条件列表中。此外，还有两个可以选择传递给 `Set()` 的函数（`WithReason()` 和 `WithMessage()`），它们分别用于设置条件的原因和消息。
- en: 'Using these helpers greatly simplifies the work necessary to retrieve and update
    the `OperatorCondition` CRD object created for our Operator by the OLM. In addition,
    the OLM takes steps to make sure that Operators cannot delete the CRD or modify
    anything outside of the object''s status. However, there are some other fields
    in the `OperatorCondition` CRD `spec` that can be modified by administrators.
    Specifically, the `overrides` field allows users to manually bypass automatically
    reported condition updates that would otherwise block upgrading. A sample usage
    of this field looks as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些辅助函数可以大大简化从 OLM 为我们的 Operator 创建的 `OperatorCondition` CRD 对象中检索和更新的工作。此外，OLM
    还会采取措施确保 Operator 无法删除 CRD 或修改对象状态以外的任何内容。然而，`OperatorCondition` CRD `spec` 中仍有一些其他字段可以由管理员修改。具体来说，`overrides`
    字段允许用户手动绕过自动报告的条件更新，这些更新本应阻止升级。该字段的示例用法如下：
- en: '[PRE189]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Using `overrides` like this can be useful in the case of known issues or bugs
    that should not prevent the Operator from upgrading.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用 `overrides` 可以在遇到已知问题或错误时非常有用，这些问题或错误不应阻止 Operator 升级。
- en: Implementing metrics reporting
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现指标报告
- en: Metrics are a crucial aspect of any Kubernetes cluster. Metrics tools can provide
    detailed insights into almost any measurable data in the cluster. This is why
    metrics are a key part of graduating an Operator to Level IV in the Capability
    Model. In fact, most native Kubernetes controllers already report metrics about
    themselves, for example, `schedule_attempts_total`, which reports the number of
    attempts the scheduler has made to schedule Pods onto Nodes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 指标是任何 Kubernetes 集群中至关重要的一部分。指标工具可以提供集群中几乎所有可衡量数据的详细洞察。这也是为什么指标是将 Operator 提升到能力模型第四级的关键因素。事实上，大多数原生
    Kubernetes 控制器已经报告了关于自身的指标，例如 `schedule_attempts_total`，它报告调度器尝试将 Pods 调度到节点上的次数。
- en: The original design for the Kubernetes monitoring architecture ([https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/monitoring_architecture.md](https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/monitoring_architecture.md))
    defines metrics such as `schedule_attempts_total` as **service metrics**. The
    alternative to service metrics is **core metrics**, which are metrics that are
    generally available from all components. Core metrics currently include information
    about CPU and memory usage and are scraped by the Kubernetes **metrics-server**
    application ([https://github.com/kubernetes-sigs/metrics-server](https://github.com/kubernetes-sigs/metrics-server)).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 监控架构的原始设计（[https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/monitoring_architecture.md](https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/monitoring_architecture.md)）定义了像
    `schedule_attempts_total` 这样的指标作为 **服务指标**。服务指标的替代品是 **核心指标**，即通常可以从所有组件中获取的指标。核心指标目前包括关于
    CPU 和内存使用情况的信息，并由 Kubernetes **metrics-server** 应用程序抓取（[https://github.com/kubernetes-sigs/metrics-server](https://github.com/kubernetes-sigs/metrics-server)）。
- en: On the other hand, service metrics expose application-specific data that is
    defined in the code of individual components. All of this data can be scraped
    and aggregated by tools such as **Prometheus** ([https://prometheus.io](https://prometheus.io))
    or **OpenTelemetry** ([https://opentelemetry.io](https://opentelemetry.io)), and
    presented with frontend visualization applications such as **Grafana** ([https://grafana.com](https://grafana.com)).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，服务指标公开了在各个组件的代码中定义的特定应用程序数据。所有这些数据都可以通过 **Prometheus**（[https://prometheus.io](https://prometheus.io)）或
    **OpenTelemetry**（[https://opentelemetry.io](https://opentelemetry.io)）等工具抓取和聚合，并通过前端可视化应用程序（如
    **Grafana**（[https://grafana.com](https://grafana.com)））呈现。
- en: The entire concept of metrics in Kubernetes extends far beyond just implementation
    with regard to Operators. While that, unfortunately, means there is a lot of information
    that is outside the scope of this chapter, there is a great deal of community
    and documentation resources available that cover the fundamentals of this topic.
    Instead, this section will focus on the relevant Operator implementation steps
    for a new service metric with an assumed prior understanding of the basics related
    to metrics in general.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，度量的整个概念远远超出了仅与 Operator 的实现相关的部分。虽然这意味着有很多信息超出了本章节的范围，但有大量社区和文档资源可以覆盖此主题的基础知识。因此，本节将专注于针对新的服务度量的相关
    Operator 实现步骤，假设读者已经具备了关于度量的基本了解。
- en: Adding a custom service metric
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义服务度量
- en: The boilerplate code that is scaffolded by `operator-sdk` when the project is
    initialized already includes the code and dependencies necessary to expose a metrics
    endpoint in the Operator Pod. By default, this is the `/metrics` path on port
    `8080`. This eliminates the need for meticulous HTTP handler code and allows us
    to focus instead on simply implementing the metrics themselves, as described in
    the Prometheus documentation (https://prometheus.io/docs/guides/go-application/#adding-your-own-metrics).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目初始化时，`operator-sdk`生成的样板代码已经包括了暴露 Operator Pod 中度量端点所需的代码和依赖项。默认情况下，这是位于端口`8080`上的`/metrics`路径。这消除了需要精心编写
    HTTP 处理程序代码的麻烦，并允许我们将精力集中在实现度量本身上，如 Prometheus 文档中所述（[https://prometheus.io/docs/guides/go-application/#adding-your-own-metrics](https://prometheus.io/docs/guides/go-application/#adding-your-own-metrics)）。
- en: Kubebuilder Metrics
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Kubebuilder 度量
- en: The built-in metrics handler code is another aspect of the Operator SDK that
    is actually provided by Kubebuilder under the hood. This implementation relies
    on the metrics library imported from `sigs.k8s.io/controller-runtime`. That library
    includes features such as a global registry of metrics that is already available
    to the core Operator code. This library is easy to hook into in order to register
    new metrics and update them from anywhere in the Operator's code base. More information
    on metrics and their use is available in the kubebuilder book at [https://book.kubebuilder.io/reference/metrics.html](https://book.kubebuilder.io/reference/metrics.html).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的度量处理程序代码是 Operator SDK 的另一个方面，实际上是由 Kubebuilder 提供的。此实现依赖于从`sigs.k8s.io/controller-runtime`导入的度量库。该库包括如全局度量注册表等功能，已经对核心
    Operator 代码可用。该库易于接入，以便从 Operator 的代码库中的任何位置注册新度量并更新它们。关于度量及其使用的更多信息，可以在 Kubebuilder
    文档中找到，地址是[https://book.kubebuilder.io/reference/metrics.html](https://book.kubebuilder.io/reference/metrics.html)。
- en: 'The `controller-runtime` library that this functionality is built with includes
    several metrics about the Operator''s controller code already, each indicated
    by the prefix `controller_runtime_`. These include the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此功能的`controller-runtime`库已经包含有关 Operator 控制器代码的若干指标，每个指标以`controller_runtime_`为前缀。这些指标包括：
- en: '`controller_runtime_reconcile_errors_total` – A counter metric that shows the
    cumulative number of times the `Reconcile()` function returned a non-nil error'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller_runtime_reconcile_errors_total` – 一个计数器指标，显示`Reconcile()`函数返回非nil错误的累计次数'
- en: '`controller_runtime_reconcile_time_seconds_bucket` – A histogram showing the
    latency for individual reconciliation attempts'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller_runtime_reconcile_time_seconds_bucket` – 一个显示单个同步尝试延迟的直方图'
- en: '`controller_runtime_reconcile_total` – A counter that increases with every
    attempt to call `Reconcile()`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller_runtime_reconcile_total` – 一个计数器，每次尝试调用`Reconcile()`时都会增加'
- en: For this example, we will be recreating the last metric, `controller_runtime_reconcile_total`,
    as a way to report the number of attempts our Operator has made to reconcile its
    state in the cluster.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将重新创建最后一个指标`controller_runtime_reconcile_total`，作为报告我们的 Operator 在集群中尝试同步其状态的次数的一种方式。
- en: RED metrics
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RED 指标
- en: 'When it comes to what type of metrics to define in any application, the possibilities
    are practically infinite. This can cause overwhelming decision fatigue for developers,
    as it may seem there is no good place to start. So, what are the most important
    metrics for an Operator to expose? The Operator SDK documentation recommends following
    the **RED method**, which outlines three key types of metrics that every service
    should expose in a Kubernetes cluster:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义任何应用程序中的指标类型时，可能性几乎是无限的。这可能会让开发人员感到决策疲劳，因为看似没有好的起点。那么，Operator 应该暴露哪些最重要的指标呢？Operator
    SDK 文档建议遵循 **RED 方法**，该方法概述了每个服务在 Kubernetes 集群中应该暴露的三种关键类型的指标：
- en: '`hotloop` conditions or suboptimal request pipelines.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hotloop` 条件或次优请求管道。'
- en: '`controller_runtime_reconcile_errors_total`). When correlated with the Rate
    metric, this can help debug common failures that are degrading an Operator''s
    performance.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller_runtime_reconcile_errors_total`）。当与 Rate 指标相关联时，这可以帮助调试常见的故障，这些故障正在降低
    Operator 的性能。'
- en: '`controller_runtime_reconcile_time_seconds`). This information can indicate
    poor performance or other conditions that degrade the cluster''s health.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller_runtime_reconcile_time_seconds`）。此信息可以指示性能差或其他降低集群健康状况的情况。'
- en: These basic metrics can provide the foundation for defining **service-level
    objectives** (**SLOs**) to ensure your Operator functions within the expected
    standards of your application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基础指标可以为定义 **服务级目标** (**SLOs**) 提供基础，以确保你的 Operator 在应用程序的预期标准范围内运行。
- en: 'To begin adding a custom metric to our Operator, it is a good practice to organize
    metrics definitions into their own package by creating a new file under `controllers/metrics/metrics.go`.
    This new module will hold the declaration of our new metric and automatically
    register it with the global registry available from `sigs.k8s.io/controller-runtime/pkg/metrics`.
    In the following code, we define this file and instantiate a new custom metric:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始将自定义指标添加到我们的 Operator，最好将指标定义组织到它们自己的包中，方法是创建一个新的文件 `controllers/metrics/metrics.go`。这个新模块将保存我们新指标的声明，并将其自动注册到来自
    `sigs.k8s.io/controller-runtime/pkg/metrics` 的全局注册表中。在以下代码中，我们定义了这个文件并实例化了一个新的自定义指标：
- en: 'controllers/metrics/metrics.go:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: controllers/metrics/metrics.go：
- en: '[PRE207]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: This file depends on the Prometheus client library to define a new counter (a
    simple, increasing metric) that we store in the `ReconcilesTotal` public variable.
    The actual name of the metric is `reconciles_total`, which is the name that will
    be exposed to Prometheus.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件依赖于 Prometheus 客户端库来定义一个新的计数器（一个简单的递增指标），我们将其存储在 `ReconcilesTotal` 公共变量中。该指标的实际名称是
    `reconciles_total`，这是暴露给 Prometheus 的名称。
- en: Metrics Naming Best Practices
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 指标命名最佳实践
- en: In a real environment, it is best to include a prefix to a metric's name that
    is specific to the application exporting that metric. This is one of the best
    practices recommended by `_total` to this cumulative metric. It is helpful to
    be familiar with these practices, not just for developing your own metrics, but
    also to know what to expect when interacting with other metrics.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际环境中，最好在指标名称前添加特定于导出该指标的应用程序的前缀。这是推荐的最佳实践之一，建议将 `_total` 用于这个累计指标。熟悉这些实践非常有帮助，不仅有助于你开发自己的指标，还能帮助你了解在与其他指标交互时需要期待什么。
- en: 'With this file''s `init()` function automatically registering the new metric
    with the global registry, we can now update this metric from anywhere in the Operator''s
    code. Since this is a measure of the total number of reconciliation attempts by
    the controller, it makes sense to update it at the start of the `Reconcile()`
    function declaration in `controllers/nginxoperator_controller.go`. This can be
    done with two new lines of code, shown in the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个文件的 `init()` 函数自动将新指标注册到全局注册表中，我们现在可以在 Operator 的代码中的任何地方更新这个指标。由于这是衡量控制器进行的所有协调尝试的总数，所以在
    `controllers/nginxoperator_controller.go` 中的 `Reconcile()` 函数声明开始时更新它是合理的。这可以通过以下两行新代码来实现：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: controllers/nginxoperator_controller.go：
- en: '[PRE223]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: All that is necessary is to import the new `metrics` package just created and
    call `metrics.ReconcilesTotal.Inc()`. This function doesn't return anything, so
    there is no need to add any error handling or status updates. We also want to
    make this the first line of the function since the goal is to increment for every
    call to `Reconcile()` (regardless of whether the call succeeds or not).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 所需要做的就是导入刚刚创建的新`metrics`包，并调用`metrics.ReconcilesTotal.Inc()`。该函数不返回任何内容，因此无需添加任何错误处理或状态更新。我们还希望将其放在函数的第一行，因为目标是对每次调用`Reconcile()`（无论调用是否成功）进行递增。
- en: 'The updated metric value is automatically reported by the metrics endpoint
    initialized by kubebuilder, so it is available to view through a properly configured
    Prometheus instance, as shown here:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的指标值会通过由 kubebuilder 初始化的指标端点自动报告，因此可以通过正确配置的 Prometheus 实例查看，如下所示：
- en: '![Figure 5.1 – Screenshot of reconciles_total metric graph in the Prometheus
    UI'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – Prometheus UI 中 reconciles_total 指标图表的截图'
- en: '](img/B18147_05_001.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18147_05_001.jpg)'
- en: Figure 5.1 – Screenshot of reconciles_total metric graph in the Prometheus UI
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Prometheus UI 中 reconciles_total 指标图表的截图
- en: 'When compared to the built-in `controller_runtime_reconcile_total` metric,
    we see that the values are the same:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置的`controller_runtime_reconcile_total`指标相比，我们看到值是相同的：
- en: '![Figure 5.2 – Screenshot comparing custom reconciles_total metric to built-in
    controller_runtime_reconcile_total](img/B18147_05_002.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 比较自定义 reconciles_total 指标与内置 controller_runtime_reconcile_total 指标的截图](img/B18147_05_002.jpg)'
- en: Figure 5.2 – Screenshot comparing custom reconciles_total metric to built-in
    controller_runtime_reconcile_total
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 比较自定义 reconciles_total 指标与内置 controller_runtime_reconcile_total 指标的截图
- en: We will cover more about how to install and configure Prometheus to capture
    this custom metric in [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building
    and Deploying Your Operator*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 6 章*](B18147_06_ePub.xhtml#_idTextAnchor090)中详细介绍如何安装和配置 Prometheus
    来捕获这个自定义指标，*构建和部署您的 Operator*。
- en: Implementing leader election
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现领导者选举
- en: Leader election is an important concept in any distributed computing system,
    not just Kubernetes (and not just for Operators, either). High-availability applications
    will often deploy multiple replicas of their workload Pods to support the uptime
    guarantees their users expect. In situations where only one workload Pod can do
    work in a cluster at a time, that replica is known as the **leader**. The remaining
    replicas will wait, running but not doing anything significant, until the current
    leader becomes unavailable or gives up its status as the leader. Those Pods will
    then determine among themselves who should be the new leader.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 领导者选举是任何分布式计算系统中的一个重要概念，不仅仅是 Kubernetes（也不仅仅是针对 Operators）。高可用性应用程序通常会部署多个副本的工作负载
    Pods，以支持用户期望的正常运行时间保证。在只能有一个工作负载 Pod 在集群中执行工作的情况下，该副本被称为**领导者**。其余的副本将等待，虽然在运行但没有做任何重要的工作，直到当前的领导者不可用或放弃其领导者身份。然后这些
    Pods 会自行决定谁应该成为新的领导者。
- en: Enabling proper leader election can greatly benefit the application's uptime.
    This can include graceful failover handling if one replica fails, or help to maintain
    application accessibility during rolling upgrades.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 启用正确的领导者选举可以大大提升应用程序的正常运行时间。这可以包括在一个副本失败时进行优雅的故障切换处理，或者帮助在滚动升级期间保持应用程序的可访问性。
- en: 'The Operator SDK makes leader election for Operators simple to implement. The
    boilerplate code scaffolded by `operator-sdk` creates a flag in our Operator,
    `--leader-elect`, which defaults to `false` and disables leader election. That
    flag is passed to the `LeaderElection` option value in the controller initialization
    function `ctrl.NewManager()`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Operator SDK 使得为 Operators 实现领导者选举变得简单。通过`operator-sdk`生成的样板代码会在我们的 Operator
    中创建一个标志`--leader-elect`，默认值为`false`，表示禁用领导者选举。该标志会传递给控制器初始化函数`ctrl.NewManager()`中的`LeaderElection`选项值：
- en: 'main.go:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: main.go：
- en: '[PRE232]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: The `LeaderElectionID` field represents the name of the resource that the Operator
    will use in order to hold the leader lock.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`LeaderElectionID`字段表示 Operator 用于持有领导者锁的资源名称。'
- en: 'This setup (using the `LeaderElection` option in `ctrl.NewManager()`) sets
    up the Operator to use the first of two possible leader election strategies, known
    as **leader-with-lease**. The other possible strategy for leader election is **leader-for-life**.
    There are some benefits and trade-offs to each strategy, as described in the Operator
    SDK documentation ([https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/#leader-election](https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/#leader-election)):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 该设置（使用`ctrl.NewManager()`中的`LeaderElection`选项）将操作员设置为使用两种可能的领导选举策略中的第一个，即**带租约的领导**。另一种可能的领导选举策略是**终身领导**。每种策略都有一些优点和权衡，如Operator
    SDK文档中所描述的([https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/#leader-election](https://sdk.operatorframework.io/docs/building-operators/golang/advanced-topics/#leader-election))。
- en: '**Leader-with-lease** – The default leader election strategy wherein the current
    leader periodically attempts to renew its status as the leader (known as its *lease*).
    If it is unable to do so, the leader relinquishes its position to a new leader.
    This strategy improves availability by enabling fast transitions between leaders
    when necessary. However, this strategy makes it possible to end up with a so-called
    **split-brain** scenario, in which multiple replicas believe they are the leader.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带租约的领导** – 默认的领导选举策略，其中当前领导者定期尝试续期其领导者身份（称为其*租约*）。如果无法续期，领导者会将其职位交给新的领导者。此策略通过在必要时快速切换领导者来提高可用性。然而，该策略可能导致所谓的**脑裂**场景，其中多个副本认为自己是领导者。'
- en: '`RenewDeadline` and `LeaseDuration` fields when calling `ctrl.NewManager()`
    to add approximate toleration for the ratio of clock skew rate between the fastest
    and slowest nodes. This is because `LeaseDuration` is the amount of time that
    current non-leaders will wait before attempting to acquire leadership, and `RenewDeadline`
    is the time that the control plane will wait to attempt refreshing the current
    leadership. Therefore, as an example, setting `LeaseDuration` to some multiple
    of `RenewDeadline` will add a tolerance for that same ratio of clock skew rate
    within the cluster.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`ctrl.NewManager()`时，`RenewDeadline`和`LeaseDuration`字段用于为集群中最快和最慢节点之间的时钟偏差比率添加大致的容忍度。这是因为`LeaseDuration`是当前非领导者在尝试获取领导权之前将等待的时间，而`RenewDeadline`是控制平面等待刷新当前领导权的时间。因此，举个例子，将`LeaseDuration`设置为`RenewDeadline`的某个倍数，将在集群内为该时钟偏差比率添加容忍度。
- en: For example, assume the current leader runs on Node A, which keeps time accurately.
    If the fail over backup replica is waiting on Node B, which is slow and keeps
    time at half the speed of Node A, then there is a clock skew rate between Nodes
    A and B with a ratio of 2:1\.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设当前领导者运行在节点A上，该节点的时间保持准确。如果备份副本运行在节点B上，该节点的速度较慢并且时间比节点A慢一半，那么节点A和节点B之间存在2:1的时钟偏差比率。
- en: In this scenario, if the leader has `LeaseDuration` of 1 hour and fails for
    some reason, then it may take 2 hours for Node B to notice that the lease has
    expired and attempt to acquire a new lease.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，如果领导者的`LeaseDuration`为1小时并因某种原因失败，则可能需要2小时才能让节点B注意到租约已过期并尝试获取新租约。
- en: However, with `RenewDeadline` of 30 minutes, the original leader will fail to
    renew its lease within that time frame. This allows the replica on the slower
    node to act at what it believes is only 30 minutes, but the actual time has surpassed
    `LeaseDuration` of 1 hour. This is an obscure detail in the leader election library,
    but one worth noting for Operators in clusters that may be affected by this skew.
    There is more discussion on this topic in the original GitHub pull request to
    add leader election to the Kubernetes clients at [https://github.com/kubernetes/kubernetes/pull/16830](https://github.com/kubernetes/kubernetes/pull/16830).
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果`RenewDeadline`为30分钟，原始领导者将在该时间范围内无法续约其租约。这允许运行在较慢节点上的副本仅按其认为的30分钟进行操作，但实际时间已超过`LeaseDuration`的1小时。这是领导选举库中的一个隐蔽细节，但对于可能受此时钟偏差影响的集群操作员而言，值得注意。有关此主题的更多讨论，可以参考原始GitHub拉取请求，内容为将领导选举添加到Kubernetes客户端，链接为[https://github.com/kubernetes/kubernetes/pull/16830](https://github.com/kubernetes/kubernetes/pull/16830)。
- en: 'To make our Operator configurable so that users can decide between leader-with-lease
    and leader-for-life election strategies, we can leverage the existing `--leader-elect`
    flag to enable or disable a call to the `leader.Become()` function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的操作员可配置，以便用户可以在带租约的领导选举策略和终身领导选举策略之间进行选择，我们可以利用现有的`--leader-elect`标志来启用或禁用对`leader.Become()`函数的调用：
- en: '[PRE249]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Now, our Operator will always use some method of leader election. The `leader.Become()`
    function is a blocking call that will prevent the Operator from running if it
    cannot acquire the leader lock. It will attempt to do so every second. If it succeeds,
    it will create the lock as a ConfigMap (in our case, that ConfigMap will be named
    nginx-lock).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的Operator将始终使用某种方式的领导者选举。`leader.Become()`函数是一个阻塞调用，如果无法获取领导者锁，它将阻止Operator的运行。它将每秒尝试一次。如果成功，它将创建一个ConfigMap作为锁（在我们的例子中，这个ConfigMap将命名为nginx-lock）。
- en: Adding health checks
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加健康检查
- en: Health checks (also known as liveness and readiness probes) are a way for any
    Pod to make its current functional state discoverable by other components in the
    cluster. This is usually done by way of exposing an endpoint in the container
    (traditionally `/healthz` for liveness checks and `/readyz` for readiness). That
    endpoint can be reached by other components (such as the kubelet) to determine
    whether the Pod is healthy and ready to serve requests. The topic is covered in
    detail in the Kubernetes documentation at [https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查（也称为存活性和就绪性探针）是任何Pod使其当前功能状态可以被集群中其他组件发现的一种方式。通常是通过在容器中暴露一个端点来完成的（传统上`/healthz`用于存活性检查，`/readyz`用于就绪性检查）。其他组件（如kubelet）可以访问该端点，以确定Pod是否健康并准备好服务请求。该主题在Kubernetes文档中有详细的说明，详见[https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)。
- en: 'The code initialized by the Operator SDK in `main.go` contains the `healthz`
    and `readyz` check setup by default:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`中由Operator SDK初始化的代码默认包含了`healthz`和`readyz`检查的设置：'
- en: main.go
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: main.go
- en: '[PRE276]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: This code sets up the two endpoints to begin serving immediately before the
    main controller is started. This makes sense because, at this point, all other
    startup code has already run. It wouldn't make sense to start advertising your
    Operator as healthy and ready to serve requests before it has even attempted to
    create a client connection.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了两个端点，在主控制器启动之前立即开始提供服务。这是有意义的，因为此时，所有其他启动代码已经运行完毕。在尝试创建客户端连接之前，开始宣传你的Operator为健康和准备好服务请求是没有意义的。
- en: 'The two functions, `mgr.AddHealthzCheck` and `mgr.AddReadyzCheck`, each take
    two parameters: a string (for the name of the check) and a function that returns
    the status of the check. That function must have the following signature:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数，`mgr.AddHealthzCheck`和`mgr.AddReadyzCheck`，每个都接受两个参数：一个字符串（用于检查的名称）和一个返回检查状态的函数。该函数必须具有以下签名：
- en: '[PRE305]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: This signature shows that the function accepts an HTTP request (because the
    check is serving an endpoint that will be queried by components such as the kubelet)
    and returns an error (if the check fails). The `healthz.Ping` function that the
    Operator is already populated with in this code is a simple `nil` error (indicating
    success). This is not very insightful, but its location in the code does provide
    the minimum of reporting that the Operator has successfully passed most of the
    initialization process.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 该签名显示该函数接受一个HTTP请求（因为该检查正在提供一个端点，该端点将被kubelet等组件查询），并返回一个错误（如果检查失败）。在这段代码中，Operator已经填充的`healthz.Ping`函数是一个简单的`nil`错误（表示成功）。这虽然没有太多洞察力，但它在代码中的位置提供了至少报告Operator已成功通过大部分初始化过程的最小信息。
- en: However, following the preceding function signature, it is possible to implement
    custom health checks. These additional checks can be added by simply calling `mgr.AddHealthzCheck`
    or `mgr.AddReadyzCheck` again (depending on the type of check) and passing the
    new function to each call. The checks are run sequentially (in no guaranteed order)
    when the `/healthz` or `/readyz` endpoints are queried, and if any checks fail,
    then an `HTTP 500` status is returned. With this, it is possible to develop your
    own liveness and readiness checks with more sophisticated logic that is unique
    to your Operator (for example, relying on dependent components to be accessible
    before reporting readiness).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在前面的函数签名之后，可以实现自定义健康检查。只需再次调用`mgr.AddHealthzCheck`或`mgr.AddReadyzCheck`（取决于检查类型），并将新函数传递给每个调用，即可添加这些附加检查。当查询`/healthz`或`/readyz`端点时，这些检查会按顺序运行（没有保证的顺序），如果有任何检查失败，则返回`HTTP
    500`状态。通过这种方式，可以开发具有更复杂逻辑的存活性和就绪性检查，这些逻辑是针对你的Operator独特的（例如，在报告就绪性之前，依赖组件需要可访问）。
- en: Summary
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter highlighted some additional options for functionality beyond the
    bare minimum that was established in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK.* This list is obviously not exhaustive
    of every possibility for advanced features, but it is intended to showcase some
    of the most common additional features added to Operators. At this point, some
    of the patterns for feature development should start to become clear (for example,
    startup and initialization code usually goes in `main.go`, while features related
    to core logic can fit nicely with the controller code in `nginxoperator_controller.go`,
    or its own package).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 本章突出了一些功能选项，超出了在[*第四章*](B18147_04_ePub.xhtml#_idTextAnchor066)，*使用 Operator
    SDK 开发操作符* 中建立的最低限度。这个列表显然不会详尽列举每种高级功能的可能性，但旨在展示一些添加到操作符中最常见的附加功能。此时，一些特性开发模式应该开始变得清晰起来（例如，启动和初始化代码通常放在
    `main.go` 中，而与核心逻辑相关的功能可以很好地与 `nginxoperator_controller.go` 中的控制器代码或其自己的包中适配）。
- en: The work done in this chapter shows some of the steps necessary in order to
    graduate an Operator from lower-level functionality to higher levels in the Capability
    Model. For example, metrics are a key aspect of a Level IV (*Deep Insights*) Operator
    and, therefore, something that is expected of the highest-function Operators available
    to users. In addition, leader election can help establish fail over processes
    (helpful in reaching Level III – *Full lifecycle*). Adding functionality like
    this helps build a useful and feature-rich Operator that improves application
    performance and, by extension, user experience.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的工作展示了从低级功能逐步提升到能力模型中更高级别的操作符所需的一些步骤。例如，度量指标是四级（*深入洞察*）操作符的关键方面，因此，这是期望用户使用的最高功能操作符之一。此外，领导选举可以帮助建立故障转移过程（在达到三级
    – *全生命周期* 时非常有帮助）。添加这样的功能有助于构建一个有用且功能丰富的操作符，提高应用程序性能，进而提升用户体验。
- en: In the next chapter, we will begin compiling the code that has been built throughout
    [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing an Operator
    with the Operator SDK*, and [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*. We will then demonstrate how
    to deploy this code and run our nginx Operator in a local Kubernetes cluster (without
    the use of the OLM). This will be a useful development process, as bypassing the
    need for the OLM in a testing environment can simplify and expedite our ability
    to iterate and test new changes.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始编译在[*第四章*](B18147_04_ePub.xhtml#_idTextAnchor066)，*使用 Operator SDK
    开发操作符*，以及[*第五章*](B18147_05_ePub.xhtml#_idTextAnchor078)，*开发操作符 – 高级功能* 中构建的代码。然后，我们将演示如何在本地
    Kubernetes 集群中部署此代码并运行我们的 nginx 操作符（不使用 OLM）。这将是一个有用的开发过程，因为在测试环境中绕过 OLM 可以简化和加快我们迭代和测试新变更的能力。
