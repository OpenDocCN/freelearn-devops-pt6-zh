<html><head></head><body>
		<div id="_idContainer013">
			<h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor013"/>1</h1>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>An Introduction to GitOps</h1>
			<p>In this opening chapter, we’ll delve into GitOps, an innovative approach that’s revolutionizing software development and operations. This chapter begins with the tale of GitOps, focusing on its transformative effect on organizational culture and workflows. The <em class="italic">Fundamentals of GitOps</em> section outlines its core principles, such as the centralization of Git, its declarative approach, and automated synchronization.  <em class="italic">Traditional CI/CD with DevOps against GitOps</em> traces the evolution of software deployment, contextualizing GitOps in the broader history of the field. This chapter will also contrast traditional CI/CD and DevOps methodologies with GitOps, highlighting GitOps as an evolution in managing complex systems. We’ll conclude by discussing the advantages of adopting GitOps for platform engineering while illustrating its efficiency, consistency, <span class="No-Break">and adaptability.</span></p>
			<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>GitOps unveiled – reshaping development culture <span class="No-Break">and practices</span></li>
				<li>The fundamentals of GitOps and the advantages of adopting it for <span class="No-Break">platform engineering</span></li>
				<li><span class="No-Break">Why GitOps?</span></li>
				<li>The integration between GitOps, IaC, <span class="No-Break">and Kubernetes</span></li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>To follow along with this chapter, you need to have basic knowledge of <strong class="bold">version control</strong>, <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>), <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>), <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>), and Kubernetes. Basic knowledge of major cloud providers, such as <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), <strong class="bold">AWS</strong>, and Azure, will <span class="No-Break">be beneficial.</span></p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>GitOps unveiled – reshaping development culture and practices</h1>
			<p>In the realm of modern software development and operations, GitOps emerges as a confluence of ideas and practices, redefining the approach to managing <span class="No-Break">complex systems.</span></p>
			<p>The term GitOps <a id="_idIndexMarker000"/>was first introduced by <em class="italic">Alexis Richardson</em>, the co-founder of <strong class="bold">Weaveworks</strong>, in<a id="_idIndexMarker001"/> August 2017 through a series of blog posts. Richardson described GitOps as a methodology where developer tools are pivotal in driving operational procedures. This approach emphasized the significance of using declarative tools and advocated for the best practices wherein configurations are treated as code. Consequently, these configurations should be subject to version control, aligning with the core principles <span class="No-Break">of GitOps.</span></p>
			<p>This innovative concept marked a shift in how software development and IT operations teams approach how infrastructure and applications are managed and deployed, promoting a more efficient, transparent, and <span class="No-Break">reliable process.</span></p>
			<p>GitOps is a paradigm that represents a breakthrough in how software development and operations teams manage and deploy applications and infrastructure. It revolves around the idea of using <strong class="bold">Git</strong>, a<a id="_idIndexMarker002"/> widely used version control system, as the single source of truth for declarative infrastructure <span class="No-Break">and applications.</span></p>
			<p><strong class="bold">Version control</strong>, also<a id="_idIndexMarker003"/> known as source control, is a system that records changes to a file or set of files over time so that you can recall specific versions later. It allows multiple people to work on a document simultaneously, and version control systems provide a way to manage these changes among <span class="No-Break">multiple people.</span></p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Traditional CI/CD with DevOps against GitOps</h2>
			<p>In <a id="_idIndexMarker004"/>traditional IT operations, as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>, the development team periodically hands over new software <a id="_idIndexMarker005"/>versions to a <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>) team. This team tests the software and passes it to the operations team <span class="No-Break">for deployment.</span></p>
			<p>As software <a id="_idIndexMarker006"/>release cycles become shorter, traditional operations models struggle to keep up. The operations team oversees configuring the infrastructure for new software versions while focusing on system reliability, resilience, <span class="No-Break">and security:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer008">
					<img alt="Figure 1.1 – Example of a traditional IT operations workflow" src="image/B22100_01_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Example of a traditional IT operations workflow</p>
			<p>Managing<a id="_idIndexMarker007"/> infrastructure <strong class="bold">without</strong> advanced frameworks can be complex and requires specialized knowledge. IT operations encompass all processes and services provided by IT staff to meet a <a id="_idIndexMarker008"/>business’s technological requirements. This includes handling maintenance work and responding to customer issues. In traditional models, development, QA, and operations teams often work under different management structures, so detailed handoff processes and thorough documentation <span class="No-Break">are crucial:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer009">
					<img alt="Figure 1.2 – Traditional organization model with separated teams" src="image/B22100_01_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Traditional organization model with separated teams</p>
			<p>The traditional organizational model, which is characterized by distinct, separated teams, tends to <strong class="bold">complicate</strong> the delivery process. This separation often leads to slower deployments and reduced deployment frequencies. Additionally, the need to transition tasks between <a id="_idIndexMarker009"/>teams heightens the risk of miscommunication, which can result in testing oversights and <span class="No-Break">deployment errors.</span></p>
			<p>Most development<a id="_idIndexMarker010"/> teams use automated build systems and CI to compile, test, and produce <span class="No-Break">deployable artifacts.</span></p>
			<p>CI is a foundational process in modern software development that automates building, testing, and packaging applications, as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer010">
					<img alt="Figure 1.3 – Example of a CI workflow" src="image/B22100_01_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Example of a CI workflow</p>
			<p>In this system, software engineers frequently commit code changes to a central repository (for example, a <strong class="bold">Git repository</strong>), where<a id="_idIndexMarker011"/> these changes are automatically built, tested, and prepared for integration with the main code branch. This approach ensures that the software is always in a state ready for production deployment, highlighting the importance of CI in maintaining the continuous flow of <span class="No-Break">software development.</span></p>
			<p>CI’s automated processes are crucial for ensuring the quality and integrity of code before it merges with the main branch. By automating these stages, CI minimizes the risks associated with human error and speeds up the development cycle. However, the process often halts at the deployment stage, which is still predominantly manual in many organizations. This manual deployment can involve complex procedures or semi-automated scripts and often requires operations engineers to physically transfer and restart applications on servers. Such manual interventions are prone to errors and lack robust control mechanisms, making them inefficient <span class="No-Break">and risky.</span></p>
			<p>Building on the foundations of CI, <strong class="bold">CD</strong> takes automation a <span class="No-Break">step further:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer011">
					<img alt="Figure 1.4 – Example of a CD workflow" src="image/B22100_01_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Example of a CD workflow</p>
			<p>CD is a practice<a id="_idIndexMarker012"/> where code changes, once<a id="_idIndexMarker013"/> they pass through CI’s build and testing phases, are automatically prepared and ready for release to a production environment. It always keeps the software in a <strong class="bold">release-ready</strong> state, dramatically simplifying the process of releasing updates and <span class="No-Break">new features.</span></p>
			<p class="callout-heading">CD versus continuous deployment</p>
			<p class="callout">CD and continuous deployment are closely related practices in software development that streamline the release process. CD ensures every code change is automatically built, tested, and prepared for release, allowing for manual deployment to production. Continuous deployment goes a step further by automatically deploying every change that passes testing directly into production, eliminating manual steps. This accelerates the release process but demands high confidence in automation and <span class="No-Break">testing protocols.</span></p>
			<p>CD not only reduces the risks associated with deploying releases by enabling smaller and more frequent updates that are easier to manage than larger, infrequent ones, but it also significantly shortens prolonged testing cycles typically necessary for extensive code changes. This method enhances collaboration among development, operations, and other teams, aligning all parties toward the shared goal of rapidly and efficiently delivering high-quality software. CD efficiently manages and mitigates potential risks associated with large-scale code modifications, fostering a more agile and responsive software development <span class="No-Break">life cycle.</span></p>
			<p>CD empowers businesses to quickly adapt to market changes and customer feedback, maintaining a competitive edge in innovation and <span class="No-Break">customer satisfaction.</span></p>
			<p><strong class="bold">DevOps</strong> marks a<a id="_idIndexMarker014"/> significant shift in both<a id="_idIndexMarker015"/> organizational framework and mindset, placing a strong emphasis on automation. DevOps, in essence, acts as the glue that binds the technical efficiencies of CI/CD with the strategic goals of the organization. It emphasizes continuous feedback, monitoring, and optimization throughout the development process, ensuring continuous improvement post-deployment. This approach ensures that software development is not just a linear process ending with deployment but a cyclical one, where feedback and performance data feed back into the <span class="No-Break">development process.</span></p>
			<p>GitOps is an <a id="_idIndexMarker016"/>influential operational model that builds upon the core practices of DevOps, which are widely adopted in application development, and applies them to infrastructure automation. It integrates essential principles such as version control, collaborative work, adherence to compliance standards, and the use of CI/CD tools. This strategy facilitates effective and dependable management of <span class="No-Break">IaC processes.</span></p>
			<p>By integrating DevOps into the CI/CD pipeline, organizations can create a more holistic, efficient, and collaborative environment. This not only accelerates the pace of innovation and delivery but also significantly enhances product quality and customer satisfaction, positioning the organization competitively in an ever-evolving <span class="No-Break">digital landscape.</span></p>
			<p>In this model, the traditional roles of deployment and operations are transferred from the operations team to the development team of the application. DevOps integrates software <strong class="bold">development</strong> (<strong class="bold">Dev</strong>) with IT <strong class="bold">operations</strong> (<strong class="bold">Ops</strong>), aiming to reduce the overall system development life cycle. This integration facilitates frequent delivery of features, fixes, and updates, ensuring they align closely with <span class="No-Break">business goals.</span></p>
			<p>The following are some key advantages of <span class="No-Break">adopting DevOps:</span></p>
			<ul>
				<li>Enhanced collaboration between the development and <span class="No-Break">operations teams</span></li>
				<li>Improvement in the quality of the <span class="No-Break">products developed</span></li>
				<li>An increase in the frequency <span class="No-Break">of releases</span></li>
				<li>A reduction in the time needed to bring new features <span class="No-Break">to market</span></li>
				<li>Lower costs in design, development, and <span class="No-Break">operational processes</span></li>
				<li>Reduced <strong class="bold">mean time to recovery</strong> (<strong class="bold">MTTR</strong>), enhancing system resilience and minimizing the impact <span class="No-Break">of disruptions</span></li>
			</ul>
			<p>The evolution <a id="_idIndexMarker017"/>from DevOps to GitOps represents a natural progression in the quest for more efficient and reliable software development <a id="_idIndexMarker018"/>and operations practices. While DevOps focuses on breaking down the barriers between software development and operations while fostering a culture of collaboration and continuous improvement, GitOps takes this a step further by centering the entire operational workflow around the Git version control system. GitOps leverages Git as the single source of truth for declarative infrastructure <span class="No-Break">and application.</span></p>
			<p class="callout-heading">Reduced MTTR</p>
			<p class="callout">Reducing the MTTR refers to improving one of the key <strong class="bold">DevOps Research and Assessment</strong> (<strong class="bold">DORA</strong>) metrics, which<a id="_idIndexMarker019"/> is the average time it takes to recover from a failure or outage in a system or service. This metric is crucial in understanding and enhancing the resilience and reliability of IT operations. By reducing the MTTR, organizations can ensure that their systems are restored more quickly after a disruption, minimizing the impact on users and business operations. This improvement is often achieved through more effective incident management processes, automation, and better preparedness for <span class="No-Break">handling failures.</span></p>
			<p>This approach not only streamlines deployment and management processes but also enhances transparency, accountability, <span class="No-Break">and reproducibility.</span></p>
			<p>The transition from DevOps to GitOps is driven by the need for greater automation, consistency, and security in managing complex and dynamic <span class="No-Break">cloud-native environments.</span></p>
			<p>GitOps automates the deployment process using Git’s powerful version control capabilities, which means every change in the system can be tracked, reversed, and subject to peer review processes, just like code changes in software development. This shift brings the rigor and precision of software development to the world of operations, significantly reducing the potential for human error and improving the stability and security of <span class="No-Break">production environments.</span></p>
			<p>Moreover, GitOps <a id="_idIndexMarker020"/>aligns perfectly with the <a id="_idIndexMarker021"/>containerized and microservices-oriented architectures that are prevalent in modern cloud environments, enabling faster and more efficient deployment pipelines that are crucial for businesses to remain agile and responsive in a rapidly changing <span class="No-Break">digital landscape.</span></p>
			<p>In the following sections of this chapter, we will delve deeper into the benefits of adopting GitOps. We will explore why it should be used, its integration with Kubernetes, and other tools such as Argo CD and <span class="No-Break">Flux CD.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>The fundamentals of GitOps and the advantages of adopting it for platform engineering</h1>
			<p>DevOps<a id="_idIndexMarker022"/> emerged as a response to these silos, blending the roles of development and operations. It extended the principles of CI/CD to include a cultural <a id="_idIndexMarker023"/>shift toward collaboration, aiming to break down the barriers between developers and IT operations. The emphasis was on a holistic approach to the software life cycle, ensuring that both development and operational considerations were <a id="_idIndexMarker024"/>integrated from the start. DevOps embraced practices such as IaC and monitoring, fostering a more responsive and <span class="No-Break">agile environment.</span></p>
			<p>GitOps, a more recent innovation, builds upon these foundations but introduces a significant shift: it takes the principles of DevOps and CI/CD and centralizes them around the <span class="No-Break">Git repository.</span></p>
			<p>In a GitOps story, as illustrated in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.5</em>, everything begins with a Git repository, where the entire state of a system – code, configuration, environment settings, and even documentation – is stored and versioned. This approach allows for a high level of transparency, traceability, and audibility as every change is recorded and can be traced back to <span class="No-Break">a commit:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 1.5 – Example of a GitOps pipeline embracing DevOps" src="image/B22100_01_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Example of a GitOps pipeline embracing DevOps</p>
			<p>In GitOps, Git is<a id="_idIndexMarker025"/> not just <a id="_idIndexMarker026"/>a version control system; it’s the single source of truth for both application code and infrastructure configuration. This approach leverages the strengths of Git – such as version control, collaboration features, and the pull request workflow – to manage the entire deployment and operational process. GitOps emphasizes a <strong class="bold">declarative approach</strong>, where <a id="_idIndexMarker027"/>the desired state of the system is defined in Git and automated processes ensure that the actual state aligns with this <span class="No-Break">desired state.</span></p>
			<p>Everything from application code to infrastructure configuration is stored in Git repositories. This centralization not only simplifies the process of managing and tracking changes but also ensures consistency and transparency across all stages of development <span class="No-Break">and deployment.</span></p>
			<p>The workflow in a GitOps scenario is elegantly automated and highly efficient. Developers submit changes via pull requests, which then undergo automated tests and reviews. Once approved, these changes are automatically deployed to production environments, aligning with the principles of CI/CD <span class="No-Break">seen previously.</span></p>
			<p class="callout-heading">Pull request</p>
			<p class="callout">A <strong class="bold">pull request</strong> is a<a id="_idIndexMarker028"/> feature in version control systems, particularly in Git, that facilitates collaboration in software development. Acting as a checkpoint, a pull request allows developers to inform others about changes they’ve pushed to a repository on a hosting service such as GitHub or GitLab. After pushing a branch with updates, a developer can initiate a pull request to merge these changes into the main branch. This process invites review and discussion on the proposed changes, ensuring that code is vetted and refined collaboratively before being integrated, thus enhancing code quality and shared understanding among <span class="No-Break">team members.</span></p>
			<p>This <a id="_idIndexMarker029"/>automation not only streamlines the deployment process but also significantly reduces the chances of human error. Moreover, because the entire system state is version-controlled, rolling back to a previous state in case of an issue <span class="No-Break">is straightforward.</span></p>
			<p>This process, often <a id="_idIndexMarker030"/>termed <strong class="bold">Git-centric</strong>, empowers teams<a id="_idIndexMarker031"/> to manage infrastructure and applications with the same tools and processes used in code development, bringing a unified approach to <span class="No-Break">software delivery.</span></p>
			<p>GitOps represents a significant evolution from traditional practices that leverages the strengths of Git, automation, and declarative models. This methodology provides a framework for realizing the results of DevOps culture, offering an agnostic approach that can be implemented with various tools, such as Kubernetes and <span class="No-Break">CI/CD solutions.</span></p>
			<p>The GitOps Working Group, with its defined set of GitOps principles, underpins this approach, emphasizing the importance of declarative configurations, versioned and immutable states, automatic pulling, and <span class="No-Break">continuous reconciliation.</span></p>
			<p>As we explore this further, these fundamentals will be illustrated with practical examples, showcasing the real-world impact and advantages of adopting a GitOps mindset in <span class="No-Break">platform engineering.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Why GitOps?</h1>
			<p>Adopting GitOps for platform engineering brings a multitude of advantages, reshaping how teams interact with infrastructure and applications. This methodology leverages the strengths of Git, automation, and declarative configurations, providing a robust framework for managing complex systems. Here <a id="_idIndexMarker032"/>are some of the <span class="No-Break">key benefits:</span></p>
			<ul>
				<li><strong class="bold">Declarative and immutable nature</strong>: GitOps focuses on declaring the desired state of systems rather than detailing imperative scripts. It adopts an immutable infrastructure approach where changes are made by replacing resources rather than modifying existing ones, enhancing consistency <span class="No-Break">and stability.</span></li>
				<li><strong class="bold">Automated synchronization</strong>: Central to GitOps is automatically synchronizing the system state with the configurations described in Git to cover the full life cycle of infrastructure and applications, including deployment, updates, scaling, <span class="No-Break">and recovery.</span></li>
				<li><strong class="bold">Pull request workflow integration</strong>: Operational processes in GitOps are deeply integrated with a pull request workflow, embodying the philosophy of treating everything as code. This integration facilitates code reviews, collaborative discussions, and shared knowledge <span class="No-Break">and responsibility.</span></li>
				<li><strong class="bold">Continuous feedback and monitoring</strong>: GitOps emphasizes continuous monitoring to detect and remedy any divergence from the desired state, promoting ongoing system maintenance <span class="No-Break">and improvement.</span></li>
				<li><strong class="bold">Enhanced efficiency and productivity</strong>: By automating platform engineering aspects, GitOps reduces manual efforts and human errors, allowing teams to focus more <span class="No-Break">on innovation.</span></li>
				<li><strong class="bold">Improved consistency and reliability</strong>: Using Git as the single source of truth with declarative configurations ensures consistent and reliable infrastructure across <span class="No-Break">different environments.</span></li>
				<li><strong class="bold">Faster recovery and rollback</strong>: GitOps enables quick rollbacks to previous states for enhanced system resilience and faster recovery <span class="No-Break">from failures.</span></li>
				<li><strong class="bold">Collaboration and transparency</strong>: The methodology encourages collaborative platform engineering, with peer reviews and discussions improving knowledge sharing <span class="No-Break">and transparency.</span></li>
				<li><strong class="bold">Streamlined audits and compliance</strong>: All changes are tracked in Git, simplifying auditing and facilitating compliance with regulatory requirements and <span class="No-Break">internal policies.</span></li>
				<li><strong class="bold">Scalability and flexibility</strong>: GitOps scales efficiently with organizational needs and adapts to various types of infrastructure, including cloud, on-premises, and <span class="No-Break">hybrid environments.</span></li>
				<li><strong class="bold">Enhanced security</strong>: The use of pull requests and code reviews adds an extra layer of <a id="_idIndexMarker033"/>security, ensuring thorough scrutiny of changes to infrastructure <span class="No-Break">and applications.</span></li>
				<li><strong class="bold">Simplified onboarding and knowledge sharing</strong>: The Git repository provides a clear overview of the system’s current state, aiding in onboarding new team members and fostering an environment of accessible <span class="No-Break">knowledge sharing.</span></li>
				<li><strong class="bold">Continuous improvement and adaptation</strong>: The inherent feedback loops and monitoring in GitOps enable teams to iteratively improve their systems and adapt to <span class="No-Break">changing requirements.</span></li>
			</ul>
			<p>Adopting GitOps presents various challenges for a company that can impact its transition to this methodology. Firstly, there’s the learning curve and the need for training in specific tools such as Kubernetes, Helm, or Argo CD, which can temporarily reduce productivity. Implementing GitOps also requires a cultural shift toward rigorous code management and CI/CD practices. The initial setup and integration process can be complex and time-consuming, necessitating significant investments in time <span class="No-Break">and resources.</span></p>
			<p>Furthermore, organizing the Git repository structure efficiently is crucial as it directly affects the manageability and scalability of deployments. Mismanagement here can lead to operational inefficiencies and increased errors. Another critical aspect is secrets management; GitOps workflows require sensitive data to be handled carefully to prevent security breaches. Proper strategies must be implemented to securely store, access, and manage secrets within the GitOps processes to ensure that automated deployments remain secure <span class="No-Break">and efficient.</span></p>
			<p>In this section, we highlighted the significant advantages and challenges of adopting GitOps for platform engineering. This methodology capitalizes on the strengths of Git, automation, and declarative configurations to offer a robust framework for managing complex systems. The next section will introduce the integration between GitOps, IaC, <span class="No-Break">and Kubernetes.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>The integration between GitOps, IaC, and Kubernetes</h1>
			<p>In this section, we’ll delve into the intricate integration of GitOps, IaC, and Kubernetes, along with key tools such as Argo CD and Flux CD. We’ll explore how this cohesive blend enhances cloud-native operations, streamlining deployment processes and bolstering security, thereby revolutionizing the way infrastructure is managed and applications are deployed in modern software <span class="No-Break">development environments.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>GitOps and IaC</h2>
			<p>IaC involves <a id="_idIndexMarker034"/>managing and provisioning infrastructure <a id="_idIndexMarker035"/>via code rather than manual procedures. This approach involves creating configuration files that detail your infrastructure requirements, thus simplifying the process of modifying and disseminating these configurations. IaC guarantees consistent provisioning of the same environment each time, and at the same time, IaC transforms configuration specifications into coded documentation, improving <span class="No-Break">configuration management.</span></p>
			<p>This approach helps avoid undocumented and spontaneous <span class="No-Break">configuration alterations.</span></p>
			<p>GitOps extends the familiar Git version control system to infrastructure and deployment management and aligns closely with the principles of IaC. This integration allows developers to manage infrastructure configuration and code deployment as they would their software development process, bringing <span class="No-Break">numerous advantages:</span></p>
			<ul>
				<li><strong class="bold">Accelerated production time</strong>: Quicker infrastructure provisioning with reduced human error leads to more <span class="No-Break">predictable outcomes</span></li>
				<li><strong class="bold">Template-based reusability</strong>: Use an IaC configuration file as a template, providing a baseline for further <span class="No-Break">related configurations</span></li>
				<li><strong class="bold">Uniform deployment</strong>: Achieve consistent infrastructure deployment, avoiding minor discrepancies that could lead to significant <span class="No-Break">future issues</span></li>
				<li><strong class="bold">Traceability and auditability</strong>: Integrating IaC with a code repository for source tracking offers a detailed history of changes, including versioning and audit trails that<a id="_idIndexMarker036"/> identify who made changes <span class="No-Break">and when</span></li>
				<li><strong class="bold">Enhanced organizational knowledge</strong>: Versioning documents the rationale behind changes, creating a valuable resource for both new and <span class="No-Break">existing employees</span></li>
				<li><strong class="bold">Improved disaster recovery</strong>: IaC ensures the ability to rapidly reconstruct environments in <a id="_idIndexMarker037"/>the event of a failure, minimizing downtime and <span class="No-Break">business disruption</span></li>
			</ul>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>GitOps and Kubernetes</h2>
			<p>GitOps and<a id="_idIndexMarker038"/> Kubernetes (<a href="https://kubernetes.io/docs/concepts/overview/">https://kubernetes.io/docs/concepts/overview/</a>) represent a powerful combination in the realm of <a id="_idIndexMarker039"/>modern software development and infrastructure management. Kubernetes, an open source platform for automating the processes of deployment, scaling, and operations for application containers across clusters of hosts, provides a robust foundation for managing containerized applications at scale. GitOps, on the other hand, is an operational framework that applies the principles of Git – version control, collaboration, and compliance – to infrastructure automation. When combined, GitOps and Kubernetes offer a highly efficient, scalable, and reliable system for managing complex applications <span class="No-Break">and infrastructure.</span></p>
			<p>Kubernetes has become essential for orchestrating containerized applications, offering capabilities such as automated rollouts and rollbacks, service discovery and load balancing (with its ability to assign IP addresses to Pods and services for load balancing), storage orchestration, secret and configuration management without exposing secrets or requiring Docker image rebuilds, and self-healing mechanisms such as restarting failed containers and rescheduling Pods when node <span class="No-Break">issues occur.</span></p>
			<p>Additionally, Kubernetes facilitates horizontal scaling based on CPU usage and operates declaratively. These features continue to evolve with each <span class="No-Break">Kubernetes release.</span></p>
			<p>The fusion of GitOps with Kubernetes significantly quickens and improves the efficiency of deployment processes. This combination promotes more frequent deployments by enabling CD automation and integrating essential feedback and control systems. By using Git’s declarative definitions, developers can employ well-known workflows, which simplifies the ability to create new development or test environments and deploy new features to a cluster. Consequently, this leads to an increased daily rate of changes, accelerating the delivery of new features and functionalities to <span class="No-Break">end users.</span></p>
			<p>GitOps <a id="_idIndexMarker040"/>also empowers teams to become more self-sufficient. Traditionally, development teams relied on operations teams for deploying changes <a id="_idIndexMarker041"/>in production. GitOps shifts this dynamic, allowing development teams to be less dependent on platform and operations teams for deploying and managing code and configuration changes in production. Simply committing changes to the Git repository and merging pull requests can trigger the rest of the process through GitOps tools. This self-service nature enhances efficiency and <span class="No-Break">strategic capability.</span></p>
			<p>GitOps enhances the management of deployments and infrastructure by utilizing Git as the source of truth <a id="_idIndexMarker042"/>for <strong class="bold">declarative configurations</strong>. In a declarative system, the focus is on defining the desired outcome rather than the steps to achieve it. This approach contrasts with the imperative approach, which involves specifying a sequence of steps and often adds extra workload for operators. Within GitOps, every component of the environment can be coded and declared in the Git repository. Once changes are made and committed to Git, the system automatically processes these declarations to create or update the <span class="No-Break">necessary objects.</span></p>
			<p>This <strong class="bold">seamless integration</strong> with <a id="_idIndexMarker043"/>the declarative nature of Kubernetes is where the power of GitOps truly shines. Kubernetes operates on a <strong class="bold">reconciliation loop</strong> that <a id="_idIndexMarker044"/>continuously adjusts the actual state of the cluster to match the desired state defined by its configurations. When discrepancies between the current and desired states are detected, Kubernetes takes automatic action to reconcile these differences. This could involve creating, updating, or deleting resources to ensure the cluster’s configuration matches what has been defined in the <span class="No-Break">Git repository.</span></p>
			<p>Together, the combination of GitOps and the Kubernetes reconciliation loop provides a robust framework for automated system management. This ensures that all system components are deployed consistently according to the precise configurations defined in Git, adhering to a fully declarative approach that streamlines operations, enhances reliability, and maintains consistency across development, staging, and <span class="No-Break">production environments.</span></p>
			<p><strong class="bold">Observability</strong> is <a id="_idIndexMarker045"/>another crucial aspect of GitOps in a Kubernetes environment. It involves continuously monitoring the actual state present in the cluster and comparing it to the desired <a id="_idIndexMarker046"/>state. GitOps aids in measuring and monitoring what’s running on the cluster, alerting teams to any discrepancies. Modern GitOps tools come equipped with monitoring and notification capabilities to support <span class="No-Break">this function.</span></p>
			<p>From a <strong class="bold">compliance and auditing</strong> perspective, GitOps offers significant advantages. With Git as the<a id="_idIndexMarker047"/> sole source of truth, auditing becomes straightforward: auditors can assess the desired state by examining the source code repository and verify the current state by reviewing the underlying infrastructure provider and the Kubernetes cluster state. This simplifies compliance and auditing processes across <span class="No-Break">various domains.</span></p>
			<p>For organizations that use <em class="italic">multiple Kubernetes clusters</em> for different business and team needs, managing these clusters and maintaining consistent configuration and security policies is a significant challenge. GitOps addresses this by allowing GitOps agents running across these clusters to manage everything on behalf of the Ops team, making it an ideal solution for multi-cluster <span class="No-Break">configuration management.</span></p>
			<p><strong class="bold">Disaster recovery</strong> (<strong class="bold">DR</strong>) is essential<a id="_idIndexMarker048"/> for organizations to<a id="_idIndexMarker049"/> recover quickly from incidents that disrupt business operations, with the primary aim being to rapidly restore critical systems and IT infrastructure. From the GitOps perspective, DR primarily handles configuration management, not data recovery. This distinction is crucial because, while configurations are saved in Git, actual data is not. Tools such as Git are useful for version control of configurations but do not aid in data recovery. For example, if a database is deleted, Git cannot assist in its recovery; therefore, separate data recovery strategies are necessary and specifically designed for restoring <span class="No-Break">lost data.</span></p>
			<p>In the Kubernetes ecosystem, the adoption of GitOps for automating infrastructure setup is on the rise. This includes the creation of deployments, services, and various Kubernetes entities. DevOps and <strong class="bold">site reliability engineering</strong> (<strong class="bold">SRE</strong>) teams are increasingly <a id="_idIndexMarker050"/>turning to GitOps for managing all infrastructure configuration files as code. This approach leverages the inherent IaC characteristic <span class="No-Break">of GitOps.</span></p>
			<p>Furthermore, GitOps enhances <em class="italic">security</em> protocols. It uses sophisticated cryptographic methods in Git for monitoring and managing changes, and it can also authenticate changes to confirm authorship and source. This practice ensures a securely defined intended state of the cluster. In the event of a security breach, the immutable and auditable nature of Git’s source of truth is instrumental in reconstructing a system separate from the compromised one, thereby minimizing downtime and boosting the efficiency of <span class="No-Break">incident responses.</span></p>
			<p>The practice <a id="_idIndexMarker051"/>of separating responsibilities in software packaging and release to production further adheres to the principle of least privilege, which <a id="_idIndexMarker052"/>diminishes the likelihood and severity of security breaches and offers a smaller <span class="No-Break">attack surface.</span></p>
			<p>GitOps facilitates this by ensuring that the entire infrastructure environment and components are defined declaratively in the Git repository. In the event of a disaster, recovery becomes a matter of reapplying the configuration files from Git to quickly restore <span class="No-Break">the ecosystem.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Kubernetes and Argo CD</h2>
			<p>Argo CD, a GitOps<a id="_idIndexMarker053"/> CD for Kubernetes (<a href="http://argo-cd.readthedocs.io">argo-cd.readthedocs.io</a>), is a <a id="_idIndexMarker054"/>declarative tool for continuous delivery specifically designed for Kubernetes. It functions as a standalone solution or can be integrated into your existing CI/CD pipeline to efficiently deploy necessary resources across your <span class="No-Break">Kubernetes clusters.</span></p>
			<p>Integrating GitOps<a id="_idIndexMarker055"/> and Kubernetes using Argo CD provides a streamlined approach for managing cloud-native applications and jobs on Kubernetes. Argo CD, part of the Argo project family, offers a suite of tools, including Workflows, Events, and Rollouts, that enhance Kubernetes-native application delivery. This becomes particularly relevant for organizations transitioning to containerized environments and Kubernetes deployments, where Argo CD can act as a <span class="No-Break">comprehensive solution.</span></p>
			<p>In large-scale deployments typical of big enterprises with numerous developers and a multitude of microservices, the GitOps methodology shines. However, it often necessitates supplementary tools and services for effective implementation. It’s not practical for each team in such an organization to operate independently and manage its Kubernetes cluster. A more efficient strategy is a centralized platform for operating and maintaining multi-tenant clusters. This setup gives teams the autonomy to manage their workloads within these clusters, while still providing centralized oversight <span class="No-Break">and maintenance.</span></p>
			<p>Argo CD is <a id="_idIndexMarker056"/>instrumental in<a id="_idIndexMarker057"/> facilitating this centralized approach to cluster management, promoting the adoption of GitOps. The following are some key factors to consider if you want to create an effective <a id="_idIndexMarker058"/>GitOps strategy in Kubernetes with <span class="No-Break">Argo CD:</span></p>
			<ul>
				<li><strong class="bold">User onboarding</strong>: Simplifying the onboarding process is crucial. Centralizing the installation, setup, and maintenance of deployment operators can ease the process of transitioning multiple microservices to Kubernetes, rather than placing this burden on individual teams. Incorporating <strong class="bold">single sign-on</strong> (<strong class="bold">SSO</strong>) is particularly<a id="_idIndexMarker059"/> beneficial in systems with a large user base, streamlining the introduction of <span class="No-Break">new users.</span></li>
				<li><strong class="bold">Multi-tenancy and management</strong>: In environments with multiple tenants, users need secure and flexible access to resources. Kubernetes’ <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) system is <a id="_idIndexMarker060"/>a powerful feature but might not suffice for managing numerous clusters. Argo CD enhances this with additional access control features, integrating seamlessly with SSO providers and facilitating access to <span class="No-Break">multiple clusters.</span></li>
				<li><strong class="bold">Observability</strong>: A key feature of an effective CD tool is enabling developers to monitor and track the state of their applications. Argo CD’s user-friendly interface provides detailed insights into an application’s configuration, such as sync status with Git, specific out-of-sync elements, and any <span class="No-Break">operational issues.</span></li>
			</ul>
			<p>In the following section, we will explore Flux CD, a tool that, when integrated with Kubernetes, enables scalability and ensures consistent environments across various types <span class="No-Break">of deployments.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Kubernetes and Flux CD</h2>
			<p>Flux (<a href="http://fluxcd.io">fluxcd.io</a>) is an <a id="_idIndexMarker061"/>open and extensible CD solution<a id="_idIndexMarker062"/> for Kubernetes <a id="_idIndexMarker063"/>and represents a critical component in the modern <span class="No-Break">DevOps ecosystem.</span></p>
			<p>At the time of writing, Alexis Richardson, CEO of Weaveworks, has announced on LinkedIn that the company is facing economic challenges and will be closing its doors and shutting down commercial operations. Weaveworks will be collaborating with a financial trustee, to be announced soon, to manage the closure process. This decision comes despite the <a id="_idIndexMarker064"/>company generating significant revenue and expanding its customer base, highlighting the financial volatility and strategic challenges faced in maintaining its operations. The original announcement can be found <span class="No-Break">here: </span><a href="https://www.linkedin.com/posts/richardsonalexis_hi-everyone-i-am-very-sad-to-announce-activity-7160295096825860096-ZS67/"><span class="No-Break">https://www.linkedin.com/posts/richardsonalexis_hi-everyone-i-am-very-sad-to-announce-activity-7160295096825860096-ZS67/</span></a><span class="No-Break">.</span></p>
			<p>As a GitOps tool, Flux <a id="_idIndexMarker065"/>ensures that the state of manifests in a Git repository is consistently synchronized with what is running in a Kubernetes cluster. GitOps, far from being just another tool, offers a method for developers to manage operational workflows in Kubernetes using Git. This approach emphasizes using a version-controlled system such as Git to deploy applications in Kubernetes, allowing developers to directly push code into production. Changes can easily be tracked and reverted if necessary, bolstering the reliability <span class="No-Break">of deployments.</span></p>
			<p>The following are <a id="_idIndexMarker066"/>the main features of <span class="No-Break">Flux CD:</span></p>
			<ul>
				<li>Automated synchronization between a version control repository and <span class="No-Break">a cluster</span></li>
				<li>Instant reflection of repository changes in <span class="No-Break">the cluster</span></li>
				<li>Direct code deployment into production <span class="No-Break">from repositories</span></li>
				<li>Version-controlled configuration, ensuring all configurations are up <span class="No-Break">to date</span></li>
				<li>Disaster recovery capabilities, enabling new clusters to be set up with <span class="No-Break">identical configurations</span></li>
			</ul>
			<p>In the context of Kubernetes, a robust container orchestration platform, Flux CD plays an instrumental role. Kubernetes excels in automating and simplifying application deployment and management, particularly in scaling and maintaining consistent environments across diverse deployments. Flux CD, adhering to GitOps principles, introduces a layer of automation and security by continuously synchronizing application and infrastructure states with configurations stored in a Git repository. This ensures that the actual state aligns with the desired state in a secure and controlled manner. The synergy between Kubernetes and<a id="_idIndexMarker067"/> Flux CD offers several <span class="No-Break">key benefits:</span></p>
			<ul>
				<li><strong class="bold">Automated deployments</strong>: Flux CD’s automated updates and configurations are committed to the <span class="No-Break">Git repository</span></li>
				<li><strong class="bold">Scalability and reliability</strong>: Kubernetes’ prowess in handling containerized applications is complemented by Flux CD’s consistency <span class="No-Break">in configurations</span></li>
				<li><strong class="bold">Enhanced security</strong>: Flux CD’s use of Git as the single source of truth adds an extra <span class="No-Break">security layer</span></li>
				<li><strong class="bold">Operational efficiency</strong>: The integration streamlines operations, reducing manual intervention and <span class="No-Break">increasing efficiency</span></li>
			</ul>
			<p>In conclusion, the <a id="_idIndexMarker068"/>combination of Kubernetes and Flux CD provides a comprehensive solution for modern software deployment and<a id="_idIndexMarker069"/> management. Their integration enhances automation, scalability, security, and efficiency, marking them as indispensable tools in cloud-native technologies and <span class="No-Break">DevOps practices.</span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Summary</h1>
			<p>This chapter provided an in-depth introduction to GitOps, exploring its transformative impact on software development and operations. We began by contrasting GitOps with traditional CI/CD and DevOps methodologies, highlighting its unique approach <span class="No-Break">and advantages.</span></p>
			<p>Then, we covered the history and evolution of deployment strategies that led to GitOps. Key principles such as Git centralization, the declarative approach, automated synchronization, and continuous feedback were discussed, emphasizing GitOps’ role in enhancing efficiency, consistency, and collaboration in <span class="No-Break">platform engineering.</span></p>
			<p>Additionally, we delved into GitOps’ integration with tools such as Kubernetes, showcasing its scalability and security advantages in modern cloud environments. We concluded by underscoring the significance of adopting GitOps for its robust framework and adaptability to evolving <span class="No-Break">technological landscapes.</span></p>
			<p>In <a href="B22100_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we’ll dive into the practicalities of GitOps in cloud-native environments, examining its seamless integration with Kubernetes, the architecture of lightweight Kubernetes distributions, and the design of cloud-native <span class="No-Break">CI/CD pipelines.</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
			<ul>
				<li><em class="italic">Argo CD – Declarative GitOps CD for </em><span class="No-Break"><em class="italic">Kubernetes</em></span><span class="No-Break">: </span><a href="https://argo-cd.readthedocs.io/en/stable/"><span class="No-Break">https://argo-cd.readthedocs.io/en/stable/</span></a></li>
				<li><em class="italic">Flux </em><span class="No-Break"><em class="italic">CD</em></span><span class="No-Break">: </span><a href="https://fluxcd.io/"><span class="No-Break">https://fluxcd.io/</span></a></li>
			</ul>
		</div>
	</body></html>