<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-30"><a id="_idTextAnchor030"/>2</h1>
<h1 id="_idParaDest-31"><a id="_idTextAnchor031"/>Introducing MicroK8s</h1>
<p><strong class="bold">Kubernetes</strong> is the world's most popular<a id="_idIndexMarker085"/> orchestration technology for container-based applications, automating their deployment and scalability while also making maintenance easier. Kubernetes, on the other hand, has its own set of complications. So, how can an organization use containerization to address complexity while avoiding adding to Kubernetes' complexity?</p>
<p><strong class="bold">Canonical's MicroK8s</strong> is a powerful Cloud-Native Computing Foundation-certified Kubernetes<a id="_idIndexMarker086"/> distribution. Here are some<a id="_idIndexMarker087"/> of the key reasons why it has become a powerful enterprise computing platform:</p>
<ul>
<li><strong class="bold">Delivered as snap packages</strong>: These are application packages for desktop, cloud, and even <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) devices that are simple to install and secured with auto-updates, and they can be deployed on any of the Linux distributions that support snaps. </li>
<li><strong class="bold">Strict confinement</strong>: This ensures complete isolation from the underlying operating system as well as a highly secure Kubernetes environment fit for production.</li>
<li><strong class="bold">Production-grade add-ons</strong>: Add-ons such as Istio, Knative, CoreDNS, Prometheus, Jaeger, Linkerd, Cilium, and Helm are available. They are straightforward to set up, requiring only a few lines of commands. For better <strong class="bold">Artificial Intelligence</strong> (<strong class="bold">AI</strong>) and <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) capabilities, Kubeflow is also available as an add-on to MicroK8s.</li>
</ul>
<p>MicroK8s will speed up Kubernetes deployments<a id="_idIndexMarker088"/> due to its ability to decrease complexity. Treating devices like distributed containerized programs allows developers to concentrate on applications rather than infrastructure, making operations teams' lives easier.</p>
<p>MicroK8s enables you to combine Kubernetes installations into a single cluster and distribute workloads over one or more of these nodes. In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>Introducing MicroK8s Kubernetes</li>
<li>Quick installation</li>
<li>Deploying a sample application</li>
<li>Enabling add-ons </li>
<li>Starting/stopping MicroK8s</li>
<li>Configuring MicroK8s to use local images </li>
<li>Configuring MicroK8s to use built-in registries</li>
<li>Configuring MicroK8s to use private/public registries </li>
<li>Configuring MicroK8s services</li>
<li>Troubleshooting application and cluster issues</li>
</ul>
<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/>Introducing MicroK8s Kubernetes</h1>
<p>MicroK8s is a production-ready Kubernetes<a id="_idIndexMarker089"/> distribution that is powerful, lightweight, and reliable. It's a Kubernetes distribution for enterprises with a reduced memory and disk footprint, as well as pre-installed add-ons such as Istio, Knative, Grafana, Cilium, and others. MicroK8s meets your needs, whether you're running a production setup or just getting started with Kubernetes.</p>
<p>Anyone who has attempted to work with Kubernetes understands how difficult it is to get up and running with the deployment. There are other minimalist solutions on the market that minimize deployment time and complexity, but they come at the cost of key extensibility and missing add-ons.</p>
<p>MicroK8s gets you up and running in just 60 seconds, so you don't waste too much time jumping through hurdles to get Kubernetes up and running. </p>
<p>Some of the key features<a id="_idIndexMarker090"/> are as follows:</p>
<ul>
<li><strong class="bold">Minimal</strong>: For laptop and workstation development, developers need the smallest Kubernetes solution possible. When running on Ubuntu, MicroK8s is a self-contained Kubernetes cluster that works with Azure AKS, Amazon EKS, and Google GKE.</li>
<li><strong class="bold">Easy</strong>: Lower administration and operations costs by using a single-package installation. All add-ons and dependencies are included. </li>
<li><strong class="bold">Secured</strong>: Updates are available<a id="_idIndexMarker091"/> for all security breaches and can be applied immediately or scheduled according to your maintenance cycle.</li>
<li><strong class="bold">Up to date</strong>: MicroK8s keeps up with upstream Kubernetes, releasing beta, RC, and final elements on the same day as upstream Kubernetes. </li>
<li><strong class="bold">Complete</strong>: A handpicked set of manifests for common Kubernetes capabilities and services is already included in MicroK8s:</li>
</ul>
<p>a. Automatic updates to the latest Kubernetes version</p>
<p>b. Service mesh: Istio and Linkerd</p>
<p>c. Serverless: Knative and OpenFaaS</p>
<p>d. Monitoring: Fluentd, Prometheus, and Grafana, Metrics</p>
<p>e. Ingress, DNS, Dashboard, and clustering</p>
<p>f. GPU bindings for AI/ML</p>
<p>g. Cilium, Helm, and Kubeflow</p>
<p>Now that we know what MicroK8s is, let's see how easy it is to get started in the next section.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/>Quick installation</h1>
<p>MicroK8s is deployed via <strong class="bold">snaps</strong>. Snaps are<a id="_idIndexMarker092"/> containerized (like Docker) software<a id="_idIndexMarker093"/> packages that are easy to create and install; they bundle their dependencies, and they work on all major Linux systems without modification. Snaps auto-update and are safe to run. Also, keep in mind that the MicroK8s snap will be updated frequently to keep up with Kubernetes releases.</p>
<p>In the next section, we will guide you through a minimal installation that'll work while we walk through the introduction. </p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>Technical requirements </h2>
<p>For the minimal installation, you require the following:</p>
<ul>
<li>You should have either a Linux distribution such as Ubuntu (20.04 LTS, 18.04 LTS, or 16.04 LTS) environment to execute the commands or any other operating system that supports <strong class="source-inline">snapd</strong>.</li>
<li>4 GB of memory and 20 GB of disk space are recommended.</li>
</ul>
<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>Step 1 – Installation</h2>
<p>In the following steps, we will be installing<a id="_idIndexMarker094"/> a MicroK8s cluster. We will install a limited set of components such as <strong class="source-inline">api-server</strong>, <strong class="source-inline">controller-manager</strong>, <strong class="source-inline">scheduler</strong>, <strong class="source-inline">kubelet</strong>, <strong class="source-inline">cni</strong>, and <strong class="source-inline">kube-proxy</strong>.</p>
<p>A MicroK8s snap can be installed using the following command:</p>
<p class="source-code">sudo snap install microk8s --classic</p>
<p>The following command execution output confirms that MicroK8s has been installed successfully:</p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="Figure 2.1 – MicroK8s installation " height="103" src="image/B18115_Fig_2.1.jpg" width="1037"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – MicroK8s installation</p>
<p>Currently, I'm using an Ubuntu VM hosted on the cloud, but MicroK8s can also be installed on Windows, macOS, and Raspberry Pi on ARM hardware. For other platforms, please<a id="_idIndexMarker095"/> refer to the following link: <a href="http://https//microk8s.io/docs/install-alternatives">https//microk8s.io/docs/install-alternatives</a>.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">You can also specify a channel when installing MicroK8s. The specified channel consists of two parts – the <em class="italic">track</em> and the <em class="italic">risk</em> level. For example, to install MicroK8s v1.20 with the risk level set to <strong class="source-inline">stable</strong>, do the following: </p>
<p class="callout"><strong class="bold">sudo snap install microk8s --classic --channel=1.20/stable</strong></p>
<p class="callout">When the MicroK8s team determines that a release (<em class="italic">edge</em> and <em class="italic">candidate</em>) is ready, your cluster is updated to the <em class="italic">stable</em> risk level, indicating that no bugs have been discovered by users running the same revision on riskier branches. </p>
<p>For accessing Kubernetes, MicroK8s<a id="_idIndexMarker096"/> includes its own version of <strong class="source-inline">kubectl</strong>. It can be used to perform commands that will monitor and control your Kubernetes cluster. MicroK8s adds a <strong class="source-inline">microk8s.kubectl</strong> command to avoid conflicting with an existing <em class="italic">kubectl</em> and overwriting any existing Kubernetes configuration file. If you just use MicroK8s, consider creating an alias with this command:</p>
<p class="source-code">sudo snap alias microk8s.kubectl kubectl</p>
<p>The following command execution output confirms that an alias was added successfully:</p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 2.2 – kubectl – adding an alias " height="123" src="image/B18115_Fig_2.2.jpg" width="1017"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – kubectl – adding an alias</p>
<p>At this point, you have installed MicroK8s. In the next steps, we will be verifying whether the installation has succeeded or not.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Step 2 – Verify the installation</h2>
<p>Next, check whether the newly deployed<a id="_idIndexMarker097"/> node is in the <strong class="source-inline">Ready</strong> state using the following command:</p>
<p class="source-code">kubectl get nodes</p>
<p>The following is the command execution output:</p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="Figure 2.3 – Verify the installation " height="263" src="image/B18115_Fig_2.3.jpg" width="1235"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Verify the installation</p>
<p>If you get the error shown in <em class="italic">Figure 2.3</em>, it means MicroK8s doesn't have enough permissions. MicroK8s creates<a id="_idIndexMarker098"/> a group to make it easier to use commands that require administrative privileges. To acquire access to the <strong class="source-inline">.kube</strong> caching directory by adding the current user to the group, run the following two commands:</p>
<p class="source-code">sudo usermod -a -G microk8s azureuser</p>
<p class="source-code">sudo chown -f -R azureuser ~/.kube</p>
<p>The following is the output: </p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 2.4 – Adding users to the group " height="100" src="image/B18115_Fig_2.4.jpg" width="992"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Adding users to the group</p>
<p>If you receive still an error, it means that MicroK8s is still starting the nodes in the background. Wait for a few minutes and try again. If the installation is successful, then you should be seeing the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 2.5 – Verify the installation " height="114" src="image/B18115_Fig_2.5.jpg" width="918"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Verify the installation</p>
<p>You can also use the <strong class="source-inline">kubectl describe</strong> command to get the details of the node as follows: </p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="Figure 2.6 – The describe command used on a node " height="565" src="image/B18115_Fig_2.6.jpg" width="1147"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – The describe command used on a node</p>
<p>At this point, you have a fully<a id="_idIndexMarker099"/> functional Kubernetes cluster. To summarize, we have installed MicroK8s and verified whether the installation was successful or not. In the next section, we are going to deploy a sample application on the MicroK8s cluster.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/>Deploying a sample application</h1>
<p>We are going to deploy the <strong class="source-inline">nginx</strong> web server sample<a id="_idIndexMarker100"/> application. It is software that responds<a id="_idIndexMarker101"/> to client requests via <strong class="bold">HTTP</strong> (<strong class="bold">Hypertext Transfer Protocol</strong>). The following command will deploy the <strong class="source-inline">nginx</strong> web application:</p>
<p class="source-code">kubectl create deployment nginx --image=nginx</p>
<p>The following command execution output indicates that there is no error in the deployment, and in the next steps, we can verify whether the Pods have been created:</p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<img alt="Figure 2.7 – Create the deployment " height="100" src="image/B18115_Fig_2.7.jpg" width="995"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Create the deployment</p>
<p>Check the <strong class="source-inline">pods</strong> status to verify whether the application<a id="_idIndexMarker102"/> has been deployed and is running:</p>
<p class="source-code">kubectl get pods</p>
<p>The following command execution output indicates that Pods have been created and in the <strong class="source-inline">Running</strong> status:</p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<img alt="Figure 2.8 – Check the status of the deployment " height="115" src="image/B18115_Fig_2.8.jpg" width="994"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Check the status of the deployment</p>
<p>The <strong class="source-inline">nginx</strong> application has been deployed successfully, so it can be exposed with the following command:</p>
<p class="source-code">kubectl expose deployment nginx \</p>
<p class="source-code">--port 80 \</p>
<p class="source-code">--target-port 80 \</p>
<p class="source-code">--type ClusterIP \</p>
<p class="source-code">--selector=run=nginx \</p>
<p class="source-code">--name nginx</p>
<p>The following command execution output indicates that the <strong class="source-inline">nginx</strong> application is exposed successfully:</p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<img alt="Figure 2.9 – Expose the deployment " height="241" src="image/B18115_Fig_2.9.jpg" width="835"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Expose the deployment</p>
<p>You should see a new service <a id="_idIndexMarker103"/>and the <strong class="source-inline">ClusterIP</strong> address assigned:</p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<img alt="Figure 2.10 – get svc and the ClusterIP address " height="153" src="image/B18115_Fig_2.10.jpg" width="1115"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – get svc and the ClusterIP address</p>
<p>Now that services are exposed externally, we can launch the web browser and point it to the external IP from our local machine to access the <strong class="source-inline">nginx</strong> application:</p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<img alt="Figure 2.11 – The nginx landing page " height="271" src="image/B18115_Fig_2.11.jpg" width="921"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – The nginx landing page</p>
<p>Congratulations! You have now deployed the <strong class="source-inline">nginx</strong> application to a fully functional Kubernetes cluster <a id="_idIndexMarker104"/>by using MicroK8s. This will help you to understand how MicroK8s gets you up and running in under 60 seconds. In the next section, we are going to learn about add-ons and how to enable them.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>Enabling add-ons</h1>
<p>To provide a pure, lightweight version<a id="_idIndexMarker105"/> of Kubernetes, MicroK8s uses the bare minimum of components. With only a few keystrokes, <strong class="bold">add-ons</strong>, which are pre-packaged components that provide additional capabilities for your Kubernetes cluster, from simple DNS control to ML with Kubeflow, are accessible.</p>
<p>To begin, the DNS add-on should be enabled to promote communication between services. The storage add-on provides directory space on the host for programs that require storage.</p>
<p>These are easy to set up with the following command:</p>
<p class="source-code">microk8s enable dns storage</p>
<p>The command execution output is as follows: </p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<img alt="Figure 2.12 – Enable DNS and storage add-ons " height="577" src="image/B18115_Fig_2.12.jpg" width="1014"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Enable DNS and storage add-ons</p>
<p>For the full list of available<a id="_idIndexMarker106"/> MicroK8s add-ons, please refer to the <em class="italic">Full list of add-ons</em> section.</p>
<p>Once the add-on is enabled, check whether all the components for the additional services can be started using the following command:</p>
<p class="source-code">kubectl get all --all-namespaces</p>
<p>The following command execution output indicates (in the highlighted portions) that additional services have been started and are in <strong class="source-inline">Running</strong> status:</p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 2.13 – Verify that additional components have been started " height="204" src="image/B18115_Fig_2.13.jpg" width="1331"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Verify that additional components have been started</p>
<p>Add-ons that have been enabled can be disabled at any time by utilizing the <strong class="source-inline">disable</strong> command:</p>
<p class="source-code">microk8s disable dns</p>
<p>To check the list of available<a id="_idIndexMarker107"/> and installed addons, use the <strong class="source-inline">status</strong> command, as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 2.14 – Use the status command to check the list of available and installed add-ons " height="468" src="image/B18115_Fig_2.14.jpg" width="896"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Use the status command to check the list of available and installed add-ons</p>
<p>In case of errors, MicroK8s gives you troubleshooting tools to check out what has gone wrong. In the following sections, we can check how to use troubleshooting tools.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Full list of add-ons</h2>
<p>The following table shows the current list <a id="_idIndexMarker108"/>of add-ons at the time of writing:</p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Table 2.1 – The complete list of MicroK8s add-ons " height="721" src="image/B18115_02_Table_2.1a.jpg" width="1600"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="Table 2.1 – The complete list of MicroK8s add-ons " height="1777" src="image/B18115_02_Table_2.1b.jpg" width="1646"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – The complete list of MicroK8s add-ons</p>
<p>We have now understood<a id="_idIndexMarker109"/> what an add-on is, and we have enabled a few add-ons, such as <strong class="source-inline">dns</strong> and <strong class="source-inline">storage</strong>. We've also seen the entire list of add-ons. In the next section, we will look at how to start/stop a MicroK8s cluster.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/>Starting/stopping MicroK8s</h1>
<p>MicroK8s will run<a id="_idIndexMarker110"/> indefinitely unless you instruct it to <strong class="bold">stop</strong>. With these simple<a id="_idIndexMarker111"/> commands, you can <em class="italic">stop and start</em> MicroK8s.</p>
<p>To stop a MicroK8s cluster, use the <strong class="source-inline">microk8s stop</strong> command:</p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<img alt="Figure 2.15 – Use the stop command to stop the MicroK8s cluster " height="105" src="image/B18115_Fig_2.15.jpg" width="852"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Use the stop command to stop the MicroK8s cluster</p>
<p>To start the MicroK8s cluster, use the <strong class="source-inline">microk8s start</strong> command:</p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 2.16 – Use the start command to start the MicroK8s cluster " height="75" src="image/B18115_Fig_2.16.jpg" width="691"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Use the start command to start the MicroK8s cluster</p>
<p>MicroK8s will automatically restart after a reboot if you keep it running. If you don't want this to happen, simply run <strong class="source-inline">microk8s stop</strong> before turning off the computer. </p>
<p>We've seen how to start<a id="_idIndexMarker112"/> and stop<a id="_idIndexMarker113"/> a MicroK8s cluster. In the following section, we'll look at how to configure MicroK8s to work with local images.</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/>Configuring MicroK8s to use local images</h1>
<p>The <strong class="bold">Kubernetes orchestration framework</strong> uses container<a id="_idIndexMarker114"/> images to manage<a id="_idIndexMarker115"/> containerized applications. These images<a id="_idIndexMarker116"/> can be in a local filesystem or can be downloaded from a remote registry. The most<a id="_idIndexMarker117"/> popular container tool is <strong class="bold">Docker</strong>. The following diagram is an introduction to what Docker does:</p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 2.17 – What Docker does " height="321" src="image/B18115_Fig_2.17.jpg" width="1557"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – What Docker does</p>
<p>Let's suppose we have a container image built and available in the local Docker image repository. For example, here, I have the <strong class="source-inline">nginx1.21</strong> image in the local Docker image repository:</p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 2.18 – Docker images from the local Docker repository " height="141" src="image/B18115_Fig_2.18.jpg" width="835"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Docker images from the local Docker repository</p>
<p>The <strong class="source-inline">nginx1.21</strong> local image is only recognized by Docker, and MicroK8s Kubernetes will not be aware of the image. This is because<a id="_idIndexMarker118"/> the MicroK8s Kubernetes cluster<a id="_idIndexMarker119"/> does not include your local Docker <em class="italic">daemon</em>. We can push the Docker image into the MicroK8s image cache by exporting it from the local Docker daemon using the following command:</p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<img alt="Figure 2.19 – Push the Docker image " height="136" src="image/B18115_Fig_2.19.jpg" width="1347"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Push the Docker image</p>
<p>Now that we have imported the image to the MicroK8s image cache, we can confirm whether the image is in there by using the following command:</p>
<p class="source-code">microk8s ctr images ls</p>
<p>The following command execution output shows that our <strong class="source-inline">nginx1.21</strong> image is available in the MicroK8s image cache:</p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 2.20 – The list of containerd images " height="128" src="image/B18115_Fig_2.20.jpg" width="1136"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – The list of containerd images</p>
<p>Now that we have the image, we can use the <strong class="source-inline">microk8s kubectl apply -f &lt;file&gt;</strong> command to deploy it to the MicroK8s Kubernetes.</p>
<p>Here, I have created the <strong class="source-inline">nginx.local</strong> file with the deployment instructions:</p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<img alt="Figure 2.21 – The nginx.local file with the deployment instructions " height="493" src="image/B18115_Fig_2.21.jpg" width="803"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21 – The nginx.local file with the deployment instructions</p>
<p>At this point, we<a id="_idIndexMarker120"/> are ready to deploy<a id="_idIndexMarker121"/> using the <strong class="source-inline">kubectl apply</strong> command:</p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Figure 2.22 – Create the deployment using the apply command " height="72" src="image/B18115_Fig_2.22.jpg" width="697"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22 – Create the deployment using the apply command</p>
<p>When the deployment<a id="_idIndexMarker122"/> is created, use the <strong class="source-inline">kubectl get deployment</strong> command to check the status<a id="_idIndexMarker123"/> of the deployments:</p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 2.23 – Check the status of the deployment " height="113" src="image/B18115_Fig_2.23.jpg" width="704"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.23 – Check the status of the deployment</p>
<p>The following fields are displayed:</p>
<ul>
<li><strong class="source-inline">NAME</strong> indicates the names of the deployments in the namespace.</li>
<li><strong class="source-inline">READY</strong> indicates how many replicas of the application are available to the users of the applications.</li>
<li><strong class="source-inline">UP-TO-DATE</strong> indicates the number of replicas that have been updated to achieve the desired state.</li>
<li><strong class="source-inline">AVAILABLE</strong> indicates the number of replicas that are available to the users.</li>
<li><strong class="source-inline">AGE</strong> indicates the amount of time that the application has been operating.</li>
</ul>
<p>Kubernetes will act as if there is an image in the Docker Hub registry at <strong class="source-inline">docker.io</strong> for which it already has a cached copy. This procedure can be repeated whenever the image is changed.</p>
<p>We have now seen how to work with locally built images without a registry. In the next section, we are going to look at how to use MicroK8s' built-in registry for the management of images.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/>Configuring MicroK8s to use its built-in registry</h1>
<p>By minimizing the time<a id="_idIndexMarker124"/> spent on uploading and downloading Docker<a id="_idIndexMarker125"/> images, having a private Docker registry can help you to be more productive. The registry that comes with MicroK8s is hosted inside a Kubernetes cluster and is accessible as a <strong class="source-inline">NodePort</strong> service on the localhost's port <strong class="source-inline">32000</strong>. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">You should be aware that this registry is not secured and will need additional steps to limit access from outside (in the case of production scenarios).</p>
<p>The first step is to enable the built-in registry using the following command:</p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 2.24 – Enable the registry " height="269" src="image/B18115_Fig_2.24.jpg" width="728"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.24 – Enable the registry</p>
<p>As you can see, the registry <a id="_idIndexMarker126"/>add-on has been set up with a 40 Gi persistent volume claim for storing images. Please note that the storage add-on is also enabled along with the registry to enable storage claims.</p>
<p>Now that we have the registry set up, our next step is to tag the image and push it into the built-in registry:</p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 2.25 – Tag the Docker image " height="26" src="image/B18115_Fig_2.25.jpg" width="945"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.25 – Tag the Docker image</p>
<p>Push the tagged image into the built-in image, as shown here: </p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 2.26 – Push the tagged image " height="221" src="image/B18115_Fig_2.26.jpg" width="1118"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.26 – Push the tagged image</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Pushing to this insecure registry<a id="_idIndexMarker127"/> may fail in some Docker versions unless the daemon is specifically set to trust it.</p>
<p class="callout">Add the registry endpoint (as shown in the following snippet) in <strong class="source-inline">/etc/docker/daemon.json</strong> and restart the Docker daemon:</p>
<p class="callout"><strong class="source-inline">{</strong></p>
<p class="callout"><strong class="source-inline">  "insecure-registries" : ["localhost:32000"]</strong></p>
<p class="callout"><strong class="source-inline">}</strong></p>
<p>Let's check<a id="_idIndexMarker128"/> whether<a id="_idIndexMarker129"/> the images are tagged by using the <strong class="source-inline">docker images</strong> command:</p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 2.27 – Check whether the images are tagged " height="155" src="image/B18115_Fig_2.27.jpg" width="829"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.27 – Check whether the images are tagged</p>
<p>Now that we have the image, we<a id="_idIndexMarker130"/> can use the <strong class="source-inline">kubectl apply -f &lt;file&gt;</strong> command to deploy<a id="_idIndexMarker131"/> it to the MicroK8s Kubernetes.</p>
<p>Here, I have created the <strong class="source-inline">nginx.builtin</strong> file with the deployment instructions:</p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 2.28 – The nginx.builtin file with the deployment instructions " height="458" src="image/B18115_Fig_2.28.jpg" width="570"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.28 – The nginx.builtin file with the deployment instructions</p>
<p>At this point, we are ready to deploy using the <strong class="source-inline">kubectl apply</strong> command:</p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 2.29 – Create the deployment using the apply command " height="68" src="image/B18115_Fig_2.29.jpg" width="723"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.29 – Create the deployment using the apply command</p>
<p>When the deployment is created, use the <strong class="source-inline">kubectl get deployment</strong> command to check the status of the deployments:</p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 2.30 – Check the status of the deployments using the kubectl get deployment command " height="126" src="image/B18115_Fig_2.30.jpg" width="832"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.30 – Check the status of the deployments using the kubectl get deployment command</p>
<p>Kubernetes will pull the image from<a id="_idIndexMarker132"/> the built-in registry. If there is a change<a id="_idIndexMarker133"/> to the image, <em class="italic">building</em> and <em class="italic">pushing</em> the images to the built-in registry can be repeated so that updates are propagated. If you've dedicated machines that host registries in a cluster, you'll need to alter the configuration files to point to the node's IP address.</p>
<p>In the next section, we will go through the steps on how to configure MicroK8s to pull the images from any of the public or private registries.</p>
<h1 id="_idParaDest-43">Configuring MicroK8s to use private/public <a id="_idTextAnchor043"/>registries</h1>
<p>MicroK8s can pull the images from <em class="italic">private</em> or <em class="italic">public</em> registries as well, but before being able to pull container<a id="_idIndexMarker134"/> images, MicroK8s Kubernetes must be made aware<a id="_idIndexMarker135"/> of the registry <a id="_idTextAnchor044"/>endpoints.</p>
<p>Let's assume that a <strong class="bold">private registry</strong> is set up<a id="_idIndexMarker136"/> at some IP address, such as <strong class="source-inline">10.131.231.155</strong>. The images we build need to be<a id="_idIndexMarker137"/> tagged with the <strong class="source-inline">IP address:Port/image:tag</strong> registry endpoint syntax, as follows:</p>
<pre class="source-code">docker build . -t 10.131.231.155:32000/nginx1.21:registry</pre>
<p class="callout-heading">Important Note</p>
<p class="callout">Pushing to this insecure registry<a id="_idIndexMarker138"/> may fail in some Docker versions unless the daemon is specifically set to trust it. Add the registry endpoint (as shown in the following snippet) to <strong class="source-inline">/etc/docker/daemon.json</strong> and restart the Docker daemon:</p>
<p class="callout"><strong class="source-inline">{</strong></p>
<p class="callout"><strong class="source-inline">  "insecure-registries" : ["10.131.231.155:32000"]</strong></p>
<p class="callout"><strong class="source-inline">}</strong></p>
<p>To push it<a id="_idIndexMarker139"/> to one of the <strong class="bold">public registries</strong> such as <strong class="source-inline">hub.docker.com</strong>, use the <strong class="source-inline">docker login</strong> command to log<a id="_idIndexMarker140"/> in and push the image<a id="_idIndexMarker141"/> tagged with <strong class="source-inline">docker-hub-username/image-name:tag</strong>:</p>
<p class="source-code">docker tag 87a94228f133 10.131.231.155:32000/nginx1.21:registry</p>
<p>Once the image is tagged, push the tagged image into a private or public registry:</p>
<p class="source-code">docker push 10.131.231.155:32000/nginx1.21:registry</p>
<p>Now that we have the image, we can use the <strong class="source-inline">kubectl apply -f &lt;file&gt;</strong> command to deploy like earlier. Here, I have created a file with the deployment instructions:</p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 2.31 – The deployment file with instructions " height="474" src="image/B18115_Fig_2.31.jpg" width="772"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.31 – The deployment file with instructions</p>
<p>Once the deployment<a id="_idIndexMarker142"/> is created, use the <strong class="source-inline">kubectl get deployment</strong> command<a id="_idIndexMarker143"/> to check the<a id="_idIndexMarker144"/> status of the<a id="_idIndexMarker145"/> deployments.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">In the <em class="italic">production</em> scenarios, a <strong class="bold">private secure registry</strong> needs to be used, which is more secure and limits<a id="_idIndexMarker146"/> access to specific users/applications. The recommended way is to create a secret from the Docker login credentials and use this secret to access the secure registry.</p>
<p>To recap, we looked<a id="_idIndexMarker147"/> at how to set up MicroK8s using either local images<a id="_idIndexMarker148"/> or ones fetched from public<a id="_idIndexMarker149"/> or private registries. In the next<a id="_idIndexMarker150"/> section, we will look at how to configure the various services or components of MicroK8s.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor045"/>Configuring MicroK8s services</h1>
<p>MicroK8s is made up of various services<a id="_idIndexMarker151"/> or components that are managed by a number of system daemons. Configuration of these services is read from files stored in the <strong class="source-inline">$SNAP_DATA</strong> directory, which normally points to <strong class="source-inline">/var/snap/microk8s/current</strong>.</p>
<p>To reconfigure the services, we will need to edit the respective file and then restart the respective daemon. The following table shows <em class="italic">system daemon services</em> that will be run by MicroK8s: </p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Table 2.2 – A list of the MicroK8s system daemon services " height="1404" src="image/B18115_02_Table_2.2a.jpg" width="1642"/>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Table 2.2 – A list of the MicroK8s system daemon services " height="1575" src="image/B18115_02_Table_2.2b.jpg" width="1649"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2 – A list of the MicroK8s system daemon services</p>
<p>In the next section, we will<a id="_idIndexMarker152"/> look at how to troubleshoot issues at the application and cluster levels.</p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/>Troubleshooting application and cluster issues</h1>
<p>It's critical to know that things<a id="_idIndexMarker153"/> can go wrong; there might be issues with the Kubernetes<a id="_idIndexMarker154"/> components themselves, or a problem with the MicroK8s component. In this section, we will cover some of the common issues and tools to assist you in determining what went wrong. </p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>The application level</h2>
<p>This section assists<a id="_idIndexMarker155"/> users in debugging Kubernetes-deployed applications that aren't functioning as intended. </p>
<p>Examining a <strong class="bold">Pod</strong> is the first step in<a id="_idIndexMarker156"/> troubleshooting it. With the following command, you can check the current state of the Pod and a historical list of the events:</p>
<p class="source-code">kubectl describe pods ${POD_NAME}</p>
<p>In the following command execution output, you can see that the <strong class="source-inline">kubectl describe pod</strong> command fetches the details of the container(s) and the Pod's configuration information (labels, resource needs, and so on), as well as the container(s) and Pod's status information (state, readiness, restart count, events, and so on):</p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 2.32 – Troubleshooting with the kubectl describe pods command " height="577" src="image/B18115_Fig_2.32.jpg" width="1004"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.32 – Troubleshooting with the kubectl describe pods command</p>
<p>The following table summarizes all the possible issues and solutions based on the Pod state from the previously described command:</p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Table 2.3 – Examining the Pod status for possible issues " height="1013" src="image/B18115_02_Table_2.3.jpg" width="1536"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.3 – Examining the Pod status for possible issues</p>
<p>We've looked at how to infer application<a id="_idIndexMarker157"/> issues from the Pod status information; in the following part, we'll look at it at the cluster level.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>The cluster level</h2>
<p>To get detailed information<a id="_idIndexMarker158"/> about the overall health of a MicroK8s cluster, you can run the following command:</p>
<p class="source-code">microk8s kubectl cluster-info dump</p>
<p>By default, this command dumps all the information about the cluster to the output for debugging and diagnosing cluster problems. It also dumps the logs of all the Pods in the cluster, which are split into directories by namespace and Pod name.</p>
<p>Kubernetes also generates events whenever any of the resources it manages undergoes a change. The entity that initiated the event, the type of event (<strong class="source-inline">Normal</strong>, <strong class="source-inline">Warning</strong>, <strong class="source-inline">Error</strong>, and so on), and the cause are generally included in these events. This data is typically stored in <strong class="source-inline">etcd</strong> and made available when you run <strong class="source-inline">kubectl events</strong> commands. </p>
<p>These events provide insight into what occurred behind the scenes when a specific entity entered a particular state:</p>
<p class="source-code">microk8s kubectl get events</p>
<p>MicroK8s also has a built-in inspection tool to generate a comprehensive report on the status of MicroK8s subsystems and the machine they run on. By running the tool, we can verify whether the system is working or not, and it also gathers all the important data for bug reporting:</p>
<p class="source-code">sudo microk8s inspect</p>
<p>Administrator privileges are required to run this tool and gather the data:</p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 2.33 – The MicroK8s inspection tool " height="500" src="image/B18115_Fig_2.33.jpg" width="693"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.33 – The MicroK8s inspection tool</p>
<p>We recognized that things may go wrong; there can be issues with the application, Kubernetes<a id="_idIndexMarker159"/> components, or the MicroK8s component. We've looked at how to diagnose problems and picked up a few tools to help us with our debugging.</p>
<p>If you are unable to resolve your problem and feel it is due to a bug in MicroK8s, please submit an issue to the project repository at the following link: <a href="https://github.com/ubuntu/microk8s/issues/">https://github.com/ubuntu/microk8s/issues/</a>.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/>Summary</h1>
<p>To summarize, we learned how to install MicroK8s, check the progress of the installation, and monitor and control a Kubernetes cluster in this chapter. We learned how to install a sample application and use some of the add-ons as well. </p>
<p>We also learned how to use MicroK8s with local container images as well as images retrieved from public and private registries. Furthermore, we investigated the inspection tool that creates a complete report on MicroK8s and the system it runs on, as well as walked through common issues to assist in fixing the most frequently encountered problems.</p>
<p>The key concepts of <em class="italic">edge computing</em> will be introduced in the next chapter. We'll also look at some of the things to keep in mind when you develop your edge architecture.</p>
</div>
</div>


<div id="sbo-rt-content"><div class="Content" id="_idContainer054">
<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Part 2: Kubernetes as the Preferred Platform for IoT and Edge Computing</h1>
<p>Data volumes continue to grow, particularly in industries such as manufacturing, oil and gas, energy, and transportation that are undergoing rapid digital transformation. There is a need to manage this data explosion at the edge and the many associated challenges, including the complexity of systems, data privacy, latency issues, low bandwidth connectivity, and increasing costs for storing and processing data, either in the cloud or data centers. In this part, we will look at how Kubernetes, the edge, and the cloud can collaborate to drive intelligent business decisions.</p>
<p>This part of the book comprises the following chapters:</p>
<ul>
<li><a href="B18115_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Essentials of IoT and Edge Computing</em></li>
<li><a href="B18115_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Handling the Kubernetes Platform for IoT and Edge Computing</em></li>
</ul>
</div>
</div>
</body></html>