<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-175" class="chapter-number"><a id="_idTextAnchor222"/>9</h1>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor223"/>Testing Helm Charts</h1>
			<p>Testing is a common task that engineers must perform during software development. Testing is performed to validate the functionality of a product, as well as to prevent regressions as a product evolves. Well-tested software is easier to maintain and allows developers to confidently provide new releases to end users.</p>
			<p>A Helm chart should be tested properly to ensure that it delivers its features to the level of quality expected. In this chapter, we will discuss the ways that testing can be applied to Helm charts to verify the expected capabilities. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up your environment</li>
				<li>Verifying Helm templating</li>
				<li>Testing in a live cluster</li>
				<li>Improving chart tests with the Chart Testing tool</li>
				<li>Cleaning up</li>
			</ul>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor224"/>Technical requirements</h1>
			<p>For this chapter, you will need the following:</p>
			<ul>
				<li><strong class="source-inline">minikube</strong></li>
				<li><strong class="source-inline">kubectl</strong></li>
				<li><strong class="source-inline">helm</strong></li>
				<li><strong class="source-inline">git</strong></li>
				<li><strong class="source-inline">yamllint</strong></li>
				<li><strong class="source-inline">yamale</strong></li>
				<li><strong class="source-inline">ct</strong> (chart-testing)</li>
			</ul>
			<p>Additionally, you should clone the Packt GitHub repository locally: $ git clone <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git</a>.</p>
			<p>In this chapter, we will use our <strong class="source-inline">minikube</strong> environment extensively throughout the scenarios. In the next section, you will set up the environment.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor225"/>Setting up your environment</h1>
			<p>Run the <a id="_idIndexMarker506"/>following steps to set up your <strong class="source-inline">minikube</strong> environment:</p>
			<ol>
				<li>Start <strong class="source-inline">minikube</strong> by running the <strong class="source-inline">minikube start</strong> command:<p class="source-code"><strong class="bold">$ minikube start</strong></p></li>
				<li>Then, create a new namespace called <strong class="source-inline">chapter9</strong>:<p class="source-code"><strong class="bold">$ kubectl create namespace chapter9</strong></p></li>
			</ol>
			<p>With your <strong class="source-inline">minikube</strong> environment ready, let’s begin by discussing how Helm charts can be tested. We will begin the discussion by outlining the methods you can use to verify your Helm templates.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor226"/>Verifying Helm templating</h1>
			<p>One of the <a id="_idIndexMarker507"/>primary purposes of Helm is to create <strong class="bold">Kubernetes</strong> resources. As <a id="_idIndexMarker508"/>a result, when developing and testing a Helm chart, you should ensure that your resources are being generated properly. This can be accomplished using a variety of methods. We will discuss these in the next section.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor227"/>Validating template generation locally with helm template</h2>
			<p>The first <a id="_idIndexMarker509"/>way to validate <a id="_idIndexMarker510"/>the templating of your chart is to use the <strong class="source-inline">helm template</strong> command. We first introduced this command in <a href="B17979_06.xhtml#_idTextAnchor167"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Helm Templates</em>. In this chapter, we will describe using the <strong class="source-inline">helm template</strong> command to render a chart’s templates locally.</p>
			<p>The <strong class="source-inline">helm template</strong> command has the following syntax:</p>
			<p class="source-code">$ helm template [NAME] [CHART] [flags]</p>
			<p>You can see this command in action by demonstrating it against the Helm chart located in <strong class="source-inline">chapter9/guestbook</strong> in the Packt repository:</p>
			<p class="source-code">$ helm template my-guestbook guestbook</p>
			<p>The result <a id="_idIndexMarker511"/>of this command <a id="_idIndexMarker512"/>will display each of the Kubernetes resources that would be created if they were applied to the cluster, as shown here:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/Figure_9.01_B17979.jpg" alt="Figure 9.1 – The helm template output&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The helm template output</p>
			<p>The preceding output displays the beginning portion of the <strong class="source-inline">helm template</strong> output. As you can see, a fully rendered <strong class="source-inline">ServiceAccount</strong> is shown, along with the beginning of another <strong class="source-inline">ServiceAccount</strong> that would be created with a release. Rendering these resources allows you to understand how the resources would be created if the release was installed against a Kubernetes cluster.</p>
			<p>During <a id="_idIndexMarker513"/>chart development, you may want to use the <strong class="source-inline">helm template</strong> command regularly to validate <a id="_idIndexMarker514"/>that your Kubernetes resources are being generated properly.</p>
			<p>Some common <a id="_idIndexMarker515"/>aspects of chart development that you may want to validate throughout are as follows:</p>
			<ul>
				<li>Parameterized fields are successfully replaced by default or overridden values</li>
				<li>Control structures such as <strong class="source-inline">if</strong>, <strong class="source-inline">range</strong>, and <strong class="source-inline">with</strong> successfully generate YAML based on the provided values.</li>
				<li>Resources contain proper spacing and indentation.</li>
				<li>Functions and pipelines are used correctly to properly format and manipulate YAML.</li>
				<li>Input validation mechanisms such as the <strong class="source-inline">required</strong> and <strong class="source-inline">fail</strong> functions or the <strong class="source-inline">values.schema.json</strong> file properly validate values based on user input.</li>
				<li>Dependencies have been declared properly and their resource definitions appear in the <strong class="source-inline">helm template</strong> output.</li>
			</ul>
			<p>In the next section, we will discuss how server-side validation can be enabled when rendering your resources with <strong class="source-inline">helm template</strong>.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor228"/>Adding server-side validation to chart rendering</h2>
			<p>While the <strong class="source-inline">helm template</strong> command is important to the chart development process and <a id="_idIndexMarker516"/>should be used <a id="_idIndexMarker517"/>frequently to verify your chart <a id="_idIndexMarker518"/>rendering, it does have a key limitation. The main purpose of the <strong class="source-inline">helm template</strong> command is to provide client-side rendering, meaning it does not communicate with the Kubernetes API server to provide resource validation. If you would like to ensure that your resources are valid after they have been generated, you can use the <strong class="source-inline">--validate</strong> flag to instruct <strong class="source-inline">helm template</strong> to communicate with the Kubernetes API server:</p>
			<p class="source-code">$ helm template my-release &lt;chart_name&gt; --validate</p>
			<p>With the <strong class="source-inline">--validate</strong> flag specified, any generated template that does not produce a valid Kubernetes resource emits an error message. Imagine, for example, a deployment template was used with the incorrect <strong class="source-inline">apiVersion</strong>. What may appear to be valid locally would be incorrect when applying the <strong class="source-inline">--validate</strong> flag. Here’s an example error message that Kubernetes could throw with invalid content that was triggered through the use of the <strong class="source-inline">--validate</strong> flag:</p>
			<pre class="source-code">
Error: unable to build kubernetes objects from release manifest: unable to recognize "": no matches for kind "Deployment" in version "v1"</pre>
			<p>While <strong class="source-inline">helm template</strong> does provide server-side validation capabilities with the <strong class="source-inline">--validate</strong> flag, it is not the only way to determine if your chart is generating valid Kubernetes <a id="_idIndexMarker519"/>resources. As <a id="_idIndexMarker520"/>an alternative approach, you <a id="_idIndexMarker521"/>can apply the <strong class="source-inline">--dry-run</strong> flag against the <strong class="source-inline">install</strong>, <strong class="source-inline">upgrade</strong>, <strong class="source-inline">rollback</strong>, and <strong class="source-inline">uninstall</strong> commands. Here is an example of using this flag with the <strong class="source-inline">install</strong> command:</p>
			<p class="source-code">$ helm install my-chart &lt;chart_name&gt; --dry-run</p>
			<p>The <strong class="source-inline">--dry-run</strong> flag is primarily used by end users to perform a sanity check before running an installation. This helps ensure that values have been provided properly and that the installation will produce the desired results. It is a good <em class="italic">last line of defense</em> that can be used to verify that errors will not be thrown before you execute the associated command.</p>
			<p>While it is necessary to verify that templates are generated the way you intend, it is also important to perform linting to ensure that Helm charts and generated resources follow best formatting practices. There are a couple of ways to accomplish this goal. Let’s take a look.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor229"/>Linting Helm charts and templates</h2>
			<p>Linting a <a id="_idIndexMarker522"/>Helm chart involves two high-level steps:</p>
			<ol>
				<li value="1">Ensuring that a Helm chart is valid</li>
				<li>Ensuring that a Helm chart follows consistent formatting practices</li>
			</ol>
			<p>To ensure that a Helm chart is valid, we can use the <strong class="source-inline">helm lint</strong> command, which has the following syntax:</p>
			<p class="source-code">$ helm lint &lt;chart-name&gt; [flags]</p>
			<p>The <strong class="source-inline">helm lint</strong> command is used to validate the <strong class="source-inline">Chart.yaml</strong> file and ensure that the Helm chart does not contain any breaking issues. Note that this command does not validate rendered resources or perform YAML style linting.</p>
			<p>You can run the <strong class="source-inline">helm lint</strong> command against the <strong class="source-inline">guestbook</strong> chart located in the Packt repository, as shown here:</p>
			<p class="source-code">$ helm lint chapter9/guestbook</p>
			<p class="source-code">==&gt; Linting chapter9/guestbook</p>
			<p class="source-code">[INFO] Chart.yaml: icon is recommended</p>
			<p class="source-code">1 chart(s) linted, 0 chart(s) failed</p>
			<p>The preceding output shows that the chart is valid, noted by the <strong class="source-inline">0 chart(s) failed</strong> message. The <strong class="source-inline">[INFO]</strong> message reported that the icon field in the <strong class="source-inline">Chart.yaml</strong> file is recommended, but not required. Other types of messages include <strong class="source-inline">[WARNING]</strong>, which indicates that the chart breaks conventions, and <strong class="source-inline">[ERROR]</strong>, which indicates that the chart will fail at installation.</p>
			<p>Let’s run through several examples to illustrate each potential outcome. Consider the chart in <strong class="source-inline">chapter9/no-chart-yaml</strong>, which contains the following file structure:</p>
			<pre class="source-code">
no-chart-yaml/
  templates/
  Values.yaml</pre>
			<p>As you can probably guess from the name, this chart is missing a <strong class="source-inline">Chart.yaml</strong> definition file. When we run <strong class="source-inline">helm lint</strong> over this chart, we get an error:</p>
			<p class="source-code">$ helm lint chapter9/no-chart-yaml</p>
			<p class="source-code">==&gt; Linting chapter9/no-chart-yaml</p>
			<p class="source-code">Error unable to check Chart.yaml file in chart: stat chapter9/no-chart-yaml/Chart.yaml: no such file or directory</p>
			<p class="source-code">Error: 1 chart(s) linted, 1 chart(s) failed</p>
			<p>This error indicates that Helm cannot find the <strong class="source-inline">Chart.yaml</strong> file, resulting in an invalid chart.</p>
			<p>We can see <a id="_idIndexMarker523"/>different errors if we add an empty <strong class="source-inline">Chart.yaml</strong> file. Let’s run <strong class="source-inline">helm lint</strong> on the <strong class="source-inline">chapter9/empty-chart-yaml</strong> chart:</p>
			<p class="source-code">$ helm lint chapter9/empty-chart-yaml</p>
			<p class="source-code">==&gt; Linting chapter9/empty-chart-yaml</p>
			<p class="source-code">[ERROR] Chart.yaml: name is required</p>
			<p class="source-code">[ERROR] Chart.yaml: apiVersion is required. The value must be either "v1" or "v2"</p>
			<p class="source-code">[ERROR] Chart.yaml: version is required</p>
			<p class="source-code">[INFO] Chart.yaml: icon is recommended</p>
			<p class="source-code">[ERROR] templates/: validation: chart.metadata.name is required</p>
			<p class="source-code">[ERROR] : unable to load chart</p>
			<p class="source-code">validation: chart.metadata.name is required</p>
			<p class="source-code">Error: 1 chart(s) linted, 1 chart(s) failed</p>
			<p>The output lists each of the required fields that are missing from the <strong class="source-inline">Chart.yaml</strong> file.</p>
			<p>The linter will also check for the existence of other files, such as the <strong class="source-inline">values.yaml</strong> file and the <strong class="source-inline">templates</strong> directory. It also ensures that files under the <strong class="source-inline">templates</strong> directory have valid <strong class="source-inline">.yaml</strong>, <strong class="source-inline">.yml</strong>, <strong class="source-inline">.tpl</strong>, or <strong class="source-inline">.txt</strong> file extensions.</p>
			<p>The <strong class="source-inline">helm lint</strong> command is great for checking whether your chart contains the appropriate contents, but it does not carry out exhaustive linting of your chart’s YAML style. To perform this type of linting, you can use another tool called <strong class="source-inline">yamllint</strong>, which can be found at <a href="https://github.com/adrienverge/yamllint">https://github.com/adrienverge/yamllint</a>. This tool can be installed using the <strong class="source-inline">pip3 (or pip)</strong> package manager across a range of operating systems by using the following command:</p>
			<p class="source-code">$ pip3 install yamllint –user</p>
			<p>It can also <a id="_idIndexMarker524"/>be installed with your system’s package manager, as described in the <strong class="source-inline">yamllint</strong> quick-start instructions at <a href="https://yamllint.readthedocs.io/en/stable/quickstart.html">https://yamllint.readthedocs.io/en/stable/quickstart.html</a>.</p>
			<p>To use <strong class="source-inline">yamllint</strong> on your chart’s resources, you must use it in combination with the <strong class="source-inline">helm template</strong> command to feed the output of the rendered templates as input to <strong class="source-inline">yamllint</strong>. Let’s run <strong class="source-inline">yamllint</strong> against the <strong class="source-inline">chapter9/guestbook</strong> Helm chart:</p>
			<p class="source-code">$ helm template my-guestbook chapter9/guestbook | yamllint -</p>
			<p>A snippet of the result is shown here:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_9.02_B17979.jpg" alt="Figure 9.2 – yamllint output&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – yamllint output</p>
			<p>The line numbers <a id="_idIndexMarker525"/>provided to the left reflect the entirety of the <strong class="source-inline">helm template</strong> output, which can make it difficult to determine which line from the <strong class="source-inline">yamllint</strong> output corresponds with which line from your template files. You can simplify this by redirecting the <strong class="source-inline">helm template</strong> output to determine its line numbers:</p>
			<p class="source-code">$ cat -n &lt;(helm template my-guestbook chapter9/guestbook)</p>
			<p>The <strong class="source-inline">yamllint</strong> tool performs linting against many different rules, including the following:</p>
			<ul>
				<li>Indentation</li>
				<li>Line length</li>
				<li>Trailing spaces</li>
				<li>Empty lines</li>
				<li>Comment format</li>
			</ul>
			<p>You can <a id="_idIndexMarker526"/>define your own rules by authoring them in one of the following files:</p>
			<ul>
				<li><strong class="source-inline">.yamllint</strong>, <strong class="source-inline">.yamllint.yaml</strong>, or <strong class="source-inline">.yamllint.yml</strong> in the current working directory</li>
				<li><strong class="source-inline">$XDG_CONFIG_HOME/yamllint/config</strong></li>
				<li><strong class="source-inline">~/.config/yamllint/config</strong></li>
			</ul>
			<p>An example <strong class="source-inline">.yamllint.yaml</strong> file can be found in <strong class="source-inline">chapter9/yamllint-override</strong>. Here, we have defined the following contents:</p>
			<pre class="source-code">
rules:
  indentation:
    indent-sequences: whatever</pre>
			<p>This sample creates one rule that instructs <strong class="source-inline">yamllint</strong> not to enforce any particular method of indentation.</p>
			<p>A deep dive into configuring <strong class="source-inline">yamllint</strong> rules is beyond the scope of this chapter, but you can refer to the <strong class="source-inline">yamllint</strong> documentation on the topic of rules to learn more: <a href="https://yamllint.readthedocs.io/en/stable/rules.html">https://yamllint.readthedocs.io/en/stable/rules.html</a>.</p>
			<p>In this section, we discussed how you can validate the local rendering of your Helm charts by using the <strong class="source-inline">helm template</strong>, <strong class="source-inline">helm lint</strong>, and <strong class="source-inline">yamllint</strong> commands. This, however, does not verify your chart’s functionality or the application’s ability to run properly. In the next section, we will address this topic by learning how to create tests in a live Kubernetes cluster.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor230"/>Testing in a live cluster</h1>
			<p>Understanding how to perform tests in a live Kubernetes cluster is an essential part of developing <a id="_idIndexMarker527"/>and maintaining a Helm chart. Live testing helps ensure your chart is functioning as intended and can be used to help prevent regressions as new additions are introduced to your chart over time.</p>
			<p>Testing can involve, but is not limited to, the following two different constructs:</p>
			<ul>
				<li>Readiness probes and the <strong class="source-inline">helm install --wait</strong> command</li>
				<li>Test hooks and the <strong class="source-inline">helm test</strong> command</li>
			</ul>
			<p>A readiness probe is a type of health check in Kubernetes that, upon success, marks a pod as <strong class="source-inline">Ready</strong> and makes the pod eligible to receive ingress traffic. An example of a readiness probe is located at <strong class="source-inline">chapter9/guestbook/templates/deployment.yaml</strong>: </p>
			<pre class="source-code">
readinessProbe:
  httpGet:
    path: /
    port: http</pre>
			<p>This readiness probe will mark the pod as <strong class="source-inline">Ready</strong> when an HTTP <strong class="source-inline">GET</strong> request succeeds against the <strong class="source-inline">/</strong> path.</p>
			<p>Readiness probes can be used alongside the <strong class="source-inline">–wait</strong> flag, which forces Helm to return successfully only when the probe passes. If the readiness probe times out, Helm will return exit code <strong class="source-inline">1</strong>, indicating that the installation was not successful. A timeout occurs 5 minutes after the installation begins, by default. This can be configured with the <strong class="source-inline">--timeout</strong> flag.</p>
			<p>The following is an example of invoking <strong class="source-inline">helm install</strong> with the <strong class="source-inline">--wait</strong> flag:</p>
			<p class="source-code">$ helm install my-guestbook chapter9/guestbook --wait</p>
			<p>Other commands that also support the <strong class="source-inline">--wait</strong> flag include <strong class="source-inline">upgrade</strong>, <strong class="source-inline">rollback</strong>, and <strong class="source-inline">uninstall</strong>. However, when used with <strong class="source-inline">uninstall</strong>, Helm waits for each resource to be deleted instead.</p>
			<p>Besides readiness probes, testing in Helm can also be performed by using test hooks and the <strong class="source-inline">helm test</strong> command. Test hooks are pods that perform custom tests after the Helm chart is installed to confirm they execute successfully. They are defined under the <strong class="source-inline">templates</strong> directory and contain the <strong class="source-inline">helm.sh/hook: test</strong> annotation. When the <strong class="source-inline">helm test</strong> command is run, templates with the test annotation are created and execute their defined functions.</p>
			<p>We can <a id="_idIndexMarker528"/>see an example test in <strong class="source-inline">chapter9/guestbook/templates/tests/test-connection.yaml</strong>:</p>
			<pre class="source-code">
apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "guestbook.fullname" . }}-test-connection"
  labels:
    {{- include "guestbook.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: wget
      image: busybox
      command: ['wget']
      args: ['{{ include "guestbook.fullname" . }}:{{ .Values.service.port }}']
  restartPolicy: Never</pre>
			<p>As we can see, this test attempts to make a call to the guestbook frontend.</p>
			<p>Let’s work on running this Helm test in our <strong class="source-inline">minikube</strong> environment.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor231"/>Running the chart test</h2>
			<p>To run a chart’s tests, the chart must be installed in a Kubernetes environment using the <strong class="source-inline">helm install</strong> command. Because the <strong class="source-inline">guestbook</strong> chart contains readiness probes for the <a id="_idIndexMarker529"/>frontend and Redis instances (provided by the Redis dependency), we can add the <strong class="source-inline">--wait</strong> flag to our <strong class="source-inline">helm</strong> command to block until all pods are ready. Run the following command to install the <strong class="source-inline">guestbook</strong> chart:</p>
			<p class="source-code">$ helm install guestbook chapter9/guestbook -n chapter9 –wait</p>
			<p>Once the chart has been installed, you can use the <strong class="source-inline">helm test</strong> command to execute the test life cycle hook. The syntax for the <strong class="source-inline">helm test</strong> command is as follows:</p>
			<p class="source-code">helm test [RELEASE] [flags]</p>
			<p>Run the <strong class="source-inline">helm test</strong> command against the <strong class="source-inline">guestbook</strong> release:</p>
			<p class="source-code">$ helm test guestbook –n chapter9</p>
			<p>If your test is successful, you will see the following results in the output:</p>
			<pre class="source-code">
NAME: guestbook
LAST DEPLOYED: Sun Mar 13 17:18:51 2022
NAMESPACE: chapter9
STATUS: deployed
REVISION: 1
TEST SUITE:     guestbook-test-connection
Last Started:   Sun Mar 13 17:26:00 2022
Last Completed: Sun Mar 13 17:26:03 2022
Phase:          Succeeded</pre>
			<p>When running your tests, you can also use the <strong class="source-inline">--logs</strong> flag to display the logs from your test pods. Let’s run the test again and inspect the logs by including the <strong class="source-inline">--logs</strong> flag:</p>
			<p class="source-code">$ helm test guestbook --logs –n chapter9</p>
			<p class="source-code">&lt;skipped&gt;</p>
			<p class="source-code">POD LOGS: guestbook-test-connection</p>
			<p class="source-code">Connecting to guestbook:80 (10.98.198.86:80)</p>
			<p class="source-code">saving to 'index.html'</p>
			<p class="source-code">index.html           100% |********************************|   920  0:00:00 ETA</p>
			<p class="source-code">'index.html' saved</p>
			<p>As evidenced by <a id="_idIndexMarker530"/>the logs from our test pod, our application is up and running! As a final step, you can delete your release with <strong class="source-inline">helm uninstall</strong>:</p>
			<p class="source-code">$ helm uninstall guestbook –n chapter9</p>
			<p>In this section, we ran a test hook that served as a smoke test for our chart installation. In the next section, we will discuss how the testing process can be improved by leveraging a tool called <strong class="bold">ct</strong>.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor232"/>Improving chart tests with the Chart Testing tool</h1>
			<p>The testing methods described in the previous section are sufficient enough to determine <a id="_idIndexMarker531"/>whether a Helm chart can be successfully installed. However, some key limitations are inherent to the standard Helm testing process and need to be discussed.</p>
			<p>The first <a id="_idIndexMarker532"/>limitation to consider is the difficulty of testing different permutations that can occur within a chart’s values. Because the <strong class="source-inline">helm test</strong> command does not provide the ability to modify a release’s values beyond those set at the time of an installation or upgrade, the following workflow must be followed when running <strong class="source-inline">helm test</strong> against different values:</p>
			<ol>
				<li value="1">Install your chart with an initial set of values.</li>
				<li>Run <strong class="source-inline">helm test</strong> against your release.</li>
				<li>Delete your release.</li>
				<li>Install the chart with a different set of values.</li>
				<li>Repeat <em class="italic">Step 2</em> through <em class="italic">Step 4</em> until a significant amount of value possibilities have been tested.</li>
			</ol>
			<p>Each of these manual steps poses the risk of errors. </p>
			<p>In addition to testing different value permutations, you should also make sure regressions <a id="_idIndexMarker533"/>do not occur when making <a id="_idIndexMarker534"/>modifications to your charts. The best way to prevent regressions is to include the usage of <strong class="source-inline">helm upgrade</strong> in your testing workflow:</p>
			<ol>
				<li value="1">Install the previous chart version.</li>
				<li>Upgrade your release to the newer chart version.</li>
				<li>Delete the release.</li>
				<li>Install the newer chart version.</li>
			</ol>
			<p>This workflow should be repeated against each set of values to ensure that there are no regressions or unintended breaking changes.</p>
			<p>These processes sound tedious but imagine the additional strain chart developers face when maintaining Helm chart <strong class="bold">monorepos</strong>, where multiple charts need to be tested and maintained at the same time. A repository is <a id="_idIndexMarker535"/>considered a monorepo when multiple different artifacts or modules are contained in the same repository. A monorepo design is the most common way for a chart developer or an organization to develop and maintain its charts.</p>
			<p>A Helm chart monorepo could have the following file structure:</p>
			<pre class="source-code">
helm-charts/
  guestbook/
    Chart.yaml
    templates/
    README.md
    values.yaml
 redis/         # Contains the same file structure as 'guestbook'
 wordpress/     # Contains the same file structure as 'guestbook'</pre>
			<p>Helm charts <a id="_idIndexMarker536"/>in a well-maintained monorepo <a id="_idIndexMarker537"/>should adhere to proper <strong class="bold">SemVer</strong> versioning to <a id="_idIndexMarker538"/>denote the types of changes made between releases. SemVer versions follow a <strong class="source-inline">MAJOR.MINOR.PATCH</strong> version format. Use the following list as a guideline on how to increase a SemVer version:</p>
			<ul>
				<li>Increment the <strong class="source-inline">MAJOR</strong> version if you are making a breaking change to your chart. A breaking change is a change that is not backward compatible with the previous chart version.</li>
				<li>Increment the <strong class="source-inline">MINOR</strong> version if you are adding a feature but you are not making a breaking change. You should increment this version if the change you are making is backward compatible with the previous chart version.</li>
				<li>Increment the <strong class="source-inline">PATCH</strong> version if you are making a bug fix or addressing a security vulnerability that will not result in a breaking change. This version should be incremented if the change is backward-compatible with the previous chart version.</li>
			</ul>
			<p>With the responsibilities of chart testing and versioning, it can become increasingly difficult for a Helm chart maintainer to ensure that charts are properly tested, and their versions are incremented, especially if maintaining a monorepo with multiple Helm charts. This challenge prompted the Helm community to create a tool called ct to provide structure and automation around the testing and maintenance of Helm charts. We will discuss this tool next.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor233"/>Introducing the Chart Testing project</h2>
			<p>The Chart <a id="_idIndexMarker539"/>Testing project, which can be found at <a href="https://github.com/helm/chart-testing">https://github.com/helm/chart-testing</a>, is designed to be used against charts in a Git monorepo <a id="_idIndexMarker540"/>to perform automated linting, validation, and testing. This automated testing is achieved by using Git to detect when charts have changed against a specified branch. Charts that have changed should undergo testing, while charts that were unchanged do not need to be tested.</p>
			<p>The <a id="_idIndexMarker541"/>project’s <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>), ct, provides four primary commands:</p>
			<ul>
				<li><strong class="source-inline">lint</strong>: Lints and validates charts that have been modified</li>
				<li><strong class="source-inline">install</strong>: Installs the chart in a running Kubernetes cluster and runs test hooks against charts that have been modified</li>
				<li><strong class="source-inline">lint-and-install</strong>: Combines the <strong class="source-inline">lint</strong> and <strong class="source-inline">install</strong> commands</li>
				<li><strong class="source-inline">list-changed</strong>: Lists charts that have been modified</li>
			</ul>
			<p>The <strong class="source-inline">lint-and-install</strong> command is the primary function of ct. It performs linting, installs <a id="_idIndexMarker542"/>charts in your Kubernetes cluster, and runs any test hooks that are present. It also checks whether you have increased the charts’ <strong class="source-inline">version</strong> fields in <strong class="source-inline">Chart.yaml</strong> for any chart that has been modified. This validation helps maintainers enforce proper versioning of their Helm charts.</p>
			<p>The ct tool <a id="_idIndexMarker543"/>also lets you test Helm charts against multiple different values files. During the invocation of the <strong class="source-inline">lint</strong>, <strong class="source-inline">install</strong>, and <strong class="source-inline">lint-and-install</strong> commands, ct loops through each test <strong class="source-inline">values</strong> file and performs linting and testing based on the different permutations of values provided. Test <strong class="source-inline">values</strong> files for use by ct are written under a folder called <strong class="source-inline">ci/</strong> and end with the <strong class="source-inline">values.yaml</strong> format. The following is an example Helm chart structure that includes the <strong class="source-inline">ci</strong> folder:</p>
			<pre class="source-code">
guestbook/
  Chart.yaml
  ci/
    nodeport-service-values.yaml
    ingress-values.yaml
  templates/
  values.yaml</pre>
			<p>Each <strong class="source-inline">values</strong> file under <strong class="source-inline">ci/</strong> should be named appropriately to determine the function that the values are testing. For example, <strong class="source-inline">nodeport-service-values.yaml</strong> might be used to <a id="_idIndexMarker544"/>ensure that <strong class="bold">NodePort</strong> services are configured properly, and <strong class="source-inline">ingress-values.yaml</strong> would test Ingress.</p>
			<p>The most common ct command you are likely to use is the <strong class="source-inline">lint-and-install</strong> command. When <a id="_idIndexMarker545"/>this command is running, a series of steps are executed:</p>
			<ol>
				<li value="1">Detect the charts that have been modified within the Git monorepo. Ensure that the charts’ versions have been incremented.</li>
				<li>For each chart that has been modified, lint the chart and each <strong class="source-inline">values</strong> file under the <strong class="source-inline">ci/</strong> folder.</li>
				<li>For each chart that has been modified, install the chart in the Kubernetes cluster and wait for the readiness probes to pass. Once the probes have passed, run test hooks, if present. Repeat <em class="italic">Step 3</em> for each <strong class="source-inline">values</strong> file in the <strong class="source-inline">ci/</strong> folder.</li>
				<li>Uninstall the Helm release.</li>
			</ol>
			<p>As you can see, this command performs a variety of steps to ensure your charts are properly linted and tested. However, by default, the <strong class="source-inline">lint-and-install</strong> command does not check for backward compatibility. This feature can be enabled by adding the <strong class="source-inline">--upgrade</strong> flag.</p>
			<p>When the <strong class="source-inline">--upgrade</strong> flag is provided, ct checks if the <strong class="source-inline">MAJOR</strong> version number of the chart’s version has been incremented. If a breaking change is not expected, then ct deploys the previous chart version first and then upgrades to the new version. This helps ensure that regressions have not occurred. Then, ct installs the new version directly using a standard release. We recommend adding the <strong class="source-inline">--upgrade</strong> flag when using the <strong class="source-inline">lint-and-install</strong> command.</p>
			<p>Let’s continue by installing ct and its dependencies locally. Then, we will look at an example of how ct can be used.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor234"/>Installing the Chart Testing tools</h2>
			<p>To use ct, you <a id="_idIndexMarker546"/>must have the following tools installed on your local machine:</p>
			<ul>
				<li><strong class="source-inline">helm</strong></li>
				<li><strong class="source-inline">git</strong> (version 2.17.0 or later)</li>
				<li><strong class="source-inline">yamllint</strong></li>
				<li><strong class="source-inline">yamale</strong></li>
				<li><strong class="source-inline">kubectl</strong></li>
			</ul>
			<p>Instructions for installing <strong class="source-inline">helm</strong> and <strong class="source-inline">kubectl</strong> were provided in <a href="B17979_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Preparing a Kubernetes and Helm Environment</em>, while <strong class="source-inline">yamllint</strong> was installed earlier in this chapter. Now, we’ll install <strong class="source-inline">yamale</strong>, which is a tool for validating YAML schemas. It is used by ct to validate the <strong class="source-inline">Chart.yaml</strong> file.</p>
			<p><strong class="source-inline">yamale</strong> can be installed with the <strong class="source-inline">pip3</strong> package manager, as shown here:</p>
			<p class="source-code">$ pip3 install yamale –user</p>
			<p>You can also install Yamale manually by downloading an archive from <a href="https://github.com/23andMe/Yamale/archive/master.zip">https://github.com/23andMe/Yamale/archive/master.zip</a>. Once downloaded, unzip the archive and run the <strong class="source-inline">setup.py</strong> script:</p>
			<p class="source-code">$ python3 setup.py install</p>
			<p>Once you have the prerequisite tooling installed, you should download ct from the project’s GitHub releases page at <a href="https://github.com/helm/chart-testing/releases">https://github.com/helm/chart-testing/releases</a>. Each release contains an <em class="italic">Assets</em> section with a list of archives associated with each release.</p>
			<p>Download the archive that corresponds with the platform type of your local machine. Version <strong class="bold">v3.5.1</strong> was the version that was used for this publication:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Figure_9.03_B17979.jpg" alt="Figure 9.3 – The Helm releases page on GitHub&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The Helm releases page on GitHub</p>
			<p>Unarchive <a id="_idIndexMarker547"/>the release once you have downloaded the appropriate archive from the GitHub releases page. Once unarchived, you will see the following contents:</p>
			<pre class="source-code">
LICENSE
README.md
etc/chart_schema.yaml
etc/lintconf.yaml
ct</pre>
			<p>The <strong class="source-inline">LICENSE</strong> and <strong class="source-inline">README.md</strong> files can be removed as they are not needed.</p>
			<p>The <strong class="source-inline">etc/chart_schema.yaml</strong> and <strong class="source-inline">etc/lintconf.yaml</strong> files can be moved to either the <strong class="source-inline">$HOME/.ct/</strong> or <strong class="source-inline">/etc/ct/</strong> location on your local machine. These files provide <strong class="source-inline">yamllint</strong> and <strong class="source-inline">yamale</strong> rules for linting and schema validation. When moved to the suggested locations, they provide default rules for any invocation of ct, regardless of their location on the filesystem.</p>
			<p>You should <a id="_idIndexMarker548"/>also move ct to a location that is included in your system’s <strong class="source-inline">PATH</strong> variable. Moving ct as well as the files located under <strong class="source-inline">etc</strong> can be done with the following commands:</p>
			<p class="source-code">$ mkdir $HOME/.ct</p>
			<p class="source-code">$ mv $HOME/Downloads/etc/* $HOME/.ct/</p>
			<p class="source-code">$ mv $HOME/Downloads/ct /usr/local/bin/</p>
			<p>Now that all of the required tools have been installed, let’s clone the Packt repository – that is, if you did not clone it previously. We will interact with this repository to demonstrate the use of ct:</p>
			<p class="source-code">$ git clone https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git</p>
			<p>Once cloned, you will notice that this repository contains several ct-related files:</p>
			<ul>
				<li><strong class="source-inline">lintconf.yaml</strong>: This is a copy of the same file that was included in the ct archive. When added to a repository, ct uses this local reference instead of the default file located at <strong class="source-inline">$HOME/.ct/</strong>.</li>
				<li><strong class="source-inline">chart_schema.yaml</strong>: This is also a copy of the same file that was included in the ct archive. When added to a repository, ct uses this local reference instead of the default file located at <strong class="source-inline">$HOME/.ct/</strong>.</li>
				<li><strong class="source-inline">ct.yaml</strong>: This file contains the configuration for ct.</li>
			</ul>
			<p>The following are a couple of the configurations that are included in the <strong class="source-inline">ct.yaml</strong> file:</p>
			<pre class="source-code">
chart-dirs:
  - helm-charts/charts
chart-repos:
  - bitnami=https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami </pre>
			<p>The <strong class="source-inline">chart-dirs</strong> field indicates that the <strong class="source-inline">helm-charts/charts</strong> directory relative to <strong class="source-inline">ct.yaml</strong> is the root of the Helm chart monorepo. The <strong class="source-inline">chart-repos</strong> field provides a <a id="_idIndexMarker549"/>list of repositories that ct should add to download dependencies. A variety of other configurations can be added to this file to customize the execution of ct. The full list of available options can be reviewed in the Chart Testing documentation at <a href="https://github.com/helm/chart-testing">https://github.com/helm/chart-testing</a>.</p>
			<p>Now, let’s see ct in action by running the <strong class="source-inline">lint-and-install</strong> command.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor235"/>Running the lint-and-install command</h2>
			<p>In the <strong class="source-inline">helm-charts/charts</strong> folder, which <a id="_idIndexMarker550"/>is the location of our Helm charts monorepo, we have two charts:</p>
			<ul>
				<li><strong class="bold">guestbook</strong>: This is the <strong class="source-inline">guestbook</strong> chart that <a id="_idIndexMarker551"/>we wrote in <em class="italic">Part 2</em> of this book.</li>
				<li><strong class="bold">nginx</strong>: This is a basic <a id="_idIndexMarker552"/>Helm chart that was created with <strong class="source-inline">helm create</strong> and is used to deploy an <strong class="source-inline">nginx</strong> reverse proxy.</li>
			</ul>
			<p>The <strong class="source-inline">guestbook</strong> and <strong class="source-inline">nginx</strong> Helm charts are the charts that will be tested with ct. First, let’s navigate to the top level of the Git repository:</p>
			<p class="source-code">$ cd Managing-Kubernetes-Resources-using-Helm</p>
			<p class="source-code">$ ls</p>
			<p class="source-code">LICENSE           chapter4          chapter6          chapter8           chart_schema.yaml helm-charts</p>
			<p class="source-code">README.md         chapter5          chapter7          chapter9           ct.yaml           lintconf.yaml</p>
			<p>Since ct should run in the same folder as the <strong class="source-inline">ct.yaml</strong> file, we can simply run <strong class="source-inline">ct lint-and-install</strong> from the top level of the repository:</p>
			<p class="source-code">$ ct lint-and-install</p>
			<p>After running this command, you should see the following message:</p>
			<pre class="source-code">
Linting and installing charts...
--------------------------------------------
No chart changes detected.
--------------------------------------------
All charts linted and installed successfully</pre>
			<p>Since none of the charts were modified, ct did not perform any testing on your charts. We should modify at least one chart in the <strong class="source-inline">helm-charts/charts</strong> directory to allow for testing to <a id="_idIndexMarker553"/>take place. Since normal development would likely involve feature branches, let’s create a new Git branch where we will make modifications. Create a new branch called <strong class="source-inline">chart-testing-example</strong> by running the following command:</p>
			<p class="source-code">$ git checkout –b chart-testing-example</p>
			<p>The modifications can be of any size and type, so for this example, we will simply modify the <strong class="source-inline">nginx</strong> chart’s <strong class="source-inline">Chart.yaml</strong> file. Modify the description fields of the <strong class="source-inline">helm-charts/charts/nginx/Chart.yaml</strong> file so that they read as follows:</p>
			<pre class="source-code">
description: Deploys an NGINX instance to Kubernetes</pre>
			<p>Previously, this value was <strong class="source-inline">A Helm chart for Kubernetes</strong>. Verify that the <strong class="source-inline">nginx</strong> chart has been modified by running the <strong class="source-inline">git status</strong> command:</p>
			<p class="source-code">$ git status</p>
			<p>You should see an output similar to the following:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_9.04_B17979.jpg" alt="Figure 9.4 – Git status, displaying a change in Chart.yaml&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Git status, displaying a change in Chart.yaml</p>
			<p>Now, try to run the <strong class="source-inline">lint-and-install</strong> command again:</p>
			<p class="source-code">$ ct lint-and-install</p>
			<p>This time, ct displays the charts from the monorepo that have changed:</p>
			<pre class="source-code">
Linting and installing charts...
----------------------------------------------------------------
Charts to be processed:
----------------------------------------------------------------
nginx =&gt; (version: "1.0.0", path: "helm-charts/charts/nginx")
----------------------------------------------------------------</pre>
			<p>The process, however, fails <a id="_idIndexMarker554"/>later on because the <strong class="source-inline">nginx</strong> chart version was not modified:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/Figure_9.05_B17979.jpg" alt="Figure 9.5 – ct output when chart versions are not updated&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – ct output when chart versions are not updated</p>
			<p>This can be fixed by incrementing the version of the <strong class="source-inline">nginx</strong> chart. Since this change does not introduce new features, we will increment the <strong class="source-inline">PATCH</strong> version. Modify the <strong class="source-inline">nginx</strong> chart version to <strong class="source-inline">1.0.1</strong> in the <strong class="source-inline">Chart.yaml</strong> file:</p>
			<pre class="source-code">
version: 1.0.1</pre>
			<p>Once the version is updated, run the <strong class="source-inline">lint-and-install</strong> command again:</p>
			<p class="source-code">$ ct lint-and-install</p>
			<p>Now that the chart version has been incremented, the <strong class="source-inline">lint-and-install</strong> command will follow the full testing workflow. You will see that the <strong class="source-inline">nginx</strong> chart has been linted and deployed to an automatically created namespace (though a specific namespace can be targeted by using the <strong class="source-inline">--namespace</strong> flag). Once the deployed pods are reported as ready, ct will automatically run the test hooks denoted by resources with the <strong class="source-inline">helm.sh/hook test</strong> annotation. ct will also print the logs of each test pod, as well as the namespace events.</p>
			<p>You may <a id="_idIndexMarker555"/>notice that the <strong class="source-inline">nginx</strong> chart was deployed multiple times. This is because the <strong class="source-inline">nginx</strong> chart contains a <strong class="source-inline">ci/</strong> folder, located within the <strong class="source-inline">helm-charts/charts/nginx/ci</strong> directory. This folder contains two different values files, so the <strong class="source-inline">nginx</strong> Helm chart was installed two different times to test both sets of values. This can be observed throughout the output of <strong class="source-inline">lint-and-install</strong>:</p>
			<pre class="source-code">
Linting chart with values file 'nginx/ci/nodeport-values.yaml'...
Linting chart with values file 'nginx/ci/ingress-values.yaml'...
Installing chart with values file 'nginx/ci/nodeport-values.yaml'...
Installing chart with values file 'nginx/ci/ingress-values.yaml'...</pre>
			<p>While this process was useful for testing the functionality of updated charts, it did not validate whether upgrades to the newer version will be successful. To do this, we need to provide the <strong class="source-inline">--upgrade</strong> flag. Run <strong class="source-inline">lint-and-install</strong> again, but this time, let’s add the <strong class="source-inline">--upgrade</strong> flag:</p>
			<p class="source-code">$ ct lint-and-install --upgrade</p>
			<p>This time, an in-place upgrade will occur for each <strong class="source-inline">values</strong> file under the <strong class="source-inline">ci/</strong> directory. This can be seen in the following output:</p>
			<pre class="source-code">
Testing upgrades of chart 'nginx =&gt; (version: "1.0.1", path: "nginx")' relative to previous revision 'nginx =&gt; (version: "1.0.0", path: "ct_previous_revision216728160/nginx")'...</pre>
			<p>Recall that an in-place upgrade will only be tested if the <strong class="source-inline">MAJOR</strong> version between versions is the same. If the <strong class="source-inline">--upgrade</strong> flag was specified and the <strong class="source-inline">MAJOR</strong> version was changed, you <a id="_idIndexMarker556"/>would see a message similar to the following:</p>
			<pre class="source-code">
Skipping upgrade test of 'nginx =&gt; (version: "2.0.0", path: "helm-charts/charts/nginx")' because: 1 error occurred:
* 2.0.0 does not have same major version as 1.0.0</pre>
			<p>Now that you have an understanding of how to test your Helm charts robustly, we will conclude by cleaning up the <strong class="source-inline">minikube</strong> environment.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor236"/>Cleaning up</h1>
			<p>If you have finished with the examples in this chapter, you can remove the <strong class="source-inline">chapter9</strong> namespace from your <strong class="source-inline">minikube</strong> cluster:</p>
			<p class="source-code">$ kubectl delete ns chapter9</p>
			<p>Finally, shut down your <strong class="source-inline">minikube</strong> cluster by running <strong class="source-inline">minikube stop</strong>.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor237"/>Summary</h1>
			<p>In this chapter, you learned about different methods you can apply to test your Helm charts. The most basic way to test a chart is to run the <strong class="source-inline">helm template</strong> command against a local chart directory and determine whether its resources were generated. You can also use the <strong class="source-inline">helm lint</strong> command to ensure that your chart follows the correct formatting for Helm resources, and you can use the <strong class="source-inline">yamllint</strong> command to lint the YAML style that’s used in your chart.</p>
			<p>Apart from local templating and linting, you can also perform live tests on a Kubernetes environment with the <strong class="source-inline">helm test</strong> command and the ct tool. In addition to performing basic chart testing capabilities, ct also provides features that make it easier to maintain Helm charts in a monorepo.</p>
			<p>In the next chapter, you will learn how Helm can be used within a <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) and GitOps setting.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor238"/>Further reading</h1>
			<p>For additional information on the <strong class="source-inline">helm template</strong> and <strong class="source-inline">helm lint</strong> commands, please refer to the following resources:</p>
			<ul>
				<li><strong class="source-inline">helm template</strong>: <a href="https://helm.sh/docs/helm/helm_template/">https://helm.sh/docs/helm/helm_template/</a></li>
				<li><strong class="source-inline">helm lint</strong>: <a href="https://helm.sh/docs/helm/helm_lint/">https://helm.sh/docs/helm/helm_lint/</a></li>
			</ul>
			<p>The following pages from the Helm documentation discuss chart tests and the <strong class="source-inline">helm test</strong> command:</p>
			<ul>
				<li>Chart tests: <a href="https://helm.sh/docs/topics/chart_tests/">https://helm.sh/docs/topics/chart_tests/</a></li>
				<li>The <strong class="source-inline">helm test</strong> command: <a href="https://helm.sh/docs/helm/helm_test/">https://helm.sh/docs/helm/helm_test/</a></li>
			</ul>
			<p>Finally, see the Chart Testing GitHub repository for more information about the ct CLI: <a href="https://github.com/helm/chart-testing">https://github.com/helm/chart-testing</a>.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor239"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li value="1">What is the purpose of the <strong class="source-inline">helm template</strong> command? How does it differ from the <strong class="source-inline">helm lint</strong> command?</li>
				<li>What tool can be leveraged to lint the YAML style of rendered Helm templates?</li>
				<li>How is a chart test created? How is a chart test executed?</li>
				<li>What is the difference between <strong class="source-inline">helm test</strong> and <strong class="source-inline">ct lint-and-install</strong>?</li>
				<li>What is the purpose of the <strong class="source-inline">ci/</strong> folder when used with the ct tool?</li>
				<li>How does the <strong class="source-inline">--upgrade</strong> flag change the behavior of the <strong class="source-inline">ct lint-and-install</strong> command?</li>
			</ol>
		</div>
		<div>
			<div id="_idContainer098">
			</div>
		</div>
	

		<div id="_idContainer099" class="Content">
			<h1 id="_idParaDest-193"><a id="_idTextAnchor240"/>Part 3: Advanced Deployment Patterns</h1>
		</div>
		<div id="_idContainer100">
			<p>The Helm <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) is a robust toolkit, but efficiency can be further increased with automation. In <em class="italic">Part 3</em>, you will learn about incorporating Helm into industry-standard deployment methodologies. You will also take a deep dive into important security considerations throughout day-to-day Helm usage.</p>
			<p>In this part, we will cover the following topics:</p>
			<ul>
				<li><a href="B17979_10.xhtml#_idTextAnchor241"><em class="italic">Chapter 10</em></a><em class="italic">, Automating Helm with CD and GitOps</em></li>
				<li><a href="B17979_11.xhtml#_idTextAnchor255"><em class="italic">Chapter 11</em></a><em class="italic">, Using Helm with the Operator Framework </em></li>
				<li><a href="B17979_12.xhtml#_idTextAnchor270"><em class="italic">Chapter 12</em></a><em class="italic">, Helm Security Considerations</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer101">
			</div>
		</div>
		<div>
			<div id="_idContainer102" class="Content">
			</div>
		</div>
		<div>
			<div id="_idContainer103">
			</div>
		</div>
	</body></html>