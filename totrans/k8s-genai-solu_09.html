<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer073" epub:type="chapter">&#13;
			<h1 id="_idParaDest-114" class="chapter-number"><a id="_idTextAnchor113"/>9</h1>&#13;
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Security Best Practices for Deploying GenAI on Kubernetes</h1>&#13;
			<p>In this chapter, we will explore the security best practices for deploying GenAI applications on <strong class="bold">Kubernetes</strong> (<strong class="bold">K8s</strong>). We <a id="_idIndexMarker702"/>will begin by introducing the concept of “defense in depth” and then cover the key pillars of securing GenAI workloads – supply chain, host, network, and runtime security. Additionally, we will cover best practices for the management of secrets and the principle of least privilege to prevent unauthorized access to critical data and <span class="No-Break">application credentials.</span></p>&#13;
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>&#13;
			<ul>&#13;
				<li>Defense <span class="No-Break">in depth</span></li>&#13;
				<li>K8s <span class="No-Break">security considerations</span></li>&#13;
				<li>Additional considerations for <span class="No-Break">GenAI apps</span></li>&#13;
				<li>Implementing security best practices in a <span class="No-Break">chatbot app</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>Technical requirements</h1>&#13;
			<p>In this chapter, we will be using the following, the first of which requires you to set up an account and create an <span class="No-Break">access token:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Hugging </strong><span class="No-Break"><strong class="bold">Face</strong></span><span class="No-Break">: </span><a href="https://huggingface.co/join"><span class="No-Break">https://huggingface.co/join</span></a></li>&#13;
				<li>An Amazon EKS cluster setup, as illustrated in <a href="B31108_03.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 3</em></span></a></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Defense in depth</h1>&#13;
			<p>The best way <a id="_idIndexMarker703"/>to protect an application in the cloud is by using the concept of <strong class="bold">defense in depth</strong> (<a href="https://csrc.nist.gov/glossary/term/defense_in_depth">https://csrc.nist.gov/glossary/term/defense_in_depth</a>). This is a strategy that implements multiple layers of security to protect against threats across different attack vectors. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> shows a conceptual view of defense in depth, where each concentric circle represents a layer or attack vector we would like <span class="No-Break">to secure.</span></p>&#13;
			<p>Let’s look over this concept<a id="_idIndexMarker704"/> for<a id="_idIndexMarker705"/> security best practices, and then we will dive deeper for every layer, specific to containers <span class="No-Break">and K8s.</span></p>&#13;
			<div>&#13;
				<div id="_idContainer070" class="IMG---Figure">&#13;
					<img src="image/B31108_09_1.jpg" alt="Figure 9.1 – Layered security model" width="1103" height="1013"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Layered security model</p>&#13;
			<p>The following are details about the layers depicted in the <span class="No-Break">preceding figure:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">User data</strong>: This is the innermost core of the system containing sensitive user data, such as<a id="_idIndexMarker706"/> user passwords, <strong class="bold">personally identifiable information</strong> (<strong class="bold">PII</strong>), and so on. To protect this layer, data encryption at rest and transit should <span class="No-Break">be used.</span></li>&#13;
				<li><strong class="bold">Configuration</strong>: Sensitive configuration data for an application includes environment variables, application settings, secrets, and API keys required for the application to function. Lapses in configuration settings could lead to data leaks, privilege escalation, or compromised <span class="No-Break">application behavior.</span></li>&#13;
				<li><strong class="bold">Application code</strong>: Vulnerabilities in application code can lead to exploits, such as SQL injection or remote code execution. To prevent this, users should conduct regular static <a id="_idIndexMarker707"/>and dynamic code analysis, promptly patch vulnerabilities, and update dependencies to the latest <span class="No-Break">secure versions.</span></li>&#13;
				<li><strong class="bold">Dependencies</strong>: Code dependencies include libraries, frameworks, and external packages that the application relies on. Vulnerable or outdated dependencies are one of the most common entry points for attackers. To prevent this, users should regularly scan dependencies <span class="No-Break">for vulnerabilities.</span></li>&#13;
				<li><strong class="bold">Containers</strong>: The container runtime and images could also create another threat vector, as misconfigured or untrusted containers can escalate privileges, attack the host, or expose sensitive information. To prevent this, users could use image signing to verify the authenticity of images and implement runtime security using tools such<a id="_idIndexMarker708"/> as <strong class="bold">Falco</strong> to watch out for <span class="No-Break">malicious behavior.</span></li>&#13;
				<li><strong class="bold">Host</strong>: This is the underlying server or node where containers are deployed. The host kernel is shared among all containers, making it a critical security layer. If the host is compromised, all containers can be affected. To prevent this, it is recommended to harden the host operating system by disabling unused services, applying <a id="_idIndexMarker709"/>patches, and using container-optimized operating systems, such <span class="No-Break">as </span><span class="No-Break"><strong class="bold">Bottlerocket</strong></span><span class="No-Break">.</span></li>&#13;
			</ul>&#13;
			<p>In this section, we learned about the concept of defense in depth, a strategy that implements multiple layers of security to protect against threats across different attack vectors. We also looked at a conceptual view of various attack vectors and best practices in each layer. In the next section, let’s look at key security considerations when deploying workloads <span class="No-Break">in K8s.</span></p>&#13;
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>K8s security considerations</h1>&#13;
			<p>Now that we have <a id="_idIndexMarker710"/>covered the concept of defense in depth at a high level, let’s discuss containers and K8s security best practices. Thinking about <strong class="bold">container security</strong> is<a id="_idIndexMarker711"/> critical in the cloud environment, as containers operate in a dynamic and <span class="No-Break">shared environment.</span></p>&#13;
			<p>Containers encapsulate <em class="italic">software</em> and <em class="italic">dependencies</em> making them highly portable; however, this portability also introduces a set of risks. A comprehensive security strategy should address vulnerabilities across the container lifecycle – from <em class="italic">build pipelines</em> to <span class="No-Break"><em class="italic">runtime environments</em></span><span class="No-Break">.</span></p>&#13;
			<p>Key areas of focus include securing the supply chain, protecting the host system, and monitoring runtime activity. Each layer of security adds resilience against potential threats, and by following the best practices, one can ensure the safe deployment and operation <span class="No-Break">of containers.</span></p>&#13;
			<p>The following are some of the key areas we will dive deeper into as part of this <span class="No-Break">container security:</span></p>&#13;
			<ul>&#13;
				<li>Supply <span class="No-Break">chain security</span></li>&#13;
				<li><span class="No-Break">Host security</span></li>&#13;
				<li><span class="No-Break">Runtime security</span></li>&#13;
				<li><span class="No-Break">Network security</span></li>&#13;
				<li><span class="No-Break">Secrets management</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Supply chain security</h2>&#13;
			<p>The <a id="_idIndexMarker712"/>container supply chain encompasses <a id="_idIndexMarker713"/>all the stages from building an image to deploying and <a id="_idIndexMarker714"/>monitoring it in production, as shown in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>&#13;
			<div>&#13;
				<div id="_idContainer071" class="IMG---Figure">&#13;
					<img src="image/B31108_09_2.jpg" alt="Figure 9.2 – Container supply chain" width="1637" height="152"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Container supply chain</p>&#13;
			<p>Now, let’s discuss the first five phases and their corresponding security <span class="No-Break">best practices.</span></p>&#13;
			<h3><strong class="bold">Build phase</strong></h3>&#13;
			<p>During<a id="_idIndexMarker715"/> the build phase, malicious/vulnerable code can enter the container image through unverified dependencies or insecure configurations. To secure the build phase, one should only use trusted base images from verified sources. To minimize the attack surface and improve security, consider using lightweight parent images for <a id="_idIndexMarker716"/>your <a id="_idIndexMarker717"/>containers. <strong class="bold">Alpine Linux</strong> (<a href="https://hub.docker.com/_/alpine">https://hub.docker.com/_/alpine</a>), <strong class="bold">distroless</strong> (<a href="https://www.docker.com/blog/is-your-container-image-really-distroless/">https://www.docker.com/blog/is-your-container-image-really-distroless/</a>), or <strong class="bold">scratch</strong> (<a href="https://hub.docker.com/_/scratch">https://hub.docker.com/_/scratch</a>) images<a id="_idIndexMarker718"/> have <a id="_idIndexMarker719"/>fewer built-in packages, limiting the potential vulnerabilities, and are <span class="No-Break">generally recommended.</span></p>&#13;
			<p><strong class="bold">DockerSlim</strong> (<a href="https://github.com/slimtoolkit/slim">https://github.com/slimtoolkit/slim</a>) is an open source tool that helps optimize<a id="_idIndexMarker720"/> container images by reducing their size, thus improving security by identifying only the parts that are required at runtime. This significantly reduces the attack surface and enhances performance without altering the functionality of the <span class="No-Break">containerized application.</span></p>&#13;
			<p>It is also recommended to enforce the immutability of container images by using declarative Dockerfiles and <a id="_idIndexMarker721"/>reproducible builds. An <strong class="bold">immutable tag</strong> refers to a container image tag that cannot be changed or updated once it is created and pushed to a container registry. This ensures that the image associated with the tag remains <em class="italic">fixed</em> and <em class="italic">consistent</em> over time, preventing unintentional or malicious changes. For example, the <strong class="source-inline">latest</strong> tag is mutable, meaning it can point to different images over time as new images are pushed, whereas a tag such as <strong class="source-inline">v1.0</strong> is immutable, as it ensures that it always references the same image, regardless of future pushes. Immutability is particularly beneficial for GenAI applications to ensure the training/fine-tuning jobs and inference images are built against a consistent environment, maintain model integrity, and simplify <span class="No-Break">troubleshooting efforts.</span></p>&#13;
			<p>A <strong class="bold">multi-stage build</strong> (<a href="https://docs.docker.com/build/building/multi-stage/">https://docs.docker.com/build/building/multi-stage/</a>) is a technique used<a id="_idIndexMarker722"/> in the build phase that allows you to break down the build process into multiple discrete stages. Each stage can focus on a specific task using an appropriate parent image, such as compiling code or installing dependencies, and then selectively copy only the necessary artifacts into the final, minimal image. </p>&#13;
			<p>For GenAI applications, multi-stage builds help ensure that large training frameworks, data preprocessing scripts, or model optimization steps can selectively be excluded from the final production image. This results in smaller, more secure, and efficient images that can be quickly deployed <span class="No-Break">for inference.</span></p>&#13;
			<h3><strong class="bold">Test phase</strong></h3>&#13;
			<p>Undetected <a id="_idIndexMarker723"/>vulnerabilities and misconfigurations in images can lead to issues downstream. To mitigate this, it is recommended to integrate automated security testing into CI/CD pipelines with tools such as <strong class="bold">Snyk</strong> (<a href="https://snyk.io/">https://snyk.io/</a>). You<a id="_idIndexMarker724"/> should perform static analysis on code and dynamic testing on built images to uncover vulnerabilities. Ensure that your testing process also covers compliance with internal security policies and relevant industry standards. Incorporate test cases to assess resource usage, verify adherence to least-privilege principles, and monitor runtime behaviors. By doing so, you can help maintain secure, compliant, and predictable operations throughout the <span class="No-Break">software lifecycle.</span></p>&#13;
			<h3><strong class="bold">Store phase</strong></h3>&#13;
			<p>During the<a id="_idIndexMarker725"/> image store phase in container registries, images can be tampered with or can contain outdated dependencies. To safely secure <a id="_idIndexMarker726"/>images, it is recommended to use secured container registries such as <strong class="bold">Amazon </strong><span class="No-Break"><strong class="bold">ECR</strong></span><span class="No-Break"> (</span><a href="https://aws.amazon.com/ecr/"><span class="No-Break">https://aws.amazon.com/ecr/</span></a><span class="No-Break">).</span></p>&#13;
			<p>You should also enable <a id="_idIndexMarker727"/>image signing and verification using tools such as Docker Content Trust or Cosign. <strong class="bold">AWS Signer</strong> (<a href="https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html">https://docs.aws.amazon.com/signer/latest/developerguide/Welcome.html</a>) is a fully managed service that allows you to digitally sign code, applications, and containers to ensure the integrity and authenticity of <span class="No-Break">your software.</span></p>&#13;
			<p>To ensure that only signed container images are deployed in production, a <strong class="bold">policy-as-code solution</strong> such as <strong class="bold">Open Policy Agent</strong> (<strong class="bold">OPA</strong>) or <a id="_idIndexMarker728"/>its K8s-native implementation, <strong class="bold">OPA Gatekeeper</strong> (<a href="https://github.com/open-policy-agent/gatekeeper">https://github.com/open-policy-agent/gatekeeper</a>), is<a id="_idIndexMarker729"/> recommended. OPA Gatekeeper is an open source project that leverages OPA to enforce policies in K8s clusters. It enables administrators to implement fine-grained governance by validating and mutating K8s resources against predefined constraints. Gatekeeper uses <strong class="bold">custom resource definitions</strong> (<strong class="bold">CRDs</strong>) to <a id="_idIndexMarker730"/>define these policies and constraints, allowing users to tailor governance to their specific needs. It operates as an admission controller, ensuring that any resource not complying with the defined rules is denied during creation or updates. Additionally, it supports auditing capabilities, enabling users to identify and remediate policy violations in existing resources. <strong class="bold">Role-based access control</strong> (<strong class="bold">RBAC</strong>) is<a id="_idIndexMarker731"/> also recommended to restrict access to images, and users should regularly clean up unused or deprecated images to reduce potential <span class="No-Break">attack surfaces.</span></p>&#13;
			<h3><strong class="bold">Encrypt phase</strong></h3>&#13;
			<p>Sensitive<a id="_idIndexMarker732"/> data in images should always be intercepted. One should avoid embedding secrets (e.g., API keys or passwords) directly in images to prevent leaks in case of a potentially compromised <span class="No-Break">container image.</span></p>&#13;
			<p>You can use <a id="_idIndexMarker733"/>secret <a id="_idIndexMarker734"/>management tools such as <strong class="bold">HashiCorp Vault</strong> (<a href="https://www.hashicorp.com/products/vault">https://www.hashicorp.com/products/vault</a>), <strong class="bold">Kubernetes Secrets</strong> (<a href="https://kubernetes.io/docs/concepts/configuration/secret/">https://kubernetes.io/docs/concepts/configuration/secret/</a>), or <strong class="bold">AWS Secrets Manager</strong> (<a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html">https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html</a>) to store the<a id="_idIndexMarker735"/> secrets. For example, AWS Secrets Manager is a secure service for managing secrets, such as database credentials, API keys, and other sensitive configuration data. By encrypting secrets with <strong class="bold">AWS Key Management Service</strong> (<strong class="bold">AWS KMS</strong>) and<a id="_idIndexMarker736"/> enabling fine-grained access control through <strong class="bold">AWS Identity and Access Management</strong> (<strong class="bold">AWS IAM</strong>), Secrets <a id="_idIndexMarker737"/>Manager ensures that sensitive data is protected and accessible only to authorized users and applications. It also supports version control and the automatic rotation of secrets, reducing the risks of credential exposure and minimizing <span class="No-Break">manual overhead.</span></p>&#13;
			<p>To integrate external secret management solutions with K8s, you can use projects such as <strong class="bold">secrets-store-csi-driver</strong> (<a href="https://github.com/kubernetes-sigs/secrets-store-csi-driver">https://github.com/kubernetes-sigs/secrets-store-csi-driver</a>), which <a id="_idIndexMarker738"/>allows K8s to mount multiple secrets, keys, and certificates stored in external secrets stores into K8s Pods as a volume. Once the volume is attached, the data in it is mounted into the container’s filesystem. Refer to the AWS documentation at <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html">https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html</a> for an example walkthrough of using AWS Secrets Manager in an Amazon EKS cluster. In the case of GenAI applications, external<a id="_idIndexMarker739"/> API keys from <strong class="bold">Hugging Face</strong> and <strong class="bold">OpenAI</strong> can <a id="_idIndexMarker740"/>safely be stored in these solutions, and applications can securely access them during <span class="No-Break">the runtime.</span></p>&#13;
			<h3><strong class="bold">Scan phase</strong></h3>&#13;
			<p> Vulnerabilities<a id="_idIndexMarker741"/> in images or dependencies can lead to exploitation by bad actors. To prevent this, images should be continuously scanned during the build and store phases. Most container registry solutions provide this capability out of the box, or open source tools <a id="_idIndexMarker742"/>such as <strong class="bold">Trivy</strong> (<a href="https://github.com/aquasecurity/trivy">https://github.com/aquasecurity/trivy</a>) can be used to scan container images for vulnerabilities. These tools identify potential risks by analyzing image layers against known vulnerability databases (e.g., CVE databases), providing early detection <span class="No-Break">of issues.</span></p>&#13;
			<p>In cloud <a id="_idIndexMarker743"/>environments, more advanced image scanning options are also available. For example, Amazon ECR supports advanced vulnerability scanning <a id="_idIndexMarker744"/>through <strong class="bold">Amazon Inspector</strong> (<a href="https://aws.amazon.com/inspector/">https://aws.amazon.com/inspector/</a>), a managed service designed to automate security assessments. This integration provides enhanced, continuous scanning for container images in ECR, ensuring they remain secure throughout their lifecycle. Amazon Inspector can scan container images in ECR automatically, without requiring manual triggers, whenever a new image is pushed or updated. Refer to the Amazon ECR documentation<a id="_idIndexMarker745"/> at <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html">https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html</a> to learn more about these options and how to enable them on your <span class="No-Break">container repositories.</span></p>&#13;
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Host security</h2>&#13;
			<p>Securing the <a id="_idIndexMarker746"/>host environment for containers is critical, as multiple containers can share the host operating system and kernel. The following are some of the best practices and strategies for securing <span class="No-Break">container hosts:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Deploy in private subnets</strong>: Deploying hosts/worker nodes in private subnets minimizes exposure to external threats by restricting direct access from the internet. To expose applications to the public internet, deploy load balancer resources in public subnets using K8s load balancer or Ingress <span class="No-Break">resource types.</span></li>&#13;
				<li><strong class="bold">Disable SSH access</strong>: SSH access should be limited to minimizing the attack vector. Instead, <strong class="bold">session management tools</strong> such as <strong class="bold">AWS Systems Manager</strong> (<strong class="bold">SSM</strong>) (<a href="https://aws.amazon.com/systems-manager/">https://aws.amazon.com/systems-manager/</a>) should be used for secure, auditable <a id="_idIndexMarker747"/>access to hosts without exposing SSH. If SSH is necessary, enforce key-based authentication and restrict access using <span class="No-Break">security groups.</span></li>&#13;
				<li><strong class="bold">Block the </strong><strong class="bold">Instance Metadata Service</strong> (<strong class="bold">IMDS</strong>): The IMDS provides data about your EC2 instance that can expose sensitive information (e.g., IAM credentials) to <a id="_idIndexMarker748"/>malicious actors if not properly secured. It is recommended to use <strong class="bold">IMDSv2</strong> (<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html</a>) instead, which requires session tokens for accessing instance metadata. To<a id="_idIndexMarker749"/> restrict IMDS access to containerized applications, you can set the hop limit to <strong class="source-inline">1</strong> and enforce the usage of IMDSv2, as shown in the following <span class="No-Break">Terraform code:</span><pre class="source-code">&#13;
resource "aws_launch_template" "example" {&#13;
  name = "example"&#13;
  ...&#13;
    metadata_options {&#13;
    http_endpoint               = "enabled"&#13;
    http_tokens                 = "required"&#13;
    <strong class="bold">http_put_response_hop_limit = 1</strong>&#13;
    instance_metadata_tags      = "enabled"&#13;
  }&#13;
  ...</pre></li>				<li><strong class="bold">Encrypt all storage</strong>: Encrypting storage protects sensitive data on the host in case of physical or logical compromise. Use AWS KMS<a id="_idIndexMarker750"/> to encrypt <strong class="bold">Amazon Elastic Block Store</strong> (<strong class="bold">Amazon EBS</strong>) volumes attached to the host. If using EC2 instances with an <strong class="bold">NVMe</strong> instance store, all<a id="_idIndexMarker751"/> the data is encrypted using an XTS-AES-256 <span class="No-Break">block cipher.</span></li>&#13;
				<li><strong class="bold">Harden the node Amazon Machine Image (AMI)</strong>: A hardened AMI reduces vulnerabilities by including only the necessary software, configurations, and security settings. Use container-optimized operating systems such as Bottlerocket (<a href="https://aws.amazon.com/bottlerocket/">https://aws.amazon.com/bottlerocket/</a>), which are built from the ground up with containers in mind. They often include features such as a read-only root filesystem, atomic updates, and minimal tooling tailored to running containers efficiently and securely. You should disable and uninstall unused software to reduce the attack surface and configure the operating system according <a id="_idIndexMarker752"/>to <a id="_idIndexMarker753"/>CIS benchmarks for Docker, Kubernetes, and<a id="_idIndexMarker754"/> Linux. Use <strong class="bold">AppArmor</strong> (<a href="https://apparmor.net/">https://apparmor.net/</a>), <strong class="bold">SELinux</strong> (<a href="https://www.redhat.com/en/topics/linux/what-is-selinux">https://www.redhat.com/en/topics/linux/what-is-selinux</a>), or <strong class="bold">seccomp</strong> (<a href="https://kubernetes.io/docs/tutorials/security/seccomp/">https://kubernetes.io/docs/tutorials/security/seccomp/</a>) to<a id="_idIndexMarker755"/> restrict <span class="No-Break">container privileges.</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Container runtime security</h2>&#13;
			<p>Securing containers<a id="_idIndexMarker756"/> at runtime is critical to prevent privilege escalations and unauthorized access. This involves limiting resources, restricting privileges, enforcing security standards, and integrating monitoring and policy tools. The following are the core runtime <span class="No-Break">security practices:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Provide only the resources required for normal operation</strong>: Unrestricted resource allocation can<a id="_idIndexMarker757"/> lead to <strong class="bold">denial-of-service</strong> (<strong class="bold">DoS</strong>) attacks and cluster instability, where some containers can consume entire node resources. To prevent this, you should define CPU and memory limits in K8s manifests reflecting the optimal resources a container <span class="No-Break">might need.</span></li>&#13;
				<li><strong class="bold">Restrict root and privileged access</strong>: Containers running as root or in privileged mode can lead to host compromise. To prevent this, ensure containers are configured to run as a non-root user in <strong class="source-inline">securityContext</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">&#13;
securityContext:&#13;
  runAsUser: 1000&#13;
  runAsGroup: 1000&#13;
  <strong class="bold">allowPrivilegeEscalation: false</strong></pre></li>				<li><strong class="bold">Drop all unnecessary Linux capabilities</strong>: Linux capabilities grant elevated permissions that can be exploited if unused capabilities are left enabled. So, it is recommended to drop unnecessary capabilities in <strong class="source-inline">securityContext</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">&#13;
securityContext:&#13;
      capabilities:&#13;
        <strong class="bold">drop:</strong>&#13;
          <strong class="bold">- ALL</strong>&#13;
...</pre></li>				<li><strong class="bold">Follow Pod Security Standards</strong>: Adherence to Pod Security Standards ensures that containers comply with best practices for security configurations. Use the K8s built-in Pod Security Admission to enforce standards such as restricted <a id="_idIndexMarker758"/>profiles. Also, isolate workloads using namespaces with different security levels (e.g., restricted or baseline). Pod Security Standards define three different policy levels (privileged, baseline, and restricted) to broadly cover the security spectrum. You can apply labels and annotations on namespaces to specify the desired level of security configuration, as <span class="No-Break">shown here:</span><pre class="source-code">&#13;
<strong class="bold">$ kubectl label namespace test-ns \</strong>&#13;
<strong class="bold">pod-security.kubernetes.io/enforce=restricted</strong></pre></li>				<li><strong class="bold">Monitor the runtime</strong>: This provides active protection for containerized workloads while they are running. The goal is to detect and/or prevent malicious activity from occurring inside the containers and the worker nodes. Tools such as <a id="_idIndexMarker759"/>Falco (<a href="https://github.com/falcosecurity/falco">https://github.com/falcosecurity/falco</a>) provide real-time monitoring and anomaly detection for container behavior. It can be deployed as a DaemonSet in a K8s cluster and can monitor containers for suspicious activity. It operates by hooking into the Linux kernel using either eBPF or traditional syscalls, allowing it to observe low-level system activity inside running containers and Pods without modifying the workload itself. This deep visibility enables Falco to monitor unexpected or suspicious behavior in real time. Common events that Falco watches for include actions such as shells being spawned inside containers, modifications to sensitive files such as <strong class="source-inline">/etc/passwd</strong> or <strong class="source-inline">/etc/shadow</strong>, and network connections to untrusted IP addresses. It can also detect when a Pod tries to access a K8s Service account token improperly, which may indicate a compromise <span class="No-Break">or misconfiguration.</span><p class="list-inset">When such behavior violates its defined security rules, Falco triggers alerts instantly. For example, alerts may look like this: <strong class="bold">Terminal shell detected in nginx container</strong> or <strong class="bold">Suspicious file access by unknown process</strong>. To make these<a id="_idIndexMarker760"/> alerts actionable, teams should implement clear response strategies, such as isolating the Pod, initiating incident response procedures, or alerting security teams. Combining these technical capabilities with practical workflows allows teams to confidently enforce runtime security and respond to threats in production-grade <span class="No-Break">K8s environments.</span></p><p class="list-inset">Some other third-party tools also offer advanced runtime protection, integration, and reporting capabilities. Use<a id="_idIndexMarker761"/> agents <a id="_idIndexMarker762"/>provided by solutions such as <strong class="bold">Prisma Cloud’s Container Security</strong> (<a href="https://www.paloaltonetworks.com/prisma/cloud/container-security">https://www.paloaltonetworks.com/prisma/cloud/container-security</a>), <strong class="bold">Aqua Security</strong> (<a href="https://www.aquasec.com/products/kubernetes-security/">https://www.aquasec.com/products/kubernetes-security/</a>), or <strong class="bold">Wiz container security</strong> (<a href="https://www.wiz.io/solutions/container-and-kubernetes-security">https://www.wiz.io/solutions/container-and-kubernetes-security</a>) to <a id="_idIndexMarker763"/>monitor and <span class="No-Break">protect containers.</span></p></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Network security</h2>&#13;
			<p>Network security <a id="_idIndexMarker764"/>in K8s is critical for securing data and applications in a containerized environment. The distributed nature of K8s presents unique challenges for securing network traffic. The following are some key considerations and best practices for ensuring network security <span class="No-Break">in K8s:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Network segmentation and isolation</strong>: K8s <strong class="bold">namespaces</strong> provide a way to isolate resources <a id="_idIndexMarker765"/>and workloads within a cluster, acting as separate security boundaries. Network<a id="_idIndexMarker766"/> segmentation can be enforced using <strong class="bold">NetworkPolicy</strong> resources, discussed in <a href="B31108_08.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, which define rules for controlling ingress (incoming) and egress (outgoing) traffic at the <span class="No-Break">Pod level.</span></li>&#13;
				<li><strong class="bold">Securing Pod-to-Pod communication</strong>: By default, K8s allows communication between Pods, which can expose K8s clusters to security risks. Implementing zero-trust principles ensures that Pods communicate only with explicitly authorized peers. Service mesh technologies <a id="_idIndexMarker767"/>such as <strong class="bold">Istio</strong> or <strong class="bold">Linkerd </strong>provide<a id="_idIndexMarker768"/> mTLS for encryption<a id="_idIndexMarker769"/> and authentication, ensuring secure and authenticated <span class="No-Break">Pod-to-Pod communication.</span></li>&#13;
				<li><strong class="bold">Ingress and egress security</strong>: Ingress security focuses on controlling and securing incoming traffic to the cluster, often using HTTPS with TLS certificates for encryption. Additional protection, such as <strong class="bold">web application firewalls</strong> (<strong class="bold">WAFs</strong>), help <a id="_idIndexMarker770"/>detect and block malicious traffic. Egress security involves restricting Pods’ outbound traffic to prevent unauthorized access to external resources, which can be enforced using <span class="No-Break">egress policies.</span></li>&#13;
				<li><strong class="bold">API server protection</strong>: The K8s API server is a critical management point, requiring strong security measures. RBAC restricts user permissions based on roles, while authentication mechanisms <a id="_idIndexMarker771"/>such as <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) or AWS IAM ensure that only authorized users access the server. Network policies or firewalls should further limit access to the API server from trusted <span class="No-Break">sources only.</span></li>&#13;
				<li><strong class="bold">DNS security</strong>: CoreDNS, the default DNS server in K8s, should be secured against spoofing and related attacks. While enabling encrypted DNS protocols such<a id="_idIndexMarker772"/> as <strong class="bold">DNS-over-TLS</strong> or <strong class="bold">DNS-over-HTTPS</strong> (<a href="https://www.cloudflare.com/learning/dns/dns-over-tls/">https://www.cloudflare.com/learning/dns/dns-over-tls/</a>) is<a id="_idIndexMarker773"/> technically possible, it is not commonly implemented by default in K8s. Instead, use network policies to restrict which Pods can query the CoreDNS server, thereby reducing the risk of unauthorized requests. Additionally, ensure<a id="_idIndexMarker774"/> CoreDNS points to trusted upstream resolvers, employing <strong class="bold">DNSSEC</strong> (<a href="https://www.internetsociety.org/deploy360/dnssec/basics/">https://www.internetsociety.org/deploy360/dnssec/basics/</a>) <span class="No-Break">for integrity.</span></li>&#13;
				<li><strong class="bold">Network monitoring</strong>: Monitoring network traffic is crucial for detecting and mitigating threats. Tools such as Cilium, Calico, Sysdig, service meshes, or Datadog provide visibility into cluster traffic, enabling cluster administrators to identify <span class="No-Break">suspicious behavior.</span></li>&#13;
				<li><strong class="bold">Securing external connections</strong>: Connections to external services, such as cloud <a id="_idIndexMarker775"/>provider services or databases, should be encrypted and authenticated. K8s Secrets offer a secure way to manage credentials for external connections, ensuring that sensitive information (such as API keys and passwords) remains protected from <span class="No-Break">unauthorized access.</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Secrets management</h2>&#13;
			<p>Secrets management<a id="_idIndexMarker776"/> in K8s is a critical component for securing and managing sensitive information, such as API keys, passwords, certificates, and tokens. K8s provides built-in mechanisms to manage Secrets but securing them requires careful configuration and the following best practices to mitigate risks of unauthorized access or <span class="No-Break">accidental exposure:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">K8s Secrets resource</strong>: K8s provides a native resource<a id="_idIndexMarker777"/> called <strong class="bold">Secrets</strong>, which is used to store sensitive data in a Base64-encoded format. Secrets are mounted into Pods as environment variables or files, enabling applications to access them without embedding sensitive data directly in container images or configuration files. While convenient, the Base64 encoding is not encryption, so additional security measures <span class="No-Break">are necessary.</span></li>&#13;
				<li><strong class="bold">Encrypting Secrets at rest</strong>: By default, K8s stores <a id="_idIndexMarker778"/>Secrets in <strong class="bold">etcd</strong>, the cluster’s key-value store. To protect this sensitive information, it is essential to enable encryption at rest for etcd. When using managed K8s services such as Amazon EKS, etcd volumes are encrypted by default using AWS managed encryption keys. As an additional security measure, you can also use techniques such as envelope encryption to encrypt the Secret values before writing to the etcd database. In Amazon EKS, you can utilize AWS KMS to enable envelope encryption; refer to the AWS documentation at <a href="https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html">https://docs.aws.amazon.com/eks/latest/userguide/envelope-encryption.html</a> to <span class="No-Break">learn more.</span></li>&#13;
				<li><strong class="bold">Access control with RBAC</strong>: RBAC is a fundamental part of securing Secrets in K8s. RBAC policies should enforce the principle of least privilege, granting users, Pods, and Services access only to the Secrets they need. Properly configured roles and role bindings help prevent unauthorized users or applications from accessing <span class="No-Break">sensitive information.</span></li>&#13;
				<li><strong class="bold">Using external secret management tools</strong>: While K8s Secrets offer a convenient mechanism, many organizations opt for external secret management solutions for enhanced security. Tools such as HashiCorp Vault or AWS Secrets <a id="_idIndexMarker779"/>Manager provide centralized secret storage with advanced features such as encryption, auditing, and fine-grained access control. These tools can integrate with K8s through the <strong class="source-inline">secrets-store-csi-driver</strong> plugin or other operators, enabling seamless access to externally <span class="No-Break">managed secrets.</span></li>&#13;
				<li><strong class="bold">Automating Secret rotation</strong>: Rotating Secrets regularly reduces the risk of long-term compromise. K8s secrets do not natively support automatic rotation, but external secret management tools often include this capability. Integrating such tools into K8s workflows allows you to periodically update secrets without disrupting applications, ensuring compliance with security <span class="No-Break">best practices.</span></li>&#13;
				<li><strong class="bold">Protecting Secrets in transit</strong>: Sensitive data, including secrets, must be protected as it travels between clients, nodes, and the etcd store. Enable TLS encryption when exchanging sensitive credentials both with internal and <span class="No-Break">external systems.</span></li>&#13;
				<li><strong class="bold">Auditing and monitoring access to Secrets</strong>: Audit logging is essential for monitoring access to secrets and detecting potential misuse. K8s can generate audit logs for API actions, including those involving secrets. Integrating these logs with centralized monitoring tools or <strong class="bold">security information and event management</strong> (<strong class="bold">SIEM</strong>) solutions<a id="_idIndexMarker780"/> helps administrators detect suspicious activity and respond promptly. Secret management tools also provide audit logs, which can be integrated into <span class="No-Break">SIEM solutions.</span></li>&#13;
			</ul>&#13;
			<p>In this section, we looked at various security considerations when running containerized workloads in K8s, including supply chain security, host security, network security, and the importance of securing sensitive information using K8s Secrets. In the next section, let’s explore additional<a id="_idIndexMarker781"/> security considerations specific to <span class="No-Break">GenAI applications.</span></p>&#13;
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Additional considerations for GenAI apps</h1>&#13;
			<p>Deploying<a id="_idIndexMarker782"/> GenAI applications on K8s often involves proprietary model artifacts, large volumes of sensitive training data, and sophisticated inference requests that can originate from untrusted sources. Beyond the standard practices of K8s security, you must consider new attack vectors related to model integrity, data privacy, software supply chain vulnerabilities, and the isolation of high-value hardware resources such as GPUs. Let’s explore some of those <span class="No-Break">considerations now:</span></p>&#13;
			<h2 id="_idParaDest-125"><strong class="bold"><a id="_idTextAnchor124"/>Data privacy and compliance</strong></h2>&#13;
			<p>GenAI models <a id="_idIndexMarker783"/>often rely on proprietary and sensitive datasets stored in data lakes, data hubs, and data warehouses for training and fine-tuning. In our walkthrough (<a href="B31108_05.xhtml#_idTextAnchor062"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>), we used <strong class="bold">Amazon S3</strong> buckets<a id="_idIndexMarker784"/> to store the datasets used during the fine-tuning process. Depending <a id="_idIndexMarker785"/>on the data classification and regulatory requirements, you must implement appropriate security controls such as data encryption at rest, strict access control policies, and auditing. When accessing these data repositories from GenAI applications running on K8s, ensure that all communications are encrypted using TLS and follow the principle of least privilege by leveraging K8s and related mechanisms. When running GenAI applications on Amazon EKS, you <a id="_idIndexMarker786"/>can<a id="_idIndexMarker787"/> leverage <strong class="bold">IAM Roles for Service Accounts</strong> (<strong class="bold">IRSA</strong>) (<a href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html">https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html</a>) or <strong class="bold">EKS Pod Identity</strong> (<a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html">https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html</a>) features to obtain temporary IAM credentials and access data from other services such as <span class="No-Break">Amazon S3.</span></p>&#13;
			<h3>IAM Roles for Service Accounts</h3>&#13;
			<p>IRSA was <a id="_idIndexMarker788"/>introduced in 2019 to associate fine-grained IAM roles with K8s service accounts. Applications running in K8s Pods can assume the role using their <strong class="bold">service account identity</strong> and <a id="_idIndexMarker789"/>access other AWS services based on the role permissions. </p>&#13;
			<p>The following are the high-level steps involved in the process; refer to the Amazon EKS documentation at <a href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html">https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html</a> for <span class="No-Break">detailed guidance:</span></p>&#13;
			<ol>&#13;
				<li>Set up an OIDC provider in AWS IAM for the Amazon <span class="No-Break">EKS cluster.</span></li>&#13;
				<li>Create fine-grained IAM policies to grant necessary permissions on AWS services. Refer to the security best practices documentation at <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege">https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#grant-least-privilege</a> for guidance on creating <span class="No-Break">IAM policies.</span></li>&#13;
				<li>Create an IAM role with the permission policies from <em class="italic">Step 2</em> and a trust policy for the K8s service account to the <span class="No-Break"><strong class="bold">assume</strong></span><span class="No-Break"> role:</span><pre class="source-code">&#13;
...&#13;
      "Effect": "Allow",&#13;
      "Principal": {&#13;
        "Federated": "arn:aws:iam::&lt;account_id&gt;:oidc-provider/&lt;oidc_provider&gt;"&#13;
      },&#13;
      "Action": "sts:AssumeRoleWithWebIdentity",&#13;
      "Condition": {&#13;
        "StringEquals": {&#13;
          "&lt;oidc_provider&gt;:aud": "sts.amazonaws.com",&#13;
          "&lt;oidc_provider&gt;:sub": <strong class="bold">"system:serviceaccount:&lt;namespace&gt;:&lt;service_account&gt;"</strong>&#13;
...</pre></li>				<li>Create <a id="_idIndexMarker790"/>a K8s service account and annotate it with the IAM role from <span class="No-Break"><em class="italic">Step 3</em></span><span class="No-Break">:</span><pre class="source-code">&#13;
apiVersion: v1&#13;
kind: ServiceAccount&#13;
metadata:&#13;
  name: example-sa&#13;
  namespace: example-ns&#13;
  annotations:&#13;
    <strong class="bold">eks.amazonaws.com/role-arn: arn:aws:iam::&lt;account_id&gt;:role/&lt;iam_role_name&gt;</strong></pre></li>				<li>Deploy the K8s application using the annotated <span class="No-Break">service account:</span><pre class="source-code">&#13;
apiVersion: apps/v1&#13;
kind: Deployment&#13;
metadata:&#13;
  name: example-app&#13;
  ...&#13;
    spec:&#13;
      <strong class="bold">serviceAccount: example-sa</strong>&#13;
      containers:&#13;
        - name: example-container&#13;
...</pre></li>				<li>When an<a id="_idIndexMarker791"/> application uses the AWS SDK to access other AWS resources, the SDK will invoke <strong class="source-inline">AssumeRoleWithWebIdentity</strong>, an AWS <strong class="bold">Security Token Service</strong> (<strong class="bold">STS</strong>) API operation <a id="_idIndexMarker792"/>that allows an application to assume an IAM role using a trusted web identity token, instead of long-lived access keys or IAM users, to fetch temporary <span class="No-Break">IAM credentials.</span><p class="list-inset"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em> summarizes <span class="No-Break">these steps:</span></p></li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer072" class="IMG---Figure">&#13;
					<img src="image/B31108_09_3.jpg" alt="Figure 9.3 – Overview of IRSA" width="1650" height="812"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Overview of IRSA</p>&#13;
			<p>This illustrates <a id="_idIndexMarker793"/>how IAM roles are securely assumed by Pods in an Amazon EKS cluster using IRSA and the <strong class="source-inline">AssumeRoleWithWebIdentity</strong> (<a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html">https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html</a>) mechanism. When a Pod associated with an annotated service account is created, the Pod Identity webhook running in the EKS control plane mutates the Pod specification to mount the projected service account token. The AWS SDK running in the Pod then uses that token to call AWS STS using the <strong class="source-inline">AssumeRoleWithWebIdentity</strong> API. STS verifies the token against the OIDC provider, checks the IAM role’s trust policy, and returns temporary AWS credentials, which the Pod uses to securely access other <span class="No-Break">AWS resources.</span></p>&#13;
			<p>Next, we will cover the recently introduced <strong class="bold">EKS Pod Identity</strong> feature, which further simplifies the IAM <span class="No-Break">permission process.</span></p>&#13;
			<h3>Amazon EKS Pod Identity</h3>&#13;
			<p>In 2023, AWS <a id="_idIndexMarker794"/>introduced the EKS Pod Identity <a id="_idIndexMarker795"/>feature as an evolution to IRSA to streamline the experience of setting up IAM permissions for K8s applications. It removed a lot of underlying complexities of IRSA, such as setting up OIDC providers in IAM, complex trust policies, annotating service accounts, and so on. EKS Pod Identity introduced new APIs to create Pod Identity associations between K8s service accounts and IAM roles, thus<a id="_idIndexMarker796"/> eliminating the need for OIDC providers, service account annotations, and so on. The high-level steps involved are <span class="No-Break">as follows:</span></p>&#13;
			<ol>&#13;
				<li>Install <strong class="source-inline">eks-pod-identity-agent deamonset</strong> on the <span class="No-Break">EKS cluster.</span></li>&#13;
				<li>Create fine-grained IAM policies granting necessary permissions on <span class="No-Break">AWS services.</span></li>&#13;
				<li>Create an IAM role with the permission policies from <em class="italic">Step 2</em> and a trust policy for the EKS Pod Identity principal to the <span class="No-Break">assume role:</span><pre class="source-code">&#13;
...&#13;
            "Effect": "Allow",&#13;
            "Principal": {&#13;
                <strong class="bold">"Service": "pods.eks.amazonaws.com"</strong>&#13;
            },&#13;
            "Action": [&#13;
                "sts:AssumeRole",&#13;
                "sts:TagSession"&#13;
...</pre></li>				<li>Create a <a id="_idIndexMarker797"/>Pod Identity association between the IAM role and the K8s <span class="No-Break">service account:</span><pre class="source-code">&#13;
aws eks create-pod-identity-association --cluster-name my-cluster --role-arn arn:aws:iam::&lt;account_id&gt;:role/my-role --namespace &lt;namespace&gt; --service-account &lt;service_account&gt;</pre></li>				<li>Deploy the K8s application using the <span class="No-Break">service account:</span><pre class="source-code">&#13;
apiVersion: apps/v1&#13;
kind: Deployment&#13;
metadata:&#13;
  name: example-app&#13;
  ...&#13;
    spec:&#13;
      <strong class="bold">serviceAccount: example-sa</strong>&#13;
      containers:&#13;
        - name: example-container&#13;
...</pre></li>			</ol>&#13;
			<p>EKS Pod Identity also introduced support for session tags to the temporary credentials assigned to each Pod, including attributes such as the cluster name, namespace, Pod UID, service account name, and so on. These tags allow administrators to configure a single IAM role <a id="_idIndexMarker798"/>that can be used across various <a id="_idIndexMarker799"/>service accounts, granting or restricting access to AWS resources based on matching tags. By incorporating role session tags, organizations can create more granular security boundaries between clusters and workloads, while continuing to leverage the same IAM roles <span class="No-Break">and policies.</span></p>&#13;
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Secure model endpoints</h2>&#13;
			<p>Before we<a id="_idIndexMarker800"/> talk about securing GenAI model endpoints, we should secure the fine-tuned model artifacts, model weights, and so on. After the fine-tuning process, you can securely store those model artifacts in object store services such as Amazon S3 using appropriate access controls, or package them along with the container image and push it to the container registry. You can securely source the credentials using one of the previously discussed approaches (IRSA or EKS Pod Identity) to access the respective <span class="No-Break">AWS services.</span></p>&#13;
			<p>Once the models are<a id="_idIndexMarker801"/> built, <strong class="bold">inference endpoints</strong> are created by deploying them as K8s deployments/Pods and exposing them via K8s Service or Ingress objects. Securing the model endpoints starts by implementing robust network and API-level protection. Enforce TLS for all communications to ensure data is encrypted in transit and verify the authenticity of clients and services using appropriate authentication methods. You can create the TLS endpoints by issuing or importing TLS certificates in <a id="_idIndexMarker802"/>the <strong class="bold">AWS Certificate Manager</strong> (<strong class="bold">ACM</strong>) (<a href="https://aws.amazon.com/certificate-manager/">https://aws.amazon.com/certificate-manager/</a>) service and deploying them on the AWS <strong class="bold">Application Load Balancer</strong> (<strong class="bold">ALB</strong>) or <strong class="bold">Network Load Balancer</strong> (<strong class="bold">NLB</strong>) resources. You can use annotations, as shown in the following code<a id="_idIndexMarker803"/> snippet, to<a id="_idIndexMarker804"/> create a secure port such as <strong class="source-inline">443</strong> and deploy TLS certificates from ACM on the K8s load <span class="No-Break">balancer service:</span></p>&#13;
			<pre class="source-code">&#13;
apiVersion: v1&#13;
kind: Service&#13;
metadata:&#13;
  name: example-service&#13;
  annotations:&#13;
    service.beta.kubernetes.io/aws-load-balancer-type: "external"&#13;
    # Reference the ACM certificate ARN for TLS termination at the load balancer&#13;
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: <strong class="bold">"arn:aws:acm:us-east-1:&lt;account_id&gt;:certificate/&lt;certificate_id&gt;"</strong>&#13;
    # The port(s) that should use SSL/TLS&#13;
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: <strong class="bold">"443"</strong>&#13;
spec:&#13;
  type: LoadBalancer&#13;
...</pre>			<p>Similarly, you<a id="_idIndexMarker805"/> can apply the annotations to a K8s Ingress resource backed by the AWS ALB to create an HTTPS listener secured with a TLS certificate from ACM, as shown in the following <span class="No-Break">code snippet:</span></p>&#13;
			<pre class="source-code">&#13;
apiVersion: networking.k8s.io/v1&#13;
kind: Ingress&#13;
metadata:&#13;
  name: example-ingress&#13;
  annotations:&#13;
    # Define which ports the ALB should listen on; here we set HTTPS on port 443&#13;
    alb.ingress.kubernetes.io/listen-ports: <strong class="bold">'[{"HTTPS":443}]'</strong>&#13;
    # The ARN of the ACM certificate for TLS termination&#13;
    alb.ingress.kubernetes.io/certificate-arn: <strong class="bold">"arn:aws:acm:us-east-1:&lt;account_id&gt;:certificate/&lt;certificate_id&gt;"</strong>&#13;
...</pre>			<p>Additionally, you can <a id="_idIndexMarker806"/>attach <strong class="bold">AWS WAF</strong> (<a href="https://aws.amazon.com/waf/">https://aws.amazon.com/waf/</a>) to the AWS ALB (K8s Ingress resource) to protect the model endpoints against common attack vectors, including injection attacks, malicious content inputs, and so on. You can use the following annotation to attach AWS WAF with <span class="No-Break">AWS ALB.</span></p>&#13;
			<pre class="source-code">&#13;
alb.ingress.kubernetes.io/wafv2-acl-arn: arn:aws:wafv2:us-west-2:xxxxx:regional/webacl/xxxxxxx/yyyyyyyyy</pre>			<p>In this section, we explored best practices for deploying GenAI workloads in K8s. We looked at the IRSA and EKS Pod Identity features to securely provide temporary IAM credentials to K8s applications. This is particularly important for GenAI applications, as it ensures secure, least-privilege access to sensitive training data or model artifacts stored in Amazon S3. We <a id="_idIndexMarker807"/>also looked at techniques for protecting model endpoints, including enforcing TLS for encrypted communications and integrating a WAF to defend against common attack vectors. In the next section, we will implement these security best practices in our <span class="No-Break">chatbot application.</span></p>&#13;
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Implementing security best practices in a chatbot app</h1>&#13;
			<p>In this section, we<a id="_idIndexMarker808"/> will implement the security best practices discussed in the previous sections in our e-commerce chatbot application. We already implemented some of these in previous chapters, such as IRSA in <a href="B31108_05.xhtml#_idTextAnchor062"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, and K8s network policies in <a href="B31108_08.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. Let’s <span class="No-Break">get started:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Container image encryption</strong>: Amazon ECR stores container images in Amazon S3 buckets that ECR manages and, by default, uses the server-side encryption feature of S3 to encrypt the data at rest. It uses the <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>) encryption<a id="_idIndexMarker809"/> algorithm using encryption keys managed by the S3 service. <p class="list-inset">We can verify this on the ECR repositories we created using the following <span class="No-Break">AWS command:</span></p><pre class="source-code">&#13;
<strong class="bold">$ aws ecr describe-repositories --repository-names my-llama-finetuned --query 'repositories[0].encryptionConfiguration.encryptionType' --output text</strong>&#13;
<strong class="bold">AES256</strong></pre><p class="list-inset">Additionally, you<a id="_idIndexMarker810"/> can use AWS KMS to create customer-managed KMS keys and use them for encrypting the container images at rest. To achieve this, use the following Terraform code, which creates a new KMS customer-managed key with an alias of <strong class="source-inline">ecr-kms-key</strong> and configures the <strong class="source-inline">sample-app-repo</strong><strong class="bold"> </strong>ECR repository to use it <span class="No-Break">for encryption:</span></p><pre class="source-code"><strong class="bold">resource "aws_kms_key" "</strong><strong class="bold">ecr_kms_key</strong><strong class="bold">" {</strong>&#13;
<strong class="bold">  deletion_window_in_days = 7</strong>&#13;
<strong class="bold">  enable_key_rotation = true</strong>&#13;
<strong class="bold">}</strong>&#13;
<strong class="bold">resource "aws_kms_alias" "ecr_kms_alias" {</strong>&#13;
<strong class="bold">  </strong><strong class="bold">name = "alias/ecr-kms-key"</strong>&#13;
<strong class="bold">  target_key_id = aws_kms_key.ecr_kms_key.key_id</strong>&#13;
<strong class="bold">}</strong>&#13;
<strong class="bold">resource "aws_ecr_repository" "sample-app-repo" {</strong>&#13;
<strong class="bold">  name = "sample-app-repo"</strong>&#13;
<strong class="bold">  encryption_configuration {</strong>&#13;
<strong class="bold">    </strong><strong class="bold">encryption_type = "KMS"</strong>&#13;
<strong class="bold">    kms_key  = aws_kms_key.ecr_kms_key.arn</strong>&#13;
<strong class="bold">  }</strong>&#13;
<strong class="bold">}</strong></pre></li>				<li><strong class="bold">Tag immutability</strong>: This <a id="_idIndexMarker811"/>ensures that<a id="_idIndexMarker812"/> once a container image is pushed to an ECR repository, its tag cannot be overwritten. This practice prevents accidental or malicious updates to your application images, ensuring consistency across deployments. You can enable this by setting the <strong class="source-inline">image_tag_mutability</strong> attribute to <strong class="source-inline">IMMUTABLE</strong> in the <strong class="source-inline">ecr.tf</strong> file, as shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">&#13;
resource "aws_ecr_repository" "my-llama-finetuned" {&#13;
  name = "my-llama-finetuned"&#13;
  <strong class="bold">image_tag_mutability = "IMMUTABLE"</strong>&#13;
}</pre></li>				<li><strong class="bold">Container image scanning</strong>: Enable the enhanced image scanning feature of Amazon ECR to automatically detect vulnerabilities in the container images. Add the following code snippet to the <strong class="source-inline">ecr.tf</strong> file, which enables enhanced scanning on the <strong class="source-inline">my-llama-finetuned</strong> ECR repository in our AWS account. Alternatively, you can download the source code from the GitHub repository at <a href="https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf">https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/ecr.tf</a> <p class="list-inset">This configuration ensures that images are scanned both <a id="_idIndexMarker813"/>when they are<a id="_idIndexMarker814"/> pushed and continuously thereafter for any <span class="No-Break">new vulnerabilities:</span></p><pre class="source-code">&#13;
resource "aws_ecr_registry_scanning_configuration" "ecr_scanning_configuration" {&#13;
  scan_type = "<strong class="bold">ENHANCED</strong>"&#13;
  rule {&#13;
    scan_frequency = "<strong class="bold">CONTINUOUS_SCAN</strong>"&#13;
    repository_filter {&#13;
      filter      = "my-llama-finetuned"&#13;
      filter_type = "WILDCARD"&#13;
    }&#13;
  }&#13;
  rule {&#13;
    scan_frequency = "<strong class="bold">SCAN_ON_PUSH</strong>"&#13;
    repository_filter {&#13;
      filter      = "my-llama-finetuned"&#13;
      filter_type = "WILDCARD"&#13;
    }&#13;
  }&#13;
}</pre><p class="list-inset">Run the following Terraform commands to apply this configuration in your <span class="No-Break">AWS account:</span></p><pre class="source-code"><strong class="bold">$ terraform plan</strong>&#13;
<strong class="bold">$ terraform apply -auto-approve</strong></pre><p class="list-inset">Once applied, Amazon ECR will continuously scan the container images pushed to the <strong class="source-inline">my-llama-finetuned</strong><strong class="bold"> repository and display the vulnerabilities in the </strong><span class="No-Break"><strong class="bold">AWS console.</strong></span></p></li>				<li><strong class="bold">Host security</strong>: Harden the security of the worker nodes by using a purpose-built operation system <a id="_idIndexMarker815"/>such as <a id="_idIndexMarker816"/>Bottlerocket. This includes only the essential software required to run containers and ensures that the underlying software is always secure. It also improves the node start-up time from ~1.5 minutes to 20 seconds, based on a customer case study (<a href="https://aws.amazon.com/bottlerocket/">https://aws.amazon.com/bottlerocket/</a>). Additionally, configure the worker nodes to use the latest version of IMDSv2 (<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html</a>) to limit access to sensitive metadata. The following code snippet highlights the use of Bottlerocket EKS AMIs and IMDSv2; the complete source code is available in the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf"><span class="No-Break">https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/eks.tf</span></a><span class="No-Break">:</span><pre class="source-code">&#13;
module "eks" {&#13;
  source = "terraform-aws-modules/eks/aws"&#13;
  ...&#13;
  eks_managed_node_groups = {&#13;
    eks-mng = {&#13;
      <strong class="bold">ami_type = "BOTTLEROCKET_x86_64"</strong>&#13;
<strong class="bold">      metadata_options {</strong>&#13;
<strong class="bold">        http_endpoint = "enabled"</strong>&#13;
<strong class="bold">        http_tokens = "required"</strong>&#13;
<strong class="bold">        http_put_response_hop_limit = 1</strong>&#13;
<strong class="bold">      }</strong>&#13;
    ...&#13;
    eks-gpu-mng = {&#13;
      <strong class="bold">ami_type = "BOTTLEROCKET_x86_64_NVIDIA"</strong>&#13;
...</pre></li>				<li><strong class="bold">K8s Pod Security Standards</strong>: Implementing K8s Pod Security Standards is critical to ensuring your workloads operate with the least privilege, thereby reducing the <a id="_idIndexMarker817"/>risk of privilege escalation and container escapes. Since our chatbot application is deployed in the default namespace, we can use the following command to enforce a baseline security policy while receiving warnings for more <span class="No-Break">restrictive settings:</span><pre class="source-code">&#13;
<strong class="bold">$ kubectl label namespace default pod-security.kubernetes.io/enforce=baseline pod-security.kubernetes.io/warn=restricted pod-security.kubernetes.io/audit=restricted</strong></pre><p class="list-inset">Test the enforced<a id="_idIndexMarker818"/> policy by attempting to run a pod with privileged settings using the <span class="No-Break">following command:</span></p><pre class="source-code"><strong class="bold">$ kubectl run pss-demo --image=nginx --privileged</strong>&#13;
<strong class="bold">Error from server (Forbidden): pods "pss-demo" is forbidden: violates PodSecurity "baseline:latest": privileged (container "pss-demo" must not set securityContext.privileged=true)</strong></pre><p class="list-inset">The preceding error confirms that the baseline policy is effectively preventing the creation of Pods with <span class="No-Break">elevated privileges.</span></p></li>				<li><strong class="bold">K8s Secrets management</strong>: A K8s Secret is an object that is designed to store sensitive data such as API Keys, passwords, TLS certificates, and so on. Using K8s Secrets means you don’t have to embed confidential information directly in your deployment manifests. In our setup, we included a Hugging Face access token in the K8s manifest when deploying the fine-tuning job and <strong class="source-inline">my-llama-finetuned</strong> inference endpoint. In this walkthrough, we’ll enhance security by storing the Hugging Face token in AWS Secrets Manager. We’ll then use <strong class="source-inline">secrets-store-csi-driver</strong> to dynamically retrieve and inject the secret into the K8s Pod during creation. Let’s <span class="No-Break">get started:</span><ol><li class="upper-roman">Store the<a id="_idIndexMarker819"/> Hugging Face<a id="_idIndexMarker820"/> access token in AWS Secrets Manager and run the following command to create a secret in your AWS account. Replace the value with your access token created in the Hugging <span class="No-Break">Face portal:</span><pre class="source-code">&#13;
<strong class="bold">$ export HUGGING_FACE_TOKEN=&lt;&lt;Your Token goes here&gt;&gt;</strong>&#13;
<strong class="bold">$ aws secretsmanager create-secret --name hugging-face-secret --secret-string "$HUGGING_FACE_TOKEN"</strong></pre></li><li class="upper-roman">Deploy the <strong class="source-inline">secrets-store-csi-driver</strong> and <strong class="source-inline">secrets-store-csi-provider-aws</strong> add-ons in the EKS cluster to integrate external secret stores with K8s via<a id="_idIndexMarker821"/> a <strong class="bold">Container Storage Interface</strong> (<strong class="bold">CSI</strong>) volume. These add-ons allow K8s to mount multiple secrets, keys, and certificates stored in enterprise-grade external secrets stores directly into your Pods. Specifically, <strong class="source-inline">secrets-store-csi-provider-aws</strong> integrates AWS Secrets Manager and AWS Systems Manager Parameter Store with Kubernetes. To set up these add-ons in your EKS cluster, download the <strong class="source-inline">addons.tf</strong> file from the GitHub repository at <a href="https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/addons.tf">https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/addons.tf</a> and run the <span class="No-Break">following commands:</span><pre class="source-code"><strong class="bold">$ terraform init</strong>&#13;
<strong class="bold">$ terraform plan</strong>&#13;
<strong class="bold">$ terraform apply -auto-approve</strong></pre><p class="list-inset">You can confirm the installation by listing the DaemonSets in the <strong class="source-inline">kube-system</strong> namespace using the following command; you will notice <strong class="source-inline">secrets-store-csi-driver</strong> and <strong class="source-inline">secrets-store-csi-driver-provider-aws</strong> in <span class="No-Break">the output:</span></p><pre class="source-code"><strong class="bold">$ kubectl get ds -n kube-system</strong>&#13;
<strong class="bold">NAME</strong>&#13;
<strong class="bold">secrets-store-csi-driver</strong>&#13;
<strong class="bold">secrets-store-csi-driver-provider-aws</strong></pre></li><li class="upper-roman">Next, create <a id="_idIndexMarker822"/>an IAM role with<a id="_idIndexMarker823"/> permission policies based on least privilege access principles granting read access to only the Hugging Face secret. Once the role is created, associate it with the K8s service account so that the <strong class="source-inline">my-llama-finetuned</strong> K8s Pod can receive temporary IAM credentials using the EKS Pod Identity feature. To set up these resources, download the <strong class="source-inline">iam.tf</strong> file from the GitHub repository at <a href="https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/iam.tf">https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/iam.tf</a> and run the <span class="No-Break">following commands:</span><pre class="source-code"><strong class="bold">$ terraform init</strong>&#13;
<strong class="bold">$ terraform plan</strong>&#13;
<strong class="bold">$ terraform apply -auto-approve</strong></pre><p class="list-inset">You can verify the Pod Identity association using the following AWS command, which will return the association ID, service account, and namespace in <span class="No-Break">the response:</span></p><pre class="source-code"><strong class="bold">$ aws eks list-pod-identity-associations --cluster-name eks-demo --query "associations[?serviceAccount=='my-llama-sa']"</strong></pre></li><li class="upper-roman">To use <strong class="source-inline">secrets-store-csi-driver</strong>, we need to configure <strong class="source-inline">SecretProviderClass</strong>, a custom Kubernetes resource that defines how <strong class="source-inline">secrets-store-csi-driver</strong> should connect to and retrieve secrets from external providers such as AWS Secrets Manager. Let’s create one for our setup to retrieve <strong class="source-inline">hugging-face-secret</strong> from AWS Secrets Manager. To create this, download the <strong class="source-inline">secret-provider-class.yaml</strong> file from the GitHub repository at <a href="https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/inference/secret-provider-class.yaml">https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/inference/secret-provider-class.yaml</a> and run the <span class="No-Break">following command:</span><pre class="source-code"><strong class="bold">$ kubectl apply -f secret-provider-class.yaml</strong></pre></li><li class="upper-roman">Finally, redeploy the <strong class="source-inline">my-llama-finetuned</strong> application using the <strong class="source-inline">my-llama-sa</strong> service account. This approach securely injects the AWS Secrets Manager <a id="_idIndexMarker824"/>secret into your<a id="_idIndexMarker825"/> application container without exposing it in the Kubernetes manifest. To redeploy the app, download the <strong class="source-inline">finetuned-inf-deploy.yaml</strong> file from the GitHub repository at <a href="https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/inference/finetuned-inf-deploy.yaml">https://github.com/PacktPublishing/Kubernetes-for-Generative-AI-Solutions/blob/main/ch9/inference/finetuned-inf-deploy.yaml</a>. Then, update the ECR image name with your own and execute the <span class="No-Break">following command:</span><pre class="source-code"><strong class="bold">$ kubectl apply -f finetuned-inf-deploy.yaml</strong></pre><p class="list-inset">You can confirm that the secret is properly injected by checking the Pod status or by executing the <strong class="source-inline">env</strong> command inside the Pod using the <span class="No-Break">following commands:</span></p><pre class="source-code"><strong class="bold">$ kubectl get pods -l app.kubernetes.io/name=my-llama-finetuned</strong>&#13;
<strong class="bold">$ kubectl exec -it $(kubectl get pods -l app.kubernetes.io/name=my-llama-finetuned -o jsonpath="{.items[0].metadata.name}") -- env | grep HUGGING_FACE</strong></pre></li></ol></li>			</ul>&#13;
			<p>In this section, we implemented multiple security best practices in our chatbot application running on EKS. We ensured ECR image immutability to prevent image tag overwrites, hardened host security using Bottlerocket AMIs, enabled IMDSv2, and applied Pod Security Standards to enforce least privilege execution. Additionally, we implemented encryption at rest, integrated vulnerability scanning to our container images in Amazon ECR, and enhanced Kubernetes secrets management through encrypted secrets and external solutions such as AWS Secrets Manager <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">secrets-store-csi-driver</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Summary</h1>&#13;
			<p>In this chapter, we covered the security best practices for deploying applications on K8s, with a focus on defense in depth and securing key aspects of the container ecosystem, including supply chain, host, network, runtime, and <span class="No-Break">secret management.</span></p>&#13;
			<p>Defense in depth is a concept that involves multiple layers of security to safeguard against different <span class="No-Break">attack vectors.</span></p>&#13;
			<p>Containers, being portable, introduce unique risks that require proactive measures at every lifecycle stage, from build to runtime. Supply chain security emphasizes securing container images during the build, test, and storage phases. Host security focuses on safeguarding the underlying server hosting containers. Runtime security ensures secure container operation by limiting privileges, enforcing resource limits, and using tools such as Falco for anomaly detection. Network security leverages namespaces, network policies, and service meshes such as Istio for segmentation and encryption. Secret management is essential for securely handling sensitive information. IRSA and EKS Pod Identity features can be used to securely provide temporary IAM credentials to K8s applications. GenAI workloads can leverage these features to securely access sensitive training data or export model artifacts in Amazon S3. GenAI model endpoints can be protected against common vectors using WAF solutions and enforcing TLS for encrypted communications. By integrating these best practices, K8s deployments can achieve robust security against <span class="No-Break">evolving threats.</span></p>&#13;
			<p>This chapter focused on K8s security best practices; in the next chapter, we will start diving into GPU resource optimization for K8s, which is one of the most expensive resources for <span class="No-Break">GenAI applications.</span></p>&#13;
		</div>&#13;
	</div></div></body></html>