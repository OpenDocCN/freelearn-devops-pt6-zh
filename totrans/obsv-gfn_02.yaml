- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Instrumenting Applications and Infrastructure
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具化应用程序和基础设施
- en: The previous chapter introduced observability, with examples outside of the
    computing world to give you a generic understanding of the subject. In this chapter,
    we’ll build on those examples by providing a high-level overview of both application
    and infrastructure instrumentation. We will look at the data created by systems
    and how that fits into the different telemetry types and common protocols in use.
    We will also explore widely used libraries for popular programming languages that
    simplify instrumenting applications. To finish, we will cover more traditional
    telemetry collection from infrastructure components, operating systems, and network
    devices. This will give you insight into the components that are still in operation
    today that run applications and Kubernetes workloads. This chapter is aimed at
    readers of all technical abilities and no specific technologies are needed. An
    understanding of observability terminology (for example, logs, metrics, traces,
    and instrumentation) is helpful. It aims to provide an overview of the technology
    space and act as a valuable resource that you can quickly reference when you are
    working with your observability solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了可观察性，并通过计算机领域外的示例帮助你对该主题有了一个通用的理解。在本章中，我们将在这些示例的基础上，提供应用程序和基础设施工具化的高级概述。我们将查看系统生成的数据，并了解这些数据如何与不同的遥测类型和常用协议相适应。我们还将探索用于流行编程语言的广泛使用的库，这些库简化了应用程序的工具化过程。最后，我们将涵盖来自基础设施组件、操作系统和网络设备的更传统的遥测收集。这将使你了解今天仍在运行的应用程序和Kubernetes工作负载的组成部分。本章面向各类技术能力的读者，且不需要特定的技术背景。了解可观察性术语（例如：日志、指标、跟踪和工具化）将有所帮助。其目的是提供技术领域的概述，并作为一个有价值的资源，当你在使用可观察性解决方案时，可以快速查阅。
- en: 'In this chapter, we explore the following introductory sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下介绍性内容：
- en: Common log formats
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见日志格式
- en: Metrics protocols and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标协议和最佳实践
- en: Tracing protocols and best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪协议和最佳实践
- en: Using libraries to instrument efficiently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库进行高效的工具化
- en: Infrastructure data technologies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施数据技术
- en: Common log formats
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见日志格式
- en: Log files are a standard component of computer systems and an essential tool
    for software developers and operators – in our example, Diego and Ophelia, respectively.
    Logs support performance and capacity monitoring in infrastructure, bug detection
    in software, root cause analysis, user behavior tracking, and more. There is no
    perfect recipe for logs and as such, it does not matter what your logs look like,
    though following certain guidelines will help your future self when you need to
    analyze logs. In this section, we will learn about different log formats and how
    the data can be used. Log formats are the definition of what a log file looks
    like and should explain how the data can be interpreted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件是计算机系统的标准组件，是软件开发人员和运维人员（在我们的例子中分别是Diego和Ophelia）必不可少的工具。日志支持基础设施的性能和容量监控、软件中的错误检测、根本原因分析、用户行为追踪等功能。没有完美的日志格式，因此日志的外观并不重要，但遵循某些指南会在你需要分析日志时为未来的自己带来帮助。在本节中，我们将了解不同的日志格式以及如何使用数据。日志格式定义了日志文件的外观，并应解释如何解读数据。
- en: Log formats usually identify if they are structured or unstructured, the data
    types used in them, and if any encoding or delimitation is being used. We’ll explore
    structure first and then look at example log formats in more detail in the following
    sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 日志格式通常会标明它们是结构化还是非结构化，所使用的数据类型，以及是否使用了任何编码或分隔符。我们将首先探索结构化日志格式，然后在接下来的章节中更详细地查看示例日志格式。
- en: Structured, semi-structured, and unstructured logging
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化、半结构化和非结构化日志
- en: As mentioned previously, it does not matter what your logs look like and they
    can come in structured, semi-structured, or unstructured formats. However, when
    designing and building observability solutions, it’s important to understand the
    log formats you are working with. This ensures that you can ingest, parse, and
    store the data in a way that it can be used effectively. If you familiarized yourself
    with the personas in [*Chapter 1*](B18277_01.xhtml#_idTextAnchor018), you have
    an awareness of who they will be used by and for what purpose.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，日志的格式并不重要，您可以使用结构化、半结构化或非结构化的格式。但是，在设计和构建可观察性解决方案时，理解您正在使用的日志格式非常重要。这确保了您可以有效地导入、解析和存储数据。如果您已经熟悉[*第1章*](B18277_01.xhtml#_idTextAnchor018)中的角色，您会知道这些日志将由谁使用以及用途是什么。
- en: Structured logging
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构化日志
- en: '`name=Diego` or `city=Berlin`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`name=Diego` 或 `city=Berlin`。'
- en: 'Here is an example of a structured log format:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是结构化日志格式的一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An additional benefit of structured logging is that you can validate the conformation
    of the data to a schema with tools such as JSON schema. This opens up the possibility
    of making version control changes to the schema, which is where logs and event
    bus technology overlap.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化日志的一个额外好处是，您可以使用诸如 JSON schema 等工具验证数据与架构的一致性。这为对架构进行版本控制更改提供了可能性，而这正是日志和事件总线技术交集的地方。
- en: Semi-structured logging
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 半结构化日志
- en: '**Semi-structured logs** aim to bridge the gap between unstructured and structured
    and, as a result, can be quite complicated. They are designed to be easy for humans
    to read but also have a schema that makes it possible for machines to process
    them too. They have complex field and event separators and usually come with a
    defined pattern to aid with ingesting and parsing. Parsing is usually done using
    regular expressions or other code.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**半结构化日志**旨在弥合非结构化和结构化之间的差距，因此可能会相当复杂。它们设计上易于人类阅读，同时也有架构使机器能够处理它们。它们具有复杂的字段和事件分隔符，并且通常带有定义的模式以帮助导入和解析。解析通常使用正则表达式或其他代码完成。'
- en: Unstructured logging
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非结构化日志
- en: '**Unstructured logging** typically refers to log entries that are presented
    in a textual format that can easily be read by humans but is difficult for machines
    to process. They are often color-coded with blank spaces to improve presentation
    and readability. It is this presentation that creates issues for machines to process
    the logs. Parsing and splitting the data correctly creates a disassociation between
    events and their identifying metadata. An unstructured log will require some custom
    parsing, requiring intimate knowledge of the data and often creating additional
    work for the engineer (*Ophelia*) when ingesting data. This also creates technical
    liability; the dependency on the log remaining the same restricts developers from
    changing logs or runs the risk of parsing and reporting on unstructured logs prone
    to breaking.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**非结构化日志**通常指的是以文本格式呈现的日志条目，这种格式易于人类阅读，但对机器处理来说较为困难。它们通常通过颜色编码和空格来改善展示和可读性。正是这种展示方式使得机器难以处理这些日志。正确解析和拆分数据会导致事件与其标识元数据之间的断裂。非结构化日志需要一些定制的解析，这通常需要对数据有深入的了解，并且在导入数据时常常会给工程师（*Ophelia*）带来额外的工作。这也带来了技术上的责任；对日志保持一致性的依赖限制了开发者对日志的修改，或者有可能导致解析和报告非结构化日志时容易出现故障。'
- en: To aid the ability of machines to process unstructured logs, encapsulation prevents
    entries such as stack traces from splitting at an inappropriate location.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助机器处理非结构化日志，封装防止像堆栈跟踪这样的条目在不适当的位置被拆分。
- en: 'The following is an example of a multiline log, with a naive encapsulation
    that looks for line breaks; this will appear in logging systems as four distinct
    events:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个多行日志的示例，采用了寻找换行符的简单封装；这将在日志系统中显示为四个独立的事件：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With encapsulation based on the timestamp at the start of the event, this will
    be stored correctly for searching.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件开始时时间戳的封装，将确保日志正确存储以便检索。
- en: In the following section, we will explore common log formats found in today’s
    systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨今天系统中常见的日志格式。
- en: Sample log formats
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例日志格式
- en: 'Many log formats have been used in computer systems. All of these formats have
    a common goal of presenting a standard structure or set of fields for recording
    important information about the activity of a computer system. The following table
    aims to provide easy reference for some of the more notable ones:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **Overview** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| **Common Event** **Format** (**CEF**) | CEF is an open logging and auditing
    format from ArcSight that aims to provide a simple interface to record security-related
    events. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| **NCSA** **Common Log** **Format** (**CLF**) | The NCSA CLF is historically
    used on web servers to record information about requests made to the server. This
    format has been extended by the CLF to include additional information about the
    browser (user-agent) and the referer. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| **W3C Extended Log** **File Format** | W3C Extended Log File Format is a
    log format commonly used by Windows Internet Information Services servers (web
    servers). |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| **Windows** **Event Log** | Windows Event Log is the standard log format
    used by the Windows operating system. These logs record events that occur on the
    system and are categorized System, Application, Security, Setup, and Forwarded
    events. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| **JavaScript Object** **Notation** (**JSON**) | JSON is an open standard
    file format that is very useful for easily parsing structured log events. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| **Syslog** | Syslog is a standard that’s used across many hardware devices
    such as networking, compute, and storage, and is used by the Linux kernel for
    logging. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| **Logfmt** | Logfmt does not have a defined standard but is a widely used
    form of human-readable structured logging. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – Log format overview
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at these formats in greater detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: CEF
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developed by ArcSight to fulfill the **Security Information and Event Management**
    (**SIEM**) use case, the CEF is a structured text-based log format. Using UTF-8
    encoding, the format contains a prefix, a CEF header, and a body containing additional
    enrichment data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the log sections of the CEF format:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '| **Log Section** | **Description** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| Prefix | It combines the event timestamp and source hostname. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| CEF header | It combines the following pieces of metadata:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Software version
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor name
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product name
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product version
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product event class identification code
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event name
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event severity
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '| Body | It contains a list of key-value pairs |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: Table 2.2 – CEF format
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example CEF log event:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: NCSA CLF
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As one of the oldest log formats used by web servers, the NCSA CLF has for a
    long time been the most common and well-known log formats. It has a fixed format
    text-based structure and therefore cannot be customized at all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the NCSA CLF field list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Remote host address
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote log name
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamp
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request and protocol version
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP status code
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bytes sent
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where data is missing from the log, a hyphen acts as a placeholder. Unsupported
    characters are replaced with the `+` symbol.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example NCSA CLF log:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: W3C Extended Log File Format
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: W3C扩展日志文件格式
- en: 'The Microsoft Internet Information Server log format known as W3C is a structured
    yet configurable format. Full control over the included fields ensures log files
    contain the most relevant data. Identification of the information or direction
    of flow is denoted using a string prefix: server (*S*), client (*C*), server to
    client (*SC*), and client to server (*CS*).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的互联网信息服务器日志格式W3C是一种结构化但可配置的格式。完全控制包含的字段，确保日志文件包含最相关的数据。信息或流向的标识通过字符串前缀表示：服务器（*S*）、客户端（*C*）、服务器到客户端（*SC*）和客户端到服务器（*CS*）。
- en: 'Here is the W3C Extended Log File Format field list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是W3C扩展日志文件格式字段列表：
- en: Timestamp
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Client IP
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端IP
- en: Server IP
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器IP
- en: URI-stem
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI主体
- en: HTTP status code
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: Bytes sent
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的字节数
- en: Bytes received
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收的字节数
- en: Time taken
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耗时
- en: Version
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本
- en: 'Here is an example W3C log:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个W3C日志示例：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Microsoft Windows Event Log
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微软Windows事件日志
- en: The Microsoft Windows operating system comes with a built-in complex structured
    logging system that captures data related to specific events on the operating
    system. There are four common Windows event log categories – system, application,
    security, and setup – and an additional special category for forwarded events.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Windows操作系统自带一个复杂的结构化日志系统，用于捕获与操作系统中特定事件相关的数据。Windows事件日志有四个常见的类别——系统、应用程序、安全性和设置——以及一个用于转发事件的特殊类别。
- en: 'Each event log is also one of five different types: information, warning, error,
    success audit, and failure audit. Windows Event Log is one of the most verbose
    log formats in use. It usually includes details such as timestamp, event ID, username,
    hostname, message, and category, making it invaluable in diagnosing problems.
    Windows event IDs are documented and searchable, so you can easily get detailed
    information regarding the log event; they are grouped into categories, narrowing
    down the area where the event occurred, which makes debugging very accurate.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件日志也有五种不同的类型：信息、警告、错误、成功审计和失败审计。Windows事件日志是使用中最详细的日志格式之一。它通常包括时间戳、事件ID、用户名、主机名、消息和类别等详细信息，这些信息在诊断问题时非常有价值。Windows事件ID有文档记录并可搜索，因此你可以轻松获取关于日志事件的详细信息；它们被分为不同的类别，缩小了事件发生的范围，这使得调试非常精确。
- en: 'Here is a trimmed example of Microsoft Windows Event Log:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个修剪过的微软Windows事件日志示例：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JSON
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON
- en: As one of the newer yet most commonly used log formats today, JSON is a structured
    format constructed from multiple key-value pairs. Using JSON, data can be nested
    into different layers while keeping the format easy to read. Additionally, different
    data types can be represented, such as string, number, Boolean, null, object,
    and array.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为今天新兴但最常用的日志格式之一，JSON是一种由多个键值对构成的结构化格式。使用JSON，数据可以嵌套成不同的层次，同时保持格式易于阅读。此外，JSON可以表示不同的数据类型，如字符串、数字、布尔值、空值、对象和数组。
- en: 'Here is an example JSON log file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个JSON日志文件示例：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Syslog
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Syslog
- en: The go-to log format for many years and still widely used, Syslog is a defined
    standard for creating and transmitting logs. The `514` and `6514`, with the latter
    being used for encryption.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog作为许多年来的标准日志格式，并且至今仍被广泛使用，是一种定义好的标准，用于创建和传输日志。`514`和`6514`是常见的端口，后者用于加密。
- en: The Syslog message format combines a standardized header and message holding
    the body of the log.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog消息格式结合了标准化的头部和包含日志正文的消息。
- en: 'Here is an example Syslog log:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Syslog日志示例：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logfmt
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Logfmt
- en: Logfmt is a widely used log format that fits as human readable and structured
    so that computers and people can both read it. A Logfmt-formatted log line consists
    of any number of key-value pairs that can be easily parsed. As there are no standards,
    it is easy to extend and perfect for developers to simply add more key-value pairs
    to the output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Logfmt是一种广泛使用的日志格式，既适合人类阅读又具有结构化，计算机和人类都能读取。Logfmt格式的日志行由任意数量的键值对组成，便于解析。由于没有标准，它很容易扩展，开发人员可以简单地向输出中添加更多键值对。
- en: 'Here is an example Logfmt log:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Logfmt日志示例：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exploring metric types and best practices
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索度量类型和最佳实践
- en: Metrics, along with logs, are an essential tool for software developers (*Diego*)
    and operators (*Ophelia*), providing them with indicators regarding the state
    of applications and systems. Resource usage data is great for monitoring a metric
    that captures numerical data over time. There are many different types of resources
    but some good examples would be CPU or RAM usage, the number of messages in a
    queue, and the number of received HTTP requests. Metrics are frequently generated
    and easily enriched with labels, attributes, or dimensions, making them efficient
    to search and ideal in determining if something is wrong, or different from usual.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'A metric commonly has the following fields:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This uniquely identifies the metric'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data point value(s)**: The data that’s stored varies by metric type'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dimensions**: Additional enrichment labels or attributes that support analysis'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metrics capture the behavior of the data they represent. CPU usage would go
    up and down between 0% and 100% usage, whereas the number of received HTTP requests
    could increase indefinitely. In the following section, we will look at metric
    types, which allow us to capture the behavior of the metric being collected.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Metric types
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Metrics vary in characteristics and structure. There are four common types
    of metrics, from simple single values to more complex values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Counter**: This metric represents the last increment value. This could be
    the incremental change from the last recording or the total increment since the
    recording started.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of this metric:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The number of requests served
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks completed
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors reported
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How the value is reset to zero depends on the protocol used to collect them,
    so it is important to factor this in for your use case. The StatsD implementation
    resets the counter every time the value is flushed, and Prometheus resets the
    counter when the application process restarts.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Gauge**: A gauge metric is a snapshot of state and can be used to take a
    measure of something reporting continuously. As such, it is usually made more
    useful by aggregating with sum, average, minimum, or maximum over a certain period.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of this metric:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Temperature
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Items in queue
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk space used
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of concurrent requests
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Like counter, the definitions for gauge vary in implementation, so be sure to
    verify how the protocol you select will report gauge metrics.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_count`), a sum of all the values of the measurements (`_sum`), and several
    buckets that have a count of events with a measure less than or equal (`le`) to
    a defined value.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definitions can vary in implementation – for example, Prometheus has a `histogram_quantile`
    function that can be used to calculate percentiles from histogram metrics.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_count` and `_sum` metrics and several groupings. Unlike a histogram, these
    groupings are a quantile, and the value represents the value of that quantile
    at the point in time for the measurement. For example, a quantile of 0.99 and
    a value of 3.2148 would indicate that 99% of the sampled data was smaller than
    3.2148.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, definitions can vary in implementation, so work out what your goals are
    from your metrics to ensure the capabilities are supported by your choice of protocol.
    It’s useful to note that, in Prometheus, summary metrics have a significant drawback
    in modern systems as they cannot be aggregated over multiple sources.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: There are some distinct differences between these metric types, as we will discuss
    in the following section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Comparing metric types
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table describes each type in general terms. When querying them,
    this provides a useful reference when approaching metric adoption:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| **Consideration** | **Counter** | **Gauge** | **Histogram** | **Summary**
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| Structure | Simple | Simple | Complex | Complex |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| Can increase and decrease | No | Yes | No | No |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| Is an approximation | No | No | Yes | Yes |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| Can calculate percentiles | No | No | Yes | Yes |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| Can use a rate function | Yes | No | No | No |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| Can be queried with the `prometheus` `histogram_quantile` function | No |
    No | Yes | No |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| Can be aggregated across multiple series | Yes | Yes | Yes | No |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: Table 2.3 – Comparison of metric types
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table provides a few reference examples of the type and values
    expected:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '| **Metric Type** | **Data Field** | **Value** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| **Counter** | Last increment | 15 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| **Gauge** | Last value | 25.4 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| **Histogram** | Min | 0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| Max | 100 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| Count | 10 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| **Interval** | 20 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| 0-20 | 1 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| 20-40 | 2 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| 40-60 | 4 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| 60-80 | 2 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 80-100 | 1 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| **Summary** | Min | 1.2ms |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '|  | Max | 4.23ms |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '|  | Count | 10 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '|  | Sum |  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '|  | **Percentiles/Quantiles** |  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '|  | P90 | 2.98ms |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '|  | P95 | 3.76ms |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '|  | P99 | 4.23ms |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: Table 2.4 – Metric type example data
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at the different types of metrics, let’s look at the different
    technologies used to transmit metrics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Metric protocols
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Metric protocols** are collections of tools and libraries for instrumenting
    applications, data formats to transmit, clients to collect data, and often storage
    and visualization tools. Some common protocols that are in use today are described
    in the following table:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '| **Metric Protocol** | **Features** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| **StatsD** | It supports the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Counters
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gauges
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Histograms
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meters
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '| **DogStatsD** | DogStatsD implements the StatsD protocol and adds a few Datadog-specific
    extensions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Histogram metric type
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service checks
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '| **OpenTelemetry** **Protocol** (**OTLP**) | It supports the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Counters
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gauges
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Histograms
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summaries (legacy support)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '| **Prometheus** | It supports the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Counters
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gauges
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cumulative histograms
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summaries
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.5 – Common metric protocols and their features
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Metrics are very powerful, but some pitfalls can catch people out. Some of these
    can lead to expensive mistakes. To avoid these pitfalls, let’s discuss some best
    practices.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for implementing metrics
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introducing metrics into your services is a very good way to gain a huge amount
    of visibility on how they behave in real situations. The following best practices
    are from our experience with metrics and will help you manage scope creep, cost,
    and linking metrics up with traces:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Set your objectives**: Work out what your objectives are from your metrics.
    We have already spoken about the variation in implementation between metric protocols
    – this can have a big impact if you are expecting to use a metric in a certain
    way and haven’t factored in nuances.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will also help you define **service-level indicators** (**SLIs**) and **service-level
    objectives** (**SLOs**), which will be useful in [*Chapter 9*](B18277_09.xhtml#_idTextAnchor183),
    *Managing Incidents* *Using Alerts*.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Manage cardinality**: Cardinality is generally defined as the number of unique
    elements in a set. High cardinality may provide richer, more useful data, but
    at the cost of monitoring performance impacts or increased storage costs. For
    example, if you dimension your metrics by server name, the sample could be small,
    maybe a few hundred metrics. If we compare this to dimensioning by user, which
    could be in the millions, the increase in the number of metrics produced is exponential.
    This increase has a direct impact on load and storage.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take time to understand the capabilities of the observability backend – things
    such as the billing framework, limitations, storage, and performance.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add context**: The ability to correlate (establish a common identifier) metrics
    with traces has been introduced to Grafana and Open Telemetry recently with exemplars.
    They enable quick visualization and linking between a metric data point and a
    specific trace span, thus giving improved context and detail to your data.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we just discussed, metrics capture numerical data from a single service;
    however, the systems that operate today may consist of multiple services. Distributed
    tracing is a way to gain visibility of the communications between services. Let’s
    take a look at tracing protocols and some best practices regarding them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Tracing protocols and best practices
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tracing**, or as it is more commonly referred to, **distributed tracing**,
    tracks application requests as they are made between services of a system. It
    allows you to follow a single request through an entire system or look at the
    aggregate data over requests to better understand distributed behavior.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This capability provides software developers (*Diego*), operators (*Ophelia*),
    and service managers (*Steven*) with valuable tools that enable an understanding
    of the flow of logic that is essential for troubleshooting. Instrumenting your
    code by adding traces helps you easily pinpoint almost any issue or at least have
    a clear indicator of where the problem could be. **Distributed tracing** uses
    the concepts of spans and traces to capture this data. Let’s examine these in
    more detail.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Spans and traces
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **trace record** is the parent object that represents the data flow or
    execution path through the system being observed. Each **trace** will contain
    one or more **span** records that represent the logical operations. This relationship
    between traces and spans is illustrated in the following figure, in what can be
    thought of as a directed acyclic graph of spans:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 2.1 – Traces and spans](img/B18277_02_1.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Traces and spans
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'A trace is pieced together from multiple spans and would usually report the
    following information:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifier**: Uniquely identifies the trace'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: Describes the overall work being recorded'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timing details**: Provides the start and end timestamps for the complete
    trace'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A span commonly has the following fields:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Trace identifier**: Establishes the trace relationship'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifier**: Uniquely identifies the span'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent span identifier**: Establishes a parent relationship'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: Describes the work being recorded'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timing details**: Provides the start and end timestamps'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trace identifier will be automatically generated if one has not been received
    by the calling operation; each application will pass the trace ID along to the
    next.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The start and end timestamps for the operation help identify which stages are
    taking the most time. You can drill down to identify dependencies on other services
    and how they contribute to the overall trace timings.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Spans can often have additional fields that are specific to the protocol implemented.
    Investigating the options against your use case will help provide the right diagnostics
    for your system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Tracing protocols
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all technology, standards have taken a while to be formalized for tracing,
    and a few protocols have been implemented. Some common protocols that are in use
    today are described in the following table:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protocol Name** | **Features** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| OTLP | It supports the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Additional fields
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span attributes (metadata about the operation)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context propagation
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span events (meaningful point-in-time annotation)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span links (imply a causal relationship between spans)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span kind (additional details supporting the assembly of a trace)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '| Zipkin | It supports the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Additional fields
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span tags (metadata about the operation)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context propagation
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span annotations (such as OTLP events and meaningful point-in-time annotation)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span kind (additional details supporting the assembly of a trace)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '| Jaeger | It supports two formats – Jaeger Thrift and Jaeger Proto – with
    similar characteristics. Jaeger Proto has been discontinued in favor of OTLP.It
    supports the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Additional fields
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span tags (metadata about the operation)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context propagation (Thrift only; Proto does not support this)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span logs (meaningful point-in-time annotation)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span references (imply a causal relationship between spans)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Span kind (similar to OTLP, this is stored as a special type of span tag)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.6 – Distributed tracing protocols and features
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Implementing distributed tracing can be a daunting task, so let’s discuss some
    best practices that will help you avoid common mistakes and issues.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for setting up distributed tracing
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have described how traces will help you with problem resolution.
    However, when producing traces, it’s worth considering the additional system visibility
    against cost and performance impacts. Let’s discuss some of the best practices
    that should be considered when implementing tracing on any application or system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of generating trace information can potentially incur a performance
    overhead at the application level. Mix this with the reduced level of control
    with auto-instrumentation and the problem can increase.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the possible impacts to consider:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Increased latency
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory overhead
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slower startup time
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the more recent observability agents have addressed a lot of the issues
    with configurable options. For example, the OpenTelemetry Collector offers a sampling
    configuration that will submit 0% to 100% of spans to the collection tool. This
    sampling implementation will also notify any downstream services that the parent
    sampled its span so that the full trace will be collected.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Increased network and storage costs can become a factor and need factoring in
    as a limitation when designing your observability solution. However, this does
    depend on your observability backend and if you are doing additional processing
    or filtering when the data is being transmitted.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The mitigation practices are as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**Sampling**: Only sends a percentage of traces'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering**: Restricts which traces are transmitted and stored'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retention**: Sets optimal data storage durations'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure one of the major benefits of tracing is implemented, it is important
    to ensure context propagation is working correctly. Without the relationships
    being established between the operations, spans will be broken across multiple
    traces. Validating and solving this problem will increase the usability and adoption
    of tracing for fast issue resolution.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: With most code, libraries are used so that developers can focus on writing code
    that provides value to the organization. The modern libraries that are available
    will help you instrument quickly so that you can start using the data collected
    from your application. We’ll explore this next.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Using libraries to instrument efficiently
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instrumenting your application code to emit the telemetry of logs, metrics,
    and traces can be complex, time-consuming, and difficult to maintain. There are
    two main approaches to solving this problem – automatic instrumentation and manual
    instrumentation – with a wide selection of SDKs and libraries available to support
    them. Here is a brief overview of them:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic instrumentation**: Automatic instrumentation is the simplest to
    implement but can lack the level of control that’s often required when building
    an observability platform. In a very short space of time, it will provide visibility
    into your application and help you start answering your observability questions.
    Without careful configuration and design, this will lead to other problems such
    as performance and cost issues, and, in the worst case, render the observability
    platform useless.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The approach varies depending on the programming language; for example, code
    manipulation (during compilation or at runtime) is often used with Java, whereas
    monkey patching (updating behavior dynamically at runtime) is often used with
    Python and JavaScript.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Manual instrumentation**: Manual instrumentation can be quite complex, depending
    on the systems being instrumented. It requires an intimate knowledge of the application
    code, with the benefit of allowing you to specify exactly what telemetry you want.
    Additionally, you need to understand the observability API you are working with.
    Though SDKs and libraries have simplified this, a lot of work must be done to
    understand the implementation.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are interested in further reading about application instrumentation,
    there is an excellent section dedicated to the subject in Alex Boten’s book *Cloud-Native
    Observability with OpenTelemetry*, by Packt Publishing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how various libraries approach instrumentation, let’s look
    at some of the common libraries that are used in different languages.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Popular libraries for different programming languages
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There have been many telemetry solutions, SDKs, and libraries over the years;
    however, in more recent history, there has been a concerted effort to align on
    supporting the OpenTelemetry standard. With its goal to provide a set of standardized
    vendor-agnostic SDKs, APIs, and tools for ingesting, transforming, and transporting
    data to an observability backend platform, there are obvious benefits. We will
    look at the OpenTelemetry libraries in this section to focus on where the most
    enhancements are currently. However, investigating what is appropriate for your
    use case is important. One drawback of this concerted development effort is that
    it creates a fast-changing landscape, so you have to pay attention to release
    stability and monitor for changes and improvements.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the available instrumentation libraries:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '| **Language** | **SDKs** **and Libraries** | **Notes** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| JavaScript | OpenTelemetry JavaScript SDK | Multiple resources and examples
    are available that cover Node.js and browser implementations. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| JavaScript | OpenTelemetry JavaScript Contrib | An additional repository
    for OpenTelemetry JavaScript contributions that are not part of the core repository
    and core distribution of the API and the SDK. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| Python | OpenTelemetry Python SDK | At the time of writing, both traces and
    metrics are stable, with logs in an experimental state. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| Python | OpenTelemetry Python Contrib | An additional repository for OpenTelemetry
    Python contributions. At the time of writing, Contrib libraries are in beta and
    active development. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| Java | OpenTelemetry Java SDK | There is a long list of supported libraries
    and frameworks with good documentation to get you started. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| Java | Spring Boot/Micrometer | As of Spring Boot 3, the default exporter
    for Micrometer is OTLP. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: Table 2.7 – Common libraries and SDKs for telemetry
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Applications are only one part of the computer systems we work with today. Our
    infrastructure components, such as switches, servers, Kubernetes clusters, and
    more, are just as important to observe. We’ll discuss how we can do this in the
    next section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure data technologies
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have focused on implementations that work well for
    cloud technologies and containerized platforms. Underneath all of the abstraction
    are physical components, the servers running the workloads, the network and security
    devices handling communications, and the power and cooling components that keep
    things running. These have not dramatically changed over time and neither has
    the telemetry reported by the logs and metrics. Let’s take a look at the common
    infrastructure components and standards used in this area.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Common infrastructure components
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Infrastructure can largely be categorized into some broad categories, as we
    will discuss in the following sections. The types of data you can collect will
    differ on the category of the component.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Compute or bare metal
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Servers are often referred to as **bare metal** or compute; these are physical
    devices that are used for computation. Often, these systems would run virtualized
    operating systems that can collect server telemetry. Usually, you will run an
    agent on the operating system that scrapes metrics or reads log files and then
    transports them to a receiver. The data that’s obtained from server equipment
    can not only help in diagnosing and responding to issues but can help predict
    capacity problems that may arise in the future. Often, these devices can send
    data outside of any virtual operating system as well.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, here are a few telemetry examples that can indicate if a system
    is close to capacity in any area:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: System temperature
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU utilization percent
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall disk space used and remaining
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory usage and free memory
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network devices
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Network and security devices such as switches and firewalls come with the capability
    to send monitoring information via SNMP to a receiver. Firewalls can often send
    Syslog-formatted logs to a receiver. The telemetry provided helps diagnose issues
    with connectivity – for example, latency and throughput are difficult to investigate
    without information from the hardware.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some telemetry examples:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Latency
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughput
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet loss
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandwidth
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power components
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The components that provide power or cooling are often built with the capability
    to emit telemetry over SNMP to a receiver. Some older components will implement
    the Modbus protocol and expose registers that can be read to obtain metrics. The
    telemetry reported at this level is simplistic but essential when you are operating
    your data center. If, for example, you are running on backup power, you need to
    react fast to protect the systems or trigger other mitigation activities.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some telemetry examples:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Power supply state
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup power supply state
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voltage
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wattage
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As infrastructure components have been used for many years, there are some agreed-upon
    standards for data structures and transmission. Let’s look at those original standards
    now.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Common standards for infrastructure components
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few well-established standards that are used by infrastructure
    components that you may need to monitor. These include the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Syslog**: Syslog has been around since the 1980s and is very common in infrastructure
    components. Created as part of the **Sendmail project** by Eric Allman, it was
    quickly adopted and became the standard logging solution on Unix-like platforms.
    It is very popular because of its ease of use. To use Syslog, you need a client
    available to receive the data, and each device needs to be configured to send
    data there. Common clients include RSyslog and Syslog-ng, and the OpenTelemetry
    Collector also supports this protocol.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Syslog message format provides a structured framework that has allowed organizations
    to provide vendor-specific extensions. Contributing to its success and longevity,
    most modern observability tooling providers still supply an interface to receive
    Syslog messages. The logs can then be accessed and analyzed alongside other system
    and application telemetry.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Simple Network Management Protocol** (**SNMP**): Forming part of the original
    Internet Protocol suite defined by the **Internet Engineering Task Force** (**IETF**),
    SNMP is commonly used in networking infrastructure. A lot of the protocol is not
    of interest for observability, but **SNMP Traps** allow devices to inform the
    manager about significant events.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SNMP provides a common mechanism for network devices to relay management and,
    specifically in the context of this chapter, monitoring information within single
    and multi-vendor LAN or WAN environments. It is different from other telemetry
    receivers as it requires more specific knowledge of the devices on the network,
    and specific configurations for the metrics to be collected. Here are some examples
    of data that can be collected from SNMP:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| **Data Type** | **Example** **Metrics Collected** |'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Network data | ProcessesUptimeThroughput |'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Device data | Memory usageCPU usageTemperature |'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Table 2.8 – Example SNMP Trap information
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: You may encounter other formats out in the wide world of engineering. We have
    covered a lot of the common formats here and have hopefully given you an indication
    of the types of information you will need to help you work with telemetry in Grafana.
    Grafana will handle just about whatever you can throw at it. Knowing what’s important
    and preparing for that will help you when you’re building your visualizations
    and alerts on that data. Now, let’s quickly recap what we’ve covered in this chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the foundations that modern observability is built
    on. This will serve as easy reference and support for future chapters in this
    book and your own projects. First, we looked at the common log formats and their
    examples, which will assist us in [*Chapter 4*](B18277_04.xhtml#_idTextAnchor092),
    *Looking at Logs with Grafana Loki*. Then, we took a closer look at metrics, their
    differing types, some example protocols, and best practices to consider when designing
    metric-based observability. What we covered here will help with [*Chapter 5*](B18277_05.xhtml#_idTextAnchor106),
    *Monitoring with Metrics Using Grafana Mimir and Prometheus*. We then moved on
    to traces and spans, where we looked at current protocols and some best practices
    to consider when building an efficient and effective trace-based observability
    platform. This section lays the groundwork for [*Chapter 6*](B18277_06.xhtml#_idTextAnchor134),
    *Tracing Technicalities with Grafana Tempo*. After looking at the telemetry of
    observability, we learned about application instrumentation, which we will see
    more of in [*Chapter 3*](B18277_03.xhtml#_idTextAnchor063), *Setting Up a Learning
    Environment with Demo Applications*, and later chapters where we go into specifics
    with logs, metrics, and traces. Lastly, we considered some of the more traditional
    infrastructure telemetry.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: With the overview of application and infrastructure instrumentation complete,
    we can now start playing with logs, metrics, and traces. In the next chapter,
    we will get our learning environment up and running.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
