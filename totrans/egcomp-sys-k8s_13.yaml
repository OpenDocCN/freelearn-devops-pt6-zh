- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geolocalization Applications Using GPS, NoSQL, and K3s Clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the growing use cases for edge computing is the implementation of a system
    for tracking cargos and logistics. Sometimes, this tracking involves monitoring
    and getting metrics that can be used to optimize packages’ delivery times, reduce
    gas consumption, and so on. One of the important technologies that you can use
    for this is the **Global Positioning System** (**GPS**). GPS can help you to obtain
    the coordinates of an object when it is moving in real time. This, together with
    Kubernetes at the edge, results in a powerful combination of technologies to create
    geolocalization systems, also called geo-tracking systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how GPS is used in a geo-tracking system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redis to store GPS coordinates data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MongoDB to store your devices’ tracking data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating services to monitor your devices in real time using GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your Raspberry Pi to track your device using GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing your devices using Leaflet library in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a real-time map and report application to track your devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy our databases in this chapter, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A single node K3s cluster using an ARM device. In this case, we are going to
    use the Raspberry Pi 4B model with 8 GB. We are going to use the Raspberry Pi
    OS lite (64-bit) operating system with no desktop environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple VK-162 G-Mouse USB GPS dongle navigation modules for your edge Raspberry
    devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A battery bank and a USB 2.0 A-Male to USB C cable. You can also power your
    Raspberry Pi with your car’s USB charger port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Kubernetes cluster hosted in your public cloud provider (AWS, Azure, or GCP)
    or your private cloud.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of programming, especially Python and JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the repository at [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch13](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch13)
    if you want to run the YAML configuration by using `kubectl apply` instead of
    copying the code from the book. Take a look at the `python` directory inside the
    `code` directory and the `yaml` directory for YAML configurations inside the `ch13`
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, you can start to implement your geolocation system using edge computing.
    Let’s start to understand how GPS works in our first section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how GPS is used in a geo-tracking system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, our goal will be to build a geolocation system, also called
    a geo-tracking system. This means that we are going to build a system that gets
    GPS coordinates or positions from vehicles. In our use case, we are assuming that
    our vehicles will be used to deliver packages. Our vehicles will be equipped with
    a Raspberry Pi device and a GPS module. This hardware will collect GPS coordinates,
    using latitude and longitude to send them to the cloud. Then, our application
    will show the live positions of all the vehicles and a report to show the route
    of vehicles within a date range. In general, these are the main features that
    our geo-tracking system will have:'
  prefs: []
  type: TYPE_NORMAL
- en: A real-time map showing the position of all delivery vehicles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A map showing the nearby delivery stops of each vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A report that shows delivery routes for a vehicle between a date range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This geo-tracking system is represented using the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – A geolocation application edge diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – A geolocation application edge diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s explain how this geo-tracking system is implemented by describing
    the edge computing layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud layer**: Here, we are going to install a Kubernetes cluster in our
    preferred cloud provider. Inside this cluster, we are going to install three main
    applications. The GPS server will receive requests from the vehicles. It will
    also save the collected positions in Redis for the real-time map and the logs
    in MongoDB for the report that shows delivery routes. Finally, we will have the
    frontend application that contains the web application to show the real-time map
    and the report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Near edge**: This layer represents all the information that will move from
    the far edge to the near edge using the LTE network. This means that all the GPS
    information will be sent across the internet to its final destination, the cloud
    layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Far edge**: Here, we are going to find the vehicles equipped with a Raspberry
    Pi; this device will use a GPS module and an internet connection to send the GPS
    coordinates. Our Raspberry Pi will have K3s installed. Inside this K3s single-node
    cluster, we are going to find the GPS reader. This application is going to read
    GPS information and send it to the cloud. However, you can also include additional
    applications to add more functionalities – for example, showing an OLED screen
    with GPS information or other processed data, such as velocity, using the GPS
    coordinates to calculate it. Hence, this part represents the local process at
    the edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To connect the Raspberry Pi to the internet, you can use a 5G or 4G LTE module
    or your smartphone, which already includes this kind of module. To simplify the
    example, we are going to use the access point from a smartphone to share the internet
    with the Raspberry Pi device.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tiny edge**: Here, we are going to find the GPS module that our edge device
    will use to get GPS coordinates. Our GPS module is going to use the **Global Navigation
    Satellite System** (**GNSS**), which is a global system of satellites that gives
    you GPS coordinates. This will be the main data used in our implementation. You
    can also use an LTE 5G/4G module with GPS integrated to speed up GPS module initialization
    to capture GPS coordinates, but this could be expensive compared with the VK-162
    G-Mouse USB module. In this case, we are going to use the VK-162 module to simplify
    the implementation and reduce costs for this prototype implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, our vehicle on the far edge is going to read information from the
    GPS module on the tiny edge. After reading the information and doing some processing,
    the information will be sent to the cloud layer using the near edge. Once all
    the information is received, it will be stored in Redis and Mongo to show the
    real-time map and the report using the frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis to store GPS coordinates data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we explained in [*Chapter 10*](B16945_10_Final_PG.xhtml#_idTextAnchor198),
    *SQL and NoSQL Databases at the Edge*, Redis is a key-value database that is pretty
    lightweight when using resources. Redis exclusively uses RAM memory to store its
    data but can persist when using snapshot configuration, which basically stores
    this data on the disk. Redis can also store geolocation data, storing GPS coordinates
    and tuples with latitude and longitude values. Redis stores this information with
    the field’s latitude, longitude, and a name. Redis also calls this data a `GEOADD`
    and `GEOSEARCH` commands to implement our geolocalization application. But first,
    let’s install Redis in the cloud to store some geolocation data. For this, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a **PersistentVolumeClaim** for Redis to persist data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a ConfigMap to configure Redis to use an authentication password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the deployment for Redis using the previous `redis-configmap` and mounted
    as the `redis.conf` file. We also use the `db-pv-claim-1`, and some resource limits
    for the deployment setting the CPU and memory. Let’s create the deployment by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, we are not going to use an image for ARM 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the service for Redis by opening port `6379`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have Redis installed. Let’s move to install Mongo to store log information
    with this data.
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB to store your device’s tracking data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB is a document-oriented NoSQL database that stores the information using
    JSON format. It also has the capability to store location data. In this use case,
    we are going to use MongoDB to store our geolocation data; this means storing
    all coordinates (latitude and longitude) that the GPS captures on the devices
    for later reports. MongoDB can perform some special manipulation for geolocation
    data, but in this case, we will use it just to store data in JSON format. To install
    MongoDB in the cloud, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **PersistentVolumeClaim** for MongoDB, to persist data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You can change the storage class if you install Longhorn or another storage
    driver, or if you are using the storage class provided by your cloud provider.
    Just uncomment the `storageClassName` line by removing the `#` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy your custom configuration to enable clients to connect to MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This exposes MongoDB to listening in port `27017` across the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the deployment using the `mongo-configmap`, our `MONGO_INITDB_ROOT_USERNAME`,
    `MONGO_INITDB_ROOT_PASSWORD`, and `MONGO_INITDB_DATABASE` variables that set the
    initial root username, an additional user to connect and their passwords to be
    used when connecting to MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We are using some values directly to configure the deployment to simplify the
    example. But it’s a best practice to use secrets to protect sensitive data. You
    can explore [*Chapter 10*](B16945_10_Final_PG.xhtml#_idTextAnchor198), *SQL and
    NoSQL Databases at the Edge*, for more examples. We are also using version 4.4
    in case you want to install MongoDB on an ARM device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the service that exposes your MongoDB deployment as a service accessible
    inside the cluster (MongoDB uses port `27017` to connect):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, your MongoDB database has been installed. So, let’s deploy our GPS server
    application that will store data in Redis and our MongoDB in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating services to monitor your devices in real time using GPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our use case, we are going to deploy a service that sends data from our
    edge device after some processing in the cloud. The goal of this use case is to
    have a global geolocation system for multiple vehicles delivering packages, showing
    their location in real time. For this, we are going to create a `gps-server` deployment
    that stores all the coordinates for our units in Redis and Mongo. We are going
    to use the Python Flask library to create this service. Let’s explore the main
    sections of the following pseudocode mixed with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s focus on the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**redisCon**: This function sets the Redis connection. This application is
    going to use the Redis service created in the *Using Redis to store GPS coordinates
    data* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/client/<cid>/position` URL, the function will get the `<cid>` value that
    represents a connected client that sends information to this service – in this
    case, our delivery vehicles. Every time the information is received, it is stored
    in the key with the form `client:{cid}:position` inside Redis, and stores the
    latitude as a `lat` variable, the longitude as `lng`, and the client ID or vehicle
    number as `cid`. It also sets an expiration time as 180 seconds or 3 minutes.
    After calling the tracking server to store this coordinate in MongoDB, it returns
    the following JSON response: `{"client_id":cid,"setPosition":"done"}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/clients/positions/unit/<unit>/r/<radius>` URL, the function connects to Redis
    and gets all the keys with the form `client:<cid>:position`, which contains the
    current GPS position of each vehicle. Then gets the near stops to this position,
    using the Redis command `geosearch`. The returned JSON will look like: `{"clients":[{"cid":1,"lat":0.0,"lng":0.0,"near":["stop1"]}]}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/client/<cid>/stops` URL, the function will get `<cid>` and store all the
    positions as a geospatial index in the key with the `client:{cid}:stops` form.
    Inside this key, each position will be stored with the name sent as part of the
    JSON data using `curl`. These stops are stored for 10 hours by default because
    the stops have to be completed during a workday. These stops will be near to the
    vehicle with the `cid` number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After understanding the code, let’s deploy our GPS server application in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying gps-server to store GPS coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `gps-server` application will receive the GPS coordinates from your edge
    devices. For this, we have to deploy it and expose it using a load balancer. To
    deploy the `gps-server` application, follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the deployment for the GPS server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This deployment uses the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**REDIS_HOST**: This is the name of the Redis service; this variable can be
    customized to fit your needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REDIS_AUTH**: This is the password to connect to the Redis service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracking-server` – in this case, the URL matches the internal `tracking-server`
    service in port `3000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the code and create your own container, refer to this link: [https://github.com/sergioarmgpl/containers/tree/main/gps-server/src](https://github.com/sergioarmgpl/containers/tree/main/gps-server/src).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the service as a LoadBalancer; this IP address will be used in our GPS
    reader services for each unit or truck:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the load balancer IP for our `gps-server` deployment with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see the value of the `GPS_SERVER_IP` environment variable by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it takes some time after the IP address of the load balancer is provisioned.
    You can check the state of the services by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Wait until `EXTERNAL_IP` is provisioned. Also, note the `$GPS_SERVER_IP` value,
    which will be used to configure the `gps-reader` application on each edge device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can set the stops for the first vehicle, represented with value `1`.
    For this, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use curl to store the stops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have the `gps-server` application deployed and exposed using a load
    balancer. Let’s deploy our `tracking-server`, the one that stores logs about the
    received GPS positions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service to log GPS positions and enable real-time tracking for your
    devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `tracking-server` application will be in charge of logging all the received
    coordinates for each vehicle. This information will be used to show the route
    of a vehicle in the desired time range using the `frontend` application. Before
    deploying `tracking-server`, let’s understand the code of this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code we can find the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tracking` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` request in the `/client/<cid>/position` URL, the function will store
    the received GPS position in the `{"cid":1,"lat":0.0,"lng":0.0,"ts":166666666,"dtxt":"01-01-22-23:59:59"}`
    format. `cid` represents the client ID or the number of the vehicle, `lat` and
    `lng` are used to store the GPS position, `ts` represents the timestamp generated
    when the coordinate was received, and `dtxt` is the date in text format to reduce
    transformation time from the timestamp format to the UNIX date format. Once this
    data is stored in the database, `mydatabase` returns the next JSON: `{"client_id":cid,"positionStored":"done"}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` request in the URL with the `/client/<cid>/positions/s/<sdate>/e/<edate>`
    form, it returns a JSON response with all the GPS positions between the starting
    date, `sdate`, and the ending date, `edate`. For this, `tracking-server` connects
    to Mongo and returns the result of performing this query in this time range. The
    information will be returned in the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we know how the `tracking-server` application works. Let’s deploy this application
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying tracking-server to store logs from GPS coordinates to be used for
    vehicles routing report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `tracking-server` will be used in our `frontend` application to show the
    route of a vehicle within the desired time range. Let’s deploy our application
    with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy `tracking-server` by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This deployment uses the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mongodb://USER:PASWORD@HOST/DATABASE?authSource=admin` format. You can customize
    these credentials and store `MONGO_URI` as a secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MONGO_DB**: This is the database created in MongoDB to store the tracking
    collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracking` collection of MongoDB. Note that our Python code uses the `pytz`
    library and the ISO 3166 convention for country names. Check the *Further reading*
    section for more information to set your country’s time zone correctly. In this
    case, we set the country to `America/Guatemala`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about the URI on the following page: [https://www.mongodb.com/docs/manual/reference/connection-string](https://www.mongodb.com/docs/manual/reference/connection-string).
    Remember that we are using hardcoded values to simplify the example, but it’s
    best practice to use secrets. Check out [*Chapter 10*](B16945_10_Final_PG.xhtml#_idTextAnchor198),
    *SQL and NoSQL Databases at the Edge*, for more details. To check out the code
    and create your own version of `tracking-server`, refer to the following link:
    [https://github.com/sergioarmgpl/containers/tree/main/tracking-server/src](https://github.com/sergioarmgpl/containers/tree/main/tracking-server/src).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a service as a ClusterIP for `tracking-server` to call it inside `gps-server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a service as a LoadBalancer for `tracking-server` to call it in our
    viewer application, which is accessible over the internet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the load balancer IP of our `tracking-server` deployment with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see the value of the `TRACKING_SERVER_IP` environment variable by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `tracking-server` application has been deployed. Now, let’s configure our
    device to run our reader application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your Raspberry Pi to track your device using GPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before using the GPS module on your Raspberry Pi, you have to follow the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Raspberry Pi OS Lite (64-bit) on your device; you can check out
    [*Chapter 2*](B16945_02_Final_PG.xhtml#_idTextAnchor036), *K3s Installation and
    Configuration*, for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to your device and set an initial user name and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `raspi-config` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see a screen like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The raspi-config main menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – The raspi-config main menu
  prefs: []
  type: TYPE_NORMAL
- en: To configure the wireless network, go to the **System Options** | **Wireless
    LAN** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a **Choose the country where your Raspberry will be used** message,
    and then click **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, the **Wireless LAN country** message will appear. Select your country
    and then click **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Please Enter SSID** message will appear. Click **Ok** and press **Enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the **Please Enter passphrase** message will appear. Click **Ok** and press
    *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon returning to the main menu, select **Finish** and press *Enter* to exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the SSH, choosing the **Interface Options** | **SSH** menu. This will
    show the **Would you like the SSH server to be enabled?** message. Choose **Yes**
    and press *Enter*. After that, the **The SSH server is enabled** message will
    appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To check the IP of your Raspberry Pi, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – The ifconfig output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – The ifconfig output
  prefs: []
  type: TYPE_NORMAL
- en: Take note of the IP address next to the word `inet` word in the `wlan0` network
    interface; this will be the IP address of your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your device using the previous IP address found using SSH:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next kernel parameters to enable the use of container by adding these
    values in the `/boot/cmdline.txt` file; remember that you need root permissions
    to modify this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Connect your VK-162 G-Mouse GPS module to one of the USB ports of your Raspberry;
    after some seconds, the `/dev/ttyACM0` device will be ready to be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Restart your device to apply these changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '(*Optional*) If you want to configure other features, log in to your device
    and run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: (*Optional*) Activate the `raspi-config`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*Optional*) Then, a dialog will show **Would you like the ARM I2C interface
    to be enabled?**. Select **Yes** and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*Optional*) After the previous dialog, the **The ARM I2C interface is enabled**
    message will appear. Press *Enter* to choose the **Ok** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*Optional*) Upon returning to the main menu, select **Finish** and press *Enter*
    to exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To finish, let’s install K3s by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to see whether your K3s single-node cluster is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will show something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The kubectl get nodes output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – The kubectl get nodes output
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about how to use `raspi-config` at the following link:
    [https://geek-university.com/raspi-config](https://geek-university.com/raspi-config).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have your Raspberry Pi installed with Raspberry Pi OS Lite, which is
    ready to be used together with your GPS module. In the next section, let’s move
    to deploy the GPS reader application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GPS reader code to send GPS coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, the only remaining part is to install `gps-reader` in the K3s single-node
    cluster installed on your Raspberry. This application will run as a container
    using the Kubernetes Pods. However, before installing our `gps-reader` application,
    let’s understand the code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous code contains an infinite loop that reads the output of the `/dev/ttyACM0`
    device every half second. Our VK-162 G-Mouse GPS module uses the `GRPMC` field
    to get the latitude and longitude coordinates using the `PynMEA2` library. Once
    the library extracts the coordinates, it calls the GPS server endpoint to store
    the current GPS position of the vehicle in Redis and log it in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the GPS module delays a little bit after the module starts receiving
    a GPS coordinate. It could take some minutes before the GPS module starts to receive
    GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what your device is doing, run the `cat /dev/ttyACM0` command. If the
    module is not receiving coordinates yet, it will show something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `GPRMC` or `GPGLL` fields are empty in some parts when the module is not
    receiving coordinates. These missing values contain the latitude and longitude
    obtained by the GPS module.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the device starts to receive data, you will see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `GPGLL` line contains all the information about latitude and longitude that
    we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your device configuration, the `GPRMC` line can include the elevation
    data. In the previous output, the elevation information is not configured, so
    the line will not include this information, but the device can be configured to
    get the elevation information too.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how our application reads information from the GPS module. Let’s
    deploy our application in our device with K3s installed.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying gps-reader to send GPS coordinates to the cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One advantage of using K3s is that if your application is complex, you can deploy
    your application separated as modules or microservices, and you can update these
    pieces without affecting the others. In this case, we are only using one piece
    called `gps-reader`. This application reads the GPS module from the device using
    a Pod. In this case, we are using a configuration that enables us to read the
    `/dev` folder from the device with just the necessary permissions to access the
    `/dev/ttyACM0` device, where the GPS module shows the GPS coordinates. This device
    can change, depending on the GPS module that you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a reader on your device, run the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `gps-reader` Pod to start reading GPS coordinates from your module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This Pod will use the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEVICE**: This contains the virtual device where the GPS module is listening.
    This could be different, depending on the GPS module that you are using. Check
    the *Further reading* section for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLIENT_ID**: This is the vehicle number that this reader will represent in
    the system – in this case, 1, the first vehicle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPS_SERVER_IP` variable in the *Deploying gps-server to store GPS coordinates*
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the code and create your own container of `gps-reader`, refer to the
    following link: [https://github.com/sergioarmgpl/containers/tree/main/gps-reader/src](https://github.com/sergioarmgpl/containers/tree/main/gps-reader/src).
    If you want to use an OLED screen to show information, refer to the following
    link: [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/blob/main/ch13/code/python/oled.py](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/blob/main/ch13/code/python/oled.py).
    The code uses the OLED included in the Raspberry Pi 4B keyestudio Complete RFID
    Starter kit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether your device is reading information by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you’re not sure whether you have access to your device, the way to test is
    by looking at the frontend and checking whether the device appears on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Press *Ctrl* + *C* to cancel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `exit` and press *Enter* to exit from your Raspberry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have all the backend services running and receiving data, but we need
    to visualize this information. Let’s move to the next section to deploy the `frontend`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing your devices using Open Street Maps in real time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has two parts, one that visualizes the GPS coordinates of the
    vehicles and their near stops in real time and one that shows the past routes
    of the vehicle within a time range. So, let’s understand first the code of the
    geo-tracking map showing the devices in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the geo-tracking map visualizer code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a map showing all the vehicles with their coordinates and
    near stops. We are using HTML, JavaScript, jQuery and the Leaflet library to create
    the map. Let’s look at the code of the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our page loads some JavaScript libraries and CSS styles. After that, it loads
    an initial GPS position to show the map. This map is loaded in the `<div id='map'></div>`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important functions in this code are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gps-server` to get all the GPS coordinates. To do this, the `setInterval`
    function calls the `http://GPS_SERVER_IP:3000/clients/positions/unit/km/r/0.1`
    URL, which returns the current GPS coordinates of each vehicle and their nearby
    stops in a radius of 0.1 kilometers. To do this, call the `markPosition` function
    every 5 seconds and send the client ID or vehicle number (`cid`), latency (`lat`),
    longitude (`lng`), and the `near` variable with the name of the stops. This function
    creates a mark object in the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**markPosition**: This function creates a Leaflet mark object with a PopUp
    window in the map. This function also resets the map when it’s called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This application basically loads all the necessary libraries and calls the
    `setInterval` function to refresh the map every 5 seconds by calling the `markPosition`
    function. It is important to set an initial GPS position to center the map; this
    is customizable in the YAML file used to deploy the `frontend` application. Once
    the map is initialized, it will show all the tracked objects after 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – A map showing two tracked devices using GPS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – A map showing two tracked devices using GPS
  prefs: []
  type: TYPE_NORMAL
- en: 'If the connected devices are not sending data to the map, it will show an empty
    map; in this case, *Figure 13.5* shows two devices connected and sending data.
    Now, let’s say, for example, that we are using the device or vehicle number 2
    – in this case, represented as the second `CID` (client ID). If you click on the
    blue mark, it will show the current `Latitude` and `Longitude` coordinates and
    the near destinations or stops of the tracked vehicle. In this case, we set two
    stops, `galeno_encinal` and `la_torre_encinal`, which are 0.1 km from the current
    position of the tracked vehicle. If you click on the blue mark, you will see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Near destinations showed when clicking the blue mark'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Near destinations showed when clicking the blue mark
  prefs: []
  type: TYPE_NORMAL
- en: This information is calculated every 5 seconds, updating the nearest position
    of your tracked vehicle in real time. You can customize the code to fit your needs;
    this is just a quick-start example to build a geo-tracking system using GPS. Let’s
    look at how our vehicles routes report works to show the collected data from the
    tracked vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the vehicles routes report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This application creates a blue line, showing the tracking log stored in MongoDB.
    This represents the route of the vehicle within a date or time range. Before we
    take an in-depth look into how it works, let’s explore first the code of this
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze the next code sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**trip**: This variable contains all the coordinates to draw a line in the
    map with the routes covered by the vehicle within a time range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**form**: This is an HTML form used to generate the dynamic called to get all
    the GPS positions between a selected time range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracking-server` and get all the GPS positions. This URL has the following
    structure: `http://TRACKING_SERVER_IP:3000/client/2/positions/s/25-05-22-04:39:58/e/25-05-22-04:40:00`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onEachFeature**: This is a function that creates a line with the GPS positions
    of the vehicle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoadMap**: This is a function that is called after clicking on the load button
    of the form to show the routes covered within a time range for a vehicle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, this report page is generated when the **Show Route History** button
    is clicked, showing the route of the vehicle on the map as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Vehicles Routes Report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – Vehicles Routes Report
  prefs: []
  type: TYPE_NORMAL
- en: Our `tracking-server` service is configured to store and query the log tracking
    information of the vehicles within a time range using the timestamp captured when
    data arrives. This application is also configured to use localization times and
    UTC in different countries. This is a basic implementation of the vehicles routes
    report that you can customize.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more about what is UTC time, you can check the next link: [https://www.timeanddate.com/time/aboututc.html](https://www.timeanddate.com/time/aboututc.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that this map has is that when you click on the map, it can
    show some information. In this case, we are showing a sample message, but you
    can customize it to show additional information, such as the time when the vehicle
    was in a particular position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Route information of the vehicle when clicking on the map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16945_13_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – Route information of the vehicle when clicking on the map
  prefs: []
  type: TYPE_NORMAL
- en: To reset the report, you have to reload the page. With this, we are ready to
    deploy our frontend application, which contains the real time map and this report,
    so finally, we can access the final application. To do this, let’s move on to
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a real-time map and report application to track your devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have all the things ready, so we have to deploy the front application
    that contains our real time map and the report page. To do this, we use a simple
    Flask application with Python using templates; here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This application renders the `map.html` page, which loads the Leaflet library
    to show the maps using the initial latitude and longitude variables. It also sets
    the endpoint of the `gps-server` that is called inside this static page. To deploy
    this application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the deployment by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This deployment has the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LATITUDE**: The initial GPS latitude coordinate to center your map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LONGITUDE**: The initial GPS longitude coordinate to center your map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gps-server` application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tracking-server` application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these variables, you configure the initial loaded GPS coordinate to center
    the map and the endpoints to be called by the pages, to show the real-time map
    of the report routes of the `frontend` application.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the code and create your own container of `frontend`, refer to
    the following link: [https://github.com/sergioarmgpl/containers/tree/main/frontend/src](https://github.com/sergioarmgpl/containers/tree/main/frontend/src).
    To get some initial GPS coordinates to center the map when loading, refer to this
    website: [https://www.gps-coordinates.net](https://www.gps-coordinates.net).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a load balancer service for your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the load balancer IP of our `frontend` deployment with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see the value of the `FRONTEND_IP` environment variable by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We used a `LoadBalancer` service type to simplify the implementation, but a
    cheaper solution would be to use ingress definitions to expose the applications.
    You can explore the following link for more information: [https://kubernetes.io/docs/concepts/services-networking/ingress](https://kubernetes.io/docs/concepts/services-networking/ingress).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, access your application as `http://<FRONTEND_IP>:3000` in your browser.
    The important endpoints of the URL are the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://<FRONTEND_IP>:3000`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://<FRONTEND_IP>:3000/report`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, turn on your Raspberry Pi device in your vehicle and wait until your device
    starts sending GPS coordinates. Don’t forget to set your stops for each device.
    After some seconds or a couple of minutes, your map will start to show your devices
    in real time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record some data by driving your equipped vehicle with your Raspberry Pi device
    and then test your reports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, our simple geolocation system is ready and running. After finishing this
    chapter, it is important to mention that this is just a basic example that you
    can extend to fit your needs. Now, it’s time to recap what we learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to take advantage of MongoDB and Redis to store
    and query GPS coordinates to build a basic geolocalization system. We also learned
    how to integrate a GPS module to an edge device and send information to the cloud
    to finally visualize how a vehicle is moving in real time on a map, showing the
    near stops in a circle area, and simulating in that way a basic tracking delivery
    system. This shows how to implement a simple use case using geolocalization and
    how edge devices moving in real time interact in a geolocalization system. In
    the next chapter, we are going to learn how to use machine learning and computer
    vision to create a small smart traffic project.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to validate your new knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I use GPS technologies to create a geolocalization system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I use Redis to store GPS coordinates and do queries with this data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I use MongoDB to store logs for a geolocalization system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I design a real-time application that shows the GPS positions of moving
    vehicles?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I use edge computing and K3s to create a distributed system to track
    vehicles?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following references for more information on the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'VK-162 G-Mouse GPS module: [https://www.amazon.com/Navigation-External-Receiver-Raspberry-Geekstory/dp/B078Y52FGQ](https://www.amazon.com/Navigation-External-Receiver-Raspberry-Geekstory/dp/B078Y52FGQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis geospatial index commands: [https://redis.io/commands/?group=geo](https://redis.io/commands/?group=geo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Geospatial data: [https://www.mongodb.com/docs/manual/geospatial-queries](https://www.mongodb.com/docs/manual/geospatial-queries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Positioning chips and modules*: [https://www.u-blox.com/en/positioning-chips-and-modules](https://www.u-blox.com/en/positioning-chips-and-modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Basics of Hash Tables*: [https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial](https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Find Arduino Port on Windows, Mac, and Linux*: [https://www.mathworks.com/help/supportpkg/arduinoio/ug/find-arduino-port-on-windows-mac-and-linux.html](https://www.mathworks.com/help/supportpkg/arduinoio/ug/find-arduino-port-on-windows-mac-and-linux.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'raspi-config: [https://geek-university.com/raspi-config](https://geek-university.com/raspi-config)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GPS – NMEA sentence information*: [http://aprs.gids.nl/nmea](http://aprs.gids.nl/nmea)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Leaflet – an open source JavaScript library for mobile-friendly interactive
    maps*: [https://leafletjs.com](https://leafletjs.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GPS Coordinates*: [https://www.gps-coordinates.net](https://www.gps-coordinates.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Epoch and Unix Timestamp Conversion Tools*: [https://www.epochconverter.com](https://www.epochconverter.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pytz timezones Library: [https://pypi.org/project/pytz](https://pypi.org/project/pytz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Country codes: [https://www.iban.com/country-codes](https://www.iban.com/country-codes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
