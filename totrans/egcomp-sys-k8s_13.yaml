- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Geolocalization Applications Using GPS, NoSQL, and K3s Clusters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GPS、NoSQL 和 K3s 集群的地理定位应用
- en: One of the growing use cases for edge computing is the implementation of a system
    for tracking cargos and logistics. Sometimes, this tracking involves monitoring
    and getting metrics that can be used to optimize packages’ delivery times, reduce
    gas consumption, and so on. One of the important technologies that you can use
    for this is the **Global Positioning System** (**GPS**). GPS can help you to obtain
    the coordinates of an object when it is moving in real time. This, together with
    Kubernetes at the edge, results in a powerful combination of technologies to create
    geolocalization systems, also called geo-tracking systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘计算的一个日益增长的应用场景是实施一个用于跟踪货物和物流的系统。有时，这种跟踪涉及监控和获取一些可以用来优化包裹配送时间、减少油耗等的指标。您可以用来实现这一目标的一个重要技术是**全球定位系统**（**GPS**）。GPS可以帮助您在物体实时移动时获取其坐标。结合
    Kubernetes 在边缘的应用，形成了强大的技术组合，用于创建地理定位系统，也称为地理跟踪系统。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding how GPS is used in a geo-tracking system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GPS 如何在地理跟踪系统中被使用
- en: Using Redis to store GPS coordinates data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 存储 GPS 坐标数据
- en: Using MongoDB to store your devices’ tracking data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoDB 存储设备的跟踪数据
- en: Creating services to monitor your devices in real time using GPS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务以使用 GPS 实时监控您的设备
- en: Configuring your Raspberry Pi to track your device using GPS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置您的 Raspberry Pi 以使用 GPS 跟踪您的设备
- en: Visualizing your devices using Leaflet library in real time
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Leaflet 库实时可视化您的设备
- en: Deploying a real-time map and report application to track your devices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个实时地图和报告应用程序来跟踪您的设备
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To deploy our databases in this chapter, you need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中部署我们的数据库，您需要以下内容：
- en: A single node K3s cluster using an ARM device. In this case, we are going to
    use the Raspberry Pi 4B model with 8 GB. We are going to use the Raspberry Pi
    OS lite (64-bit) operating system with no desktop environment.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ARM 设备的单节点 K3s 集群。在本例中，我们将使用 8 GB 的 Raspberry Pi 4B 型号。我们将使用没有桌面环境的 Raspberry
    Pi OS lite（64 位）操作系统。
- en: Multiple VK-162 G-Mouse USB GPS dongle navigation modules for your edge Raspberry
    devices.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个 VK-162 G-Mouse USB GPS dongle 导航模块，用于您的边缘 Raspberry 设备
- en: A battery bank and a USB 2.0 A-Male to USB C cable. You can also power your
    Raspberry Pi with your car’s USB charger port.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电池组和一根 USB 2.0 A-Male 到 USB C 的数据线。您也可以通过汽车的 USB 充电端口为 Raspberry Pi 供电。
- en: A Kubernetes cluster hosted in your public cloud provider (AWS, Azure, or GCP)
    or your private cloud.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个托管在您的公共云服务提供商（AWS、Azure 或 GCP）或私有云中的 Kubernetes 集群
- en: Basic knowledge of programming, especially Python and JavaScript.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程基础知识，尤其是 Python 和 JavaScript。
- en: Clone the repository at [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch13](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch13)
    if you want to run the YAML configuration by using `kubectl apply` instead of
    copying the code from the book. Take a look at the `python` directory inside the
    `code` directory and the `yaml` directory for YAML configurations inside the `ch13`
    directory.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望通过 `kubectl apply` 运行 YAML 配置而不是从书中复制代码，请克隆 [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch13](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch13)
    这个仓库。查看 `code` 目录中的 `python` 目录以及 `ch13` 目录中的 `yaml` 目录，以获取 YAML 配置。
- en: With this, you can start to implement your geolocation system using edge computing.
    Let’s start to understand how GPS works in our first section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，您可以开始使用边缘计算实现您的地理定位系统。让我们从第一部分开始了解 GPS 是如何工作的。
- en: Understanding how GPS is used in a geo-tracking system
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GPS 如何在地理跟踪系统中被使用
- en: 'For this chapter, our goal will be to build a geolocation system, also called
    a geo-tracking system. This means that we are going to build a system that gets
    GPS coordinates or positions from vehicles. In our use case, we are assuming that
    our vehicles will be used to deliver packages. Our vehicles will be equipped with
    a Raspberry Pi device and a GPS module. This hardware will collect GPS coordinates,
    using latitude and longitude to send them to the cloud. Then, our application
    will show the live positions of all the vehicles and a report to show the route
    of vehicles within a date range. In general, these are the main features that
    our geo-tracking system will have:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们的目标是构建一个地理定位系统，也称为地理跟踪系统。这意味着我们将构建一个从车辆获取GPS坐标或位置的系统。在我们的使用案例中，我们假设我们的车辆将用于配送包裹。我们的车辆将配备树莓派设备和GPS模块。这些硬件将收集GPS坐标，使用纬度和经度将其发送到云端。然后，我们的应用程序将显示所有车辆的实时位置，并生成报告以显示车辆在日期范围内的行驶路线。总体而言，这就是我们的地理跟踪系统将具备的主要功能：
- en: A real-time map showing the position of all delivery vehicles
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实时地图，显示所有送货车辆的位置
- en: A map showing the nearby delivery stops of each vehicle
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示每辆车附近配送站点的地图
- en: A report that shows delivery routes for a vehicle between a date range
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示车辆在日期范围内配送路线的报告
- en: 'This geo-tracking system is represented using the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该地理跟踪系统通过以下图示表示：
- en: '![Figure 13.1 – A geolocation application edge diagram'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 一个地理定位应用的边缘图'
- en: '](img/B16945_13_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_01.jpg)'
- en: Figure 13.1 – A geolocation application edge diagram
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 一个地理定位应用的边缘图
- en: 'Now, let’s explain how this geo-tracking system is implemented by describing
    the edge computing layers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过描述边缘计算层来解释这个地理跟踪系统是如何实现的：
- en: '**Cloud layer**: Here, we are going to install a Kubernetes cluster in our
    preferred cloud provider. Inside this cluster, we are going to install three main
    applications. The GPS server will receive requests from the vehicles. It will
    also save the collected positions in Redis for the real-time map and the logs
    in MongoDB for the report that shows delivery routes. Finally, we will have the
    frontend application that contains the web application to show the real-time map
    and the report.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云层**：在这里，我们将会在我们选择的云服务商上安装Kubernetes集群。在这个集群中，我们将安装三个主要应用程序。GPS服务器将接收来自车辆的请求。它还会将收集到的位置保存在Redis中，以供实时地图使用，并将日志保存在MongoDB中，用于显示配送路线的报告。最后，我们将有一个前端应用程序，包含用于显示实时地图和报告的Web应用。'
- en: '**Near edge**: This layer represents all the information that will move from
    the far edge to the near edge using the LTE network. This means that all the GPS
    information will be sent across the internet to its final destination, the cloud
    layer.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**近端**：这一层表示所有将通过LTE网络从远端移动到近端的信息。这意味着所有的GPS信息将通过互联网发送到最终目的地——云层。'
- en: '**Far edge**: Here, we are going to find the vehicles equipped with a Raspberry
    Pi; this device will use a GPS module and an internet connection to send the GPS
    coordinates. Our Raspberry Pi will have K3s installed. Inside this K3s single-node
    cluster, we are going to find the GPS reader. This application is going to read
    GPS information and send it to the cloud. However, you can also include additional
    applications to add more functionalities – for example, showing an OLED screen
    with GPS information or other processed data, such as velocity, using the GPS
    coordinates to calculate it. Hence, this part represents the local process at
    the edge.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远端**：在这里，我们将找到配备了树莓派的车辆；该设备将使用GPS模块和互联网连接发送GPS坐标。我们的树莓派将安装K3s。在这个K3s单节点集群中，我们将找到GPS读取器。这个应用程序将读取GPS信息并将其发送到云端。然而，您还可以包含其他应用程序以增加更多功能——例如，显示一个带有GPS信息或其他处理过的数据（如速度）的OLED屏幕，通过GPS坐标来计算速度。因此，这部分代表了边缘的本地处理。'
- en: To connect the Raspberry Pi to the internet, you can use a 5G or 4G LTE module
    or your smartphone, which already includes this kind of module. To simplify the
    example, we are going to use the access point from a smartphone to share the internet
    with the Raspberry Pi device.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要将树莓派连接到互联网，您可以使用5G或4G LTE模块，或者使用已经包含此类模块的智能手机。为了简化示例，我们将使用智能手机的接入点与树莓派设备共享互联网。
- en: '**Tiny edge**: Here, we are going to find the GPS module that our edge device
    will use to get GPS coordinates. Our GPS module is going to use the **Global Navigation
    Satellite System** (**GNSS**), which is a global system of satellites that gives
    you GPS coordinates. This will be the main data used in our implementation. You
    can also use an LTE 5G/4G module with GPS integrated to speed up GPS module initialization
    to capture GPS coordinates, but this could be expensive compared with the VK-162
    G-Mouse USB module. In this case, we are going to use the VK-162 module to simplify
    the implementation and reduce costs for this prototype implementation.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tiny edge**：在这里，我们将找到边缘设备用于获取 GPS 坐标的 GPS 模块。我们的 GPS 模块将使用 **全球导航卫星系统** (**GNSS**)，这是一个全球卫星系统，能够提供
    GPS 坐标。这将是我们实现中的主要数据。你还可以使用集成了 GPS 的 LTE 5G/4G 模块来加快 GPS 模块初始化速度，从而更快速地获取 GPS
    坐标，但与 VK-162 G-Mouse USB 模块相比，这可能会更昂贵。在这种情况下，我们将使用 VK-162 模块来简化实现并降低该原型实现的成本。'
- en: In summary, our vehicle on the far edge is going to read information from the
    GPS module on the tiny edge. After reading the information and doing some processing,
    the information will be sent to the cloud layer using the near edge. Once all
    the information is received, it will be stored in Redis and Mongo to show the
    real-time map and the report using the frontend application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们位于远端的车辆将从微型边缘设备的 GPS 模块读取信息。在读取信息并进行一些处理后，信息将通过近端设备发送到云层。一旦接收到所有信息，这些数据将存储在
    Redis 和 Mongo 中，并通过前端应用展示实时地图和报告。
- en: Using Redis to store GPS coordinates data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 存储 GPS 坐标数据
- en: 'As we explained in [*Chapter 10*](B16945_10_Final_PG.xhtml#_idTextAnchor198),
    *SQL and NoSQL Databases at the Edge*, Redis is a key-value database that is pretty
    lightweight when using resources. Redis exclusively uses RAM memory to store its
    data but can persist when using snapshot configuration, which basically stores
    this data on the disk. Redis can also store geolocation data, storing GPS coordinates
    and tuples with latitude and longitude values. Redis stores this information with
    the field’s latitude, longitude, and a name. Redis also calls this data a `GEOADD`
    and `GEOSEARCH` commands to implement our geolocalization application. But first,
    let’s install Redis in the cloud to store some geolocation data. For this, follow
    these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 10 章*](B16945_10_Final_PG.xhtml#_idTextAnchor198) 中解释的，*边缘的 SQL 和
    NoSQL 数据库*，Redis 是一个键值数据库，在使用资源时非常轻量。Redis 专门使用 RAM 内存来存储数据，但在使用快照配置时可以持久化数据，这基本上是将数据存储在磁盘上。Redis
    还可以存储地理位置数据，存储 GPS 坐标和包含纬度和经度值的元组。Redis 通过字段的纬度、经度和名称来存储这些信息。Redis 还通过 `GEOADD`
    和 `GEOSEARCH` 命令来实现我们的地理定位应用程序。但是首先，让我们在云端安装 Redis，以存储一些地理位置信息。为此，请按照以下步骤操作：
- en: 'First, let’s create a **PersistentVolumeClaim** for Redis to persist data:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为 Redis 创建一个 **PersistentVolumeClaim** 来持久化数据：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, create a ConfigMap to configure Redis to use an authentication password:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个 ConfigMap 来配置 Redis 使用认证密码：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the deployment for Redis using the previous `redis-configmap` and mounted
    as the `redis.conf` file. We also use the `db-pv-claim-1`, and some resource limits
    for the deployment setting the CPU and memory. Let’s create the deployment by
    running the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的 `redis-configmap` 创建 Redis 的部署，并将其挂载为 `redis.conf` 文件。我们还使用 `db-pv-claim-1`，并为部署设置了一些资源限制，包括
    CPU 和内存。让我们通过运行以下命令来创建该部署：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This time, we are not going to use an image for ARM 64 bits.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不打算使用 ARM 64 位的镜像。
- en: 'Now, create the service for Redis by opening port `6379`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过打开端口 `6379` 来创建 Redis 服务：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we have Redis installed. Let’s move to install Mongo to store log information
    with this data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经安装了 Redis。接下来，我们来安装 Mongo，用于存储带有这些数据的日志信息。
- en: Using MongoDB to store your device’s tracking data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 存储设备的追踪数据
- en: 'MongoDB is a document-oriented NoSQL database that stores the information using
    JSON format. It also has the capability to store location data. In this use case,
    we are going to use MongoDB to store our geolocation data; this means storing
    all coordinates (latitude and longitude) that the GPS captures on the devices
    for later reports. MongoDB can perform some special manipulation for geolocation
    data, but in this case, we will use it just to store data in JSON format. To install
    MongoDB in the cloud, follow the next steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个文档导向的NoSQL数据库，使用JSON格式存储信息。它也具备存储位置数据的能力。在这个用例中，我们将使用MongoDB来存储我们的地理位置数据；这意味着存储GPS在设备上捕获的所有坐标（纬度和经度）以供后续报告。MongoDB可以对地理位置数据进行一些特殊处理，但在此用例中，我们将仅用它来存储JSON格式的数据。要在云中安装MongoDB，请按照以下步骤操作：
- en: 'Create a **PersistentVolumeClaim** for MongoDB, to persist data:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为MongoDB创建**PersistentVolumeClaim**以持久化数据：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Important Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can change the storage class if you install Longhorn or another storage
    driver, or if you are using the storage class provided by your cloud provider.
    Just uncomment the `storageClassName` line by removing the `#` character.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了Longhorn或其他存储驱动，或者使用了云服务提供商提供的存储类，可以更改存储类。只需通过移除`#`字符取消注释`storageClassName`行。
- en: 'Deploy your custom configuration to enable clients to connect to MongoDB:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署你的自定义配置，以便客户端能够连接到MongoDB：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This exposes MongoDB to listening in port `27017` across the network.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过网络暴露MongoDB监听端口`27017`。
- en: 'Create the deployment using the `mongo-configmap`, our `MONGO_INITDB_ROOT_USERNAME`,
    `MONGO_INITDB_ROOT_PASSWORD`, and `MONGO_INITDB_DATABASE` variables that set the
    initial root username, an additional user to connect and their passwords to be
    used when connecting to MongoDB:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mongo-configmap`创建部署，我们的`MONGO_INITDB_ROOT_USERNAME`、`MONGO_INITDB_ROOT_PASSWORD`和`MONGO_INITDB_DATABASE`变量设置初始的根用户名、额外的用户及其连接密码，用于连接MongoDB：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are using some values directly to configure the deployment to simplify the
    example. But it’s a best practice to use secrets to protect sensitive data. You
    can explore [*Chapter 10*](B16945_10_Final_PG.xhtml#_idTextAnchor198), *SQL and
    NoSQL Databases at the Edge*, for more examples. We are also using version 4.4
    in case you want to install MongoDB on an ARM device.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接使用一些值来配置部署，以简化示例。但最佳实践是使用机密来保护敏感数据。你可以查看[*第10章*](B16945_10_Final_PG.xhtml#_idTextAnchor198)，*边缘的SQL和NoSQL数据库*，获取更多示例。我们也使用的是4.4版本，如果你想在ARM设备上安装MongoDB，请参考此版本。
- en: 'Now, create the service that exposes your MongoDB deployment as a service accessible
    inside the cluster (MongoDB uses port `27017` to connect):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建服务，将你的MongoDB部署暴露为集群内可访问的服务（MongoDB使用端口`27017`连接）：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, your MongoDB database has been installed. So, let’s deploy our GPS server
    application that will store data in Redis and our MongoDB in the next section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的MongoDB数据库已经安装完成。那么，让我们在下一部分部署我们的GPS服务器应用程序，存储数据到Redis和MongoDB。
- en: Creating services to monitor your devices in real time using GPS
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务以通过GPS实时监控你的设备
- en: 'In our use case, we are going to deploy a service that sends data from our
    edge device after some processing in the cloud. The goal of this use case is to
    have a global geolocation system for multiple vehicles delivering packages, showing
    their location in real time. For this, we are going to create a `gps-server` deployment
    that stores all the coordinates for our units in Redis and Mongo. We are going
    to use the Python Flask library to create this service. Let’s explore the main
    sections of the following pseudocode mixed with Python:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，我们将部署一个服务，将来自边缘设备的数据经过处理后发送到云端。这个用例的目标是为多个运送包裹的车辆提供全球地理定位系统，实时显示它们的位置。为此，我们将创建一个`gps-server`部署，将所有的坐标存储在Redis和Mongo中。我们将使用Python的Flask库来创建这个服务。接下来，让我们探索以下包含Python的伪代码的主要部分：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s focus on the following functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于以下功能：
- en: '**redisCon**: This function sets the Redis connection. This application is
    going to use the Redis service created in the *Using Redis to store GPS coordinates
    data* section.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**redisCon**：此功能设置Redis连接。此应用将使用*使用Redis存储GPS坐标数据*部分中创建的Redis服务。'
- en: '`/client/<cid>/position` URL, the function will get the `<cid>` value that
    represents a connected client that sends information to this service – in this
    case, our delivery vehicles. Every time the information is received, it is stored
    in the key with the form `client:{cid}:position` inside Redis, and stores the
    latitude as a `lat` variable, the longitude as `lng`, and the client ID or vehicle
    number as `cid`. It also sets an expiration time as 180 seconds or 3 minutes.
    After calling the tracking server to store this coordinate in MongoDB, it returns
    the following JSON response: `{"client_id":cid,"setPosition":"done"}`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/<cid>/position` URL，函数将获取 `<cid>` 值，表示向此服务发送信息的连接客户端——在此案例中是我们的配送车辆。每次接收到信息时，它都会存储在
    Redis 中以 `client:{cid}:position` 形式命名的键中，并存储纬度为 `lat` 变量，经度为 `lng`，客户端 ID 或车辆编号为
    `cid`。它还会设置一个过期时间为 180 秒或 3 分钟。在调用跟踪服务器将该坐标存储到 MongoDB 后，它返回以下 JSON 响应：`{"client_id":cid,"setPosition":"done"}`。'
- en: '`/clients/positions/unit/<unit>/r/<radius>` URL, the function connects to Redis
    and gets all the keys with the form `client:<cid>:position`, which contains the
    current GPS position of each vehicle. Then gets the near stops to this position,
    using the Redis command `geosearch`. The returned JSON will look like: `{"clients":[{"cid":1,"lat":0.0,"lng":0.0,"near":["stop1"]}]}`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/clients/positions/unit/<unit>/r/<radius>` URL，函数连接到 Redis 并获取所有键，其形式为 `client:<cid>:position`，包含每辆车的当前
    GPS 位置。然后，通过使用 Redis 命令 `geosearch` 获取靠近该位置的停靠点。返回的 JSON 将如下所示：`{"clients":[{"cid":1,"lat":0.0,"lng":0.0,"near":["stop1"]}]}`。'
- en: '`/client/<cid>/stops` URL, the function will get `<cid>` and store all the
    positions as a geospatial index in the key with the `client:{cid}:stops` form.
    Inside this key, each position will be stored with the name sent as part of the
    JSON data using `curl`. These stops are stored for 10 hours by default because
    the stops have to be completed during a workday. These stops will be near to the
    vehicle with the `cid` number.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/client/<cid>/stops` URL，函数将获取 `<cid>` 并将所有位置作为地理空间索引存储在以 `client:{cid}:stops`
    形式命名的键中。在此键中，每个位置将与通过 `curl` 发送的 JSON 数据中的名称一起存储。这些停靠点默认存储 10 小时，因为停靠点必须在工作日内完成。这些停靠点将靠近具有
    `cid` 编号的车辆。'
- en: After understanding the code, let’s deploy our GPS server application in the
    next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解代码后，我们将在下一节部署我们的 GPS 服务器应用程序。
- en: Deploying gps-server to store GPS coordinates
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 gps-server 来存储 GPS 坐标
- en: 'The `gps-server` application will receive the GPS coordinates from your edge
    devices. For this, we have to deploy it and expose it using a load balancer. To
    deploy the `gps-server` application, follow the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`gps-server` 应用程序将接收来自您的边缘设备的 GPS 坐标。为此，我们需要部署它并通过负载均衡器公开。要部署 `gps-server`
    应用程序，请按照以下步骤操作：'
- en: 'Create the deployment for the GPS server:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 GPS 服务器的部署：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This deployment uses the following variables:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此部署使用以下变量：
- en: '**REDIS_HOST**: This is the name of the Redis service; this variable can be
    customized to fit your needs.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REDIS_HOST**：这是 Redis 服务的名称；此变量可以根据您的需要进行自定义。'
- en: '**REDIS_AUTH**: This is the password to connect to the Redis service.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REDIS_AUTH**：这是连接 Redis 服务的密码。'
- en: '`tracking-server` – in this case, the URL matches the internal `tracking-server`
    service in port `3000`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracking-server` – 在这种情况下，URL 匹配内部的 `tracking-server` 服务，端口为 `3000`。'
- en: Important Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To check the code and create your own container, refer to this link: [https://github.com/sergioarmgpl/containers/tree/main/gps-server/src](https://github.com/sergioarmgpl/containers/tree/main/gps-server/src).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码并创建自己的容器，请参考此链接：[https://github.com/sergioarmgpl/containers/tree/main/gps-server/src](https://github.com/sergioarmgpl/containers/tree/main/gps-server/src)。
- en: 'Create the service as a LoadBalancer; this IP address will be used in our GPS
    reader services for each unit or truck:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务创建为 LoadBalancer；此 IP 地址将在我们的 GPS 读取器服务中用于每个单位或卡车：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Get the load balancer IP for our `gps-server` deployment with the following
    command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取我们 `gps-server` 部署的负载均衡器 IP：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see the value of the `GPS_SERVER_IP` environment variable by running
    the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令查看 `GPS_SERVER_IP` 环境变量的值：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that it takes some time after the IP address of the load balancer is provisioned.
    You can check the state of the services by running the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在负载均衡器的 IP 地址配置完成后需要一些时间。您可以通过运行以下命令检查服务的状态：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Wait until `EXTERNAL_IP` is provisioned. Also, note the `$GPS_SERVER_IP` value,
    which will be used to configure the `gps-reader` application on each edge device.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 `EXTERNAL_IP` 配置完成。同时，注意 `$GPS_SERVER_IP` 的值，这将用于配置每个边缘设备上的 `gps-reader`
    应用程序。
- en: 'Now, you can set the stops for the first vehicle, represented with value `1`.
    For this, follow the next steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以为第一个车辆设置停靠点，该车辆用值 `1` 表示。为此，请按照以下步骤操作：
- en: 'Use curl to store the stops:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 curl 存储停靠点：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will return the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we have the `gps-server` application deployed and exposed using a load
    balancer. Let’s deploy our `tracking-server`, the one that stores logs about the
    received GPS positions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经部署了 `gps-server` 应用程序，并通过负载均衡器对外暴露。接下来，让我们部署我们的 `tracking-server`，即存储接收到的
    GPS 位置日志的服务器。
- en: Creating a service to log GPS positions and enable real-time tracking for your
    devices
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个服务来记录 GPS 位置并实现设备的实时追踪
- en: 'Our `tracking-server` application will be in charge of logging all the received
    coordinates for each vehicle. This information will be used to show the route
    of a vehicle in the desired time range using the `frontend` application. Before
    deploying `tracking-server`, let’s understand the code of this application:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `tracking-server` 应用程序将负责记录每辆车接收到的所有坐标。该信息将用于在所需的时间范围内，通过 `frontend` 应用程序显示车辆的路线。在部署
    `tracking-server` 之前，让我们先了解一下这个应用程序的代码：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this code we can find the following functions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们可以找到以下功能：
- en: '`tracking` value.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracking` 值。'
- en: '`POST` request in the `/client/<cid>/position` URL, the function will store
    the received GPS position in the `{"cid":1,"lat":0.0,"lng":0.0,"ts":166666666,"dtxt":"01-01-22-23:59:59"}`
    format. `cid` represents the client ID or the number of the vehicle, `lat` and
    `lng` are used to store the GPS position, `ts` represents the timestamp generated
    when the coordinate was received, and `dtxt` is the date in text format to reduce
    transformation time from the timestamp format to the UNIX date format. Once this
    data is stored in the database, `mydatabase` returns the next JSON: `{"client_id":cid,"positionStored":"done"}`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `/client/<cid>/position` URL 中发送 `POST` 请求，函数将以 `{"cid":1,"lat":0.0,"lng":0.0,"ts":166666666,"dtxt":"01-01-22-23:59:59"}`
    格式存储接收到的 GPS 位置。`cid` 表示客户端 ID 或车辆编号，`lat` 和 `lng` 用于存储 GPS 位置，`ts` 表示接收到坐标时生成的时间戳，`dtxt`
    是文本格式的日期，以减少从时间戳格式到 UNIX 日期格式的转换时间。将数据存储到数据库后，`mydatabase` 会返回以下 JSON：`{"client_id":cid,"positionStored":"done"}`。
- en: '`GET` request in the URL with the `/client/<cid>/positions/s/<sdate>/e/<edate>`
    form, it returns a JSON response with all the GPS positions between the starting
    date, `sdate`, and the ending date, `edate`. For this, `tracking-server` connects
    to Mongo and returns the result of performing this query in this time range. The
    information will be returned in the following format:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 URL 中使用 `GET` 请求，格式为 `/client/<cid>/positions/s/<sdate>/e/<edate>`，它会返回一个
    JSON 响应，包含在开始日期 `sdate` 和结束日期 `edate` 之间的所有 GPS 位置。为此，`tracking-server` 会连接到 Mongo
    并返回在此时间范围内执行此查询的结果。信息将以以下格式返回：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we know how the `tracking-server` application works. Let’s deploy this application
    in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `tracking-server` 应用程序的工作原理。接下来，让我们在下一节中部署这个应用程序。
- en: Deploying tracking-server to store logs from GPS coordinates to be used for
    vehicles routing report
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 tracking-server 来存储来自 GPS 坐标的日志，以便用于车辆路线报告
- en: 'Our `tracking-server` will be used in our `frontend` application to show the
    route of a vehicle within the desired time range. Let’s deploy our application
    with the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `tracking-server` 将在我们的 `frontend` 应用程序中使用，以显示车辆在指定时间范围内的路线。让我们通过以下步骤部署我们的应用程序：
- en: 'Deploy `tracking-server` by running the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令部署 `tracking-server`：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This deployment uses the following environment variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本次部署使用以下环境变量：
- en: '`mongodb://USER:PASWORD@HOST/DATABASE?authSource=admin` format. You can customize
    these credentials and store `MONGO_URI` as a secret.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongodb://USER:PASWORD@HOST/DATABASE?authSource=admin` 格式。你可以自定义这些凭证，并将 `MONGO_URI`
    存储为密钥。'
- en: '**MONGO_DB**: This is the database created in MongoDB to store the tracking
    collection.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MONGO_DB**：这是在 MongoDB 中创建的数据库，用于存储 tracking 集合。'
- en: '`tracking` collection of MongoDB. Note that our Python code uses the `pytz`
    library and the ISO 3166 convention for country names. Check the *Further reading*
    section for more information to set your country’s time zone correctly. In this
    case, we set the country to `America/Guatemala`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracking` 集合的 MongoDB。请注意，我们的 Python 代码使用了 `pytz` 库和 ISO 3166 国家名称约定。有关如何正确设置国家时区的更多信息，请查阅
    *进一步阅读* 部分。在此案例中，我们将国家设置为 `America/Guatemala`。'
- en: Important Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find out more about the URI on the following page: [https://www.mongodb.com/docs/manual/reference/connection-string](https://www.mongodb.com/docs/manual/reference/connection-string).
    Remember that we are using hardcoded values to simplify the example, but it’s
    best practice to use secrets. Check out [*Chapter 10*](B16945_10_Final_PG.xhtml#_idTextAnchor198),
    *SQL and NoSQL Databases at the Edge*, for more details. To check out the code
    and create your own version of `tracking-server`, refer to the following link:
    [https://github.com/sergioarmgpl/containers/tree/main/tracking-server/src](https://github.com/sergioarmgpl/containers/tree/main/tracking-server/src).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下页面了解更多关于 URI 的信息：[https://www.mongodb.com/docs/manual/reference/connection-string](https://www.mongodb.com/docs/manual/reference/connection-string)。记住，我们为了简化示例而使用了硬编码值，但最好使用机密信息。查看[*第
    10 章*](B16945_10_Final_PG.xhtml#_idTextAnchor198)，*边缘上的 SQL 和 NoSQL 数据库*，了解更多细节。要查看代码并创建你自己的
    `tracking-server` 版本，请参考以下链接：[https://github.com/sergioarmgpl/containers/tree/main/tracking-server/src](https://github.com/sergioarmgpl/containers/tree/main/tracking-server/src)。
- en: 'Create a service as a ClusterIP for `tracking-server` to call it inside `gps-server`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 ClusterIP 服务以便在 `gps-server` 内部调用 `tracking-server`：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a service as a LoadBalancer for `tracking-server` to call it in our
    viewer application, which is accessible over the internet:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个负载均衡器服务，以便在我们的查看应用程序中调用 `tracking-server`，该应用程序可以通过互联网访问：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Get the load balancer IP of our `tracking-server` deployment with the following
    command:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取我们 `tracking-server` 部署的负载均衡器 IP：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see the value of the `TRACKING_SERVER_IP` environment variable by running
    the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令查看 `TRACKING_SERVER_IP` 环境变量的值：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `tracking-server` application has been deployed. Now, let’s configure our
    device to run our reader application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracking-server` 应用程序已部署。现在，让我们配置设备以运行我们的阅读器应用程序。'
- en: Configuring your Raspberry Pi to track your device using GPS
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置你的 Raspberry Pi 以使用 GPS 跟踪你的设备
- en: 'Before using the GPS module on your Raspberry Pi, you have to follow the following
    steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Raspberry Pi 上使用 GPS 模块之前，你需要按照以下步骤操作：
- en: Install the Raspberry Pi OS Lite (64-bit) on your device; you can check out
    [*Chapter 2*](B16945_02_Final_PG.xhtml#_idTextAnchor036), *K3s Installation and
    Configuration*, for more details.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的设备上安装 Raspberry Pi OS Lite（64 位）；你可以查看[*第 2 章*](B16945_02_Final_PG.xhtml#_idTextAnchor036)，*K3s
    安装与配置*，了解更多细节。
- en: Log in to your device and set an initial user name and password.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到你的设备并设置一个初始用户名和密码。
- en: 'Run `raspi-config` with the following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行 `raspi-config`：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will see a screen like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下屏幕：
- en: '![Figure 13.2 – The raspi-config main menu'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – raspi-config 主菜单'
- en: '](img/B16945_13_02.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_02.jpg)'
- en: Figure 13.2 – The raspi-config main menu
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – raspi-config 主菜单
- en: To configure the wireless network, go to the **System Options** | **Wireless
    LAN** menu.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置无线网络，请进入**系统选项** | **无线局域网**菜单。
- en: You will see a **Choose the country where your Raspberry will be used** message,
    and then click **Ok**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到一个**选择你 Raspberry Pi 使用的国家**的消息，然后点击**确定**。
- en: After that, the **Wireless LAN country** message will appear. Select your country
    and then click **Ok**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，**无线局域网国家**的消息将出现。选择你的国家并点击**确定**。
- en: The **Please Enter SSID** message will appear. Click **Ok** and press **Enter**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请输入 SSID**消息将出现。点击**确定**并按**回车**键。'
- en: Now, the **Please Enter passphrase** message will appear. Click **Ok** and press
    *Enter*.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**请输入密码**消息将出现。点击**确定**并按*回车*键。
- en: Upon returning to the main menu, select **Finish** and press *Enter* to exit.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回主菜单后，选择**完成**并按*回车*键退出。
- en: Activate the SSH, choosing the **Interface Options** | **SSH** menu. This will
    show the **Would you like the SSH server to be enabled?** message. Choose **Yes**
    and press *Enter*. After that, the **The SSH server is enabled** message will
    appear.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 SSH，选择**接口选项** | **SSH**菜单。这将显示**是否启用 SSH 服务器？**消息。选择**是**并按*回车*键。之后，**SSH
    服务器已启用**消息将出现。
- en: 'To check the IP of your Raspberry Pi, run the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查你的 Raspberry Pi 的 IP，请运行以下命令：
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will look like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 13.3 – The ifconfig output'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.3 – ifconfig 输出'
- en: '](img/B16945_13_03.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_03.jpg)'
- en: Figure 13.3 – The ifconfig output
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – ifconfig 输出
- en: Take note of the IP address next to the word `inet` word in the `wlan0` network
    interface; this will be the IP address of your Raspberry Pi.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `wlan0` 网络接口旁边的 `inet` 字样的 IP 地址；这将是你 Raspberry Pi 的 IP 地址。
- en: 'Log in to your device using the previous IP address found using SSH:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面找到的 IP 地址通过 SSH 登录到您的设备：
- en: '[PRE25]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the next kernel parameters to enable the use of container by adding these
    values in the `/boot/cmdline.txt` file; remember that you need root permissions
    to modify this file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内核参数添加到 `/boot/cmdline.txt` 文件中以启用容器功能；请记住，您需要 root 权限才能修改此文件：
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Connect your VK-162 G-Mouse GPS module to one of the USB ports of your Raspberry;
    after some seconds, the `/dev/ttyACM0` device will be ready to be used.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的 VK-162 G-Mouse GPS 模块连接到树莓派的一个 USB 端口；几秒钟后，`/dev/ttyACM0` 设备将准备好使用。
- en: 'Restart your device to apply these changes:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启您的设备以应用这些更改：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '(*Optional*) If you want to configure other features, log in to your device
    and run the following:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 如果您想配置其他功能，请登录到设备并运行以下命令：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: (*Optional*) Activate the `raspi-config`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 激活 `raspi-config`。
- en: (*Optional*) Then, a dialog will show **Would you like the ARM I2C interface
    to be enabled?**. Select **Yes** and press *Enter*.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 然后，弹出对话框会显示 **是否启用 ARM I2C 接口？**。选择 **是** 并按 *Enter*。
- en: (*Optional*) After the previous dialog, the **The ARM I2C interface is enabled**
    message will appear. Press *Enter* to choose the **Ok** button.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 在前一个对话框之后，将显示 **ARM I2C 接口已启用** 信息。按 *Enter* 选择 **确定** 按钮。
- en: (*Optional*) Upon returning to the main menu, select **Finish** and press *Enter*
    to exit.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 返回主菜单后，选择 **完成** 并按 *Enter* 退出。
- en: 'To finish, let’s install K3s by running the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过运行以下命令来安装 K3s：
- en: '[PRE29]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the following command to see whether your K3s single-node cluster is running:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以查看您的 K3s 单节点集群是否正在运行：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will show something like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示类似以下内容：
- en: '![Figure 13.4 – The kubectl get nodes output'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4 – kubectl 获取节点输出'
- en: '](img/B16945_13_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_04.jpg)'
- en: Figure 13.4 – The kubectl get nodes output
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – kubectl 获取节点输出
- en: Important Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find out more about how to use `raspi-config` at the following link:
    [https://geek-university.com/raspi-config](https://geek-university.com/raspi-config).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接了解更多关于如何使用 `raspi-config` 的信息：[https://geek-university.com/raspi-config](https://geek-university.com/raspi-config)。
- en: Now, you have your Raspberry Pi installed with Raspberry Pi OS Lite, which is
    ready to be used together with your GPS module. In the next section, let’s move
    to deploy the GPS reader application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的树莓派已经安装了 Raspberry Pi OS Lite，并且可以与您的 GPS 模块一起使用。在下一部分中，我们将开始部署 GPS 读取应用程序。
- en: Understanding the GPS reader code to send GPS coordinates
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 GPS 读取器代码以发送 GPS 坐标
- en: 'Now, the only remaining part is to install `gps-reader` in the K3s single-node
    cluster installed on your Raspberry. This application will run as a container
    using the Kubernetes Pods. However, before installing our `gps-reader` application,
    let’s understand the code first:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的部分是安装 `gps-reader` 到您 Raspberry 上安装的 K3s 单节点集群中。这个应用程序将作为容器使用 Kubernetes
    Pods 运行。然而，在安装 `gps-reader` 应用程序之前，让我们先理解一下代码：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous code contains an infinite loop that reads the output of the `/dev/ttyACM0`
    device every half second. Our VK-162 G-Mouse GPS module uses the `GRPMC` field
    to get the latitude and longitude coordinates using the `PynMEA2` library. Once
    the library extracts the coordinates, it calls the GPS server endpoint to store
    the current GPS position of the vehicle in Redis and log it in MongoDB.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含一个无限循环，每半秒读取一次 `/dev/ttyACM0` 设备的输出。我们的 VK-162 G-Mouse GPS 模块使用 `GRPMC`
    字段通过 `PynMEA2` 库获取纬度和经度坐标。一旦库提取到坐标，它会调用 GPS 服务器端点将当前的 GPS 位置存储到 Redis 中，并记录到 MongoDB。
- en: Be aware that the GPS module delays a little bit after the module starts receiving
    a GPS coordinate. It could take some minutes before the GPS module starts to receive
    GPS coordinates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GPS 模块在开始接收 GPS 坐标后会有一点延迟。在 GPS 模块开始接收坐标之前，可能需要几分钟时间。
- en: 'To see what your device is doing, run the `cat /dev/ttyACM0` command. If the
    module is not receiving coordinates yet, it will show something like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看设备正在做什么，请运行 `cat /dev/ttyACM0` 命令。如果模块尚未接收坐标，它将显示类似以下内容：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Important Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `GPRMC` or `GPGLL` fields are empty in some parts when the module is not
    receiving coordinates. These missing values contain the latitude and longitude
    obtained by the GPS module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块尚未接收到坐标时，`GPRMC` 或 `GPGLL` 字段会有空值。这些缺失的值包含 GPS 模块获得的纬度和经度。
- en: 'When the device starts to receive data, you will see something like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备开始接收数据时，您将看到类似以下内容：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `GPGLL` line contains all the information about latitude and longitude that
    we are looking for.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPGLL`行包含我们要查找的所有关于纬度和经度的信息。'
- en: Important Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Depending on your device configuration, the `GPRMC` line can include the elevation
    data. In the previous output, the elevation information is not configured, so
    the line will not include this information, but the device can be configured to
    get the elevation information too.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设备配置，`GPRMC`行可能包含海拔数据。在之前的输出中，海拔信息未配置，因此该行不会包含这些信息，但设备可以配置以获取海拔信息。
- en: Now, we know how our application reads information from the GPS module. Let’s
    deploy our application in our device with K3s installed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道应用程序如何从GPS模块读取信息。让我们使用已安装K3s的设备来部署我们的应用程序。
- en: Deploying gps-reader to send GPS coordinates to the cloud
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署gps-reader将GPS坐标发送到云端
- en: One advantage of using K3s is that if your application is complex, you can deploy
    your application separated as modules or microservices, and you can update these
    pieces without affecting the others. In this case, we are only using one piece
    called `gps-reader`. This application reads the GPS module from the device using
    a Pod. In this case, we are using a configuration that enables us to read the
    `/dev` folder from the device with just the necessary permissions to access the
    `/dev/ttyACM0` device, where the GPS module shows the GPS coordinates. This device
    can change, depending on the GPS module that you are using.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用K3s的一个优势是，如果你的应用程序比较复杂，你可以将应用程序分模块或微服务部署，并且可以更新这些模块而不影响其他模块。在这种情况下，我们只使用了一个模块，称为`gps-reader`。这个应用程序通过Pod从设备读取GPS模块。在这个案例中，我们使用的配置允许我们仅用必要的权限读取设备上的`/dev`文件夹，访问`/dev/ttyACM0`设备，GPS模块在此设备上显示GPS坐标。该设备可能会变化，具体取决于你使用的GPS模块。
- en: 'To create a reader on your device, run the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的设备上创建读卡器，请执行以下步骤：
- en: 'Create the `gps-reader` Pod to start reading GPS coordinates from your module:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`gps-reader` Pod以开始从你的模块读取GPS坐标：
- en: '[PRE34]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This Pod will use the following environment variables:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此Pod将使用以下环境变量：
- en: '**DEVICE**: This contains the virtual device where the GPS module is listening.
    This could be different, depending on the GPS module that you are using. Check
    the *Further reading* section for more information.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DEVICE**：此项包含GPS模块监听的虚拟设备。根据你使用的GPS模块，可能会有所不同。请参阅*进一步阅读*部分获取更多信息。'
- en: '**CLIENT_ID**: This is the vehicle number that this reader will represent in
    the system – in this case, 1, the first vehicle.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLIENT_ID**：这是该读卡器在系统中代表的车辆编号——在此案例中为1，表示第一辆车。'
- en: '`GPS_SERVER_IP` variable in the *Deploying gps-server to store GPS coordinates*
    section.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPS_SERVER_IP`变量在*部署gps-server以存储GPS坐标*部分中。'
- en: Important Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'To check the code and create your own container of `gps-reader`, refer to the
    following link: [https://github.com/sergioarmgpl/containers/tree/main/gps-reader/src](https://github.com/sergioarmgpl/containers/tree/main/gps-reader/src).
    If you want to use an OLED screen to show information, refer to the following
    link: [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/blob/main/ch13/code/python/oled.py](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/blob/main/ch13/code/python/oled.py).
    The code uses the OLED included in the Raspberry Pi 4B keyestudio Complete RFID
    Starter kit.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码并创建你自己的`gps-reader`容器，请参考以下链接：[https://github.com/sergioarmgpl/containers/tree/main/gps-reader/src](https://github.com/sergioarmgpl/containers/tree/main/gps-reader/src)。如果你想使用OLED屏幕显示信息，请参考以下链接：[https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/blob/main/ch13/code/python/oled.py](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/blob/main/ch13/code/python/oled.py)。该代码使用树莓派4B的keyestudio
    Complete RFID Starter套件中的OLED屏幕。
- en: 'You can check whether your device is reading information by running the following:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令检查你的设备是否正在读取信息：
- en: '[PRE35]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you’re not sure whether you have access to your device, the way to test is
    by looking at the frontend and checking whether the device appears on the map.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定是否可以访问你的设备，可以通过查看前端并检查设备是否出现在地图上来测试。
- en: 'The output will look like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Press *Ctrl* + *C* to cancel.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *C*取消操作。
- en: Write `exit` and press *Enter* to exit from your Raspberry.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`exit`并按*Enter*退出你的树莓派。
- en: Now, we have all the backend services running and receiving data, but we need
    to visualize this information. Let’s move to the next section to deploy the `frontend`
    application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经启动了所有后端服务并接收数据，但我们需要将这些信息可视化。接下来，进入下一部分，部署`frontend`应用程序。
- en: Visualizing your devices using Open Street Maps in real time
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Open Street Maps实时可视化您的设备
- en: Our application has two parts, one that visualizes the GPS coordinates of the
    vehicles and their near stops in real time and one that shows the past routes
    of the vehicle within a time range. So, let’s understand first the code of the
    geo-tracking map showing the devices in real time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有两个部分，一个是实时可视化车辆的GPS坐标及其附近的停靠点，另一个是显示车辆在时间范围内的历史轨迹。因此，让我们首先了解实时显示设备的地理跟踪地图的代码。
- en: Understanding the geo-tracking map visualizer code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解地理跟踪地图可视化代码
- en: 'Let’s start with a map showing all the vehicles with their coordinates and
    near stops. We are using HTML, JavaScript, jQuery and the Leaflet library to create
    the map. Let’s look at the code of the map:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一张显示所有车辆及其坐标和附近停靠点的地图开始。我们使用HTML、JavaScript、jQuery和Leaflet库来创建这张地图。让我们来看一下地图的代码：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our page loads some JavaScript libraries and CSS styles. After that, it loads
    an initial GPS position to show the map. This map is loaded in the `<div id='map'></div>`
    code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面加载了一些JavaScript库和CSS样式。之后，它加载了一个初始的GPS位置来显示地图。此地图被加载到`<div id='map'></div>`代码中。
- en: 'The important functions in this code are the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码中的重要函数如下：
- en: '`gps-server` to get all the GPS coordinates. To do this, the `setInterval`
    function calls the `http://GPS_SERVER_IP:3000/clients/positions/unit/km/r/0.1`
    URL, which returns the current GPS coordinates of each vehicle and their nearby
    stops in a radius of 0.1 kilometers. To do this, call the `markPosition` function
    every 5 seconds and send the client ID or vehicle number (`cid`), latency (`lat`),
    longitude (`lng`), and the `near` variable with the name of the stops. This function
    creates a mark object in the map.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gps-server`用于获取所有的GPS坐标。为此，`setInterval`函数调用`http://GPS_SERVER_IP:3000/clients/positions/unit/km/r/0.1`网址，该网址返回每个车辆的当前位置和其周围0.1公里范围内的停靠点。为此，每隔5秒调用`markPosition`函数，并传送客户端ID或车辆编号（`cid`）、纬度（`lat`）、经度（`lng`）以及包含停靠点名称的`near`变量。此函数将在地图上创建一个标记对象。'
- en: '**markPosition**: This function creates a Leaflet mark object with a PopUp
    window in the map. This function also resets the map when it’s called.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**markPosition**：该函数在地图上创建一个Leaflet标记对象，并在地图上弹出窗口。调用此函数时，还会重置地图。'
- en: 'This application basically loads all the necessary libraries and calls the
    `setInterval` function to refresh the map every 5 seconds by calling the `markPosition`
    function. It is important to set an initial GPS position to center the map; this
    is customizable in the YAML file used to deploy the `frontend` application. Once
    the map is initialized, it will show all the tracked objects after 5 seconds:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序基本上加载所有必要的库，并调用`setInterval`函数，每5秒刷新一次地图，通过调用`markPosition`函数。设置初始GPS位置以居中地图是非常重要的；这个位置可以在用于部署`frontend`应用程序的YAML文件中进行自定义。地图初始化后，5秒后将显示所有跟踪的对象：
- en: '![Figure 13.5 – A map showing two tracked devices using GPS'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5 – 显示两台使用GPS的设备的地图'
- en: '](img/B16945_13_05.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_05.jpg)'
- en: Figure 13.5 – A map showing two tracked devices using GPS
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 显示两台使用GPS的设备的地图
- en: 'If the connected devices are not sending data to the map, it will show an empty
    map; in this case, *Figure 13.5* shows two devices connected and sending data.
    Now, let’s say, for example, that we are using the device or vehicle number 2
    – in this case, represented as the second `CID` (client ID). If you click on the
    blue mark, it will show the current `Latitude` and `Longitude` coordinates and
    the near destinations or stops of the tracked vehicle. In this case, we set two
    stops, `galeno_encinal` and `la_torre_encinal`, which are 0.1 km from the current
    position of the tracked vehicle. If you click on the blue mark, you will see something
    like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接的设备没有向地图发送数据，它将显示一张空白地图；在这种情况下，*图13.5*显示了两台连接并发送数据的设备。现在，假设我们使用的是设备或车辆编号为2——在此例中，表示为第二个`CID`（客户端ID）。如果点击蓝色标记，它将显示当前的`纬度`和`经度`坐标，以及跟踪车辆的附近目的地或停靠点。在这种情况下，我们设置了两个停靠点，`galeno_encinal`和`la_torre_encinal`，它们距离跟踪车辆当前位置0.1公里。如果点击蓝色标记，你将看到类似的内容：
- en: '![Figure 13.6 – Near destinations showed when clicking the blue mark'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 – 点击蓝色标记时显示的附近目的地'
- en: '](img/B16945_13_06.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_06.jpg)'
- en: Figure 13.6 – Near destinations showed when clicking the blue mark
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 点击蓝色标记时显示的附近目的地
- en: This information is calculated every 5 seconds, updating the nearest position
    of your tracked vehicle in real time. You can customize the code to fit your needs;
    this is just a quick-start example to build a geo-tracking system using GPS. Let’s
    look at how our vehicles routes report works to show the collected data from the
    tracked vehicles.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息每5秒计算一次，实时更新您被跟踪车辆的最近位置。您可以根据需要定制代码；这只是一个构建使用GPS的地理跟踪系统的快速入门示例。让我们看看我们的车辆路线报告如何工作，以显示从跟踪车辆收集的数据。
- en: Understanding the vehicles routes report
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解车辆路线报告
- en: 'This application creates a blue line, showing the tracking log stored in MongoDB.
    This represents the route of the vehicle within a date or time range. Before we
    take an in-depth look into how it works, let’s explore first the code of this
    page:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序创建一个蓝线，显示存储在MongoDB中的跟踪日志。这代表了车辆在特定日期或时间范围内的路线。在我们深入研究其工作原理之前，让我们首先探讨一下本页的代码：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s analyze the next code sections:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析下一个代码段：
- en: '**trip**: This variable contains all the coordinates to draw a line in the
    map with the routes covered by the vehicle within a time range.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**trip**: 这个变量包含所有坐标，用于在地图上绘制车辆在时间范围内覆盖的路线。'
- en: '**form**: This is an HTML form used to generate the dynamic called to get all
    the GPS positions between a selected time range.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**form**: 这是一个用于生成动态调用的HTML表单，以获取所选时间范围内所有GPS位置的工具。'
- en: '`tracking-server` and get all the GPS positions. This URL has the following
    structure: `http://TRACKING_SERVER_IP:3000/client/2/positions/s/25-05-22-04:39:58/e/25-05-22-04:40:00`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracking-server` 并获取所有GPS位置。此URL的结构如下：`http://TRACKING_SERVER_IP:3000/client/2/positions/s/25-05-22-04:39:58/e/25-05-22-04:40:00`。'
- en: '**onEachFeature**: This is a function that creates a line with the GPS positions
    of the vehicle.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onEachFeature**: 这是一个创建包含车辆GPS位置的线的函数。'
- en: '**LoadMap**: This is a function that is called after clicking on the load button
    of the form to show the routes covered within a time range for a vehicle.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadMap**: 这是一个在点击表单加载按钮后调用的函数，用于显示车辆在时间范围内覆盖的路线。'
- en: 'In general, this report page is generated when the **Show Route History** button
    is clicked, showing the route of the vehicle on the map as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，当单击**显示路线历史**按钮时，会生成此报告页面，显示地图上车辆的路线如下：
- en: '![Figure 13.7 – Vehicles Routes Report'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.7 – 车辆路线报告'
- en: '](img/B16945_13_07.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_07.jpg)'
- en: Figure 13.7 – Vehicles Routes Report
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 车辆路线报告
- en: Our `tracking-server` service is configured to store and query the log tracking
    information of the vehicles within a time range using the timestamp captured when
    data arrives. This application is also configured to use localization times and
    UTC in different countries. This is a basic implementation of the vehicles routes
    report that you can customize.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `tracking-server` 服务配置为在不同国家使用本地化时间和UTC时存储和查询车辆跟踪信息的日志。这是一个基本的车辆路线报告的实现，您可以根据需要进行定制。
- en: Important Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To know more about what is UTC time, you can check the next link: [https://www.timeanddate.com/time/aboututc.html](https://www.timeanddate.com/time/aboututc.html).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于UTC时间的信息，请查看以下链接：[https://www.timeanddate.com/time/aboututc.html](https://www.timeanddate.com/time/aboututc.html)。
- en: 'Another feature that this map has is that when you click on the map, it can
    show some information. In this case, we are showing a sample message, but you
    can customize it to show additional information, such as the time when the vehicle
    was in a particular position:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此地图的另一个功能是，当您单击地图时，它可以显示一些信息。在这种情况下，我们显示了一个示例消息，但您可以根据需要进行定制，例如显示车辆在特定位置的时间：
- en: '![Figure 13.8 – Route information of the vehicle when clicking on the map'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.8 – 点击地图时车辆路线信息'
- en: '](img/B16945_13_08.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_13_08.jpg)'
- en: Figure 13.8 – Route information of the vehicle when clicking on the map
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 点击地图时车辆路线信息
- en: To reset the report, you have to reload the page. With this, we are ready to
    deploy our frontend application, which contains the real time map and this report,
    so finally, we can access the final application. To do this, let’s move on to
    the next section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要重置报告，您需要重新加载页面。通过这样做，我们准备部署包含实时地图和此报告的前端应用程序，最终可以访问最终应用程序。为此，让我们继续下一节。
- en: Deploying a real-time map and report application to track your devices
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署实时地图和报告应用程序来跟踪您的设备。
- en: 'Now we have all the things ready, so we have to deploy the front application
    that contains our real time map and the report page. To do this, we use a simple
    Flask application with Python using templates; here is the code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好所有东西，所以我们需要部署包含实时地图和报告页面的前端应用。为此，我们使用一个简单的 Flask 应用，结合 Python 和模板；以下是代码：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This application renders the `map.html` page, which loads the Leaflet library
    to show the maps using the initial latitude and longitude variables. It also sets
    the endpoint of the `gps-server` that is called inside this static page. To deploy
    this application, follow these steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用呈现 `map.html` 页面，加载 Leaflet 库以显示地图，使用初始的纬度和经度变量。它还设置了 `gps-server` 的端点，该端点在此静态页面中被调用。要部署此应用，请按以下步骤操作：
- en: 'Create the deployment by running the following:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建部署：
- en: '[PRE40]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This deployment has the following environment variables:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此部署包含以下环境变量：
- en: '**LATITUDE**: The initial GPS latitude coordinate to center your map'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纬度**: 用于定位地图中心的初始 GPS 纬度坐标'
- en: '**LONGITUDE**: The initial GPS longitude coordinate to center your map'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经度**: 用于定位地图中心的初始 GPS 经度坐标'
- en: '`gps-server` application.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gps-server` 应用。'
- en: '`tracking-server` application.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracking-server` 应用。'
- en: With these variables, you configure the initial loaded GPS coordinate to center
    the map and the endpoints to be called by the pages, to show the real-time map
    of the report routes of the `frontend` application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些变量，你可以配置初始加载的 GPS 坐标以定位地图中心，并设置页面调用的端点，显示 `frontend` 应用的报告路线实时地图。
- en: Important Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'To check out the code and create your own container of `frontend`, refer to
    the following link: [https://github.com/sergioarmgpl/containers/tree/main/frontend/src](https://github.com/sergioarmgpl/containers/tree/main/frontend/src).
    To get some initial GPS coordinates to center the map when loading, refer to this
    website: [https://www.gps-coordinates.net](https://www.gps-coordinates.net).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码并创建你自己的 `frontend` 容器，请参阅以下链接：[https://github.com/sergioarmgpl/containers/tree/main/frontend/src](https://github.com/sergioarmgpl/containers/tree/main/frontend/src)。要获取加载时地图中心的初始
    GPS 坐标，请访问此网站：[https://www.gps-coordinates.net](https://www.gps-coordinates.net)。
- en: 'Create a load balancer service for your application:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的应用创建负载均衡器服务：
- en: '[PRE41]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Get the load balancer IP of our `frontend` deployment with the following command:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取 `frontend` 部署的负载均衡器 IP：
- en: '[PRE42]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can see the value of the `FRONTEND_IP` environment variable by running
    the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令查看 `FRONTEND_IP` 环境变量的值：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Important Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'We used a `LoadBalancer` service type to simplify the implementation, but a
    cheaper solution would be to use ingress definitions to expose the applications.
    You can explore the following link for more information: [https://kubernetes.io/docs/concepts/services-networking/ingress](https://kubernetes.io/docs/concepts/services-networking/ingress).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `LoadBalancer` 服务类型来简化实现，但一种更便宜的解决方案是使用 Ingress 定义来暴露应用程序。你可以通过以下链接获取更多信息：[https://kubernetes.io/docs/concepts/services-networking/ingress](https://kubernetes.io/docs/concepts/services-networking/ingress)。
- en: 'Now, access your application as `http://<FRONTEND_IP>:3000` in your browser.
    The important endpoints of the URL are the following:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中访问 `http://<FRONTEND_IP>:3000`，以下是 URL 的重要端点：
- en: '`http://<FRONTEND_IP>:3000`'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://<FRONTEND_IP>:3000`'
- en: '`http://<FRONTEND_IP>:3000/report`'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://<FRONTEND_IP>:3000/report`'
- en: Now, turn on your Raspberry Pi device in your vehicle and wait until your device
    starts sending GPS coordinates. Don’t forget to set your stops for each device.
    After some seconds or a couple of minutes, your map will start to show your devices
    in real time.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的车辆中打开 Raspberry Pi 设备，并等待直到设备开始发送 GPS 坐标。别忘了为每个设备设置停靠点。几秒钟或几分钟后，你的地图将开始实时显示设备的位置。
- en: Record some data by driving your equipped vehicle with your Raspberry Pi device
    and then test your reports.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在装备了 Raspberry Pi 设备的车辆中驾驶并记录一些数据，随后测试你的报告。
- en: Now, our simple geolocation system is ready and running. After finishing this
    chapter, it is important to mention that this is just a basic example that you
    can extend to fit your needs. Now, it’s time to recap what we learned.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的简单地理定位系统已经准备就绪并开始运行。在完成本章内容后，重要的是要提到，这只是一个基本示例，你可以根据需求进行扩展。现在，是时候回顾我们所学到的内容了。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we learned how to take advantage of MongoDB and Redis to store
    and query GPS coordinates to build a basic geolocalization system. We also learned
    how to integrate a GPS module to an edge device and send information to the cloud
    to finally visualize how a vehicle is moving in real time on a map, showing the
    near stops in a circle area, and simulating in that way a basic tracking delivery
    system. This shows how to implement a simple use case using geolocalization and
    how edge devices moving in real time interact in a geolocalization system. In
    the next chapter, we are going to learn how to use machine learning and computer
    vision to create a small smart traffic project.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用 MongoDB 和 Redis 存储和查询 GPS 坐标，以构建一个基础的地理定位系统。我们还学习了如何将 GPS 模块集成到边缘设备中，并将信息发送到云端，最终在地图上实时可视化车辆的移动，展示圆形区域内的附近停靠点，从而模拟一个基础的跟踪配送系统。这展示了如何使用地理定位实现一个简单的应用案例，以及边缘设备在实时移动中如何在地理定位系统中互动。在下一章中，我们将学习如何使用机器学习和计算机视觉创建一个小型智能交通项目。
- en: Questions
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are a few questions to validate your new knowledge:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些问题，用于验证你新的知识：
- en: How can I use GPS technologies to create a geolocalization system?
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 GPS 技术创建一个地理定位系统？
- en: How can I use Redis to store GPS coordinates and do queries with this data?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Redis 存储 GPS 坐标并对这些数据进行查询？
- en: How can I use MongoDB to store logs for a geolocalization system?
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 MongoDB 存储地理定位系统的日志？
- en: How can I design a real-time application that shows the GPS positions of moving
    vehicles?
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计一个实时应用，展示移动车辆的 GPS 位置？
- en: How can I use edge computing and K3s to create a distributed system to track
    vehicles?
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用边缘计算和 K3s 创建一个分布式系统来跟踪车辆？
- en: Further reading
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following references for more information on the topics
    covered in this chapter:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下资料，了解本章涵盖的主题：
- en: 'VK-162 G-Mouse GPS module: [https://www.amazon.com/Navigation-External-Receiver-Raspberry-Geekstory/dp/B078Y52FGQ](https://www.amazon.com/Navigation-External-Receiver-Raspberry-Geekstory/dp/B078Y52FGQ)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VK-162 G-Mouse GPS 模块： [https://www.amazon.com/Navigation-External-Receiver-Raspberry-Geekstory/dp/B078Y52FGQ](https://www.amazon.com/Navigation-External-Receiver-Raspberry-Geekstory/dp/B078Y52FGQ)
- en: 'Redis geospatial index commands: [https://redis.io/commands/?group=geo](https://redis.io/commands/?group=geo)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 空间索引命令： [https://redis.io/commands/?group=geo](https://redis.io/commands/?group=geo)
- en: 'Geospatial data: [https://www.mongodb.com/docs/manual/geospatial-queries](https://www.mongodb.com/docs/manual/geospatial-queries)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间数据： [https://www.mongodb.com/docs/manual/geospatial-queries](https://www.mongodb.com/docs/manual/geospatial-queries)
- en: '*Positioning chips and modules*: [https://www.u-blox.com/en/positioning-chips-and-modules](https://www.u-blox.com/en/positioning-chips-and-modules)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定位芯片和模块*： [https://www.u-blox.com/en/positioning-chips-and-modules](https://www.u-blox.com/en/positioning-chips-and-modules)'
- en: '*Basics of Hash Tables*: [https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial](https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希表基础*： [https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial](https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial)'
- en: '*Find Arduino Port on Windows, Mac, and Linux*: [https://www.mathworks.com/help/supportpkg/arduinoio/ug/find-arduino-port-on-windows-mac-and-linux.html](https://www.mathworks.com/help/supportpkg/arduinoio/ug/find-arduino-port-on-windows-mac-and-linux.html)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Windows、Mac 和 Linux 上查找 Arduino 端口*： [https://www.mathworks.com/help/supportpkg/arduinoio/ug/find-arduino-port-on-windows-mac-and-linux.html](https://www.mathworks.com/help/supportpkg/arduinoio/ug/find-arduino-port-on-windows-mac-and-linux.html)'
- en: 'raspi-config: [https://geek-university.com/raspi-config](https://geek-university.com/raspi-config)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: raspi-config： [https://geek-university.com/raspi-config](https://geek-university.com/raspi-config)
- en: '*GPS – NMEA sentence information*: [http://aprs.gids.nl/nmea](http://aprs.gids.nl/nmea)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GPS – NMEA 语句信息*： [http://aprs.gids.nl/nmea](http://aprs.gids.nl/nmea)'
- en: '*Leaflet – an open source JavaScript library for mobile-friendly interactive
    maps*: [https://leafletjs.com](https://leafletjs.com)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Leaflet – 一个开源的 JavaScript 库，用于移动友好的互动地图*： [https://leafletjs.com](https://leafletjs.com)'
- en: '*GPS Coordinates*: [https://www.gps-coordinates.net](https://www.gps-coordinates.net)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GPS 坐标*： [https://www.gps-coordinates.net](https://www.gps-coordinates.net)'
- en: '*Epoch and Unix Timestamp Conversion Tools*: [https://www.epochconverter.com](https://www.epochconverter.com)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Epoch 和 Unix 时间戳转换工具*： [https://www.epochconverter.com](https://www.epochconverter.com)'
- en: 'pytz timezones Library: [https://pypi.org/project/pytz](https://pypi.org/project/pytz)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytz 时区库： [https://pypi.org/project/pytz](https://pypi.org/project/pytz)
- en: 'Country codes: [https://www.iban.com/country-codes](https://www.iban.com/country-codes)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家代码：[https://www.iban.com/country-codes](https://www.iban.com/country-codes)
