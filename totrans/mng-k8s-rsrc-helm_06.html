<html><head></head><body>
		<div id="_idContainer074">
			<h1 id="_idParaDest-120" class="chapter-number"><a id="_idTextAnchor167"/>6</h1>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor168"/>Understanding Helm Templates</h1>
			<p>One of the fundamental features of Helm is to create and maintain the Kubernetes resources that comprise an application. Helm accomplishes this with a concept called <strong class="bold">templates</strong>. Templates <a id="_idIndexMarker327"/>represent the core component comprising Helm charts, as they are used to configure Kubernetes resources based on a given set of <strong class="bold">values</strong>.</p>
			<p>In <a href="B17979_04.xhtml#_idTextAnchor139"><em class="italic">Chapter 4</em></a>, <em class="italic">Scaffolding a New Helm Chart</em>, you scaffolded a new Helm chart by using the <strong class="source-inline">helm create</strong> command, which created basic templates under the chart’s <strong class="source-inline">templates/</strong> folder. In this chapter, we will dive deep into the world of Helm templates, and at the end, we will revisit the scaffolded templates to make improvements and deploy the Guestbook frontend. By the end of the chapter, your Helm chart will be able to deploy the full Guestbook architecture—from the Redis backend added in <a href="B17979_05.xhtml#_idTextAnchor154"><em class="italic">Chapter 5</em></a>, <em class="italic">Helm Dependency Management</em>, to the frontend that we will add later in this chapter.</p>
			<p>Here are the main topics for this chapter:</p>
			<ul>
				<li>Helm template basics</li>
				<li>Template values</li>
				<li>Built-in objects</li>
				<li>Helm template functions</li>
				<li>Helm template control structures</li>
				<li>Generating release notes</li>
				<li>Helm template variables</li>
				<li>Helm template validation</li>
				<li>Enabling code reuse with named templates and library charts</li>
				<li>Creating <strong class="bold">custom resource definitions</strong> (<strong class="bold">CRDs</strong>)</li>
				<li>Post rendering</li>
				<li>Updating and deploying the Guestbook chart</li>
			</ul>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor169"/>Technical requirements</h1>
			<p>This chapter requires the following tools:</p>
			<ul>
				<li>minikube</li>
				<li>kubectl</li>
				<li>Helm</li>
				<li>Git</li>
			</ul>
			<p>We will use minikube to explore several examples throughout this chapter, so feel free to start your minikube environment by running the following command:</p>
			<p class="source-code">$ minikube start</p>
			<p>Once minikube has started, create a new namespace for this chapter, like so:</p>
			<p class="source-code">$ kubectl create namespace chapter6</p>
			<p>If you have not already cloned the example Git repository in previous chapters, do so by running the following command:</p>
			<p class="source-code">$ git clone https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm.git</p>
			<p>Now that your environment is set up, let’s explore this chapter’s first topic—Helm templating.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor170"/>Helm template basics</h1>
			<p>Helm templates<a id="_idIndexMarker328"/> are used to dynamically generate Kubernetes <strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>) (or <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>)) resources. They<a id="_idIndexMarker329"/> consume a set of default and<a id="_idIndexMarker330"/> user-provided values to generate resources that comprise a Kubernetes application. You’ve had some exposure to templates already in <a href="B17979_04.xhtml#_idTextAnchor139"><em class="italic">Chapter 4</em></a>, <em class="italic">Scaffolding a New Helm Chart</em>, when you ran the <strong class="source-inline">helm create</strong> command, which generated a set of starter templates. In the Git repository cloned previously, these templates are located at <strong class="source-inline">chapter6/guestbook/templates/</strong>. Here’s a short snippet of the <strong class="source-inline">deployment.yaml</strong> Helm template, located <a id="_idIndexMarker331"/>within the <strong class="source-inline">chapter6/guestbook/templates/deployment.yaml</strong> file:</p>
			<pre class="source-code">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "guestbook.fullname" . }}
  labels:
    {{- include "guestbook.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "guestbook.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      {{- with .Values.podAnnotations }}
      annotations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      labels:
        {{- include "guestbook.selectorLabels" . | nindent 8 }}</pre>
			<p>You may<a id="_idIndexMarker332"/> find the syntax from the preceding code snippet to be odd, as it resembles a YAML file, but it contains characters that are invalid per the YAML specification. To understand this syntax, we must first talk about <strong class="bold">Go</strong>. Go<a id="_idIndexMarker333"/> is a programming language developed by Google in 2009. It is the programming language used by Kubernetes, Helm, and many other tools in the container community. A core component of the Go programming language is <strong class="bold">templates</strong>, which are used to generate files of many different formats. Helm’s template engine is built off of Go and can be thought of as a superset of Go templates. Go templates<a id="_idIndexMarker334"/> provide the fundamental syntax and control, while Helm adds extra capabilities to enhance the template engine’s capabilities.</p>
			<p>Helm templates contain various different actions, or strings, that begin with two opening curly braces ( <strong class="source-inline">{{</strong> ) and end with accompanying two closing curly braces ( <strong class="source-inline">}}</strong> ). Actions mark locations where data processing occurs or where control structures such as conditionals and loops are implemented. You can see different actions located throughout the code snippets and in other Helm chart templates under the <strong class="source-inline">templates/</strong> directory. While actions appear in local template files, they are processed and removed during processing, such as during an installation or upgrade, to produce a valid Kubernetes YAML resource.</p>
			<p>There are many <a id="_idIndexMarker335"/>different components such as objects, functions, and control structures that you can leverage to write actions throughout your Helm chart templates. We will explore each of these throughout this chapter. Let’s begin by discussing how the <strong class="source-inline">values</strong> component can be used within chart templates.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor171"/>Template values</h1>
			<p>In previous chapters, we<a id="_idIndexMarker336"/> described values as parameters that are used to configure a Helm chart. Now, we will gain an understanding of how values are integrated into chart templates to dynamically generate Kubernetes resources.</p>
			<p>Here is a basic <strong class="source-inline">ConfigMap</strong> template from the Git repository at <strong class="source-inline">chapter6/examples/values-example/templates/configmap.yaml</strong>:</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: values-example
data:
  config.properties: |-
    chapterNumber={{ .Values.chapterNumber }}
    chapterName={{ .Values.chapterName }}</pre>
			<p>The last two lines of this template contain <strong class="source-inline">{{ .Values.chapterNumber }}</strong> and <strong class="source-inline">{{ .Values.chapterName }}</strong> actions, which are used as placeholders for the <strong class="source-inline">chapterNumber</strong> and <strong class="source-inline">chapterName</strong> values. This allows the ConfigMap to be parameterized based on the default chart values and the values the user provides during installation or upgrade.</p>
			<p>Let’s take a look at the<a id="_idIndexMarker337"/> default chart values located at <strong class="source-inline">chapter6/examples/values-example/values.yaml</strong>. You can see these here:</p>
			<pre class="source-code">
chapterNumber: 6
chapterName: Understanding Helm Templates</pre>
			<p>Given this <strong class="source-inline">Values</strong> file, we would expect the default ConfigMap to be rendered like this:</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: values-example
data:
  config.properties: |-
    chapterNumber=6
    chapterName=Understanding Helm Templates</pre>
			<p>You could verify this on your own by running the <strong class="source-inline">helm install</strong> command, as we have demonstrated in previous chapters, but it may be more convenient to leverage a new command, <strong class="source-inline">helm template</strong>, which is used to render template resources locally, but not install them to the Kubernetes cluster. The <strong class="source-inline">helm template</strong> command, as shown here, has the same syntax as <strong class="source-inline">helm install</strong>:</p>
			<p class="source-code">helm template &lt;RELEASE_NAME&gt; &lt;CHART_NAME&gt; [flags]</p>
			<p>Let’s use this command to <a id="_idIndexMarker338"/>render the <strong class="source-inline">values-example</strong> chart templates locally. Proceed as follows:</p>
			<ol>
				<li>Run the <strong class="source-inline">helm template</strong> command, pointing the <strong class="source-inline">&lt;CHART_NAME&gt;</strong> parameter to the <strong class="source-inline">values-example</strong> folder, as follows:<p class="source-code"><strong class="bold">$ helm template example chapter6/examples/values-example</strong></p></li>
				<li>You should see the ConfigMap rendered as shown previously, with the actions replaced by <strong class="source-inline">chapterNumber</strong> and <strong class="source-inline">chapterName</strong> values, as illustrated in the following code snippet:<p class="source-code">&lt;skipped for brevity&gt;</p><p class="source-code">data:</p><p class="source-code">  config.properties: |-</p><p class="source-code">    chapterNumber=6</p><p class="source-code">    chapterName=Understanding Helm Templates</p></li>
			</ol>
			<p>Unless we intend to install resources to the minikube environment, we will use the <strong class="source-inline">helm template</strong> command to quickly demonstrate templating constructs throughout this chapter. That way, you won’t have to worry about cleaning up after each exercise. We will return to using <strong class="source-inline">helm install</strong> at the end of this chapter when we install an updated version of the Guestbook Helm chart.</p>
			<p>As you saw in the preceding example, templates that reference values refer to a construct called <strong class="source-inline">.Values</strong> each <a id="_idIndexMarker339"/>time an action is being used as a placeholder for chart values. <strong class="source-inline">.Values</strong> is one of several built-in objects that are at your disposal as a Helm chart developer. Let’s explore these built-in objects next.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor172"/>Built-in objects</h1>
			<p>Built-in objects<a id="_idIndexMarker340"/> are essential building blocks that you can use to write your own Helm charts. As mentioned previously, they provide access to chart values by using the <strong class="source-inline">.Values</strong> object, but there are many more objects to explore that provide access to additional information and features.</p>
			<p>The following table lists these built-in objects:</p>
			<table id="table001-6" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Object</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Definition</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Values</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to access values in the <strong class="source-inline">values.yaml</strong> file or values that were provided using the <strong class="source-inline">--values</strong> and <strong class="source-inline">--set</strong> flags</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Release</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to access metadata about the Helm release, such as its name, namespace, and revision number</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Chart</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to access metadata about the Helm chart, such as its name and version</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Template</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to access metadata about chart templates, such as their filename and path</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Capabilities</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to access information about the Kubernetes cluster</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Files</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to access arbitrary files within a Helm chart directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>The root object</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – Built-in Helm objects</p>
			<p>Each object <a id="_idIndexMarker341"/>contains fields and functions that are accessible by using dot notation. Dot notation is used to access an object’s properties. For example, imagine the following <strong class="source-inline">Values</strong> file is provided:</p>
			<pre class="source-code">
books:
  harryPotter:
    - The Sorcerer's Stone
    - The Chamber of Secrets
    - The Prisoner of Azkaban
  lotr:
    - The Fellowship of the Ring
    - The Two Towers
    - Return of the King</pre>
			<p>The <strong class="source-inline">.Values</strong> object would now contain the following properties:</p>
			<ul>
				<li><strong class="source-inline">.Values.books.harryPotter</strong> (list of strings)</li>
				<li>.<strong class="source-inline">Values.books.lotr</strong> (list of strings)</li>
			</ul>
			<p>In Helm (and Go templates), a dot (<strong class="source-inline">.</strong>) is also used to represent object scope. The dot represents global scope, from which all objects are accessible. A dot followed by an object name limits the scope of that object. For example, the <strong class="source-inline">.Values</strong> scope limits visibility to the chart’s values, and the <strong class="source-inline">.Release</strong> scope limits visibility to the release’s metadata. Scopes play a significant role in loops and control structures, which we will explore later<a id="_idIndexMarker342"/> in this chapter.</p>
			<p>While the <strong class="source-inline">.Values</strong> object is the most common object that you will use throughout Helm chart development, there are other built-in objects that we will discuss. We’ll start with the <strong class="source-inline">.Release</strong> object next.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor173"/>The .Release object</h2>
			<p>The <strong class="source-inline">.Release</strong> object is <a id="_idIndexMarker343"/>used to retrieve metadata about the Helm release being installed. Two common attributes that are used from within the <strong class="source-inline">.Release</strong> object are <strong class="source-inline">.Release.Name</strong> and <strong class="source-inline">.Release.Namespace</strong>, which allow chart developers to substitute the release name and namespace in their chart templates.</p>
			<p>Consider the following example template, located at <strong class="source-inline">chapter6/examples/release-example/templates/configmap.yaml</strong> in the Git repository:</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}
data:
  config.properties: |-
    namespace={{ .Release.Namespace }}</pre>
			<p>In the template, we are setting the ConfigMap’s name to the name of the Helm release, and we are setting the namespace property to the release namespace.</p>
			<p>When running the Helm <strong class="source-inline">install</strong>, <strong class="source-inline">upgrade</strong>, or <strong class="source-inline">template</strong> commands, you can see the <strong class="source-inline">{{ .Release.Name }}</strong> and <strong class="source-inline">{{ .Release.Namespace }}</strong> actions get replaced with their <a id="_idIndexMarker344"/>actual values, as illustrated in the following code snippet:</p>
			<pre class="source-code">
<strong class="bold">$ helm template release-example chapter6/examples/release-example</strong>
<strong class="bold">---</strong>
<strong class="bold"># Source: release-example/templates/configmap.yaml</strong>
<strong class="bold">apiVersion: v1</strong>
<strong class="bold">kind: ConfigMap</strong>
<strong class="bold">metadata:</strong>
<strong class="bold">  name: release-example</strong>
<strong class="bold">data:</strong>
<strong class="bold">  config.properties: |-</strong>
<strong class="bold">    namespace=default</strong></pre>
			<p>As you can see, the ConfigMap name has been generated as <strong class="source-inline">release-example</strong>, and the <strong class="source-inline">namespace</strong> property has been generated as <strong class="source-inline">default</strong> (if we had selected a different namespace using the <strong class="source-inline">-n</strong> flag, that value would have been reflected instead). By using the <strong class="source-inline">.Release</strong> object, we were able to leverage the name and namespace that were provided when invoking Helm rather than creating repetitive values in <strong class="source-inline">values.yaml</strong> for the name and namespace.</p>
			<p>There are several <a id="_idIndexMarker345"/>more objects besides <strong class="source-inline">name</strong> and <strong class="source-inline">namespace</strong> under <strong class="source-inline">.Release</strong> that you can leverage in your chart templates. The following table lists each <strong class="source-inline">.Release</strong> object, with the descriptions quoted from the Helm documentation at <a href="https://helm.sh/docs/chart_template_guide/builtin_objects/#helm">https://helm.sh/docs/chart_template_guide/builtin_objects/#helm</a>:</p>
			<table id="table002-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Object</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Release.Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>The release name</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Release.Namespace</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>The namespace to be released into</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Release.IsUpgrade</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>This is set to <strong class="source-inline">true</strong> if the current operation is an upgrade or rollback</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Release.IsInstall</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>This is set to <strong class="source-inline">true</strong> if the current operation is an install</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Release.Revision</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>The revision number for this release</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Release.Service</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>The service that is rendering the template (this is always equivalent to the <strong class="source-inline">"Helm"</strong> string)</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.2 – .Release objects</p>
			<p>We will explore the <strong class="source-inline">.Chart</strong> object next.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor174"/>The .Chart object</h2>
			<p>The <strong class="source-inline">.Chart</strong> object is used to <a id="_idIndexMarker346"/>retrieve metadata from the <strong class="source-inline">Chart.yaml</strong> file of the Helm chart that is being installed. It is commonly used for labeling chart resources with the chart name and version. Let’s take a look at the example template at <strong class="source-inline">chapter6/examples/chart-example/templates/configmap.yaml</strong> from the Git repository. You can view this here:</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}
  labels:
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
data:
  config.properties: |-
    chapterNumber={{ .Values.chapterNumber }}
    chapterName={{ .Values.chapterName }}</pre>
			<p>As you can see<a id="_idIndexMarker347"/> in the <strong class="source-inline">metadata.labels</strong> section, the template is using the <strong class="source-inline">{{ .Chart.Name }}</strong>, <strong class="source-inline">{{ .Chart.Version }}</strong>, and <strong class="source-inline">{{ .Chart.AppVersion }}</strong> actions, which retrieve the <strong class="source-inline">name</strong>, <strong class="source-inline">version</strong>, and <strong class="source-inline">appVersion</strong> fields from the <strong class="source-inline">Chart.yaml</strong> file. Here, you can see the <strong class="source-inline">Chart.yaml</strong> file for this example chart:</p>
			<pre class="source-code">
apiVersion: v2
name: chart-example
description: A Helm chart for Kubernetes
type: application
version: 1.0.0
appVersion: 0.1.0</pre>
			<p>When we use the <strong class="source-inline">helm template</strong> command to render this template locally, we see the fields from the <strong class="source-inline">Chart.yaml</strong> file are used in the ConfigMap resource, as illustrated here:</p>
			<pre class="source-code">
<strong class="bold">$ helm template chart-example chapter6/examples/chart-example</strong>
<strong class="bold">---</strong>
<strong class="bold"># Source: chart-example/templates/configmap.yaml</strong>
<strong class="bold">apiVersion: v1</strong>
<strong class="bold">kind: ConfigMap</strong>
<strong class="bold">metadata:</strong>
<strong class="bold">  name: chart-example</strong>
<strong class="bold">  labels:</strong>
<strong class="bold">    helm.sh/chart: chart-example-1.0.0</strong>
<strong class="bold">    app.kubernetes.io/version: 0.1.0</strong>
<strong class="bold">data:</strong>
<strong class="bold">  config.properties: |-</strong>
<strong class="bold">    chapterNumber=6</strong>
<strong class="bold">    chapterName=Understanding Helm Templates</strong></pre>
			<p>The <strong class="source-inline">.Chart</strong> object <a id="_idIndexMarker348"/>can reference any field from the <strong class="source-inline">Chart.yaml</strong> file. For a full list of <strong class="source-inline">Chart.yaml</strong> fields, please refer to <a href="B17979_04.xhtml#_idTextAnchor139"><em class="italic">Chapter 4</em></a>, <em class="italic">Scaffolding a New Helm Chart</em>.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor175"/>The .Template object</h2>
			<p>The <strong class="source-inline">.Template</strong> object is used <a id="_idIndexMarker349"/>to retrieve metadata about the current template that is being rendered. It is the simplest built-in object (besides <strong class="source-inline">.Values</strong>) and contains only two objects underneath, as outlined here:</p>
			<ul>
				<li><strong class="source-inline">.Template.Name</strong>—The file path to the template being rendered (such as <strong class="source-inline">mychart/templates/mytemplate.yaml</strong>)</li>
				<li><strong class="source-inline">.Template.BasePath</strong>—The path leading up to the <strong class="source-inline">templates</strong> directory (such as  <strong class="source-inline">mychart/templates</strong>)</li>
			</ul>
			<p>In our experience, the <strong class="source-inline">.Template</strong> object is rarely used, but it can be useful if you need to reference the<a id="_idIndexMarker350"/> template’s file path in your chart.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor176"/>The .Capabilities object</h2>
			<p>The <strong class="source-inline">.Capabilities</strong> object<a id="_idIndexMarker351"/> is used for getting information about the target Kubernetes cluster. There are many objects underneath <strong class="source-inline">.Capabilities</strong>, but the most common are <strong class="source-inline">.Capabilities.APIVersions.Has</strong> and <strong class="source-inline">.Capabilities.KubeVersion</strong>.</p>
			<p>The <strong class="source-inline">.Capabilities.APIVersions.Has</strong> object is a function that returns a Boolean based on whether or not the Kubernetes cluster has a given <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) version. Here is an example invocation:</p>
			<pre class="source-code">
{{ .Capabilities.APIVersions.Has "batch/v1" }}</pre>
			<p>This action would return <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> based on whether or not the cluster contains the "<strong class="source-inline">batch/v1</strong>” API version. <strong class="source-inline">.Capabilities.APIVersions.Has</strong> is most commonly used in conditional logic to install a resource only if the cluster contains a particular API version. Conditional logic will be covered in the <em class="italic">Helm template control structures</em> section later in this chapter.</p>
			<p>The other commonly used <strong class="source-inline">.Capabilities</strong> object is <strong class="source-inline">.Capabilities.KubeVersion</strong>. Use this property to retrieve the version of the Kubernetes cluster. For example, the following action would return a <strong class="source-inline">v1.21.2</strong> string (or similar, based on the version of Kubernetes being used):</p>
			<pre class="source-code">
{{ .Capabilities.KubeVersion }}</pre>
			<p>Other <strong class="source-inline">.Capabilities</strong> objects, such as <strong class="source-inline">.Capabilities.KubeVersion.Major</strong> and <strong class="source-inline">.Capabilities.KubeVersion.Minor</strong>, allow chart developers to get only the major or minor version of the Kubernetes cluster (as opposed to the whole <strong class="bold">Semantic Versioning</strong> (<strong class="bold">SemVer</strong>) version). For a full list of objects under <strong class="source-inline">.Capabilities</strong>, visit the Helm documentation at <a href="https://helm.sh/docs/chart_template_guide/builtin_objects/#helm">https://helm.sh/docs/chart_template_guide/builtin_objects/#helm</a>.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor177"/>The .Files object</h2>
			<p>Occasionally, you may <a id="_idIndexMarker352"/>encounter use cases where you need to include contents from files in your chart templates. You can include file contents by using the <strong class="source-inline">.Files</strong> object. This is used primarily with ConfigMap and Secret resources, where the <strong class="source-inline">data</strong> section is provided or supplemented by a separate configuration file. Note that files must be located within the Helm chart directory (but outside of the <strong class="source-inline">templates/</strong> folder) in order to be referenced with <strong class="source-inline">.Files</strong>.</p>
			<p>The <strong class="source-inline">.Files</strong> object contains several other objects underneath. The most basic is <strong class="source-inline">.Files.Get</strong>, which is a function that retrieves the contents of the provided filename. Imagine a ConfigMap template such as this (this template is also located in the Git repository at <strong class="source-inline">chapter6/examples/files-example/get</strong>):</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}
data:
  config.properties: |-
    {{ .Files.Get "files/config.properties" }}</pre>
			<p>The <strong class="source-inline">.Files.Get</strong> function in the example is being used to get the contents of the <strong class="source-inline">files/config.properties</strong> file, which is a path relative to the Helm chart root. This file is located at <strong class="source-inline">chapter6/examples/files-example/get/files/config.properties</strong> in the Git repository and contains the following:</p>
			<pre class="source-code">
chapterNumber=6</pre>
			<p>Now, when we render this template, we will see the following output:</p>
			<pre class="source-code">
<strong class="bold">$ helm template basic-files-example chapter6/examples/files-example/get</strong>
<strong class="bold">---</strong>
<strong class="bold"># Source: files-example/templates/configmap.yaml</strong>
<strong class="bold">apiVersion: v1</strong>
<strong class="bold">kind: ConfigMap</strong>
<strong class="bold">metadata:</strong>
<strong class="bold">  name: basic-files-example</strong>
<strong class="bold">data:</strong>
<strong class="bold">  config.properties: |-</strong>
<strong class="bold">    chapterNumber=6</strong></pre>
			<p>Three other<a id="_idIndexMarker353"/> important objects under <strong class="source-inline">.Files</strong> are <strong class="source-inline">.Files.Glob</strong>, <strong class="source-inline">.Files.AsConfig</strong>, and <strong class="source-inline">.Files.AsSecret</strong>. First, <strong class="source-inline">.Files.Glob</strong>, is a function that returns a list of file objects that match a provided <strong class="bold">global</strong> (<strong class="bold">glob</strong>) pattern. A glob pattern<a id="_idIndexMarker354"/> is a set of names with wildcard characters (<strong class="source-inline">*</strong>). For example, the <strong class="source-inline">files/*</strong> glob would match each file under the <strong class="source-inline">files/</strong> folder.</p>
			<p>The <strong class="source-inline">.Files.Glob</strong> object is commonly used with <strong class="source-inline">.Files.AsConfig</strong> and <strong class="source-inline">.Files.AsSecrets</strong> objects. <strong class="source-inline">.Files.AsConfig</strong> is a function used to return the file as a YAML dictionary, where the key is the name of the file and the value is the file contents. It is called <strong class="source-inline">AsConfig</strong> because it is useful when formatting different ConfigMap data entries. The <strong class="source-inline">.Files.AsSecrets</strong> function is similar, but in addition to returning files as a YAML map, <strong class="source-inline">AsSecrets</strong> also Base64-encodes the contents of the file—this is useful for creating data for Kubernetes Secrets. Do keep in mind that sensitive files should never be checked into a Git repository in plaintext (though we have one such file in the example Git repository for demonstration purposes).</p>
			<p>The following templates demonstrate the usage of these objects and are also located in the Git repository at <strong class="source-inline">chapter6/examples/files-example/glob</strong>:</p>
			<pre class="source-code">
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}
data:
{{ (.Files.Glob "files/chapter*").AsConfig | indent 2 }}
---
kind: Secret
&lt;skipped for brevity&gt;
Data:
{{ (.Files.Glob "files/secret*").AsSecrets | indent 2 }}</pre>
			<p>The <strong class="source-inline">files</strong> folder contains the following files:</p>
			<ul>
				<li><strong class="source-inline">chapter.properties</strong></li>
				<li><strong class="source-inline">secret.properties</strong></li>
			</ul>
			<p>When this <a id="_idIndexMarker355"/>template is rendered, the contents of both files are generated as YAML maps under the ConfigMap’s <strong class="source-inline">data</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">
<strong class="bold">$ helm template glob-example chapter6/examples/files-example/glob</strong>
---
# Source: files-example/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: glob-example
data:
  chapter.properties: |
    chapterNumber=6
    chapterName=Understanding Helm Templates
---
# Source: files-example/templates/secret.yaml
apiVersion: v1
kind: Secret
&lt;skipped for brevity&gt;
  secret.properties: dXNlcm5hbWU9bXl1c2VyMTIzCnBhc3N3b3JkPW15cGFzczEyMwo=</pre>
			<p>In the previous<a id="_idIndexMarker356"/> example, you likely noticed the usage of <strong class="source-inline">| indent 2</strong>. This represents a pipeline and function that will be explored thoroughly in the next section, <em class="italic">Helm template functions</em>. For now, all you need to worry about is that the output is indented by two spaces in order to produce properly formatted ConfigMap and Secret resources.</p>
			<p>Other <strong class="source-inline">.Files</strong> objects are <strong class="source-inline">.Files.GetBytes</strong>, which returns a file as an array of bytes, and <strong class="source-inline">.Files.Lines</strong>, which is used to iterate over each line of a file.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor178"/>Helm template functions</h1>
			<p>One of the <a id="_idIndexMarker357"/>common traits of any templating language is the ability to transform data. Thus far, when referring to <strong class="source-inline">.Values</strong> or any of the other built-in objects within Helm, we have only made reference to the resource as-is, without any form of data manipulation. Where Helm really begins to shine and show its true power is its ability to perform complex data processing within templates through the use of template functions and pipelines.</p>
			<p>Since Helm uses Go as the basis for its own templating language, it inherits the capabilities provided by functions. A Go template function is comparable to any other function that you may have interacted with in another programming language. Functions contain logic designed to consume certain inputs and provide an output based on the inputs that were provided.</p>
			<p>When using Go templates, functions make use of the following syntax: </p>
			<pre class="source-code">
functionName arg1 arg2 . .</pre>
			<p>A function that is commonly used within Helm charts is the <strong class="source-inline">quote</strong> function, as it encompasses quotation marks surrounding an input string. Take the following ConfigMap located in <strong class="source-inline">chapter6/examples/functions-example/templates/configmap.yaml</strong> from the Git repository:</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}
  labels:
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
  annotations:
    {{- toYaml .Values.annotations | nindent 4 }}
data:
  path: {{ .Values.fs.path }}
  config.properties: |-
    {{- (.Files.Get "files/chapter-details.cfg") | nindent 4}}</pre>
			<p>The <strong class="source-inline">path</strong> property <a id="_idIndexMarker358"/>in the preceding ConfigMap represents a filesystem location that is consumed by an application, as shown in the following code snippet. The value referenced by this property is located in the <strong class="source-inline">values.yaml</strong> file:</p>
			<pre class="source-code">
fs:
  path: /var/props/../configs/my app/config.cfg</pre>
			<p>The resulting template would be rendered as follows (some fields were omitted for brevity):</p>
			<pre class="source-code">
...
data:
  path: /var/props/../configs/my app/config.cfg
...</pre>
			<p>A potential downstream issue within a consuming application could result if it did not contain logic to appropriately manage whether spaces could be present within the input. </p>
			<p>To avoid these potential issues, add the <strong class="source-inline">quote</strong> function that will surround the property with quotation marks, as shown in the following code snippet:</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}
  labels:
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
  annotations:
    {{- toYaml .Values.annotations | nindent 4 }}
data:
  path: {{ quote .Values.fs.path }}
...</pre>
			<p>Use the <strong class="source-inline">helm template</strong> command to render the chart locally to see the function in action, as follows:</p>
			<p class="source-code">$ helm template functions-example chapter6/examples/functions-example</p>
			<p>The result upon template <a id="_idIndexMarker359"/>rendering produces a<strong class="source-inline">/var/props/../configs/my app/config.cfg</strong> string that not only enhances the readability of the property but protects any consuming application.</p>
			<p><strong class="source-inline">quote</strong> is just one of over 60 functions included within Helm. While some of the functions are sourced from Go templates, the majority are part of the <strong class="source-inline">Sprig</strong> template library. The <strong class="source-inline">Sprig</strong> library includes functions to implement more complex capabilities within charts, such as the ability to perform mathematical formulas, conversion operations, and the management of data structures, including lists and dictionaries.</p>
			<p>The functions inherited from Go and Sprig can be found in the Go documentation at <a href="https://pkg.go.dev/text/template#hdr-Functions">https://pkg.go.dev/text/template#hdr-Functions</a> and in the Sprig template library at <a href="http://masterminds.github.io/sprig/">http://masterminds.github.io/sprig/</a>.</p>
			<p>One of the more recent functions added to Helm is the ability to query resources from a running Kubernetes environment through the use of the <strong class="source-inline">lookup</strong> function. Helm chart developers can make reference to a single resource or references of a given type across a namespace or cluster and inject the results within their templates.</p>
			<p>The <strong class="source-inline">lookup</strong> function takes the following form:</p>
			<pre class="source-code">
lookup &lt;apiVersion&gt; &lt;kind&gt; &lt;namespace&gt; &lt;name&gt;</pre>
			<p>For example, to query a ConfigMap called <strong class="source-inline">props</strong> in the <strong class="source-inline">chapter6</strong> namespace, use the following function:</p>
			<pre class="source-code">
lookup "v1" "ConfigMap" "chapter6" "props"</pre>
			<p>The result from the <strong class="source-inline">lookup</strong> function is a dictionary that can be further navigated as necessary to retrieve individual properties on the returned resource.</p>
			<p>So, to extract a property defined on a ConfigMap called <strong class="source-inline">author</strong> containing the default name of the author for all WordPress posts, the following code would be added within a Helm template:</p>
			<pre class="source-code">
{{ (lookup "v1" "ConfigMap" "chapter6" "props").data.author }}</pre>
			<p>As you can see, we are first retrieving a dictionary of values containing the <strong class="source-inline">props</strong> ConfigMap and then navigating to the <strong class="source-inline">author</strong> property on the ConfigMap data structure.</p>
			<p>You are not limited to querying for a single resource when using the <strong class="source-inline">lookup</strong> function and can instead search for all resources of a given type within a single namespace or within all namespaces. This can be accomplished by substituting empty quotes for either the namespace and/or resource name, as shown in the following template:</p>
			<pre class="source-code">
lookup "v1" "ConfigMap" "chapter6" ""</pre>
			<p>One final important<a id="_idIndexMarker360"/> note when working with the <strong class="source-inline">lookup</strong> function is that it can only be used when resources are being deployed to a Kubernetes cluster, such as through the <strong class="source-inline">helm install</strong> and <strong class="source-inline">helm upgrade</strong> commands. This is due to the requirement that there be an active connection to a Kubernetes cluster as part of the execution process being performed. For commands such as <strong class="source-inline">helm template</strong>, where templates are being rendered locally and there is no interaction with a Kubernetes cluster, the <strong class="source-inline">lookup</strong> function will not return any meaningful results.</p>
			<p>Helm functions and their ability to influence Helm template commands are just the first steps toward adding more dynamic mechanisms to chart templates. Multiple template commands can also be chained together to perform a series of complex actions through the use of <strong class="bold">pipelines</strong>.</p>
			<p>Pipelines are a<a id="_idIndexMarker361"/> borrowed concept from Unix where the result from one command is fed in as the input of another command. You can see an illustration of this in the following code snippet:</p>
			<p class="source-code">cat file.txt | grep helm</p>
			<p>Commands are separated by the pipe (<strong class="source-inline">|</strong>) character (hence the name <em class="italic">pipeline</em>) where in this case, the output of the contents of the <strong class="source-inline">file.txt</strong> file is provided as an input to the <strong class="source-inline">grep</strong> command. <strong class="source-inline">grep</strong> processes the input, filters out any presence of the word <strong class="source-inline">helm</strong> from the input, and provides it as an output that is printed to the screen. </p>
			<p>Pipelines can be applied to Helm in a similar fashion. Let’s return to the prior example where we introduced the <strong class="source-inline">quote</strong> function to add quotation marks to a filesystem path. Instead of using the <strong class="source-inline">value</strong> property as a function argument, inverse the order to pipe the contents of the value into the <strong class="source-inline">quote</strong> function, as follows:</p>
			<pre class="source-code">
{{ .Values.fs.path | quote }}</pre>
			<p>The end result remains<a id="_idIndexMarker362"/> the same whether calling the function directly or using the pipeline approach. However, in practice, you will find that pipelines are the preferred option over directly invoking functions, given the extensibility of chinning template commands.</p>
			<p>You may also have noticed that the <strong class="source-inline">fs.path</strong> value includes a reference to a relative path (denoted by <strong class="source-inline">..</strong>). This may be difficult for some to read and or understand if they are unfamiliar with the syntax. Fortunately, there is a function included in the Sprig library called <strong class="source-inline">clean</strong> that can resolve the path fully and remove any relative paths automatically. This function can be added to the existing pipeline, as shown here:</p>
			<pre class="source-code">
{{ .Values.fs.path | clean | quote }}</pre>
			<p>In the ConfigMap within the <strong class="source-inline">functions-example</strong> Helm chart from the Git repository, apply the preceding changes and then use the <strong class="source-inline">helm template</strong> command to see the changes in action. Upon instantiation, the rendered template would look like this:</p>
			<pre class="source-code">
"/var/configs/my app/config.cfg"</pre>
			<p>Functions and pipelines are both extensively used within Helm, and it is important that as a chart developer, you have insights into the available options in order to design charts effectively. Let’s take a moment to look at a few more commonly used functions.</p>
			<p><strong class="source-inline">Values</strong> files, as we have seen, contain a dictionary of key/value pairs. While individual key/value pairs can be referenced, there are plenty of situations where a deeply nested structure would want to be injected instead. Fortunately, several Helm functions can help in this situation. </p>
			<p>As you recall, the<a id="_idIndexMarker363"/> YAML language is very particular about the specific indentation and spacing of content. To account for this, Helm provides the <strong class="source-inline">toYaml</strong> function, which allows a dictionary of values to be provided, and for it to be formatted appropriately, regardless of how deeply nested it is. An example of this can be found within the ConfigMap that we have been using thus far in this section where a dictionary of annotations is injected from properties defined in the <strong class="source-inline">Values</strong> file, as illustrated in the following code snippet:</p>
			<pre class="source-code">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}
  labels:
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
  annotations:
    {{- toYaml .Values.annotations | nindent 4 }}
data:
…</pre>
			<p>The following content is defined within the chart <strong class="source-inline">values.yaml</strong> file:</p>
			<pre class="source-code">
annotations:
  publisher: "Packt Publishing"
  title: "Managing Kubernetes Resources Using Helm"</pre>
			<p>You may also notice that the result of the <strong class="source-inline">toYaml</strong> function is then piped to another function called <strong class="source-inline">nindent</strong>. The use of this function is a necessary requirement to manage the formatting of the content; otherwise, a rendering error would occur. Both <strong class="source-inline">indent</strong> and <strong class="source-inline">nindent</strong> provide formatting capabilities by indenting content a certain number of spaces, crucial when working with YAML. The difference between <strong class="source-inline">indent</strong> and <strong class="source-inline">nindent</strong> is that <strong class="source-inline">nindent</strong> will add a newline character after each line of input, a required step in our use case as there are multiple annotation properties defined within the <strong class="source-inline">Values</strong> file.</p>
			<p>Process the chart<a id="_idIndexMarker364"/> using the <strong class="source-inline">helm template</strong> command to visualize how these values would be rendered, as follows:</p>
			<pre class="source-code">
<strong class="bold">$ helm template functions-example chapter6/examples/functions-example</strong>
<strong class="bold">apiVersion: v1</strong>
<strong class="bold">kind: ConfigMap</strong>
<strong class="bold">metadata:</strong>
<strong class="bold">  name: functions-example</strong>
<strong class="bold">  labels:</strong>
<strong class="bold">    helm.sh/chart: functions-example-0.1.0</strong>
<strong class="bold">    app.kubernetes.io/version: 1.16.0</strong>
<strong class="bold">  annotations:</strong>
<strong class="bold">    publisher: Packt Publishing</strong>
<strong class="bold">    title: Managing Kubernetes Resources Using Helm</strong></pre>
			<p>The final Helm function that we will look at in detail is used when performing more complex rendering of templates. Earlier in this chapter, you learned how external files can be referenced within charts and their values injected into templates using the built-in <strong class="source-inline">.Files</strong> object. While Helm’s templating capabilities can be used to evaluate resources within template files, there are cases where there is a need to perform evaluation against externally sourced files. Take a look here at the ConfigMap once again and note the <strong class="source-inline">config.properties</strong> key: </p>
			<pre class="source-code">
  config.properties: |-
    {{- (.Files.Get "files/chapter-details.cfg") | nindent 4}}</pre>
			<p>Instead of including the values directly within the ConfigMap, they are instead sourced from a file located at <strong class="source-inline">files/chapter-details.cfg</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">
chapterNumber={{ .Values.book.chapterNumber }}
chapterName={{ .Values.book.chapterName }}</pre>
			<p>However, when the chart is rendered using <strong class="source-inline">helm template</strong>, the desired values are not substituted as we would expect, as we can see here:</p>
			<pre class="source-code">
  config.properties: |-
    chapterNumber={{ .Values.book.chapterNumber }}
    chapterName={{ .Values.book.chapterName }}</pre>
			<p>This situation occurs<a id="_idIndexMarker365"/> since template processing only occurs by default, within files in the <strong class="source-inline">templates</strong> folder and not in any externally sourced content. To apply templating to external sources that are brought into templates, the <strong class="source-inline">tpl</strong> function can be used, as shown here:</p>
			<pre class="source-code">
...
  config.properties: |-
    {{-  tpl (.Files.Get "files/chapter-details.cfg") . | nindent 4}}</pre>
			<p>What you may be wondering about when looking at the updated content of the ConfigMap is the presence of the period (<strong class="source-inline">.</strong>) before the pipe. This character indicates the scope that will be passed to the templating engine. We will cover this topic in detail in the next section. </p>
			<p>Use the <strong class="source-inline">helm template</strong> command to confirm that values are substituted appropriately thanks to the inclusion of the <strong class="source-inline">tpl</strong> function, as follows: </p>
			<p class="source-code">$ helm template functions-example chapter6/examples/functions-example</p>
			<p class="source-code">...</p>
			<p class="source-code">  config.properties: |-</p>
			<p class="source-code">    chapterNumber=6</p>
			<p class="source-code">    chapterName=Understanding Helm Templates</p>
			<p>The template<a id="_idIndexMarker366"/> functions addressed in this section only scratch the surface of the functions provided by Helm. The following table lists a few other important functions that chart developers should be aware of in order to fully take advantage of what Helm has to offer:</p>
			<table id="table003-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Example</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">printf</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a string based upon a formatting string and arguments </p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">printf "A cat named %s has %d lives." $name $numLives</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">default</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Assigns a string “placeholder” if the content of <strong class="source-inline">$value</strong> is <strong class="source-inline">nil</strong> or empty</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">default "placeholder" $value</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">list</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a new list based upon a series of inputs</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">list "ClusterIP" "NodePort" "LoadBalancer"</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">has</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines if an element is present in a list</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">has 4 $list</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">b64enc</strong>/<strong class="source-inline">b64dec</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Encodes or decodes with Base64. Useful when working with Secrets.</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">b64enc $mySecret</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">atoi</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Convert a string to an integer</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">atoi $myIntegerString</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">add</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Adds a list of integers</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">add 1 2 3</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">upper</strong>/<strong class="source-inline">lower</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Convert the entire string to uppercase or lowercase</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">upper $myString</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">now</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the current date and time</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">Now</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">date</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Formats a date in the specified format</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">now | date "2006-01-02"</strong></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.3 – A list of common Helm functions</p>
			<p>With a better understanding of the ways that Helm can be used to manipulate and format content within templates using functions, let’s turn to how we can introduce flow control to manage the content that will be rendered.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor179"/>Helm template control structures</h1>
			<p>The way in <a id="_idIndexMarker367"/>which templates are generated can be managed by chart developers thanks to the functionality provided by control structures. Included in the <strong class="source-inline">actions </strong>component of the <strong class="source-inline">Go</strong> templates, control structures enable fine-grained flow control for determining the types of resources that should be generated and how they are rendered.</p>
			<p>The following control-structure keywords are available:</p>
			<ul>
				<li><strong class="source-inline">if</strong>/<strong class="source-inline">else</strong>—Creating conditional blocks for resource generation</li>
				<li><strong class="source-inline">with</strong>—Modifying the <em class="italic">scope</em> of resources being generated</li>
				<li><strong class="source-inline">range</strong>—Looping over a set of resources</li>
			</ul>
			<p>There are occasions where portions of a template would need to be included or excluded based on some sort of condition. In this situation, an <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> action can be used. Here is a basic example for conditionally determining whether to include a readiness probe as part of a deployment resource:</p>
			<pre class="source-code">
{{- if .Values.readinessProbe.enabled }}
readinessProbe:
  httpGet:
    path: /healthz
    port: 8080
    scheme: HTTP
  initialDelaySeconds: 30
  periodSeconds: 10
{{- end }}</pre>
			<p>The <strong class="source-inline">readinessProbe</strong> section will only be included when the condition evaluates to <strong class="source-inline">true</strong>. However, it is important to note that the condition is actually a pipeline where multiple statements can be chained together to aid in the creation of complex conditionals. The logic behind the <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> action can also be interpreted as follows:</p>
			<pre class="source-code">
{{ if PIPELINE }}
  # Do something
{{ else if OTHER PIPELINE }}
  # Do something else
{{ else }}
  # Default case
{{ end }}</pre>
			<p>The conditional <a id="_idIndexMarker368"/>statements and their associated <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> action should look familiar to anyone with prior programming experience. But what is the logic behind determining whether a pipeline is <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>? </p>
			<p>A pipeline fails to evaluate to <strong class="source-inline">true</strong> when the following is returned:</p>
			<ul>
				<li>A <strong class="source-inline">false</strong> Boolean</li>
				<li>A numeric <strong class="source-inline">0</strong></li>
				<li>An empty string</li>
				<li><strong class="source-inline">nil</strong> (whether it be empty or <strong class="source-inline">null</strong>)</li>
				<li>An empty collection</li>
			</ul>
			<p>So, in the previous scenario where conditional logic is applied to the readiness probe, the probe would only be included if the value is <strong class="source-inline">readinessProbe.enabled=true</strong>.</p>
			<p>Nesting of conditionals can also be applied within templates. The following code snippet illustrates how conditionals can be used to determine the type of probe that should be applied to <strong class="source-inline">readinessProbe</strong>:</p>
			<pre class="source-code">
 {{- if .Values.readinessProbe.enabled }}
readinessProbe:
{{- if eq .Values.readinessProbe.type "http" }}
  httpGet:
    path: /healthz
    port: 8080
    scheme: HTTP
  initialDelaySeconds: 30
  periodSeconds: 10
{{- else }}
  tcpSocket:
    port: 8080
{{- end }}
{{- end }}</pre>
			<p>An <strong class="source-inline">httpGet</strong> probe <a id="_idIndexMarker369"/>type will be applied when the <strong class="source-inline">readinessProbe.type</strong> property is equal to <strong class="source-inline">"http"</strong>. Otherwise, a <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) probe will be used. </p>
			<p><strong class="source-inline">eq</strong> (short for <em class="italic">equals</em>) within the <strong class="source-inline">if</strong> statement is one of the available Boolean functions that test the equality of the two arguments. When the <strong class="source-inline">readinessProbe.type</strong> is equal to <strong class="source-inline">http</strong>, the <strong class="source-inline">httpGet</strong> probe type will be applied. Otherwise, a TCP probe type will be used. </p>
			<p>A full list of available Boolean functions is provided here:</p>
			<ul>
				<li><strong class="source-inline">and</strong></li>
				<li><strong class="source-inline">or</strong></li>
				<li><strong class="source-inline">not</strong></li>
				<li><strong class="source-inline">eq</strong> (short for <em class="italic">equals</em>)</li>
				<li><strong class="source-inline">ne</strong> (short for <em class="italic">not equals</em>)</li>
				<li><strong class="source-inline">lt</strong> (short for <em class="italic">less than</em>)</li>
				<li><strong class="source-inline">le</strong> (short for <em class="italic">less than or equal to</em>)</li>
				<li><strong class="source-inline">gt</strong> (short for <em class="italic">greater than</em>)</li>
				<li><strong class="source-inline">ge</strong> (short for greater than or <em class="italic">equal to</em>)</li>
			</ul>
			<p>Another method of flow control available for chart developers is the ability to modify the scope of the resources being rendered. A period (<strong class="source-inline">.</strong>) represents the <em class="italic">current scope</em>, and thus far, we have been operating at the root or top-level scope. Each of the built-in objects that were covered earlier in this chapter is available at this level. However, when working with objects with deeply nested structures, there may be a desire to modify the scope being applied to avoid rather unwieldy property references. </p>
			<p>The <strong class="source-inline">with</strong> action <a id="_idIndexMarker370"/>provides these necessary capabilities to modify the current scope.</p>
			<p>Take a look at the <strong class="source-inline">flowcontrol-example</strong> Helm chart located at <strong class="source-inline">chapter6/examples/flowcontrol-example</strong> within the Git repository. Included within the <strong class="source-inline">values.yaml</strong> file is a deeply nested dictionary of properties, as illustrated here: </p>
			<pre class="source-code">
book:
  chapter6:
    props:
      chapterNumber: 6
      chapterName: Understanding Helm Templates</pre>
			<p>These values should look familiar given that they have been used several times in this chapter, but note that they are now placed into a deeply nested dictionary. They could be referenced in the following manner: </p>
			<pre class="source-code">
chapterNumber: {{ .Values.book.chapter6.props.chapterNumber }} 
chapterName: {{ .Values.book.chapter6.props.chapterName }}</pre>
			<p>However, by using the <strong class="source-inline">with</strong> action, the current scope is changed so that references within the block begin at <strong class="source-inline">.Values.book.chapter6.props</strong>, greatly increasing the readability and reducing the complexity. You can see an illustration of this in the following code snippet:</p>
			<pre class="source-code">
{{- with .Values.book.chapter6.props }}
  chapterNumber: {{ .chapterNumber }} 
  chapterName: {{ .chapterName }}
{{- end }}</pre>
			<p>This is illustrated within the ConfigMap located at <strong class="source-inline">chapter6/examples/flowcontrol-example/templates/configmap.yaml</strong>. Render the chart using the <strong class="source-inline">helm template</strong> command to confirm that values within the ConfigMap are generated properly, as follows:</p>
			<p class="source-code">$ helm template flowcontrol-example chapter6/examples/flowcontrol-example</p>
			<p>One very important note when modifying scope is that chart developers may be caught off guard when attempting to reference any built-in objects such as <strong class="source-inline">.Release</strong> or <strong class="source-inline">.Chart</strong> within a block where the current scope has changed. </p>
			<p>Attempting to use<a id="_idIndexMarker371"/> the following templating within the ConfigMap would result in an error upon instantiation:</p>
			<pre class="source-code">
{{- with .Values.book.chapter6.props }}
  chapterNumber: {{ .chapterNumber }} 
  chapterName: {{ .chapterName }}
  ChartName: {{ .Chart.Name }}
{{- end }}
Error: template: flowcontrol-example/templates/configmap.yaml:12:22: executing "flowcontrol-example/templates/configmap.yaml" at &lt;.Chart.Name&gt;: nil pointer evaluating interface {}.Name</pre>
			<p>This is due to the fact that the current scope within the <strong class="source-inline">with</strong> statement is no longer at the root scope where the built-in objects reside. Fortunately, Helm provides a way to reference the root scope by using <strong class="source-inline">$</strong>. By adding  <strong class="source-inline">$</strong> to the <strong class="source-inline">.Chart.Name</strong> reference, a rendering error will no longer occur. You can see this in use in the following code snippet:</p>
			<pre class="source-code">
{{- with .Values.book.chapter6.props }}
  chapterNumber: {{ .chapterNumber }} 
  chapterName: {{ .chapterName }}
  ChartName: {{ $.Chart.Name }}
{{- end }}</pre>
			<p>The final<a id="_idIndexMarker372"/> flow-control action that chart developers need to be aware of is <strong class="source-inline">range</strong>—this is useful when performing <strong class="source-inline">foreach</strong> style iteration over lists and dictionaries. Similar to the <strong class="source-inline">with</strong> action, the <strong class="source-inline">range</strong> action also modifies the scope of resources being rendered.</p>
			<p>For example, say the following were included as values within a <strong class="source-inline">values.yaml</strong> file to represent ports associated with a Service resource:</p>
			<pre class="source-code">
service:
  ports:
    - name: http
      port: 80
      targetPort: 8080
    - name: https
      port: 443
      targetPort: 8443</pre>
			<p>By using the <strong class="source-inline">range</strong> action, these <a id="_idIndexMarker373"/>values can be then applied to the Service, as shown in the following example:</p>
			<pre class="source-code">
apiVersion: v1
kind: Service
metadata:
  name: {{ .Release.Name }}
  labels:
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
spec:
  type: ClusterIP
  ports:
  {{- range .Values.service.ports }}
    - port: {{ .port }}
      targetPort: {{ .targetPort }}
      protocol: TCP
      name: {{ .name }}
  {{- end }}
  selector:
    app: {{ .Release.Name }}</pre>
			<p>The <strong class="source-inline">range</strong> action <a id="_idIndexMarker374"/>modifies the scope in a similar fashion as the <strong class="source-inline">with</strong> action so that within the block, the current scope represents each port within the <strong class="source-inline">ports</strong> list during each iteration of the loop and can be referenced accordingly. An example of this in practice can be found in the <strong class="source-inline">flowcontrol-example</strong> chart within the Git repository located at <strong class="source-inline">chapter6/examples/flowcontrol-example</strong>.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor180"/>Generating release notes</h1>
			<p>One special type of <a id="_idIndexMarker375"/>Helm template is called the <strong class="source-inline">NOTES.txt</strong> file, located in a Helm chart’s <strong class="source-inline">templates/</strong> folder. This file is used to dynamically generate usage instructions (or other details) for applications once they are installed with Helm.</p>
			<p>A <strong class="source-inline">NOTES.txt</strong> file uses the same exact templating syntax as Kubernetes resource templates and can be seen in the following example:</p>
			<pre class="source-code">
Follow these instructions to access your application.
{{- if eq .Values.serviceType "NodePort" }}
export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{.Release.Name }})
export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
echo "URL: http://$NODE_IP:$NODE_PORT
{{- else }}
export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Name }} wordpress --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}")
echo "URL: http://$SERVICE_IP"
{{- end }}</pre>
			<p>These examples would provide instructions on how to access applications deployed by the chart. They would be displayed during the install, upgrade, and rollback phases, and can be recalled by running the <strong class="source-inline">helm get notes</strong> command. By providing a <strong class="source-inline">NOTES.txt</strong> file, chart developers can provide additional insight on how to better use applications that <a id="_idIndexMarker376"/>have just been deployed.</p>
			<p>In the next section, we will discuss Helm template variables.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor181"/>Helm template variables</h1>
			<p>In addition to leveraging values <a id="_idIndexMarker377"/>and other built-in objects, chart developers can create variables of their own within chart templates to provide additional processing options. A common use case for this approach is flow control, but template variables can serve other use cases as well.</p>
			<p>A variable in a chart template is defined as follows:</p>
			<pre class="source-code">
{{ $myvar := "Hello World!" }}</pre>
			<p>The preceding example creates a variable called <strong class="source-inline">myvar</strong> and sets the value to a string equaling to <strong class="source-inline">Hello World!</strong>. Variables can be assigned to objects as well, such as a chart’s values, as illustrated here:</p>
			<pre class="source-code">
{{ $myvar := .Values.greeting }}</pre>
			<p>Once a variable is defined, it can be referenced in the following way:</p>
			<pre class="source-code">
data:
  greeting.txt: |-
    {{ $myvar }}</pre>
			<p>Another example of using variables is in a <strong class="source-inline">range</strong> block, where variables capture the index and value of list iterations, as illustrated in the following code snippet:</p>
			<pre class="source-code">
data:
  greetings.txt
{{- range $index, $value := .Values.greetings }}
    Greeting {{ $index }}: {{ $value }}
{{- end }}</pre>
			<p><strong class="source-inline">index</strong> represents the current loop iteration number and <strong class="source-inline">value</strong> represents the value from the list for the iteration. The previous snippet is rendered as follows:</p>
			<pre class="source-code">
data:
  greetings.txt
    Greeting 0: Hello
    Greeting 1: Hola
    Greeting 2: Hallo</pre>
			<p>Variables can also simplify the processing of map iterations, as shown here:</p>
			<pre class="source-code">
data:
  greetings.txt
{{- range $key, $val := .Values.greetings }}
    Greeting in {{ $key }}: {{ $val }}
{{- end }}</pre>
			<p>A possible <a id="_idIndexMarker378"/>result might look like this: </p>
			<pre class="source-code">
data:
  greetings.txt
    Greeting in English: Hello
    Greeting in Spanish: Hola
    Greeting in German: Hallo</pre>
			<p>Another common use case for Helm variables is to refer to values outside of the current scope.</p>
			<p>Consider the following <strong class="source-inline">with</strong> block:</p>
			<pre class="source-code">
{{- with .Values.application.configuration }}
My application is called {{ .Release.Name }}
{{- end }}</pre>
			<p>A template such as this one would fail to process since <strong class="source-inline">.Release.Name</strong> is not under the scope of <strong class="source-inline">.Values.application.configuration</strong>. One way this can be remedied is by setting a variable to <strong class="source-inline">.Release.Name</strong> above the <strong class="source-inline">with</strong> block, as follows:</p>
			<pre class="source-code">
{{ $appName := .Release.Name }}
{{- with .Values.application.configuration }}
My application is called {{ $appName }}
{{- end }}</pre>
			<p>While this is a possible solution to this problem, the approach of using a dollar sign (<strong class="source-inline">$</strong>) to refer to the global scope is preferred as it requires fewer lines to configure and is easier to read <a id="_idIndexMarker379"/>as the complexity increases. In this case, this template could be rewritten like so:</p>
			<pre class="source-code">
{{- with .Values.application.configuration }}
My application is called {{ $.Release.Name }}
{{- end }}</pre>
			<p>We will explore template validation next.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor182"/>Helm template validation</h1>
			<p>When working with<a id="_idIndexMarker380"/> Kubernetes and Helm, input validation is automatically performed by the Kubernetes API server when a new resource is created. This means that if an invalid resource is created by Helm, an error message will be returned by the API server, resulting in a failed installation. Although Kubernetes performs input validation, there may still be cases in which chart developers will want to perform validation before the resources reach the API server, such as to return a simple error message or to limit the range of possibilities to the user.</p>
			<p>In Helm, input validation refers to validating user-provided values to ensure that users have provided a proper set of values. You can perform this validation in three different ways (or a combination of these three), as follows:</p>
			<ul>
				<li>Using<a id="_idIndexMarker381"/> the <strong class="source-inline">fail</strong> function</li>
				<li>Using the <strong class="source-inline">required</strong> function</li>
				<li>Using a <strong class="source-inline">values.schema.json</strong> file</li>
			</ul>
			<p>Let’s begin exploring input validation by first looking at the <strong class="source-inline">fail</strong> function.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor183"/>The fail function</h2>
			<p>The <strong class="source-inline">fail</strong> function <a id="_idIndexMarker382"/>is used to immediately fail the Helm installation and is often used in cases where users have provided an invalid value. In this section, we’ll explore an example use case of the <strong class="source-inline">fail</strong> function that restricts user input and halts the installation if the user has provided a value outside of the expected set of values.</p>
			<p>Many Helm charts support values for setting the Kubernetes Service type. There are many different Service types that a user could choose from, but here are a few:</p>
			<ul>
				<li><strong class="source-inline">ClusterIP</strong>: Assigns an <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) address to the Service. Reachable only from within the cluster.</li>
				<li><strong class="source-inline">NodePort</strong>: Exposes a port on each Kubernetes node. Reachable from outside the cluster.</li>
				<li><strong class="source-inline">LoadBalancer</strong>: Creates a load balancer on the cloud provider where Kubernetes is deployed, if applicable.</li>
			</ul>
			<p>Let’s assume that we want to restrict users to be able to only create a <strong class="source-inline">ClusterIP</strong> or <strong class="source-inline">NodePort</strong> Service. We can use the <strong class="source-inline">fail</strong> function to fail and provide an error message if the Service type is not one of these two types.</p>
			<p>The example in the Git repository, located at <strong class="source-inline">chapter6/examples/fail-example</strong>, demonstrates this use case. In the <strong class="source-inline">values.yaml</strong> file, we see the following value:</p>
			<pre class="source-code">
service:
  type: ClusterIP</pre>
			<p>In the <strong class="source-inline">service.yaml</strong> template (located in the chart’s <strong class="source-inline">templates/</strong> folder), we see the following lines of code:</p>
			<pre class="source-code">
{{- $serviceTypes := list "ClusterIP" "NodePort" }}
{{- if has .Values.service.type $serviceTypes }}
  type: {{ .Values.service.type }}
{{- else }}
  {{- fail "value 'service.type' must be either 'ClusterIP' or 'NodePort'" }}
{{- end }}</pre>
			<p>In the previous template snippet, we first created a variable called <strong class="source-inline">serviceTypes</strong> and set it to a list of strings, containing the <strong class="source-inline">ClusterIP</strong> and <strong class="source-inline">NodePort</strong> types. Then, in an <strong class="source-inline">if</strong> action, we used the <strong class="source-inline">has</strong> function to determine whether or not the <strong class="source-inline">service.type</strong> value was included in the <strong class="source-inline">serviceTypes</strong> list, representing the set of permitted values. If the value provided was found, then we assume that the input was valid and render the service type and proceed with the installation. Otherwise, the <strong class="source-inline">fail</strong> function<a id="_idIndexMarker383"/> would be invoked, failing the installation and displaying to the user a message that explains the reason for the failure.</p>
			<p>Since the default service is already <strong class="source-inline">ClusterIP</strong> (as seen in the <strong class="source-inline">values.yaml</strong> file), we know that running <strong class="source-inline">helm template</strong> or <strong class="source-inline">helm install</strong> without providing any additional values would be successful. But let’s see what happens if we try to set the <strong class="source-inline">service.type</strong> value to an invalid setting, such as <strong class="source-inline">LoadBalancer</strong>. This is what we’d see:</p>
			<p class="source-code">$ helm template fail-example chapter6/examples/fail-example --set service.type=LoadBalancer</p>
			<p class="source-code">Error: execution error at (fail-example/templates/service.yaml:10:6): value 'service.type' must be either 'ClusterIP' or 'NodePort'</p>
			<p>As you can see in the error<a id="_idIndexMarker384"/> message, the <strong class="source-inline">fail</strong> function caused rendering to fail early and displays an error message that was coded in the Service template.</p>
			<p>Let’s look at the next way to perform input validation—the <strong class="source-inline">required</strong> function.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor184"/>The required function</h2>
			<p>The <strong class="source-inline">required</strong> function, as <a id="_idIndexMarker385"/>with <strong class="source-inline">fail</strong>, is also used to halt template rendering. The difference is that, unlike <strong class="source-inline">fail</strong>, the <strong class="source-inline">required</strong> function is used to ensure that a value is not left blank when a chart’s templates are rendered. It is named as such because it requires a user to provide a value when specified.</p>
			<p>Take a look at this snippet of the <strong class="source-inline">values.yaml</strong> file from the chart at <strong class="source-inline">chapter6/examples/required-example</strong>:</p>
			<pre class="source-code">
service:
  type:</pre>
			<p>In the <strong class="source-inline">service.yaml</strong> template for this chart, we see the following output:</p>
			<pre class="source-code">
spec:
  type: {{ required "value 'service.type' is required" .Values.service.type }}</pre>
			<p>This invocation of <strong class="source-inline">required</strong> checks to see if the string represented by the <strong class="source-inline">service.type</strong> value is empty. If it is empty, rendering fails and an error message is displayed. Otherwise, it renders the <strong class="source-inline">service.type</strong> value.</p>
			<p>We can see this in<a id="_idIndexMarker386"/> action by using the <strong class="source-inline">helm template</strong> command, as follows:</p>
			<p class="source-code">$ helm template required-example chapter6/examples/required-example</p>
			<p class="source-code">Error: execution error at (required-example/templates/service.yaml:6:11): value 'service.type' is required</p>
			<p>As expected, we<a id="_idIndexMarker387"/> receive an error message stating that the <strong class="source-inline">service.type</strong> value is required. The user can then remedy this error by providing a value for <strong class="source-inline">service.type</strong> by using either the <strong class="source-inline">--set</strong> or <strong class="source-inline">--values</strong> flags.</p>
			<p>Let’s explore the final<a id="_idIndexMarker388"/> validation method that we will touch upon—the <strong class="source-inline">values.schema.json</strong> file.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor185"/>The values.schema.json file</h2>
			<p>The <strong class="source-inline">values.schema.json</strong> file is <a id="_idIndexMarker389"/>used to define and enforce a schema for your chart’s values. Whereas the <strong class="source-inline">required</strong> and <strong class="source-inline">fail</strong> functions are invoked from within chart templates, the <strong class="source-inline">values.schema.json</strong> file allows you to set value requirements and constraints in a single location. This file also adds additional validation capabilities, such as setting minimums and maximums for integer values.</p>
			<p>The <strong class="source-inline">values.schema.json</strong> file is based on the <strong class="bold">JSON Schema</strong> vocabulary. An exhaustive overview of JSON Schema is out of scope for this book, but you can explore the vocabulary yourself by visiting <a href="http://json-schema.org/specification.html">http://json-schema.org/specification.html</a>.</p>
			<p>Let’s review an example <strong class="source-inline">values.schema.json</strong> file, located in the chart at <strong class="source-inline">chapter6/examples/schema-example</strong> within the Git repository. You can see a representation of this here:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_6.1_B17979.jpg" alt="Figure 7.8 – The Guestbook frontend after the pre-rollback phase&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Sample values.schema.json file</p>
			<p>This schema <a id="_idIndexMarker390"/>provides validation for the following objects under <strong class="source-inline">.Values</strong>:</p>
			<table id="table004-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Object</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Validation</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Values.image</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ensures that the image object exists</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Values.image.repository</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ensures that the <strong class="source-inline">image.repository</strong> value exists and is a string</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Values.image.tag</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ensures that the <strong class="source-inline">image.tag</strong> value exists and is a string</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Values.service</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ensures that the service object exists</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Values.service.type</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ensures that the <strong class="source-inline">service.type</strong> value exists and is set to either <strong class="source-inline">ClusterIP</strong> or <strong class="source-inline">NodePort</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.Values.service.port</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ensures that the <strong class="source-inline">service.port</strong> value exists and is greater than or equal to <strong class="source-inline">8080</strong></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.4 – Values that are validated in the example values.schema.json file</p>
			<p>As shown<a id="_idIndexMarker391"/> in the preceding table, there is a lot of robust validation being performed by providing the <strong class="source-inline">values.schema.json</strong> file. More values could be added to the schema file, but we’ve only included a small amount for demonstration purposes. Sometimes, it is useful to include all supported values in the <strong class="source-inline">values.schema.json</strong> file for purposes of self-documentation or to ensure that all values are strictly validated.</p>
			<p>When using a <strong class="source-inline">values.schema.json</strong> file, error messages are handled for you automatically. For example, let’s see what happens if we try to set <strong class="source-inline">service.type</strong> to <strong class="source-inline">LoadBalancer</strong> (which is not supported in the <strong class="bold">enumerator</strong> (<strong class="bold">enum</strong>) defined in the schema). Here’s the result:</p>
			<p class="source-code">$ helm template schema-example chapter6/examples/schema-example --set service.type=LoadBalancer</p>
			<p class="source-code">Error: values don't meet the specifications of the schema(s) in the following chart(s):</p>
			<p class="source-code">schema-example:</p>
			<p class="source-code">- service.type: service.type must be one of the following: "ClusterIP", "NodePort"</p>
			<p>Notice we did not have to specify the specific error message to return to the user—the JSON Schema library provided it for us.</p>
			<p>In this section, we reviewed three different input validation strategies. Next, we’ll look at enabling template reuse with named templates and library charts.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor186"/>Enabling code reuse with named templates and library charts</h1>
			<p>When creating template files, there may <a id="_idIndexMarker392"/>be boilerplate or<a id="_idIndexMarker393"/> repetitive blocks of YAML among the different Kubernetes resources in a chart.</p>
			<p>For example, you may strive to use a consistent set of labels for each resource, as illustrated here:</p>
			<pre class="source-code">
labels:
  "app.kubernetes.io/instance": {{ .Release.Name }}
  "app.kubernetes.io/managed-by": {{ .Release.Service }}
  "helm.sh/chart": {{ .Chart.Name }}-{{ .Chart.Version }}
  "app.kubernetes.io/version": {{ .Chart.AppVersion }}</pre>
			<p>The preceding labels could be copy-pasted manually throughout your templates, but this would be cumbersome, especially if you wanted to make updates to these labels in the future. To help reduce the amount of boilerplate code and to enable reuse, Helm provides a construct called <strong class="bold">named templates</strong>.</p>
			<p>Named templates, as with regular Kubernetes templates, are defined under the <strong class="source-inline">templates/</strong> directory. They begin with an underscore and end with the <strong class="source-inline">.tpl</strong> file extension. Many charts (including our Guestbook chart) leverage a file called <strong class="source-inline">_helpers.tpl</strong> that contains these named templates, though the file does not need to be called <strong class="source-inline">helpers</strong>. When creating a new chart with the <strong class="source-inline">helm create</strong> command, this file is included in the scaffolded set of resources.</p>
			<p>To create a named <a id="_idIndexMarker394"/>template, chart developers can leverage the <strong class="source-inline">define</strong> action. The following example creates a named template that can be<a id="_idIndexMarker395"/> used to encapsulate resource labels:</p>
			<pre class="source-code">
{{- define "mychart.labels" }}
labels:
  "app.kubernetes.io/instance": {{ .Release.Name }}
  "app.kubernetes.io/managed-by": {{ .Release.Service }}
  "helm.sh/chart": {{ .Chart.Name }}-{{ .Chart.Version }}
  "app.kubernetes.io/version": {{ .Chart.AppVersion }}
{{- end }}</pre>
			<p>The <strong class="source-inline">define</strong> action takes a template name as an argument. In the preceding example, the template name is called <strong class="source-inline">mychart.labels</strong>. The common convention for naming a template is <strong class="source-inline">$CHART_NAME.$TEMPLATE_NAME</strong>, where <strong class="source-inline">$CHART_NAME</strong> is the name of the Helm chart and <strong class="source-inline">$TEMPLATE_NAME</strong> is a short, descriptive name that describes the purpose of the template. The <strong class="source-inline">mychart.labels</strong> name implies that the template is native to the <strong class="source-inline">mychart</strong> Helm chart and will generate labels for resources it is applied to.</p>
			<p>To use a named <a id="_idIndexMarker396"/>template in a Kubernetes YAML template, you<a id="_idIndexMarker397"/> can use the <strong class="source-inline">include</strong> function, which has the following usage:</p>
			<pre class="source-code">
include [TEMPLATE_NAME] [SCOPE]</pre>
			<p>The <strong class="source-inline">TEMPLATE_NAME</strong> parameter is the name of the named template that should be processed. The <strong class="source-inline">SCOPE</strong> parameter is the scope in which values and built-in objects should be processed. Most of the time, this parameter is a dot (<strong class="source-inline">.</strong>) to denote the current top-level scope, but any scope could be provided including the dollar-sign ( <strong class="source-inline">$</strong> ) symbol, which should be used if the named template references values outside of the current scope. </p>
			<p>The following example demonstrates how the <strong class="source-inline">include</strong> function is used to process a named template:</p>
			<pre class="source-code">
metadata:
  name: {{ .Release.Name }}
{{- include "mychart.labels" . | indent 2 }}</pre>
			<p>This example begins by setting the name of the resource to the name of the release. It then uses the <strong class="source-inline">include</strong> function to process the labels and indents each line by two spaces, as declared by the pipeline. When processing is finished, a rendered resource may appear as follows for a release called <strong class="source-inline">template-demonstration</strong>:</p>
			<pre class="source-code">
metadata:
  name: template-demonstration
  labels:
    "app.kubernetes.io/instance": template-demonstration
    "app.kubernetes.io/managed-by": Helm
    "helm.sh/chart": mychart-1.0.0
    "app.kubernetes.io/version": 1.0</pre>
			<p>Helm also provides a <strong class="source-inline">template</strong> action that can also expand named templates. This action has the same usage as <strong class="source-inline">include</strong>, but with one major limitation—it cannot be used in a pipeline to provide additional formatting and processing capabilities. The <strong class="source-inline">template</strong> action is used to simply display data inline. Because of this limitation, chart developers should use the <strong class="source-inline">include</strong> function over the <strong class="source-inline">template</strong> action since <strong class="source-inline">include</strong> has <a id="_idIndexMarker398"/>feature parity with <strong class="source-inline">template</strong> but also provides<a id="_idIndexMarker399"/> additional processing options.</p>
			<p>Named templates are excellent for reducing boilerplate in a single Helm chart, but imagine you want to share common boilerplate (such as labels) across multiple Helm charts. To do this, you can<a id="_idIndexMarker400"/> leverage <strong class="bold">library charts</strong>. Library charts are similar in structure to <a id="_idIndexMarker401"/>application charts, but their <strong class="source-inline">type</strong> field in <strong class="source-inline">Chart.yaml</strong> is set to <strong class="source-inline">library</strong>. Library charts also differ in that they cannot be installed—a library chart’s purpose is to provide a set of helper templates that can then be imported among different application charts by using dependency management. </p>
			<p>An example of a library chart is Bitnami’s <strong class="source-inline">common</strong> chart, which can be seen at the following link: <a href="https://github.com/bitnami/charts/tree/master/bitnami/common">https://github.com/bitnami/charts/tree/master/bitnami/common</a>. There, you will find that each of the chart’s templates is actually a <strong class="source-inline">tpl</strong> file that contains named templates within. Here is an abbreviated list from Bitnami’s common library chart:</p>
			<ul>
				<li><strong class="source-inline">_affinities.tpl</strong></li>
				<li><strong class="source-inline">_capabilities.tpl</strong></li>
				<li><strong class="source-inline">_errors.tpl</strong></li>
				<li><strong class="source-inline">_images.tpl</strong></li>
			</ul>
			<p>These named templates can be used by adding the following dependency to any application Helm chart:</p>
			<pre class="source-code">
dependencies:
  - name: common
    version: 0.x.x
    repository: https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami </pre>
			<p>Then, any chart<a id="_idIndexMarker402"/> importing this dependency can leverage any<a id="_idIndexMarker403"/> template by referencing the template name with the <strong class="source-inline">include</strong> function—for example, <strong class="source-inline">{{ include "common.names.fullname" . }}</strong>.</p>
			<p>In the next section, we will explore how Helm can handle the creation of Kubernetes <strong class="bold">custom resources</strong> (<strong class="bold">CRs</strong>).</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor187"/>Creating CRDs</h1>
			<p>While Helm is often <a id="_idIndexMarker404"/>used to create traditional Kubernetes resources, it can also be used to create CRDs and CRs. CRDs are used to define resources that are not native to the Kubernetes API. You may want to use this functionality to augment the abilities that Kubernetes provides. CRs are resources that implement the CRD’s specification. As a result, it’s important to ensure that a CRD is always created before the CRs that implement it.</p>
			<p>Helm is able to ensure CRDs are created and registered to Kubernetes before CRs are included in a Helm chart when CRDs are included in the chart’s <strong class="source-inline">crds/</strong> folder. All CRDs defined under this folder are created before those in <strong class="source-inline">templates/</strong>.</p>
			<p>An example <strong class="source-inline">crds/</strong> folder is shown here:</p>
			<pre class="source-code">
crds/
  my-custom-resource-crd.yaml</pre>
			<p>The <strong class="source-inline">my-custom-resource-crd.yaml</strong> file may have the following contents:</p>
			<pre class="source-code">
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: my-custom-resources.learnhelm.io
spec:
  group: learnhelm.io
  names:
    kind: MyCustomResource
    listKind: MyCustomResourceList
    plural: MyCustomResources
    singular: MyCustomResource
  scope: Namespaced
  version: v1</pre>
			<p>Then, the <strong class="source-inline">templates/</strong> directory can contain an instance of the <strong class="source-inline">MyCustomResource</strong> resource (that is, the CR), as illustrated here:</p>
			<pre class="source-code">
templates/
  my-custom-resource.yaml</pre>
			<p>There are a few important<a id="_idIndexMarker405"/> caveats to note when creating CRDs with Helm. First, CRDs cannot be templated, so they are created exactly as defined under the CRDs folder. Second, CRDs cannot be deleted with Helm, and as a result, they also cannot be upgraded or rolled back. Third, creating CRDs requires <strong class="source-inline">cluster-admin</strong> privileges within the Kubernetes cluster. Note that these caveats apply to CRDs, not CRs. Since CRs are created in the <strong class="source-inline">templates/</strong> folder, they are treated by Helm like regular Kubernetes resource templates. CRs also typically do not require elevated permissions to the level of <strong class="source-inline">cluster-admin</strong>, so they can typically be installed by normal users. </p>
			<p>Throughout this chapter, we have discussed using templates to render Kubernetes resources with Helm. In the next section, we will discuss how advanced Helm chart users can further process Kubernetes resources while running an installation.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor188"/>Post rendering</h1>
			<p>When developing Helm charts, you <a id="_idIndexMarker406"/>should carefully consider each of the different values that need to be included in your chart. For example, if you know users may need to change the Service type within Service templates, you should expose a value to do so to keep your chart flexible. The same idea holds true for image names, resources, health checks, and other settings users would need to configure based on your use case.</p>
			<p>Sometimes, however, users will still require additional flexibility that is not provided by a Helm chart. This is where post rendering comes into play. Post rendering is an advanced feature of Helm that allows users to perform further modifications to rendered chart templates when they install your chart. It is often seen as a last resort if they require modifications that your Helm chart does not allow.</p>
			<p>Post rendering is applied by adding the <strong class="source-inline">--post-renderer</strong> flag to the <strong class="source-inline">install</strong>, <strong class="source-inline">upgrade</strong>, or <strong class="source-inline">template</strong> commands. Here is an example:</p>
			<p class="source-code">$ helm install &lt;release-name&gt; &lt;path-to-chart&gt; --post-renderer &lt;path-to-executable&gt;</p>
			<p>The <strong class="source-inline">&lt;path-to-executable&gt;</strong> parameter is an executable file that invokes the post-renderer. The executable could be anything from a Go program to a shell script invoking another tool, such as <strong class="bold">Kustomize</strong>. Kustomize is a <a id="_idIndexMarker407"/>tool used for patching YAML files, so it is often used for post rendering.</p>
			<p>We won’t dive deep into Kustomize because it is out of scope for this book. However, we have included an example of using Kustomize as a post-renderer in the Git repository at <strong class="source-inline">chapter6/examples/post-renderer-example</strong> that can be invoked as follows, assuming that the <strong class="source-inline">kustomize</strong> command-line tool is available on the local machine:</p>
			<p class="source-code">$ cd chapter6/examples/post-renderer-example/post-render</p>
			<p class="source-code">$ helm template nginx ../nginx --post-renderer ./hook.sh</p>
			<p>The <strong class="source-inline">hook.sh</strong> file invokes Kustomize, which patches the deployment and service YAML resources with custom environment variables and the <strong class="source-inline">NodePort</strong> service type, as defined in the <strong class="source-inline">kustomization.yaml</strong> file.</p>
			<p>In this section, we discussed post rendering. One note before we depart from this topic is that post rendering should not be considered part of normal Helm usage. As a chart developer, you should ensure that your chart is flexible enough for users to leverage your chart as-is out of the box. As a chart user, you should try to avoid using post renders unless absolutely necessary. This is because you need to remember to use the <strong class="source-inline">--post-renderer</strong> flag on each Helm upgrade, or the patch will be inadvertently omitted. Post-renderers <a id="_idIndexMarker408"/>also require additional effort from the user to maintain, as there may be tooling or other prerequisites needed.</p>
			<p>Throughout this chapter, we have covered each of the key components of Helm templates. Next, we will tie this all in by returning to our Guestbook chart. We will make small updates to the scaffolded <strong class="source-inline">values.yaml</strong> file and the <strong class="source-inline">deployment.yaml</strong> template, and we will deploy our Guestbook Helm chart.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor189"/>Updating and deploying the Guestbook chart</h1>
			<p>In order to successfully deploy our Guestbook application, we need to add values to configure the following details:</p>
			<ul>
				<li>Configure the Redis service names and disable Redis authentication</li>
				<li>Create environment variables for defining the names of the Redis leader and follower</li>
			</ul>
			<p>We will begin by first handling Redis values.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor190"/>Updating Redis values</h2>
			<p>In <a href="B17979_05.xhtml#_idTextAnchor154"><em class="italic">Chapter 5</em></a>, <em class="italic">Helm Dependency Management</em>, we created a Redis dependency for creating a backend. Now, we <a id="_idIndexMarker409"/>will add a couple of values to our <strong class="source-inline">values.yaml</strong> file to complete the configuration.</p>
			<p>The values that we need to add are in the Git repository at <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L5-L8">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L5-L8</a> and are shown in the following snippet:</p>
			<pre class="source-code">
redis:
  fullnameOverride: redis
  auth:
    enabled: false</pre>
			<p>The <strong class="source-inline">redis.fullnameOverride</strong> value is used to ensure that deployed Redis instances are prefixed with <strong class="source-inline">redis</strong>. This will help ensure the Guestbook application is talking to consistently named instances. </p>
			<p>Setting the <strong class="source-inline">redis.auth.enabled</strong> value to <strong class="source-inline">false</strong> will disable Redis authentication. This is necessary because the Guestbook frontend is not configured to authenticate with Redis.</p>
			<p>That’s all the changes <a id="_idIndexMarker410"/>needed for Redis. Let’s update the Guestbook values and templates next.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor191"/>Updating Guestbook’s deployment template and values.yaml file</h2>
			<p>The <strong class="source-inline">helm create</strong> command we used in <a href="B17979_04.xhtml#_idTextAnchor139"><em class="italic">Chapter 4</em></a>, <em class="italic">Scaffolding a New Helm Chart,</em> did an excellent job of<a id="_idIndexMarker411"/> giving us almost all of the<a id="_idIndexMarker412"/> templating features we need for this application, but there is one gap that we need to fill in order to deploy Guestbook. We need to be able to set environment variables in the Guestbook deployment in order to tell the frontend how to connect to Redis.</p>
			<p>If we observe the Guestbook source code at <a href="https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/main/guestbook/php-redis/guestbook.php">https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/main/guestbook/php-redis/guestbook.php</a>, we can see three different environment variables that need to be set, as follows:</p>
			<ul>
				<li><strong class="source-inline">GET_HOSTS_FROM</strong>: Informs Guestbook whether or not it should retrieve the Redis hostnames from the environment. We will set this to <strong class="source-inline">env</strong> so that hostnames are retrieved from the two environment variables defined next.</li>
				<li><strong class="source-inline">REDIS_LEADER_SERVICE_HOST</strong>: Provides the hostname of the Redis leader. Because the Redis dependency we are using specifies the leader as <strong class="source-inline">redis-master</strong>, we will set this value to <strong class="source-inline">redis-master</strong>.</li>
				<li><strong class="source-inline">REDIS_FOLLOWER_SERVICE_HOST</strong>: Provides the hostname of the Redis follower. The Redis dependency we are using specifies the follower as <strong class="source-inline">redis-replicas</strong>, so we will set this value to <strong class="source-inline">redis-replicas</strong>.</li>
			</ul>
			<p>Since the scaffolded <strong class="source-inline">deployment.yaml</strong> template did not allow for environment variables to be created, we need to write this logic into the template ourselves. We can do this by adding the lines located at <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/templates/deployment.yaml#L50-L51">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/templates/deployment.yaml#L50-L51</a>, which are also shown here:</p>
			<pre class="source-code">
env:
  {{- toYaml .Values.env | nindent 12 }}</pre>
			<p>Here, we <a id="_idIndexMarker413"/>added a new <strong class="source-inline">env</strong> object. Underneath, we <a id="_idIndexMarker414"/>are using the <strong class="source-inline">toYaml</strong> function to format the <strong class="source-inline">env</strong> value (which we will add shortly) as a YAML object. Then, we are using a pipeline and the <strong class="source-inline">nindent</strong> function to form a new line and indent by 12 spaces.</p>
			<p>Next, we need to add the <strong class="source-inline">env</strong> object with the associated content to our <strong class="source-inline">values.yaml</strong> file. An example of this is located at <a href="https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L10-L16">https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L10-L16</a> and is also displayed here:</p>
			<pre class="source-code">
env:
  - name: GET_HOSTS_FROM
    value: env
  - name: REDIS_LEADER_SERVICE_HOST
    value: redis-master
  - name: REDIS_FOLLOWER_SERVICE_HOST
    value: redis-replicas</pre>
			<p>With the Guestbook chart’s values and template updated, let’s move on to the next section.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor192"/>Deploying the Guestbook chart</h2>
			<p>Now, it’s time to<a id="_idIndexMarker415"/> deploy a fully functional Guestbook instance with our Helm chart! First, start your minikube environment and create a new namespace for this chapter, as shown here. If you already started and created the <strong class="source-inline">chapter6</strong> name at the beginning of this chapter, you can skip the next two commands:</p>
			<p class="source-code">$ minikube start</p>
			<p class="source-code">$ kubectl create namespace chapter6</p>
			<p>Then, use the <strong class="source-inline">helm install</strong> command to deploy the Guestbook instance, as illustrated here. You should also watch the pods in the namespace for the Redis pods to become ready:</p>
			<p class="source-code">$ helm install guestbook chapter6/guestbook -n chapter6</p>
			<p class="source-code">$ kubectl get pods –n chapter6 –w</p>
			<p>Once the Redis instances are ready, hit <em class="italic">Ctrl+C</em> to stop watching resources and then use the <strong class="source-inline">kubectl port-forward</strong> command to expose your Guestbook frontend to localhost on port <strong class="source-inline">8080</strong>:</p>
			<p class="source-code">$ kubectl port-forward svc/guestbook 8080:80 -n chapter6</p>
			<p>Once the Guestbook service is exposed, you can navigate to the <strong class="source-inline">http://localhost:8080</strong> <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) in your browser. The Guestbook frontend should appear. Try entering a message, such as <strong class="bold">Hello world!</strong>, and a message should appear under the blue <strong class="bold">Submit</strong> button, as illustrated here:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_6.2_B17979.jpg" alt="Figure 6.2 – The Guestbook frontend after the Hello world! message has been submitted&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The Guestbook frontend after the Hello world! message has been submitted</p>
			<p>If you are able to load the page in a browser and enter a message, then congratulations! You have successfully built and deployed your first Helm chart! However, as with any software product, you can always continue to make improvements. We will enhance this chart in the next chapter by adding upgrade and rollback hooks for performing backup and restore of the Redis database.</p>
			<p>For now, when<a id="_idIndexMarker416"/> you are done working, feel free to clean up your environment and stop your minikube instance, as follows:</p>
			<p class="source-code">$ kubectl delete ns chapter6</p>
			<p class="source-code">$ minikube stop</p>
			<p>This brings us to the end of the section.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor193"/>Summary</h1>
			<p>Templates represent the core of Helm’s functionality. They allow you to create a variety of different Kubernetes resource configurations by enabling dynamic YAML generation. Helm’s template engine, based on Go templates, contains several built-in objects upon which chart developers can build charts, such as the <strong class="source-inline">.Values</strong> and <strong class="source-inline">.Release</strong> objects. Templates also provide many different functions to provide robust formatting and manipulation, along with control structures for enabling conditional logic and loops. Besides rendering Kubernetes resources, templates can also be used to abstract boilerplate by using named templates and library charts.</p>
			<p>By incorporating the capabilities provided by templates, we were able to make small modifications to the Guestbook chart at the end of the chapter by enhancing the content of the values and the <strong class="source-inline">deployment.yaml</strong> chart template, which resulted in the ability to deploy the Guestbook application successfully. In the next chapter, we will continue to explore templates and enhance our Helm chart by learning about and leveraging lifecycle hooks.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor194"/>Further reading</h1>
			<p>To learn more about the basics behind creating Helm charts, consult the <em class="italic">Chart Template Developer’s Guide</em> page on the Helm documentation at <a href="https://helm.sh/docs/chart_template_guide/">https://helm.sh/docs/chart_template_guide/</a>.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor195"/>Questions</h1>
			<p>See if you can answer the following questions:</p>
			<ol>
				<li value="1">Which Helm templating construct can you take advantage of to generate repeating YAML portions?</li>
				<li>What is the purpose of the <strong class="source-inline">with</strong> action?</li>
				<li>What are the different built-in objects in Helm templates?</li>
				<li>How does a Kubernetes resource template differ from a named template?</li>
				<li>How does an application chart differ from a library chart?</li>
				<li>What can a chart developer do to perform input validation?</li>
				<li>What are some examples of different functions commonly used in Helm templates?</li>
				<li>What is the difference between a template variable and a value?</li>
			</ol>
		</div>
		<div>
			<div id="_idContainer075">
			</div>
		</div>
	</body></html>