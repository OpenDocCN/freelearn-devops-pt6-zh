- en: Building Kubernetes on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Amazon Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Kubernetes by kops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AWS as Kubernetes Cloud Provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Kubernete cluster on AWS by kops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on a recent survey of the Cloud Native Computing Foundation, CNCF, **Amazon
    Web Services** (**AWS**) is a dominant solution for production-level Kubernetes
    systems ([https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/](https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/)).
    In this chapter, you will learn about the cloud services of AWS, and how these
    services work together to deliver a robust Kubernetes system. We will also introduce
    how kops works, a tool for Kubernetes operation, which helps us manage the Kubernetes
    cluster. Let's explore the world of Kubernetes in AWS!
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon Web Services ([https://aws.amazon.com](https://aws.amazon.com/)) is the
    most popular public cloud service. It provides the online service for Virtual
    Server (EC2), Software Defined Network (VPC), Object Store (S3), and so on. It
    is a suitable infrastructure to set up a Kubernetes cluster. We will explore AWS
    to understand the fundamental function of AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, you need to sign up to AWS. AWS gives a free tier that allows
    you to use some amount of AWS resources, free for 12 months. Go to [https://aws.amazon.com/free/](https://aws.amazon.com/free/) to
    register your information and credit card. It may take 24 hours to verify and
    activate your account.
  prefs: []
  type: TYPE_NORMAL
- en: Once your AWS account is activated, we need to create one **Identity and Access
    Management** (**IAM**) user, which will control your AWS infrastructure via APIs.
    Then, install the AWS CLI on to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create an IAM user:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to AWS Web console [https://console.aws.amazon.com](https://console.aws.amazon.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on IAM (use the search box, which makes it easier to find):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5cf92cc-6868-4735-a725-6d57a0725e32.png)'
  prefs: []
  type: TYPE_IMG
- en: Access to IAM console
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Users in the left navigation and then click on Add user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35a36126-64d0-49e6-9a79-103209103aaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating an IAM user
  prefs: []
  type: TYPE_NORMAL
- en: 'Type User name `chap6`, then choose Programmatic access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fe599cfc-8532-499e-9784-30dfc41a75cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating chap6 user
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose Attach existing policies directly, as shown in the following screenshot, and
    then select the following policies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AmazonEC2FullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonRoute53FullAcccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonS3FullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonVPCFullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IAMFullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/301e2810-98e5-4151-94f4-c7983a5d6d22.png)'
  prefs: []
  type: TYPE_IMG
- en: Attaching the necessary Policy
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, it generates Access key ID and Secret access key. Copy and paste
    into your text editor or click on Download .csv to preserve to your computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15b0a0e3-91ca-4c49-9074-48a042f112e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Downloading Access key ID and Secret access key
  prefs: []
  type: TYPE_NORMAL
- en: Installing AWS CLI on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install `awscli` to macOS using HomeBrew ([https://brew.sh](https://brew.sh));
    this is the easiest way. HomeBrew has already been introduced in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building
    your own Kubernetes Cluster*, while installing minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install awscli by HomeBrew on your Mac, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command to update the latest formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify `awscli` to install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the `aws` command using the` --version` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installing AWS CLI on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install awscli on Windows; there is a Windows installer package, which is the
    easiest way to install  awscli on to your Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to AWS Command Line Interface page ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download Windows installer 64 bit ([https://s3.amazonaws.com/aws-cli/AWSCLI64.msi](https://s3.amazonaws.com/aws-cli/AWSCLI64.msi))
    or 32 bit ([https://s3.amazonaws.com/aws-cli/AWSCLI32.msi](https://s3.amazonaws.com/aws-cli/AWSCLI32.msi)),
    based on your Windows OS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Launch AWS CLI installer, and then choose the default option to proceed with
    the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d30f75b4-ae98-4293-9f1c-bfde62241948.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing AWS CLI for Windows
  prefs: []
  type: TYPE_NORMAL
- en: 'After complete installation, launch Command Prompt. Then, type the `aws` command
    with the `--version` option to verify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f175700-22de-4607-9433-3c09cd6f7fad.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing aws command on Windows
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, you need to set your AWS Access Key ID and AWS Secret Access Key
    for awscli. We've already acquired `chap6` for the IAM user. We will use this
    user's Access Key ID and Secret Access Key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch terminal (Command Prompt for Windows), and then use the `aws` command
    to set `Access Key ID` and `Secret Access Key`. Also, set the default region as
    `us-east-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Check `chap6` IAM user using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now you can start using AWS to launch your own network and instances.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explorer AWS to launch a typical infrastructure. Using awscli to build
    your own VPC, Subnet, Gateway, and Security group. Then, launch the EC2 instance
    to understand the basic usage of AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Creating VPC and Subnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Virtual Private Cloud** (**VPC**) is a Software-Defined Network. You can
    configure a virtual network on AWS. Subnets are inside of VPC that define network
    block (**Classless Inter Domain Routing** (**CIDR**)) such as `192.168.1.0/24`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create one VPC and two subnets using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new VPC that has `192.168.0.0/16` CIDR block (IP range: `192.168.0.0`
    – `192.168.255.255`). Then, capture `VpcId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the first subnet under the VPC (`vpc-69cfbd12`) that has `192.168.0.0/24`
    CIDR block (IP range: `192.168.0.0` – `192.168.0.255`) and specify the availability
    zone as `us-east-1a`. Then, capture `SubnetId:`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the second subnet on `us-east-1b`, which has `192.168.1.0/24` CIDR block
    (IP range: `192.168.1.0` – `192.168.1.255`). Then, capture `SubnetId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the subnet list under VPC (`vpc-69cfbd12`) using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This looks good!
  prefs: []
  type: TYPE_NORMAL
- en: Internet gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access your VPC network, you need to have a gateway that accesses it from
    the internet. **Internet Gateway** (**IGW**) is the one that connects the internet
    to your VPC.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the subnets under VPC, you can set the default route to go to IGW or
    not. If it routes to IGW, the subnet is classified as the public subnet. Then,
    you can assign the global IP address on the public subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure the first subnet (`192.168.0.0/24`) as the public subnet that
    routes to IGW using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create IGW and capture `InternetGatewayId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach IGW (`igw-e50b849d`) to your VPC (`vpc-69cfbd12`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create a routing table on VPC (`vpc-69cfbd12`) and then capture `RouteTableId:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the default route (`0.0.0.0/0`) for route table (`rtb-a9e791d5`) as IGW
    (`igw-e50b849d`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate route table (`rtb-a9e791d5`) to public subnet (`subnet-6296863f`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable autoassign public IP on the public subnet (`subnet-6296863f`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: NAT-GW
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if the subnet default route is not pointing to IGW? The subnet
    is classified as a private subnet with no connectivity to the internet. However,
    some of situation, your VM in private subnet needs to access to the Internet.
    For example, download some security patch.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can setup NAT-GW. It allows you access to the internet from
    the private subnet. However, it allows outgoing traffic only, so you cannot assign
    public IP address for a private subnet. Therefore, it is suitable for backend
    instances, such as the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create NAT-GW and configure a second subnet (`192.168.1.0/24`) as a
    private subnet that routes to NAT-GW using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'NAT-GW needs a Global IP address, so create **Elastic IP** (**EIP**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create NAT-GW on the public subnet (`subnet-6296863f`) and assign EIP (`eipalloc-bad28bb3`).
    Then, capture `NatGatewayId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since NAT-GW needs to access the internet, it must be located on the public
    subnet instead of the private subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the route table and capture `RouteTableId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the default route (`0.0.0.0/0`) of the route table (`rtb-70f1870c`) to
    NAT-GW (`nat-0b12be42c575bba43`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate route table (`rtb-70f1870c`) to private subnet (`subnet-ce947da`9):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Security group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before launching your Virtual Server (EC2), you need to create a Security Group
    that has an appropriate security rule. Now, we have two subnets, public and private.
    Let''s set public subnet such that it allows `ssh` (`22/tcp`) and `http` (`80/tcp`)
    from the internet. Then, set the private subnet such that it allows ssh from the
    public subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create one security group for the public subnet on VPC (`vpc-69cfbd12`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the ssh allow rule to the public security group (`sg-dd8a3f94`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `http` allow rule to the public security group (`sg-dd8a3f94`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a second security group for the private subnet on VPC (`vpc-69cfbd12`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `ssh` allow rule to the private security group (`sg-a18c39e8`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the Security Group list using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you need to upload your ssh public key and then launch the EC2 instance
    on both the public subnet and the private subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload your ssh public key (assume you have a public key that is located at `~/.ssh/id_rsa.pub`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the first EC2 instance with the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use Amazon Linux image: `ami-1853ac65` (Amazon Linux)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T2.nano instance type: `t2.nano`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ssh key: `chap6-key`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public Subnet: `subnet-6296863f`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public Security Group: `sg-dd8a3f94`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the second EC2 instance with the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use Amazon Linux image: `ami-1853ac65`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T2.nano instance type: `t2.nano`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ssh key: `chap6-key`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Private subnet: `subnet-ce947da9`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Private Secuity Group: `sg-a18c39e8`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the EC2 instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH (use the `-A` option to forward your authentication info) to the public
    EC2 host from your computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Install and launch nginx to the public EC2 host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you can access the nginx server from your machine (see the following
    screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ecb8ab27-c187-49c4-ab25-ce68e6d67977.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing nginx web server on public host
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH from the public host to the private host (you must use a private IP address):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the private host can perform yum update via NAT-GW:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! You can set up your own infrastructure on AWS, as shown in
    the following diagram, which has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One VPC with CIDR `192.168.0.0/16`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IGW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NAT-GW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two Subnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'public subnet: `192.168.0.0/24` route to IGW'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'private subnet: 192.168.1.0/24 route to NAT-GW'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two EC2 instances (public and private)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two Security Groups (allow public http/ssh and private ssh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, take a look at the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97480e7b-4918-4383-841c-372a6992a957.png)'
  prefs: []
  type: TYPE_IMG
- en: AWS components diagram
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how to use AWS from scratch. We have covered
    its basic uses, but it is important to know while setup Kubernetes on AWS. Next,
    we will explore how to set up Kubernetes on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Kubernetes with kops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is kops? It is the abbreviated term of Kubernetes Operation ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)).
    Similar to kubeadm, minikube, and kubespray, kops reduces the heavy duty of building
    up a Kubernetes cluster by ourselves. It helps in creation, and provides an interface
    to users for managing the clusters. Furthermore, kops achieves a more automatic
    installing procedure and delivers a production-level system. It targets to support
    dominate cloud platforms, such as AWS, GCE, and VMware vSphere. In this recipe,
    we will talk about how to run a Kubernetes cluster with kops.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before our major tutorial, we will need to install kops on to your local host.
    It is a straightforward step for downloading the binary file and moving it to
    the system directory of the execution file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to prepare some AWS configuration on your host and required services
    for cluster. Refer to the following items and make sure that they are ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IAM user**: Since kops would create and build several AWS service components
    together for you, you must have an IAM user with kops required permissions. We''ve
    created an IAM user named chap6 in the previous section that has the following
    policies with the necessary permissions for kops:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonEC2FullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonRoute53FullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonS3FullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IAMFullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonVPCFullAccess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, exposing the AWS access key ID and secret key as environment variables
    can make this role applied on host while firing `kops` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Prepare an S3 bucket for storing cluster configuration**: In our demonstration
    later, the S3 bucket name will be `kubernetes-cookbook`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prepare a Route53 DNS domain for accessing points of cluster**: In our demonstration
    later, the domain name we use will be `k8s-cookbook.net`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily run up a Kubernetes cluster using a single command with parameters
    containing complete configurations. These parameters are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** | **Value in example** |'
  prefs: []
  type: TYPE_TB
- en: '| `--name` | This is the name of the cluster. It will also be the domain name
    of the cluster''s entry point. So you can utilize your Route53 DNS domain with
    a customized name, for example, `{your cluster name}.{your Route53 domain name}`.
    | `my-cluster.k8s-cookbook.net` |'
  prefs: []
  type: TYPE_TB
- en: '| `--state` | This indicates the S3 bucket that stores the status of the cluster
    in the format `s3://{bucket name}`. | `s3://kubernetes-cookbook` |'
  prefs: []
  type: TYPE_TB
- en: '| `--zones` | This is the availability zone where you need to build your cluster.
    | `us-east-1a` |'
  prefs: []
  type: TYPE_TB
- en: '| `--cloud` | This is the cloud provider. | `aws` |'
  prefs: []
  type: TYPE_TB
- en: '| `--network-cidr` | Here, kops helps to create independent CIDR range for
    the new VPC. | `10.0.0.0/16` |'
  prefs: []
  type: TYPE_TB
- en: '| `--master-size` | This is the instance size of Kubernetes master. | `t2.large`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--node-size` | This is the instance size of Kubernetes nodes. | `t2.medium`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--node-count` | This is the number of nodes in the cluster. | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `--network` | This is the overlay network used in this cluster. | `calico`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--topology` | This helps you decide whether the cluster is public facing.
    | `private` |'
  prefs: []
  type: TYPE_TB
- en: '| `--ssh-public-key` | This helps you assign an SSH public key for bastion
    server, then we may log in through the private key. | `~/.ssh/id_rsa.pub` |'
  prefs: []
  type: TYPE_TB
- en: '| `--bastion` | This gives you an indication to create the bastion server.
    | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `--yes` | This gives you the confirmation for executing immediately. | N/A
    |'
  prefs: []
  type: TYPE_TB
- en: 'Now we are ready to compose the configurations into a command and fire it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few minutes, the command takes out the preceding logs showing what
    AWS services have been created and served for you kops-built Kubernetes cluster.
    You can even check your AWS console to verify their relationships, which will
    look similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43f90e6c-c355-49df-8f2b-f59719ddca51.png)'
  prefs: []
  type: TYPE_IMG
- en: The components of Kubernetes cluster in AWS created by kops
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From localhost, users can interact with the cluster on AWS using the kops command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Working with kops-built AWS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Furthermore, as you can see in the previous section, the last few logs of kops
    cluster creation shows that the environment of the client is also ready. It means
    that kops helps to bind the API server to our host securely as well. We may use
    the `kubectl` command like we were in Kubernetes master. What we need to do is
    install kubectl manually. It would be as simple as installing kops; just download
    the binary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can still access the nodes in the cluster. Since the cluster is
    set down in a private network, we will require to login to the bastion server
    first, and jump to the nodes for the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Deleting kops-built AWS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can simply remove our cluster using the kops command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It will clean the AWS services for you. But some other services created by
    yourself: S3 bucket, IAM role with powerful authorization, and Route53 domain
    name; kops will not remove them on user''s behavior. Remember to delete the no
    used AWS services on your side.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Playing with Amazon Web Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using AWS as Kubernetes Cloud Provider*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Managing Kubernetes cluster on AWS by kops*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting up the Kubernetes cluster on Linux by kubeadm* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building your own Kubernetes Cluster*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting up Kubernetes cluster on Linux by kubespray* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building your own Kubernetes* *Cluster*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AWS as Kubernetes Cloud Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From Kubernetes 1.6, **Cloud Controller Manager** (**CCM**) was introduced,
    which defines a set of interfaces so that different cloud providers could evolve
    their own implementations out of the Kubernetes release cycle. Talking to the
    cloud providers, you can''t ignore the biggest player: Amazon Web Service. According
    to the Cloud Native Computing Foundation, in 2017, 63% of Kubernetes workloads
    run on AWS. AWS CloudProvider supports Service as **Elastic Load Balancer** (**ELB**)
    and Amazon **Elastic Block Store** (**EBS**) as StorageClass.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time this book was written, Amazon Elastic Container Service for Kubernetes
    (Amazon EKS) was under preview, which is a hosted Kubernetes service in AWS. Ideally,
    it'll have better integration with Kubernetes, such as **Application Load Balancer**
    (**ALB**) for Ingress, authorization, and networking. Currently in AWS, the limitation
    of routes per route tables in VPC is 50; it could be up to 100 as requested. However,
    network performance may be impacted if the routes exceed 50 according to the official
    documentation of AWS. While kops uses kubenet networking by default, which allocates
    a/24 CIDR to each node and configures the routes in route table in AWS VPC. This
    might lead to the performance hit if the cluster has more than 50 nodes. Using
    a CNI network could address this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For following along with the examples in this recipe, you''ll need to create
    a Kubernetes cluster in AWS. The following example is using kops to provision
    a Kubernetes cluster named `k8s-cookbook.net` in AWS; as the preceding recipes
    show, set `$KOPS_STATE_STORE` as a s3 bucket to store your kops configuration
    and metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run the recommended kops update cluster `<cluster_name> --yes` command,
    after a few minutes, the cluster is up and running. We can use the kops validate
    cluster to check whether the cluster components are all up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We're good to go!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When running Kubernetes in AWS, there are two possible integrations we could
    use: ELB as Service with `LoadBalancer` Type and Amazon Elastic Block Store as
    `StorageClass`.'
  prefs: []
  type: TYPE_NORMAL
- en: Elastic load balancer as LoadBalancer service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `LoadBalancer` Service with Pods underneath, which is what
    we learned in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing
    with Containers*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding template, we declared one nginx Pod and associated it with
    the `LoadBalancer` service. The service will direct the packet to container port
    `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s describe our `nginx` Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After the service is created, we will find out that the AWS CloudProvider will
    provision a classic load balancer with the endpoint `adb576a05401911e8b1240ef0c7f25d3-1637943008.us-east-1.elb.amazonaws.com`.
    We can check its detailed settings via the aws command-line interface ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)).
  prefs: []
  type: TYPE_NORMAL
- en: To install aws CLI, you can use pip to install in Mac or Linux (`pip install
    awscli`); for Windows users, you'll have to download the installer from the official
    website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The combination of AWS CLI commands is `aws [options] <command> <subcommand>
    [<subcommand> ...] [parameters]`. For listing load balancers, we''ll use `aws
    elb describe-load-balancers` as the major command. Using the `--load-balancer-names
    parameter` will filter load balancers by name, and for the `--output` parameter,
    you can choose text, JSON, or table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we access this ELB endpoint port `80`, we''ll see the nginx welcome page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40c40acf-d984-4021-ab91-c7f7f92e54bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Access ELB endpoint to access LoadBalancer Service
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scene, AWS CloudProvider creates a AWS elastic load balancer and
    configures its ingress rules and listeners by the Service we just defined. The
    following is a diagram of how the traffic gets into the Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63c00acb-0240-4931-9813-9ffa62912489.png)'
  prefs: []
  type: TYPE_IMG
- en: The illustration of Kubernetes resources and AWS resources for Service with
    LoadBalancer type
  prefs: []
  type: TYPE_NORMAL
- en: The external load balancer receives the requests and forwards them to EC2 instances
    using a round-robin algorithm. For Kubernetes, the traffic gets into the Service
    via NodePort and starts a Service-to-Pod communication. For more information about
    external-to-Service and Service-to-Pod communications, you can refer to [Chapter
    3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing with Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic Block Store as StorageClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned about Volumes in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*. We know `PersistentVolumeClaims` is used
    to abstract storage resources from users. It can dynamically provision the `PersistentVolume`
    via `StorageClass`. The default provisioner in `StorageClass` in **AWS CloudProvider
    is Elastic Block Storage Service**‎ (**aws-ebs**). Whenever you request a PVC,
    aws-ebs provisioner will create a volume in AWS EBS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the storage class in our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After PVC is created, an associated PV will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can take a closer look at PV here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can find that it's associated with the claim we just created `pvclaim01`
    and the source type is `AWSElasticBlockStore`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use AWS CLI to inspect the volume we created in EBS. Using the `--filter
    Name=tag-`value we can filter the volumes in EBS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the EBS resource has been tagged with lots of different values: by
    observing these tags, we can know which Kubernetes cluster, namespace, PVC, and
    PV are associated with this EBS volume.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to dynamic provisioning that StorageClass and CloudProvider support,
    Volume management is no longer a huge pain. We can create and destroy PV on the
    fly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this book, there is no native way in Kubernetes 1.10
    to support Ingress integration in AWS CloudProvider yet (ideally with application
    load balancer). Alternatively, kops provides addons that allow you to do so. The
    first one is ingress-nginx ([https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx](https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx)),
    which is powered by nginx ([https://nginx.org](https://nginx.org)) and AWS Elastic
    Load Balancer. The requests will go through ELB to nginx, and nginx will dispatch
    the requests, based on the path definition in Ingress. Another alternative is
    running skipper as kubernetes-ingress-controller ([https://zalando.github.io/skipper/dataclients/kubernetes](https://zalando.github.io/skipper/dataclients/kubernetes)).
    Kops also provides add-ons to help you deploy and leverage skipper and AWS Application
    Load Balancer ([https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller](https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller)).
  prefs: []
  type: TYPE_NORMAL
- en: We're expecting CCM and Amazon EKS ([https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)) to
    provide more native integration for Ingress via AWS Application Load Balancer,
    and there will be more to come!
  prefs: []
  type: TYPE_NORMAL
- en: Managing Kubernetes cluster on AWS by kops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In kops, both Kubernetes masters and nodes are running as auto-scaling groups
    in AWS. In kops, the concept is called **instance groups** (**ig**), which indicate
    the same type of instances in your cluster. Similar to nodes across zones, or
    masters in each availability zone, we could check it via the kops command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With kops, you can change the instance type, resize instance groups (masters
    and nodes), rolling-update, and upgrade cluster. Kops also supports configuration
    for specific AWS features, such as enable AWS detailed monitoring for the instances
    in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For performing this recipe, you''ll need a Kubernetes cluster deployed by kops
    in AWS. You will need to follow the previous recipes in this chapter to launch
    a cluster. Here, we''ll use the same cluster we created in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the previous recipe, we've had the `KOPS_STATE_STORE` environment variable
    set as one of our S3 bucket names by the format `s3://<bucket_name>` to store
    the kops configuration and metadata.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The upcoming subsections cover some common operational examples that cluster
    administrators may run into.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying and resizing instance groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modifying instance groups may be cumbersome if you deploy all instances manually.
    You'll need to update instances one by one or relaunch them. By kops, we can easily
    perform the update without pain.
  prefs: []
  type: TYPE_NORMAL
- en: Updating nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the kops edit command, we can modify the instance type and the node count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we modify both minSize and maxSize from `2` to `3`. After
    the modification, we''ll need to run the kops update to see it take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Some updates will need a rolling-update cluster. In this example, kops has
    updated the configuration in the AWS auto scaling group. AWS will then launch
    a new instance to accommodate the change. The following is a screenshot from AWS
    Auto Scaling Group''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/544524b9-bc0f-422c-b4f7-3632b3e32a07.png)'
  prefs: []
  type: TYPE_IMG
- en: nodes_in_AWS_Auto_Scaling_Groups
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the configuration has been updated, and AWS is scaling a new
    instance. After few minutes, we can check cluster status via `kops validate` or
    `kubectl get nodes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Everything looks good!
  prefs: []
  type: TYPE_NORMAL
- en: Updating masters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating masters is the same as updating nodes. Note that masters in the same
    availability zone are in one instance group. This means that you can't add additional
    subnets into the master instance group. In the following example, we'll resize
    the master count from 1 to 2.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we only make the master count 1\. In the real world, the recommended
    way is to deploy masters to at least two availability zones and have three masters
    per zone (one kops instance group). You can achieve that via the `--master-count`
    and `--master-zones` parameters when launching the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Before applying the change, we can run the update cluster command without `--yes`
    in the dry run mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: After we verify the dry run message as expected, we can perform the update as
    follows. In this case, we'll have to perform a rolling update.
  prefs: []
  type: TYPE_NORMAL
- en: How to know whether a rolling update is needed
  prefs: []
  type: TYPE_NORMAL
- en: 'If we didn''t run a kops rolling update in the preceding example, kops will
    show a validation error when running the kops validate cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: VALIDATION ERRORS
  prefs: []
  type: TYPE_NORMAL
- en: KIND                NAME                          MESSAGE
  prefs: []
  type: TYPE_NORMAL
- en: InstanceGroup     `master-us-east-1a` InstanceGroup `master-us-east-1a` did
    not have enough nodes 1 vs 2
  prefs: []
  type: TYPE_NORMAL
- en: Remember to replace k8s-cookbook.net with your cluster name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Just like modifying nodes, we can use both `kubectl get nodes` and `kops validate
    cluster` to check whether the new master has joined the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For demonstrating how we upgrade the Kubernetes version, we''ll first launch
    the cluster with the 1.8.7 version. For detailed instructions of parameters, refer
    to the previous recipes in this chapter. Input the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After few minutes, we can see that the master and the nodes are up with version
    1.8.7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we''ll walk through how to upgrade Kubernetes cluster
    from 1.8.7 to 1.9.3 using kops. Firstly, run the kops upgrade cluster command.
    Kops will show us the latest version that we could upgrade to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It indicates that the configuration has been updated, and that we''ll need
    to update the cluster now. We run command with the dryrun mode to check what will
    be modified first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We could see all of the components moved from v1.8.7 to v1.9.3 in Auto Scaling
    Launch Configuration. After verifying that everything is good, we can run the
    same command with the `--yes` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we need to run the rolling update for the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: All the nodes have been upgraded to 1.9.3! When performing the rolling update,
    kops drains one instance first then cordons the node. The auto-scaling group will
    bring up another node with the updated user data, which contains the Kubernetes
    component images with the updates. For avoiding downtime, you should have multiple
    masters and nodes as the basic deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a rolling update is completed, we can check the cluster version via `kubectl
    get nodes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: All the nodes have been upgraded to 1.9.3!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In kops, there are lots of useful addons, such as autoscaling nodes ([https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler](https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler))
     and mapping the service to the record in Route53 ([https://github.com/kubernetes/kops/tree/master/addons/route53-mapper](https://github.com/kubernetes/kops/tree/master/addons/route53-mapper)).
    Refer to the add-ons page to find out more!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Deployment API* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building multiple masters* in [Chapter 4](1a0d884d-59d3-4f67-adee-2d2e37030132.xhtml),
    *Building High-Availability Clusters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Managing Kubernetes cluster on GKE* in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml),
    *Building Kubernetes on GCP*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
