- en: Operating Systems, Platforms, and Cloud and Local Providers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统、平台以及云服务和本地服务提供商
- en: The first half of this chapter will cover how open standards encourage a diverse
    ecosystem of container implementations. We'll look at the **Open Container Initiative**
    (**OCI**) and its mission to provide an open container specification as well.
    The second half of this chapter will cover the various operating systems available
    for running containerized workloads, such as CoreOS. We'll also look at its advantages
    as a host OS, including performance and support for various container implementations.
    Additionally, we'll take a brief look at the Tectonic Enterprise offering from
    CoreOS. We'll look at the various hosted platforms offered by the major **cloud
    service providers** (**CSPs**) and see how they stack up.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前半部分将讲解开放标准如何鼓励多样化的容器实现生态系统。我们将讨论**开放容器倡议**（**OCI**）及其提供开放容器规范的使命。本章的后半部分将讨论可用于运行容器化工作负载的各种操作系统，如
    CoreOS。我们还将探讨作为宿主操作系统的优势，包括性能和对各种容器实现的支持。此外，我们还将简要介绍 CoreOS 的 Tectonic 企业版。我们将讨论主要**云服务提供商**（**CSPs**）提供的各种托管平台，并比较它们的优劣。
- en: 'This chapter will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: Why do standards matter?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么标准如此重要？
- en: The OCI and the **Cloud Native Computing Foundation** (**CNCF**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCI 和 **云原生计算基金会**（**CNCF**）
- en: Container specifications versus implementations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器规范与实现
- en: Various container-oriented operating systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种面向容器的操作系统
- en: Tectonic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tectonic
- en: The CSP platforms available that can run Kubernetes workloads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可运行 Kubernetes 工作负载的 CSP 平台
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: You'll need to have your Google Cloud Platform account enabled and logged in,
    or you can use a local Minikube instance of Kubernetes. You can also use Play
    with Kubernetes online at [https://labs.play-with-k8s.com/](https://labs.play-with-k8s.com/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要启用并登录你的 Google Cloud Platform 账户，或者可以使用本地的 Minikube 实例来运行 Kubernetes。你还可以在
    [https://labs.play-with-k8s.com/](https://labs.play-with-k8s.com/) 上使用在线的 Play
    with Kubernetes。
- en: You'll also need GitHub credentials, which we'll go over setting up later in
    the chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要 GitHub 凭证，我们将在本章后面介绍如何设置。
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter09](https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 GitHub 仓库可以在 [https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter09](https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter09)
    找到。
- en: The importance of standards
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准的重要性
- en: Over the past two years, containerization technology has had a tremendous growth
    in popularity. While Docker has been at the center of this ecosystem, there is
    an increasing number of players in the container space. There are already a number
    of alternatives to the containerization and Docker implementation itself (rkt,
    Garden, and so on). In addition, there is a rich ecosystem of third-party tools
    that enhance and complement your container infrastructure. While Kubernetes is
    designed to manage the state of a container and the orchestration, scheduling,
    and networking side of this ecosystem, the bottom line is that all of these tools
    form the basis to build cloud-native applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去两年中，容器化技术在流行度上经历了巨大的增长。尽管 Docker 一直处于这一生态系统的核心，但容器领域的参与者越来越多。已经有很多替代容器化技术和
    Docker 实现的选项（如 rkt、Garden 等）。此外，还有丰富的第三方工具生态系统，它们增强并补充了你的容器基础设施。尽管 Kubernetes
    设计用于管理容器的状态及其编排、调度和网络方面的内容，但关键是，这些工具构成了构建云原生应用的基础。
- en: As we mentioned at the very beginning of this book, one of the most attractive
    things about containers is their ability to package our application for deployment
    across various environment tiers (that is, development, testing, and production)
    and various infrastructure providers (GCP, AWS, on-premises, and so on).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书一开始提到的，容器最吸引人的地方之一就是它们能够将我们的应用程序打包，以便在不同的环境层（即开发、测试和生产）以及不同的基础设施提供商（如
    GCP、AWS、本地等）之间进行部署。
- en: To truly support this type of deployment agility, we need not only the containers
    themselves to have a common platform, but also the underlying specifications to
    follow a common set of ground rules. This will allow for implementations that
    are both flexible and highly specialized. For example, some workloads may need
    to be run on a highly secure implementation. To provide this, the implementation
    will have to make more intentional decisions about some aspects of the implementation.
    In either case, we will have more agility and freedom if our containers are built
    on some common structures that all implementations agree on and support.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正支持这种部署灵活性，我们不仅需要容器本身拥有一个共同的平台，还需要底层的规范遵循一套共同的基本规则。这将允许既灵活又高度专业化的实现。例如，一些工作负载可能需要在一个高度安全的实现上运行。为了提供这一点，实施过程必须对一些方面做出更有意图的决策。无论哪种情况，如果我们的容器建立在所有实现都同意并支持的共同结构上，我们将获得更多的灵活性和自由。
- en: In the following pages, we'll explore the building blocks of the many competing
    standards in the Kubernetes ecosystem. We'll explain how they're changing and
    developing and what part they may play in the future.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，我们将探讨Kubernetes生态系统中许多竞争标准的构建模块。我们将解释它们是如何变化和发展的，以及它们在未来可能扮演的角色。
- en: One of the examples that we'll explore more deeply in this third edition is
    the CRI-O project, which came to be after the creation of the OCI Charter. Let's
    make sure we understand the importance of that mission.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第三版中更深入地探讨的一个例子是CRI-O项目，它是在OCI宪章创建之后诞生的。让我们确保理解这个使命的重要性。
- en: The OCI Charter
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OCI宪章
- en: The mission of the OCI Charter is to ensure that the open source community has
    a stable platform from which industry participants can contribute the portable,
    open, and vendor-neutral runtimes required to build container-powered applications.
    The Linux Foundation is the holder of the charter, which is a sister organization
    to the CNCF. We'll look more into the implications of a foundation in [Chapter
    11](d7bfc2e3-8a59-4df7-94ee-67828421848d.xhtml), *Kubernetes SIGs, Incubation
    Projects, and the CNCF*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: OCI宪章的使命是确保开源社区拥有一个稳定的平台，从而使行业参与者能够贡献出构建容器驱动应用所需的可移植、开放且供应商中立的运行时。Linux基金会是宪章的持有者，它是CNCF的姊妹组织。我们将在[第11章](d7bfc2e3-8a59-4df7-94ee-67828421848d.xhtml)，*Kubernetes
    SIGs、孵化项目和CNCF* 中更深入地探讨基础设施的影响。
- en: If you'd like to read more about these foundations, you can check out their
    websites here: [https://www.linuxfoundation.org/](https://www.linuxfoundation.org/)
    and **[https://www.cncf.io/](https://www.cncf.io/).**
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于这些基础的内容，可以访问他们的网站：[https://www.linuxfoundation.org/](https://www.linuxfoundation.org/)
    和 **[https://www.cncf.io/](https://www.cncf.io/)。**
- en: 'While the OCI Charter tries to standardize the building blocks of the ecosystem,
    it does not attempt to define the system at the macroscopic level, nor does it
    market a particular pathway or solution. There''s also a process defined that
    helps technology mature in a responsible way through these foundations, to ensure
    that the best possible technology is reaching the end user. These are defined
    as the following stages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OCI宪章试图标准化生态系统的构建模块，但它并不试图在宏观层面上定义系统，也不推广某种特定的路径或解决方案。它还定义了一个过程，通过这些基础设施帮助技术以负责任的方式成熟，以确保最好的技术能够到达最终用户。这些被定义为以下几个阶段：
- en: Sandbox
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沙盒
- en: Incubating
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 孵化
- en: Graduated
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毕业
- en: 'For the specifics of this chapter as regards the OCI, let''s look at what else
    they''re trying to accomplish. Firstly, we''re attempting to create a format specification.
    This specification will call out a few important dimensions in order to create
    a consensus:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就本章涉及OCI的具体内容来说，让我们看看他们还在努力完成什么。首先，我们正在尝试创建一个格式规范。这个规范将指出几个重要维度，以便达成共识：
- en: '**Provide a format**: In order to ensure a specification that can be used across
    multiple runtimes, you need a standard container format and runtime specification.
    The container format is represented by the root filesystem that sits on the disk,
    with the necessary additional configuration that allows a given container to be
    run on the system. There is a push to categorize the standardization into the
    following layers: base, optional, and out of scope.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供一种格式**：为了确保能够跨多个运行时使用的规范，你需要一个标准的容器格式和运行时规范。容器格式由磁盘上的根文件系统表示，并且需要额外的配置，使得给定的容器能够在系统上运行。推动将标准化分类为以下几个层级：基础、可选和超出范围。'
- en: '**Provide a runtime**: This is more straightforward, as it''s designed to provide
    an executable that can directly run a container via consumption of the aforementioned
    container format and runtime specification.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供一个运行时**：这个更直接，因为它旨在提供一个可执行文件，可以通过消费上述容器格式和运行时规范直接运行容器。'
- en: 'The Charter also incentivizes a number of projects, the first two of which
    are the runc projects, and the third of which involves the definition of its own
    specifications in the OCI Specification project. New projects are added by members
    through a review process that needs two-thirds approval from the current **Technical
    Oversight Board** (**TOB**). If we look deeper into the principles that govern
    the OCI, the website names six guiding principles:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 《宪章》还激励了许多项目，其中前两个是runc项目，第三个涉及在OCI规范项目中定义自己的规范。新项目由成员通过审查流程添加，该流程需要当前**技术监督委员会**（**TOB**）的三分之二批准。如果我们更深入地了解OCI的治理原则，网站列出了六项指导原则：
- en: Technology leadership
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术领导力
- en: Influence through contribution
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过贡献产生影响
- en: Limited scope, limited politics
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限的范围，有限的政治
- en: Minimalist structure
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极简结构
- en: Representative leadership
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表性领导力
- en: Adherence to anti-trust regulations
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵守反垄断法规
- en: These items are a blend of philosophical and logical frameworks that encourage
    competition, collaboration, meritocracy, and the continuous improvement cycles
    that many Agile and DevOps practitioners have long utilized.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条目融合了哲学和逻辑框架，鼓励竞争、合作、精英主义以及许多敏捷和DevOps从业者长期以来所利用的持续改进周期。
- en: Let's dig more into the initiative itself now.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解一下这个倡议本身。
- en: The OCI
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OCI
- en: One of the first initiatives to gain widespread industry engagement is the OCI.
    Among the 36 industry collaborators are Docker, Red Hat, VMware, IBM, Google,
    and AWS, as listed on the OCI website at [https://www.opencontainers.org/](https://www.opencontainers.org/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首批获得广泛行业参与的倡议之一是OCI。在36个行业合作伙伴中，有Docker、Red Hat、VMware、IBM、Google和AWS，如OCI网站所列，网址为[https://www.opencontainers.org/](https://www.opencontainers.org/)。
- en: 'The purpose of the OCI is to split implementations, such as Docker and rkt,
    from a standard specification for the format and runtime of containerized workloads.
    According to their own terms, the goal of the OCI specifications has three basic tenets
    (you can refer to more details about this in the *Further reading* section at
    the end of the chapter):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: OCI的目的是将实现方案，如Docker和rkt，与容器化工作负载的格式和运行时标准分离。根据他们自己的定义，OCI规范的目标有三个基本原则（你可以在章节末尾的*进一步阅读*部分找到更多细节）：
- en: Creating a formal specification for container image formats and runtime, which
    will allow a compliant container to be portable across all major, compliant operating
    systems and platforms without artificial technical barriers.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个容器镜像格式和运行时的正式规范，允许符合规范的容器在所有主要的、合规的操作系统和平台上可移植，不受人为技术障碍的限制。
- en: Accepting, maintaining, and advancing the projects associated with these standards.
    It will look to agree on a standard set of container actions (start, exec, pause,
    and so on), as well as a runtime environment associated with a container runtime.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受、维护和推动与这些标准相关的项目。它将力求就容器的标准操作集（启动、执行、暂停等）以及与容器运行时相关的运行时环境达成一致。
- en: Harmonizing the previously referenced standard with other proposed standards,
    including the appc specification.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将先前提到的标准与其他提议的标准（包括appc规范）进行协调。
- en: By following these principals, the OCI hopes to bolster a collaborative and
    inclusive ecosystem that provides a rich and evolving toolset to meet the needs
    of today's complex application workloads, be they cloud-native or traditional.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些原则，OCI希望加强一个协作和包容的生态系统，提供一个丰富且不断发展的工具集，以满足当今复杂应用工作负载的需求，无论是云原生还是传统的。
- en: 'There are additionally some guiding principles for the development of standards
    in this space. These principles were integrated from the founding beliefs of the
    folks who created appc, and are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在此领域的标准发展中，还有一些指导原则。这些原则源自创建appc的人的创始信念，具体如下：
- en: '**Security**: Isolate containers via pluggable interfaces using secure cryptographic
    principles, and a chain of custody for both images and application code.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：通过使用安全的加密原理和图像及应用代码的监控链条，通过可插拔接口隔离容器。'
- en: '**Portability**: Ensure that containers continue to be portable across a wide
    variety software, clouds, and hardware.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：确保容器能够在各种软件、云和硬件之间保持可移植性。'
- en: '**Decentralized**: Container images should be straightforward and should take
    advantage of federation and namespacing.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去中心化**：容器镜像应简洁明了，并应利用联邦和命名空间的优势。'
- en: '**Open**: The runtime and formats should be community-built, with multiple
    interchangeable parts.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放**：运行时和格式应由社区构建，并具有多个可互换的部分。'
- en: '**Backward compatible**: Given the popularity of Docker and containers with
    nearly 9 billion downloads, backward compatibility should be given high priority.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向后兼容**：鉴于Docker和容器的受欢迎程度（近90亿次下载），向后兼容性应给予高度优先考虑。'
- en: '**Composable**: Tools for the operation of containers should be well integrated,
    but modular.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合**：容器操作工具应良好集成，但保持模块化。'
- en: '**Code**: Consensus should be built from running, working code that follows
    principles of minimalism that adhere to domain-driven design. It should be stable
    and extensible.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：共识应基于运行中的、可工作的代码，并遵循最简原则，符合领域驱动设计。它应是稳定和可扩展的。'
- en: Container Runtime Interface
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行时接口
- en: Let's look at one of the newer and Kubernetes-specific OCI-based initiatives,
    CRI-O. CRI-O is currently part of the Kubernetes incubator, but it may move out
    to its own project as it matures. One of the compelling parts of the CRI-O design
    is that it never breaks Kubernetes. This is different because other runtimes are
    designed to do many things, such as building images, managing security, orchestration,
    and inspecting images. CRI-O is only designed to help Kubernetes orchestrate and
    schedule containers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其中一个更新的、针对Kubernetes的OCI基础项目——CRI-O。CRI-O目前是Kubernetes孵化器的一部分，但随着其成熟，它可能会脱离并成为独立项目。CRI-O设计的一个引人注目的特点是，它从不破坏Kubernetes。这与其他运行时不同，因为其他运行时的设计目的是做许多事情，如构建镜像、管理安全性、编排和检查镜像。而CRI-O仅仅是为了帮助Kubernetes编排和调度容器。
- en: You can get the code for the CRI-O project and read the documentation at [https://github.com/kubernetes-incubator/cri-o/](https://github.com/kubernetes-incubator/cri-o).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过[https://github.com/kubernetes-incubator/cri-o/](https://github.com/kubernetes-incubator/cri-o)获取CRI-O项目的代码并阅读文档。
- en: 'To this end, CRI-O is developed congruently with the CRI itself, and aligns
    itself with upstream releases of the Kubernetes system. The following diagram
    shows how the CRI-O works with the OCI:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，CRI-O与CRI本身一起开发，并与Kubernetes系统的上游版本保持一致。下图展示了CRI-O如何与OCI配合工作：
- en: '![](img/e46506c8-1ed5-4515-bda4-f1d4b4f43506.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e46506c8-1ed5-4515-bda4-f1d4b4f43506.png)'
- en: 'In order to achieve this workflow, the following happens:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一工作流，发生了以下情况：
- en: The operator decides to start a pod, which causes Kubernetes to use the `kubelet`
    to start a pod. That `kubelet` talks through the CRI to the CRI-O daemon.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作员决定启动一个Pod，这会导致Kubernetes使用`kubelet`来启动Pod。然后，该`kubelet`通过CRI与CRI-O守护进程进行通信。
- en: CRI-O then uses several libraries, built with the OCI standard, to pull and
    unpack the given container image from a registry. From these operations, CRI-O
    generates a JSON blob that is used in the next step to run the container.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRI-O随后使用多个基于OCI标准的库，从注册表中拉取并解压给定的容器镜像。通过这些操作，CRI-O生成一个JSON数据块，供下一步运行容器使用。
- en: CRI-O kicks off an OCI-compatible runtime, which then runs the container process.
    This could be runc or the new Kata Container runtime (which has absorbed Intel's
    clear containers initiative).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRI-O启动一个兼容OCI的运行时，然后运行容器进程。这可能是runc，或者是新的Kata容器运行时（它已经吸收了Intel的清晰容器计划）。
- en: 'You''ll notice here that the CRI-O is acting as an interleaving layer between
    the libraries and runtimes, such that it''s using standard formats to accomplish
    most its goals. This ensures the goal is making Kubernetes work at all times.
    Here''s a diagram showing the system of the flow that was described in this section:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，CRI-O在库和运行时之间充当了一个交错层，它通过使用标准格式来完成大多数目标。这确保了目标是让Kubernetes始终有效运行。以下是展示本节描述的流程系统的图示：
- en: '![](img/dc16cc9a-9ac5-4faa-bc78-94cc4ca29d37.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc16cc9a-9ac5-4faa-bc78-94cc4ca29d37.png)'
- en: For networking, CRI-O would leverage the **Container Networking Interface**
    (**CNI**), which is similar to the CRI, but deals with the networking stack. You
    should begin to see a pattern emerge here.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络，CRI-O将利用**容器网络接口**（**CNI**），这与CRI类似，但处理的是网络堆栈。你应该开始看到一些模式的出现。
- en: CRI-O is an implementation that helps to implement the OCI specification. This
    allows users to take for granted the container runtime being used as an implementation
    detail, and to focus instead on how the application is interacting with the objects
    and abstractions of the Kubernetes system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CRI-O是一个实现，帮助实现OCI规范。这使得用户可以理所当然地将容器运行时作为实现细节，而专注于应用程序如何与Kubernetes系统中的对象和抽象进行交互。
- en: Trying out CRI-O
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用CRI-O
- en: 'Let''s look at some installation methods so you can give CRI-O a try on your
    own. In order to get started, you''ll need a few things, including runc or another
    OCI compatible runtime, as well as socat, iproute, and iptables. There''s a few
    options for running CRI-O in Kubernetes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些安装方法，帮助你自己尝试CRI-O。为了开始，你需要一些工具，包括runc或其他OCI兼容的运行时，以及socat、iproute和iptables。你可以选择几种方式在Kubernetes中运行CRI-O：
- en: In a full-scale cluster, using `kube-adm` and `systemd` to leverage the CRI-O
    socket with `--container-runtime-endpoint /var/run/crio/crio.sock`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全规模集群中，使用`kube-adm`和`systemd`通过`--container-runtime-endpoint /var/run/crio/crio.sock`来利用CRI-O套接字。
- en: With Minikube, by starting it up with specific command-line options
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Minikube，通过特定的命令行选项启动它。
- en: On atomic with atomic install `--system-package=no -n cri-o --storage ostree
    registry.centos.org/projectatomic/cri-o:latest`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Atomic系统上使用`--system-package=no -n cri-o --storage ostree registry.centos.org/projectatomic/cri-o:latest`安装。
- en: If you'd like to build CRI-O from source, you can run the following on your
    laptop. You need some dependencies installed in order to make this build phase
    work. First, run the following commands to get your dependencies installed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从源代码构建CRI-O，你可以在笔记本电脑上运行以下命令。你需要安装一些依赖项，才能使这个构建阶段正常工作。首先，运行以下命令安装你的依赖项。
- en: 'The following commands are for Fedora, CentOS, and RHEL distributions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令适用于Fedora、CentOS和RHEL发行版：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These commands are to be used for Debian, Ubuntu, and related distributions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令适用于Debian、Ubuntu及相关发行版：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Secondly, you''ll need to grab the source code like so:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要像下面这样获取源代码：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you have the code, go ahead and build it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了代码，就可以继续构建它：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can use additional build flags to add thing such as `seccomp`, SELinux,
    and `apparmor` with this format: `make BUILDTAGS=''seccomp apparmor''`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用额外的构建标志添加如`seccomp`、SELinux和`apparmor`等内容，格式为：`make BUILDTAGS='seccomp
    apparmor'`。
- en: You can run Kubernetes locally with the `local-up-cluster.sh` script in Kubernetes.
    I'll also show you how to run this on Minikube.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Kubernetes中的`local-up-cluster.sh`脚本在本地运行Kubernetes。我还会向你展示如何在Minikube上运行它。
- en: 'First, clone the Kubernetes repository:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，克隆Kubernetes仓库：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, you''ll need to start the CRI-O daemon and run the following command
    to get spin up your cluster using CRI-O:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要启动CRI-O守护进程，并运行以下命令，使用CRI-O启动集群：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you have a running cluster, you can also use the instructions, available
    at the following URL, to switch the runtime from Docker to CRI-O: [https://github.com/kubernetes-incubator/cri-o/blob/master/kubernetes.md/](https://github.com/kubernetes-incubator/cri-o/blob/master/kubernetes.md).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个正在运行的集群，你也可以使用以下网址的说明，将运行时从Docker切换到CRI-O：[https://github.com/kubernetes-incubator/cri-o/blob/master/kubernetes.md/](https://github.com/kubernetes-incubator/cri-o/blob/master/kubernetes.md)。
- en: 'Let''s also check how to use CRI-O on Minikube, which is one of the easiest
    ways to get experimenting:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还检查一下如何在Minikube上使用CRI-O，这是最简单的实验方式之一：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, we can use our GCP platform to spin up a cluster with CRI-O and start
    experimenting:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用GCP平台创建一个CRI-O集群并开始实验：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's use these machines to run through a quick tutorial. SSH into the machine
    using `gcloud compute ssh cri-o`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些机器快速进行一个教程。使用`gcloud compute ssh cri-o`通过SSH连接到机器。
- en: 'Once you''re on the server, we''ll need to install the `cri-o`, `crioctl`,
    `cni`, and `runc` programs. Grab the `runc` binary first:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入服务器，我们需要安装`cri-o`、`crioctl`、`cni`和`runc`程序。首先获取`runc`二进制文件：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set it executable and move it to your path as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 设置可执行权限并将其移动到你的路径，如下所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see it''s working by checking the version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查版本来验证它是否工作正常：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You'll need to install the CRI-O binary from source, as it's not currently shipping
    any binaries.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从源代码安装CRI-O二进制文件，因为目前没有发布任何二进制文件。
- en: 'First, download the latest binary release and install Go:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载最新的二进制发布版本并安装Go：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should feel familiar, as you would install Go the same way for any other
    project. Check your version:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很熟悉，因为你安装Go的方式和任何其他项目相同。检查你的版本：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next up, get `crictl` using the following commands:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令获取`crictl`：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that''s downloaded, you''ll need to build CRI-O from source:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，你需要从源代码构建 CRI-O：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, get CRI-O and install it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取并安装 CRI-O：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After this is complete, you''ll need to create configuration files with `sudo
    make install.config`. You need to ensure that you''re using a valid registry option
    in the `/etc/crio/cirio.conf` file. An example of this looks like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你需要通过 `sudo make install.config` 创建配置文件。你需要确保在 `/etc/crio/cirio.conf` 文件中使用了有效的注册表选项。其示例如下：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, we''re ready to start the CRI-O system daemon, which we can
    do by leveraging `systemctl`. Let''s create a `crio.service`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经准备好启动 CRI-O 系统守护进程，我们可以通过使用 `systemctl` 来实现。让我们创建一个 `crio.service`：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following text:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下文本：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once that''s complete, we can reload `systemctl` and enable CRI-O:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以重新加载 `systemctl` 并启用 CRI-O：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After this is complete, we can validate whether or not we have a working install
    of CRI-O by checking the version of the endpoint as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以通过检查端点的版本来验证是否成功安装了 CRI-O，如下所示：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next up, we''ll need to grab the latest version of the CNI plugin, so we can
    build and use it from source. Let''s use Go to grab our source code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取最新版本的 CNI 插件，以便我们可以从源代码构建并使用它。我们将使用 Go 来获取我们的源代码：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, install the CNI plugins into your cluster:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装 CNI 插件到你的集群中：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can configure the CNI so that CRI-O can use it.  First, make a directory
    to store the configuration, then we''ll set two configuration files as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置 CNI，使得 CRI-O 可以使用它。首先，创建一个目录来存储配置文件，然后我们将设置以下两个配置文件：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, you''ll want to create and compose `10-mynet.conf`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建并配置 `10-mynet.conf`：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then, compose the `loopback` interface as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按如下方式构建 `loopback` 接口：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next up, we''ll need some special containers from Project Atomic to get this
    working. `skopeo` is a command-line utility that is OCI-compliant and can perform
    various operations on container images and image repositories. Install the containers
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将需要一些来自 Project Atomic 的特殊容器来使其工作。`skopeo` 是一个符合 OCI 标准的命令行工具，可以对容器镜像和镜像仓库执行各种操作。按如下方式安装容器：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Restart CRI-O to pick up the CNI configuration with `sudo systemctl restart
    crio`. Great! Now that we have these components installed, let's build something!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sudo systemctl restart crio` 重启 CRI-O 以加载 CNI 配置。太棒了！现在我们已经安装了这些组件，开始构建一些东西吧！
- en: First off, we'll create a sandbox using a template policy from the Kubernetes
    incubator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用来自 Kubernetes 孵化器的模板策略创建一个沙箱。
- en: This template is NOT production ready!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板不是生产就绪的！
- en: 'Change first to the CRI-O source tree with the template, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先切换到带有模板的 CRI-O 源树，如下所示：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, you''ll need to create and capture the pod ID:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建并捕获 pod 的 ID：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use `critcl` to get the status of the pod as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `critcl` 获取 pod 状态，如下所示：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll use the `crictl` tool again to pull a container image for a Redis server:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 `crictl` 工具拉取 Redis 服务器的容器镜像：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we''ll start and check the status of the Redis container as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将启动并检查 Redis 容器的状态，如下所示：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, you should be able to `telnet` into the Redis container to test
    its functionality:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该能够 `telnet` 进入 Redis 容器以测试其功能：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Nicely done—you''ve now created a pod and container manually, using some of
    the core abstractions of the Kubernetes system! You can stop the container and
    shut down the pod with the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 干得漂亮—你已经手动创建了一个 pod 和容器，使用了 Kubernetes 系统的一些核心抽象！你可以使用以下命令停止容器并关闭 pod：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: More on container runtimes
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于容器运行时的信息
- en: 'There''s a number of container- and VM-based options for OCI-compliant implementations.
    We know of runc, which is the standard reference implementation of the OCI runtime.
    This is what the container uses. There''s also the following available:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多基于容器和虚拟机的选项适用于符合 OCI 标准的实现。我们知道 runc，这是 OCI 运行时的标准参考实现，容器就使用这个。还有以下选项可用：
- en: '`projectatomic/bwrap-oci` ([https://github.com/projectatomic/bwrap-oci](https://github.com/projectatomic/bwrap-oci)):
    Converts the OCI spec file to a command line for `projectatomic/bubblewrap` ([https://github.com/projectatomic/bubblewrap](https://github.com/projectatomic/bubblewrap))'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projectatomic/bwrap-oci` ([https://github.com/projectatomic/bwrap-oci](https://github.com/projectatomic/bwrap-oci)):
    将 OCI 规范文件转换为 `projectatomic/bubblewrap` ([https://github.com/projectatomic/bubblewrap](https://github.com/projectatomic/bubblewrap))
    的命令行'
- en: '`giuseppe/crun` ([https://github.com/giuseppe/crun](https://github.com/giuseppe/crun)):
    Runtime implementation in C'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`giuseppe/crun` ([https://github.com/giuseppe/crun](https://github.com/giuseppe/crun))：C语言实现的运行时'
- en: 'There are also VM-based implementations that take a different path towards
    security:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有基于虚拟机的实现，它们采取了不同的安全路径：
- en: '`hyperhq/runv` ([https://github.com/hyperhq/runv](https://github.com/hyperhq/runv))—hypervisor-based
    runtime for OCI'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hyperhq/runv` ([https://github.com/hyperhq/runv](https://github.com/hyperhq/runv))—基于虚拟机监控程序的OCI运行时'
- en: '`clearcontainers/runtime` ([https://github.com/clearcontainers/runtime](https://github.com/clearcontainers/runtime))—hypervisor-based
    OCI runtime utilizing `containers/virtcontainers` ([https://github.com/containers/virtcontainers](https://github.com/containers/virtcontainers))
    by Intel'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearcontainers/runtime` ([https://github.com/clearcontainers/runtime](https://github.com/clearcontainers/runtime))—基于虚拟机监控程序的OCI运行时，利用Intel的`containers/virtcontainers` ([https://github.com/containers/virtcontainers](https://github.com/containers/virtcontainers))'
- en: '`google/gvisor` ([https://github.com/google/gvisor](https://github.com/google/gvisor))—gVisor
    is a user-space kernel, which contains runsc to run sandboxed containers'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google/gvisor` ([https://github.com/google/gvisor](https://github.com/google/gvisor))—gVisor是一个用户空间内核，包含runsc来运行沙箱化的容器'
- en: '`kata-containers/runtime` ([https://github.com/kata-containers/runtime](https://github.com/kata-containers/runtime))—hypervisor-based
    OCI runtime combining technology from `clearcontainers/runtime` ([https://github.com/clearcontainers/runtime](https://github.com/clearcontainers/runtime))
    and `hyperhq/runv` ([https://github.com/hyperhq/runv](https://github.com/hyperhq/runv))'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kata-containers/runtime` ([https://github.com/kata-containers/runtime](https://github.com/kata-containers/runtime))—基于虚拟机监控程序的OCI运行时，结合了`clearcontainers/runtime`
    ([https://github.com/clearcontainers/runtime](https://github.com/clearcontainers/runtime))
    和 `hyperhq/runv` ([https://github.com/hyperhq/runv](https://github.com/hyperhq/runv))的技术'
- en: The most interesting project of these is the last in the list, Kata containers,
    which combines clear container and runV into a cohesive package. These foundational
    pieces are already in production use at scale in the enterprises, and Kata is
    looking to provide a secure, lightweight VM for containerized environments. By
    utilizing runV, Kata containers can run inside of any KVM-compatible VM, such
    as Xen, KVM, and vSphere, while still remaining compatible with CRI-O, which is
    important! Kata hopes to offer the speed of a container with the security surface
    of a VM.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目中最有趣的是列表中的最后一个——Kata容器，它将clear container和runV结合成一个统一的包。这些基础性组件已经在企业中大规模投入生产使用，而Kata旨在为容器化环境提供一个安全、轻量的虚拟机。通过利用runV，Kata容器可以在任何KVM兼容的虚拟机中运行，如Xen、KVM和vSphere，同时仍与CRI-O保持兼容，这一点非常重要！Kata希望能提供容器的速度和虚拟机的安全性。
- en: 'Here''s a diagram from Kata''s site, explaining the architecture in visual
    detail:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Kata网站上的一个图表，详细解释了架构的视觉细节：
- en: '![](img/a0daf1d8-69b9-4a3b-b027-efa0db055a5c.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0daf1d8-69b9-4a3b-b027-efa0db055a5c.png)'
- en: CNCF
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CNCF
- en: A second initiative that also has widespread industry acceptance is the CNCF.
    While still focused on containerized workloads, the CNCF operates a bit higher
    up the stack, at the application design level.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在业内广泛接受的倡议是CNCF。尽管它仍然专注于容器化工作负载，但CNCF的运作层级略高，处于应用设计层面。
- en: Its purpose is to provide a standard set of tools and technologies to build,
    operate, and orchestrate cloud-native application stacks. Cloud has given us access
    to a variety of new technologies and practices that can improve and evolve our
    classic software designs. The CNCF is also particularly focused on the new paradigm
    of microservice-oriented development.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它的目的是提供一套标准的工具和技术，用于构建、操作和编排云原生应用栈。云计算为我们提供了多种新技术和实践，这些可以改进并演化我们的经典软件设计。CNCF也特别关注微服务导向开发的新范式。
- en: As a founding participant in the CNCF, Google has donated the Kubernetes open
    source project. The goal will be to increase interoperability in the ecosystem
    and support better integration with projects. The CNCF already hosts a variety
    of projects on orchestration, logging, monitoring, tracing, and application resilience.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作为CNCF的创始参与者，Google捐赠了Kubernetes开源项目。其目标是提高生态系统中的互操作性，并支持与其他项目的更好集成。CNCF已经托管了各种关于编排、日志、监控、追踪和应用程序韧性等项目。
- en: For more information on CNCF, refer to [https://cncf.io/](https://cncf.io/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于CNCF的信息，请参阅 [https://cncf.io/](https://cncf.io/)。
- en: We'll talk more about the CNCF, **Special Interest Groups** (**SIGs**), and
    the landscape therein in the following chapters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更多地讨论CNCF、**特殊兴趣小组**（**SIGs**）及其中的相关领域。
- en: For now, here's a landscape and trail map to consider: [https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/](https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请考虑这份景观和路径图：[https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/](https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/)。
- en: Standard container specification
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准容器规范
- en: 'A core result of the OCI effort is the creation and development of the overarching
    container specification. The specification has five core principles that all containers
    should follow, which I will briefly paraphrase:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 努力的核心成果之一是创建和开发全面的容器规范。该规范包括五个核心原则，所有容器都应遵循，我将简要解释一下：
- en: The container must have *standard operations* to create, start, and stop containers
    across all implementations.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器必须具有创建、启动和停止容器的*标准操作*，适用于所有实施。
- en: The container must be *content-agnostic*, which means that type of application
    inside the container does not alter the standard operations or publishing of the
    container itself.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器必须*与内容无关*，这意味着容器内部的应用类型不会改变容器本身的标准操作或发布。
- en: The container must be *infrastructure-agnostic* as well. Portability is paramount;
    therefore, the container must be able to operate just as easily in GCE as in your
    company's data center or on a developer's laptop.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器还必须*与基础设施无关*。可移植性至关重要；因此，容器必须能够在 GCE 中和在您公司的数据中心或开发者的笔记本上同样轻松地运行。
- en: A container must also be *designed for automation*, which allows us to automate
    across the build, as well as for updates and the deployment pipelines. While this
    rule is a bit vague, the container implementation should not require onerous manual
    steps for creation and release.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器还必须设计用于*自动化*，这使我们能够在构建过程中自动化，以及更新和部署管道。虽然这个规则有点模糊，但容器的实施不应要求繁琐的手动步骤来进行创建和发布。
- en: Finally, the implementation must support *industrial-grade delivery*. Once again,
    this means speaking to the build and deployment pipelines and requiring streamlined
    efficiency in the portability and transit of the containers between infrastructure
    and deployment tiers.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，实施必须支持*工业级交付*。这再次意味着与构建和部署管道相关，并要求在基础设施和部署层之间容器的可移植性和传输中实现高效率。
- en: The specification also defines core principles for container formats and runtimes.
    You can read more about the specifications on the open containers GitHub page
    at [https://github.com/opencontainers/specs](https://github.com/opencontainers/specs).
    [](https://github.com/opencontainers/specs)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 规范还为容器格式和运行时定义了核心原则。您可以在 open containers GitHub 页面上阅读更多规范信息，网址为[https://github.com/opencontainers/specs](https://github.com/opencontainers/specs)。
- en: While the core specification can be a bit abstract, the runc implementation
    is a concrete example of the OCI specs, in the form of a container runtime and
    image format. Again, you can read more of the technical details on GitHub at [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管核心规范可能有点抽象，但 runc 的实施是 OCI 规范的一个具体示例，是一个容器运行时和镜像格式。您可以在 GitHub 上阅读更多技术细节，网址为[https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)。
- en: The backing format and runtime for a variety of popular container tools is runc.
    It was donated to OCI by Docker and was created from the same plumbing work used
    in the Docker platform. Since its release, it has received a welcome uptake by
    numerous projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行容器工具的支持格式和运行时是 runc。它由 Docker 捐赠给 OCI，并基于 Docker 平台使用的相同基础设施工作创建而成。自发布以来，它得到了许多项目的欢迎。
- en: Even the popular open source PaaS Cloud Foundry announced that it will use runc
    in Garden. Garden provides the containerization plumbing for Diego, which acts
    as an orchestration layer similar to Kubernetes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是流行的开源 PaaS Cloud Foundry 也宣布将在 Garden 中使用 runc。Garden 为 Diego 提供了容器化的基础设施，作为类似于
    Kubernetes 的编排层。
- en: The rkt implementation was originally based on the appc specification. The appc
    specification was actually an earlier attempt by the folks at CoreOS to form a
    common specification around containerization. Now that CoreOS is participating
    in OCI, they are working to help merge the appc specification into OCI; this should
    result in a higher level of compatibility across the container ecosystem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: rkt 的实现最初基于 appc 规范。appc 规范实际上是 CoreOS 团队早期的一次尝试，旨在围绕容器化形成一个共同的规范。现在，CoreOS
    参与了 OCI，他们正在努力将 appc 规范并入 OCI；这应该会导致容器生态系统中的更高兼容性。
- en: CoreOS
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoreOS
- en: While the specifications provide us with a common ground, there are also some
    trends evolving around the choice of OS for our containers. There are several
    tailored-fit OSes that are being developed specifically to run container workloads.
    Although implementations vary, they all have similar characteristics. The focus
    is on a slim installation base, atomic OS updating, and signed applications for
    efficient and secure operations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然规格提供了我们一个共同的基础，但也有一些趋势在容器操作系统的选择上不断发展。现在有几种量身定制的操作系统正在开发，专门用于运行容器负载。尽管实现方式各异，但它们都有类似的特点。重点在于精简的安装基础、原子化的操作系统更新以及签名应用程序，以实现高效和安全的操作。
- en: One OS that is gaining popularity is CoreOS. CoreOS offers major benefits for
    both security and resource utilization. It provides resource utilization by completely removing
    package dependencies from the picture. Instead, CoreOS runs all applications and
    services in containers. By providing only a small set of services required to
    support running containers and bypassing the need for hypervisor usage, CoreOS
    lets us use a larger portion of the resource pool to run our containerized applications.
    This allows users to gain higher performance from their infrastructure and better
    container-to-node (server) usage ratios.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正在获得越来越多关注的操作系统是 CoreOS。CoreOS 在安全性和资源利用方面都提供了重要的优势。它通过完全去除包依赖关系来提供资源利用。相反，CoreOS
    将所有应用程序和服务运行在容器中。通过仅提供一小部分支持容器运行所需的服务，并绕过虚拟化程序的使用，CoreOS 使我们能够使用更多的资源池来运行容器化应用程序。这使得用户能够从基础设施中获得更高的性能，并实现更好的容器与节点（服务器）使用比例。
- en: Recently, CoreOS was purchased by Red Hat, which means that the current version
    of container Linux will evolve against Red Hat's container OS offering, Project
    Atomic. These two products will eventually turn into Red Hat CoreOS. If you consider
    the upstream community approach that Fedora takes to Red Hat Enterprise Linux,
    it seems likely that there will be something similar for Red Hat CoreOS.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，CoreOS 被红帽收购，这意味着当前版本的 Container Linux 将会与红帽的容器操作系统产品 Project Atomic 竞争。这两款产品最终将合并为
    Red Hat CoreOS。如果你考虑到 Fedora 对 Red Hat Enterprise Linux 采取的上游社区方法，那么可以推测 Red Hat
    CoreOS 也会有类似的方式。
- en: This also means that Red Hat will be integration Tectonic, which we'll explore
    later in the chapter, and the Quay, the enterprise container registry that CoreOS
    acquired. It's important to note that the rkt container standard will not be part
    of the acquisition, and will instead become a community supported project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着红帽将会集成 Tectonic（我们将在本章稍后讨论）以及 Quay，这是 CoreOS 收购的企业级容器注册中心。需要注意的是，rkt 容器标准不会成为收购的一部分，而是将成为一个社区支持的项目。
- en: 'If you''d like to see the relevant official announcements for the news discussed
    in the preceding section, you can check out these posts:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看前面部分讨论的相关官方公告，可以查看以下这些帖子：
- en: '**Press release**: [https://www.redhat.com/en/about/press-releases/red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership](https://www.redhat.com/en/about/press-releases/red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新闻稿**：[https://www.redhat.com/en/about/press-releases/red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership](https://www.redhat.com/en/about/press-releases/red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership)'
- en: '**Red Hat blog**:[https://www.redhat.com/en/blog/coreos-bet](https://www.redhat.com/en/blog/coreos-bet)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Red Hat 博客**：[https://www.redhat.com/en/blog/coreos-bet](https://www.redhat.com/en/blog/coreos-bet)'
- en: '**CoreOS blog**:[https://coreos.com/blog/coreos-agrees-to-join-red-hat/](https://coreos.com/blog/coreos-agrees-to-join-red-hat/)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CoreOS 博客**：[https://coreos.com/blog/coreos-agrees-to-join-red-hat/](https://coreos.com/blog/coreos-agrees-to-join-red-hat/)'
- en: 'Here''s a brief overview of the various container OSes. There are several other
    container-optimized OSes that have emerged recently:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于各种容器操作系统的简要概述。最近出现了几种其他针对容器优化的操作系统：
- en: '*Red Hat Enterprise Linux Atomic Host* focuses on security with SELinux enabled
    by default and atomic updates to the OS similar to what we saw with CoreOS. Refer
    to the following link: [https://access.redhat.com/articles/rhel-atomic-getting-started](https://access.redhat.com/articles/rhel-atomic-getting-started).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Red Hat Enterprise Linux Atomic Host* 专注于安全性，默认启用 SELinux，并采用与 CoreOS 相似的原子式操作系统更新。请参阅以下链接：[https://access.redhat.com/articles/rhel-atomic-getting-started](https://access.redhat.com/articles/rhel-atomic-getting-started)。'
- en: '*Ubuntu Snappy* also capitalizes on the efficiency and security gains of separating
    the OS components from the frameworks and applications. Using application images
    and verification signatures, we get an efficient Ubuntu-based OS for our container
    workloads at [http://www.ubuntu.com/cloud/tools/snappy](http://www.ubuntu.com/cloud/tools/snappy).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ubuntu Snappy* 同样利用了将操作系统组件与框架和应用程序分离所带来的效率和安全性提升。通过使用应用程序镜像和验证签名，我们获得了一个高效的基于
    Ubuntu 的操作系统，用于容器工作负载，[http://www.ubuntu.com/cloud/tools/snappy](http://www.ubuntu.com/cloud/tools/snappy)。'
- en: '*Ubuntu LXD* runs a container hypervisor and provides a path for migrating
    Linux-based VMs to containers with ease: [https://www.ubuntu.com/cloud/lxd](https://www.ubuntu.com/cloud/lxd).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ubuntu LXD* 运行容器虚拟机管理程序，并提供了一种将基于 Linux 的虚拟机轻松迁移到容器的路径：[https://www.ubuntu.com/cloud/lxd](https://www.ubuntu.com/cloud/lxd)。'
- en: '*VMware Photon* is another lightweight container OS that is optimized specifically
    for vSphere and the VMware platform. It runs Docker, rkt, and Garden and also
    has some images that you can run on the popular public cloud providers. Refer
    to the following link: [https://vmware.github.io/photon/](https://vmware.github.io/photon/).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VMware Photon* 是另一个轻量级容器操作系统，专门为 vSphere 和 VMware 平台进行了优化。它支持 Docker、rkt 和
    Garden，并且还提供了一些镜像，您可以在流行的公共云提供商上运行。请参阅以下链接：[https://vmware.github.io/photon/](https://vmware.github.io/photon/)。'
- en: 'Using the isolated nature of containers, we increase reliability and decrease
    the complexity of updates for each application. Now, applications can be updated
    along with supporting libraries whenever a new container release is ready, as
    shown in the following diagram:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 利用容器的隔离特性，我们提高了可靠性，并减少了每个应用程序更新的复杂性。现在，应用程序可以与支持库一起更新，每当新的容器版本发布时，正如下图所示：
- en: '![](img/c42dff26-cbee-4e99-adc6-41680ffc95df.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c42dff26-cbee-4e99-adc6-41680ffc95df.png)'
- en: CoreOS update procedure
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 更新过程
- en: 'Finally, CoreOS has some added advantages in the realm of security. For starters,
    the OS can be updated as one whole unit, instead of via individual packages (refer
    to the preceding diagram). This avoids many issues that arise from partial updates.
    To achieve this, CoreOS uses two partitions: one as the active OS partition, and
    a secondary one to receive a full update. Once updates are completed successfully,
    a reboot promotes the secondary partition. If anything goes wrong, the original
    partition is available as a fallback.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CoreOS 在安全性方面有一些额外的优势。首先，操作系统可以作为一个整体进行更新，而不是通过单独的软件包（参见前面的图示）。这样可以避免许多部分更新带来的问题。为了实现这一点，CoreOS
    使用了两个分区：一个作为活动的操作系统分区，另一个则用于接收完整的更新。更新成功完成后，重新启动时会提升第二个分区。如果出现问题，原始分区将作为备用。
- en: The system owners can also control when those updates are applied. This gives
    us the flexibility to prioritize critical updates, while working with real-world
    scheduling for the more common updates. In addition, the entire update is signed
    and transmitted via SSL for added security across the entire process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 系统所有者还可以控制这些更新的应用时间。这为我们提供了灵活性，可以优先处理关键更新，同时根据实际的调度安排处理更常见的更新。此外，整个更新过程都是签名并通过
    SSL 进行传输，以增强安全性。
- en: rkt
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rkt
- en: As mentioned previously, rkt will be continuing on as a community driven project.
    rkt is another implementation with a specific focus on security. The main advantage
    of rkt is that it runs the engine without a daemon as root, the way Docker does
    today. Initially, rkt also had an advantage in the establishment of trust for
    container images. However, recent updates to Docker have made great strides, especially
    the new content trust feature.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，rkt 将继续作为一个社区驱动的项目进行开发。rkt 是另一个专注于安全性的实现。rkt 的主要优势是它以不需要守护进程的方式运行引擎，而不像今天的
    Docker 那样以 root 用户身份运行守护进程。最初，rkt 在容器镜像的信任建立方面也具有优势。然而，Docker 最近的更新取得了很大进展，特别是新的内容信任功能。
- en: The bottom line is that rkt is still an implementation, with a focus on security,
    for running containers in production. rkt uses an image format named ACI, but
    it also supports Docker-based images. Over the past year, rkt has undergone significant
    updates and is now at version 1.24.0\. It has gained much momentum as a means
    to run Docker images securely in production.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结论是，rkt仍然是一种实现方案，专注于在生产环境中安全地运行容器。rkt使用一种名为ACI的镜像格式，但也支持基于Docker的镜像。在过去的一年里，rkt进行了重大更新，现在已经是版本1.24.0。它作为一种在生产环境中安全运行Docker镜像的方式，获得了很大的发展势头。
- en: 'Here''s a diagram showing how the rkt execution chain works:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示rkt执行链如何工作的示意图：
- en: '![](img/66dd571b-1ae2-4020-b788-29621df494f5.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66dd571b-1ae2-4020-b788-29621df494f5.png)'
- en: In addition, CoreOS is working with Intel® to integrate the new Intel® Virtualization
    Technology, which allows containers to run in higher levels of isolation. This
    hardware-enhanced security allows the containers to be run inside a **Kernel-based
    Virtual Machine** (**KVM**) process, providing isolation from the kernel in a
    similar fashion to what we see with hypervisors today.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CoreOS正在与Intel®合作，集成新的Intel®虚拟化技术，这使得容器能够在更高层次的隔离中运行。此硬件增强的安全性允许容器在**基于内核的虚拟机**（**KVM**）进程中运行，以类似我们今天在虚拟化监控程序中看到的方式提供与内核的隔离。
- en: etcd
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: etcd
- en: Another central piece in the CoreOS ecosystem worth mentioning is their open
    source etcd project. etcd is a distributed and consistent key-value store. A RESTful
    API is used to interface with etcd, so it's easy to integrate with your project.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS生态系统中另一个值得一提的核心部分是他们的开源etcd项目。etcd是一个分布式且一致的键值存储。它使用RESTful API与etcd进行接口，因此很容易与你的项目进行集成。
- en: If it sounds familiar, it's because we saw this process running in [Chapter
    1](446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml), *Introduction to Kubernetes*,
    in the section entitled *Services running on the master*. Kubernetes actually
    utilizes etcd to keep track of cluster configuration and current state. K8s uses
    it for its service discovery capabilities as well. For more details, refer to
    [https://github.com/coreos/etcd](https://github.com/coreos/etcd).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个听起来很熟悉，那是因为我们在[第1章](446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml)《Kubernetes简介》的*运行在主节点上的服务*这一节中看到了这个过程。Kubernetes实际上利用etcd来跟踪集群的配置和当前状态。K8s还利用它的服务发现功能。更多详细信息，请参阅[https://github.com/coreos/etcd](https://github.com/coreos/etcd)。
- en: Kubernetes with CoreOS
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有CoreOS的Kubernetes
- en: Now that we understand the benefits, let's take a look at a Kubernetes cluster
    using CoreOS. The documentation supports a number of platforms, but one of the
    easiest to spin up is AWS with the CoreOS CloudFormation and CLI scripts.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了这些好处，让我们来看看使用CoreOS的Kubernetes集群。文档支持多个平台，但最容易启动的是使用CoreOS CloudFormation和CLI脚本的AWS平台。
- en: If you are interested in running Kubernetes with CoreOS on other platforms,
    you can find more details in the CoreOS documentation at [https://coreos.com/kubernetes/docs/latest/](https://coreos.com/kubernetes/docs/latest/). [You
    can find the latest instructions for AWS at](https://coreos.com/kubernetes/docs/latest/)
    [https://coreos.com/kubernetes/docs/latest/kubernetes-on-aws.html](https://coreos.com/kubernetes/docs/latest/kubernetes-on-aws.html)[.](https://coreos.com/kubernetes/docs/latest/)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣在其他平台上运行带有CoreOS的Kubernetes，可以在CoreOS文档中找到更多细节，网址是[https://coreos.com/kubernetes/docs/latest/](https://coreos.com/kubernetes/docs/latest/)。
    [你可以在此找到最新的AWS操作指南](https://coreos.com/kubernetes/docs/latest/) [https://coreos.com/kubernetes/docs/latest/kubernetes-on-aws.html](https://coreos.com/kubernetes/docs/latest/kubernetes-on-aws.html)[。](https://coreos.com/kubernetes/docs/latest/)
- en: You can follow the instructions covered previously in this chapter to spin up
    Kubernetes on CoreOS. You'll need to create a key pair on AWS, and also specify
    a region, cluster name, cluster size, and DNS to proceed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照本章之前介绍的步骤，在CoreOS上启动Kubernetes。你需要在AWS上创建一个密钥对，并指定一个区域、集群名称、集群大小和DNS来继续操作。
- en: In addition, we will need to create a DNS entry, and will require a service
    such as Route 53 or a production DNS service. When following the instructions,
    you'll want to set the DNS to a domain or sub-domain on which you have permission
    to set up a record. We will need to update the record after the cluster is up
    and running and has a dynamic endpoint defined.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要创建一个DNS条目，并且需要像Route 53这样的服务或生产DNS服务。在按照说明操作时，你需要将DNS设置为一个你有权限设置记录的域名或子域名。集群启动并运行后，我们需要更新记录，并定义一个动态端点。
- en: 'There you have it! We now have a cluster running CoreOS. The script creates
    all the necessary AWS resources, such as **Virtual Private Clouds** (**VPCs**),
    security groups, and IAM roles. Now that the cluster is up and running, we can
    get the endpoint with the `status` command and update our DNS record as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们已经有了一个运行 CoreOS 的集群。这个脚本创建了所有必要的 AWS 资源，例如 **虚拟私有云**（**VPCs**）、安全组和
    IAM 角色。集群已启动并运行，我们可以使用 `status` 命令获取端点，并按如下方式更新 DNS 记录：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Copy the entry listed next to `Controller DNS Name` in the output from the preceding
    command, and then edit your DNS records to get the domain or sub-domain you specified
    earlier to point to this load balancer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 复制前一个命令输出中列出的 `Controller DNS Name` 旁边的条目，然后编辑你的 DNS 记录，使你之前指定的域名或子域名指向这个负载均衡器。
- en: 'If you forget which domain you specified or need to check on the configuration,
    you can look in the generated `kubeconfig` file with your favorite editor. It
    will look something like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了指定的域名或需要检查配置，你可以使用你喜欢的编辑器查看生成的 `kubeconfig` 文件。它的内容大概是这样的：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, the `server` line will have your domain name.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`server` 行将包含你的域名。
- en: 'If this is a fresh box, you will need to download `kubectl` separately, as
    it is not bundled with `kube-aws`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个全新的机器，你需要单独下载 `kubectl`，因为它没有和 `kube-aws` 一起打包：
- en: '`**$ wget https://storage.googleapis.com/kubernetes-release/release/v1.0.6/bin/linux/amd64/kubectl**`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ wget https://storage.googleapis.com/kubernetes-release/release/v1.0.6/bin/linux/amd64/kubectl**`'
- en: 'We can now use `kubectl` to see our new cluster:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `kubectl` 查看我们的新集群：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We should see a single node listed with the EC2 internal DNS as the name. Note
    `kubeconfig`, this tells Kubernetes the path to use the configuration file for
    the cluster that was just created instead. This is also useful if we want to manage
    multiple clusters from the same machine.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个节点列出，名称是 EC2 内部 DNS。注意 `kubeconfig`，它告诉 Kubernetes 使用配置文件的路径，以便使用刚创建的集群。这在我们想要从同一台机器管理多个集群时也非常有用。
- en: Tectonic
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tectonic
- en: Running Kubernetes on CoreOS is a great start, but you may find that you want
    a higher level of support. Enter Tectonic, the CoreOS enterprise offering for
    running Kubernetes with CoreOS. Tectonic uses many of the components we already
    discussed. Both Docker and rkt runtimes are supported. In addition, Kubernetes,
    etcd, and flannel are packaged together to give a full stack of cluster orchestration.
    We discussed flannel briefly in [Chapter 3](9b6aa290-fc68-4111-98a9-697c94f0e6a2.xhtml),
    *Working with Networking, Load Balancers, and Ingress*. It is an overlay network
    that uses a model similar to the native Kubernetes model, and uses etcd as a backend.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CoreOS 上运行 Kubernetes 是一个很好的开始，但你可能会发现你需要更高层次的支持。这时就需要 Tectonic，CoreOS 为在
    CoreOS 上运行 Kubernetes 提供的企业级解决方案。Tectonic 使用了我们之前讨论过的许多组件。它支持 Docker 和 rkt 运行时。此外，Kubernetes、etcd
    和 flannel 被打包在一起，提供完整的集群编排栈。我们在 [第 3 章](9b6aa290-fc68-4111-98a9-697c94f0e6a2.xhtml)，*与网络、负载均衡器和
    Ingress 配合工作* 中简要讨论了 flannel。它是一个覆盖网络，使用类似于原生 Kubernetes 模型的模型，并使用 etcd 作为后端。
- en: Offering a support package similar to Red Hat, CoreOS also provides 24/7 support
    for the open source software that Tectonic is built on. Tectonic also provides
    regular cluster updates and a nice dashboard with views for all of the components
    of Kubernetes. **CoreUpdate** allows users to have more control of the automatic
    update process. In addition, it ships with modules for monitoring, SSO, and other
    security features.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS 提供的支持包类似于 Red Hat，此外，它还为 Tectonic 所构建的开源软件提供 24/7 支持。Tectonic 还提供定期的集群更新，并且配有一个漂亮的控制面板，展示
    Kubernetes 所有组件的视图。**CoreUpdate** 使用户可以更好地控制自动更新过程。此外，它还提供了用于监控、SSO 和其他安全功能的模块。
- en: As CoreOS is integrated into Red Hat, this offering will be replaced over time
    with a Red Hat approach.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 CoreOS 被集成到 Red Hat 中，这项服务将逐步被 Red Hat 的方案取代。
- en: You can find more information and the latest instructions to install at [https://coreos.com/tectonic/docs/latest/install/aws/index.html](https://coreos.com/tectonic/docs/latest/install/aws/index.html).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://coreos.com/tectonic/docs/latest/install/aws/index.html](https://coreos.com/tectonic/docs/latest/install/aws/index.html)
    找到更多信息以及最新的安装指南。
- en: Dashboard highlights
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制面板亮点
- en: 'Some highlights of the Tectonic dashboard are shown in the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Tectonic 控制面板的一些亮点截图：
- en: '![](img/148e826b-de2b-46d9-899b-fcbd580bdd25.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/148e826b-de2b-46d9-899b-fcbd580bdd25.png)'
- en: The Tectonic main dashboard
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Tectonic 主控制面板
- en: 'Tectonic is now generally available and the dashboard already has some nice
    features. As you can see in the following screenshot, we can see a lot of detail
    about our replication controller, and can even use the GUI to scale up and down
    with the click of a button:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Tectonic 现在已经全面推出，仪表盘也已经具备了一些不错的功能。正如下面的截图所示，我们可以看到关于复制控制器的许多详细信息，甚至可以通过 GUI
    点击按钮轻松实现扩展与收缩：
- en: '![](img/73c9308e-df74-46aa-86df-8b79da9190c4.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73c9308e-df74-46aa-86df-8b79da9190c4.png)'
- en: Tectonic replication controller detail
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Tectonic 复制控制器详细信息
- en: 'This graphic is quite large, so it''s broken across two pages. The following
    screenshot continues from the preceding screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图很大，因此被分成了两页。以下截图是接续前一张截图的内容：
- en: '![](img/6f6c2827-552a-400f-91fc-2da18b0c24b0.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f6c2827-552a-400f-91fc-2da18b0c24b0.png)'
- en: 'Another nice feature is the Events page. Here, we can watch the events live,
    pause them, and filter them based on event severity and resource type:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不错的功能是事件页面。在这里，我们可以实时查看事件，暂停它们，并根据事件的严重性和资源类型进行过滤：
- en: '![](img/5a11a984-804c-4fa6-8423-b99f62bcafe4.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a11a984-804c-4fa6-8423-b99f62bcafe4.png)'
- en: Events stream
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流
- en: 'A useful feature to browse anywhere in the dashboard system is the Namespace:
    filtering option. Simply click on the drop-down menu next to the word Namespace:
    at the top of any page that shows resources, and we can filter our views by namespace.
    This can be helpful if we want to filter out the Kubernetes system pods, or just
    look at a particular collection of resources:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在仪表盘系统中随时浏览的一个有用功能是命名空间：过滤选项。只需点击任何资源页面顶部的命名空间旁的下拉菜单，就可以按命名空间过滤视图。如果我们想要排除 Kubernetes
    系统的 pod，或者只查看某个特定资源集合，这会很有帮助：
- en: '![](img/c8b94900-44de-4112-9234-4ed5b897e16d.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8b94900-44de-4112-9234-4ed5b897e16d.png)'
- en: Namespace filtering
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间过滤
- en: Hosted platforms
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管平台
- en: There are several options available for hosted Kubernetes in the cloud. These
    **Platforms as a service** (**PaaS**) can provide a stable operating model as
    you push towards production. Here's an overview of the major PaaSes provided by
    Amazon, Microsoft, and Google.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 云中有几种托管 Kubernetes 选项可供选择。这些**平台即服务**（**PaaS**）能够提供稳定的操作模式，帮助你向生产环境推进。以下是亚马逊、微软和谷歌提供的主要
    PaaS 概览。
- en: Amazon Web Services
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚马逊 Web 服务
- en: '**Elastic Container Service** (**ECS**) has just been launched as of the time
    of this chapter''s writing. AWS is preparing a networking plugin to differentiate
    itself from other offerings, called the vpc-cni. This allows for pod networking
    in Kubernetes to use **Elastic Network Interfaces** (**ENIs**) on AWS. With ECS,
    you do have to pay for manager nodes, which is a different path to that taken
    by Microsoft and Google. ECS'' startup procedure is also currently more complex
    and doesn''t have single-command creation via the CLI.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**弹性容器服务**（**ECS**）在本章写作时刚刚推出。AWS 正在准备一个网络插件，用以区分自己与其他提供商，名为 vpc-cni。它允许 Kubernetes
    中的 pod 网络使用 AWS 上的 **弹性网络接口**（**ENIs**）。使用 ECS 时，您需要为管理节点付费，这与微软和谷歌的做法不同。ECS 的启动过程目前也更复杂，且无法通过
    CLI 使用单一命令创建。'
- en: Microsoft Azure
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软 Azure
- en: The Azure Container Service is the second longest running hosted Kubernetes
    service in the cloud after the Google Kubernetes Engine. You can use Azure templates
    and the Resource Manager to spin up clusters with Terraform. Microsoft offers
    advanced networking features, integration with Azure Active Directory, and monitoring
    as its standout features.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 容器服务是继 Google Kubernetes Engine 之后，云中运行时间第二长的托管 Kubernetes 服务。你可以使用 Azure
    模板和资源管理器通过 Terraform 快速部署集群。微软提供了先进的网络功能、与 Azure Active Directory 的集成以及监控作为其突出特点。
- en: Google Kubernetes Engine
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine
- en: The Google Kubernetes Engine is another excellent option for running your containerized
    workloads. At the time of writing, it's considered to be one of the most robust
    offerings.  GKE is able to autoscale the cluster size, while AWS and Azure offer
    manual scaling. GKE offers a one-command start, and is the fastest to provision
    a Kubernetes cluster. It also offers an *Alpha Mode* where you can try bleeding
    edge features in the alpha channel releases. GKE provides high availability in
    zones and regions, the latter of which spreads out master node zones to provide
    best-in-class high availability.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine是运行容器化工作负载的另一个优秀选择。在撰写时，它被认为是最强大的选择之一。GKE能够自动调整集群大小，而AWS和Azure则提供手动扩展。GKE提供一键启动，是部署Kubernetes集群最快的方式。它还提供*Alpha模式*，你可以在Alpha频道发布中尝试前沿功能。GKE提供区域和可用区的高可用性，后者将主节点区域分布开来，提供业内领先的高可用性。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the emerging standards bodies in the container
    community and how they are using open specifications to shape the technology for
    the better. We looked at various container frameworks and runtimes. We dipped
    our toes into the CNCF, and tried out CRI-O.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了容器社区中新兴的标准化机构，以及它们如何使用开放规格来推动技术的进步。我们审视了各种容器框架和运行时。我们初步了解了CNCF，并尝试了CRI-O。
- en: We also took a closer look at CoreOS, a key player in both the container and
    Kubernetes community. We explored the technology that CoreOS is developing in
    order to enhance and complement container orchestration, and saw first-hand how
    to use some of it with Kubernetes. Finally, we looked at the supported enterprise
    offering of Tectonic and some of the features that are available now.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入了解了CoreOS，这是容器和Kubernetes社区中的一个关键玩家。我们探讨了CoreOS正在开发的技术，旨在增强和补充容器编排，并亲自体验了如何在Kubernetes中使用其中一些技术。最后，我们查看了Tectonic的企业级支持服务以及目前可用的一些功能。
- en: We also looked at some of the major PaaS offered by cloud service providers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了云服务提供商提供的一些主要PaaS。
- en: In the next chapter, we will explore the broader Kubernetes ecosystem and the
    tools available to move your cluster from development and testing into full-blown
    production.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索更广泛的Kubernetes生态系统以及将集群从开发和测试环境迁移到生产环境的工具。
- en: Further reading
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.opencontainers.org/faq/](https://www.opencontainers.org/faq/)
    (under How broad is the mission of the OCI?)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.opencontainers.org/faq/](https://www.opencontainers.org/faq/)（在“OCI的任务范围有多广？”部分）'
- en: '[https://github.com/opencontainers/specs/blob/master/principles.md](https://github.com/opencontainers/specs/blob/master/principles.md)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/opencontainers/specs/blob/master/principles.md](https://github.com/opencontainers/specs/blob/master/principles.md)'
