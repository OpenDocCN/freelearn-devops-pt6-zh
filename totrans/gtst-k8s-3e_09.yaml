- en: Operating Systems, Platforms, and Cloud and Local Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first half of this chapter will cover how open standards encourage a diverse
    ecosystem of container implementations. We'll look at the **Open Container Initiative**
    (**OCI**) and its mission to provide an open container specification as well.
    The second half of this chapter will cover the various operating systems available
    for running containerized workloads, such as CoreOS. We'll also look at its advantages
    as a host OS, including performance and support for various container implementations.
    Additionally, we'll take a brief look at the Tectonic Enterprise offering from
    CoreOS. We'll look at the various hosted platforms offered by the major **cloud
    service providers** (**CSPs**) and see how they stack up.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do standards matter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OCI and the **Cloud Native Computing Foundation** (**CNCF**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container specifications versus implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various container-oriented operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tectonic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CSP platforms available that can run Kubernetes workloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need to have your Google Cloud Platform account enabled and logged in,
    or you can use a local Minikube instance of Kubernetes. You can also use Play
    with Kubernetes online at [https://labs.play-with-k8s.com/](https://labs.play-with-k8s.com/).
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need GitHub credentials, which we'll go over setting up later in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter09](https://github.com/PacktPublishing/Getting-Started-with-Kubernetes-third-edition/tree/master/Code-files/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: The importance of standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past two years, containerization technology has had a tremendous growth
    in popularity. While Docker has been at the center of this ecosystem, there is
    an increasing number of players in the container space. There are already a number
    of alternatives to the containerization and Docker implementation itself (rkt,
    Garden, and so on). In addition, there is a rich ecosystem of third-party tools
    that enhance and complement your container infrastructure. While Kubernetes is
    designed to manage the state of a container and the orchestration, scheduling,
    and networking side of this ecosystem, the bottom line is that all of these tools
    form the basis to build cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the very beginning of this book, one of the most attractive
    things about containers is their ability to package our application for deployment
    across various environment tiers (that is, development, testing, and production)
    and various infrastructure providers (GCP, AWS, on-premises, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: To truly support this type of deployment agility, we need not only the containers
    themselves to have a common platform, but also the underlying specifications to
    follow a common set of ground rules. This will allow for implementations that
    are both flexible and highly specialized. For example, some workloads may need
    to be run on a highly secure implementation. To provide this, the implementation
    will have to make more intentional decisions about some aspects of the implementation.
    In either case, we will have more agility and freedom if our containers are built
    on some common structures that all implementations agree on and support.
  prefs: []
  type: TYPE_NORMAL
- en: In the following pages, we'll explore the building blocks of the many competing
    standards in the Kubernetes ecosystem. We'll explain how they're changing and
    developing and what part they may play in the future.
  prefs: []
  type: TYPE_NORMAL
- en: One of the examples that we'll explore more deeply in this third edition is
    the CRI-O project, which came to be after the creation of the OCI Charter. Let's
    make sure we understand the importance of that mission.
  prefs: []
  type: TYPE_NORMAL
- en: The OCI Charter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mission of the OCI Charter is to ensure that the open source community has
    a stable platform from which industry participants can contribute the portable,
    open, and vendor-neutral runtimes required to build container-powered applications.
    The Linux Foundation is the holder of the charter, which is a sister organization
    to the CNCF. We'll look more into the implications of a foundation in [Chapter
    11](d7bfc2e3-8a59-4df7-94ee-67828421848d.xhtml), *Kubernetes SIGs, Incubation
    Projects, and the CNCF*.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to read more about these foundations, you can check out their
    websites here: [https://www.linuxfoundation.org/](https://www.linuxfoundation.org/)
    and **[https://www.cncf.io/](https://www.cncf.io/).**
  prefs: []
  type: TYPE_NORMAL
- en: 'While the OCI Charter tries to standardize the building blocks of the ecosystem,
    it does not attempt to define the system at the macroscopic level, nor does it
    market a particular pathway or solution. There''s also a process defined that
    helps technology mature in a responsible way through these foundations, to ensure
    that the best possible technology is reaching the end user. These are defined
    as the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incubating
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Graduated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the specifics of this chapter as regards the OCI, let''s look at what else
    they''re trying to accomplish. Firstly, we''re attempting to create a format specification.
    This specification will call out a few important dimensions in order to create
    a consensus:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provide a format**: In order to ensure a specification that can be used across
    multiple runtimes, you need a standard container format and runtime specification.
    The container format is represented by the root filesystem that sits on the disk,
    with the necessary additional configuration that allows a given container to be
    run on the system. There is a push to categorize the standardization into the
    following layers: base, optional, and out of scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide a runtime**: This is more straightforward, as it''s designed to provide
    an executable that can directly run a container via consumption of the aforementioned
    container format and runtime specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Charter also incentivizes a number of projects, the first two of which
    are the runc projects, and the third of which involves the definition of its own
    specifications in the OCI Specification project. New projects are added by members
    through a review process that needs two-thirds approval from the current **Technical
    Oversight Board** (**TOB**). If we look deeper into the principles that govern
    the OCI, the website names six guiding principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Technology leadership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Influence through contribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited scope, limited politics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimalist structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representative leadership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adherence to anti-trust regulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These items are a blend of philosophical and logical frameworks that encourage
    competition, collaboration, meritocracy, and the continuous improvement cycles
    that many Agile and DevOps practitioners have long utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig more into the initiative itself now.
  prefs: []
  type: TYPE_NORMAL
- en: The OCI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first initiatives to gain widespread industry engagement is the OCI.
    Among the 36 industry collaborators are Docker, Red Hat, VMware, IBM, Google,
    and AWS, as listed on the OCI website at [https://www.opencontainers.org/](https://www.opencontainers.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the OCI is to split implementations, such as Docker and rkt,
    from a standard specification for the format and runtime of containerized workloads.
    According to their own terms, the goal of the OCI specifications has three basic tenets
    (you can refer to more details about this in the *Further reading* section at
    the end of the chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a formal specification for container image formats and runtime, which
    will allow a compliant container to be portable across all major, compliant operating
    systems and platforms without artificial technical barriers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting, maintaining, and advancing the projects associated with these standards.
    It will look to agree on a standard set of container actions (start, exec, pause,
    and so on), as well as a runtime environment associated with a container runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harmonizing the previously referenced standard with other proposed standards,
    including the appc specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these principals, the OCI hopes to bolster a collaborative and
    inclusive ecosystem that provides a rich and evolving toolset to meet the needs
    of today's complex application workloads, be they cloud-native or traditional.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are additionally some guiding principles for the development of standards
    in this space. These principles were integrated from the founding beliefs of the
    folks who created appc, and are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: Isolate containers via pluggable interfaces using secure cryptographic
    principles, and a chain of custody for both images and application code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Ensure that containers continue to be portable across a wide
    variety software, clouds, and hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decentralized**: Container images should be straightforward and should take
    advantage of federation and namespacing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: The runtime and formats should be community-built, with multiple
    interchangeable parts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backward compatible**: Given the popularity of Docker and containers with
    nearly 9 billion downloads, backward compatibility should be given high priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composable**: Tools for the operation of containers should be well integrated,
    but modular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code**: Consensus should be built from running, working code that follows
    principles of minimalism that adhere to domain-driven design. It should be stable
    and extensible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container Runtime Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at one of the newer and Kubernetes-specific OCI-based initiatives,
    CRI-O. CRI-O is currently part of the Kubernetes incubator, but it may move out
    to its own project as it matures. One of the compelling parts of the CRI-O design
    is that it never breaks Kubernetes. This is different because other runtimes are
    designed to do many things, such as building images, managing security, orchestration,
    and inspecting images. CRI-O is only designed to help Kubernetes orchestrate and
    schedule containers.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the code for the CRI-O project and read the documentation at [https://github.com/kubernetes-incubator/cri-o/](https://github.com/kubernetes-incubator/cri-o).
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, CRI-O is developed congruently with the CRI itself, and aligns
    itself with upstream releases of the Kubernetes system. The following diagram
    shows how the CRI-O works with the OCI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e46506c8-1ed5-4515-bda4-f1d4b4f43506.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to achieve this workflow, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The operator decides to start a pod, which causes Kubernetes to use the `kubelet`
    to start a pod. That `kubelet` talks through the CRI to the CRI-O daemon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CRI-O then uses several libraries, built with the OCI standard, to pull and
    unpack the given container image from a registry. From these operations, CRI-O
    generates a JSON blob that is used in the next step to run the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CRI-O kicks off an OCI-compatible runtime, which then runs the container process.
    This could be runc or the new Kata Container runtime (which has absorbed Intel's
    clear containers initiative).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll notice here that the CRI-O is acting as an interleaving layer between
    the libraries and runtimes, such that it''s using standard formats to accomplish
    most its goals. This ensures the goal is making Kubernetes work at all times.
    Here''s a diagram showing the system of the flow that was described in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc16cc9a-9ac5-4faa-bc78-94cc4ca29d37.png)'
  prefs: []
  type: TYPE_IMG
- en: For networking, CRI-O would leverage the **Container Networking Interface**
    (**CNI**), which is similar to the CRI, but deals with the networking stack. You
    should begin to see a pattern emerge here.
  prefs: []
  type: TYPE_NORMAL
- en: CRI-O is an implementation that helps to implement the OCI specification. This
    allows users to take for granted the container runtime being used as an implementation
    detail, and to focus instead on how the application is interacting with the objects
    and abstractions of the Kubernetes system.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out CRI-O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some installation methods so you can give CRI-O a try on your
    own. In order to get started, you''ll need a few things, including runc or another
    OCI compatible runtime, as well as socat, iproute, and iptables. There''s a few
    options for running CRI-O in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: In a full-scale cluster, using `kube-adm` and `systemd` to leverage the CRI-O
    socket with `--container-runtime-endpoint /var/run/crio/crio.sock`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Minikube, by starting it up with specific command-line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On atomic with atomic install `--system-package=no -n cri-o --storage ostree
    registry.centos.org/projectatomic/cri-o:latest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you'd like to build CRI-O from source, you can run the following on your
    laptop. You need some dependencies installed in order to make this build phase
    work. First, run the following commands to get your dependencies installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands are for Fedora, CentOS, and RHEL distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands are to be used for Debian, Ubuntu, and related distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, you''ll need to grab the source code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the code, go ahead and build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use additional build flags to add thing such as `seccomp`, SELinux,
    and `apparmor` with this format: `make BUILDTAGS=''seccomp apparmor''`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can run Kubernetes locally with the `local-up-cluster.sh` script in Kubernetes.
    I'll also show you how to run this on Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, clone the Kubernetes repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you''ll need to start the CRI-O daemon and run the following command
    to get spin up your cluster using CRI-O:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you have a running cluster, you can also use the instructions, available
    at the following URL, to switch the runtime from Docker to CRI-O: [https://github.com/kubernetes-incubator/cri-o/blob/master/kubernetes.md/](https://github.com/kubernetes-incubator/cri-o/blob/master/kubernetes.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also check how to use CRI-O on Minikube, which is one of the easiest
    ways to get experimenting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can use our GCP platform to spin up a cluster with CRI-O and start
    experimenting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's use these machines to run through a quick tutorial. SSH into the machine
    using `gcloud compute ssh cri-o`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re on the server, we''ll need to install the `cri-o`, `crioctl`,
    `cni`, and `runc` programs. Grab the `runc` binary first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Set it executable and move it to your path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see it''s working by checking the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You'll need to install the CRI-O binary from source, as it's not currently shipping
    any binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download the latest binary release and install Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This should feel familiar, as you would install Go the same way for any other
    project. Check your version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, get `crictl` using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that''s downloaded, you''ll need to build CRI-O from source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, get CRI-O and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is complete, you''ll need to create configuration files with `sudo
    make install.config`. You need to ensure that you''re using a valid registry option
    in the `/etc/crio/cirio.conf` file. An example of this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we''re ready to start the CRI-O system daemon, which we can
    do by leveraging `systemctl`. Let''s create a `crio.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that''s complete, we can reload `systemctl` and enable CRI-O:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is complete, we can validate whether or not we have a working install
    of CRI-O by checking the version of the endpoint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll need to grab the latest version of the CNI plugin, so we can
    build and use it from source. Let''s use Go to grab our source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the CNI plugins into your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure the CNI so that CRI-O can use it.  First, make a directory
    to store the configuration, then we''ll set two configuration files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you''ll want to create and compose `10-mynet.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, compose the `loopback` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''ll need some special containers from Project Atomic to get this
    working. `skopeo` is a command-line utility that is OCI-compliant and can perform
    various operations on container images and image repositories. Install the containers
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Restart CRI-O to pick up the CNI configuration with `sudo systemctl restart
    crio`. Great! Now that we have these components installed, let's build something!
  prefs: []
  type: TYPE_NORMAL
- en: First off, we'll create a sandbox using a template policy from the Kubernetes
    incubator.
  prefs: []
  type: TYPE_NORMAL
- en: This template is NOT production ready!
  prefs: []
  type: TYPE_NORMAL
- en: 'Change first to the CRI-O source tree with the template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you''ll need to create and capture the pod ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `critcl` to get the status of the pod as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use the `crictl` tool again to pull a container image for a Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll start and check the status of the Redis container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should be able to `telnet` into the Redis container to test
    its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Nicely done—you''ve now created a pod and container manually, using some of
    the core abstractions of the Kubernetes system! You can stop the container and
    shut down the pod with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: More on container runtimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a number of container- and VM-based options for OCI-compliant implementations.
    We know of runc, which is the standard reference implementation of the OCI runtime.
    This is what the container uses. There''s also the following available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`projectatomic/bwrap-oci` ([https://github.com/projectatomic/bwrap-oci](https://github.com/projectatomic/bwrap-oci)):
    Converts the OCI spec file to a command line for `projectatomic/bubblewrap` ([https://github.com/projectatomic/bubblewrap](https://github.com/projectatomic/bubblewrap))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`giuseppe/crun` ([https://github.com/giuseppe/crun](https://github.com/giuseppe/crun)):
    Runtime implementation in C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also VM-based implementations that take a different path towards
    security:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hyperhq/runv` ([https://github.com/hyperhq/runv](https://github.com/hyperhq/runv))—hypervisor-based
    runtime for OCI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearcontainers/runtime` ([https://github.com/clearcontainers/runtime](https://github.com/clearcontainers/runtime))—hypervisor-based
    OCI runtime utilizing `containers/virtcontainers` ([https://github.com/containers/virtcontainers](https://github.com/containers/virtcontainers))
    by Intel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google/gvisor` ([https://github.com/google/gvisor](https://github.com/google/gvisor))—gVisor
    is a user-space kernel, which contains runsc to run sandboxed containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kata-containers/runtime` ([https://github.com/kata-containers/runtime](https://github.com/kata-containers/runtime))—hypervisor-based
    OCI runtime combining technology from `clearcontainers/runtime` ([https://github.com/clearcontainers/runtime](https://github.com/clearcontainers/runtime))
    and `hyperhq/runv` ([https://github.com/hyperhq/runv](https://github.com/hyperhq/runv))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most interesting project of these is the last in the list, Kata containers,
    which combines clear container and runV into a cohesive package. These foundational
    pieces are already in production use at scale in the enterprises, and Kata is
    looking to provide a secure, lightweight VM for containerized environments. By
    utilizing runV, Kata containers can run inside of any KVM-compatible VM, such
    as Xen, KVM, and vSphere, while still remaining compatible with CRI-O, which is
    important! Kata hopes to offer the speed of a container with the security surface
    of a VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a diagram from Kata''s site, explaining the architecture in visual
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0daf1d8-69b9-4a3b-b027-efa0db055a5c.png)'
  prefs: []
  type: TYPE_IMG
- en: CNCF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A second initiative that also has widespread industry acceptance is the CNCF.
    While still focused on containerized workloads, the CNCF operates a bit higher
    up the stack, at the application design level.
  prefs: []
  type: TYPE_NORMAL
- en: Its purpose is to provide a standard set of tools and technologies to build,
    operate, and orchestrate cloud-native application stacks. Cloud has given us access
    to a variety of new technologies and practices that can improve and evolve our
    classic software designs. The CNCF is also particularly focused on the new paradigm
    of microservice-oriented development.
  prefs: []
  type: TYPE_NORMAL
- en: As a founding participant in the CNCF, Google has donated the Kubernetes open
    source project. The goal will be to increase interoperability in the ecosystem
    and support better integration with projects. The CNCF already hosts a variety
    of projects on orchestration, logging, monitoring, tracing, and application resilience.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on CNCF, refer to [https://cncf.io/](https://cncf.io/).
  prefs: []
  type: TYPE_NORMAL
- en: We'll talk more about the CNCF, **Special Interest Groups** (**SIGs**), and
    the landscape therein in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For now, here's a landscape and trail map to consider: [https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/](https://www.cncf.io/blog/2018/03/08/introducing-the-cloud-native-landscape-2-0-interactive-edition/).
  prefs: []
  type: TYPE_NORMAL
- en: Standard container specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A core result of the OCI effort is the creation and development of the overarching
    container specification. The specification has five core principles that all containers
    should follow, which I will briefly paraphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: The container must have *standard operations* to create, start, and stop containers
    across all implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container must be *content-agnostic*, which means that type of application
    inside the container does not alter the standard operations or publishing of the
    container itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container must be *infrastructure-agnostic* as well. Portability is paramount;
    therefore, the container must be able to operate just as easily in GCE as in your
    company's data center or on a developer's laptop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container must also be *designed for automation*, which allows us to automate
    across the build, as well as for updates and the deployment pipelines. While this
    rule is a bit vague, the container implementation should not require onerous manual
    steps for creation and release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the implementation must support *industrial-grade delivery*. Once again,
    this means speaking to the build and deployment pipelines and requiring streamlined
    efficiency in the portability and transit of the containers between infrastructure
    and deployment tiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specification also defines core principles for container formats and runtimes.
    You can read more about the specifications on the open containers GitHub page
    at [https://github.com/opencontainers/specs](https://github.com/opencontainers/specs).
    [](https://github.com/opencontainers/specs)
  prefs: []
  type: TYPE_NORMAL
- en: While the core specification can be a bit abstract, the runc implementation
    is a concrete example of the OCI specs, in the form of a container runtime and
    image format. Again, you can read more of the technical details on GitHub at [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc).
  prefs: []
  type: TYPE_NORMAL
- en: The backing format and runtime for a variety of popular container tools is runc.
    It was donated to OCI by Docker and was created from the same plumbing work used
    in the Docker platform. Since its release, it has received a welcome uptake by
    numerous projects.
  prefs: []
  type: TYPE_NORMAL
- en: Even the popular open source PaaS Cloud Foundry announced that it will use runc
    in Garden. Garden provides the containerization plumbing for Diego, which acts
    as an orchestration layer similar to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The rkt implementation was originally based on the appc specification. The appc
    specification was actually an earlier attempt by the folks at CoreOS to form a
    common specification around containerization. Now that CoreOS is participating
    in OCI, they are working to help merge the appc specification into OCI; this should
    result in a higher level of compatibility across the container ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: CoreOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the specifications provide us with a common ground, there are also some
    trends evolving around the choice of OS for our containers. There are several
    tailored-fit OSes that are being developed specifically to run container workloads.
    Although implementations vary, they all have similar characteristics. The focus
    is on a slim installation base, atomic OS updating, and signed applications for
    efficient and secure operations.
  prefs: []
  type: TYPE_NORMAL
- en: One OS that is gaining popularity is CoreOS. CoreOS offers major benefits for
    both security and resource utilization. It provides resource utilization by completely removing
    package dependencies from the picture. Instead, CoreOS runs all applications and
    services in containers. By providing only a small set of services required to
    support running containers and bypassing the need for hypervisor usage, CoreOS
    lets us use a larger portion of the resource pool to run our containerized applications.
    This allows users to gain higher performance from their infrastructure and better
    container-to-node (server) usage ratios.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, CoreOS was purchased by Red Hat, which means that the current version
    of container Linux will evolve against Red Hat's container OS offering, Project
    Atomic. These two products will eventually turn into Red Hat CoreOS. If you consider
    the upstream community approach that Fedora takes to Red Hat Enterprise Linux,
    it seems likely that there will be something similar for Red Hat CoreOS.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that Red Hat will be integration Tectonic, which we'll explore
    later in the chapter, and the Quay, the enterprise container registry that CoreOS
    acquired. It's important to note that the rkt container standard will not be part
    of the acquisition, and will instead become a community supported project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to see the relevant official announcements for the news discussed
    in the preceding section, you can check out these posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Press release**: [https://www.redhat.com/en/about/press-releases/red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership](https://www.redhat.com/en/about/press-releases/red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red Hat blog**:[https://www.redhat.com/en/blog/coreos-bet](https://www.redhat.com/en/blog/coreos-bet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CoreOS blog**:[https://coreos.com/blog/coreos-agrees-to-join-red-hat/](https://coreos.com/blog/coreos-agrees-to-join-red-hat/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a brief overview of the various container OSes. There are several other
    container-optimized OSes that have emerged recently:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Red Hat Enterprise Linux Atomic Host* focuses on security with SELinux enabled
    by default and atomic updates to the OS similar to what we saw with CoreOS. Refer
    to the following link: [https://access.redhat.com/articles/rhel-atomic-getting-started](https://access.redhat.com/articles/rhel-atomic-getting-started).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ubuntu Snappy* also capitalizes on the efficiency and security gains of separating
    the OS components from the frameworks and applications. Using application images
    and verification signatures, we get an efficient Ubuntu-based OS for our container
    workloads at [http://www.ubuntu.com/cloud/tools/snappy](http://www.ubuntu.com/cloud/tools/snappy).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ubuntu LXD* runs a container hypervisor and provides a path for migrating
    Linux-based VMs to containers with ease: [https://www.ubuntu.com/cloud/lxd](https://www.ubuntu.com/cloud/lxd).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*VMware Photon* is another lightweight container OS that is optimized specifically
    for vSphere and the VMware platform. It runs Docker, rkt, and Garden and also
    has some images that you can run on the popular public cloud providers. Refer
    to the following link: [https://vmware.github.io/photon/](https://vmware.github.io/photon/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the isolated nature of containers, we increase reliability and decrease
    the complexity of updates for each application. Now, applications can be updated
    along with supporting libraries whenever a new container release is ready, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c42dff26-cbee-4e99-adc6-41680ffc95df.png)'
  prefs: []
  type: TYPE_IMG
- en: CoreOS update procedure
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, CoreOS has some added advantages in the realm of security. For starters,
    the OS can be updated as one whole unit, instead of via individual packages (refer
    to the preceding diagram). This avoids many issues that arise from partial updates.
    To achieve this, CoreOS uses two partitions: one as the active OS partition, and
    a secondary one to receive a full update. Once updates are completed successfully,
    a reboot promotes the secondary partition. If anything goes wrong, the original
    partition is available as a fallback.'
  prefs: []
  type: TYPE_NORMAL
- en: The system owners can also control when those updates are applied. This gives
    us the flexibility to prioritize critical updates, while working with real-world
    scheduling for the more common updates. In addition, the entire update is signed
    and transmitted via SSL for added security across the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: rkt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, rkt will be continuing on as a community driven project.
    rkt is another implementation with a specific focus on security. The main advantage
    of rkt is that it runs the engine without a daemon as root, the way Docker does
    today. Initially, rkt also had an advantage in the establishment of trust for
    container images. However, recent updates to Docker have made great strides, especially
    the new content trust feature.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that rkt is still an implementation, with a focus on security,
    for running containers in production. rkt uses an image format named ACI, but
    it also supports Docker-based images. Over the past year, rkt has undergone significant
    updates and is now at version 1.24.0\. It has gained much momentum as a means
    to run Docker images securely in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a diagram showing how the rkt execution chain works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66dd571b-1ae2-4020-b788-29621df494f5.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition, CoreOS is working with Intel® to integrate the new Intel® Virtualization
    Technology, which allows containers to run in higher levels of isolation. This
    hardware-enhanced security allows the containers to be run inside a **Kernel-based
    Virtual Machine** (**KVM**) process, providing isolation from the kernel in a
    similar fashion to what we see with hypervisors today.
  prefs: []
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another central piece in the CoreOS ecosystem worth mentioning is their open
    source etcd project. etcd is a distributed and consistent key-value store. A RESTful
    API is used to interface with etcd, so it's easy to integrate with your project.
  prefs: []
  type: TYPE_NORMAL
- en: If it sounds familiar, it's because we saw this process running in [Chapter
    1](446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml), *Introduction to Kubernetes*,
    in the section entitled *Services running on the master*. Kubernetes actually
    utilizes etcd to keep track of cluster configuration and current state. K8s uses
    it for its service discovery capabilities as well. For more details, refer to
    [https://github.com/coreos/etcd](https://github.com/coreos/etcd).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes with CoreOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the benefits, let's take a look at a Kubernetes cluster
    using CoreOS. The documentation supports a number of platforms, but one of the
    easiest to spin up is AWS with the CoreOS CloudFormation and CLI scripts.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in running Kubernetes with CoreOS on other platforms,
    you can find more details in the CoreOS documentation at [https://coreos.com/kubernetes/docs/latest/](https://coreos.com/kubernetes/docs/latest/). [You
    can find the latest instructions for AWS at](https://coreos.com/kubernetes/docs/latest/)
    [https://coreos.com/kubernetes/docs/latest/kubernetes-on-aws.html](https://coreos.com/kubernetes/docs/latest/kubernetes-on-aws.html)[.](https://coreos.com/kubernetes/docs/latest/)
  prefs: []
  type: TYPE_NORMAL
- en: You can follow the instructions covered previously in this chapter to spin up
    Kubernetes on CoreOS. You'll need to create a key pair on AWS, and also specify
    a region, cluster name, cluster size, and DNS to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will need to create a DNS entry, and will require a service
    such as Route 53 or a production DNS service. When following the instructions,
    you'll want to set the DNS to a domain or sub-domain on which you have permission
    to set up a record. We will need to update the record after the cluster is up
    and running and has a dynamic endpoint defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'There you have it! We now have a cluster running CoreOS. The script creates
    all the necessary AWS resources, such as **Virtual Private Clouds** (**VPCs**),
    security groups, and IAM roles. Now that the cluster is up and running, we can
    get the endpoint with the `status` command and update our DNS record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Copy the entry listed next to `Controller DNS Name` in the output from the preceding
    command, and then edit your DNS records to get the domain or sub-domain you specified
    earlier to point to this load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget which domain you specified or need to check on the configuration,
    you can look in the generated `kubeconfig` file with your favorite editor. It
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `server` line will have your domain name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is a fresh box, you will need to download `kubectl` separately, as
    it is not bundled with `kube-aws`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ wget https://storage.googleapis.com/kubernetes-release/release/v1.0.6/bin/linux/amd64/kubectl**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use `kubectl` to see our new cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We should see a single node listed with the EC2 internal DNS as the name. Note
    `kubeconfig`, this tells Kubernetes the path to use the configuration file for
    the cluster that was just created instead. This is also useful if we want to manage
    multiple clusters from the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: Tectonic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running Kubernetes on CoreOS is a great start, but you may find that you want
    a higher level of support. Enter Tectonic, the CoreOS enterprise offering for
    running Kubernetes with CoreOS. Tectonic uses many of the components we already
    discussed. Both Docker and rkt runtimes are supported. In addition, Kubernetes,
    etcd, and flannel are packaged together to give a full stack of cluster orchestration.
    We discussed flannel briefly in [Chapter 3](9b6aa290-fc68-4111-98a9-697c94f0e6a2.xhtml),
    *Working with Networking, Load Balancers, and Ingress*. It is an overlay network
    that uses a model similar to the native Kubernetes model, and uses etcd as a backend.
  prefs: []
  type: TYPE_NORMAL
- en: Offering a support package similar to Red Hat, CoreOS also provides 24/7 support
    for the open source software that Tectonic is built on. Tectonic also provides
    regular cluster updates and a nice dashboard with views for all of the components
    of Kubernetes. **CoreUpdate** allows users to have more control of the automatic
    update process. In addition, it ships with modules for monitoring, SSO, and other
    security features.
  prefs: []
  type: TYPE_NORMAL
- en: As CoreOS is integrated into Red Hat, this offering will be replaced over time
    with a Red Hat approach.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information and the latest instructions to install at [https://coreos.com/tectonic/docs/latest/install/aws/index.html](https://coreos.com/tectonic/docs/latest/install/aws/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard highlights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some highlights of the Tectonic dashboard are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/148e826b-de2b-46d9-899b-fcbd580bdd25.png)'
  prefs: []
  type: TYPE_IMG
- en: The Tectonic main dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Tectonic is now generally available and the dashboard already has some nice
    features. As you can see in the following screenshot, we can see a lot of detail
    about our replication controller, and can even use the GUI to scale up and down
    with the click of a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73c9308e-df74-46aa-86df-8b79da9190c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Tectonic replication controller detail
  prefs: []
  type: TYPE_NORMAL
- en: 'This graphic is quite large, so it''s broken across two pages. The following
    screenshot continues from the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f6c2827-552a-400f-91fc-2da18b0c24b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another nice feature is the Events page. Here, we can watch the events live,
    pause them, and filter them based on event severity and resource type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a11a984-804c-4fa6-8423-b99f62bcafe4.png)'
  prefs: []
  type: TYPE_IMG
- en: Events stream
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful feature to browse anywhere in the dashboard system is the Namespace:
    filtering option. Simply click on the drop-down menu next to the word Namespace:
    at the top of any page that shows resources, and we can filter our views by namespace.
    This can be helpful if we want to filter out the Kubernetes system pods, or just
    look at a particular collection of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b94900-44de-4112-9234-4ed5b897e16d.png)'
  prefs: []
  type: TYPE_IMG
- en: Namespace filtering
  prefs: []
  type: TYPE_NORMAL
- en: Hosted platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several options available for hosted Kubernetes in the cloud. These
    **Platforms as a service** (**PaaS**) can provide a stable operating model as
    you push towards production. Here's an overview of the major PaaSes provided by
    Amazon, Microsoft, and Google.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Elastic Container Service** (**ECS**) has just been launched as of the time
    of this chapter''s writing. AWS is preparing a networking plugin to differentiate
    itself from other offerings, called the vpc-cni. This allows for pod networking
    in Kubernetes to use **Elastic Network Interfaces** (**ENIs**) on AWS. With ECS,
    you do have to pay for manager nodes, which is a different path to that taken
    by Microsoft and Google. ECS'' startup procedure is also currently more complex
    and doesn''t have single-command creation via the CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Azure Container Service is the second longest running hosted Kubernetes
    service in the cloud after the Google Kubernetes Engine. You can use Azure templates
    and the Resource Manager to spin up clusters with Terraform. Microsoft offers
    advanced networking features, integration with Azure Active Directory, and monitoring
    as its standout features.
  prefs: []
  type: TYPE_NORMAL
- en: Google Kubernetes Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google Kubernetes Engine is another excellent option for running your containerized
    workloads. At the time of writing, it's considered to be one of the most robust
    offerings.  GKE is able to autoscale the cluster size, while AWS and Azure offer
    manual scaling. GKE offers a one-command start, and is the fastest to provision
    a Kubernetes cluster. It also offers an *Alpha Mode* where you can try bleeding
    edge features in the alpha channel releases. GKE provides high availability in
    zones and regions, the latter of which spreads out master node zones to provide
    best-in-class high availability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the emerging standards bodies in the container
    community and how they are using open specifications to shape the technology for
    the better. We looked at various container frameworks and runtimes. We dipped
    our toes into the CNCF, and tried out CRI-O.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a closer look at CoreOS, a key player in both the container and
    Kubernetes community. We explored the technology that CoreOS is developing in
    order to enhance and complement container orchestration, and saw first-hand how
    to use some of it with Kubernetes. Finally, we looked at the supported enterprise
    offering of Tectonic and some of the features that are available now.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at some of the major PaaS offered by cloud service providers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the broader Kubernetes ecosystem and the
    tools available to move your cluster from development and testing into full-blown
    production.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.opencontainers.org/faq/](https://www.opencontainers.org/faq/)
    (under How broad is the mission of the OCI?)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/opencontainers/specs/blob/master/principles.md](https://github.com/opencontainers/specs/blob/master/principles.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
