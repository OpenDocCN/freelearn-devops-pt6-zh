<html><head></head><body>
<div class="IMG---Figure" id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.2.1">Building Secure Container Images with Build Service</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we discussed how Application Accelerator for VMware Tanzu helps organizations with a uniform and efficient way of building greenfield applications. </span><span class="koboSpan" id="kobo.3.2">This is a great start to building cloud-native applications that are based on predefined templates. </span><span class="koboSpan" id="kobo.3.3">These templates help developers purely focus on the business logic, which brings revenue to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the organization.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.5.1">Greenfield and cloud-native applications</span></p>
<p class="callout"><span class="koboSpan" id="kobo.6.1">Greenfield is a term from the construction industry that refers to undeveloped land. </span><span class="koboSpan" id="kobo.6.2">In the IT world, greenfield describes a software project that is developed from scratch rather than built from an existing program. </span><span class="koboSpan" id="kobo.6.3">It is often contrasted with </span><em class="italic"><span class="koboSpan" id="kobo.7.1">brownfield</span></em><span class="koboSpan" id="kobo.8.1">, which describes software built from an existing program. </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Reference: </span></span><a href="https://techterms.com/definition/greenfield"><span class="No-Break"><span class="koboSpan" id="kobo.10.1">https://techterms.com/definition/greenfield</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.11.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.12.1">Cloud-native applications, as you might surmise, are written to take advantage of cloud computing. </span><span class="koboSpan" id="kobo.12.2">They are characterized by such technologies as containers, service meshes, microservices, immutable infrastructure, and declarative APIs. </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Reference: </span></span><a href="https://github.com/cncf/toc/blob/main/DEFINITION.md"><span class="No-Break"><span class="koboSpan" id="kobo.14.1">https://github.com/cncf/toc/blob/main/DEFINITION.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.15.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">However, to get the true benefit out of a cloud-native application on a container platform such as Kubernetes, we need to run these applications as containers. </span><span class="koboSpan" id="kobo.16.2">And, to run them as containers, we need to build container images for those applications. </span><span class="koboSpan" id="kobo.16.3">While there are various ways we can build such container images for our applications, one of the most popular approaches in the industry is to build them using configuration files known as Dockerfiles. </span><span class="koboSpan" id="kobo.16.4">A </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">Dockerfile</span></strong><span class="koboSpan" id="kobo.18.1"> contains</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.19.1"> the definition, requirements, and attributes of the container image that should be built for the application. </span><span class="koboSpan" id="kobo.19.2">Though using Dockerfile is one of the most popular approaches to building container images, it is not always the most </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">optimal one.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we will take a deep dive into this concept and cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Why Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Build Service?</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Unboxing Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Build Service</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Getting started with Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Build Service</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Common day-2 activities for Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Build Service</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.31.1">So, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">get started.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.33.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.34.1">Some technical requirements need to be fulfilled before we start installing </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Tanzu Build Service</span></strong><span class="koboSpan" id="kobo.36.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.37.1">TBS</span></strong><span class="koboSpan" id="kobo.38.1">). </span><span class="koboSpan" id="kobo.38.2">These requirements will be covered later in this chapter at the beginning of the </span><em class="italic"><span class="koboSpan" id="kobo.39.1">Getting started with Tanzu Build Service</span></em><span class="koboSpan" id="kobo.40.1"> section. </span><span class="koboSpan" id="kobo.40.2">However, you may not need them to understand the benefits TBS brings to the table. </span><span class="koboSpan" id="kobo.40.3">Let’s start looking </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">into it.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.42.1">Why Tanzu Build Service?</span></h1>
<p><span class="koboSpan" id="kobo.43.1">There are various</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.44.1"> business, technical, and security challenges in building container images for applications. </span><span class="koboSpan" id="kobo.44.2">This becomes even more complex when we do it at scale in a large enterprise. </span><span class="koboSpan" id="kobo.44.3">Let’s understand what those challenges are and how TBS </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">addresses them.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.46.1">Increasing developer productivity</span></h2>
<p><span class="koboSpan" id="kobo.47.1">As discussed, one </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.48.1">of the most popular approaches to building container images today is using Dockerfiles. </span><span class="koboSpan" id="kobo.48.2">And, in most cases, the application teams are responsible for building and maintaining such Dockerfiles for their applications. </span><span class="koboSpan" id="kobo.48.3">These Dockerfiles contain details such as the base container operating system and its version, application bundles such as JAR files for a Java application, environment variables, and useful libraries and </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">their versions.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.50.1">JAR files</span></p>
<p class="callout"><span class="koboSpan" id="kobo.51.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Java ARchive</span></strong><span class="koboSpan" id="kobo.53.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.54.1">JAR</span></strong><span class="koboSpan" id="kobo.55.1">) file is</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.56.1"> a package of an application containing compiled source code files, configuration files, and external libraries required by the application. </span><span class="koboSpan" id="kobo.56.2">A JAR file can either be a supporting library or an application package that can be</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.57.1"> run in a </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">Java Runtime </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.59.1">Environment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.61.1">JRE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Developers know their applications more than anybody. </span><span class="koboSpan" id="kobo.63.2">So, it makes sense that they define what goes in their applications’ Dockerfiles. </span><span class="koboSpan" id="kobo.63.3">But at the same time, building and managing Dockerfiles are additional overheads for developers. </span><span class="koboSpan" id="kobo.63.4">Developers should spend all their time building more business-impacting functionalities in their applications. </span><span class="koboSpan" id="kobo.63.5">You might argue that building and changing such Dockerfiles is not a frequent task. </span><span class="koboSpan" id="kobo.63.6">Also, you may build some automation around building containers to reduce the amount of effort. </span><span class="koboSpan" id="kobo.63.7">However, such in-house automation brings other maintenance challenges. </span><span class="koboSpan" id="kobo.63.8">It would not eliminate the time required from the application teams. </span><span class="koboSpan" id="kobo.63.9">It’s not just about the time the developers need to spend to create or update the Dockerfiles. </span><span class="koboSpan" id="kobo.63.10">They also need the time required to research and decide on the content of it. </span><span class="koboSpan" id="kobo.63.11">And finally, these Dockerfiles have to be kept up to date to reflect the latest security patches of the libraries referenced in them. </span><span class="koboSpan" id="kobo.63.12">That ensures the best possible security posture for the running containers. </span><span class="koboSpan" id="kobo.63.13">Such endless ongoing maintenance consumes a lot of productive time of developers for </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">unproductive activities.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.65.1">Layers in container images</span></p>
<p class="callout"><span class="koboSpan" id="kobo.66.1">A final container</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.67.1"> image of an application could be a combination of multiple smaller images that are stacked as layers on top of each other to provide reusability, separation, and ease </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">of usage.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">To address these </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.70.1">challenges, Pivotal Software Inc. </span><span class="koboSpan" id="kobo.70.2">(which was acquired by VMware Inc. </span><span class="koboSpan" id="kobo.70.3">in 2020) and Heroku collaborated. </span><span class="koboSpan" id="kobo.70.4">They incepted an open source project </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.71.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">buildpacks.io</span></strong><span class="koboSpan" id="kobo.73.1"> under the </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">Cloud Native Computing Foundation</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">CNCF</span></strong><span class="koboSpan" id="kobo.77.1">). </span><span class="koboSpan" id="kobo.77.2">We will discuss this project </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.78.1">later in this chapter in detail. </span><span class="koboSpan" id="kobo.78.2">TBS is commercially-supported packaging containing buildpacks.io and a few other open </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">source tools.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">TBS addresses this challenge by providing a complete automation engine to build container images when you supply application code or built artifacts. </span><span class="koboSpan" id="kobo.80.2">As an output, TBS generates an OCI-compliant container image for the application. </span><span class="koboSpan" id="kobo.80.3">This image can be deployed on Kubernetes or any other OCI-compliant container orchestration platform. </span><span class="koboSpan" id="kobo.80.4">With TBS, developers are off the hook to build and maintain their container images. </span><span class="koboSpan" id="kobo.80.5">The reduced amount of responsibilities helps developers focus on what is more important for </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the business.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.82.1">What is OCI?</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.83.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.84.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.85.1">OCI</span></strong><span class="koboSpan" id="kobo.86.1">) is a standard set by The Linux Foundation describing the characteristics</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.87.1"> of a container image that can be implemented by various container image-building tools and understood by different container scheduling platforms such as Kubernetes. </span><span class="koboSpan" id="kobo.87.2">All major container platforms, including Kubernetes, support OCI-compliant </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">container images.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">TBS supports </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.90.1">different languages including Java, .Net, Python, Go, NodeJS, and </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">many more.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.92.1">Reduction of bespoke automation</span></h2>
<p><span class="koboSpan" id="kobo.93.1">It is a commonly</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.94.1"> observed practice that organizations </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.95.1">create </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">continuous integration</span></strong><span class="koboSpan" id="kobo.97.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.98.1">CI</span></strong><span class="koboSpan" id="kobo.99.1">) pipelines to build their applications’ container images. </span><span class="koboSpan" id="kobo.99.2">These pipelines are often developed using tools such as Jenkins and written mostly using languages such as Python or Shell script. </span><span class="koboSpan" id="kobo.99.3">Organizations may need to invest in resources to first develop such custom automation and then to maintain them ongoingly. </span><span class="koboSpan" id="kobo.99.4">Furthermore, the lack of good documentation around such custom automation makes such maintenance a nightmare. </span><span class="koboSpan" id="kobo.99.5">Hence, such people-dependent automation becomes a pain to maintain when their parents leave the organization. </span><span class="koboSpan" id="kobo.99.6">Additionally, the organizations could get better business outcomes if these people could rather be used for a better business-value-oriented assignment instead of such below-value-line </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">engineering efforts.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">TBS also helps address this challenge. </span><span class="koboSpan" id="kobo.101.2">It automates the container image-building process to a significant level. </span><span class="koboSpan" id="kobo.101.3">Although this will not replace the entire CI pipeline, it will reduce its complexity by covering the various steps required to build container images with </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">full automation.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.103.1">Standardization of container build process</span></h2>
<p><span class="koboSpan" id="kobo.104.1">It is often</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.105.1"> seen that there are many departmental silos in enterprises with large development shops. </span><span class="koboSpan" id="kobo.105.2">Such silos have tools and practices to follow. </span><span class="koboSpan" id="kobo.105.3">This could be a huge waste of crucial resources for the organizations in terms of duplication at various levels. </span><span class="koboSpan" id="kobo.105.4">Such duplication could be people’s time spent for similar outcomes, the license cost of tools, and the infrastructure used by the automation. </span><span class="koboSpan" id="kobo.105.5">This could lead to a whole new issue of lack of standardization. </span><span class="koboSpan" id="kobo.105.6">Such non-standard practices result in decreased transparency, governance, and security posture. </span><span class="koboSpan" id="kobo.105.7">When it comes to building container images, such an absence of standardization could be proven to be a very costly mistake for security risk exposures. </span><span class="koboSpan" id="kobo.105.8">This is caused by using unapproved libraries or not patching them quickly. </span><span class="koboSpan" id="kobo.105.9">When different teams have different ways of building container images, they could follow different practices. </span><span class="koboSpan" id="kobo.105.10">They might use different container operating systems, open source tools, third-party libraries, and their versions. </span><span class="koboSpan" id="kobo.105.11">It would be very difficult to apply an enterprise-wide standard. </span><span class="koboSpan" id="kobo.105.12">Such enforced standards should not affect different teams’ productivity and freedom </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">of choice.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">TBS solves this problem in two ways. </span><span class="koboSpan" id="kobo.107.2">First, it includes a centralized software library provided by VMware in the form of buildpacks and </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.108.1">Stacks. </span><span class="koboSpan" id="kobo.108.2">Here, </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">buildpacks</span></strong><span class="koboSpan" id="kobo.110.1"> include all the required libraries for the application to work in the container, including application runtimes</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.111.1"> such as </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Java Runtime Environment</span></strong><span class="koboSpan" id="kobo.113.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.114.1">JRE</span></strong><span class="koboSpan" id="kobo.115.1">) and middleware such as Tomcat Server. </span><span class="koboSpan" id="kobo.115.2">On the other side, </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Stacks</span></strong><span class="koboSpan" id="kobo.117.1"> include </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.118.1">different flavors of container operating systems. </span><span class="koboSpan" id="kobo.118.2">Second, TBS provides a standardized container image-building automation engine. </span><span class="koboSpan" id="kobo.118.3">Hence, when an organization uses TBS to build containers, it automatically implements standardization in the container-building process. </span><span class="koboSpan" id="kobo.118.4">This standardization comes in the form of the required automation and the application supporting content in </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the images.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">TBS does not</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.121.1"> only help to standardize the container build process across the company but also improves the overall security posture around the same, as explained in the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">following section.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.123.1">Stronger security posture</span></h2>
<p><span class="koboSpan" id="kobo.124.1">Security exposure</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.125.1"> is a major concern for the most established organizations in their journey to cloud transformation. </span><span class="koboSpan" id="kobo.125.2">Most cloud-native applications are deployed as containers in either public or private cloud platforms for several benefits. </span><span class="koboSpan" id="kobo.125.3">Containers are nothing but tiny virtual machines where the applications run. </span><span class="koboSpan" id="kobo.125.4">It is critical that such containers are built with secure ingredients that do not contain security vulnerabilities. </span><span class="koboSpan" id="kobo.125.5">But today’s secure library version could be found vulnerable tomorrow since it is very common to see new security vulnerabilities getting announced often for all operating systems and libraries that could be used in those container images. </span><span class="koboSpan" id="kobo.125.6">The corresponding organizations behind such operating systems and libraries would release newer versions to address those </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Common Vulnerabilities and Exposures</span></strong><span class="koboSpan" id="kobo.127.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.128.1">CVE</span></strong><span class="koboSpan" id="kobo.129.1">). </span><span class="koboSpan" id="kobo.129.2">However, it is on the user organizations to</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.130.1"> take the newer versions of the software and use them to rebuild the impacted container images. </span><span class="koboSpan" id="kobo.130.2">Such container image rebuild exercises may introduce two big pain points. </span><span class="koboSpan" id="kobo.130.3">The first is when there are multiple development teams managing hundreds of containerized applications. </span><span class="koboSpan" id="kobo.130.4">In that case, it is very difficult to find the impacted applications. </span><span class="koboSpan" id="kobo.130.5">Such an identification and remediation process may take weeks, keeping those applications vulnerable to attacks. </span><span class="koboSpan" id="kobo.130.6">It would be very difficult to push all the application teams at the same time to rebuild their applications’ container images using the newer version of the software. </span><span class="koboSpan" id="kobo.130.7">The patching gets delayed as the application teams would have their product backlogs and priorities to manage. </span><span class="koboSpan" id="kobo.130.8">And history has proven time and again that most major software-related security breaches were driven by unpatched software components running for a </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">long time.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">TBS can greatly speed up the CVE patching of the impacted container images with its centralized resource library and container image rebuild automation using that library. </span><span class="koboSpan" id="kobo.132.2">As a new CVE patch is announced for the impacted component in the library, VMware releases a new version of the repository component (either a buildpack or a stack) containing the fix for the vulnerability. </span><span class="koboSpan" id="kobo.132.3">TBS identifies impacted application container images using an internal map of container images and their linked dependencies. </span><span class="koboSpan" id="kobo.132.4">So, when VMware releases a new component version in the centralized repository to fix any CVE, TBS immediately triggers the patching of the impacted application images using the patched version. </span><span class="koboSpan" id="kobo.132.5">Such an automatic rebuilding of images for hundreds of applications may be complete in a few hours rather than needing weeks in the absence of TBS. </span><span class="koboSpan" id="kobo.132.6">This could be one of the most important reasons to consider using a tool such as TBS. </span><span class="koboSpan" id="kobo.132.7">Such mappings of applications, their container images, and the associated software components used in them provide the required transparency and auditability to the security team. </span><span class="koboSpan" id="kobo.132.8">Using TBS, we can quickly</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.133.1"> generate a </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">Bill of Material</span></strong><span class="koboSpan" id="kobo.135.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.136.1">BOM</span></strong><span class="koboSpan" id="kobo.137.1">) for any application</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.138.1"> managed by TBS. </span><span class="koboSpan" id="kobo.138.2">A BOM is a detailed report listing all the components and their versions used in the respective container images. </span><span class="koboSpan" id="kobo.138.3">It greatly simplifies security audits of </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">containerized environments.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.140.1">Optimized network bandwidth and storage utilization</span></h2>
<p><span class="koboSpan" id="kobo.141.1">As described</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.142.1"> previously, an OCI-compliant </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.143.1">container image is a collection of other smaller images containing different components required for the final resultant container image. </span><span class="koboSpan" id="kobo.143.2">These layers are made up of application code, configurations, third-party libraries, and operating systems. </span><span class="koboSpan" id="kobo.143.3">Container image repositories such as Docker Hub and Harbor store such layers separately. </span><span class="koboSpan" id="kobo.143.4">They also maintain maps of which image layer depends on which other image layers. </span><span class="koboSpan" id="kobo.143.5">So, when you pull a specific container image from the container image registry, the registry pushes all dependent container image layers as a result. </span><span class="koboSpan" id="kobo.143.6">Due to this, when an application goes through any change, only the corresponding impacted layer will get transferred over the network into the container registry. </span><span class="koboSpan" id="kobo.143.7">All other non-impacted image layers will not move over the network. </span><span class="koboSpan" id="kobo.143.8">This makes the image push and pull operations a lot more efficient. </span><span class="koboSpan" id="kobo.143.9">It also helps to reduce the storage requirements for the container image registry because of the reuse of the unchanged layers. </span><span class="koboSpan" id="kobo.143.10">However, to get the full benefit of these layers, you should follow some discipline in the image-building process. </span><span class="koboSpan" id="kobo.143.11">If the authors of Dockerfiles do not take enough care, they end up with fewer image layers than what is optimally possible. </span><span class="koboSpan" id="kobo.143.12">The following figures show the anatomy of the same application’s container images. </span><span class="koboSpan" id="kobo.143.13">They both have a different number of layers. </span><span class="koboSpan" id="kobo.143.14">They are built with two different Dockerfile approaches. </span><span class="koboSpan" id="kobo.143.15">These snapshots were taken using an open source tool</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.144.1"> named </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">Dive</span></strong><span class="koboSpan" id="kobo.146.1"> (</span><a href="https://github.com/wagoodman/dive"><span class="koboSpan" id="kobo.147.1">https://github.com/wagoodman/dive</span></a><span class="koboSpan" id="kobo.148.1">), which gives a detailed view of layers and their content for a </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">container image:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.150.1"><img alt="Figure 3.1 – A demo Java application’s container image built using ﻿four layers" src="image/B18145_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.151.1">Figure 3.1 – A demo Java application’s container image built using four layers</span></p>
<p><span class="koboSpan" id="kobo.152.1">As you can see, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.153.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.154.1">.1</span></em><span class="koboSpan" id="kobo.155.1"> has only four layers, whereas </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.156.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.157.1">.2</span></em><span class="koboSpan" id="kobo.158.1"> has eight layers, even though the total resultant image size is almost the same. </span><span class="koboSpan" id="kobo.158.2">There are various ways to build a container image, which may result in different outputs for the same </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">application code:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.160.1"><img alt="Figure 3.2 – The same demo Java application’s container image but built using ﻿eight layers" src="image/B18145_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.161.1">Figure 3.2 – The same demo Java application’s container image but built using eight layers</span></p>
<p><span class="koboSpan" id="kobo.162.1">When the developers do not have the required awareness or there are no enterprise-level guidelines on how to build application container images, every team might end up with their own standards and practices. </span><span class="koboSpan" id="kobo.162.2">With such a lack of knowledge and controls in place, large organizations may end up with several suboptimal application container images, which may lead to a waste of network bandwidth and storage for every container image push and </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">pull operation.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">On the other side, TBS uses a highly acclaimed </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">Cloud Native Computing Foundation</span></strong><span class="koboSpan" id="kobo.166.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.167.1">CNCF</span></strong><span class="koboSpan" id="kobo.168.1">) (</span><a href="https://cncf.io"><span class="koboSpan" id="kobo.169.1">https://cncf.io</span></a><span class="koboSpan" id="kobo.170.1">) certified </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.171.1">project </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.172.1">named </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">Cloud Native Buildpacks</span></strong><span class="koboSpan" id="kobo.174.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.175.1">CNB</span></strong><span class="koboSpan" id="kobo.176.1">) (</span><a href="https://buildpack.io"><span class="koboSpan" id="kobo.177.1">https://buildpack.io</span></a><span class="koboSpan" id="kobo.178.1">) as a tool under the hood, which provides a way to build container images with several smaller layers when the application container images are built using this tool. </span><span class="koboSpan" id="kobo.178.2">It provides an organization-level standardized approach to</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.179.1"> building </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.180.1">container images that are also very resource efficient, along with having other benefits, as discussed previously. </span><span class="koboSpan" id="kobo.180.2">Here is a high-level representation depicting how TBS performs </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">this operation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.182.1"><img alt="Figure 3.3 – High-level representation of how TBS builds container images with layers" src="image/B18145_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.183.1">Figure 3.3 – High-level representation of how TBS builds container images with layers</span></p>
<p><span class="koboSpan" id="kobo.184.1">The preceding figure shows how TBS takes some application code, performs various operations internally, and creates a final OCI-compliant application container image that has different </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">smaller layers.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Overall, TBS is useful to enhance developer productivity, reduce the learning curve, reduce operational toil, and increase security posture, along with several other benefits listed here for building secure container images. </span><span class="koboSpan" id="kobo.186.2">With all that, it just helps you accelerate your cloud-native application journey. </span><span class="koboSpan" id="kobo.186.3">After learning about the different benefits of using a tool such as TBS, let’s unbox it to check its anatomy. </span><span class="koboSpan" id="kobo.186.4">We will take a deep dive into all</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.187.1"> the</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.188.1"> different components that are bundled together </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">as TBS.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.190.1">Unboxing Tanzu Build Service</span></h1>
<p><span class="koboSpan" id="kobo.191.1">As described</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.192.1"> previously, TBS is built on top of two main open source projects: CNB and kpack. </span><span class="koboSpan" id="kobo.192.2">The following figure depicts the whole packaging </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">of TBS:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.194.1"><img alt="Figure 3.4 – Building blocks of Tanzu Build Service" src="image/B18145_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.195.1">Figure 3.4 – Building blocks of Tanzu Build Service</span></p>
<p><span class="koboSpan" id="kobo.196.1">As shown in the preceding figure, kpack includes engine and CLIs, whereas CNB includes things such as Builder, buildpacks and their groups, the stack, build and run images, and the life cycle</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.197.1"> process. </span><span class="koboSpan" id="kobo.197.2">Additionally, there are some VMware-supplied components for additional functionalities that are bundled in TBS. </span><span class="koboSpan" id="kobo.197.3">Let’s understand them </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">in detail.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.199.1">Cloud-native buildpacks</span></h2>
<p><span class="koboSpan" id="kobo.200.1">The concept</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.201.1"> of CNB was derived from</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.202.1"> the concept of buildpacks in Cloud Foundry, which is another container orchestration platform for cloud-native applications. </span><span class="koboSpan" id="kobo.202.2">The buildpacks in Cloud Foundry have been proven a battle-tested tool for over a decade. </span><span class="koboSpan" id="kobo.202.3">Buildpacks in Cloud Foundry are used to scan application source code, determine application requirements based on the technology and language used, club all required dependencies with application packages, and create an offline container </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.203.1">called a </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">droplet</span></strong><span class="koboSpan" id="kobo.205.1">. </span><span class="koboSpan" id="kobo.205.2">These droplets are large binary objects that contain everything required by the corresponding applications to run as containers on the Cloud Foundry platform. </span><span class="koboSpan" id="kobo.205.3">Though droplets have a solid track record, they have some limitations, listed </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.207.1">Cloud Foundry buildpacks generate droplets that are very large as they contain everything required by the application. </span><span class="koboSpan" id="kobo.207.2">They do not have a layer concept like modern OCI-compliant container images do. </span><span class="koboSpan" id="kobo.207.3">Hence, every small change in the application or its dependency creates a new version of the heavy droplet again. </span><span class="koboSpan" id="kobo.207.4">Such droplets require more storage as they do not contain just the delta but a full-blown application package. </span><span class="koboSpan" id="kobo.207.5">Because of this, deploying containers using droplets in Cloud Foundry is a relatively slower process than deploying containers using an OCI image for a newer version of the application on an OCI-compatible platform such as Kubernetes. </span><span class="koboSpan" id="kobo.207.6">This slowness of container scheduling impacts application deployment times while scaling or redeploying </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">the applications.</span></span></li>
<li><span class="koboSpan" id="kobo.209.1">The Buildpack project was designed to work only on Cloud Foundry. </span><span class="koboSpan" id="kobo.209.2">So, there was no way to use them on platforms such as Kubernetes that support only OCI-compliant </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">container images.</span></span></li>
<li><span class="koboSpan" id="kobo.211.1">The extendibility or customization of Cloud Foundry buildpacks is very limited. </span><span class="koboSpan" id="kobo.211.2">Rather than adding newer changes as layers or plugins, they must be modified by opening </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">them completely.</span></span></li>
<li><span class="koboSpan" id="kobo.213.1">Cloud Foundry buildpacks are slow in building new droplets as they do not optimally use </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">cached resources.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.215.1">Keeping all these limitations in mind and using the power of the buildpack concept in more broader and popular platforms such as Kubernetes, two software companies, Heroku and Pivotal (acquired by VMware in 2019), joined hands and announced that they were to collaborate on a new open source project called CNB, which retains all the goodness of</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.216.1"> the original Buildpack project</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.217.1"> but addresses its weaknesses. </span><span class="koboSpan" id="kobo.217.2">With this background, let’s discuss the anatomy of CNB </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">in detail.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">The following are some of the key concepts and terminologies of CNB that are important constructs </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">of TBS.</span></span></p>
<h3><span class="koboSpan" id="kobo.221.1">Build image</span></h3>
<p><span class="koboSpan" id="kobo.222.1">This is a base</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.223.1"> container operating system layer that is used to create a builder’s container image. </span><span class="koboSpan" id="kobo.223.2">A build container is short-lived. </span><span class="koboSpan" id="kobo.223.3">It executes the life cycle process to build the application’s </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.224.1">container image and </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">gets terminated.</span></span></p>
<h3><span class="koboSpan" id="kobo.226.1">Run image</span></h3>
<p><span class="koboSpan" id="kobo.227.1">This is a base </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.228.1">container operating system layer that is used to create an application’s container image. </span><span class="koboSpan" id="kobo.228.2">This is the main outcome of TBS. </span><span class="koboSpan" id="kobo.228.3">All the application-specific container images built by TBS use this image as the base container operating </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">system layer.</span></span></p>
<h3><span class="koboSpan" id="kobo.230.1">Stack</span></h3>
<p><span class="koboSpan" id="kobo.231.1">This is a </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.232.1">configuration entity that contains details of the build image and runs image flavors to be used in the container image build process. </span><span class="koboSpan" id="kobo.232.2">As a part of the package, TBS provides four different flavors of stacks that contain different flavors of build-and-run operating systems. </span><span class="koboSpan" id="kobo.232.3">These operating systems layers could be either thin or thick, depending on the requirements of the applications that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">use them.</span></span></p>
<h3><span class="koboSpan" id="kobo.234.1">Buildpack</span></h3>
<p><span class="koboSpan" id="kobo.235.1">This is a</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.236.1"> collection of executables that inspect your application code and determines whether the buildpack would apply to the application and hence should be a part of the resultant application’s container image. </span><span class="koboSpan" id="kobo.236.2">For example, there is a buildpack for Java applications, which detects the presence of Java-specific files in the application code or artifact, and then takes a call if the application needs required support to run as a Java application. </span><span class="koboSpan" id="kobo.236.3">In the TBS architecture, such buildpacks are stored in a container registry as </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">container images.</span></span></p>
<h3><span class="koboSpan" id="kobo.238.1">Buildpack group</span></h3>
<p><span class="koboSpan" id="kobo.239.1">This is a collection </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.240.1">of buildpacks that are typically used together to build a container image of a specific type of application. </span><span class="koboSpan" id="kobo.240.2">The buildpacks that are members of a buildpack group could either be mandatory or optional, depending on their use case and the requirement of the application. </span><span class="koboSpan" id="kobo.240.3">For example, buildpacks for </span><strong class="bold"><span class="koboSpan" id="kobo.241.1">Java Runtime Environment</span></strong><span class="koboSpan" id="kobo.242.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.243.1">JRE</span></strong><span class="koboSpan" id="kobo.244.1">), Maven, Gradle, Tomcat Server, and Jetty Server may all fall in the same group as they are all Java application-related dependencies. </span><span class="koboSpan" id="kobo.244.2">However, the buildpack for JRE would be a compulsory one for a Java application, but all others listed before would fall into the optional category as the application might or might not need them. </span><span class="koboSpan" id="kobo.244.3">There are</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.245.1"> various such buildpack groups for different types of applications, such as Python, .Net, NodeJS, </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">and more.</span></span></p>
<h3><span class="koboSpan" id="kobo.247.1">Life cycle</span></h3>
<p><span class="koboSpan" id="kobo.248.1">This determines</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.249.1"> the application of buildpacks and orchestrates their execution. </span><span class="koboSpan" id="kobo.249.2">The life cycle process has various components that execute its stages. </span><span class="koboSpan" id="kobo.249.3">At the end of all the stages, we get the final OCI-compliant container image of an application. </span><span class="koboSpan" id="kobo.249.4">Let’s review these life </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">cycle components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.251.1">Analyzer</span></strong><span class="koboSpan" id="kobo.252.1">: This retrieves and examines all required files that would be required during the image build process and used by the buildpacks. </span><span class="koboSpan" id="kobo.252.2">It also checks whether all the required images for the build are accessible in the container registry used by TBS. </span><span class="koboSpan" id="kobo.252.3">With such quick checking of dependencies, the build process fails fast if something is missing rather than realizing that later in the </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">build process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.254.1">Detector</span></strong><span class="koboSpan" id="kobo.255.1">: This checks which buildpack group is applicable for the application under the build process. </span><span class="koboSpan" id="kobo.255.2">It also gets a list of all available buildpack groups in a specific order. </span><span class="koboSpan" id="kobo.255.3">Then, it checks the applicability of each of these groups one by one until the first group passes the required criteria. </span><span class="koboSpan" id="kobo.255.4">The detector then creates a plan of execution to perform the container image build process as a </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">resulting artifact.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.257.1">Restorer</span></strong><span class="koboSpan" id="kobo.258.1">: This restores all the required dependency image layers based on the selected buildpack group from the cache put in by previous container build processes using the same image layers. </span><span class="koboSpan" id="kobo.258.2">This phase reduces the build time and the network traffic to transfer frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">used images.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.260.1">App Builder</span></strong><span class="koboSpan" id="kobo.261.1">: This transforms the application source code into a runnable artifact that can be packaged for execution inside a container. </span><span class="koboSpan" id="kobo.261.2">For example, this stage converts a Java application source code into a JAR file with compiled class files as an executable artifact. </span><span class="koboSpan" id="kobo.261.3">The application of this stage could be optional, depending on the supplied artifact of the application or even based on the technology requirements. </span><span class="koboSpan" id="kobo.261.4">For example, if the build process gets an already prepared JAR file for a Java application instead of the source code, then there is no need to prepare a build for the application and this stage may </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">be skipped.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.263.1">Exporter</span></strong><span class="koboSpan" id="kobo.264.1">: This creates the final OCI-compliant container image file. </span><span class="koboSpan" id="kobo.264.2">It also prepares a report containing the BOM for the components and their versions used in the </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.265.1">container image. </span><span class="koboSpan" id="kobo.265.2">Finally, it pushes the container image into the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">target registry.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.267.1">Builder</span></h3>
<p><span class="koboSpan" id="kobo.268.1">To build a </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.269.1">container image of an application, TBS needs to deploy a temporary container on Kubernetes that executes the life cycle components, as previously described, to create the resultant container image. </span><span class="koboSpan" id="kobo.269.2">A builder is a container image that deploys this container, which contains the executables for the life cycle processes, along with a list of buildpack groups and a </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">build image.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.271.1">kpack</span></h2>
<p><span class="koboSpan" id="kobo.272.1">kpack (</span><a href="https://github.com/pivotal/kpack"><span class="koboSpan" id="kobo.273.1">https://github.com/pivotal/kpack</span></a><span class="koboSpan" id="kobo.274.1">) is</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.275.1"> an open source </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.276.1">project initiated by Pivotal and is now actively being maintained by VMware. </span><span class="koboSpan" id="kobo.276.2">kpack provides a way to use CNB on the Kubernetes platform. </span><span class="koboSpan" id="kobo.276.3">kpack uses some</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.277.1"> Kubernetes </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">Custom Resource Definitions</span></strong><span class="koboSpan" id="kobo.279.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.280.1">CRDs</span></strong><span class="koboSpan" id="kobo.281.1">) to deploy itself as a tool running on top of Kubernetes. </span><span class="koboSpan" id="kobo.281.2">Hence, kpack is a tool that runs on Kubernetes and uses CNB to build OCI-compliant </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">container images.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.283.1">Custom Resource Definitions (CRDs)</span></p>
<p class="callout"><span class="koboSpan" id="kobo.284.1">Kubernetes has several out-of-the-box APIs that are referred to as resources. </span><span class="koboSpan" id="kobo.284.2">Some examples of such resources are Pod, Node, Deployment, Service, ReplicaSet, and many others. </span><span class="koboSpan" id="kobo.284.3">Though Kubernetes comes with many such out-of-the-box resources, it is a very extensible platform that allows adding more resources that are custom. </span><span class="koboSpan" id="kobo.284.4">Such custom resources are called CRDs. </span><span class="koboSpan" id="kobo.284.5">You may learn more about CRDs </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">here: </span></span><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/"><span class="No-Break"><span class="koboSpan" id="kobo.286.1">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.287.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">kpack has two main components, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.289.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.290.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.292.1">kpack Kubernetes CRDs to help use CNB and define the container </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">image specification.</span></span></li>
<li><span class="koboSpan" id="kobo.294.1">The kpack </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">command-line interface</span></strong><span class="koboSpan" id="kobo.296.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.297.1">CLI</span></strong><span class="koboSpan" id="kobo.298.1">), which provides the required user interface </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.299.1">to use kpack resources. </span><span class="koboSpan" id="kobo.299.2">The kpack CLI provides ways to create and manage </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.300.1">container image build specifications </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">using kpack.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.302.1">kpack CRD objects used by TBS</span></h3>
<p><span class="koboSpan" id="kobo.303.1">Though kpack is an</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.304.1"> internal component of TBS, the following are</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.305.1"> some of the key kpack CRD objects that are used </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">by TBS:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.307.1">Image</span></strong><span class="koboSpan" id="kobo.308.1">: An image gets created for every application that is registered with TBS to build its container images. </span><span class="koboSpan" id="kobo.308.2">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Image</span></strong><span class="koboSpan" id="kobo.310.1"> object references the application source code or package location, the runtime details for the build process, and the container registry details to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">built images.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.312.1">ClusterStore</span></strong><span class="koboSpan" id="kobo.313.1">: This contains references to buildpacks in the form of their respective container </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">image locations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.315.1">ClusterStack</span></strong><span class="koboSpan" id="kobo.316.1">: This contains references to the OS layers in terms of the build image and run image, along with their container </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">registry locations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.318.1">ClusterBuilder</span></strong><span class="koboSpan" id="kobo.319.1">: This is a high-level map that links </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">ClusterStore</span></strong><span class="koboSpan" id="kobo.321.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">ClusterStack</span></strong><span class="koboSpan" id="kobo.323.1"> combinations. </span><span class="koboSpan" id="kobo.323.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">ClusterBuilder</span></strong><span class="koboSpan" id="kobo.325.1"> object also defines an order of buildpacks to be validated against </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">any application.</span></span></li>
</ul>
<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.327.1">VMware-provided components and features</span></h2>
<p><span class="koboSpan" id="kobo.328.1">In addition </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.329.1">to the two main open source build blocks of TBS – CNB and kpack – there are also a few additional components and functionalities provided by VMware that the enterprises can get as a part of TBS packaging. </span><span class="koboSpan" id="kobo.329.2">Let’s quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">visit them:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.331.1">TBS comes with a proprietary installation and upgrades the user experience using an open source toolkit</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.332.1"> named Carvel (</span><a href="https://carvel.dev"><span class="koboSpan" id="kobo.333.1">https://carvel.dev</span></a><span class="koboSpan" id="kobo.334.1">). </span><span class="koboSpan" id="kobo.334.2">It is a Kubernetes application packaging and deployment toolkit mainly maintained by VMware. </span><span class="koboSpan" id="kobo.334.3">We will use it to install TBS in the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">next section.</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">TBS has a dependency updater component that keeps all the container images built by TBS up to date with changes made in their corresponding buildpacks or stack. </span><span class="koboSpan" id="kobo.336.2">This feature helps to keep all the container images patched and secured with the latest updates in the operating system and application </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">dependency changes.</span></span></li>
<li><span class="koboSpan" id="kobo.338.1">TBS also comes with a bundle of VMware-supplied buildpacks. </span><span class="koboSpan" id="kobo.338.2">This includes the support for offline buildpacks, Windows containers, and quick and reliable release engineering of the new buildpack versions to include new features and fixes </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">of CVEs.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.340.1">In this section, we saw the structure and components of TBS. </span><span class="koboSpan" id="kobo.340.2">We also learned the role that each of them plays to build the whole solution. </span><span class="koboSpan" id="kobo.340.3">Now, let’s get started with working with TBS. </span><span class="koboSpan" id="kobo.340.4">In the</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.341.1"> next section, you will learn how to install and configure TBS in your Kubernetes cluster and rip all the benefits we </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">discussed previously.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.343.1">Getting started with Tanzu Build Service</span></h1>
<p><span class="koboSpan" id="kobo.344.1">After learning about</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.345.1"> the challenges addressed by TBS and the details of what TBS contains, let’s learn how we can quickly get started with it running in a </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">Kubernetes cluster.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.347.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.348.1">All these instructions are for </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">Tanzu Build Service</span></strong><span class="koboSpan" id="kobo.350.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.351.1">TBS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">) v1.3.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">The following section details different prerequisites that you may need to get TBS fully up and</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.354.1"> running in your </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">Kubernetes cluster.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.356.1">Prerequisites</span></h2>
<p><span class="koboSpan" id="kobo.357.1">You will need the </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.358.1">following to configure TBS in your </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">Kubernetes environment:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.360.1">Administrator-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">kubectl</span></strong><span class="koboSpan" id="kobo.362.1"> CLI access to a Kubernetes cluster with version 1.19 or later. </span><span class="koboSpan" id="kobo.362.2">If administrator-level access is not feasible, then the user must at least have permissions listed at </span><a href="https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-03/tbs-k8s-cluster-permissions.yml"><span class="koboSpan" id="kobo.363.1">https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-03/tbs-k8s-cluster-permissions.yml</span></a><span class="koboSpan" id="kobo.364.1"> on the cluster to install and </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">configure TBS.</span></span></li>
<li><span class="koboSpan" id="kobo.366.1">The worker nodes of the Kubernetes cluster should at least have 50 GB of ephemeral storage as TBS stores the historical versions of the built images for records. </span><span class="koboSpan" id="kobo.366.2">The number of historical versions stored by TBS can be configured. </span><span class="koboSpan" id="kobo.366.3">This will be covered later in this chapter under </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">day-2 activities.</span></span></li>
<li><span class="koboSpan" id="kobo.368.1">Access to any container registry with required permission that supports Docker HTTP API V2 with at least a 5 GB storage quota, which excludes the space required for application images built by TBS. </span><span class="koboSpan" id="kobo.368.2">To keep things simple, we will use Docker Hub (</span><a href="https://hub.docker.com/"><span class="koboSpan" id="kobo.369.1">https://hub.docker.com/</span></a><span class="koboSpan" id="kobo.370.1">), which provides a free account that is good enough for </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">TBS integration.</span></span></li>
<li><span class="koboSpan" id="kobo.372.1">There should be a default </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">StorageClass</span></strong><span class="koboSpan" id="kobo.374.1"> configured in your Kubernetes cluster that TBS can use to create the required storage volumes. </span><span class="koboSpan" id="kobo.374.2">By default, TBS will need a </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">PersistentVolumeClaim</span></strong><span class="koboSpan" id="kobo.376.1"> that it uses to cache already-built artifacts. </span><span class="koboSpan" id="kobo.376.2">Such caching helps the subsequent builds </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">complete faster.</span></span></li>
<li><span class="koboSpan" id="kobo.378.1">The operator machine that will be used for this installation should have Carvel CLI tools installed. </span><span class="koboSpan" id="kobo.378.2">The following are those Carvel tools that TBS uses, along with their download locations </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">and purposes:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">kapp</span></strong><span class="koboSpan" id="kobo.381.1"> version 0.41.0 (</span><a href="https://network.tanzu.vmware.com/products/kapp"><span class="koboSpan" id="kobo.382.1">https://network.tanzu.vmware.com/products/kapp</span></a><span class="hidden"><span class="koboSpan" id="kobo.383.1">/</span></span><span class="koboSpan" id="kobo.384.1">) to deploy the bundle of Kubernetes resources required </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">for TBS.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">ytt</span></strong><span class="koboSpan" id="kobo.387.1"> version 0.37.0 (</span><a href="https://network.tanzu.vmware.com/products/ytt/"><span class="koboSpan" id="kobo.388.1">https://network.tanzu.vmware.com/products/ytt/</span></a><span class="koboSpan" id="kobo.389.1">) to replace custom configuration values in the YAML template files used for TBS Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">resource deployments.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">kbld</span></strong><span class="koboSpan" id="kobo.392.1"> version 0.31.0 (</span><a href="https://network.tanzu.vmware.com/products/kbld/"><span class="koboSpan" id="kobo.393.1">https://network.tanzu.vmware.com/products/kbld/</span></a><span class="koboSpan" id="kobo.394.1">) to reference container images in Kubernetes configuration files that are relocated based on your choice of </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">container registry.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">imgpkg</span></strong><span class="koboSpan" id="kobo.397.1"> version 0.23.1 (</span><a href="https://network.tanzu.vmware.com/products/imgpkg/"><span class="koboSpan" id="kobo.398.1">https://network.tanzu.vmware.com/products/imgpkg/</span></a><span class="koboSpan" id="kobo.399.1">) to deploy the packaged application bundle for TBS that contains the required configuration and OCI images. </span><span class="koboSpan" id="kobo.399.2">For an air-gapped (an environment that has no outbound internet connectivity) installation, it helps to relocate all the required OCI images to the private container registry </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">in use.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.401.1">The operator </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.402.1">machine should have </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">kp</span></strong><span class="koboSpan" id="kobo.404.1"> CLI v0.4.*, which can be downloaded from the Tanzu Network website </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">at </span></span><a href="https://network.tanzu.vmware.com/products/build-service/"><span class="No-Break"><span class="koboSpan" id="kobo.406.1">https://network.tanzu.vmware.com/products/build-service/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.407.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.408.1">The operator machine should have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">docker</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.410.1">CLI: </span></span><a href="https://docs.docker.com/get-docker/"><span class="No-Break"><span class="koboSpan" id="kobo.411.1">https://docs.docker.com/get-docker/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.412.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.413.1">The operator machine should have the Dependency Descriptor file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">descriptor-&lt;version&gt;.yaml</span></strong><span class="koboSpan" id="kobo.415.1"> format downloaded from the TBS dependencies page on the Tanzu Network website at </span><a href="https://network.tanzu.vmware.com/products/build-service/"><span class="koboSpan" id="kobo.416.1">https://network.tanzu.vmware.com/products/build-service/</span></a><span class="koboSpan" id="kobo.417.1">. </span><span class="koboSpan" id="kobo.417.2">This book has used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">descriptor-100.0.229.yaml</span></strong><span class="koboSpan" id="kobo.419.1"> file. </span><span class="koboSpan" id="kobo.419.2">This file contains container image paths that TBS will need to execute image builds. </span><span class="koboSpan" id="kobo.419.3">You may find a different version, depending on when you download it, which </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">is fine.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.421.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.422.1">The Kubernetes cluster running with Containerd v1.4.1 is not compatible with TBS. </span><span class="koboSpan" id="kobo.422.2">The following </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">kubectl</span></strong><span class="koboSpan" id="kobo.424.1"> command will get the version of the underneath container runtime to </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">check this:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">kubectl get </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">nodes -o=jsonpath='{.items[0].status.nodeInfo.containerRuntimeVersion}'</span></strong></span></p>
<p><span class="koboSpan" id="kobo.428.1">Let’s start our journey working with TBS by first installing it and then performing some basic tests to </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.429.1">confirm whether it is working </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">as expected.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.431.1">Installation procedure</span></h2>
<p><span class="koboSpan" id="kobo.432.1">In this </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.433.1">chapter, we will use Docker Hub as the container registry to be used with TBS. </span><span class="koboSpan" id="kobo.433.2">Also, the installation steps assume that the base Kubernetes cluster has full outbound internet connectivity. </span><span class="koboSpan" id="kobo.433.3">The procedure to install and configure TBS is different for an air-gapped environment and a custom container registry to be used instead of Docker Hub. </span><span class="koboSpan" id="kobo.433.4">You may follow the official product documentation (</span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-installing.html"><span class="koboSpan" id="kobo.434.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-installing.html</span></a><span class="koboSpan" id="kobo.435.1">) for a different </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">p********t</span></strong><span class="koboSpan" id="kobo.439.1"> value used in all the commands should be replaced with your respective username and </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">**********</span></strong><span class="koboSpan" id="kobo.441.1"> with your </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">respective password.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">With those expectations set, let’s install and configure TBS by performing the </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">following steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.445.1">Make sure you are working in the right Kubernetes cluster and context where you want to </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">install TBS:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.447.1">
$ kubectl config use-context &lt;CONTEXT-NAME&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.448.1">Relocate the required container images from the Tanzu Network registry to your Docker Hub account. </span><span class="koboSpan" id="kobo.448.2">For that, log in to your Docker Hub account, </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.450.1">
$ docker login -u </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">p********t</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.452.1">
Password:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.453.1">
Login Succeeded</span></pre></li>
<li><span class="koboSpan" id="kobo.454.1">Log in to the Tanzu Network container registry to pull the required images for installation using your Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">Network credentials:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
$ docker login registry.tanzu.vmware.com</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
Username: </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">p********t</span></strong><span class="koboSpan" id="kobo.459.1">@*******.io</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.460.1">
Password:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.461.1">
Login Succeeded</span></pre></li>
<li><span class="koboSpan" id="kobo.462.1">Relocate the images from Tanzu </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.463.1">Network to your Docker Hub registry using the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">imgpkg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1"> command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.466.1">
$ imgpkg copy -b "registry.tanzu.vmware.com/build-service/bundle:1.3.0" --to-repo </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">p********t</span></strong><span class="koboSpan" id="kobo.468.1">/build-service-1-3</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.469.1">
copy | exporting 17 images...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
copy | will export registry.tanzu.vmware.com/build-service/bundle@sha256:0e64239d34119c1b8140d457a238050751360617d8e8b64703d8b7b4f944054a</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
..</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
copy | will export registry.tanzu.vmware.com/build-service/smart-warmer@sha256:4d865b7f4c10c1099ae9648a64e6e7da097d0a375551e8fd2ef80a6d1fc50176</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
copy | exported 17 images</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
copy | importing 17 images...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.475.1">
 443.39 MiB / 443.64 MiB [==============================================================================================]  99.94% 1.92 MiB/s 3m51s</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
copy | done uploading images</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.477.1">
copy | Warning: Skipped layer due to it being non-distributable. </span><span class="koboSpan" id="kobo.477.2">If you would like to include non-distributable layers, use the --include-non-distributable-layers flag</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.478.1">
Succeeded</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.479.1">You may ignore the warning given before the success message because TBS excludes Windows components by default as they </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">are licensed.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.481.1">Pull the TBS bundle image locally using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">imgpkg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.483.1"> command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
$ imgpkg pull -b "</span><strong class="bold"><span class="koboSpan" id="kobo.485.1">p********t</span></strong><span class="koboSpan" id="kobo.486.1">/build-service-1-3:1.3.0" -o /tmp/bundle</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.487.1">
Pulling bundle 'index.docker.io/p********t/build-service-1-3@sha256:0e64239d34119c1b8140d457a238050751360617d8e8b64703d8b7b4f944054a'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.488.1">
  Extracting layer 'sha256:872d56ff2b8ef97689ecaa0901199d84e7f7ae55bfef3ad9c7effa14b02e6dfd' (1/1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.489.1">
Locating image lock file images...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.490.1">
The bundle repo (index.docker.io/p********t/build-service-1-3) is hosting every image specified in the bundle's Images Lock file (.imgpkg/images.yml)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.491.1">
Succeeded</span></pre></li>
<li><span class="koboSpan" id="kobo.492.1">Install TBS </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.493.1">using the relevant Carvel tools – </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">ytt</span></strong><span class="koboSpan" id="kobo.495.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">kbld</span></strong><span class="koboSpan" id="kobo.497.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">kapp</span></strong><span class="koboSpan" id="kobo.499.1"> – with the following command. </span><span class="koboSpan" id="kobo.499.2">It is a very long command that injects the provided custom parameter values with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">-v</span></strong><span class="koboSpan" id="kobo.501.1"> flag into the deployment configuration files using </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">ytt</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">Then, the command replaces the container image locations based on your registry location using </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">kbld</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">And finally, it deploys TBS using the configuration files with custom parameter values and the required container image files pulled from your repository </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">kapp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.509.1">
$ ytt -f /tmp/bundle/values.yaml -f /tmp/bundle/config/ -v kp_default_repository='p********t/build-service-1-3' -v kp_default_repository_username='p********t' -v kp_default_repository_password='**********' -v pull_from_kp_default_repo=true -v tanzunet_username='p********t@*******.io' -v tanzunet_password='**********' | kbld -f /tmp/bundle/.imgpkg/images.yml -f- | kapp deploy -a tanzu-build-service -f- -y</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.510.1">
resolve | final: build-init -&gt; index.docker.io/p********t/build-service-1-3@sha256:838e8f1ad7be81e8dab637259882f9c4daea70c42771264f96be4b57303d85f2</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.511.1">
resolve | final: completion -&gt; index.docker.io/p********t/build-service-1-3@sha256:765dafb0bb1503ef2f9d2deb33b476b14c85023e5952f1eeb46a983feca595c6</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.512.1">
..</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.513.1">
..</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.514.1">
Succeeded</span></pre></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.515.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.516.1">At the time of writing this book, all the binaries supplied under Carvel, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">ytt</span></strong><span class="koboSpan" id="kobo.518.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">kbld</span></strong><span class="koboSpan" id="kobo.520.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">kapp,</span></strong><span class="koboSpan" id="kobo.522.1"> are unsigned binaries. </span><span class="koboSpan" id="kobo.522.2">Because of this, your operating system, especially macOS, may raise a security concern against using them. </span><span class="koboSpan" id="kobo.522.3">However, you may explicitly allow the execution of these binaries in your operating system’s security settings. </span><span class="koboSpan" id="kobo.522.4">Additionally, as this command performs various long image pull operations to deploy TBS in your Kubernetes cluster, you may see the command complete unsuccessfully with an error – </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">use of closed network connection</span></strong><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">In that case, you may run the same command again and it may </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">just work.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">You may need</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.527.1"> to replace the highlighted values in the preceding command as per the </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">following specification:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.529.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">p********t</span></strong><span class="koboSpan" id="kobo.531.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">kp_default_repository</span></strong><span class="koboSpan" id="kobo.533.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">kp_default_repository_username</span></strong><span class="koboSpan" id="kobo.535.1"> parameters with your Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">Hub username</span></span></li>
<li><span class="koboSpan" id="kobo.537.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">**********</span></strong><span class="koboSpan" id="kobo.539.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">kp_default_repository_password</span></strong><span class="koboSpan" id="kobo.541.1"> parameter with your Docker Hub </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">account password</span></span></li>
<li><span class="koboSpan" id="kobo.543.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">p********t@*******.io</span></strong><span class="koboSpan" id="kobo.545.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">tanzunet_username</span></strong><span class="koboSpan" id="kobo.547.1"> with your Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">Network username</span></span></li>
<li><span class="koboSpan" id="kobo.549.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">**********</span></strong><span class="koboSpan" id="kobo.551.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">tanzunet_password</span></strong><span class="koboSpan" id="kobo.553.1"> with your Tanzu </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">Network password</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.555.1">With that last command completed successfully, TBS should be up and running in your Kubernetes </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.556.1">cluster. </span><span class="koboSpan" id="kobo.556.2">Let’s verify the installation and ensure TBS is </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">working fine.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.558.1">Verifying the installation</span></h2>
<p><span class="koboSpan" id="kobo.559.1">To verify the TBS</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.560.1"> installation, execute the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">kp</span></strong><span class="koboSpan" id="kobo.562.1"> command to list the cluster builders available in your </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">TBS environment:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.564.1">
$ kp clusterbuilder list</span></pre>
<p><span class="koboSpan" id="kobo.565.1">The result of the preceding command should look as follows, where you should see your Docker Hub username instead </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">p********t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.569.1">
NAME       READY    STACK                          IMAGE
base       true     io.buildpacks.stacks.bionic p********t/build-service-1-3:clusterbuilder-base@sha256:7af47645c47b305caa1b14b3900dbca206025e30b684e9cd32b6d27f9942661f
default    true     io.buildpacks.stacks.bionic    p********t/build-service-1-3:clusterbuilder-default@sha256:7af47645c47b305caa1b14b3900dbca206025e30b684e9cd32b6d27f9942661f
full       true     io.buildpacks.stacks.bionic    p********t/build-service-1-3:clusterbuilder-full@sha256:714990fdf5e90039024bceafd5f499830235f1b5f51477a3434f3b297646b3d0
tiny       true     io.paketo.stacks.tiny          p********t/build-service-1-3:clusterbuilder-tiny@sha256:29d03b1d4f45ce6e7947ab2bf862023f47d5a6c84e634727900a1625e661ee3b</span></pre>
<p><span class="koboSpan" id="kobo.570.1">If you see the preceding output, then congratulations to you as you have TBS running in your Kubernetes environment, waiting to build container images of </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">your application!</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Now that we’ve got started with TBS, let’s investigate common day-2 operations that we can perform on TBS for various </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">use cases.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.574.1">Common day-2 activities for Tanzu Build Service</span></h1>
<p><span class="koboSpan" id="kobo.575.1">In this section, we will go through some useful operations we can perform </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">on TBS.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.577.1">Building application container images</span></h2>
<p><span class="koboSpan" id="kobo.578.1">In this section, we </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.579.1">will learn how to register our application with TBS for the first time, create the first container image, run that container image locally, retrigger the image build process again by modifying the application configuration, and, finally, verify the newly created container image to reflect the application change. </span><span class="koboSpan" id="kobo.579.2">This will be an exciting journey to use TBS for its </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">main purpose.</span></span></p>
<h3><span class="koboSpan" id="kobo.581.1">Registering an application with TBS</span></h3>
<p><span class="koboSpan" id="kobo.582.1">The main</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.583.1"> reason to use TBS is to gain the ability to build application container images in a fully automatic and secure way. </span><span class="koboSpan" id="kobo.583.2">Let’s see how we can build container images of a cloud-native application using the TBS setup we have completed. </span><span class="koboSpan" id="kobo.583.3">We will use a sample Spring Framework-based application, Spring Pet Clinic, available at </span><a href="https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/spring-petclinic"><span class="koboSpan" id="kobo.584.1">https://github.com/tandcruz/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/spring-petclinic</span></a><span class="koboSpan" id="kobo.585.1">. </span><span class="koboSpan" id="kobo.585.2">To follow along, you need to fork this project in your </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">Git repository.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">kp</span></strong><span class="koboSpan" id="kobo.589.1"> CLI to register our application with TBS. </span><span class="koboSpan" id="kobo.589.2">To register an application, we must create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">image</span></strong><span class="koboSpan" id="kobo.591.1"> resource, which is a kpack CRD object to create a record of the application in its list. </span><span class="koboSpan" id="kobo.591.2">Once an image resource has been created, TBS creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">build</span></strong><span class="koboSpan" id="kobo.593.1">, which is also a kpack CRD object that creates a container image of a registered application. </span><span class="koboSpan" id="kobo.593.2">There can be one-to-many relationships between an </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">image</span></strong><span class="koboSpan" id="kobo.595.1"> and its </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">build</span></strong><span class="koboSpan" id="kobo.597.1"> objects, depending on the number of instances to create a new container image for an application. </span><span class="koboSpan" id="kobo.597.2">But before we register our application, let’s verify the current </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">image objects:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.599.1">
$ kp image list
Error: no image resources found</span></pre>
<p><span class="koboSpan" id="kobo.600.1">As you might have guessed, we don’t have any existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">image</span></strong><span class="koboSpan" id="kobo.602.1"> objects managed by our newly deployed TBS in our </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">Additionally, we will also need to provide TBS with the credentials to our Docker Hub account so that it can push built images there. </span><span class="koboSpan" id="kobo.604.2">You may also use a different container registry or a Docker Hub account to push built application images. </span><span class="koboSpan" id="kobo.604.3">But, to keep things simple, we will use the same Docker Hub account that we used previously to install TBS. </span><span class="koboSpan" id="kobo.604.4">To supply the login credentials of our Docker Hub account, we need to create a Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">Secret</span></strong><span class="koboSpan" id="kobo.606.1"> object, </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.608.1">
$ DOCKER_PASSWORD="</span><strong class="bold"><span class="koboSpan" id="kobo.609.1">**********</span></strong><span class="koboSpan" id="kobo.610.1">" kp secret create tbs-dockerhub-cred –dockerhub </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">p********t</span></strong><span class="koboSpan" id="kobo.612.1">
Secret "tbs-dockerhub-cred" created</span></pre>
<p><span class="koboSpan" id="kobo.613.1">Now, let’s work on creating an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">image</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">There are three different ways in which we may configure an application to use TBS for building container</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.617.1"> images. </span><span class="koboSpan" id="kobo.617.2">Let’s take a look at them so that you can understand which one you should </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">use when:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.619.1">Using a Git repository URL</span></strong><span class="koboSpan" id="kobo.620.1">: In this approach, we register the Git repository URL and the</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.621.1"> branch of the repository that we want to monitor for changes and trigger TBS image builds based on the changes committed in this branch. </span><span class="koboSpan" id="kobo.621.2">This is the most automated approach to creating container images as soon as application changes are merged in the final code branch. </span><span class="koboSpan" id="kobo.621.3">We will use this approach in </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">this book.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.623.1">Using a local path</span></strong><span class="koboSpan" id="kobo.624.1">: In this </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.625.1">approach, we supply either the location of the application’s package such as a JAR file for a Java application that is precompiled and packaged on the local system, or provide the location of the application’s source code on the local system. </span><span class="koboSpan" id="kobo.625.2">This approach is not fully automated using TBS and assumes that you have an external CI process that will explicitly call TBS whenever there is a need to create a container image of the application, rather than creating new images automatically based on the new changes pushed into the Git </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">repository branch.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.627.1">Using a BLOB store location</span></strong><span class="koboSpan" id="kobo.628.1">: Like </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.629.1">the local path approach, in this approach, we supply the BLOB store location, such as an S3 bucket in AWS, containing application source code packaged as either a </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">zip</span></strong><span class="koboSpan" id="kobo.631.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">tar.gz</span></strong><span class="koboSpan" id="kobo.633.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">tar</span></strong><span class="koboSpan" id="kobo.635.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">jar</span></strong><span class="koboSpan" id="kobo.637.1"> file. </span><span class="koboSpan" id="kobo.637.2">This approach is also used for explicit build triggers like the </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">previous one.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.639.1">Now, let’s register the application, Spring Pet Clinic, to be used with TBS, along with its Git repository. </span><span class="koboSpan" id="kobo.639.2">See the following command and its results, which explain how to do this. </span><span class="koboSpan" id="kobo.639.3">The command uses the application’s Git repository and the branch that we want TBS to monitor for changes and build container </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">images from:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.641.1">
$ kp image create tbs-spring-petclinic --tag </span><strong class="bold"><span class="koboSpan" id="kobo.642.1">p********t</span></strong><span class="koboSpan" id="kobo.643.1">/tbs-spring-petclinic:1.0 --wait --git  </span><strong class="bold"><span class="koboSpan" id="kobo.644.1">https://github.com/PacktPublishing/DevSecOps-in-Practice-with-VMware-Tanzu/tree/main/spring-petclinic</span></strong><span class="koboSpan" id="kobo.645.1"> --git-revision </span><strong class="bold"><span class="koboSpan" id="kobo.646.1">main</span></strong></pre>
<p><span class="koboSpan" id="kobo.647.1">In this command, replace the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">--git</span></strong><span class="koboSpan" id="kobo.649.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">--git-revision</span></strong><span class="koboSpan" id="kobo.651.1"> with the repository details that you would </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">have forked.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.653.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.654.1">This command may take several minutes to run since it’s the first build and application registration. </span><span class="koboSpan" id="kobo.654.2">Also, it assumes that the Git repository is publicly accessible. </span><span class="koboSpan" id="kobo.654.3">But if the repository requires user credentials to pull the source code, you may need to create a TBS </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">secret</span></strong><span class="koboSpan" id="kobo.656.1"> object for the Git repository credentials, as described </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">here: </span></span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-secrets.html#create-a-git-ssh-secret"><span class="No-Break"><span class="koboSpan" id="kobo.658.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-secrets.html#create-a-git-ssh-secret</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.659.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">As you can see, this </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.661.1">command performs several operations, including accessing the application’s source code, downloading all required dependencies, performing all CNB life cycle stages, and finally, pushing the application image into your Docker Hub registry, as specified in </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the command.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">Let’s check the presence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">image</span></strong><span class="koboSpan" id="kobo.665.1"> objects for </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">our application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.667.1">
$ kp image list
NAME                    READY    LATEST REASON    LATEST IMAGE                                                     NAMESPACE
tbs-spring-petclinic    True     CONFIG           index.docker.io/p********t/tbs-spring-petclinic@sha256:45688e54b22ee96e798f3f28e09a81020acc69fa0db806690aeb2ba07ae3ab00    default</span></pre>
<p><span class="koboSpan" id="kobo.668.1">Here, we can see that one </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">image</span></strong><span class="koboSpan" id="kobo.670.1"> object has been created called </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">tbs-spring-petclinic</span></strong><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">Now, let’s check the number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">build</span></strong><span class="koboSpan" id="kobo.674.1"> objects that have been created for </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">our application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.676.1">
$ kp build list
BUILD    STATUS     BUILT IMAGE                                                     REASON    IMAGE RESOURCE
1        SUCCESS    index.docker.io/p********t/tbs-spring-petclinic@sha256:45688e54b22ee96e798f3f28e09a81020acc69fa0db806690aeb2ba07ae3ab00    CONFIG    tbs-spring-petclinic</span></pre>
<p><span class="koboSpan" id="kobo.677.1">Here, we can see one </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">build</span></strong><span class="koboSpan" id="kobo.679.1"> object created for our application </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">image</span></strong><span class="koboSpan" id="kobo.681.1"> object. </span><span class="koboSpan" id="kobo.681.2">We may see more </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">build</span></strong><span class="koboSpan" id="kobo.683.1"> objects if there were a greater number of image builds triggered for application</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.684.1"> changes. </span><span class="koboSpan" id="kobo.684.2">The column named </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">REASON</span></strong><span class="koboSpan" id="kobo.686.1"> indicates the reason to get this build triggered by TBS. </span><span class="koboSpan" id="kobo.686.2">There are the following </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">possible reasons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.688.1">CONFIG</span></strong><span class="koboSpan" id="kobo.689.1"> to indicate when a change is made to commit, branch, Git repository, or build fields on the image’s </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">configuration file</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.691.1">COMMIT</span></strong><span class="koboSpan" id="kobo.692.1"> to indicate a build as a result of a change pushed in an application’s code repository under </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">TBS’s watch</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.694.1">STACK</span></strong><span class="koboSpan" id="kobo.695.1"> to indicate a change in the run image </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">OS layer</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.697.1">BUILDPACK</span></strong><span class="koboSpan" id="kobo.698.1"> to indicate a change in the buildpack versions that are made available through an </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">updated builder</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.700.1">TRIGGER</span></strong><span class="koboSpan" id="kobo.701.1"> to indicate a build </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">triggered manually</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.703.1">Now that the application has been registered with TBS, when you commit a small change in the monitored branch, you should see a new build getting created in a few seconds, as </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.705.1">
$ kp build list
BUILD    STATUS      BUILT IMAGE                                                              REASON    IMAGE RESOURCE
1        SUCCESS     index.docker.io/p********t/tbs-spring-petclinic@sha256:45688e54b22ee96e798f3f28e09a81020acc69fa0db806690aeb2ba07ae3ab00    CONFIG    tbs-spring-petclinic
2        BUILDING                                  COMMIT    tbs-spring-petclinic</span></pre>
<p><span class="koboSpan" id="kobo.706.1">You may now pull the old and the new images to deploy their containers within your local Docker environment to verify the changes that have been made to the application. </span><span class="koboSpan" id="kobo.706.2">Now that we’ve </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.707.1">learned how to create new builds of the container images for the registered applications, let’s learn how to check the build logs to see the execution details of the life </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">cycle stages.</span></span></p>
<h3><span class="koboSpan" id="kobo.709.1">Checking image build logs</span></h3>
<p><span class="koboSpan" id="kobo.710.1">To check </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.711.1">the TBS logs of the newly built image, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.713.1">
$ kp build logs tbs-spring-petclinic
..
</span><span class="koboSpan" id="kobo.713.2">..
</span><span class="koboSpan" id="kobo.713.3">Saving p********t/tbs-spring-petclinic:1.0...
</span><span class="koboSpan" id="kobo.713.4">*** Images (sha256:322010cd44fa9dc3bcb0bfadc7ba6873fb65f1bfe4f0bbe6cf6dc9d4e3112e84):
      p********t/tbs-spring-petclinic:1.0
      index.docker.io/p********t/tbs-spring-petclinic:1.0-b2.20211213.072737
===&gt; COMPLETION
Build successful</span></pre>
<p><span class="koboSpan" id="kobo.714.1">The output has been truncated </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">for brevity.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">With that, we’ve learned how to create the first application configuration, trigger a new build, and check build logs on TBS. </span><span class="koboSpan" id="kobo.716.2">Now, let’s discuss another very important activity around TBS, which is to keep our container images always secured and patched with the latest versions of the software libraries and operating system layers used in the application </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">container images.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.718.1">Upgrading buildpacks and stacks</span></h2>
<p><span class="koboSpan" id="kobo.719.1">As we </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.720.1">saw </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.721.1">in the </span><em class="italic"><span class="koboSpan" id="kobo.722.1">Why Tanzu Build Service</span></em><span class="koboSpan" id="kobo.723.1"> section, one of the main benefits </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.724.1">of </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.725.1">using this tool is to enhance the security posture by staying up to date using the latest patched application dependencies and the OS layer used to build container images. </span><span class="koboSpan" id="kobo.725.2">As we know, buildpacks contain references to different software library versions and stacks contain the OS layers for the container image building. </span><span class="koboSpan" id="kobo.725.3">So, when there are new patch releases of the libraries that are referenced in the buildpacks or the OS in the stacks, VMware releases a new version of the impacted buildpacks and stacks to provide the latest patched version of the software that </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">they reference.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">The most recommended way to stay up to date with TBS component versions is to enable the automatic update ability that TBS is equipped with. </span><span class="koboSpan" id="kobo.727.2">When we deploy TBS with our Tanzu Network account credentials, TBS deploys a CRD object in our Kubernetes cluster</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.728.1"> named </span><strong class="bold"><span class="koboSpan" id="kobo.729.1">TanzuNetDependencyUpdater</span></strong><span class="koboSpan" id="kobo.730.1">. </span><span class="koboSpan" id="kobo.730.2">This CRD object is responsible for keeping our TBS components up to date automatically. </span><span class="koboSpan" id="kobo.730.3">We used the same approach in our installation, which we performed earlier in this chapter. </span><span class="koboSpan" id="kobo.730.4">You can verify this setup by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.732.1">
$ kubectl get TanzuNetDependencyUpdater -A
NAMESPACE       NAME                 DESCRIPTORVERSION   READY
build-service   dependency-updater   100.0.240           True</span></pre>
<p><span class="koboSpan" id="kobo.733.1">Here, the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">DESCRIPTIONVERSION</span></strong><span class="koboSpan" id="kobo.735.1"> may be different, depending on the latest available release of the description file that you would have downloaded as a part of the prerequisites at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">If the automatic update was not enabled during the installation process, then the following link shows how to enable it post-installation or how to manually update various components to retain more control over time and the impact of the </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">changes: </span></span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-updating-deps.html"><span class="No-Break"><span class="koboSpan" id="kobo.739.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-updating-deps.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.740.1">.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.741.1">Managing images and builds</span></h2>
<p><span class="koboSpan" id="kobo.742.1">There are </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.743.1">various day-to-day operations that we may need to perform to work with the application configuration, in the form of image objects, and their corresponding build processes, created in the form of build objects, that are triggered for different possible reasons we saw earlier, including STACK, BUILDPACK, CONFIG, COMMIT, and TRIGGER. </span><span class="koboSpan" id="kobo.743.2">You can learn more about such operations at </span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-images.html"><span class="koboSpan" id="kobo.744.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-images.html</span></a><span class="koboSpan" id="kobo.745.1">. </span><span class="koboSpan" id="kobo.745.2">Additionally, TBS keeps the last 10 successful and failed pieces of build history information, including their completed pods and hence the logs for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">Image</span></strong><span class="koboSpan" id="kobo.747.1"> resource. </span><span class="koboSpan" id="kobo.747.2">Such historical builds help you obtain historical logs and details but also occupy a lot of storage space on the cluster. </span><span class="koboSpan" id="kobo.747.3">In a large enterprise-scale environment, it could impact more because of several </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">Image</span></strong><span class="koboSpan" id="kobo.749.1"> resources being created. </span><span class="koboSpan" id="kobo.749.2">You may refer to this documentation if you want to change the default configuration of 10 historical builds to a different </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">number: </span></span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-faq.html#faq-18"><span class="No-Break"><span class="koboSpan" id="kobo.751.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-faq.html#faq-18</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.752.1">.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.753.1">Configuring role-based access controls</span></h2>
<p><span class="koboSpan" id="kobo.754.1">It is recommended</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.755.1"> to</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.756.1"> install TBS on a Kubernetes cluster that is dedicated to such platform services that are different from the cluster running actual business workloads. </span><span class="koboSpan" id="kobo.756.2">Such supporting services clusters are under the control of a specific user group of platform operators. </span><span class="koboSpan" id="kobo.756.3">Such cluster-level separation is one good way to selectively allow users to access TBS in the first place. </span><span class="koboSpan" id="kobo.756.4">An accidental change in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">ClusterBuilder</span></strong><span class="koboSpan" id="kobo.758.1"> definition may cause a trigger to build possibly hundreds of container images for the applications that are linked with that </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">ClusterBuilder</span></strong><span class="koboSpan" id="kobo.760.1">. </span><span class="koboSpan" id="kobo.760.2">And if there is an automated deployment pipeline in place that deploys new versions of all the applications with the new container images, then such a mistake could be even more severe. </span><span class="koboSpan" id="kobo.760.3">That is why putting the required guardrail around TBS is very important. </span><span class="koboSpan" id="kobo.760.4">For that reason, TBS provides some level of access control using two Kubernetes ClusterRoles, </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">build-service-user-role</span></strong><span class="koboSpan" id="kobo.763.1">: To allow working with images and </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">build resources</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">build-service-admin-role</span></strong><span class="koboSpan" id="kobo.766.1">: To allow all other administrative activities </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">on TBS</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.768.1">The TBS users with access to images and builds should create these objects in their respective Kubernetes namespace to restrict access to these objects to the members of the same namespace. </span><span class="koboSpan" id="kobo.768.2">This way, we can combine the power of Kubernetes access control capabilities for greater control. </span><span class="koboSpan" id="kobo.768.3">You may find more details on how to configure these </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.769.1">permissions </span><a id="_idIndexMarker159"/><span class="No-Break"><span class="koboSpan" id="kobo.770.1">here: </span></span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-tbs-with-projects.html#rbac-support-in-tanzu-build-service"><span class="No-Break"><span class="koboSpan" id="kobo.771.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-tbs-with-projects.html#rbac-support-in-tanzu-build-service</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.772.1">.</span></span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.773.1">Upgrading TBS to a newer version</span></h2>
<p><span class="koboSpan" id="kobo.774.1">Upgrading TBS to </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.775.1">a newer version is very simple. </span><span class="koboSpan" id="kobo.775.2">You just need to perform the same steps that we walked through for the installation process other than re-importing the dependencies if they’re </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">not required.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.777.1">Uninstalling TBS</span></h2>
<p><span class="koboSpan" id="kobo.778.1">To uninstall TBS </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.779.1">from your Kubernetes cluster, just run the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">kapp</span></strong><span class="koboSpan" id="kobo.781.1"> command; it will delete all TBS objects from your cluster other than the container images created by TBS. </span><span class="koboSpan" id="kobo.781.2">This command is very destructive and should be used with </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">extreme caution:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.783.1">
$ kapp delete -a tanzu-build-service</span></pre>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.784.1">Customizing buildpacks</span></h2>
<p><span class="koboSpan" id="kobo.785.1">TBS is built with </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.786.1">a very modular, customizable, and </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.787.1">extendable architecture. </span><span class="koboSpan" id="kobo.787.2">It allows us to perform various custom changes, such as including new buildpacks, changing buildpack order, adding new OS layers, and many more. </span><span class="koboSpan" id="kobo.787.3">You may learn more about such customizations using the </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">following references:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.789.1">Managing </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">ClusterStores</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">: </span></span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stores.html"><span class="No-Break"><span class="koboSpan" id="kobo.792.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stores.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.793.1">Managing </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">ClusterStacks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">: </span></span><a href="https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stacks.html"><span class="No-Break"><span class="koboSpan" id="kobo.796.1">https://docs.vmware.com/en/Tanzu-Build-Service/1.3/vmware-tanzu-build-service/GUID-managing-stacks.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.797.1">Creating and managing </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">buildpacks: </span></span><a href="https://buildpacks.io/docs/buildpack-author-guide/"><span class="No-Break"><span class="koboSpan" id="kobo.799.1">https://buildpacks.io/docs/buildpack-author-guide/</span></span></a></li>
</ul>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.800.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.801.1">In this chapter, we learned about different problems around building secured container images for our applications and how TBS targets them with different capabilities. </span><span class="koboSpan" id="kobo.801.2">Later, we took a deep dive into the full anatomy of TBS to understand all its building blocks. </span><span class="koboSpan" id="kobo.801.3">After that, we walked through the installation process of TBS to get started with it. </span><span class="koboSpan" id="kobo.801.4">And finally, we saw how to perform various key operations on TBS. </span><span class="koboSpan" id="kobo.801.5">Using a solution such as TBS that is based on CNB is one of the most recommended approaches suggested by CNCF, and now, we can appreciate why that is </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">the case.</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">In any Kubernetes environment, we deploy two different types of container images – either they belong to our application or a third-party software. </span><span class="koboSpan" id="kobo.803.2">Now that we’ve learned how to build secured container images for our applications using an out-of-box automation tool, in the next chapter, we will learn how to consume secured container images of popular open source software to provide backing services to </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">our applications.</span></span></p>
</div>
</body></html>