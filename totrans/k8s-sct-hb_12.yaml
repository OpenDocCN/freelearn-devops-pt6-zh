- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Integrating with Secret Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与秘密存储集成
- en: 'Kubernetes provides a basic system for managing Secrets, but it is not typically
    seen as secure enough for sensitive data such as passwords, tokens, or keys, especially
    in production settings. To address this, integrating advanced Secrets management
    tools into Kubernetes is vital. These tools enhance security through encryption
    and offer centralized management of sensitive information. This surpasses the
    native capabilities of Kubernetes Secrets, leading to a more robust and compliant
    security stance. In this chapter, you will learn how to integrate Secrets management
    tools with Kubernetes. The chapter will cover how to configure external secret
    stores in Kubernetes and explore the different types of external secret stores
    that can be used. You will gain an understanding of the security implications
    of using external secret stores and how to use them to store sensitive data using
    different approaches such as init containers, sidecars, CSI drivers, operators,
    and sealed Secrets. The chapter will also cover the best practices for using external
    secret stores and how they can impact the overall security of a Kubernetes cluster.
    In this chapter, we’re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一个基本的系统来管理 Secrets，但通常不被认为足够安全，尤其是在生产环境中处理密码、令牌或密钥等敏感数据时。为了解决这个问题，将先进的秘密管理工具集成到
    Kubernetes 中变得至关重要。这些工具通过加密增强了安全性，并提供了敏感信息的集中管理。它们超越了 Kubernetes Secrets 的原生功能，使得安全性更加强大和合规。本章将讲解如何将秘密管理工具与
    Kubernetes 集成。内容包括如何在 Kubernetes 中配置外部秘密存储，以及可用的不同类型的外部秘密存储。你将了解使用外部秘密存储的安全性影响，并学习如何通过不同的方法，如
    init 容器、sidecar、CSI 驱动程序、操作员和封印的 Secrets，来存储敏感数据。本章还将涵盖使用外部秘密存储的最佳实践，以及它们如何影响
    Kubernetes 集群的整体安全性。本章我们将涉及以下主要主题：
- en: Configuring external secret stores in Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中配置外部秘密存储
- en: Integrating with external secret stores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部秘密存储的集成
- en: Security implications and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性影响与最佳实践
- en: Practical and theoretical balance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际与理论的平衡
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To link concepts with hands-on examples, we are leveraging a series of tools
    and platforms commonly used to interact with external Secrets management and Kubernetes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将概念与实际操作示例结合，我们将使用一系列常用于与外部秘密管理和 Kubernetes 交互的工具和平台：
- en: '**minikube**: It runs a single-node Kubernetes cluster inside a **virtual machine**
    (**VM**) on your computer. Get it set up using the guide at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minikube**：它在你的计算机上通过**虚拟机**（**VM**）运行一个单节点的 Kubernetes 集群。可以通过 [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    的指南进行设置。'
- en: '**Helm**: This is a package manager for Kubernetes that will simplify deployments.
    Check out the Helm installation guide for setup instructions at [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm**：这是一个 Kubernetes 的包管理工具，可以简化部署过程。有关安装的指南，可以查看 [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)。'
- en: '**kubectl**: This is the Kubernetes command-line tool. Instructions for its
    installation are available at [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl**：这是 Kubernetes 的命令行工具。安装指南可以在 [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    找到。'
- en: '**External Secrets management tool**: While various tools can be utilized for
    the purpose of our demonstrations, it’s recommended to have Hashicorp Vault. The
    official guide for its installation is found at [https://www.vaultproject.io/docs/install](https://www.vaultproject.io/docs/install).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部秘密管理工具**：虽然可以使用多种工具进行演示，但建议使用 Hashicorp Vault。它的官方安装指南可以在 [https://www.vaultproject.io/docs/install](https://www.vaultproject.io/docs/install)
    找到。'
- en: Integrating secret stores with Kubernetes
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密存储与 Kubernetes 集成
- en: As we’ve explored in previous chapters, Kubernetes has its own Secrets management
    capabilities. However, when operating at scale or with specific security requirements,
    the native Kubernetes Secrets may fall short. The sheer diversity of Secrets management
    tools available, as previously discussed, alludes to this need. But why integrate
    them with Kubernetes?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中探讨的那样，Kubernetes 本身具备秘密管理功能。然而，在大规模操作或特定的安全需求下，原生的 Kubernetes Secrets
    可能会有所不足。之前讨论过的各种秘密管理工具的多样性，正是暗示了这一需求。但为什么要将它们与 Kubernetes 集成呢？
- en: 'Integrating third-party tools with Kubernetes offers the following benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将第三方工具与 Kubernetes 集成带来以下好处：
- en: '**Operational consistency**: For organizations that already use tools for applications
    outside Kubernetes, integration provides a uniform Secrets management experience
    across the board.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作一致性**：对于已经在 Kubernetes 外使用工具的组织，集成提供了一个统一的秘密管理体验。'
- en: '**Enhanced security features**: Many external tools offer advanced features
    such as secret rotation, granular access controls, and multi-layered encryption
    methods that aren’t readily available or require additional configurations in
    native Kubernetes.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的安全特性**：许多外部工具提供了高级功能，如秘密轮换、细粒度的访问控制和多层加密方法，这些功能在 Kubernetes 原生环境中并不容易获得，或者需要额外配置。'
- en: '**Scalability and performance**: At scale, the management of a large number
    of Secrets may become complex using only Kubernetes native Secrets. External tools,
    designed for high-volume operations, can effectively address this.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和性能**：在大规模环境中，仅使用 Kubernetes 原生的 Secrets 管理大量秘密可能变得复杂。为高容量操作设计的外部工具可以有效应对这一挑战。'
- en: '**Advanced audit trails**: In an environment of tougher regulations and increasing
    cyber threats, having a thorough audit capability is essential, not a luxury.
    Many tools come equipped with comprehensive logging and alerting functions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级审计追踪**：在日益严格的法规和增加的网络威胁环境中，拥有一个全面的审计能力至关重要，而非奢侈。许多工具配备了完整的日志记录和警报功能。'
- en: '**Detailed audit capabilities**: These capabilities ensure regulatory compliance,
    improve security, increase accountability, detect unusual activities, support
    informed decision-making, provide legal evidence, enhance operational efficiency,
    build customer trust, reduce insider threats, and enable historical analysis for
    future improvements.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细的审计能力**：这些能力确保合规性，提升安全性，增加责任追踪，检测异常活动，支持基于信息的决策，提供法律证据，增强操作效率，建立客户信任，减少内部威胁，并为未来的改进提供历史分析。'
- en: '**Cross-platform compatibility**: With the rise of hybrid and multi-cloud strategies,
    secret managers can offer consistent Secrets management across different cloud
    platforms, making it easier to manage Secrets in such heterogeneous environments.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台兼容性**：随着混合云和多云策略的兴起，秘密管理器可以在不同的云平台之间提供一致的 Secrets 管理，使得在这些异构环境中管理 Secrets
    更加简便。'
- en: While we’ve recognized the capabilities of various cloud secret stores and third-party
    secret stores in previous chapters, this chapter aims to bridge the gap to focus
    on integration. The primary focus is to showcase how these secret stores can be
    seamlessly integrated with Kubernetes, leveraging the best of both worlds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在前面的章节中已经认识到各种云秘密存储和第三方秘密存储的能力，本章旨在弥补这一差距，专注于集成。主要的焦点是展示这些秘密存储如何与 Kubernetes
    无缝集成，充分利用两者的优势。
- en: Through the subsequent sections, we’ll dive deep into the mechanics of these
    integrations, offering both a theoretical and practical understanding. Each method,
    from Kubernetes extensions to Pod lifecycle mechanisms, will illustrate different
    strategies and approaches for this integration. By the end of this chapter, our
    goal is to provide you with a robust set of strategies and insights, empowering
    you to make choices that align seamlessly with your unique operational requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过后续章节，我们将深入探讨这些集成的机制，提供理论与实践的双重理解。从 Kubernetes 扩展到 Pod 生命周期机制，每种方法都将展示不同的集成策略和方法。到本章结束时，我们的目标是为您提供一套强大的策略和见解，帮助您做出与独特操作需求无缝对接的选择。
- en: Configuring external secret stores in Kubernetes
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中配置外部秘密存储
- en: The decentralized nature of Kubernetes and its dynamic workloads necessitate
    a robust Secrets management solution. This section provides insights into the
    general configuration process and delineates two predominant paradigms for secret
    consumption within Kubernetes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的去中心化特性和动态工作负载要求有一个强大的秘密管理解决方案。本节提供了关于一般配置过程的见解，并阐明了在 Kubernetes
    中使用秘密的两种主要范式。
- en: 'The following are the general configuration steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一般的配置步骤：
- en: '**Selection of secret store**: Begin by choosing a Secrets management tool
    that suits organizational needs, factoring in aspects such as security requirements,
    scalability, compliance standards, team familiarity, and more. Options abound,
    ranging from cloud-native solutions such as AWS/GCP Secrets Manager and Azure
    Key Vault to tools such as HashiCorp Vault and CyberArk.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择秘钥存储**：首先选择一个适合组织需求的 Secrets 管理工具，考虑安全需求、可扩展性、合规标准、团队熟悉度等因素。可选的方案非常多，包括云原生解决方案，如
    AWS/GCP Secrets Manager 和 Azure Key Vault，也有诸如 HashiCorp Vault 和 CyberArk 等工具。'
- en: '**Initialization and connecting to Kubernetes**: Once the secret store is selected,
    proceed with its initialization. Deploy it either within the Kubernetes cluster
    or alongside it based on architectural preferences, ensuring smooth connectivity
    between the store and Kubernetes.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化并连接到 Kubernetes**：一旦选择了秘钥存储，就开始其初始化。根据架构偏好，将其部署在 Kubernetes 集群内部或旁边，确保秘钥存储与
    Kubernetes 之间的顺畅连接。'
- en: '**Handle authentication and authorization**: Establish robust and secure communication
    channels between Kubernetes and the secret store. Mechanisms could encompass IAM
    roles, tokens, service accounts, or client certificates. Concurrently, put in
    place fine-grained authorization controls to ensure that only entitled services
    or applications access designated Secrets.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理认证与授权**：在 Kubernetes 和秘钥存储之间建立强大且安全的通信渠道。机制可以包括 IAM 角色、令牌、服务帐户或客户端证书。同时，建立精细的授权控制，确保只有授权的服务或应用访问指定的
    Secrets。'
- en: '**Determine secret retrieval and consumption method**: Delve into how the Secrets
    will be consumed. Decide if Secrets from the external store will be converted
    into native Kubernetes Secrets or if they will be fetched directly from the external
    store when required.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定秘钥获取与使用方式**：深入探讨 Secrets 将如何被使用。决定是否将外部存储中的 Secrets 转换为原生 Kubernetes Secrets，或者在需要时直接从外部存储中提取。'
- en: '**Test the configuration**: Before rolling out the integration in a production
    environment, conduct thorough testing. Verify secret retrieval, consumption, and
    other configured functionalities to ensure they operate as intended.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试配置**：在将集成应用到生产环境之前，进行全面测试。验证密钥的获取、使用以及其他已配置的功能，确保它们按预期工作。'
- en: '**Monitor and auditing**: As the final step, implement monitoring mechanisms
    to oversee access to Secrets. Augment this with logging and auditing tools to
    swiftly detect unauthorized access attempts or potential breaches.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控与审计**：作为最后一步，实施监控机制来监督对 Secrets 的访问。并通过日志记录和审计工具增强这一过程，快速发现未经授权的访问尝试或潜在的安全漏洞。'
- en: Completing these general configuration steps lays a strong foundation for secure
    and efficient Secrets management within your Kubernetes environment. With the
    secret store now integrated, authenticated, and authorized, you’re set to proceed
    to the next phase, ensuring a seamless and secure consumption of Secrets by your
    applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些通用配置步骤为在 Kubernetes 环境中实现安全高效的 Secrets 管理奠定了坚实的基础。现在，秘钥存储已经集成、认证并授权，您可以继续进入下一阶段，确保应用程序能够无缝且安全地使用
    Secrets。
- en: Secret consumption in Kubernetes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 中的秘钥消费
- en: 'When integrating an external secret store, two primary paradigms dominate secret
    consumption within Kubernetes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成外部秘钥存储时，有两种主要模式主导了 Kubernetes 中的密钥使用：
- en: '**Convert to native Kubernetes Secrets**: Translating Secrets from external
    stores into native Kubernetes Secrets allows the leveraging of Kubernetes-native
    methods for Secrets management and access. It provides the benefit of caching,
    minimizing the need for frequent external requests. Additionally, it eliminates
    a critical point of failure. However, there are challenges such as redundancy
    and ensuring synchronization between the two secret storage locations.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为原生 Kubernetes Secrets**：将外部存储中的 Secrets 转换为原生 Kubernetes Secrets 使您能够利用
    Kubernetes 原生的方法进行 Secrets 管理和访问。这带来了缓存的好处，减少了频繁外部请求的需求。此外，它还消除了一个关键的故障点。然而，也存在诸如冗余和确保两个秘钥存储位置之间同步等挑战。'
- en: '**Directly fetch from external store**: Directly retrieving Secrets ensures
    applications get the most recent versions, cutting down on the need to synchronize.
    It also leads to a cleaner audit trail. Nevertheless, this method might introduce
    latency due to external fetch operations and create a direct dependency on the
    external store.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接从外部存储中获取**：直接检索机密确保应用程序能够获取到最新的版本，减少了同步的需求，同时也能保持更清晰的审计记录。然而，这种方法可能会由于外部获取操作而引入延迟，并且会对外部存储产生直接依赖。'
- en: To summarize, the process of configuring an external secret store in Kubernetes
    is fundamental to constructing a scalable and secure cloud-native infrastructure.
    A clear comprehension of the configuration steps and the various paradigms of
    secret consumption sets the stage for an effective Secrets management strategy.
    Future sections will provide a more in-depth exploration of these topics and the
    accompanying mechanisms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在 Kubernetes 中配置外部机密存储的过程是构建可扩展、安全的云原生基础设施的基础。清楚理解配置步骤和各种机密消费方式为制定有效的机密管理策略奠定了基础。未来的章节将更深入地探讨这些主题及其相关机制。
- en: Integrating with external secret stores
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部机密存储集成
- en: The integration of external secret stores with Kubernetes is a critical component
    of securing your applications and protecting sensitive data. This section explores
    various mechanisms and patterns that can be used to seamlessly integrate external
    secret stores with your Kubernetes clusters, enhancing security and management
    efficiency.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部机密存储与 Kubernetes 集成是保护应用程序和敏感数据的关键组成部分。本节探讨了可以无缝将外部机密存储与 Kubernetes 集群集成的各种机制和模式，从而增强安全性和管理效率。
- en: Kubernetes extensions and API mechanisms
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 扩展和 API 机制
- en: Kubernetes provides a variety of extensions and API mechanisms that can be leveraged
    to connect and interact with external secret stores. In this part, we will delve
    into the available options and guide you on how to utilize them effectively for
    Secrets management.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了各种扩展和 API 机制，可以利用它们与外部机密存储进行连接和交互。在本部分，我们将深入探讨可用选项，并指导你如何有效地利用它们进行机密管理。
- en: Admission controllers and mutating webhooks for Secrets in Kubernetes
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的准入控制器和变异 webhook 用于机密管理
- en: Kubernetes provides a rich set of tools for controlling and modifying behavior
    within its environment. Among them, *admission controllers* and *mutating webhooks*
    play a pivotal role in enhancing the operational and security aspects of Kubernetes
    clusters. Especially when it comes to Secrets management, these tools can be game-changing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一整套工具，用于控制和修改其环境中的行为。其中，*准入控制器*和*变异 webhook*在增强 Kubernetes 集群的操作和安全性方面发挥了至关重要的作用。特别是在机密管理方面，这些工具可能会带来革命性的变化。
- en: Admission controllers are parts of the Kubernetes control plane that govern
    and enforce how the cluster is used. They intercept requests to the Kubernetes
    API server before the persistence of the object but after the request is authenticated
    and authorized. By doing so, admission controllers have the ability to take specific
    actions, such as rejecting a request or modifying the object before it’s stored.
    There are several built-in admission controllers, but for specific requirements
    such as Secrets management, you might need custom controllers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制器是 Kubernetes 控制平面的一部分，负责管理和执行集群的使用方式。它们会在对象持久化之前、但在请求被认证和授权之后，拦截对 Kubernetes
    API 服务器的请求。通过这样做，准入控制器能够采取特定行动，例如拒绝请求或在存储之前修改对象。有几个内置的准入控制器，但对于像机密管理这样的特定需求，你可能需要自定义控制器。
- en: Mutating webhooks come into play when we want the flexibility provided by admission
    controllers but with custom logic. They allow you to run custom code (or a custom
    function) when specific resources are created or modified. This is incredibly
    valuable for Secrets management, as you can programmatically modify Kubernetes
    resources; for example, you can inject secret references into Pods at the time
    of creation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要由准入控制器提供的灵活性，但又需要自定义逻辑时，变异 webhook 就会发挥作用。它们允许你在创建或修改特定资源时运行自定义代码（或自定义函数）。这对机密管理非常有价值，因为你可以以编程方式修改
    Kubernetes 资源；例如，你可以在 Pod 创建时注入机密引用。
- en: Consider a scenario where you don’t want developers to explicitly define Secrets
    within the manifest. Using a mutating webhook, you can set up a system where developers
    only specify a label or annotation. The webhook then intercepts the Pod creation
    request, identifies the label or annotation, and injects the required secret reference,
    thus abstracting away the direct interaction with Secrets.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个场景，你不希望开发者在清单中显式地定义 Secrets。通过使用变更 webhook，你可以建立一个系统，开发者只需要指定标签或注释。Webhook
    会拦截 Pod 创建请求，识别标签或注释，并注入所需的 secret 引用，从而抽象化了与 Secrets 的直接交互。
- en: 'Here’s an illustrative example of setting up a mutating webhook for secret
    injection:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置用于 Secret 注入的变更 webhook 的示例：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down this configuration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个配置：
- en: The webhook is named `secret-injector.example.com`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 webhook 被命名为 `secret-injector.example.com`。
- en: The `clientConfig` specifies the service that handles the webhook. In this case,
    the service is named `secret-injector-service`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clientConfig` 指定了处理 webhook 的服务。在这种情况下，服务名为 `secret-injector-service`。'
- en: The `rules` section defines when this webhook is invoked. Here, it’s set up
    to run when a Pod
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rules` 部分定义了何时调用此 webhook。在这里，它设置为在创建 Pod 时运行。'
- en: is created.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已创建。
- en: When a new Pod gets created, the request is intercepted by our webhook. The
    service `secret-injector-service` then processes this request, checks for specific
    labels or annotations, and decides whether to inject secret references.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的 Pod 被创建时，请求会被我们的 webhook 拦截。服务 `secret-injector-service` 然后处理这个请求，检查特定的标签或注释，并决定是否注入
    secret 引用。
- en: The combination of admission controllers and mutating webhooks provides a robust
    mechanism to streamline and enforce best practices for Secrets management. By
    offloading Secrets management concerns to these tools, developers can focus on
    their application logic while ensuring that Secrets are handled in a secure and
    compliant manner.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Admission 控制器和变更 webhook 的结合提供了一种强大的机制，用于简化和强制执行 Secrets 管理的最佳实践。通过将 Secrets
    管理的责任交给这些工具，开发者可以专注于他们的应用逻辑，同时确保 Secrets 以安全和合规的方式处理。
- en: In conclusion, when looking to enhance the Secrets management capabilities within
    your Kubernetes clusters, consider leveraging admission controllers and mutating
    webhooks. They not only help maintain the sanctity of the cluster but also automate
    and enforce best practices for handling sensitive data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在希望增强 Kubernetes 集群中的 Secrets 管理功能时，考虑利用 admission 控制器和变更 webhook。它们不仅有助于维护集群的完整性，还能自动化并强制执行处理敏感数据的最佳实践。
- en: Custom resource definitions in Secrets management
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Secrets 管理中的自定义资源定义
- en: Kubernetes allows for the extensibility of its API through the use of **custom
    resource definitions** (**CRDs**). CRDs empower cluster operators to introduce
    new resource types in Kubernetes without the need to modify the core Kubernetes
    code base. When dealing with Secrets, especially those stored outside of a Kubernetes
    cluster in external systems such as AWS Secrets Manager or HashiCorp Vault, CRDs
    can offer a more Kubernetes-native approach to managing and accessing them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过使用 **自定义资源定义**（**CRDs**）允许其 API 的扩展性。CRDs 使集群操作员能够在 Kubernetes
    中引入新的资源类型，而无需修改 Kubernetes 核心代码库。在处理 Secrets，尤其是那些存储在 Kubernetes 集群外部的系统（如 AWS
    Secrets Manager 或 HashiCorp Vault）中的 Secrets 时，CRDs 可以提供一种更符合 Kubernetes 原生方式的管理和访问方法。
- en: Defining an ExternalSecret CRD
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 ExternalSecret CRD
- en: 'A CRD definition for an external secret might look something like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 secret 的 CRD 定义可能如下所示：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you’ve defined the CRD, the next logical step is to create instances of
    this new resource type (`ExternalSecret`). However, just defining and creating
    the CRD doesn’t give it functionality. To make the `ExternalSecret` resource meaningful,
    you need a custom controller that understands how to interpret and act upon these
    resources.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了 CRD，下一步就是创建这个新资源类型（`ExternalSecret`）的实例。然而，仅仅定义和创建 CRD 并不能赋予其功能。为了使 `ExternalSecret`
    资源有意义，你需要一个自定义控制器来理解如何解读和操作这些资源。
- en: Using the ExternalSecret CRD
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 ExternalSecret CRD
- en: 'Assuming you have a secret named `database-password` stored in AWS Secrets
    Manager, you might define an `ExternalSecret` resource that references it as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 `database-password` 的 secret 存储在 AWS Secrets Manager 中，你可能会定义一个引用它的
    `ExternalSecret` 资源，内容如下：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s a breakdown of this resource:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个资源的分解：
- en: '`metadata.name`: This is the name assigned to this `ExternalSecret` within
    Kubernetes. It doesn’t necessarily have to match the name in AWS Secrets Manager.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.name`：这是Kubernetes中分配给该`ExternalSecret`的名称。它不必与AWS Secrets Manager中的名称完全匹配。'
- en: '`spec.backendType`: This denotes the external Secrets manager to use; in this
    case, it’s AWS Secrets Manager.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.backendType`：表示要使用的外部Secrets管理器；在此情况下，是AWS Secrets Manager。'
- en: '`spec.data`: This is a list that indicates the Secrets to fetch.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.data`：这是一个列表，指示要获取的密钥。'
- en: '`key`: This is the name or identifier of the secret in AWS Secrets Manager.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：这是在AWS Secrets Manager中密钥的名称或标识符。'
- en: '`name`: This is the name the secret will take when presented to Kubernetes
    Pods.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是密钥在呈现给Kubernetes Pods时的名称。'
- en: '`spec.region`: This specifies the AWS region where the secret resides.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.region`：指定存储密钥的AWS区域。'
- en: 'Upon applying the following resource:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用以下资源后：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A custom controller observing `ExternalSecret` resources would do the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个观察`ExternalSecret`资源的自定义控制器将执行以下操作：
- en: Detect the creation of a new `ExternalSecret`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测到新的`ExternalSecret`的创建。
- en: Understand from the specification that it should communicate with the AWS Secrets
    Manager in the `us-west-1` region.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从规格中理解它应与`us-west-1`区域的AWS Secrets Manager进行通信。
- en: Authenticate with AWS Secrets Manager (assuming it has the necessary permissions).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与AWS Secrets Manager进行身份验证（假设它具有必要的权限）。
- en: Retrieve the `database-password` secret.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`database-password`密钥。
- en: Present this secret to Kubernetes Pods under the name `dbPassword`. This could
    be by creating a native Kubernetes secret, setting it as an environment variable,
    or placing it in a `tmpfs` volume depending on the controller’s design.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此密钥以`dbPassword`的名称展示给Kubernetes Pods。具体方法可以是创建一个本地Kubernetes密钥、将其设置为环境变量，或根据控制器设计将其放入`tmpfs`卷中。
- en: In essence, CRDs combined with custom controllers provide a powerful mechanism
    to extend Kubernetes’s capabilities. For Secrets management, CRDs allow Kubernetes
    to naturally integrate with external secret storage solutions, making the process
    of fetching and using Secrets seamless for end users.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，CRD结合自定义控制器提供了一种强大的机制，来扩展Kubernetes的能力。在密钥管理方面，CRD使得Kubernetes能够自然地与外部密钥存储解决方案集成，使得提取和使用密钥的过程对最终用户无缝化。
- en: 'Kubernetes API extensions: custom API server'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes API扩展：自定义API服务器
- en: Building a custom API server allows us to define our API behaviors, including
    interactions with external secret stores. A Pod can request a secret through the
    custom API, and this API server can fetch it from an external store, process it,
    and return it. However, running and maintaining a custom API server isn’t trivial.
    You’d need to set it up, ensure it’s secure, and potentially handle scaling and
    failover.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个自定义API服务器使我们能够定义API行为，包括与外部密钥存储的交互。Pod可以通过自定义API请求密钥，API服务器可以从外部存储中获取密钥、处理它并返回。然而，运行和维护一个自定义API服务器并不是简单的。你需要设置它，确保它的安全性，并可能处理扩展和故障转移。
- en: 'Please note that this is a simplified example focusing on the conceptual configuration:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个简化的示例，重点讲解概念配置：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For a custom API server to work with the main Kubernetes API server and external
    secret storages, it needs specific settings in its configuration, `custom-api-server-config`.
    This includes how it will verify who is allowed to access it, known as authentication,
    and the rules for how it communicates, called API specifications. Typically, this
    setup uses either service-based or role-based authentication. Service-based authentication
    checks the identity of the service requesting access, while role-based authentication
    looks at the user’s or service’s role to decide access. A common example is using
    IRSA roles in AWS, where Kubernetes services get special permissions to access
    AWS resources securely.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让自定义API服务器能够与主Kubernetes API服务器和外部密钥存储一起工作，它需要在其配置`custom-api-server-config`中进行特定设置。这些设置包括如何验证谁有权限访问，这叫做身份验证，以及如何进行通信的规则，称为API规范。通常，这个设置会使用基于服务的身份验证或基于角色的身份验证。基于服务的身份验证检查请求访问的服务的身份，而基于角色的身份验证则查看用户或服务的角色来决定访问权限。一个常见的例子是使用AWS中的IRSA角色，Kubernetes服务可以安全地访问AWS资源。
- en: This method provides seamless interaction with external secret stores, especially
    for teams more familiar with `kubectl` than with, say, Hashicorp Vault’s CLI.
    By extending the API, users can stay in their familiar environment. However, as
    powerful as it is, just extending the API does not complete the loop. You need
    additional components or procedures to ensure safe and efficient consumption of
    the Secrets by the Pods. This could be through agents, controllers, or other orchestration
    mechanisms that watch for these custom or converted Secrets and make them available
    to Pods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法提供了与外部密钥存储的无缝交互，特别是对于那些更熟悉 `kubectl` 而不是 Hashicorp Vault CLI 的团队。通过扩展 API，用户可以保持在熟悉的环境中。然而，尽管
    API 扩展非常强大，单靠扩展 API 并不能完成整个过程。你需要额外的组件或流程来确保 Pods 安全高效地使用这些 Secrets。这可以通过代理、控制器或其他编排机制来实现，它们会监控这些自定义或转换后的
    Secrets，并使其可供 Pods 使用。
- en: The Kubernetes extensions and API mechanisms offer a flexible and powerful means
    to integrate external secret stores, providing a variety of options to suit different
    use cases and requirements. Understanding how to leverage these tools is key to
    effective Secrets management within Kubernetes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 扩展和 API 机制提供了一种灵活且强大的方式来集成外部密钥存储，提供多种选项以适应不同的用例和需求。了解如何利用这些工具是有效管理
    Kubernetes 中 Secrets 的关键。
- en: Pod lifecycle and manipulation mechanisms
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 生命周期和管理机制
- en: Managing Secrets throughout the lifecycle of a Pod is essential for maintaining
    security and operational efficiency. This section focuses on the mechanisms that
    Kubernetes provides for injecting and managing Secrets in conjunction with the
    Pod lifecycle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 生命周期中管理 Secrets 对于维护安全性和操作效率至关重要。本节重点介绍 Kubernetes 提供的机制，用于在 Pod 生命周期中注入和管理
    Secrets。
- en: Init containers
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Init 容器
- en: Init containers run before application containers and can be used for setup
    tasks such as fetching Secrets from an external store. If your application needs
    a configuration file populated with Secrets before it starts, an init container
    can fetch those Secrets, populate the configuration, and store it in a shared
    volume.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Init 容器在应用容器之前运行，可用于设置任务，例如从外部存储获取 Secrets。如果你的应用需要在启动之前通过配置文件填充 Secrets，Init
    容器可以获取这些 Secrets，填充配置文件并将其存储在共享卷中。
- en: 'Here’s a sample configuration:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例配置：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By incorporating this sample init container configuration, you can ensure that
    your application has access to the necessary Secrets before it starts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成这个示例 Init 容器配置，你可以确保应用在启动之前就能访问所需的 Secrets。
- en: Sidecars
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sidecar 容器
- en: Sidecars run alongside the main container in a Pod and can be used to dynamically
    manage Secrets during the Pod’s lifecycle. If your application needs to periodically
    refresh its Secrets without restarting, a sidecar can fetch the latest Secrets
    and update a shared configuration or notify the main application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Sidecar 容器与 Pod 中的主容器一起运行，可以用于在 Pod 生命周期期间动态管理 Secrets。如果你的应用需要定期刷新其 Secrets
    而不重启，Sidecar 容器可以获取最新的 Secrets，并更新共享配置或通知主应用。
- en: 'Here’s a sample configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例配置：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sidecars in Kubernetes enhance Secrets management by running alongside the main
    container, enabling dynamic updates of Secrets without needing to restart the
    application, as illustrated in the provided sample configuration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 Sidecar 容器通过与主容器并行运行，增强了 Secrets 管理，使 Secrets 可以动态更新，而无需重启应用，正如提供的示例配置所示。
- en: DaemonSets
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DaemonSets
- en: DaemonSets ensures that all (or some) nodes run a copy of a Pod, making them
    suitable for node-level tasks, such as setting up node-wide Secrets or Secrets
    management tools. If you have a node-level application (for example, a logging
    agent) that requires certain Secrets, you can use a DaemonSet to ensure each node
    fetches its own Secrets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSets 确保所有（或部分）节点运行一个 Pod 的副本，使其适合用于节点级任务，例如设置节点范围的 Secrets 或 Secrets 管理工具。如果你有一个节点级应用（例如，日志代理）需要特定的
    Secrets，可以使用 DaemonSet 确保每个节点获取自己的 Secrets。
- en: 'Here’s a sample configuration:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例配置：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By utilizing DaemonSets for such node-level operations, you ensure a consistent
    and secure distribution of Secrets across your entire Kubernetes cluster.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 DaemonSets 来进行此类节点级操作，你可以确保在整个 Kubernetes 集群中一致且安全地分发 Secrets。
- en: Environment controllers
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境控制器
- en: Different from CRDs, environment controllers don’t seek to expand the Kubernetes
    API. Instead, they dynamically manage environment variables directly within the
    Pod’s context. The advantage is direct integration at the Pod level, avoiding
    the need for additional CRD management or controller infrastructure specific to
    a new CRD. For applications that read Secrets from environment variables, and
    if you want to avoid storing these Secrets in Kubernetes directly, an environment
    controller can fetch and inject these Secrets just before the Pod starts, avoiding
    the need for the application or another container to fetch them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于 CRD，环境控制器并不寻求扩展 Kubernetes API。相反，它们直接在 Pod 的上下文中动态管理环境变量。其优势在于可以在 Pod 层级进行直接集成，避免了需要额外的
    CRD 管理或特定于新 CRD 的控制器基础设施。对于从环境变量读取 Secrets 的应用程序，如果你希望避免直接在 Kubernetes 中存储这些 Secrets，环境控制器可以在
    Pod 启动前获取并注入这些 Secrets，避免了应用程序或其他容器去获取它们的需求。
- en: 'Imagine we’re using a custom controller that watches `EnvSecret` CRD resources.
    Here’s a sample configuration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用了一个自定义控制器，它监控 `EnvSecret` CRD 资源。这里是一个示例配置：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This hypothetical `EnvSecret` CRD resource instructs the controller to fetch
    `db-credentials-in-vault` from an external store and populate it into the `DB_CREDS`
    environment variable for Pods with the label `app: my-app`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '这个假设的 `EnvSecret` CRD 资源指示控制器从外部存储中获取 `db-credentials-in-vault`，并将其填充到标签为 `app:
    my-app` 的 Pods 的 `DB_CREDS` 环境变量中。'
- en: Effectively managing Secrets throughout the Pod lifecycle ensures that applications
    have access to the necessary sensitive information when they need it while maintaining
    a high level of security.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地管理 Secrets 贯穿整个 Pod 生命周期，确保应用程序在需要时能够访问到必要的敏感信息，同时保持高水平的安全性。
- en: Specialized Kubernetes patterns – SealedSecrets
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用的 Kubernetes 模式 – SealedSecrets
- en: '**SealedSecrets** is a Kubernetes controller and tool for one-way encrypted
    Secrets. It’s designed for developers to encrypt a secret and submit it to the
    control plane (typically in a Git repository and through **continuous integration
    and continuous delivery** (**CI/CD**). Kubernetes administrators have the decryption
    key and, upon seeing the encrypted secret (a SealedSecret), the controller decrypts
    it into a regular Kubernetes secret. It enhances security by ensuring that actual
    secret values are not directly stored in a Git repository but kept in an encrypted
    format instead.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**SealedSecrets** 是一个 Kubernetes 控制器和工具，用于一键加密的 Secrets。它旨在帮助开发人员加密一个 secret
    并提交到控制平面（通常是在 Git 仓库中并通过 **持续集成和持续交付** (**CI/CD**）进行管理）。Kubernetes 管理员拥有解密密钥，并且当看到加密的
    Secret（SealedSecret）时，控制器会将其解密为常规的 Kubernetes Secret。它通过确保实际的 secret 值不会直接存储在
    Git 仓库中，而是以加密格式保存，来增强安全性。'
- en: 'The brilliance of SealedSecrets is in its simplicity: Secrets are encrypted
    in a way that only the cluster itself can decrypt, allowing for Secrets to be
    safely stored alongside the application’s configuration, typically in version
    control.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SealedSecrets 的亮点在于它的简洁性：Secrets 以只有集群本身能够解密的方式进行加密，从而允许 Secrets 安全地与应用程序的配置一起存储，通常是在版本控制中。
- en: 'Let’s walk through the distinct phases of the SealedSecrets process:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 SealedSecrets 过程的不同阶段来了解一下：
- en: '`kubeseal` CLI tool'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeseal` CLI 工具'
- en: '`kubeseal` to encrypt a secret, which creates a SealedSecret'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubeseal` 加密一个 secret，这将创建一个 SealedSecret
- en: '`kubectl`, just like any other Kubernetes resource'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl`，就像其他任何 Kubernetes 资源一样'
- en: '**Decryption**: The SealedSecret controller, running in the cluster, decrypts
    the SealedSecret and creates a standard Kubernetes secret'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解密**：SealedSecret 控制器在集群中运行，它解密 SealedSecret 并创建一个标准的 Kubernetes secret'
- en: The primary benefit of using SealedSecrets in DevOps is its ease of use. It
    allows developers to keep their application’s configuration and Secrets (in an
    encrypted form) under version control together safely. However, it’s crucial to
    note that SealedSecrets are not exactly the same as regular Kubernetes Secrets.
    When decrypted, SealedSecrets turn into standard Kubernetes Secrets within the
    cluster. These Secrets are then only accessible to the workloads that have the
    required permissions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 中使用 SealedSecrets 的主要好处是其易用性。它允许开发人员将应用程序的配置和 Secrets（加密形式）一起安全地进行版本控制。然而，值得注意的是，SealedSecrets
    与常规的 Kubernetes Secrets 并不完全相同。当解密时，SealedSecrets 会在集群内转化为标准的 Kubernetes Secrets。这些
    Secrets 只有具有相应权限的工作负载才能访问。
- en: 'Let’s briefly explore the creation and application of SealedSecrets and how
    they’re used in Pods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要探讨 SealedSecrets 的创建和应用，以及它们如何在 Pods 中使用：
- en: '**Creating** **a SealedSecret**:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建** **一个 SealedSecret**：'
- en: Here is a quick example of creating a simple Kubernetes secret.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`sealed-secret.yaml` file via `kubectl`, the SealedSecret controller will decrypt
    it and create a regular Kubernetes secret named `my-secret` in the specified namespace.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Usage** **in Pods**:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the SealedSecret is decrypted and the regular secret is available, Pods
    can reference this secret just like any other, for example, to mount it as a volume
    or use it to set an environment variable:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In essence, SealedSecrets facilitates the encrypted storage and management of
    Secrets outside the cluster, while the in-cluster controller ensures their safe
    decryption and transformation into accessible Kubernetes Secrets when required.
    It harmoniously bridges the gap between the operational need for secret encryption
    and the practical use of these Secrets within the Kubernetes ecosystem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Secret Store CSI Driver for Kubernetes Secrets
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Secret Store CSI Driver provides an advanced solution for integrating external
    Secrets management platforms with Kubernetes. This robust mechanism aims to enhance
    the security and efficiency of handling Secrets in Kubernetes workloads.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the CSI driver for Secrets management
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Container Storage Interface** (**CSI**) is a critical standard for connecting
    various storage systems to orchestrators such as Kubernetes. In the realm of Secrets
    management, the Secret Store CSI Driver acts as this connecting bridge:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**CSI driver**: Fundamentally, this is an interface between Kubernetes and
    numerous external storage systems. It has the responsibility of dynamically provisioning
    Secrets. In a world where timely access to Secrets can be crucial, the capability
    this driver offers can be invaluable.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secrets-store.csi.k8s.io`, empowers Kubernetes to fetch and mount multiple
    Secrets, keys, and certificates from high-grade external secret stores. These
    are then made available to Pods as a volume. When connected, the encapsulated
    data is mounted into the Pod’s file system. This direct access ensures applications
    can readily consume the Secrets.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSI driver stands as a vital bridge between Kubernetes and external storage
    solutions. Facilitating the seamless and secure provisioning of Secrets, keys,
    and certificates ensures timely access and efficient integration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Secrets CSI Driver’s unique aspects
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Secret Store CSI Driver boasts several distinct features:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**Dual architecture**: The driver amalgamates the CRD and DaemonSets. The CRD
    steers the custom behavior and the interaction with the external secret stores.
    On the other hand, DaemonSets ensures a copy of the driver is operational on each
    node in the cluster. This architecture ensures Secrets are uniformly available
    across the cluster.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmpfs` in-memory file system. This approach ensures Secrets aren’t written
    to node disks, enhancing security.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node-level interface**: Because it operates at the node level with the Kubernetes
    CSI interface, the driver necessitates root user privileges on each host.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Secret Store CSI Driver stands out with its innovative dual architecture,
    direct in-memory secret mounting, and node-level operation, necessitating root
    privileges and ensuring a uniform, secure approach to Secrets management across
    Kubernetes clusters. Here is a sample configuration to demonstrate the end-to-end
    usage of the Secret Store CSI Driver:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying Secret Store** **CSI Driver**:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a quick start with the Secret Store CSI Driver in Kubernetes, you can use
    Helm 3 for installation:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Begin by adding the driver’s Helm repository with the following command:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver
    --namespace kube-system
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The exact deployment steps can differ depending on your Kubernetes environment,
    but you typically have the option to use helm charts or raw YAML files. These
    are available in the official repository, which you can find at [https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver).
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Declaring** **a SecretProviderClass**:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the central object that tells the driver where and how to fetch the
    Secrets:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`SecretProviderClass` is set, you can reference it in your Pod configuration:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The provided example configuration outlines the steps to deploy the driver,
    declare a `SecretProviderClass`, and incorporate it into a Pod. Moving forward,
    let’s dive into the advantages and limitations of this approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and limitations of the Secrets CSI Driver
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Secret Store CSI Driver, while immensely powerful, comes with both strengths
    and challenges:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '`tmpfs` ensures Secrets are never persisted on node disks'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic updates**: Depending on the external store’s capabilities, Secrets
    can be updated dynamically, ensuring workloads have access to the latest data'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations**:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex setup**: The dual nature (CRD and DaemonSet) can make the initial
    setup more complex'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node-level access**: Requiring root access on every node can be seen as a
    security concern in certain environments'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provider dependencies**: Some features might be dependent on the capabilities
    of the external secret store'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For comprehensive details, best practices, and community support, always refer
    to the official documentation, found at [https://secrets-store-csi-driver.sigs.k8s.io/](https://secrets-store-csi-driver.sigs.k8s.io/).
    For those interested in contributing, understanding its architecture, or exploring
    its detailed capabilities, the GitHub repository for the project is a valuable
    resource (Secret Store CSI Driver on GitHub, found at [https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the Secret Store CSI Driver marks a significant advancement in
    Kubernetes’ ability to manage Secrets. Adopting it can lead to more secure and
    efficient Secrets management, though like all tools, its correct implementation
    is crucial.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Service mesh integration for secret distribution
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the evolving world of Kubernetes, a *service mesh* has emerged as a crucial
    overlay to handle inter-service communications. Its primary value proposition
    lies in abstracting the complexity of service-to-service interactions, offloading
    developers from having to embed this logic in the application code. When it comes
    to secret distribution, especially in the context of certificates and tokens,
    a service mesh plays a pivotal role. To summarize, a service mesh is a configurable
    infrastructure layer for microservice applications that makes communication flexible,
    reliable, and fast. It’s implemented through lightweight network proxies deployed
    alongside application code without the application needing to be aware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Secrets in service mesh – certificates and tokens
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we talk about Secrets in the context of a service mesh, we’re mostly referring
    to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Certificates**: These are used to establish trust between services in the
    mesh. **Mutual TLS** (**mTLS**) often gets employed to ensure both client and
    server services can trust each other. The service mesh automates the provisioning
    and rotation of these certificates.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tokens**: For certain authentication and authorization scenarios, tokens
    (such as JWTs) might be used. These can be generated, validated, and rotated by
    the service mesh, ensuring applications don’t have to handle this complexity.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service mesh simplifies and secures the management of certificates and
    tokens through automation. Within the service mesh, the handling and distribution
    of Secrets are both secure and dynamic, adhering to a well-established and commonly
    practiced procedure throughout their entire lifecycle:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic secret creation**: A service mesh can integrate with external **certificate
    authorities** (**CAs**) or even have its built-in CA. On-demand, certificates
    are generated for services when they join the mesh.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Secret distribution**: Once generated, these certificates (or tokens) get
    securely distributed to the relevant services. This distribution is done through
    the sidecar proxies that accompany each service instance in the mesh.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rotation and renewal**: A key benefit of using a service mesh is its capability
    to automate the rotation of Secrets. This feature enhances security by regularly
    updating these sensitive credentials. After a predefined period, Secrets are renewed
    and older ones are invalidated, all without any downtime or manual intervention.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Revocation**: In scenarios where a service might be compromised, the service
    mesh can quickly revoke the associated Secrets, mitigating potential damage.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service mesh automates the entire process, from creating and distributing
    certificates and tokens on-demand to managing their rotation and revocation, ensuring
    a secure and efficient operation with minimal manual intervention required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Service meshes in action – Istio
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While there are multiple service mesh implementations available, **Istio** stands
    out as a prominent example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: For its certificate management, Istio uses a component called **Citadel**. It
    acts as the CA, generating, distributing, rotating, and having the capability
    to revoke certificates for services in the mesh. With its built-in capabilities,
    Istio’s Citadel ensures that the mTLS communication within the mesh remains secure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example configuration for enabling mTLS in Istio:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Istio, as a leading service mesh implementation, utilizes its Citadel component
    not only for robust certificate management to secure mutual TLS communication;
    it also extends its capabilities to include authentication, identity provisioning,
    and policy enforcement, making it a comprehensive solution for managing security
    within the service mesh architecture.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and considerations
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Service meshes, when integrated into Kubernetes, bolster security through automated
    certificate management and enable mTLS for all communications. This ensures uniform
    application of security policies across the cluster. However, the added layer
    of sidecar proxies introduces latency and brings challenges to monitoring and
    maintenance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: For organizations already utilizing or planning to utilize a service mesh, incorporating
    it for Secrets management, especially for certificates and tokens, becomes compelling.
    Such integration simplifies Secrets management, ensuring secure transmission,
    appropriate scoping, and regular rotation. Yet, it’s crucial to recognize that
    while service meshes excel in managing certificates and tokens, they aren’t a
    one-size-fits-all solution for all secret types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In sum, when a service mesh is present in your Kubernetes setup, leveraging
    it for managing certificates and tokens can streamline operations and enhance
    security. However, it shouldn’t be seen as a complete replacement for comprehensive
    Secrets management.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, a service mesh enhances the Kubernetes ecosystem’s security landscape,
    especially around secret distribution in the form of certificates and tokens.
    While the benefits are manifold, like with any technology, a thorough understanding
    and diligent implementation are key to reaping its full potential.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Broker systems in Secrets management
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within the expansive terrain of IT security, especially when discussing the
    realm of Secrets management, the term **broker system** emerges as an essential
    player. Acting as intermediaries, these brokers act like traffic cops, ensuring
    that applications get what they need, but only after verifying their *identity*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The following can help you understand how broker mechanisms work:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**: An application needing a secret sends a request to the broker.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation**: The broker validates the request, often verifying the sender’s
    identity and authorization.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fetch and transmit**: Once validated, the broker retrieves the secret from
    the store and securely sends it to the application.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audit and log**: All transactions, be they requests or fetches, are duly
    logged for auditing. This design ensures applications sidestep the intricacies
    of directly engaging with different secret stores; they merely need to interface
    with the broker.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example. Suppose service `foo` needs to connect to a
    specific database. Instead of directly fetching the database credentials, the
    following occurs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`foo` sends a request: `I need credentials` `for DB1.`'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The broker checks whether `foo` has the right permissions for `DB1`
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon confirmation, the broker fetches and hands over the credentials
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throughout this process, `foo` remains agnostic to the exact secret storage
    location and the retrieval method. It safely obtains necessary database credentials
    through a broker, which validates permissions and retrieves the information, ensuring
    a secure access process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Broker mechanisms versus secretless brokers
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s easy to conflate the two given the similar terminology, but they function
    distinctly. Secretless brokers go one step further; they establish connections
    on behalf of applications without ever revealing the secret to the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, this is how they differ:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Broker mechanisms**: They deliver Secrets to applications after validations'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secretless brokers**: They use Secrets to facilitate a direct connection,
    keeping the Secrets hidden'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thought bubble – brokers and service mesh
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this juncture, it’s worth drawing a parallel with service mesh. A service
    mesh employs proxies to control and manage traffic between services in a microservices
    architecture. If you think about it, isn’t this proxy acting like a broker? Indeed,
    the service mesh’s proxy ensures secure communication between services, potentially
    managing certificates, tokens, and sometimes other Secrets. However, its primary
    focus isn’t Secrets management, but facilitating secure service-to-service communication.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Why do brokers still matter?
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While secretless brokers and service meshes are making headway, traditional
    broker systems remain invaluable. They’re flexible, work with a vast array of
    applications, provide centralized control for secret distribution, allow granular
    access, and often bridge the gap for legacy systems. Their role isn’t just retrieval
    but also secret governance and lifecycle management.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the realm of integrating external secret stores with Kubernetes, this
    section shed light on essential mechanisms and patterns vital for secure and efficient
    Secrets management. We kicked off with Kubernetes extensions and API mechanisms,
    illustrating how these tools can be seamlessly woven into your Secrets management
    strategy, followed by an in-depth look at Pod lifecycle and manipulation mechanisms,
    ensuring that Secrets are securely managed throughout a Pod’s lifecycle. The journey
    continued with specialized Kubernetes patterns, highlighting SealedSecrets as
    a paradigm of enhanced security, and delved into the world of service mesh integration,
    showcasing its prowess in secure secret distribution and service-to-service communication.
    The discussion was rounded off with broker systems in Secrets management, emphasizing
    their role in creating a secure, intermediary layer between applications and secret
    stores and ensuring a decoupled, flexible management system. Altogether, these
    subsections collectively forge a comprehensive guide, empowering teams to securely
    and efficiently manage Secrets in Kubernetes while navigating the complexities
    of external secret integration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Security implications and best practices
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Kubernetes gains traction, integrating it with external secret stores comes
    with specific advantages, such as specialized encryption and audit capabilities.
    However, this approach also brings its own set of challenges and security implications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a list of them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency on external systems**: Relying on external secret stores means
    introducing an additional layer of complexity and dependency. Any downtime or
    compromise in the external store can directly impact the applications running
    in the Kubernetes cluster.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data transit exposure**: Transferring Secrets from the external store to
    Kubernetes could expose them if the transmission isn’t properly secured, for example,
    if it lacks end-to-end encryption.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privilege escalation through brokers or intermediaries**: Brokers or sidecars
    fetching Secrets can become potential attack vectors. A malicious actor gaining
    access to one of these can potentially siphon Secrets from the external store.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurations and access policies**: Incorrect configurations or overly
    permissive access policies in the external secret store can inadvertently expose
    sensitive Secrets.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning and secret rotation challenges**: If not managed properly, syncing
    secret versions between Kubernetes and the external store can be challenging,
    leading to potential mismatches or usage of outdated Secrets.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integrating Kubernetes with external secret stores can be challenging. Ensuring
    the security and integrity of Secrets in Kubernetes necessitates a set of robust
    practices. Here, we outline the key best practices to consider:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure the data transit**: Always use encrypted channels (such as TLS) when
    transferring Secrets from the external store to Kubernetes. Ensure both ends of
    the communication authenticate each other.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restrict and monitor access**: Implement fine-grained access controls in
    the external secret store. Only allow specific entities (such as certain brokers
    or sidecars) to fetch Secrets and monitor their activities.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secret rotation and sync**: Periodically rotate Secrets in the external store
    and ensure there’s a mechanism to propagate these changes efficiently into Kubernetes.
    This avoids stale Secrets and potential vulnerabilities.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Harden broker or intermediary systems**: If using brokers, sidecars, or any
    other intermediary system to fetch Secrets, ensure they’re secure, monitored,
    and run with the least privilege possible.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Back up the external store**: Regularly back up the external secret store.
    In the event of a compromise or failure, this ensures Secrets can be restored
    and services can be brought back online quickly.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audits and anomaly detection**: Use the auditing capabilities of the external
    secret store. Monitor for any unusual access patterns or anomalies that could
    indicate a breach or misconfiguration.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By acknowledging these implications and adhering to best practices, Kubernetes
    administrators can effectively and securely leverage the strengths of external
    secret stores.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Practical and theoretical balance
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When integrating Kubernetes with external secret stores, striking the right
    balance is crucial. This balance isn’t just about the technical aspects; it spans
    scalability, auditability, interoperability, and even cost implications. The goal
    is to create a robust, scalable, and secure environment that doesn’t compromise
    usability or cost efficiency.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Security remains paramount. You must ensure that Secrets aren’t exposed during
    transit or at rest. External dependencies can introduce vulnerabilities if not
    properly managed, and a single compromise could lead to a domino effect, endangering
    multiple systems. Always ensure encrypted communications and choose secret stores
    with strong security postures.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Usability and the user experience are often seen as the other side of the security
    coin. A system that’s too cumbersome might lead to workarounds or shortcuts, negating
    the security benefits. Moreover, when evaluating how to apply these considerations
    in practice, it’s critical to understand the optimal usage of the various mechanisms.
    Pod lifecycle-based methods, such as init containers and sidecars, naturally align
    with direct fetch methodologies without converting to Kubernetes-native Secrets.
    In contrast, Kubernetes extensions and API mechanisms, although versatile, are
    inherently more suited for conversion to Kubernetes resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Granular access is crucial for modern applications. Not every application or
    service requires access to all Secrets. Properly implemented granular access minimizes
    the risk if a particular service is compromised. Legacy systems can’t always be
    ignored or replaced immediately. Therefore, any solution must consider how to
    integrate or coexist with older systems that might not have been designed with
    modern security practices in mind. Handling external dependencies is a delicate
    task. Depending too much on external systems can introduce fragility into the
    infrastructure. It’s essential to evaluate the reliability of these systems and
    have contingencies in place.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding failure and recovery models is important, as it’s a matter of
    when, not if, failures will occur; thus, having comprehensive backup and restoration
    strategies in place is imperative to restoring Secrets in the event of data corruption
    or loss. Addressing the potential secret leak blast radius is vital. Understand
    the implications of a breach: what happens if a node or an entire cluster is compromised?
    Minimize the potential damage by compartmentalizing and isolating Secrets as much
    as possible. Auditability and monitoring ensure the traceability of secret access.
    Comprehensive logs and real-time alerts help in identifying and rectifying suspicious
    activities swiftly.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The scalability of the secret store must align with your organizational growth.
    As clusters and deployments grow, the secret store should seamlessly handle increased
    traffic. Lifecycle management involves managing Secrets throughout their entire
    lifecycle—creation, updates, rotations, and deletions—and seamlessly integrating
    these processes into CI/CD pipelines.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: In our multi-cloud era, interoperability is non-negotiable. Solutions must support
    diverse environments, ensuring compatibility across different cloud providers.
    Costs extend beyond direct financial implications. Consider operational costs,
    potential breach-related costs, and latency-related costs, ensuring the overall
    cost-efficiency of the solution. Geographic redundancy becomes essential for global
    operations, ensuring low latency and high availability from any location worldwide.
    Ease of transition ensures future flexibility. Avoid being locked into a particular
    solution by favoring those designed with open standards.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, adhere to regulatory and compliance requirements specific to your industry,
    ensuring the secret store’s compliance with standards such as ISO 27001, PCI-DSS,
    and HIPAA.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the integration of Kubernetes with external secret stores reveals
    essential methods and patterns for secure and efficient Secrets management. We’ve
    delved into key mechanisms, including Kubernetes extensions, Pod lifecycle manipulations,
    and innovative tools such as the Secret Store CSI Driver, showcasing Kubernetes’
    adaptability and commitment to security.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Service mesh and broker mechanisms play crucial roles in balancing robust security
    with application agility, acting as intermediaries for secret distribution and
    decoupling applications from direct secret access. Achieving this balance requires
    attention to granular access controls, legacy systems, and the potential impacts
    of secret leaks, alongside the need for scalability, monitoring, and compliance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, this intricate journey towards integrating Kubernetes with external
    secret stores is about creating a resilient and secure operational environment,
    ensuring a scalable and sustainable future for organizations navigating the Kubernetes
    ecosystem.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Building on our exploration of integrating Kubernetes with external secret stores,
    the next chapter presents an end-to-end story of secret lifecycle management in
    a production environment. This will encompass practical applications, challenges,
    and solutions, illustrating a comprehensive approach to managing Secrets securely
    and efficiently in real-world scenarios.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
