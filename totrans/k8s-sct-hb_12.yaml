- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Integrating with Secret Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与秘密存储集成
- en: 'Kubernetes provides a basic system for managing Secrets, but it is not typically
    seen as secure enough for sensitive data such as passwords, tokens, or keys, especially
    in production settings. To address this, integrating advanced Secrets management
    tools into Kubernetes is vital. These tools enhance security through encryption
    and offer centralized management of sensitive information. This surpasses the
    native capabilities of Kubernetes Secrets, leading to a more robust and compliant
    security stance. In this chapter, you will learn how to integrate Secrets management
    tools with Kubernetes. The chapter will cover how to configure external secret
    stores in Kubernetes and explore the different types of external secret stores
    that can be used. You will gain an understanding of the security implications
    of using external secret stores and how to use them to store sensitive data using
    different approaches such as init containers, sidecars, CSI drivers, operators,
    and sealed Secrets. The chapter will also cover the best practices for using external
    secret stores and how they can impact the overall security of a Kubernetes cluster.
    In this chapter, we’re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一个基本的系统来管理 Secrets，但通常不被认为足够安全，尤其是在生产环境中处理密码、令牌或密钥等敏感数据时。为了解决这个问题，将先进的秘密管理工具集成到
    Kubernetes 中变得至关重要。这些工具通过加密增强了安全性，并提供了敏感信息的集中管理。它们超越了 Kubernetes Secrets 的原生功能，使得安全性更加强大和合规。本章将讲解如何将秘密管理工具与
    Kubernetes 集成。内容包括如何在 Kubernetes 中配置外部秘密存储，以及可用的不同类型的外部秘密存储。你将了解使用外部秘密存储的安全性影响，并学习如何通过不同的方法，如
    init 容器、sidecar、CSI 驱动程序、操作员和封印的 Secrets，来存储敏感数据。本章还将涵盖使用外部秘密存储的最佳实践，以及它们如何影响
    Kubernetes 集群的整体安全性。本章我们将涉及以下主要主题：
- en: Configuring external secret stores in Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中配置外部秘密存储
- en: Integrating with external secret stores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部秘密存储的集成
- en: Security implications and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性影响与最佳实践
- en: Practical and theoretical balance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际与理论的平衡
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To link concepts with hands-on examples, we are leveraging a series of tools
    and platforms commonly used to interact with external Secrets management and Kubernetes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将概念与实际操作示例结合，我们将使用一系列常用于与外部秘密管理和 Kubernetes 交互的工具和平台：
- en: '**minikube**: It runs a single-node Kubernetes cluster inside a **virtual machine**
    (**VM**) on your computer. Get it set up using the guide at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minikube**：它在你的计算机上通过**虚拟机**（**VM**）运行一个单节点的 Kubernetes 集群。可以通过 [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    的指南进行设置。'
- en: '**Helm**: This is a package manager for Kubernetes that will simplify deployments.
    Check out the Helm installation guide for setup instructions at [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm**：这是一个 Kubernetes 的包管理工具，可以简化部署过程。有关安装的指南，可以查看 [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)。'
- en: '**kubectl**: This is the Kubernetes command-line tool. Instructions for its
    installation are available at [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl**：这是 Kubernetes 的命令行工具。安装指南可以在 [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    找到。'
- en: '**External Secrets management tool**: While various tools can be utilized for
    the purpose of our demonstrations, it’s recommended to have Hashicorp Vault. The
    official guide for its installation is found at [https://www.vaultproject.io/docs/install](https://www.vaultproject.io/docs/install).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部秘密管理工具**：虽然可以使用多种工具进行演示，但建议使用 Hashicorp Vault。它的官方安装指南可以在 [https://www.vaultproject.io/docs/install](https://www.vaultproject.io/docs/install)
    找到。'
- en: Integrating secret stores with Kubernetes
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密存储与 Kubernetes 集成
- en: As we’ve explored in previous chapters, Kubernetes has its own Secrets management
    capabilities. However, when operating at scale or with specific security requirements,
    the native Kubernetes Secrets may fall short. The sheer diversity of Secrets management
    tools available, as previously discussed, alludes to this need. But why integrate
    them with Kubernetes?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中探讨的那样，Kubernetes 本身具备秘密管理功能。然而，在大规模操作或特定的安全需求下，原生的 Kubernetes Secrets
    可能会有所不足。之前讨论过的各种秘密管理工具的多样性，正是暗示了这一需求。但为什么要将它们与 Kubernetes 集成呢？
- en: 'Integrating third-party tools with Kubernetes offers the following benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将第三方工具与 Kubernetes 集成带来以下好处：
- en: '**Operational consistency**: For organizations that already use tools for applications
    outside Kubernetes, integration provides a uniform Secrets management experience
    across the board.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作一致性**：对于已经在 Kubernetes 外使用工具的组织，集成提供了一个统一的秘密管理体验。'
- en: '**Enhanced security features**: Many external tools offer advanced features
    such as secret rotation, granular access controls, and multi-layered encryption
    methods that aren’t readily available or require additional configurations in
    native Kubernetes.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的安全特性**：许多外部工具提供了高级功能，如秘密轮换、细粒度的访问控制和多层加密方法，这些功能在 Kubernetes 原生环境中并不容易获得，或者需要额外配置。'
- en: '**Scalability and performance**: At scale, the management of a large number
    of Secrets may become complex using only Kubernetes native Secrets. External tools,
    designed for high-volume operations, can effectively address this.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和性能**：在大规模环境中，仅使用 Kubernetes 原生的 Secrets 管理大量秘密可能变得复杂。为高容量操作设计的外部工具可以有效应对这一挑战。'
- en: '**Advanced audit trails**: In an environment of tougher regulations and increasing
    cyber threats, having a thorough audit capability is essential, not a luxury.
    Many tools come equipped with comprehensive logging and alerting functions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级审计追踪**：在日益严格的法规和增加的网络威胁环境中，拥有一个全面的审计能力至关重要，而非奢侈。许多工具配备了完整的日志记录和警报功能。'
- en: '**Detailed audit capabilities**: These capabilities ensure regulatory compliance,
    improve security, increase accountability, detect unusual activities, support
    informed decision-making, provide legal evidence, enhance operational efficiency,
    build customer trust, reduce insider threats, and enable historical analysis for
    future improvements.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细的审计能力**：这些能力确保合规性，提升安全性，增加责任追踪，检测异常活动，支持基于信息的决策，提供法律证据，增强操作效率，建立客户信任，减少内部威胁，并为未来的改进提供历史分析。'
- en: '**Cross-platform compatibility**: With the rise of hybrid and multi-cloud strategies,
    secret managers can offer consistent Secrets management across different cloud
    platforms, making it easier to manage Secrets in such heterogeneous environments.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台兼容性**：随着混合云和多云策略的兴起，秘密管理器可以在不同的云平台之间提供一致的 Secrets 管理，使得在这些异构环境中管理 Secrets
    更加简便。'
- en: While we’ve recognized the capabilities of various cloud secret stores and third-party
    secret stores in previous chapters, this chapter aims to bridge the gap to focus
    on integration. The primary focus is to showcase how these secret stores can be
    seamlessly integrated with Kubernetes, leveraging the best of both worlds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在前面的章节中已经认识到各种云秘密存储和第三方秘密存储的能力，本章旨在弥补这一差距，专注于集成。主要的焦点是展示这些秘密存储如何与 Kubernetes
    无缝集成，充分利用两者的优势。
- en: Through the subsequent sections, we’ll dive deep into the mechanics of these
    integrations, offering both a theoretical and practical understanding. Each method,
    from Kubernetes extensions to Pod lifecycle mechanisms, will illustrate different
    strategies and approaches for this integration. By the end of this chapter, our
    goal is to provide you with a robust set of strategies and insights, empowering
    you to make choices that align seamlessly with your unique operational requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过后续章节，我们将深入探讨这些集成的机制，提供理论与实践的双重理解。从 Kubernetes 扩展到 Pod 生命周期机制，每种方法都将展示不同的集成策略和方法。到本章结束时，我们的目标是为您提供一套强大的策略和见解，帮助您做出与独特操作需求无缝对接的选择。
- en: Configuring external secret stores in Kubernetes
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中配置外部秘密存储
- en: The decentralized nature of Kubernetes and its dynamic workloads necessitate
    a robust Secrets management solution. This section provides insights into the
    general configuration process and delineates two predominant paradigms for secret
    consumption within Kubernetes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的去中心化特性和动态工作负载要求有一个强大的秘密管理解决方案。本节提供了关于一般配置过程的见解，并阐明了在 Kubernetes
    中使用秘密的两种主要范式。
- en: 'The following are the general configuration steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一般的配置步骤：
- en: '**Selection of secret store**: Begin by choosing a Secrets management tool
    that suits organizational needs, factoring in aspects such as security requirements,
    scalability, compliance standards, team familiarity, and more. Options abound,
    ranging from cloud-native solutions such as AWS/GCP Secrets Manager and Azure
    Key Vault to tools such as HashiCorp Vault and CyberArk.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择秘钥存储**：首先选择一个适合组织需求的 Secrets 管理工具，考虑安全需求、可扩展性、合规标准、团队熟悉度等因素。可选的方案非常多，包括云原生解决方案，如
    AWS/GCP Secrets Manager 和 Azure Key Vault，也有诸如 HashiCorp Vault 和 CyberArk 等工具。'
- en: '**Initialization and connecting to Kubernetes**: Once the secret store is selected,
    proceed with its initialization. Deploy it either within the Kubernetes cluster
    or alongside it based on architectural preferences, ensuring smooth connectivity
    between the store and Kubernetes.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化并连接到 Kubernetes**：一旦选择了秘钥存储，就开始其初始化。根据架构偏好，将其部署在 Kubernetes 集群内部或旁边，确保秘钥存储与
    Kubernetes 之间的顺畅连接。'
- en: '**Handle authentication and authorization**: Establish robust and secure communication
    channels between Kubernetes and the secret store. Mechanisms could encompass IAM
    roles, tokens, service accounts, or client certificates. Concurrently, put in
    place fine-grained authorization controls to ensure that only entitled services
    or applications access designated Secrets.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理认证与授权**：在 Kubernetes 和秘钥存储之间建立强大且安全的通信渠道。机制可以包括 IAM 角色、令牌、服务帐户或客户端证书。同时，建立精细的授权控制，确保只有授权的服务或应用访问指定的
    Secrets。'
- en: '**Determine secret retrieval and consumption method**: Delve into how the Secrets
    will be consumed. Decide if Secrets from the external store will be converted
    into native Kubernetes Secrets or if they will be fetched directly from the external
    store when required.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定秘钥获取与使用方式**：深入探讨 Secrets 将如何被使用。决定是否将外部存储中的 Secrets 转换为原生 Kubernetes Secrets，或者在需要时直接从外部存储中提取。'
- en: '**Test the configuration**: Before rolling out the integration in a production
    environment, conduct thorough testing. Verify secret retrieval, consumption, and
    other configured functionalities to ensure they operate as intended.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试配置**：在将集成应用到生产环境之前，进行全面测试。验证密钥的获取、使用以及其他已配置的功能，确保它们按预期工作。'
- en: '**Monitor and auditing**: As the final step, implement monitoring mechanisms
    to oversee access to Secrets. Augment this with logging and auditing tools to
    swiftly detect unauthorized access attempts or potential breaches.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控与审计**：作为最后一步，实施监控机制来监督对 Secrets 的访问。并通过日志记录和审计工具增强这一过程，快速发现未经授权的访问尝试或潜在的安全漏洞。'
- en: Completing these general configuration steps lays a strong foundation for secure
    and efficient Secrets management within your Kubernetes environment. With the
    secret store now integrated, authenticated, and authorized, you’re set to proceed
    to the next phase, ensuring a seamless and secure consumption of Secrets by your
    applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些通用配置步骤为在 Kubernetes 环境中实现安全高效的 Secrets 管理奠定了坚实的基础。现在，秘钥存储已经集成、认证并授权，您可以继续进入下一阶段，确保应用程序能够无缝且安全地使用
    Secrets。
- en: Secret consumption in Kubernetes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 中的秘钥消费
- en: 'When integrating an external secret store, two primary paradigms dominate secret
    consumption within Kubernetes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成外部秘钥存储时，有两种主要模式主导了 Kubernetes 中的密钥使用：
- en: '**Convert to native Kubernetes Secrets**: Translating Secrets from external
    stores into native Kubernetes Secrets allows the leveraging of Kubernetes-native
    methods for Secrets management and access. It provides the benefit of caching,
    minimizing the need for frequent external requests. Additionally, it eliminates
    a critical point of failure. However, there are challenges such as redundancy
    and ensuring synchronization between the two secret storage locations.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换为原生 Kubernetes Secrets**：将外部存储中的 Secrets 转换为原生 Kubernetes Secrets 使您能够利用
    Kubernetes 原生的方法进行 Secrets 管理和访问。这带来了缓存的好处，减少了频繁外部请求的需求。此外，它还消除了一个关键的故障点。然而，也存在诸如冗余和确保两个秘钥存储位置之间同步等挑战。'
- en: '**Directly fetch from external store**: Directly retrieving Secrets ensures
    applications get the most recent versions, cutting down on the need to synchronize.
    It also leads to a cleaner audit trail. Nevertheless, this method might introduce
    latency due to external fetch operations and create a direct dependency on the
    external store.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接从外部存储中获取**：直接检索机密确保应用程序能够获取到最新的版本，减少了同步的需求，同时也能保持更清晰的审计记录。然而，这种方法可能会由于外部获取操作而引入延迟，并且会对外部存储产生直接依赖。'
- en: To summarize, the process of configuring an external secret store in Kubernetes
    is fundamental to constructing a scalable and secure cloud-native infrastructure.
    A clear comprehension of the configuration steps and the various paradigms of
    secret consumption sets the stage for an effective Secrets management strategy.
    Future sections will provide a more in-depth exploration of these topics and the
    accompanying mechanisms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在 Kubernetes 中配置外部机密存储的过程是构建可扩展、安全的云原生基础设施的基础。清楚理解配置步骤和各种机密消费方式为制定有效的机密管理策略奠定了基础。未来的章节将更深入地探讨这些主题及其相关机制。
- en: Integrating with external secret stores
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部机密存储集成
- en: The integration of external secret stores with Kubernetes is a critical component
    of securing your applications and protecting sensitive data. This section explores
    various mechanisms and patterns that can be used to seamlessly integrate external
    secret stores with your Kubernetes clusters, enhancing security and management
    efficiency.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部机密存储与 Kubernetes 集成是保护应用程序和敏感数据的关键组成部分。本节探讨了可以无缝将外部机密存储与 Kubernetes 集群集成的各种机制和模式，从而增强安全性和管理效率。
- en: Kubernetes extensions and API mechanisms
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 扩展和 API 机制
- en: Kubernetes provides a variety of extensions and API mechanisms that can be leveraged
    to connect and interact with external secret stores. In this part, we will delve
    into the available options and guide you on how to utilize them effectively for
    Secrets management.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了各种扩展和 API 机制，可以利用它们与外部机密存储进行连接和交互。在本部分，我们将深入探讨可用选项，并指导你如何有效地利用它们进行机密管理。
- en: Admission controllers and mutating webhooks for Secrets in Kubernetes
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的准入控制器和变异 webhook 用于机密管理
- en: Kubernetes provides a rich set of tools for controlling and modifying behavior
    within its environment. Among them, *admission controllers* and *mutating webhooks*
    play a pivotal role in enhancing the operational and security aspects of Kubernetes
    clusters. Especially when it comes to Secrets management, these tools can be game-changing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一整套工具，用于控制和修改其环境中的行为。其中，*准入控制器*和*变异 webhook*在增强 Kubernetes 集群的操作和安全性方面发挥了至关重要的作用。特别是在机密管理方面，这些工具可能会带来革命性的变化。
- en: Admission controllers are parts of the Kubernetes control plane that govern
    and enforce how the cluster is used. They intercept requests to the Kubernetes
    API server before the persistence of the object but after the request is authenticated
    and authorized. By doing so, admission controllers have the ability to take specific
    actions, such as rejecting a request or modifying the object before it’s stored.
    There are several built-in admission controllers, but for specific requirements
    such as Secrets management, you might need custom controllers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制器是 Kubernetes 控制平面的一部分，负责管理和执行集群的使用方式。它们会在对象持久化之前、但在请求被认证和授权之后，拦截对 Kubernetes
    API 服务器的请求。通过这样做，准入控制器能够采取特定行动，例如拒绝请求或在存储之前修改对象。有几个内置的准入控制器，但对于像机密管理这样的特定需求，你可能需要自定义控制器。
- en: Mutating webhooks come into play when we want the flexibility provided by admission
    controllers but with custom logic. They allow you to run custom code (or a custom
    function) when specific resources are created or modified. This is incredibly
    valuable for Secrets management, as you can programmatically modify Kubernetes
    resources; for example, you can inject secret references into Pods at the time
    of creation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要由准入控制器提供的灵活性，但又需要自定义逻辑时，变异 webhook 就会发挥作用。它们允许你在创建或修改特定资源时运行自定义代码（或自定义函数）。这对机密管理非常有价值，因为你可以以编程方式修改
    Kubernetes 资源；例如，你可以在 Pod 创建时注入机密引用。
- en: Consider a scenario where you don’t want developers to explicitly define Secrets
    within the manifest. Using a mutating webhook, you can set up a system where developers
    only specify a label or annotation. The webhook then intercepts the Pod creation
    request, identifies the label or annotation, and injects the required secret reference,
    thus abstracting away the direct interaction with Secrets.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个场景，你不希望开发者在清单中显式地定义 Secrets。通过使用变更 webhook，你可以建立一个系统，开发者只需要指定标签或注释。Webhook
    会拦截 Pod 创建请求，识别标签或注释，并注入所需的 secret 引用，从而抽象化了与 Secrets 的直接交互。
- en: 'Here’s an illustrative example of setting up a mutating webhook for secret
    injection:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置用于 Secret 注入的变更 webhook 的示例：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down this configuration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个配置：
- en: The webhook is named `secret-injector.example.com`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 webhook 被命名为 `secret-injector.example.com`。
- en: The `clientConfig` specifies the service that handles the webhook. In this case,
    the service is named `secret-injector-service`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clientConfig` 指定了处理 webhook 的服务。在这种情况下，服务名为 `secret-injector-service`。'
- en: The `rules` section defines when this webhook is invoked. Here, it’s set up
    to run when a Pod
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rules` 部分定义了何时调用此 webhook。在这里，它设置为在创建 Pod 时运行。'
- en: is created.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已创建。
- en: When a new Pod gets created, the request is intercepted by our webhook. The
    service `secret-injector-service` then processes this request, checks for specific
    labels or annotations, and decides whether to inject secret references.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的 Pod 被创建时，请求会被我们的 webhook 拦截。服务 `secret-injector-service` 然后处理这个请求，检查特定的标签或注释，并决定是否注入
    secret 引用。
- en: The combination of admission controllers and mutating webhooks provides a robust
    mechanism to streamline and enforce best practices for Secrets management. By
    offloading Secrets management concerns to these tools, developers can focus on
    their application logic while ensuring that Secrets are handled in a secure and
    compliant manner.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Admission 控制器和变更 webhook 的结合提供了一种强大的机制，用于简化和强制执行 Secrets 管理的最佳实践。通过将 Secrets
    管理的责任交给这些工具，开发者可以专注于他们的应用逻辑，同时确保 Secrets 以安全和合规的方式处理。
- en: In conclusion, when looking to enhance the Secrets management capabilities within
    your Kubernetes clusters, consider leveraging admission controllers and mutating
    webhooks. They not only help maintain the sanctity of the cluster but also automate
    and enforce best practices for handling sensitive data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在希望增强 Kubernetes 集群中的 Secrets 管理功能时，考虑利用 admission 控制器和变更 webhook。它们不仅有助于维护集群的完整性，还能自动化并强制执行处理敏感数据的最佳实践。
- en: Custom resource definitions in Secrets management
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Secrets 管理中的自定义资源定义
- en: Kubernetes allows for the extensibility of its API through the use of **custom
    resource definitions** (**CRDs**). CRDs empower cluster operators to introduce
    new resource types in Kubernetes without the need to modify the core Kubernetes
    code base. When dealing with Secrets, especially those stored outside of a Kubernetes
    cluster in external systems such as AWS Secrets Manager or HashiCorp Vault, CRDs
    can offer a more Kubernetes-native approach to managing and accessing them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过使用 **自定义资源定义**（**CRDs**）允许其 API 的扩展性。CRDs 使集群操作员能够在 Kubernetes
    中引入新的资源类型，而无需修改 Kubernetes 核心代码库。在处理 Secrets，尤其是那些存储在 Kubernetes 集群外部的系统（如 AWS
    Secrets Manager 或 HashiCorp Vault）中的 Secrets 时，CRDs 可以提供一种更符合 Kubernetes 原生方式的管理和访问方法。
- en: Defining an ExternalSecret CRD
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 ExternalSecret CRD
- en: 'A CRD definition for an external secret might look something like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 secret 的 CRD 定义可能如下所示：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you’ve defined the CRD, the next logical step is to create instances of
    this new resource type (`ExternalSecret`). However, just defining and creating
    the CRD doesn’t give it functionality. To make the `ExternalSecret` resource meaningful,
    you need a custom controller that understands how to interpret and act upon these
    resources.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了 CRD，下一步就是创建这个新资源类型（`ExternalSecret`）的实例。然而，仅仅定义和创建 CRD 并不能赋予其功能。为了使 `ExternalSecret`
    资源有意义，你需要一个自定义控制器来理解如何解读和操作这些资源。
- en: Using the ExternalSecret CRD
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 ExternalSecret CRD
- en: 'Assuming you have a secret named `database-password` stored in AWS Secrets
    Manager, you might define an `ExternalSecret` resource that references it as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 `database-password` 的 secret 存储在 AWS Secrets Manager 中，你可能会定义一个引用它的
    `ExternalSecret` 资源，内容如下：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s a breakdown of this resource:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个资源的分解：
- en: '`metadata.name`: This is the name assigned to this `ExternalSecret` within
    Kubernetes. It doesn’t necessarily have to match the name in AWS Secrets Manager.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.name`：这是Kubernetes中分配给该`ExternalSecret`的名称。它不必与AWS Secrets Manager中的名称完全匹配。'
- en: '`spec.backendType`: This denotes the external Secrets manager to use; in this
    case, it’s AWS Secrets Manager.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.backendType`：表示要使用的外部Secrets管理器；在此情况下，是AWS Secrets Manager。'
- en: '`spec.data`: This is a list that indicates the Secrets to fetch.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.data`：这是一个列表，指示要获取的密钥。'
- en: '`key`: This is the name or identifier of the secret in AWS Secrets Manager.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：这是在AWS Secrets Manager中密钥的名称或标识符。'
- en: '`name`: This is the name the secret will take when presented to Kubernetes
    Pods.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是密钥在呈现给Kubernetes Pods时的名称。'
- en: '`spec.region`: This specifies the AWS region where the secret resides.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.region`：指定存储密钥的AWS区域。'
- en: 'Upon applying the following resource:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用以下资源后：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A custom controller observing `ExternalSecret` resources would do the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个观察`ExternalSecret`资源的自定义控制器将执行以下操作：
- en: Detect the creation of a new `ExternalSecret`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测到新的`ExternalSecret`的创建。
- en: Understand from the specification that it should communicate with the AWS Secrets
    Manager in the `us-west-1` region.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从规格中理解它应与`us-west-1`区域的AWS Secrets Manager进行通信。
- en: Authenticate with AWS Secrets Manager (assuming it has the necessary permissions).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与AWS Secrets Manager进行身份验证（假设它具有必要的权限）。
- en: Retrieve the `database-password` secret.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`database-password`密钥。
- en: Present this secret to Kubernetes Pods under the name `dbPassword`. This could
    be by creating a native Kubernetes secret, setting it as an environment variable,
    or placing it in a `tmpfs` volume depending on the controller’s design.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此密钥以`dbPassword`的名称展示给Kubernetes Pods。具体方法可以是创建一个本地Kubernetes密钥、将其设置为环境变量，或根据控制器设计将其放入`tmpfs`卷中。
- en: In essence, CRDs combined with custom controllers provide a powerful mechanism
    to extend Kubernetes’s capabilities. For Secrets management, CRDs allow Kubernetes
    to naturally integrate with external secret storage solutions, making the process
    of fetching and using Secrets seamless for end users.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，CRD结合自定义控制器提供了一种强大的机制，来扩展Kubernetes的能力。在密钥管理方面，CRD使得Kubernetes能够自然地与外部密钥存储解决方案集成，使得提取和使用密钥的过程对最终用户无缝化。
- en: 'Kubernetes API extensions: custom API server'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes API扩展：自定义API服务器
- en: Building a custom API server allows us to define our API behaviors, including
    interactions with external secret stores. A Pod can request a secret through the
    custom API, and this API server can fetch it from an external store, process it,
    and return it. However, running and maintaining a custom API server isn’t trivial.
    You’d need to set it up, ensure it’s secure, and potentially handle scaling and
    failover.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个自定义API服务器使我们能够定义API行为，包括与外部密钥存储的交互。Pod可以通过自定义API请求密钥，API服务器可以从外部存储中获取密钥、处理它并返回。然而，运行和维护一个自定义API服务器并不是简单的。你需要设置它，确保它的安全性，并可能处理扩展和故障转移。
- en: 'Please note that this is a simplified example focusing on the conceptual configuration:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个简化的示例，重点讲解概念配置：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For a custom API server to work with the main Kubernetes API server and external
    secret storages, it needs specific settings in its configuration, `custom-api-server-config`.
    This includes how it will verify who is allowed to access it, known as authentication,
    and the rules for how it communicates, called API specifications. Typically, this
    setup uses either service-based or role-based authentication. Service-based authentication
    checks the identity of the service requesting access, while role-based authentication
    looks at the user’s or service’s role to decide access. A common example is using
    IRSA roles in AWS, where Kubernetes services get special permissions to access
    AWS resources securely.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让自定义API服务器能够与主Kubernetes API服务器和外部密钥存储一起工作，它需要在其配置`custom-api-server-config`中进行特定设置。这些设置包括如何验证谁有权限访问，这叫做身份验证，以及如何进行通信的规则，称为API规范。通常，这个设置会使用基于服务的身份验证或基于角色的身份验证。基于服务的身份验证检查请求访问的服务的身份，而基于角色的身份验证则查看用户或服务的角色来决定访问权限。一个常见的例子是使用AWS中的IRSA角色，Kubernetes服务可以安全地访问AWS资源。
- en: This method provides seamless interaction with external secret stores, especially
    for teams more familiar with `kubectl` than with, say, Hashicorp Vault’s CLI.
    By extending the API, users can stay in their familiar environment. However, as
    powerful as it is, just extending the API does not complete the loop. You need
    additional components or procedures to ensure safe and efficient consumption of
    the Secrets by the Pods. This could be through agents, controllers, or other orchestration
    mechanisms that watch for these custom or converted Secrets and make them available
    to Pods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法提供了与外部密钥存储的无缝交互，特别是对于那些更熟悉 `kubectl` 而不是 Hashicorp Vault CLI 的团队。通过扩展 API，用户可以保持在熟悉的环境中。然而，尽管
    API 扩展非常强大，单靠扩展 API 并不能完成整个过程。你需要额外的组件或流程来确保 Pods 安全高效地使用这些 Secrets。这可以通过代理、控制器或其他编排机制来实现，它们会监控这些自定义或转换后的
    Secrets，并使其可供 Pods 使用。
- en: The Kubernetes extensions and API mechanisms offer a flexible and powerful means
    to integrate external secret stores, providing a variety of options to suit different
    use cases and requirements. Understanding how to leverage these tools is key to
    effective Secrets management within Kubernetes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 扩展和 API 机制提供了一种灵活且强大的方式来集成外部密钥存储，提供多种选项以适应不同的用例和需求。了解如何利用这些工具是有效管理
    Kubernetes 中 Secrets 的关键。
- en: Pod lifecycle and manipulation mechanisms
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 生命周期和管理机制
- en: Managing Secrets throughout the lifecycle of a Pod is essential for maintaining
    security and operational efficiency. This section focuses on the mechanisms that
    Kubernetes provides for injecting and managing Secrets in conjunction with the
    Pod lifecycle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 生命周期中管理 Secrets 对于维护安全性和操作效率至关重要。本节重点介绍 Kubernetes 提供的机制，用于在 Pod 生命周期中注入和管理
    Secrets。
- en: Init containers
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Init 容器
- en: Init containers run before application containers and can be used for setup
    tasks such as fetching Secrets from an external store. If your application needs
    a configuration file populated with Secrets before it starts, an init container
    can fetch those Secrets, populate the configuration, and store it in a shared
    volume.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Init 容器在应用容器之前运行，可用于设置任务，例如从外部存储获取 Secrets。如果你的应用需要在启动之前通过配置文件填充 Secrets，Init
    容器可以获取这些 Secrets，填充配置文件并将其存储在共享卷中。
- en: 'Here’s a sample configuration:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例配置：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By incorporating this sample init container configuration, you can ensure that
    your application has access to the necessary Secrets before it starts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成这个示例 Init 容器配置，你可以确保应用在启动之前就能访问所需的 Secrets。
- en: Sidecars
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sidecar 容器
- en: Sidecars run alongside the main container in a Pod and can be used to dynamically
    manage Secrets during the Pod’s lifecycle. If your application needs to periodically
    refresh its Secrets without restarting, a sidecar can fetch the latest Secrets
    and update a shared configuration or notify the main application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Sidecar 容器与 Pod 中的主容器一起运行，可以用于在 Pod 生命周期期间动态管理 Secrets。如果你的应用需要定期刷新其 Secrets
    而不重启，Sidecar 容器可以获取最新的 Secrets，并更新共享配置或通知主应用。
- en: 'Here’s a sample configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例配置：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sidecars in Kubernetes enhance Secrets management by running alongside the main
    container, enabling dynamic updates of Secrets without needing to restart the
    application, as illustrated in the provided sample configuration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 Sidecar 容器通过与主容器并行运行，增强了 Secrets 管理，使 Secrets 可以动态更新，而无需重启应用，正如提供的示例配置所示。
- en: DaemonSets
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DaemonSets
- en: DaemonSets ensures that all (or some) nodes run a copy of a Pod, making them
    suitable for node-level tasks, such as setting up node-wide Secrets or Secrets
    management tools. If you have a node-level application (for example, a logging
    agent) that requires certain Secrets, you can use a DaemonSet to ensure each node
    fetches its own Secrets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSets 确保所有（或部分）节点运行一个 Pod 的副本，使其适合用于节点级任务，例如设置节点范围的 Secrets 或 Secrets 管理工具。如果你有一个节点级应用（例如，日志代理）需要特定的
    Secrets，可以使用 DaemonSet 确保每个节点获取自己的 Secrets。
- en: 'Here’s a sample configuration:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例配置：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By utilizing DaemonSets for such node-level operations, you ensure a consistent
    and secure distribution of Secrets across your entire Kubernetes cluster.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 DaemonSets 来进行此类节点级操作，你可以确保在整个 Kubernetes 集群中一致且安全地分发 Secrets。
- en: Environment controllers
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境控制器
- en: Different from CRDs, environment controllers don’t seek to expand the Kubernetes
    API. Instead, they dynamically manage environment variables directly within the
    Pod’s context. The advantage is direct integration at the Pod level, avoiding
    the need for additional CRD management or controller infrastructure specific to
    a new CRD. For applications that read Secrets from environment variables, and
    if you want to avoid storing these Secrets in Kubernetes directly, an environment
    controller can fetch and inject these Secrets just before the Pod starts, avoiding
    the need for the application or another container to fetch them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于 CRD，环境控制器并不寻求扩展 Kubernetes API。相反，它们直接在 Pod 的上下文中动态管理环境变量。其优势在于可以在 Pod 层级进行直接集成，避免了需要额外的
    CRD 管理或特定于新 CRD 的控制器基础设施。对于从环境变量读取 Secrets 的应用程序，如果你希望避免直接在 Kubernetes 中存储这些 Secrets，环境控制器可以在
    Pod 启动前获取并注入这些 Secrets，避免了应用程序或其他容器去获取它们的需求。
- en: 'Imagine we’re using a custom controller that watches `EnvSecret` CRD resources.
    Here’s a sample configuration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用了一个自定义控制器，它监控 `EnvSecret` CRD 资源。这里是一个示例配置：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This hypothetical `EnvSecret` CRD resource instructs the controller to fetch
    `db-credentials-in-vault` from an external store and populate it into the `DB_CREDS`
    environment variable for Pods with the label `app: my-app`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '这个假设的 `EnvSecret` CRD 资源指示控制器从外部存储中获取 `db-credentials-in-vault`，并将其填充到标签为 `app:
    my-app` 的 Pods 的 `DB_CREDS` 环境变量中。'
- en: Effectively managing Secrets throughout the Pod lifecycle ensures that applications
    have access to the necessary sensitive information when they need it while maintaining
    a high level of security.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地管理 Secrets 贯穿整个 Pod 生命周期，确保应用程序在需要时能够访问到必要的敏感信息，同时保持高水平的安全性。
- en: Specialized Kubernetes patterns – SealedSecrets
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用的 Kubernetes 模式 – SealedSecrets
- en: '**SealedSecrets** is a Kubernetes controller and tool for one-way encrypted
    Secrets. It’s designed for developers to encrypt a secret and submit it to the
    control plane (typically in a Git repository and through **continuous integration
    and continuous delivery** (**CI/CD**). Kubernetes administrators have the decryption
    key and, upon seeing the encrypted secret (a SealedSecret), the controller decrypts
    it into a regular Kubernetes secret. It enhances security by ensuring that actual
    secret values are not directly stored in a Git repository but kept in an encrypted
    format instead.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**SealedSecrets** 是一个 Kubernetes 控制器和工具，用于一键加密的 Secrets。它旨在帮助开发人员加密一个 secret
    并提交到控制平面（通常是在 Git 仓库中并通过 **持续集成和持续交付** (**CI/CD**）进行管理）。Kubernetes 管理员拥有解密密钥，并且当看到加密的
    Secret（SealedSecret）时，控制器会将其解密为常规的 Kubernetes Secret。它通过确保实际的 secret 值不会直接存储在
    Git 仓库中，而是以加密格式保存，来增强安全性。'
- en: 'The brilliance of SealedSecrets is in its simplicity: Secrets are encrypted
    in a way that only the cluster itself can decrypt, allowing for Secrets to be
    safely stored alongside the application’s configuration, typically in version
    control.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SealedSecrets 的亮点在于它的简洁性：Secrets 以只有集群本身能够解密的方式进行加密，从而允许 Secrets 安全地与应用程序的配置一起存储，通常是在版本控制中。
- en: 'Let’s walk through the distinct phases of the SealedSecrets process:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 SealedSecrets 过程的不同阶段来了解一下：
- en: '`kubeseal` CLI tool'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeseal` CLI 工具'
- en: '`kubeseal` to encrypt a secret, which creates a SealedSecret'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubeseal` 加密一个 secret，这将创建一个 SealedSecret
- en: '`kubectl`, just like any other Kubernetes resource'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl`，就像其他任何 Kubernetes 资源一样'
- en: '**Decryption**: The SealedSecret controller, running in the cluster, decrypts
    the SealedSecret and creates a standard Kubernetes secret'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解密**：SealedSecret 控制器在集群中运行，它解密 SealedSecret 并创建一个标准的 Kubernetes secret'
- en: The primary benefit of using SealedSecrets in DevOps is its ease of use. It
    allows developers to keep their application’s configuration and Secrets (in an
    encrypted form) under version control together safely. However, it’s crucial to
    note that SealedSecrets are not exactly the same as regular Kubernetes Secrets.
    When decrypted, SealedSecrets turn into standard Kubernetes Secrets within the
    cluster. These Secrets are then only accessible to the workloads that have the
    required permissions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 中使用 SealedSecrets 的主要好处是其易用性。它允许开发人员将应用程序的配置和 Secrets（加密形式）一起安全地进行版本控制。然而，值得注意的是，SealedSecrets
    与常规的 Kubernetes Secrets 并不完全相同。当解密时，SealedSecrets 会在集群内转化为标准的 Kubernetes Secrets。这些
    Secrets 只有具有相应权限的工作负载才能访问。
- en: 'Let’s briefly explore the creation and application of SealedSecrets and how
    they’re used in Pods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要探讨 SealedSecrets 的创建和应用，以及它们如何在 Pods 中使用：
- en: '**Creating** **a SealedSecret**:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建** **一个 SealedSecret**：'
- en: Here is a quick example of creating a simple Kubernetes secret.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个创建简单Kubernetes密钥的快速示例。
- en: '[PRE9]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`sealed-secret.yaml` file via `kubectl`, the SealedSecret controller will decrypt
    it and create a regular Kubernetes secret named `my-secret` in the specified namespace.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`kubectl`执行`sealed-secret.yaml`文件，SealedSecret控制器将解密该文件并在指定的命名空间中创建一个名为`my-secret`的常规Kubernetes密钥。
- en: '**Usage** **in Pods**:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Pods中的使用**：'
- en: 'Once the SealedSecret is decrypted and the regular secret is available, Pods
    can reference this secret just like any other, for example, to mount it as a volume
    or use it to set an environment variable:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦SealedSecret被解密并且常规密钥可用，Pods可以像引用其他密钥一样引用此密钥，例如，将其挂载为卷或用来设置环境变量：
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In essence, SealedSecrets facilitates the encrypted storage and management of
    Secrets outside the cluster, while the in-cluster controller ensures their safe
    decryption and transformation into accessible Kubernetes Secrets when required.
    It harmoniously bridges the gap between the operational need for secret encryption
    and the practical use of these Secrets within the Kubernetes ecosystem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，SealedSecrets使密钥在集群外部的加密存储和管理成为可能，而集群内的控制器确保它们在需要时被安全解密并转化为可访问的Kubernetes密钥。它和谐地弥合了密钥加密的操作需求与这些密钥在Kubernetes生态系统中实际使用之间的鸿沟。
- en: Secret Store CSI Driver for Kubernetes Secrets
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes密钥的Secret Store CSI驱动程序
- en: The Secret Store CSI Driver provides an advanced solution for integrating external
    Secrets management platforms with Kubernetes. This robust mechanism aims to enhance
    the security and efficiency of handling Secrets in Kubernetes workloads.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Secret Store CSI驱动程序为将外部密钥管理平台与Kubernetes集成提供了先进的解决方案。这个强大的机制旨在提高Kubernetes工作负载中处理密钥的安全性和效率。
- en: Understanding the CSI driver for Secrets management
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解用于密钥管理的CSI驱动程序
- en: 'The **Container Storage Interface** (**CSI**) is a critical standard for connecting
    various storage systems to orchestrators such as Kubernetes. In the realm of Secrets
    management, the Secret Store CSI Driver acts as this connecting bridge:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器存储接口**（**CSI**）是将各种存储系统连接到Kubernetes等调度器的关键标准。在密钥管理领域，Secret Store CSI驱动程序充当这个连接桥梁：'
- en: '**CSI driver**: Fundamentally, this is an interface between Kubernetes and
    numerous external storage systems. It has the responsibility of dynamically provisioning
    Secrets. In a world where timely access to Secrets can be crucial, the capability
    this driver offers can be invaluable.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSI驱动程序**：从根本上讲，这是Kubernetes与众多外部存储系统之间的接口。它负责动态地提供密钥。在一个密钥访问及时性至关重要的世界里，驱动程序提供的这一能力是无价的。'
- en: '`secrets-store.csi.k8s.io`, empowers Kubernetes to fetch and mount multiple
    Secrets, keys, and certificates from high-grade external secret stores. These
    are then made available to Pods as a volume. When connected, the encapsulated
    data is mounted into the Pod’s file system. This direct access ensures applications
    can readily consume the Secrets.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets-store.csi.k8s.io`使Kubernetes能够从高级外部密钥存储中提取并挂载多个密钥、证书和机密。然后，这些数据会作为卷提供给Pods。连接时，封装的数据会被挂载到Pod的文件系统中。这种直接访问确保了应用程序可以轻松使用这些密钥。'
- en: CSI driver stands as a vital bridge between Kubernetes and external storage
    solutions. Facilitating the seamless and secure provisioning of Secrets, keys,
    and certificates ensures timely access and efficient integration.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: CSI驱动程序作为Kubernetes与外部存储解决方案之间的重要桥梁。通过促进密钥、证书和机密的无缝和安全提供，确保了及时访问和高效集成。
- en: Secrets CSI Driver’s unique aspects
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥CSI驱动程序的独特方面
- en: 'The Secret Store CSI Driver boasts several distinct features:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Secret Store CSI驱动程序具有几个独特的特点：
- en: '**Dual architecture**: The driver amalgamates the CRD and DaemonSets. The CRD
    steers the custom behavior and the interaction with the external secret stores.
    On the other hand, DaemonSets ensures a copy of the driver is operational on each
    node in the cluster. This architecture ensures Secrets are uniformly available
    across the cluster.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双重架构**：驱动程序将CRD和DaemonSets结合在一起。CRD负责引导自定义行为和与外部密钥存储的交互，而DaemonSets确保驱动程序在集群中的每个节点上都有一个副本在运行。这种架构确保了密钥在集群中均匀地可用。'
- en: '`tmpfs` in-memory file system. This approach ensures Secrets aren’t written
    to node disks, enhancing security.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmpfs`内存文件系统。此方法确保密钥不会被写入节点磁盘，从而提高安全性。'
- en: '**Node-level interface**: Because it operates at the node level with the Kubernetes
    CSI interface, the driver necessitates root user privileges on each host.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点级接口**：由于它在节点级别与Kubernetes CSI接口一起工作，因此驱动程序要求每个主机上具有根用户权限。'
- en: 'The Secret Store CSI Driver stands out with its innovative dual architecture,
    direct in-memory secret mounting, and node-level operation, necessitating root
    privileges and ensuring a uniform, secure approach to Secrets management across
    Kubernetes clusters. Here is a sample configuration to demonstrate the end-to-end
    usage of the Secret Store CSI Driver:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Secret Store CSI 驱动程序凭借其创新的双重架构、直接的内存中密钥挂载和节点级操作而脱颖而出，这需要 root 权限，并确保在 Kubernetes
    集群中对 Secrets 管理的统一、安全方法。以下是一个示例配置，演示了 Secret Store CSI 驱动程序的端到端使用：
- en: '**Deploying Secret Store** **CSI Driver**:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署 Secret Store** **CSI 驱动程序**：'
- en: 'For a quick start with the Secret Store CSI Driver in Kubernetes, you can use
    Helm 3 for installation:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 Kubernetes 中快速开始使用 Secret Store CSI 驱动程序，可以使用 Helm 3 进行安装：
- en: 'Begin by adding the driver’s Helm repository with the following command:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过以下命令添加驱动程序的 Helm 仓库：
- en: '[PRE12]'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver
    --namespace kube-system
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver
    --namespace kube-system
- en: '[PRE13]'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The exact deployment steps can differ depending on your Kubernetes environment,
    but you typically have the option to use helm charts or raw YAML files. These
    are available in the official repository, which you can find at [https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver).
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 精确的部署步骤可能因 Kubernetes 环境而异，但通常你可以选择使用 helm charts 或原始 YAML 文件。这些都可以在官方仓库中找到，网址是
    [https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver)。
- en: '**Declaring** **a SecretProviderClass**:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**声明** **SecretProviderClass**：'
- en: 'This is the central object that tells the driver where and how to fetch the
    Secrets:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是告诉驱动程序在哪里以及如何获取密钥的核心对象：
- en: '[PRE14]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`SecretProviderClass` is set, you can reference it in your Pod configuration:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SecretProviderClass` 已设置，可以在你的 Pod 配置中引用它：'
- en: '[PRE15]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The provided example configuration outlines the steps to deploy the driver,
    declare a `SecretProviderClass`, and incorporate it into a Pod. Moving forward,
    let’s dive into the advantages and limitations of this approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例配置概述了部署驱动程序、声明 `SecretProviderClass` 并将其整合到 Pod 中的步骤。接下来，我们将深入探讨这种方法的优点和限制。
- en: Advantages and limitations of the Secrets CSI Driver
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Secrets CSI 驱动程序的优点和限制
- en: 'The Secret Store CSI Driver, while immensely powerful, comes with both strengths
    and challenges:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Secret Store CSI 驱动程序虽然功能强大，但也有其优点和挑战：
- en: '`tmpfs` ensures Secrets are never persisted on node disks'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmpfs` 确保 Secrets 永远不会保存在节点磁盘上'
- en: '**Dynamic updates**: Depending on the external store’s capabilities, Secrets
    can be updated dynamically, ensuring workloads have access to the latest data'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态更新**：根据外部存储的能力，Secrets 可以动态更新，确保工作负载访问最新数据'
- en: '**Limitations**:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：'
- en: '**Complex setup**: The dual nature (CRD and DaemonSet) can make the initial
    setup more complex'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的设置**：双重性质（CRD 和 DaemonSet）可能使初始设置更为复杂'
- en: '**Node-level access**: Requiring root access on every node can be seen as a
    security concern in certain environments'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点级别访问**：在每个节点上要求 root 权限在某些环境中可能被视为安全隐患'
- en: '**Provider dependencies**: Some features might be dependent on the capabilities
    of the external secret store'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者依赖**：某些功能可能依赖于外部密钥存储的能力'
- en: For comprehensive details, best practices, and community support, always refer
    to the official documentation, found at [https://secrets-store-csi-driver.sigs.k8s.io/](https://secrets-store-csi-driver.sigs.k8s.io/).
    For those interested in contributing, understanding its architecture, or exploring
    its detailed capabilities, the GitHub repository for the project is a valuable
    resource (Secret Store CSI Driver on GitHub, found at [https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息、最佳实践和社区支持，请始终参考官方文档，网址是 [https://secrets-store-csi-driver.sigs.k8s.io/](https://secrets-store-csi-driver.sigs.k8s.io/)。对于那些有兴趣贡献、了解架构或探索其详细功能的人，项目的
    GitHub 仓库是一个有价值的资源（GitHub 上的 Secret Store CSI 驱动程序，网址是 [https://github.com/kubernetes-sigs/secrets-store-csi-driver](https://github.com/kubernetes-sigs/secrets-store-csi-driver)）。
- en: In conclusion, the Secret Store CSI Driver marks a significant advancement in
    Kubernetes’ ability to manage Secrets. Adopting it can lead to more secure and
    efficient Secrets management, though like all tools, its correct implementation
    is crucial.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Secret Store CSI 驱动程序标志着 Kubernetes 在管理 Secrets 方面的重大进展。采用它可以带来更安全和高效的 Secrets
    管理，但与所有工具一样，正确的实施至关重要。
- en: Service mesh integration for secret distribution
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务网格集成用于密钥分发
- en: In the evolving world of Kubernetes, a *service mesh* has emerged as a crucial
    overlay to handle inter-service communications. Its primary value proposition
    lies in abstracting the complexity of service-to-service interactions, offloading
    developers from having to embed this logic in the application code. When it comes
    to secret distribution, especially in the context of certificates and tokens,
    a service mesh plays a pivotal role. To summarize, a service mesh is a configurable
    infrastructure layer for microservice applications that makes communication flexible,
    reliable, and fast. It’s implemented through lightweight network proxies deployed
    alongside application code without the application needing to be aware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 不断发展的世界中，*服务网格*已经成为处理服务间通信的关键叠加层。它的主要价值主张在于抽象化服务间交互的复杂性，减轻开发者将此逻辑嵌入应用代码的负担。对于密钥分发，尤其是在证书和令牌的上下文中，服务网格发挥着至关重要的作用。总而言之，服务网格是一个为微服务应用提供配置的基础设施层，使得通信变得灵活、可靠且快速。它通过轻量级网络代理实现，这些代理与应用代码一起部署，而无需应用程序感知。
- en: Secrets in service mesh – certificates and tokens
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务网格中的密钥 – 证书和令牌
- en: 'When we talk about Secrets in the context of a service mesh, we’re mostly referring
    to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务网格的上下文中谈论“密钥”时，我们主要指的是以下内容：
- en: '**Certificates**: These are used to establish trust between services in the
    mesh. **Mutual TLS** (**mTLS**) often gets employed to ensure both client and
    server services can trust each other. The service mesh automates the provisioning
    and rotation of these certificates.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书**：这些证书用于在网格中的服务之间建立信任。**互信 TLS**（**mTLS**）通常用于确保客户端和服务器服务彼此信任。服务网格自动化这些证书的提供和轮换。'
- en: '**Tokens**: For certain authentication and authorization scenarios, tokens
    (such as JWTs) might be used. These can be generated, validated, and rotated by
    the service mesh, ensuring applications don’t have to handle this complexity.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌**：对于某些身份验证和授权场景，可能会使用令牌（如JWT）。这些令牌可以由服务网格生成、验证和轮换，确保应用程序不必处理这些复杂性。'
- en: 'The service mesh simplifies and secures the management of certificates and
    tokens through automation. Within the service mesh, the handling and distribution
    of Secrets are both secure and dynamic, adhering to a well-established and commonly
    practiced procedure throughout their entire lifecycle:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格通过自动化简化并安全管理证书和令牌。在服务网格中，密钥的处理和分发既安全又动态，遵循着整个生命周期中广泛应用且成熟的流程。
- en: '**Dynamic secret creation**: A service mesh can integrate with external **certificate
    authorities** (**CAs**) or even have its built-in CA. On-demand, certificates
    are generated for services when they join the mesh.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态密钥创建**：服务网格可以与外部**证书颁发机构**（**CAs**）集成，甚至可以拥有内置的CA。按需生成证书，当服务加入网格时，自动为其创建证书。'
- en: '**Secret distribution**: Once generated, these certificates (or tokens) get
    securely distributed to the relevant services. This distribution is done through
    the sidecar proxies that accompany each service instance in the mesh.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密钥分发**：生成后，这些证书（或令牌）会被安全地分发给相关服务。这一分发过程通过与每个服务实例配套的边车代理进行。'
- en: '**Rotation and renewal**: A key benefit of using a service mesh is its capability
    to automate the rotation of Secrets. This feature enhances security by regularly
    updating these sensitive credentials. After a predefined period, Secrets are renewed
    and older ones are invalidated, all without any downtime or manual intervention.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**轮换和续期**：使用服务网格的一个关键优势是它能够自动化密钥的轮换。此功能通过定期更新这些敏感凭证来增强安全性。经过预定时间后，密钥会被续期，旧的密钥将失效，整个过程不需要停机或手动干预。'
- en: '**Revocation**: In scenarios where a service might be compromised, the service
    mesh can quickly revoke the associated Secrets, mitigating potential damage.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**吊销**：在某个服务可能被攻破的情况下，服务网格可以迅速吊销相关的密钥，减轻潜在的损害。'
- en: The service mesh automates the entire process, from creating and distributing
    certificates and tokens on-demand to managing their rotation and revocation, ensuring
    a secure and efficient operation with minimal manual intervention required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格自动化整个过程，从按需创建和分发证书及令牌到管理它们的轮换和吊销，确保安全高效的操作，并最小化手动干预。
- en: Service meshes in action – Istio
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务网格实例 – Istio
- en: While there are multiple service mesh implementations available, **Istio** stands
    out as a prominent example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多种服务网格实现可用，但**Istio**作为一个突出的例子脱颖而出。
- en: For its certificate management, Istio uses a component called **Citadel**. It
    acts as the CA, generating, distributing, rotating, and having the capability
    to revoke certificates for services in the mesh. With its built-in capabilities,
    Istio’s Citadel ensures that the mTLS communication within the mesh remains secure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其证书管理，Istio使用一个名为**Citadel**的组件。它充当证书颁发机构（CA），为网格中的服务生成、分发、轮换证书，并具有撤销证书的能力。借助其内置功能，Istio的Citadel确保网格中的mTLS通信始终保持安全。
- en: 'The following is an example configuration for enabling mTLS in Istio:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是启用Istio中mTLS的示例配置：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Istio, as a leading service mesh implementation, utilizes its Citadel component
    not only for robust certificate management to secure mutual TLS communication;
    it also extends its capabilities to include authentication, identity provisioning,
    and policy enforcement, making it a comprehensive solution for managing security
    within the service mesh architecture.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Istio作为领先的服务网格实现，利用其Citadel组件，不仅用于强大的证书管理，以确保双向TLS通信的安全；还扩展了其功能，涵盖身份验证、身份提供和策略执行，成为一个全面的解决方案，用于在服务网格架构中管理安全性。
- en: Benefits and considerations
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 好处与考虑事项
- en: Service meshes, when integrated into Kubernetes, bolster security through automated
    certificate management and enable mTLS for all communications. This ensures uniform
    application of security policies across the cluster. However, the added layer
    of sidecar proxies introduces latency and brings challenges to monitoring and
    maintenance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格在Kubernetes中集成时，通过自动化证书管理增强安全性，并为所有通信启用mTLS。这确保了安全策略在整个集群中的一致应用。然而，附加的边车代理层引入了延迟，并给监控和维护带来了挑战。
- en: For organizations already utilizing or planning to utilize a service mesh, incorporating
    it for Secrets management, especially for certificates and tokens, becomes compelling.
    Such integration simplifies Secrets management, ensuring secure transmission,
    appropriate scoping, and regular rotation. Yet, it’s crucial to recognize that
    while service meshes excel in managing certificates and tokens, they aren’t a
    one-size-fits-all solution for all secret types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已经在使用或计划使用服务网格的组织，将其用于密钥管理，特别是证书和令牌，变得非常具有吸引力。这种集成简化了密钥管理，确保了安全传输、适当的范围控制和定期轮换。然而，必须认识到，虽然服务网格在管理证书和令牌方面表现出色，但它们并不是适用于所有密钥类型的“一刀切”解决方案。
- en: In sum, when a service mesh is present in your Kubernetes setup, leveraging
    it for managing certificates and tokens can streamline operations and enhance
    security. However, it shouldn’t be seen as a complete replacement for comprehensive
    Secrets management.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当服务网格存在于Kubernetes设置中时，利用它来管理证书和令牌可以简化操作并增强安全性。然而，它不应被视为全面的密钥管理的完全替代方案。
- en: In conclusion, a service mesh enhances the Kubernetes ecosystem’s security landscape,
    especially around secret distribution in the form of certificates and tokens.
    While the benefits are manifold, like with any technology, a thorough understanding
    and diligent implementation are key to reaping its full potential.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，服务网格增强了Kubernetes生态系统的安全性，特别是在证书和令牌形式的密钥分发方面。虽然其好处多多，但和任何技术一样，彻底理解并认真实施是实现其全部潜力的关键。
- en: Broker systems in Secrets management
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理系统在密钥管理中的作用
- en: Within the expansive terrain of IT security, especially when discussing the
    realm of Secrets management, the term **broker system** emerges as an essential
    player. Acting as intermediaries, these brokers act like traffic cops, ensuring
    that applications get what they need, but only after verifying their *identity*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT安全的广阔领域，特别是在讨论密钥管理时，**代理系统**一词作为一个重要角色出现。作为中介，这些代理就像交通警察，确保应用程序在验证其*身份*后获得所需内容。
- en: 'The following can help you understand how broker mechanisms work:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容可以帮助您理解代理机制如何工作：
- en: '**Request**: An application needing a secret sends a request to the broker.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：需要密钥的应用程序向代理发送请求。'
- en: '**Validation**: The broker validates the request, often verifying the sender’s
    identity and authorization.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：代理验证请求，通常会验证发送方的身份和授权。'
- en: '**Fetch and transmit**: Once validated, the broker retrieves the secret from
    the store and securely sends it to the application.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取和传输**：一旦验证通过，代理从存储中检索密钥，并安全地将其发送到应用程序。'
- en: '**Audit and log**: All transactions, be they requests or fetches, are duly
    logged for auditing. This design ensures applications sidestep the intricacies
    of directly engaging with different secret stores; they merely need to interface
    with the broker.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计和日志**：所有事务，无论是请求还是获取，都会被适当记录以供审计。这种设计确保了应用程序避免直接与不同的密钥存储交互；它们只需要与代理进行接口对接。'
- en: 'Consider the following example. Suppose service `foo` needs to connect to a
    specific database. Instead of directly fetching the database credentials, the
    following occurs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下示例。假设服务 `foo` 需要连接到特定的数据库。与其直接获取数据库凭证，发生的情况如下：
- en: '`foo` sends a request: `I need credentials` `for DB1.`'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`foo` 发送请求：`我需要凭证` `用于 DB1。`'
- en: The broker checks whether `foo` has the right permissions for `DB1`
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理检查 `foo` 是否拥有 `DB1` 的正确权限
- en: Upon confirmation, the broker fetches and hands over the credentials
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认后，代理获取并交付凭证
- en: Throughout this process, `foo` remains agnostic to the exact secret storage
    location and the retrieval method. It safely obtains necessary database credentials
    through a broker, which validates permissions and retrieves the information, ensuring
    a secure access process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，`foo` 不关心确切的密钥存储位置和检索方法。它通过代理安全地获取必要的数据库凭证，代理验证权限并检索信息，确保了安全的访问过程。
- en: Broker mechanisms versus secretless brokers
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理机制与无密钥代理
- en: It’s easy to conflate the two given the similar terminology, but they function
    distinctly. Secretless brokers go one step further; they establish connections
    on behalf of applications without ever revealing the secret to the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于术语相似，很容易将两者混淆，但它们的功能是不同的。无密钥代理更进一步；它们代表应用程序建立连接，而不会将密钥暴露给应用程序。
- en: 'Essentially, this is how they differ:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，它们的区别如下：
- en: '**Broker mechanisms**: They deliver Secrets to applications after validations'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理机制**：它们在验证后将密钥传递给应用程序'
- en: '**Secretless brokers**: They use Secrets to facilitate a direct connection,
    keeping the Secrets hidden'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无密钥代理**：它们使用密钥促进直接连接，同时保持密钥的隐藏'
- en: Thought bubble – brokers and service mesh
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 思考泡泡 – 代理和服务网格
- en: At this juncture, it’s worth drawing a parallel with service mesh. A service
    mesh employs proxies to control and manage traffic between services in a microservices
    architecture. If you think about it, isn’t this proxy acting like a broker? Indeed,
    the service mesh’s proxy ensures secure communication between services, potentially
    managing certificates, tokens, and sometimes other Secrets. However, its primary
    focus isn’t Secrets management, but facilitating secure service-to-service communication.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，值得与服务网格进行类比。服务网格通过代理来控制和管理微服务架构中服务之间的流量。如果你仔细想想，代理不就是像一个代理吗？的确，服务网格的代理确保服务之间的安全通信，可能还会管理证书、令牌以及有时其他密钥。然而，其主要关注点并不是密钥管理，而是促进服务间的安全通信。
- en: Why do brokers still matter?
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么代理仍然重要？
- en: While secretless brokers and service meshes are making headway, traditional
    broker systems remain invaluable. They’re flexible, work with a vast array of
    applications, provide centralized control for secret distribution, allow granular
    access, and often bridge the gap for legacy systems. Their role isn’t just retrieval
    but also secret governance and lifecycle management.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无密钥代理和服务网格正在取得进展，传统的代理系统仍然不可或缺。它们灵活，适用于各种应用程序，提供密钥分发的集中控制，允许细粒度的访问，并且常常弥合遗留系统的差距。它们的角色不仅仅是检索，还包括密钥治理和生命周期管理。
- en: Exploring the realm of integrating external secret stores with Kubernetes, this
    section shed light on essential mechanisms and patterns vital for secure and efficient
    Secrets management. We kicked off with Kubernetes extensions and API mechanisms,
    illustrating how these tools can be seamlessly woven into your Secrets management
    strategy, followed by an in-depth look at Pod lifecycle and manipulation mechanisms,
    ensuring that Secrets are securely managed throughout a Pod’s lifecycle. The journey
    continued with specialized Kubernetes patterns, highlighting SealedSecrets as
    a paradigm of enhanced security, and delved into the world of service mesh integration,
    showcasing its prowess in secure secret distribution and service-to-service communication.
    The discussion was rounded off with broker systems in Secrets management, emphasizing
    their role in creating a secure, intermediary layer between applications and secret
    stores and ensuring a decoupled, flexible management system. Altogether, these
    subsections collectively forge a comprehensive guide, empowering teams to securely
    and efficiently manage Secrets in Kubernetes while navigating the complexities
    of external secret integration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 探索将外部密钥存储与Kubernetes集成的领域，本节阐明了对于安全高效的密钥管理至关重要的机制和模式。我们从Kubernetes扩展和API机制开始，展示了如何将这些工具无缝地融入到您的密钥管理策略中，接着深入研究了Pod生命周期和操作机制，确保在Pod的生命周期内，密钥始终得到安全管理。接下来的内容讨论了Kubernetes的专门模式，重点介绍了SealedSecrets这一增强安全性的范式，并深入探讨了服务网格集成，展示了其在安全密钥分发和服务间通信中的强大能力。最后，讨论了密钥管理中的代理系统，强调了它们在应用程序与密钥存储之间创建安全中介层的作用，并确保了一个解耦且灵活的管理系统。总的来说，这些子部分共同构成了一份全面的指南，帮助团队在Kubernetes中安全高效地管理密钥，同时应对外部密钥集成的复杂性。
- en: Security implications and best practices
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全隐患与最佳实践
- en: As Kubernetes gains traction, integrating it with external secret stores comes
    with specific advantages, such as specialized encryption and audit capabilities.
    However, this approach also brings its own set of challenges and security implications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Kubernetes的普及，将其与外部密钥存储集成具有一些特定的优势，如专用加密和审计能力。然而，这种方式也带来了一系列挑战和安全隐患。
- en: 'Here’s a list of them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些最佳实践的列表：
- en: '**Dependency on external systems**: Relying on external secret stores means
    introducing an additional layer of complexity and dependency. Any downtime or
    compromise in the external store can directly impact the applications running
    in the Kubernetes cluster.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对外部系统的依赖**：依赖外部密钥存储意味着引入了一个额外的复杂性和依赖层。外部存储的任何停机或安全漏洞都可能直接影响在Kubernetes集群中运行的应用程序。'
- en: '**Data transit exposure**: Transferring Secrets from the external store to
    Kubernetes could expose them if the transmission isn’t properly secured, for example,
    if it lacks end-to-end encryption.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输暴露**：如果外部存储到Kubernetes的密钥传输没有得到妥善加密保护，例如缺乏端到端加密，传输过程中可能会暴露密钥。'
- en: '**Privilege escalation through brokers or intermediaries**: Brokers or sidecars
    fetching Secrets can become potential attack vectors. A malicious actor gaining
    access to one of these can potentially siphon Secrets from the external store.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过代理或中介提升权限**：获取密钥的代理或边车可能成为潜在的攻击入口。恶意攻击者若能访问其中一个代理，可能会从外部存储中窃取密钥。'
- en: '**Configurations and access policies**: Incorrect configurations or overly
    permissive access policies in the external secret store can inadvertently expose
    sensitive Secrets.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置和访问策略**：外部密钥存储中的配置错误或过于宽松的访问策略可能会无意间暴露敏感密钥。'
- en: '**Versioning and secret rotation challenges**: If not managed properly, syncing
    secret versions between Kubernetes and the external store can be challenging,
    leading to potential mismatches or usage of outdated Secrets.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制和密钥轮换的挑战**：如果管理不当，Kubernetes与外部存储之间的密钥版本同步可能会遇到挑战，导致潜在的版本不匹配或使用过时的密钥。'
- en: 'Integrating Kubernetes with external secret stores can be challenging. Ensuring
    the security and integrity of Secrets in Kubernetes necessitates a set of robust
    practices. Here, we outline the key best practices to consider:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将Kubernetes与外部密钥存储集成可能具有挑战性。确保Kubernetes中密钥的安全性和完整性需要一系列强有力的实践。在这里，我们概述了需要考虑的关键最佳实践：
- en: '**Secure the data transit**: Always use encrypted channels (such as TLS) when
    transferring Secrets from the external store to Kubernetes. Ensure both ends of
    the communication authenticate each other.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护数据传输**：在从外部存储将密钥传输到 Kubernetes 时，始终使用加密通道（如 TLS）。确保通信的双方相互认证。'
- en: '**Restrict and monitor access**: Implement fine-grained access controls in
    the external secret store. Only allow specific entities (such as certain brokers
    or sidecars) to fetch Secrets and monitor their activities.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制并监控访问**：在外部密钥存储中实现细粒度的访问控制。只允许特定的实体（如某些代理或 sidecar）获取密钥，并监控它们的活动。'
- en: '**Secret rotation and sync**: Periodically rotate Secrets in the external store
    and ensure there’s a mechanism to propagate these changes efficiently into Kubernetes.
    This avoids stale Secrets and potential vulnerabilities.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥轮换和同步**：定期轮换外部存储中的密钥，并确保有机制高效地将这些变化同步到 Kubernetes 中。这可以避免过时的密钥和潜在的安全漏洞。'
- en: '**Harden broker or intermediary systems**: If using brokers, sidecars, or any
    other intermediary system to fetch Secrets, ensure they’re secure, monitored,
    and run with the least privilege possible.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加强代理或中介系统的安全性**：如果使用代理、sidecar 或任何其他中介系统来获取密钥，确保它们是安全的、可监控的，并且以最小权限运行。'
- en: '**Back up the external store**: Regularly back up the external secret store.
    In the event of a compromise or failure, this ensures Secrets can be restored
    and services can be brought back online quickly.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份外部存储**：定期备份外部密钥存储。在遭遇安全事件或故障时，这可以确保密钥恢复并快速使服务恢复上线。'
- en: '**Audits and anomaly detection**: Use the auditing capabilities of the external
    secret store. Monitor for any unusual access patterns or anomalies that could
    indicate a breach or misconfiguration.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计和异常检测**：利用外部密钥存储的审计功能。监控任何异常的访问模式或可能表明存在安全漏洞或配置错误的异常情况。'
- en: By acknowledging these implications and adhering to best practices, Kubernetes
    administrators can effectively and securely leverage the strengths of external
    secret stores.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过认识到这些影响并遵循最佳实践，Kubernetes 管理员可以有效且安全地利用外部密钥存储的优势。
- en: Practical and theoretical balance
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与理论的平衡
- en: When integrating Kubernetes with external secret stores, striking the right
    balance is crucial. This balance isn’t just about the technical aspects; it spans
    scalability, auditability, interoperability, and even cost implications. The goal
    is to create a robust, scalable, and secure environment that doesn’t compromise
    usability or cost efficiency.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Kubernetes 与外部密钥存储集成时，找到正确的平衡至关重要。这种平衡不仅仅涉及技术层面，还包括可扩展性、审计能力、互操作性，甚至成本影响。目标是创建一个强大、可扩展且安全的环境，而不会妥协可用性或成本效益。
- en: Security remains paramount. You must ensure that Secrets aren’t exposed during
    transit or at rest. External dependencies can introduce vulnerabilities if not
    properly managed, and a single compromise could lead to a domino effect, endangering
    multiple systems. Always ensure encrypted communications and choose secret stores
    with strong security postures.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 安全始终是最重要的。你必须确保密钥在传输过程中或静态存储时不被暴露。外部依赖如果没有得到妥善管理，可能会引入漏洞，单一的安全事件可能引发多米诺效应，危及多个系统。始终确保加密通信，并选择具有强大安全防护措施的密钥存储。
- en: Usability and the user experience are often seen as the other side of the security
    coin. A system that’s too cumbersome might lead to workarounds or shortcuts, negating
    the security benefits. Moreover, when evaluating how to apply these considerations
    in practice, it’s critical to understand the optimal usage of the various mechanisms.
    Pod lifecycle-based methods, such as init containers and sidecars, naturally align
    with direct fetch methodologies without converting to Kubernetes-native Secrets.
    In contrast, Kubernetes extensions and API mechanisms, although versatile, are
    inherently more suited for conversion to Kubernetes resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性和用户体验通常被视为安全的另一面。如果系统过于繁琐，可能会导致绕过或简化操作，从而抵消安全效益。此外，在评估如何实际应用这些考虑因素时，理解各种机制的最佳使用方式至关重要。基于
    Pod 生命周期的方法，如 init 容器和 sidecar，自然与直接获取方法对接，而无需转化为 Kubernetes 原生密钥。相比之下，Kubernetes
    扩展和 API 机制，虽然功能多样，但本质上更适合转化为 Kubernetes 资源。
- en: Granular access is crucial for modern applications. Not every application or
    service requires access to all Secrets. Properly implemented granular access minimizes
    the risk if a particular service is compromised. Legacy systems can’t always be
    ignored or replaced immediately. Therefore, any solution must consider how to
    integrate or coexist with older systems that might not have been designed with
    modern security practices in mind. Handling external dependencies is a delicate
    task. Depending too much on external systems can introduce fragility into the
    infrastructure. It’s essential to evaluate the reliability of these systems and
    have contingencies in place.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度访问对现代应用至关重要。并非每个应用或服务都需要访问所有秘密。正确实施的细粒度访问可以在某个服务被攻破时最小化风险。遗留系统并不能总是被忽视或立即替换。因此，任何解决方案都必须考虑如何与可能未按照现代安全实践设计的旧系统进行集成或共存。处理外部依赖是一项微妙的任务。过度依赖外部系统可能会给基础设施带来脆弱性。评估这些系统的可靠性并预设应急方案至关重要。
- en: 'Understanding failure and recovery models is important, as it’s a matter of
    when, not if, failures will occur; thus, having comprehensive backup and restoration
    strategies in place is imperative to restoring Secrets in the event of data corruption
    or loss. Addressing the potential secret leak blast radius is vital. Understand
    the implications of a breach: what happens if a node or an entire cluster is compromised?
    Minimize the potential damage by compartmentalizing and isolating Secrets as much
    as possible. Auditability and monitoring ensure the traceability of secret access.
    Comprehensive logs and real-time alerts help in identifying and rectifying suspicious
    activities swiftly.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 了解故障和恢复模型非常重要，因为故障发生的不是“如果”，而是“何时”；因此，必须制定全面的备份和恢复策略，以便在数据损坏或丢失时恢复秘密。处理潜在的秘密泄露影响范围至关重要。了解泄露的影响：如果一个节点或整个集群被攻破会发生什么？通过尽可能地分隔和隔离秘密，最大限度地减少潜在的损害。可审计性和监控确保秘密访问的可追溯性。全面的日志和实时警报有助于快速识别和纠正可疑活动。
- en: The scalability of the secret store must align with your organizational growth.
    As clusters and deployments grow, the secret store should seamlessly handle increased
    traffic. Lifecycle management involves managing Secrets throughout their entire
    lifecycle—creation, updates, rotations, and deletions—and seamlessly integrating
    these processes into CI/CD pipelines.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密存储的可扩展性必须与组织的增长相匹配。随着集群和部署的增长，秘密存储应该能够无缝处理增加的流量。生命周期管理涉及在整个生命周期中管理秘密——包括创建、更新、轮换和删除——并将这些过程无缝集成到CI/CD流水线中。
- en: In our multi-cloud era, interoperability is non-negotiable. Solutions must support
    diverse environments, ensuring compatibility across different cloud providers.
    Costs extend beyond direct financial implications. Consider operational costs,
    potential breach-related costs, and latency-related costs, ensuring the overall
    cost-efficiency of the solution. Geographic redundancy becomes essential for global
    operations, ensuring low latency and high availability from any location worldwide.
    Ease of transition ensures future flexibility. Avoid being locked into a particular
    solution by favoring those designed with open standards.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的多云时代，互操作性是不可谈判的。解决方案必须支持多种环境，确保跨不同云提供商的兼容性。成本不仅仅是直接的财务影响。需要考虑运营成本、潜在的泄露相关成本以及延迟相关的成本，确保解决方案的整体成本效益。地理冗余对于全球运营至关重要，确保从全球任何位置都能实现低延迟和高可用性。过渡的便捷性确保了未来的灵活性。通过优先考虑采用开放标准设计的解决方案，避免被锁定在某个特定的解决方案中。
- en: Lastly, adhere to regulatory and compliance requirements specific to your industry,
    ensuring the secret store’s compliance with standards such as ISO 27001, PCI-DSS,
    and HIPAA.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，遵守特定行业的监管和合规要求，确保秘密存储符合ISO 27001、PCI-DSS和HIPAA等标准。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Exploring the integration of Kubernetes with external secret stores reveals
    essential methods and patterns for secure and efficient Secrets management. We’ve
    delved into key mechanisms, including Kubernetes extensions, Pod lifecycle manipulations,
    and innovative tools such as the Secret Store CSI Driver, showcasing Kubernetes’
    adaptability and commitment to security.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Kubernetes与外部秘密存储的集成，揭示了安全高效的秘密管理的基本方法和模式。我们深入研究了关键机制，包括Kubernetes扩展、Pod生命周期操作，以及像Secret
    Store CSI驱动程序这样的创新工具，展示了Kubernetes的适应性和对安全性的承诺。
- en: Service mesh and broker mechanisms play crucial roles in balancing robust security
    with application agility, acting as intermediaries for secret distribution and
    decoupling applications from direct secret access. Achieving this balance requires
    attention to granular access controls, legacy systems, and the potential impacts
    of secret leaks, alongside the need for scalability, monitoring, and compliance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格和代理机制在平衡强大安全性与应用灵活性方面发挥着关键作用，它们作为中介，负责密钥的分发，并将应用与直接访问密钥解耦。实现这一平衡需要关注细粒度的访问控制、遗留系统以及密钥泄露的潜在影响，同时还要满足可扩展性、监控和合规性等需求。
- en: In conclusion, this intricate journey towards integrating Kubernetes with external
    secret stores is about creating a resilient and secure operational environment,
    ensuring a scalable and sustainable future for organizations navigating the Kubernetes
    ecosystem.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，将 Kubernetes 与外部密钥存储系统集成的这一复杂旅程，旨在创建一个强韧且安全的操作环境，确保为在 Kubernetes 生态系统中航行的组织提供可扩展且可持续的未来。
- en: Building on our exploration of integrating Kubernetes with external secret stores,
    the next chapter presents an end-to-end story of secret lifecycle management in
    a production environment. This will encompass practical applications, challenges,
    and solutions, illustrating a comprehensive approach to managing Secrets securely
    and efficiently in real-world scenarios.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索将 Kubernetes 与外部密钥存储系统集成的基础上，下一章将呈现一个关于在生产环境中管理密钥生命周期的端到端故事。此章节将涵盖实际应用、挑战与解决方案，展示一种全面的方法，以确保在实际场景中安全高效地管理密钥。
