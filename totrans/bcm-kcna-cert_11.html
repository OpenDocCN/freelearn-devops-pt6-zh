<html><head></head><body>
		<div id="_idContainer061">
			<h1 id="_idParaDest-113" class="chapter-number"><a id="_idTextAnchor112"/>11</h1>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Automating Cloud Native Application Delivery</h1>
			<p>In this chapter we will focus on Cloud Native application lifecycle. We’ll learn about best practices for development and delivery of Cloud Native apps and see how automation helps to <em class="italic">develop better</em> and <span class="No-Break"><em class="italic">ship faster</em></span><span class="No-Break">.</span></p>
			<p>This chapter covers everything you need to know about <em class="italic">Cloud Native Application Delivery</em> domain of KCNA exam that makes up 8% of the total exam questions. The following topics we’re about <span class="No-Break">to cover:</span></p>
			<ul>
				<li>Delivery of Cloud <span class="No-Break">Native applications</span></li>
				<li>CI/CD <span class="No-Break">and GitOps</span></li>
				<li>Infrastructure as a <span class="No-Break">Code (IaC)</span></li>
			</ul>
			<p>This is the last technically packed chapter of the book. You’re almost ready to take the exam and become Kubernetes and Cloud Native associate. <span class="No-Break">Carry on!</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Delivery of Cloud Native applications</h1>
			<p>Modern applications are often developed at a high velocity which requires efficient and robust <a id="_idIndexMarker626"/>delivery processes. That is why Cloud Native applications delivery is a rather complex, but highly automated process consisting of <span class="No-Break">multiple stages.</span></p>
			<p>First, developers <a id="_idIndexMarker627"/>write code and commit it to a <strong class="bold">Version Control System (VCS)</strong> such <a id="_idIndexMarker628"/>as <strong class="bold">Git</strong>, <strong class="bold">Mercurial</strong> or <strong class="bold">Subversion</strong> with Git <a id="_idIndexMarker629"/>being de-facto <a id="_idIndexMarker630"/>standard today. The code is then <em class="italic">built</em>, <em class="italic">tested</em> and <em class="italic">released</em>. Automating those stages makes it possible to speed up the whole process of software delivery and make small, frequent, and well-tested <span class="No-Break">software releases.</span></p>
			<p class="callout-heading">Release</p>
			<p class="callout">Is a version of software including the changes (new features, enhancements, bugfixes, etc.) to be delivered to the users. Each <a id="_idIndexMarker631"/>release has <strong class="bold">semantic versioning</strong> where v1.0.0 commonly stands for the <em class="italic">first stable</em> release (More about semantic versioning can be found in <em class="italic">Further </em><span class="No-Break"><em class="italic">Reading</em></span><span class="No-Break"> section).</span></p>
			<p class="callout"><em class="italic">To release</em> (as a verb) is also commonly used for describing the process of deploying to a production environment, e.g., making new software version available to the <span class="No-Break">end users.</span></p>
			<p>Strictly speaking, the application delivered doesn’t have to be Cloud Native. However, with Cloud <a id="_idIndexMarker632"/>Native architectures that are often based on microservices, it is pretty much impossible to do all the <em class="italic">build-test-release</em> stages manually. Imagine for a moment you’d have to do it 30 times for 30 different microservices – slow, error prone, and tedious work. That is why automation became an <a id="_idIndexMarker633"/>essential part of modern application lifecycle and brought us many benefits including <span class="No-Break">the following:</span></p>
			<ul>
				<li>Faster delivery times and more <span class="No-Break">frequent updates</span></li>
				<li>More stable releases with <span class="No-Break">automated processes</span></li>
				<li>More productivity as manual <span class="No-Break">work minimized</span></li>
				<li>Fewer bugs with automated <span class="No-Break">test runs</span></li>
				<li><span class="No-Break">Repeatable results</span></li>
			</ul>
			<p>Obviously, there is more to it than just <em class="italic">build-test-release</em> as every service should also be deployed, operated and monitored as suggested on <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">11</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break"> below:</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B18970_11_01.jpg" alt="Figure 11.1 – modern application lifecycle."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – modern application lifecycle.</p>
			<p>This loop is infinite, and automation of the stages makes it possible to release the changes and <a id="_idIndexMarker634"/>updates even multiple times per day. In fact, it also saves a lot of developer’s time so that they could focus on developing new features and fixing bugs. It should also be possible to roll back the changes easily and fast in case of any issues (one example of how to do it with Kubernetes and Helm was discussed previously in <a href="B18970_08.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><span class="No-Break">).</span></p>
			<p>Now that we know about the basics of Cloud Native application delivery, let’s dive into CI/CD <span class="No-Break">and GitOps.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>CI/CD and GitOps</h1>
			<p>You <a id="_idIndexMarker635"/>might <a id="_idIndexMarker636"/>have heard <a id="_idIndexMarker637"/>it before, <strong class="bold">CI</strong> stands for <strong class="bold">Continuous Integration</strong> and <strong class="bold">CD</strong> for <strong class="bold">Continuous Delivery</strong> or <a id="_idIndexMarker638"/>sometimes <span class="No-Break"><strong class="bold">Continuous Deployment</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Continuous Integration</p>
			<p class="callout">Is a practice and process automation targeting developers. With CI, code changes are regularly <em class="italic">built</em>, <em class="italic">tested</em> and <em class="italic">integrated</em> into a shared <span class="No-Break">repository (branch/trunk/etc.)</span></p>
			<p>CI is viewed as a solution to the problem of having too many changes in development at once that might conflict with each other and being hard <em class="italic">to merge</em>. The ultimate goal is to ensure <a id="_idIndexMarker639"/>that the software is always in the working state and in case automated tests fail, the team has to fix the problem first, before continuing <span class="No-Break">with development.</span></p>
			<p class="callout-heading">Continuous Delivery</p>
			<p class="callout">Usually refers to an automation in the pipeline where the tested code changes mark a <em class="italic">release</em> that is uploaded to a package repository or container image. From there on, the image or a package can be <em class="italic">deployed</em> <span class="No-Break">after approval.</span></p>
			<p>Continuous Delivery <a id="_idIndexMarker640"/>can be seen as a way to align development and business teams and its purpose is to ensure that it would take minimum time and effort to deploy new code. In Continuous Delivery, there is normally an approval that should be done by a human before the release can be deployed to a <span class="No-Break">production environment.</span></p>
			<p class="callout-heading">Continuous Deployment</p>
			<p class="callout">Is a further automation <a id="_idIndexMarker641"/>for deploying changes from the source repository to a development, testing or production environments. It is essentially Continuous Delivery except deployment happens automatically when all the tests and checks <span class="No-Break">have passed.</span></p>
			<p>Schematically, this can be seen as follows in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B18970_11_02.jpg" alt="Figure 11.2 – the CI/CD/CD pipelines."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – the CI/CD/CD pipelines.</p>
			<p>Needless to say, there are many ways how to implement CI or CD automation in any organization, and there is no <em class="italic">single right way</em> of doing it. We can use different tools, introduce custom checks or deployment schedules, involve various stakeholders for approval, etc. However, one thing that will always be present is <span class="No-Break">a </span><span class="No-Break"><strong class="bold">Pipeline</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Ci/CD Pipeline</p>
			<p class="callout">Is a top-level <a id="_idIndexMarker642"/>component which implements automation processes. Pipeline typically consists of multiple jobs and stages where output of one job or stage can be used as an input for the next job/stage. Pipeline might invoke multiple tools to compile the code, run unit tests, perform code analysis, create binaries, package code into container and <span class="No-Break">so on.</span></p>
			<p>Why we often refer to pipelines when talking about CI/CD is because many processes in software delivery have sequential steps that are executed one after another. You can think of it as a pipe where the source code comes in on one side and built and tested package come out on another side. Or, possibly, the package is being deployed on the other end. And this process repeats all over again as previously shown on <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<p>Speaking about the packages and change sets, it is considered best to release and deploy small changes often, rather than infrequently do big changes, especially when implementing <em class="italic">Continuous Deployment</em>. When the change set is small, there is much lower risk of things going wrong, so it is recommended to release and deploy small, tested changes regularly instead of deploying many changes together as <em class="italic">big bang</em> once in <span class="No-Break">a while.</span></p>
			<p>Now that we’ve covered the concept, let’s mention few tools that can help us to implement CI/CD automation. There are many tools available today and despite different feature sets, they all can be used to build and run CI/CD pipelines. Some might be a better fit for your tech stack with better support for one or another VCS, some provide Kubernetes and various IaaS/PaaS integrations, and some are only available <em class="italic">as a service</em>. CI/CD system offered as a service means provider will take care of its maintenance, updates, scaling and so on for a monthly fee. Make sure to conduct some research before picking one for <span class="No-Break">your team.</span></p>
			<p>Listed here are a few popular CI/CD systems that you might want to <span class="No-Break">check out:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">ArgoCD</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Jenkins</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Gitlab CI</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Tekton</strong></span></li>
				<li><span class="No-Break"><strong class="bold">GitHub Actions</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Spinnaker</strong></span></li>
				<li><span class="No-Break"><strong class="bold">FluxCD</strong></span></li>
				<li><span class="No-Break"><strong class="bold">GoCD</strong></span></li>
				<li><span class="No-Break"><strong class="bold">CircleCI</strong></span></li>
				<li><span class="No-Break"><strong class="bold">TravisCI</strong></span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">The <a id="_idIndexMarker643"/>presence of <em class="italic">CI</em> or <em class="italic">CD</em> in the names does not mean you can only implement <em class="italic">CI </em>or <em class="italic">CD</em> with that tool. Some of the tools could be used for implementing both <em class="italic">CI </em>and<em class="italic"> CD</em> and <span class="No-Break">some not.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>GitOps</h2>
			<p>Previously, we’ve <a id="_idIndexMarker644"/>learned about <em class="italic">DevOps</em>, <em class="italic">DevSecOps</em>, <em class="italic">FinOps,</em> and now there is one more <em class="italic">Ops</em> to go – <strong class="bold">GitOps</strong>. Introduced in 2017, it is a further evolution of industry best practices and CI/CD applied for modern infrastructure and Cloud Native <span class="No-Break">application delivery.</span></p>
			<p class="callout-heading">GitOps</p>
			<p class="callout">Is an operational framework combining DevOps practices such as Git version control, collaboration, compliance, declarative configuration, <span class="No-Break">and CI/CD.</span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B18970_11_03.jpg" alt="Figure 11.3 – overview of GitOps."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – overview of GitOps.</p>
			<p>GitOps <a id="_idIndexMarker645"/>based upon three <span class="No-Break">core elements:</span></p>
			<p><strong class="bold">Merge Requests (MR) + Infrastructure as a Code (IaC) + </strong><span class="No-Break"><strong class="bold">CI/CD</strong></span></p>
			<ol>
				<li><strong class="bold">Merge Requests</strong> are the change mechanism offered by Git version control system. MR is <a id="_idIndexMarker646"/>where the team collaborates and does code reviews and leaves comments. When a MR is approved, the changes are typically merged into the <em class="italic">main</em> (<strong class="source-inline">master</strong>) branch and commit messages along with comments serve as an <span class="No-Break">audit log.</span></li>
				<li><strong class="bold">IaC</strong> is the topic <a id="_idIndexMarker647"/>of the upcoming section, but at a high-level, it is a practice of describing desired infrastructure configuration and setup as a code that is kept in Git repository. IaC is an example of <em class="italic">declarative configuration</em> that serves as the <em class="italic">source of truth</em> for <span class="No-Break">your infrastructure.</span></li>
				<li><strong class="bold">CI/CD</strong> is an essential part of GitOps and its purpose is not just to automate the delivery stages described in the previous section, but also to avoid manual changes and <a id="_idIndexMarker648"/>eliminate <strong class="bold">infrastructure drift</strong>. Manual changes are not tolerated <span class="No-Break">with GitOps.</span></li>
			</ol>
			<p class="callout-heading">Infrastructure (configuration) drift</p>
			<p class="callout">Is when the real-time state of the infrastructure does not match what has been defined in your <em class="italic">IaC</em> configuration. Drift can be caused by manual human actions, applications making unintended changes, software bugs and <span class="No-Break">other reasons.</span></p>
			<p>Drift can cause uncertainty, application failures, and even introduce security holes. That is why eliminating infrastructure drift is very important and GitOps does this job well if implemented right. If someone did manual changes, then latest on the next MR being accepted and merged into the <em class="italic">source of truth</em> Git repository those manual changes will be overwritten and drift will <span class="No-Break">be eliminated.</span></p>
			<p>Furthermore, some advanced GitOps tools such as <em class="italic">ArgoCD</em>, <em class="italic">FluxCD</em> and <em class="italic">Jenkins X</em> have the capability <a id="_idIndexMarker649"/>to constantly watch the changes in Git repository and propagate those to a connected live environment. The system will resync and bring environment to the desired state automatically – any manual change on the live environment will be overwritten in a matter of seconds. New changes coming from code merged in Git will be deployed automatically <span class="No-Break">and fast.</span></p>
			<p>One thing to keep in mind is that <em class="italic">ArgoCD</em>, <em class="italic">FluxCD</em> and <em class="italic">Jenkins X</em> require Kubernetes cluster to run on. That does not mean it is impossible to implement GitOps without Kubernetes, but implementing it with Kubernetes is much easier due to developed ecosystem and its ultimate <em class="italic">reconciliation loop</em> functionality that brings cluster resources to the desired state (see <a href="B18970_05.xhtml#_idTextAnchor059"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> in case <span class="No-Break">you’ve forgotten).</span></p>
			<p>Let’s consider the following example to see how GitOps and K8s can complement each other. Imagine your team operates microservices on Kubernetes and specification definitions are stored in Git repository which acts as the source of truth. You use ArgoCD for GitOps that deploys K8s manifests to the target Kubernetes clusters. A new colleague has recently started in your team and got the task to decommission a microservice that is no <span class="No-Break">longer needed.</span></p>
			<p>Unfortunately, the new colleague was not fully onboarded with the processes and started deleting Kubernetes resources manually with <strong class="source-inline">kubectl</strong> which is a GitOps anti-pattern. By mistake, he/she has deleted wrong K8 Deployment which belonged to another microservice in production environment. Kubernetes controller loop kicked in and started terminating Pods managed by that Deployment, bringing wrong microservice down. Luckily, ArgoCD had auto-sync turned on and detected that the state of both affected microservices has drifted away from the definition located in Git repository. ArgoCD kicked in and quickly created missing Deployment and other manually deleted resources. The service quickly came back online. A colleague has opened a MR to change the desired state in Git correctly which got approved by the teammates and merged. In an event of wrong changes been merged into Git, it is just as easy to roll them back by simply reverting the <span class="No-Break">respective commit.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.4</em> demonstrates an example <span class="No-Break">GitOps process:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B18970_11_04.jpg" alt="Figure 11.4 – CI/CD and GitOps example with ArgoCD and Kubernetes."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – CI/CD and GitOps example with ArgoCD and Kubernetes.</p>
			<p>If you decide <a id="_idIndexMarker650"/>to implement similar process in your team or organization, consider the fact that ArgoCD is suitable for GitOps and CD, but for implementing CI, you’ll need an additional tool. That could be, for example, Argo Workflows or Gitlab CI <span class="No-Break">or similar.</span></p>
			<p>To wrap it up, GitOps is a very powerful framework that primarily focuses on CD and CI. It allows to deliver software at a very fast pace, maximize stability, increase productivity and free up productive time for the team as manual operations are automated. All configurations are transparent, auditable and reviewable. For best results and maximum efficiency, you also need to implement CI to automate testing and building of <span class="No-Break">the applications.</span></p>
			<p>Finally, let’s talk about IaC in <span class="No-Break">more detail.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Infrastructure as a Code (IaC)</h1>
			<p>IaC is the practice of managing and provisioning infrastructure in a declarative way via definition <a id="_idIndexMarker651"/>files. You describe the desired state in definition files and let a tool apply the configuration to <span class="No-Break">your environment.</span></p>
			<p>Don’t worry, despite the presence of the word <em class="italic">Code</em> that does not mean you’ll need to learn how to code in <strong class="bold">C++</strong> or <strong class="bold">Java</strong> or other advanced programming language. Most IaC tools allow configuration to be defined in <em class="italic">YAML</em> or a similar human-readable <span class="No-Break">markup language.</span></p>
			<p>IaC automates and replaces manual operations for infrastructure configuration and provisioning. Essentially, all actions that can be done using your cloud provider UI or CLI manually can be done with an IaC tool. Instead of clicking through the dashboard to configure and provision VM every time you need one, you could describe the desired number and type of VMs you need in IaC and keep that configuration in Git or other version control. Invoking an IaC tool with desired configuration will establish communication with cloud provider API and create described resources. If resources were there before and configured correctly, IaC tool won’t do any further changes. Resources that IaC can provision include VMs, load balancers, network attached storage, firewall rules, object storage buckets and <span class="No-Break">much-much more.</span></p>
			<p>Today, <strong class="bold">Terraform</strong> is one <a id="_idIndexMarker652"/>of the most popular IaC tools on the market. It supports major public and private cloud providers and most of their <span class="No-Break">IaaS/PaaS/SaaS/FaaS offerings.</span></p>
			<p>Terraform accepts JSON as well as own <strong class="source-inline">.tf</strong> definition file format and here is a small example to give you an idea what it <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 4.16"
    }
  }
  required_version = "&gt;= 1.2.0"
}
provider "aws" {
  region  = "eu-central-1"
}
resource "aws_instance" "kcna_demo_vm" {
  ami           = "ami-051835d754b74795c"
  instance_type = „t3.medium"
  tags = {
    Name = "KCNAExampleInstance"
  }
}</pre>
			<p>If applied, this <a id="_idIndexMarker653"/>definition file will provision a <strong class="source-inline">t3.medium</strong> type VM tagged <strong class="source-inline">KCNAExampleInstance</strong> in AWS public cloud in <strong class="source-inline">eu-central-1</strong> region. This VM can also be referenced again in other definition files, for example, if you’d like to attach a storage block device <span class="No-Break">to it.</span></p>
			<p>For the scope of KCNA, you don’t need to memorize the format or <strong class="source-inline">.tf</strong> specifics, but you need to remember the advantages of IaC which were already mentioned in the previous section since IaC is an essential part <span class="No-Break">of GitOps:</span></p>
			<ul>
				<li>Faster setup and <span class="No-Break">reproducible results.</span></li>
				<li>Human-readable and reviewable configuration that can be stored <span class="No-Break">in VCS.</span></li>
				<li>Elimination of infrastructure drift with desired <span class="No-Break">state definition.</span></li>
			</ul>
			<p>Worth mentioning that some cloud providers have their own, vendor specific IaC tools that might offer better support for their cloud services, but obviously won’t be compatible with <a id="_idIndexMarker654"/>any other providers. <strong class="bold">CloudFormation</strong> – an IaC made by AWS only for AWS would be such <span class="No-Break">an example.</span></p>
			<p>If you remember <a id="_idIndexMarker655"/>the exercises we did in <em class="italic">Chapters 5</em> and <em class="italic">6</em>, we basically used IaC with Kubernetes. Kubernetes uses declarative resource definitions to describe workloads but can also be used to provision load balancers (with <strong class="source-inline">LoadBalancer</strong> Service type) and persistent storage (as <em class="italic">PV</em> and <em class="italic">PVC</em>). When you run it in a public cloud environment and apply the specification, Kubernetes cloud controller manager will interact with provider APIs and ensure that resources are provisioned and in the <span class="No-Break">desired state.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Summary</h1>
			<p>In this chapter we’ve learned about the delivery of Cloud Native applications. Modern applications require CI/CD to automate all stages of <span class="No-Break">software delivery.</span></p>
			<p>Where CI focuses on the first <em class="italic">build-test-release</em> stages, <em class="italic">Continuous Delivery</em> focuses on packaging software in container images or installable software packages and uploading them into container registry or package <span class="No-Break">repositories respectively.</span></p>
			<p>Another CD – <em class="italic">Continuous Deployment</em> focuses on automatic deployment of the tested and packaged <em class="italic">releases</em> into various <span class="No-Break">live environments.</span></p>
			<p>Next, we’ve seen how <em class="italic">GitOps</em> evolved on top of <em class="italic">CI/CD</em> by adding reviewable merge (or pull) requests together with IaC. This has led to an ultimate, highly automated, and powerful process that works especially well with Kubernetes. Some of the popular tools that help implementing GitOps are <em class="italic">ArgoCD</em>, <em class="italic">FluxCD</em> and <span class="No-Break"><em class="italic">Jenkins X</em></span><span class="No-Break">.</span></p>
			<p>IaC is the practice of managing and provisioning infrastructure in a declarative way with definition files. Using IaC allows to eliminate <em class="italic">Infrastructure Drift</em> and have reviewable and reproducible infrastructure configuration. <em class="italic">Terraform</em> is one of the most popular IaC <span class="No-Break">tools today.</span></p>
			<p>Going with IaC and GitOps means no manual changes, no manual deployments or live reconfiguration is allowed. The whole team should be aware and follow the process. Git repositories act as a source of truth and CI/CD systems ensure that this desired state is reached <span class="No-Break">and maintained.</span></p>
			<p>And with that we’ve finished the last technical chapter! Congratulations and well done! In the next two chapters you’ll find a mock exam to evaluate your readiness as well as tips on how to pass the exam and what to <span class="No-Break">do after.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Questions</h1>
			<p>Correct answers can be found <span class="No-Break">at __TBD__</span></p>
			<ol>
				<li value="1">What does <span class="No-Break">CI mean?</span><ol><li><span class="No-Break">Continuous Interaction</span></li><li><span class="No-Break">Continuous Improvement</span></li><li><span class="No-Break">Continuous Integration</span></li><li><span class="No-Break">Continuous Inspection</span></li></ol></li>
				<li>Which of the following stages are the focus of CI automation (<span class="No-Break">pick multiple)?</span><ol><li><span class="No-Break">Release</span></li><li><span class="No-Break">Build, Test</span></li><li><span class="No-Break">Deploy</span></li><li><span class="No-Break">Package</span></li></ol></li>
				<li>Which of the following definitions are correct for CD (<span class="No-Break">pick multiple)?</span><ol><li><span class="No-Break">Continuous Debugging</span></li><li><span class="No-Break">Continuous Delivery</span></li><li><span class="No-Break">Continuous Destruction</span></li><li><span class="No-Break">Continuous Deployment</span></li></ol></li>
				<li>Which of the following is considered a <span class="No-Break">CI/CD practice?</span><ol><li>Frequent, large releases done by the whole <span class="No-Break">team together</span></li><li>Frequent, small, and fully <span class="No-Break">automated releases</span></li><li>Frequent, small, well tested, and <span class="No-Break">automated releases</span></li><li>Infrequent, large, and <span class="No-Break">automated releases</span></li></ol></li>
				<li>Which of the following tools are suitable for GitOps (<span class="No-Break">pick multiple)?</span><ol><li><span class="No-Break">Jenkins X</span></li><li><span class="No-Break">FluxCD</span></li><li><span class="No-Break">TravisCI</span></li><li><span class="No-Break">ArgoCD</span></li></ol></li>
				<li>Which of the following elements are a part of GitOps (<span class="No-Break">pick multiple)?</span><ol><li><span class="No-Break">Kubernetes</span></li><li><span class="No-Break">CI/CD</span></li><li><span class="No-Break">IaC</span></li><li>Merge (or <span class="No-Break">pull) Requests</span></li></ol></li>
				<li>Which VCS is used <span class="No-Break">with GitOps?</span><ol><li><span class="No-Break">Bitbucket</span></li><li><span class="No-Break">Subversion</span></li><li><span class="No-Break">Git</span></li><li><span class="No-Break">Mercurial</span></li></ol></li>
				<li>What is <span class="No-Break">infrastructure drift?</span><ol><li>When the infrastructure is fully automated and can drift <span class="No-Break">on autopilot</span></li><li>When the number of VMs in cloud has increased due to <span class="No-Break">autoscaling events</span></li><li>When the performance of VMs varies during the day depending <span class="No-Break">on demand</span></li><li>When the real infrastructure state is different from what is desired and defined <span class="No-Break">by IaC</span></li></ol></li>
				<li>What should NOT be done with established GitOps process <span class="No-Break">in team?</span><ol><li>Monitoring the <span class="No-Break">system state</span></li><li>Opening (pull) <span class="No-Break">merge requests</span></li><li>Manual changes in the <span class="No-Break">live environment</span></li><li>Reviewing teammate’s code as tests <span class="No-Break">are automated</span></li></ol></li>
				<li>What is normally defined with IaC (<span class="No-Break">pick multiple)?</span><ol><li><span class="No-Break">System architecture</span></li><li>VMs and <span class="No-Break">load balancers</span></li><li><span class="No-Break">Database migrations</span></li><li><span class="No-Break">Firewall rules</span></li></ol></li>
				<li>What are the benefits of GitOps (<span class="No-Break">pick multiple)?</span><ol><li>Faster and more stable <span class="No-Break">software delivery</span></li><li>No need to monitor live <span class="No-Break">environments anymore</span></li><li>More free time for the team due to high degree <span class="No-Break">of automation</span></li><li>All Kubernetes operations are handled <span class="No-Break">by CI/CD</span></li></ol></li>
				<li>What are the benefits of CI (<span class="No-Break">pick multiple)?</span><ol><li>Automatic deployment of <span class="No-Break">tested code</span></li><li>Automatic packaging of <span class="No-Break">tested code</span></li><li>No developer time spent for running builds <span class="No-Break">or tests</span></li><li>Issue detection with <span class="No-Break">automated tests</span></li></ol></li>
				<li>What is a correct definition of <span class="No-Break">a </span><span class="No-Break"><em class="italic">release</em></span><span class="No-Break">?</span><ol><li>A version of software to be delivered to <span class="No-Break">the users</span></li><li>A current state of application in <span class="No-Break">K8s cluster</span></li><li>A decision to stop <span class="No-Break">further development</span></li><li>A complete CI/CD <span class="No-Break">pipeline run</span></li></ol></li>
				<li>Which of the following is a <span class="No-Break">CI/CD tool?</span><ol><li><span class="No-Break">CloudFormation</span></li><li><span class="No-Break">Terraform</span></li><li><span class="No-Break">GitlabCI</span></li><li><span class="No-Break">Subversion</span></li></ol></li>
				<li>What normally triggers a deployment <span class="No-Break">in GitOps?</span><ol><li>Push into any <span class="No-Break">Git branch</span></li><li>An event of <span class="No-Break">infrastructure drift</span></li><li>Approved and merged <span class="No-Break">MR (PR)</span></li><li>Manual rebase <span class="No-Break">in Git</span></li></ol></li>
				<li>Which of the following is true about GitOps (<span class="No-Break">pick multiple)?</span><ol><li>Overwrite of <span class="No-Break">manual changes</span></li><li>It is only possible <span class="No-Break">with Kubernetes</span></li><li>Uses <span class="No-Break">declarative configuration</span></li><li>Can only be used with a few popular <span class="No-Break">programming languages</span></li></ol></li>
				<li>Which of the following stages are NOT a part of CI/CD (<span class="No-Break">pick multiple)?</span><ol><li><span class="No-Break">Monitor</span></li><li><span class="No-Break">Build</span></li><li><span class="No-Break">Plan</span></li><li><span class="No-Break">Code</span></li></ol></li>
			</ol>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Further reading</h1>
			<ul>
				<li>Semantic <span class="No-Break">versioning: </span><a href="https://semver.org/"><span class="No-Break">https://semver.org/</span></a></li>
				<li>What is <span class="No-Break">GitOps: </span><a href="https://www.weave.works/blog/what-is-gitops-really"><span class="No-Break">https://www.weave.works/blog/what-is-gitops-really</span></a></li>
				<li><span class="No-Break">ArgoCD: </span><a href="https://argo-cd.readthedocs.io/"><span class="No-Break">https://argo-cd.readthedocs.io/</span></a></li>
				<li>ArgoCD <span class="No-Break">examples: </span><a href="https://github.com/argoproj/argocd-example-apps"><span class="No-Break">https://github.com/argoproj/argocd-example-apps</span></a></li>
				<li><span class="No-Break">FluxCD: </span><a href="https://fluxcd.io/"><span class="No-Break">https://fluxcd.io/</span></a></li>
				<li>GitLab for <span class="No-Break">CI/CD: </span><a href="https://docs.gitlab.com/ee/ci/"><span class="No-Break">https://docs.gitlab.com/ee/ci/</span></a></li>
				<li><span class="No-Break">Terraform: </span><a href="https://www.terraform.io/"><span class="No-Break">https://www.terraform.io/</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer062" class="Content">
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Part 5: <span lang="en-US" xml:lang="en-US">KCNA Exam and Next Steps</span></h1>
			<p>In this closing part, you’ll find tips for preparing for and passing the exam, along with two mock exams to verify your knowledge. Finally, we’ll discuss what your next steps could be after getting certified to start or advance your cloud <span class="No-Break">native career.</span></p>
			<p>This part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18970_12.xhtml#_idTextAnchor122"><em class="italic">Chapter 12</em></a>, <em class="italic">Practicing for the KCNA Exam with Mock Papers</em></li>
				<li><a href="B18970_13.xhtml#_idTextAnchor128"><em class="italic">Chapter 13</em></a>, <em class="italic">The Road Ahead</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer063">
			</div>
		</div>
		<div>
			<div id="_idContainer064">
			</div>
		</div>
	</body></html>