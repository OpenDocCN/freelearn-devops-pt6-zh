<html><head></head><body>
		<div id="_idContainer013">
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Understanding Kubernetes and Helm</h1>
			<p>Thank you for choosing this book, <em class="italic">Learn Helm</em>. If you are interested in this book, you are probably aware of the challenges that modern applications bring. Teams face tremendous pressure to ensure that applications are lightweight and scalable. Applications must also be highly available and able to withstand varying loads. Historically, applications have most commonly been deployed as monoliths or large, single-tiered applications served on a single system. As time has progressed, the industry has shifted toward a microservice approach or small, multi-tiered applications served on multiple systems. Often deployed using container technology, the industry has started leveraging tools such as Kubernetes to orchestrate and scale their containerized microservices.</p>
			<p>Kubernetes, however, comes with its own set of challenges. While it is an effective container orchestration tool, it presents a steep learning curve that can be difficult for teams to overcome. One tool that helps simplify the challenges of running workloads on Kubernetes is Helm. Helm allows users to more simply deploy and manage the life cycle of Kubernetes applications. It abstracts many of the complexities behind configuring Kubernetes applications and allows teams to be more productive on the platform.</p>
			<p>In this book, you will explore each of the benefits offered by Helm and discover how Helm makes application deployment much simpler on Kubernetes. You will first assume the role of an end user, consuming Helm charts written by the community and learning the best practices behind leveraging Helm as a package manager. As this book progresses, you will assume the role of a chart developer and learn how to package Kubernetes applications in ways that are easily consumable and efficient. Toward the end of this book, you’ll learn about advanced patterns around application management and security with Helm.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>From monoliths to modern microservices</li>
				<li>What is Kubernetes?</li>
				<li>Deploying a Kubernetes application</li>
				<li>Approaches to resource management</li>
				<li>Resource configuration challenges</li>
				<li>Helm to the rescue!</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>From monoliths to modern microservices</h1>
			<p>Software applications<a id="_idIndexMarker000"/> are a fundamental component of most modern technology. Whether they take the form of a word processor, web browser, or streaming service, they enable user interaction to complete one or more tasks. Applications have a long and storied history, from the days of <strong class="bold">Electronic Numerical Integrator and Computer</strong> (<strong class="bold">ENIAC</strong>)—the <a id="_idIndexMarker001"/>first general-purpose computer—to taking man to the moon in the Apollo space missions, to the rise of <a id="_idIndexMarker002"/>the <strong class="bold">World Wide Web</strong> (<strong class="bold">WWW</strong>), social media, and online retail.</p>
			<p>These applications can operate on a wide range of platforms and systems, leveraging either physical or virtual computing resources. Depending on their purpose and resource requirements, entire machines may be dedicated to serving the compute and/or storage needs of an application. Fortunately, thanks in part to the realization of Moore’s law, the power and performance of microprocessors initially increased with each passing year, along with the overall cost associated with the physical resources used. This trend has subsided in recent years, but the advent of this trend and its persistence for the first 30 years of the existence of processors was instrumental to the advances in technology.</p>
			<p>Software developers took full advantage of this opportunity and bundled more features and components into their applications. As a result, a single application could consist of several smaller components, each of which, on its own, could be written as its own individual services. Initially, bundling components together yielded several benefits, including a simplified deployment process. However, as industry trends began to change and businesses focused more on the ability to deliver features more rapidly, the design of a single deployable application brought with it a number of challenges. Whenever a change was required, the entire application and all of its underlying components needed to be validated once again to ensure the change had no adverse features. This process potentially required coordination from multiple teams, which slowed the overall delivery of the feature.</p>
			<p>Delivering features more rapidly, especially across traditional divisions within organizations, was also something that organizations wanted. This concept of rapid delivery is fundamental to a practice <a id="_idIndexMarker003"/>called <strong class="bold">development-operations</strong> (<strong class="bold">DevOps</strong>), whose rise in popularity occurred around 2010. DevOps encouraged more iterative changes to applications over time, instead of extensive planning prior to development. In order to be sustainable in this new model, architectures evolved from being a single large application to instead favoring several smaller applications that could be delivered faster. Because of this change in thinking, the more traditional application design was <a id="_idIndexMarker004"/>labeled as <strong class="bold">monolithic</strong>. This new approach of breaking components down into separate applications coined a name for these components: <strong class="bold">microservices</strong>. The traits that were inherent in microservices applications<a id="_idIndexMarker005"/> brought with them several desirable features, including the ability to develop and deploy services concurrently from one another as well as to scale them (increase the number of instances) independently.</p>
			<p>The change in software architecture from monolithic to microservices also resulted in re-evaluating how applications are packaged and deployed at runtime. Traditionally, entire machines were dedicated to either one or two applications. Now, as microservices resulted in the overall reduction of resources required for a single application, dedicating an entire machine to one or two microservices was no longer viable.</p>
			<p>Fortunately, a technology called <strong class="bold">containers</strong> was <a id="_idIndexMarker006"/>introduced and gained popularity in filling in the gaps for many missing features needed to create a microservices runtime environment. Red Hat defines a container as “<em class="italic">a set of one or more processes that are isolated from the rest of the system and includes all of the files necessary to run</em>”(<a href="">https://www.redhat.com/en/topics/containers/whats-a-linux-container#:~:text=A%20Linux%C2%AE%20container%20is,testing%2C%20and%20finally%20to%20production</a>.). Containerized technology has a long history in computing, dating back to the 1970s. Many of the foundational container technologies, including <strong class="bold">chroots</strong> (the<a id="_idIndexMarker007"/> ability to change the root directory of a process and any of its children to a new location on the filesystem) and <strong class="bold">jails</strong>, are <a id="_idIndexMarker008"/>still in use today.</p>
			<p>The combination of a simple and portable packaging model, along with the ability to create many isolated sandboxes on each <a id="_idIndexMarker009"/>physical machine or <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>), led to the rapid adoption of containers in the microservices space. This rise in container popularity in the mid-2010s can also be attributed to Docker, which brought containers to the masses through simplified packaging and runtimes that could be utilized on Linux, macOS, and Windows. The ability to distribute container images with ease led to the increase in the popularity of container technologies. This was because first-time users did not need to know how to create images but instead could make use of existing images that were created by others.</p>
			<p>Containers <a id="_idIndexMarker010"/>and microservices <a id="_idIndexMarker011"/>became a match made in heaven. Applications had a packaging and distribution mechanism, along with the ability to share the same compute footprint while taking advantage of being isolated from one another. However, as more and more containerized microservices were deployed, the overall management became a concern. How do you ensure the health of each running container? What do you do if a container fails? What happens if your underlying machine does not have the compute capacity required? Enter Kubernetes, which helped answer this need for container orchestration.</p>
			<p>In the next section, we will discuss how Kubernetes works and provides value to an enterprise.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>What is Kubernetes?</h1>
			<p><strong class="bold">Kubernetes</strong>, often<a id="_idIndexMarker012"/> abbreviated as <strong class="bold">k8s</strong> (pronounced as <em class="italic">kaytes</em>), is an open source container orchestration platform. Originating from Google’s proprietary orchestration tool, Borg, the project was open sourced in 2015 and was renamed Kubernetes. Following the v1.0 release on July 21, 2015, Google and the Linux Foundation partnered to form <a id="_idIndexMarker013"/>the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>), which acts as the current maintainer of the Kubernetes project.</p>
			<p>The word <em class="italic">Kubernetes</em> is a Greek word, meaning <em class="italic">helmsman</em> or <em class="italic">pilot</em>. A helmsman<a id="_idIndexMarker014"/> is a person who is in charge of steering a ship and works closely with the ship’s officer to ensure a safe and steady course, along with the overall safety of the crew. Having similar responsibilities with regard to containers and microservices, Kubernetes is in charge of the orchestration and scheduling of containers. It is in charge of <em class="italic">steering</em> those containers to proper worker nodes that can handle their workloads. Kubernetes will also help ensure the safety of those microservices by providing <strong class="bold">high availability</strong> (<strong class="bold">HA</strong>) and <a id="_idIndexMarker015"/>health checks.</p>
			<p>Let’s review some of the ways Kubernetes helps simplify the management of containerized workloads.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Container orchestration</h2>
			<p>The most prominent feature of Kubernetes is container orchestration. This is a fairly loaded term, so we’ll break it down into different pieces.</p>
			<p>Container orchestration is<a id="_idIndexMarker016"/> about placing containers on certain machines from a<a id="_idIndexMarker017"/> pool of compute resources based on their requirements. The simplest use case for container orchestration is for deploying containers on machines that can handle their resource requirements. In the following diagram, there is an application that requests 2 <strong class="bold">Gibibytes</strong> (<strong class="bold">Gi</strong>) of memory (Kubernetes resource requests typically use their <em class="italic">power-of-two</em> values, which in this case is roughly equivalent to 2 <strong class="bold">gigabytes</strong> (<strong class="bold">GB</strong>)) and one <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) core. This means that the container will be allocated 2 Gi of memory and 1 CPU core from the underlying machine that it is scheduled on. It is up to Kubernetes to track which machines, or <strong class="bold">nodes</strong>, have the required resources available and to place an incoming container on that machine. If a node does not have enough resources to satisfy the request, the container will not be scheduled on that node. If none of the nodes in a cluster have enough resources to run the workload, the container will not be deployed. Once a node has enough resources free, the container will be deployed on the node with sufficient resources:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.1_B17979.jpg" alt="Figure 1.1 – Kubernetes orchestration and scheduling&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Kubernetes orchestration and scheduling</p>
			<p>Container<a id="_idIndexMarker018"/> orchestration relieves you of the effort required to track the available<a id="_idIndexMarker019"/> resources on machines. Kubernetes and other monitoring tools provide insight into these metrics. So, a developer can simply declare the number of resources they expect a container to use, and Kubernetes will take care of the rest on the backend.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>HA</h2>
			<p>Another benefit of Kubernetes is that it provides features that help take care of redundancy and HA. HA is a <a id="_idIndexMarker020"/>characteristic that prevents application downtime. It’s performed by a load balancer, which splits incoming traffic across multiple instances of an <a id="_idIndexMarker021"/>application. The premise of HA is that if one instance of an application goes down, other instances are still available to accept incoming traffic. In this regard, downtime is avoided, and the end user—whether a human or another microservice—remains completely unaware that there was a failed instance of the application. Kubernetes provides a networking mechanism, called a <em class="italic">service</em>, that <a id="_idIndexMarker022"/>allows applications to be load-balanced. We will talk about services in greater detail later on, in the <em class="italic">Deploying a Kubernetes application</em> section of this chapter.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Scalability</h2>
			<p>Given the lightweight nature of containers and microservices, developers can use Kubernetes to rapidly scale their workloads, both horizontally and vertically.</p>
			<p>Horizontal scaling is<a id="_idIndexMarker023"/> the act of deploying more container instances. If a team running their workloads on Kubernetes were expecting increased load, they could simply tell <a id="_idIndexMarker024"/>Kubernetes to deploy more instances of their application. Since Kubernetes is a container orchestrator, developers would not need to worry about the physical infrastructure that those applications would be deployed on. It would simply locate a node within the cluster with the available resources and deploy the additional instances there. Each extra instance would be added to a load-balancing pool, which would allow the application to continue to be highly available.</p>
			<p>Vertical scaling<a id="_idIndexMarker025"/> is the act of allocating additional memory and CPU to an application. Developers can modify the resource requirements of their applications while they are running. This will prompt Kubernetes to redeploy the running instances and reschedule them on nodes that can support the new resource requirements. Depending on how this is configured, Kubernetes can redeploy each instance in a way that prevents downtime while the new instances are being deployed.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Active community</h2>
			<p>The Kubernetes<a id="_idIndexMarker026"/> community is an incredibly active open source community. As a result, Kubernetes frequently receives patches and new features. The community has also made many contributions to documentation, both to the official Kubernetes documentation and to professional or hobbyist blog websites. In addition to documentation, the community is highly involved in planning and attending meetups and conferences around the world, which helps increase education about the platform and innovation surrounding it.</p>
			<p>Another benefit of Kubernetes’ large community is the number of different tools built to augment the abilities that are provided. Helm is one such tool. As we’ll see later in this chapter and throughout this book, Helm—a tool built by members of the Kubernetes community—vastly improves a developer’s experience by simplifying application deployments and life cycle management.</p>
			<p>With an understanding of the benefits Kubernetes brings to managing containerized workloads, let’s now discuss how an application can be deployed in Kubernetes.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Deploying a Kubernetes application</h1>
			<p>Deploying an application on Kubernetes is fundamentally similar to deploying an application outside of Kubernetes. All applications, whether containerized or not, must consider the following <a id="_idIndexMarker027"/>configuration details:</p>
			<ul>
				<li>Networking</li>
				<li>Persistent storage and file mounts</li>
				<li>Resource allocation</li>
				<li>Availability and redundancy</li>
				<li>Runtime configuration</li>
				<li>Security</li>
			</ul>
			<p>Configuring these details on Kubernetes is done by interacting with the Kubernetes <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). The Kubernetes API serves as a set of endpoints that can be interacted with to view, modify, or delete different Kubernetes resources, many of which are used to configure different details of an application.</p>
			<p>There are many different Kubernetes API resources, but the following table shows some of the most<a id="_idIndexMarker028"/> common ones:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Resource Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Definition</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Pod</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">The smallest deployable unit in Kubernetes. Encapsulates one or more containers.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">Deployment</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Used to deploy and manage a set of Pods. Maintains the desired amount of Pod replicas (1 by default).</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">StatefulSet</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Similar to a Deployment resource, except a StatefulSet maintains a sticky identity for each Pod replica and can also provision PersistentVolumeClaims resources (explained further down in this table) unique to each Pod.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">Service</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Used to load-balance between Pod replicas.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">Ingress</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Provides external access to services within the cluster.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">ConfigMap</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Stores application configuration to decouple configuration from code.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">Secret</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Used to store sensitive data such as credentials and keys. Data stored in Secrets resources are only obfuscated using Base64 encoding, so administrators must ensure that proper access controls are in place.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">PersistentVolumeClaim</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">A request for storage by a user. Used to provide persistence for running Pods.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">Role</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Represents a set of permissions to be allowed against the Kubernetes API.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">RoleBinding</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Grants the permissions defined in a role to a user or set of users.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – Common Kubernetes resources</p>
			<p>Creating resources<a id="_idIndexMarker029"/> is central to deploying and managing an application on Kubernetes, but what does a user need to do to create them? We will explore this question further in the next section.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Approaches to resource management</h1>
			<p>In order to<a id="_idIndexMarker030"/> deploy an application on Kubernetes, we need to interact with the Kubernetes API to create resources. <strong class="source-inline">kubectl</strong> is the tool we use to talk to the Kubernetes API. <strong class="source-inline">kubectl</strong> is a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) tool used to abstract the <a id="_idIndexMarker031"/>complexity of the Kubernetes API from end users, allowing them to more efficiently work on the platform.</p>
			<p>Let’s discuss how <strong class="source-inline">kubectl</strong> can be used to manage Kubernetes resources.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Imperative and declarative configurations</h2>
			<p>The <strong class="source-inline">kubectl</strong> tool provides a series of subcommands to create and modify resources in an imperative fashion. Here is a small list of these commands:</p>
			<ul>
				<li><strong class="source-inline">create</strong></li>
				<li><strong class="source-inline">describe</strong></li>
				<li><strong class="source-inline">edit</strong></li>
				<li><strong class="source-inline">delete</strong></li>
			</ul>
			<p>The <strong class="source-inline">kubectl</strong> commands follow a common format, as shown here:</p>
			<p class="source-code">kubectl &lt;verb&gt; &lt;noun&gt; &lt;arguments&gt;</p>
			<p>The <strong class="source-inline">verb</strong> refers <a id="_idIndexMarker032"/>to one of the <strong class="source-inline">kubectl</strong> subcommands, and the <strong class="source-inline">noun</strong> refers to a particular Kubernetes resource. For example, the following command can be run to create a deployment:</p>
			<p class="source-code">kubectl create deployment my-deployment --image=busybox</p>
			<p>This would instruct <strong class="source-inline">kubectl</strong> to talk to the Deployment API endpoint and create a new deployment called <strong class="source-inline">my-deployment</strong>, using the <strong class="source-inline">busybox</strong> image from Docker Hub.</p>
			<p>You could use <strong class="source-inline">kubectl</strong> to get more information on the deployment that was created by using the <strong class="source-inline">describe</strong> subcommand, as follows:</p>
			<p class="source-code">kubectl describe deployment my-deployment</p>
			<p>This command would retrieve information about the deployment and format the result in a readable format that allows developers to inspect the live <strong class="source-inline">my-deployment</strong> deployment on Kubernetes.</p>
			<p>If a change to <a id="_idIndexMarker033"/>the deployment was desired, a developer could use the <strong class="source-inline">edit</strong> subcommand to modify it in place, like this:</p>
			<p class="source-code">kubectl edit deployment my-deployment</p>
			<p>This command would open a text editor, allowing you to modify the deployment.</p>
			<p>When it comes to deleting a resource, the user could run the <strong class="source-inline">delete</strong> subcommand, as illustrated here:</p>
			<p class="source-code">kubectl delete deployment my-deployment</p>
			<p>This would call the appropriate API endpoint to delete the <strong class="source-inline">my-deployment</strong> deployment.</p>
			<p>Kubernetes resources, once created, exist in the cluster as <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) resource files, which can be exported as <strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>) files for greater human readability. An example resource in YAML format can be seen here:</p>
			<pre class="source-code">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: busybox
spec:
  replicas: 1
  selector:
    matchLabels:
      app: busybox
  template:
    metadata:
      labels:
        app: busybox
    spec:
      containers:
        - name: main
          image: busybox
          args:
            - sleep
            - infinity</pre>
			<p>The preceding YAML format presents a very basic use case. It deploys the <strong class="source-inline">busybox</strong> image from<a id="_idIndexMarker034"/> Docker Hub and runs the <strong class="source-inline">sleep</strong> command indefinitely to keep the Pod running.</p>
			<p>While it may be easier to create resources imperatively using the <strong class="source-inline">kubectl</strong> subcommands we have just described, Kubernetes allows you to directly manage the YAML resources in a declarative fashion to gain more control over resource creation. The <strong class="source-inline">kubectl</strong> subcommands do not always let you configure all the possible resource options, but creating YAML files directly allows you to more flexibly create resources and fill in the gaps that the <strong class="source-inline">kubectl</strong> subcommands may contain.</p>
			<p>When creating resources declaratively, users first write out the resource they want to create in YAML format. Next, they use the <strong class="source-inline">kubectl</strong> tool to apply the resource against the Kubernetes API. While in imperative configuration developers use <strong class="source-inline">kubectl</strong> subcommands to manage resources, declarative configuration relies primarily on only one subcommand—<strong class="source-inline">apply</strong>.</p>
			<p>Declarative configuration<a id="_idIndexMarker035"/> often takes the following form:</p>
			<p class="source-code">kubectl apply -f my-deployment.yaml</p>
			<p>This command gives Kubernetes a YAML resource that contains a resource specification, although the JSON format can be used as well. Kubernetes infers the action to perform on resources (create or modify) based on whether or not they exist.</p>
			<p>An application may be <a id="_idIndexMarker036"/>configured declaratively by following these steps:</p>
			<ol>
				<li>First, the user can create a file called <strong class="source-inline">deployment.yaml</strong> and provide a YAML-formatted specification for the deployment. We will use the same example as before, as follows:<p class="source-code">apiVersion: apps/v1</p><p class="source-code">kind: Deployment</p><p class="source-code">metadata:</p><p class="source-code">  name: busybox</p><p class="source-code">spec:</p><p class="source-code">  replicas: 1</p><p class="source-code">  selector:</p><p class="source-code">    matchLabels:</p><p class="source-code">      app: busybox</p><p class="source-code">  template:</p><p class="source-code">    metadata:</p><p class="source-code">      labels:</p><p class="source-code">        app: busybox</p><p class="source-code">    spec:</p><p class="source-code">      containers:</p><p class="source-code">        - name: main</p><p class="source-code">          image: busybox</p><p class="source-code">          args:</p><p class="source-code">            - sleep</p><p class="source-code">            - infinity</p></li>
				<li>A deployment can then be created with the following command:<p class="source-code"><strong class="bold">kubectl apply –f deployment.yaml</strong></p></li>
			</ol>
			<p>Upon running this command, Kubernetes will attempt to create a deployment in the way you specified.</p>
			<ol>
				<li value="3">If you wanted to<a id="_idIndexMarker037"/> make a change to the deployment by changing the number of replicas to <strong class="source-inline">2</strong>, you would first modify the <strong class="source-inline">deployment.yaml</strong> file, as follows:<p class="source-code">apiVersion: apps/v1</p><p class="source-code">kind: Deployment</p><p class="source-code">metadata:</p><p class="source-code">  name: busybox</p><p class="source-code">spec:</p><p class="source-code">  replicas: 2</p><p class="source-code">  selector:</p><p class="source-code">    matchLabels:</p><p class="source-code">      app: busybox</p><p class="source-code">  template:</p><p class="source-code">    metadata:</p><p class="source-code">      labels:</p><p class="source-code">        app: busybox</p><p class="source-code">    spec:</p><p class="source-code">      containers:</p><p class="source-code">        - name: main</p><p class="source-code">          image: busybox</p><p class="source-code">          args:</p><p class="source-code">            - sleep</p><p class="source-code">            - infinity</p></li>
				<li>You would then apply the change with <strong class="source-inline">kubectl apply</strong>, like this:<p class="source-code"><strong class="bold">kubectl apply –f deployment.yaml</strong></p></li>
			</ol>
			<p>After running that <a id="_idIndexMarker038"/>command, Kubernetes would apply the provided deployment declaration over the previously applied deployment. At this point, the application would scale up from a replica value of <strong class="source-inline">1</strong> to <strong class="source-inline">2</strong>.</p>
			<ol>
				<li value="5">When it comes to deleting an application, the Kubernetes documentation actually recommends doing so in an imperative manner; that is, using the <strong class="source-inline">delete</strong> subcommand instead of <strong class="source-inline">apply</strong>, as illustrated here:<p class="source-code"><strong class="bold">kubectl delete –f deployment.yaml</strong></p></li>
			</ol>
			<p>As you can see, the <strong class="source-inline">delete</strong> subcommand uses the <strong class="source-inline">–f</strong> flag to delete the resource from the given file.</p>
			<p>With an understanding of how Kubernetes resources are created, let’s now discuss some of the challenges involved in resource configuration.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Resource configuration challenges</h1>
			<p>In the previous section, we <a id="_idIndexMarker039"/>covered how Kubernetes has two different configuration methods—imperative and declarative. One question to consider is this: <em class="italic">What challenges do users need to be aware of when creating Kubernetes resources with imperative and declarative methodologies?</em></p>
			<p>Let’s discuss some of the most common challenges.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>The many types of Kubernetes resources</h2>
			<p>First of all, as described in the <em class="italic">Deploying a Kubernetes application</em> section, there are many different types of resources in Kubernetes. In order to be effective on Kubernetes, developers need to be able to determine which resources are required to deploy their applications, and they need to understand them at a deep enough level to configure them appropriately. This requires a lot of knowledge of and training on the platform. While understanding and creating resources may already sound like a large hurdle, this is actually just the beginning of many different operational challenges.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Keeping live and local states in sync</h2>
			<p>A method of configuring Kubernetes resources that we would encourage is to maintain their configuration in source control for teams to edit and share, which also allows the source control repository to become the source of truth. The configuration defined in source control (referred to as the <em class="italic">local state</em>) is then created by applying them to the Kubernetes environment, and the resources become <em class="italic">live</em> or enter what can be called a <em class="italic">live state</em>. This sounds simple enough, but what happens when developers need to make changes to their resources? The proper answer would be to modify the files in source control and<a id="_idIndexMarker040"/> apply the changes to synchronize the local state to the live state. However, this isn’t what always ends up happening. It is often simpler, in the short term, to modify the live resource in place with <strong class="source-inline">kubectl edit</strong> or <strong class="source-inline">kubectl patch</strong> and completely skip over modifying the local files. This results in state inconsistency between local and live states and is an act that makes scaling on Kubernetes difficult.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Application life cycles are hard to manage</h2>
			<p>Life cycle management is a loaded term, but in this context, we’ll refer to it as the concept of installing, upgrading, and rolling back applications. In the Kubernetes world, an installation would include API resources for deploying and configuring an application. The initial installation would create what we refer to here as version 1 of an application.</p>
			<p>An upgrade, then, can be thought of as a modification to one or many of those Kubernetes resources. Each batch of edits can be thought of as a single upgrade. A developer could modify a single service resource, which would bump the version number to version 2. The developer could then modify a deployment, a configmap, and a service at the same time, bumping the version count to version 3.</p>
			<p>As newer versions of an application continue to be rolled out onto Kubernetes, it becomes more difficult to keep track of changes that have occurred across relevant API resources. Kubernetes, in most cases, does not have an inherent way of keeping a history of changes. While this makes upgrades harder to keep track of, it also makes restoring a prior version of an application much more difficult. Say, for example, a developer previously made an incorrect edit on a particular resource. How would a team know where to roll back to? The <strong class="source-inline">n-1</strong> case is particularly easy to work out, as that is the most recent version. What happens, however, if the latest stable release was five versions ago? Teams often end up scrambling to resolve issues because they cannot quickly identify the latest stable configuration that worked previously.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Resource files are static</h2>
			<p>This is a challenge <a id="_idIndexMarker041"/>that primarily affects the declarative configuration style of applying YAML resources. Part of the difficulty in following a declarative approach is that Kubernetes resource files are not natively designed to be parameterized. Resource files are largely designed to be written out in full before being applied, and the contents remain the <strong class="bold">source of truth</strong> (<strong class="bold">SOT</strong>) until<a id="_idIndexMarker042"/> the file is modified. When dealing with Kubernetes, this can be a frustrating reality. Some API resources can be lengthy, containing many different customizable fields, and it can be quite cumbersome to write and configure YAML resources in full.</p>
			<p>Static files lend themselves to becoming boilerplate. <strong class="bold">Boilerplate</strong> represents text or code that remains largely consistent in different<a id="_idIndexMarker043"/> but similar contexts. This becomes an issue if developers manage multiple different applications, where they could potentially manage multiple different deployment resources, multiple different services, and so on. In comparing the different applications’ resource files, you may find large numbers of similar YAML configurations between them.</p>
			<p>The following screenshot depicts an example of two resources with significant boilerplate configuration between them. The blue text denotes lines that are boilerplate, while the red text denotes lines that are unique:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.2_B17979.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – An example of two resources with boilerplate</p>
			<p>Notice, in this example, that<a id="_idIndexMarker044"/> both files are almost exactly the same. When managing files that are as similar as this, boilerplate becomes a major headache for teams managing their applications in a declarative fashion.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Helm to the rescue!</h1>
			<p>Over time, the Kubernetes community discovered that creating and maintaining Kubernetes resources to deploy applications is difficult. This prompted the development of a simple yet powerful tool that would allow teams to overcome the challenges posed by deploying applications on Kubernetes. The tool that was created is called Helm. <strong class="bold">Helm</strong> is an<a id="_idIndexMarker045"/> open source tool used for packaging and deploying applications on Kubernetes. It is often referred to as the <strong class="bold">Kubernetes package manager</strong> because of its<a id="_idIndexMarker046"/> similarities to any other package manager you would find on your favorite <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>). Helm is widely used throughout the Kubernetes community and is a CNCF graduated project.</p>
			<p>Given Helm’s similarities to traditional package managers, let’s begin exploring Helm by first reviewing how a package manager works.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Understanding package managers</h2>
			<p>Package managers are <a id="_idIndexMarker047"/>used to simplify the process of installing, upgrading, reverting, and removing a system’s applications. These applications are defined as packages that contain metadata around target software and its dependencies.</p>
			<p>The idea behind package managers is simple. First, the user passes the name of a software package as an argument. The package manager then performs a lookup against a repository to see whether that package exists. If it is found, the package manager installs the application defined by the package and its dependencies to specified locations on the system.</p>
			<p>Package managers make managing software very easy. As an example, let’s imagine you wanted to install <strong class="source-inline">htop</strong>, a Linux system monitor, to a Fedora machine. Installing this would be as simple as typing a single command, as follows:</p>
			<p class="source-code">dnf install htop --assumeyes</p>
			<p>This instructs <strong class="source-inline">dnf</strong>, the Fedora package manager, to find <strong class="source-inline">htop</strong> in the Fedora package repository and install it. <strong class="source-inline">dnf</strong> also takes care of installing the <strong class="source-inline">htop</strong> package’s dependencies, so you don’t have to worry about installing its requirements beforehand. After <strong class="source-inline">dnf</strong> finds the <strong class="source-inline">htop</strong> package from the upstream repository, it asks you whether you’re sure you want to proceed. The <strong class="source-inline">--assumeyes</strong> flag automatically answers yes to this question and any other prompts that <strong class="source-inline">dnf</strong> may potentially ask.</p>
			<p>Over time, newer versions of <strong class="source-inline">htop</strong> may appear in the upstream repository. <strong class="source-inline">dnf</strong> and other package managers allow users to efficiently upgrade to new versions of the software. The subcommand that allows users to upgrade using <strong class="source-inline">dnf</strong> is <strong class="source-inline">upgrade</strong>, as illustrated here:</p>
			<p class="source-code">dnf upgrade htop --assumeyes</p>
			<p>This instructs <strong class="source-inline">dnf</strong> to upgrade <strong class="source-inline">htop</strong> to its latest version. It also upgrades its dependencies to the versions specified in the package’s metadata.</p>
			<p>While moving forward is often better, package managers also allow users to move backward and revert an application to a prior version if necessary. <strong class="source-inline">dnf</strong> does this with the <strong class="source-inline">downgrade</strong> subcommand, as illustrated here:</p>
			<p class="source-code">dnf downgrade htop --assumeyes</p>
			<p>This is a powerful process because the<a id="_idIndexMarker048"/> package manager allows users to quickly roll back if a critical bug or vulnerability is reported.</p>
			<p>If you want to remove an application completely, a package manager can take care of that as well. <strong class="source-inline">dnf</strong> provides the <strong class="source-inline">remove</strong> subcommand for this purpose, as illustrated here:</p>
			<p class="source-code">dnf remove htop --assumeyes</p>
			<p>In this section, we reviewed how the <strong class="source-inline">dnf</strong> package manager on Fedora can be used to manage a software package. Helm, as the Kubernetes package manager, is similar to <strong class="source-inline">dnf</strong>, both in its purpose and functionality. While <strong class="source-inline">dnf</strong> is used to manage applications on Fedora, Helm is used to manage applications on Kubernetes. We will explore this in greater detail next.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>The Kubernetes package manager</h2>
			<p>Given that Helm was designed to provide an experience similar to that of package managers, experienced users of <strong class="source-inline">dnf</strong> or similar tools will immediately understand Helm’s basic concepts. Things become more complicated, however, when talking about the specific <a id="_idIndexMarker049"/>implementation details. <strong class="source-inline">dnf</strong> operates on <strong class="bold">RPM Package Manager</strong> (<strong class="bold">RPM</strong>) packages <a id="_idIndexMarker050"/>that provide executables, dependency information, and metadata. Helm, on the other hand, works <a id="_idIndexMarker051"/>with <strong class="bold">charts</strong>. A Helm chart can be thought of as a Kubernetes package. Charts contain the declarative Kubernetes resource files required to deploy an application. Similar to an RPM package, it can also declare one or more dependencies that the application needs in order to run.</p>
			<p>Helm relies on repositories to provide widespread access to charts. Chart developers create declarative YAML files, package them into charts, and publish them to chart repositories. End users then use Helm to search for existing charts to deploy onto Kubernetes, similar to how end users of <strong class="source-inline">dnf</strong> will search for RPM packages to deploy to Fedora.</p>
			<p>Let’s go through a basic example. Helm can be used to deploy Redis, an in-memory cache, to Kubernetes by using a chart from an upstream repository. This can be performed using Helm’s <strong class="source-inline">install</strong> command, as illustrated here:</p>
			<p class="source-code">helm install redis bitnami/redis --namespace=redis</p>
			<p>This would install the <strong class="source-inline">redis</strong> chart from the <strong class="source-inline">bitnami</strong> repository to a Kubernetes namespace called <strong class="source-inline">redis</strong>. This installation would be referred to as the initial revision, or the initial installation of a Helm chart.</p>
			<p>If a new version of the <strong class="source-inline">redis</strong> chart becomes available, users can upgrade to the new version using the <strong class="source-inline">upgrade</strong> command, as follows:</p>
			<p class="source-code">helm upgrade redis bitnami/redis --namespace=redis</p>
			<p>This would upgrade <strong class="source-inline">redis</strong> to meet the specification defined by the newer <strong class="source-inline">redis</strong> chart.</p>
			<p>With OSs, users <a id="_idIndexMarker052"/>should be concerned about rollbacks if a bug or vulnerability is found. The same concern exists with applications on Kubernetes, and Helm provides the <strong class="source-inline">rollback</strong> command to handle this use case, as illustrated here:</p>
			<p class="source-code">helm rollback redis 1 --namespace=redis</p>
			<p>This command would roll <strong class="source-inline">redis</strong> back to its first revision.</p>
			<p>Finally, Helm provides the ability to remove <strong class="source-inline">redis</strong> altogether with the <strong class="source-inline">uninstall</strong> command, as follows:</p>
			<p class="source-code">helm uninstall redis --namespace=redis</p>
			<p>Compare <strong class="source-inline">dnf</strong> and Helm’s subcommands, and the functions they serve in the following table. Notice that <strong class="source-inline">dnf</strong> and Helm offer similar commands that provide a similar <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>):</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">dnf</strong><span lang="en-US" xml:lang="en-US"> subcommands</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Helm subcommands</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Purpose</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">install</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">Install</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Install an application and its dependencies.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">upgrade</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">Upgrade</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Upgrade an application to a newer version. Upgrade dependencies as specified by the target package.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">downgrade</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">rollback</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Revert an application to a previous version. Revert dependencies as specified by the target package.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">remove</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">uninstall</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span lang="en-US" xml:lang="en-US">Delete an application. Each tool has a different philosophy around handling dependencies.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.2 – Purpose of dnf and Helm subcommands</p>
			<p>With an understanding of how Helm functions as a package manager, let’s discuss in greater detail the benefits that Helm brings to Kubernetes.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>The benefits of Helm</h2>
			<p>Earlier in this chapter, we<a id="_idIndexMarker053"/> reviewed how Kubernetes applications are created by managing Kubernetes resources, and we discussed some of the challenges involved. Here are a few ways Helm can overcome these challenges.</p>
			<h3>Abstracting the complexity of Kubernetes resources</h3>
			<p>Let’s assume that a<a id="_idIndexMarker054"/> developer has been given the task of deploying a WordPress instance onto Kubernetes. The developer would need to create the resources required to configure its containers, network, and storage. The amount of Kubernetes knowledge required to configure such an application from scratch is high and is a big hurdle for new—and even intermediate Kubernetes users—to clear.</p>
			<p>With Helm, a developer tasked with deploying a WordPress instance could simply search for WordPress charts from upstream chart repositories. These charts would have already been written by chart developers in the community and would already contain the declarative configuration required to deploy WordPress and a backing database. Vendor-owned chart repositories also tend to be well maintained, so teams using charts from them would not <a id="_idIndexMarker055"/>need to worry about keeping Kubernetes resources up to date. In this regard, developers with this kind of task would act as simple end users that consume Helm in a similar way to any other package manager.</p>
			<h3>Maintaining an ongoing history of revisions</h3>
			<p>Helm has a concept <a id="_idIndexMarker056"/>called <strong class="bold">release history</strong>. When a Helm chart is installed for the first time, Helm adds that initial revision to the history. The history is further modified as revisions increase via upgrades, keeping various snapshots of how the application was configured at varying revisions.</p>
			<p>The following diagram <a id="_idIndexMarker057"/>depicts an<a id="_idIndexMarker058"/> ongoing history of<a id="_idIndexMarker059"/> revisions. The squares in blue illustrate resources that have been modified from their previous versions:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_1.3_B17979.jpg" alt="Figure 1.3 – An example of a revision history&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – An example of a revision history</p>
			<p>The process of tracking each revision provides opportunities for rollback. Rollbacks in Helm are very simple. Users simply point Helm to a previous revision, and Helm reverts the live state to that of the selected revision. Helm allows users to roll back their applications as far as they desire, even back to the very first installation.</p>
			<h3>Configuring declarative resources in a dynamic fashion</h3>
			<p>One of the biggest<a id="_idIndexMarker060"/> hassles with creating resources declaratively is that Kubernetes resources are static and cannot be parameterized. As you may recall from earlier, this results in resources becoming boilerplate across applications and similar configurations, making it more difficult for teams to configure their applications as code. Helm alleviates these issues by introducing <strong class="bold">values</strong> and <strong class="bold">templates</strong>.</p>
			<p>Values <a id="_idIndexMarker061"/>can be thought of as parameters for charts. Templates are dynamically generated files based on a given<a id="_idIndexMarker062"/> set of values. These two constructs give chart developers the ability to write Kubernetes resources that are generated based on values that end users provide. By doing so, applications managed by Helm become more flexible, have less boilerplate, and are easier to maintain.</p>
			<p>Values and <a id="_idIndexMarker063"/>templates allow users to do things such as this:</p>
			<ul>
				<li>Parameterize common fields, such as the image name in a deployment and the ports in a service.</li>
				<li>Generate long pieces of YAML configuration based on user input, such as volume mounts in a deployment or the data in a ConfigMap.</li>
				<li>Include or exclude resources based on user input.</li>
			</ul>
			<p>The ability to dynamically generate declarative resource files makes it simpler to create YAML-based resources while still ensuring that applications are deployed in an easily reproducible fashion.</p>
			<h3>Simplifying local and live state synchronization</h3>
			<p>Package managers prevent users from having to manage all of the intricate details of an application and its dependencies. The same idea holds true with Helm. Using Helm’s <strong class="source-inline">values</strong> construct, users <a id="_idIndexMarker064"/>can provide configuration changes <a id="_idIndexMarker065"/>across an application’s life cycle by managing a small number of parameters instead of multiple full-length YAML resources. When the local state (values/parameters) is updated, Helm propagates the configuration change out to the relevant resources in Kubernetes. This workflow keeps Helm in control of managing intricate Kubernetes details and encourages users to manage the state locally instead of updating live resources directly.</p>
			<h3>Deploying resources in an intelligent order</h3>
			<p>Helm simplifies<a id="_idIndexMarker066"/> application deployments by having a pre-determined order in which Kubernetes resources need to be created. This ordering exists to ensure that dependent resources are deployed first. For example, Secret instances and ConfigMap instances should be created before deployments, since a deployment would likely consume those resources as volumes. Helm performs this ordering without any interaction from the user, so this complexity is abstracted and prevents users from needing to<a id="_idIndexMarker067"/> understand the order in which resources should be applied.</p>
			<h3>Providing automated life cycle hooks</h3>
			<p>Similar to other<a id="_idIndexMarker068"/> package managers, Helm provides the ability to define life cycle hooks. Life cycle hooks are actions that take place automatically at different stages of an application’s life cycle. They can be used to do things such as the following:</p>
			<ul>
				<li>Perform a data backup on an upgrade.</li>
				<li>Restore data on a rollback.</li>
				<li>Validate a Kubernetes environment prior to installation.</li>
			</ul>
			<p>Life cycle hooks are valuable because they abstract complexities around tasks that may not be Kubernetes-specific. For example, a Kubernetes user may not be familiar with the best practices behind backing up a database or may not know when such a task should be performed. Life cycle hooks allow experts to write automation that handles various life cycle tasks and prevents users from needing to handle them on their own.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
			<p>In this chapter, we began by exploring the trend of adopting microservice-based architectures to decompose monoliths into smaller applications. The creation of microservices that are more lightweight and easier to manage has led to utilizing containers as a packaging and runtime format to produce releases more frequently. By adopting containers, additional operational challenges were introduced and solved by using Kubernetes as a container orchestration platform to manage the container life cycle.</p>
			<p>Our discussion turned to the various ways Kubernetes applications can be configured. These resources can be expressed using two distinct styles of application configuration: imperative and declarative. Each of these configuration styles contributes to a set of challenges involved in deploying Kubernetes applications, including the amount of knowledge required to understand how Kubernetes resources work and the challenge of managing application life cycles.</p>
			<p>To better manage each of the assets that comprise an application, Helm was introduced as the package manager for Kubernetes. Through its rich feature set, the full life cycle of applications from installation, upgrading, and, rollback to deletion can be managed with ease.</p>
			<p>In the next chapter, we’ll walk through the process of installing Helm and preparing an environment that can be used for following along with this book’s examples.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Further reading</h1>
			<p>For more information about the Kubernetes resources that make up an application, please see the <em class="italic">Understanding Kubernetes Objects</em> page from the Kubernetes documentation at <a href="B17979_01.xhtml#_idTextAnchor015">https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/</a>.</p>
			<p>To reinforce some of the benefits of Helm discussed in this chapter, please refer to the <em class="italic">Using Helm</em> page of the Helm documentation at <a href="B17979_01.xhtml#_idTextAnchor037">https://helm.sh/docs/intro/using_helm/</a>. (This page also dives into some basic usage around Helm, which will be discussed throughout this book in greater detail.)</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Questions</h1>
			<p>Here are some questions to test your knowledge of the chapter:</p>
			<ol>
				<li value="1">What is the difference between a monolithic and a microservices application?</li>
				<li>What is Kubernetes? What kinds of problems was it designed to solve?</li>
				<li>What are some of the <strong class="source-inline">kubectl</strong> commands commonly used when deploying applications to Kubernetes?</li>
				<li>What challenges are often involved in deploying applications to Kubernetes?</li>
				<li>How does Helm function as a Kubernetes package manager? How does it address the challenges posed by Kubernetes?</li>
				<li>Imagine you want to roll back an application deployed on Kubernetes. Which Helm command allows you to perform this action? How does Helm keep track of your changes to make this rollback possible?</li>
				<li>What are the four primary Helm commands?</li>
			</ol>
		</div>
	</body></html>