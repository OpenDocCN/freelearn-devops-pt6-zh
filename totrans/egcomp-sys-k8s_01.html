<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Edge Computing with Kubernetes</h1>
			<p>Edge computing is an emerging paradigm of distributed systems where the units that compute information are close to the origin of that information. The benefit of this paradigm is that it helps your system to reduce network outages and reduces the delays when you process across the cloud. This means you get a better interactive experience with your machine learning or <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) applications. This chapter covers the basics and the importance of edge computing and how Kubernetes can be used for it. It also covers different scenarios and basic architectures using low-power devices, which can use private and public clouds to exchange data.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Edge data centers using K3s and basic edge computing concepts</li>
				<li>Basic edge computing architectures with K3s</li>
				<li>Adapting your software to run at the edge</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>In this chapter, we are going to run our edge computing on an edge device (such as a <strong class="bold">Raspberry Pi</strong>), so we need to set up a cross-compiling toolchain for <strong class="bold">Advanced RISC Machines</strong> (<strong class="bold">ARM</strong>).</p>
			<p>For this, you need one of the following:</p>
			<ul>
				<li>A Mac with terminal access</li>
				<li>A PC with Ubuntu installed with terminal access</li>
				<li>A virtual machine with Ubuntu installed with terminal access</li>
			</ul>
			<p>For more detail and code snippets, check out this resource on GitHub: <a href="https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch1">https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch1</a>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Edge data centers using K3s and basic edge computing concepts</h1>
			<p>With the evolution of the cloud, companies and organizations are starting to migrate their processing <a id="_idIndexMarker000"/>tasks to edge computing devices, with the <a id="_idIndexMarker001"/>goal to reduce costs and get more benefits for <a id="_idIndexMarker002"/>the infrastructure that they are paying <a id="_idIndexMarker003"/>for. As a part of the introductory content in this book, we must learn about the basic concepts related to edge computing and understand why we use K3s for edge computing. So, let’s get started with the basic concepts.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>The edge and edge computing</h2>
			<p>According to <a id="_idIndexMarker004"/>the Qualcomm and Cisco companies, the edge can be defined as <em class="italic">“anywhere where data is processed before it crosses the Wide Area Network (WAN)”</em>; this is the edge, but what is edge computing? A post by Eric Hamilton from Cloudwards.net defines edge computing as <em class="italic">“the processing and analyzing of data along a network edge, closest to the point of its collection, so that data becomes actionable.”</em> In other words, edge computing refers to processing your data near to the source and distributing the computation in different places, using devices that are close to the source of data.</p>
			<p>To add more context, let’s explore the next figure:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16945_Figure_1.1.jpg" alt="Figure 1.1 – Components of edge layers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Components of edge layers</p>
			<p>This figure shows how the data is processed in different contexts; these contexts are the following:</p>
			<ul>
				<li><strong class="bold">Cloud layer</strong>: In this layer, you <a id="_idIndexMarker005"/>can find the cloud providers, such as AWS, Azure, GCP, and more.</li>
				<li><strong class="bold">Near edge</strong>: In this layer, you <a id="_idIndexMarker006"/>can find telecommunications infrastructure and devices, such as 5G networks, radio virtual devices, and similar devices. </li>
				<li><strong class="bold">Far edge</strong>: In this layer, you will <a id="_idIndexMarker007"/>find edge clusters, such as K3s clusters or devices that exchange data between the cloud and edge layer, but this layer can be subdivided into the tiny edge layer.</li>
				<li><strong class="bold">Tiny edge</strong>: In this layer, you will <a id="_idIndexMarker008"/>find sensors, end-user devices that exchange data with a processing device, and edge clusters on the far edge.</li>
			</ul>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Remember that edge computing refers to data that is processed on edge devices before the result goes to its destination, which could be on a public or private cloud.</p>
			<p>Other important concepts to consider for building edge clusters are the following:</p>
			<ul>
				<li><strong class="bold">Fog computing</strong>: An architecture of cloud services that distribute the system across near edge <a id="_idIndexMarker009"/>and far edge devices; these devices can be geographically dispersed.</li>
				<li><strong class="bold">Multi-Access Edge Computing</strong> (<strong class="bold">MEC</strong>): This distributes the computing at the edge <a id="_idIndexMarker010"/>of larger networks, with low latency and high bandwidth, and is the predecessor of mobile edge computing; in other words, the processing uses telecom networks and mobile devices.</li>
				<li><strong class="bold">Cloudlets</strong>: This is <a id="_idIndexMarker011"/>a small-scale cloud data center, which <a id="_idIndexMarker012"/>could be used for resource-intensive use cases, such as data analytics, <strong class="bold">Machine Learning</strong> (<strong class="bold">ML</strong>) and so on.</li>
			</ul>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Benefits of edge computing</h2>
			<p>With this <a id="_idIndexMarker013"/>short explanation, let’s move on to understand the main benefits of edge computing; some of these include the following:</p>
			<ul>
				<li><strong class="bold">Reducing latency</strong>: Edge computing can process heavy compute processes on edge devices, reducing the latency to bring this information. </li>
				<li><strong class="bold">Reducing bandwidth</strong>: Edge computing can reduce the used bandwidth while taking part of the data on the edge devices, reducing the traffic on the network.</li>
				<li><strong class="bold">Reducing costs</strong>: Reducing latency and bandwidth translates to the reduction of operational costs, which is one of the most important benefits of edge computing.</li>
				<li><strong class="bold">Improving security</strong>: Edge computing uses data aggregation and data encryption algorithms to improve the security of data access. </li>
			</ul>
			<p>Let’s now discuss containers, Docker, and containerd.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Containers, Docker, and containerd for edge computing</h2>
			<p>In the last few years, container adoption has been increasing because of the success of Docker. Docker has been <a id="_idIndexMarker014"/>the most popular container engine for <a id="_idIndexMarker015"/>the last few years. Container technology gives businesses a way to design applications using microservices architecture. This way, companies<a id="_idIndexMarker016"/> speed up their development and strategies for scaling their applications. So, to begin with a basic concept: <em class="italic">A container is a small runtime environment that packages your application with all the dependencies needed for it to run.</em> This concept is not new, but Docker, a container engine, popularized this concept. In simple words, Docker uses small operating system images with the necessary dependencies to run your software. This can be called operating system virtualization. What this does is use the <strong class="bold">cgroups</strong> kernel feature of Linux to limit CPU, memory, network, I/O, and so on for your processes. Other operating systems, such as Windows or FreeBSD, use similar features to insulate and create this type of virtualization. Let’s see the next figure to represent these concepts:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16945_Figure_1.2.jpg" alt="Figure 1.2 – Containerized applications inside the OS&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Containerized applications inside the OS</p>
			<p>This figure shows that a container doesn’t depend on special features, such as a hypervisor that is <a id="_idIndexMarker017"/>commonly seen in hardware virtualization used by VMware, Hyper-V, and Xen; instead of that, the application runs as a binary inside the container and reuses the host kernel. Let’s say that running a container is almost like <a id="_idIndexMarker018"/>running a binary program inside a directory but adds some resource limits, using cgroups in the case of Linux containers.</p>
			<p>Docker implements <a id="_idIndexMarker019"/>all these abstractions. It is a popular container toolchain that adds some versioning features, such as Git. That was the main reason it became very popular, and it features easy portability and versioning at the operating system level. At the moment, containerd is the container runtime used by Docker and Kubernetes to create containers. In general, with containerd, you can create containers without extra features; it’s very optimized. With the explosion of edge computing, containerd has become an important piece of software to run containers in low-resource environments.</p>
			<p>In general, with all these technologies you can do the following:</p>
			<ul>
				<li>Standardize how to package your software.</li>
				<li>Bring portability to your software.</li>
				<li>Maintain your software in an easier way.</li>
				<li>Run applications in low-resource environments.</li>
			</ul>
			<p>So, Docker must be taken into consideration as an important software piece to build edge computing and low-resource environments.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Distributed systems, edge computing, and Kubernetes</h2>
			<p>In the last decade, distributed systems evolved from multi-node clusters with applications using monolithic architectures to multi-node clusters with microservices architectures. One of the <a id="_idIndexMarker020"/>first options to start building microservices is to use containers, but once the system needs to scale, it is necessary to use an orchestrator. This is <a id="_idIndexMarker021"/>where Kubernetes comes into the game. </p>
			<p>As an example, let’s imagine an orchestra with lots of musicians. You can find musicians playing the piano, trumpets, and so on. But if the orchestra was disorganized, what would you need <a id="_idIndexMarker022"/>to have to organize all the musicians? The answer is an orchestra director or an orchestrator. Here is when Kubernetes appears; each musician is a container that needs to communicate or listen to other musicians and, of course, follow the instructions of the orchestra director or orchestrator. In this way, all the musicians can play their instruments at the right time and can sound beautiful. </p>
			<p>This is what Kubernetes does; it is an orchestrator of containers, but at the same time it is a platform with all the necessary prebuilt pieces to build your own distributed system, ready to scale and designed with best practices that can help you to implement agile development and a DevOps culture. Depending on your use case, sometimes it’s better to use something small such as Docker or containerd, but for complex or demanding scenarios, it’s better to use Kubernetes. </p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Edge clusters using K3s – a lightweight Kubernetes</h2>
			<p>Now, the big <a id="_idIndexMarker023"/>question is how to start building edge computing systems. Let’s get started with K3s. K3s is a Kubernetes-certified distribution created by <a id="_idIndexMarker024"/>Rancher Labs. K3s doesn’t include by default extra features that are not vital to be used on Kubernetes, but they can be added later. K3s uses containerd as its container engine, which gives K3s the ability to run on low-resource environments using ARM devices. For example, you can also run K3s on x86_64 devices in production environments. However, for the purpose of this book, we will use K3s as our main piece of software to build edge computing systems using ARM devices.</p>
			<p>Talking about clusters at the edge, K3s offers the same power as Kubernetes but in a small package and in an optimized way, plus some features designed especially for edge computing systems. K3s is very easy to use, compared with other Kubernetes distributions. It’s a lightweight Kubernetes that can be used for edge computing, sandbox environments, or whatever you want, depending on the use case.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Edge devices using ARM processors and micro data centers</h2>
			<p>Now, it’s time to talk about edge devices and ARM processors, so let’s begin with edge devices. Edge <a id="_idIndexMarker025"/>devices are designed to process and analyze information near to the data source location; this is where the <em class="italic">edge</em> computing mindset comes from. Talking about low-energy consumption devices, x86 or Intel <a id="_idIndexMarker026"/>processors consume more energy and get warmer than ARM processors. This means more power and more cooling; in other words, you will pay more money for x86_64 processors. On the other hand, ARM processors <a id="_idIndexMarker027"/>have less computational power and <a id="_idIndexMarker028"/>consume less energy. That’s the reason for the success of ARM processors on smartphone devices; they give you better cost and benefit between processing and energy consumption compared to Intel processors.</p>
			<p>Because of that, companies are interested in designing micro data centers using ARM processors in their servers. For the same reason, companies are starting to migrate their workloads to be processed by devices using ARM processors. One example is the AWS Graviton2, which is a service that offers cloud instances using ARM processors. </p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Edge computing diagrams to build your system</h1>
			<p>Right now, with all the basic concepts of containers, orchestrators, and edge computing and its layers, we can <a id="_idIndexMarker029"/>focus on the five basic diagrams of edge computing configurations that you can use to design this kind of system. So, let’s use K3s as our main platform for edge computing for the next diagrams.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Edge cluster and public cloud</h2>
			<p>This <a id="_idIndexMarker030"/>configuration shares and <a id="_idIndexMarker031"/>processes data between the public or private cloud with edge layers, but let’s explain its different layers:</p>
			<ul>
				<li><strong class="bold">Cloud layer</strong>: This layer is in the public cloud and its provider, such as AWS, Azure, or GCP. This provider <a id="_idIndexMarker032"/>can offer instances using Intel or ARM processors. For example, AWS offers the AWS Graviton2 instance if you need an ARM processor. As a complement, the public cloud can offer managed services to store data such as databases, storage, and so on. The private cloud could be in this layer too. You can find software such as VMware ESXi or OpenStack to provide this kind of service or instance locally. You can even choose a hybrid approach using the public and the private cloud. In general, this layer supports your far and tiny edge layers for storage or data processing. </li>
				<li><strong class="bold">Near edge</strong>: In this layer, you can find network devices to move all the data between the <a id="_idIndexMarker033"/>cloud layer and the far layer. Typically, these include telco devices, 5G networks, and so on.</li>
				<li><strong class="bold">Far edge</strong>: In this layer, you <a id="_idIndexMarker034"/>can find K3s clusters, similar lightweight clusters such as KubeEdge, and software such as Docker or containerd. In general, this is your local processing layer.</li>
				<li><strong class="bold">Tiny edge</strong>: This is a <a id="_idIndexMarker035"/>layer inside the far edge, where you can find edge devices such as smartwatches, IoT devices, and so on, which send data to the far edge. </li>
			</ul>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16945_Figure_1.3.jpg" alt="Figure 1.3 – Edge cluster and public cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Edge cluster and public cloud</p>
			<p>Use cases <a id="_idIndexMarker036"/>include the following:</p>
			<ul>
				<li>Scenarios where you must share data between different systems across the internet or a private cloud</li>
				<li>Distribute data processing between your cloud and the edge, such as a machine learning model generation or predictions</li>
				<li>Scenarios where you must scale IoT applications, and the response time of the application is critical</li>
				<li>Scenarios where you want to secure your data using the aggregation strategy of distributing data and encryption across the system</li>
			</ul>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Regional edge clusters and public cloud</h2>
			<p>This configuration <a id="_idIndexMarker037"/>is focused on distributing <a id="_idIndexMarker038"/>the processing strategy across different regions and sharing data across a public cloud. Let’s explain the different layers:</p>
			<ul>
				<li><strong class="bold">Cloud layer</strong>: This layer <a id="_idIndexMarker039"/>contains managed services such as databases to distribute the data across different regions.</li>
				<li><strong class="bold">Near edge</strong>: In this <a id="_idIndexMarker040"/>layer, you can find network devices to move all the data between the cloud layer and the far layer. Typically, this includes telco devices, 5G networks, and so on.</li>
				<li><strong class="bold">Far edge</strong>: In this <a id="_idIndexMarker041"/>layer, you can find K3s clusters across different regions. These clusters or nodes can share or update the data stored in a public cloud.</li>
				<li><strong class="bold">Tiny edge</strong>: Here, you <a id="_idIndexMarker042"/>can find different edge devices close to each region where the far edge clusters process the information because of this distributed configuration.</li>
			</ul>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B16945_Figure_1.4.jpg" alt="Figure 1.4 – Regional edge cluster and public cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Regional edge cluster and public cloud</p>
			<p>Use cases <a id="_idIndexMarker043"/>include the following:</p>
			<ul>
				<li>Different cluster configurations across different regions</li>
				<li>Reducing application response time, choosing the closest data, or processing node location, which is critical in IoT applications</li>
				<li>Sharing data across different regions</li>
				<li>Distributing processing across different regions</li>
			</ul>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Single node cluster and public/private cloud</h2>
			<p>This is <a id="_idIndexMarker044"/>a basic configuration where a single <a id="_idIndexMarker045"/>computer processes all the information <a id="_idIndexMarker046"/>captured <a id="_idIndexMarker047"/>on tiny edge devices. Let’s explain the different layers:</p>
			<ul>
				<li><strong class="bold">Cloud layer</strong>: In this <a id="_idIndexMarker048"/>layer, you <a id="_idIndexMarker049"/>can find the data storage for the system. It could be placed on the public or private cloud.</li>
				<li><strong class="bold">Near edge</strong>: In this <a id="_idIndexMarker050"/>layer, you <a id="_idIndexMarker051"/>can find network devices to move all the data between the cloud layer and the far layer. Typically, this includes telco devices, 5G networks, and so on.</li>
				<li><strong class="bold">Far edge</strong>: In <a id="_idIndexMarker052"/>this layer, you can <a id="_idIndexMarker053"/>find a single node K3s cluster that recollects data from tiny edge devices.</li>
				<li><strong class="bold">Tiny edge</strong>: Devices <a id="_idIndexMarker054"/>that capture <a id="_idIndexMarker055"/>data, such as smartwatches, tablets, cameras, sensors, and so on. This kind of configuration is more for processing locally or on a small scale.</li>
			</ul>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B16945_Figure_1.5.jpg" alt="Figure 1.5 – Single node cluster and public/private cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Single node cluster and public/private cloud</p>
			<p>Use cases <a id="_idIndexMarker056"/>include the following:</p>
			<ul>
				<li>Low-cost <a id="_idIndexMarker057"/>and low-energy consumption environments</li>
				<li>Green edge applications that can be powered by solar panels or wind turbines</li>
				<li>Small processes or use cases, such as analyzing health records or autonomous house systems that need something local or not too complicated</li>
			</ul>
			<p>Let’s now adapt the software to run at the edge.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Adapting your software to run at the edge</h1>
			<p>Something important while designing an edge computing system is to choose the processor <a id="_idIndexMarker058"/>architecture to build your software. One popular architecture because of the lower consumption for computing is ARM, but if ARM is the selected architecture, it is necessary to transform your current code in most of the cases from x86_64 (Intel) to ARM (ARMv7 such as RI and ARM such as AWS Graviton2 instances). The following subsections include short guides to perform the process to convert from one platform to another; this process is called cross-compiling. With this, you will be able to run your software on ARM devices using Go, Python, Rust, and Java. So, let’s get started.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Adapting Go to run on ARM</h2>
			<p>First, it’s <a id="_idIndexMarker059"/>necessary to install Go on your system. Here are a couple of ways to install Go.</p>
			<h3>Installing Go on Linux</h3>
			<p>To install <a id="_idIndexMarker060"/>Go on Linux, execute the following steps:</p>
			<ol>
				<li>Download and untar the Go official binaries: <p class="source-code"><strong class="bold">$ wget https://golang.org/dl/go1.15.linux-amd64.tar.gz</strong></p><p class="source-code"><strong class="bold">$ tar -C /usr/local -xzf go1.15.linux-amd64.tar.gz</strong></p></li>
				<li>Set the environment variables to run Go:<p class="source-code"><strong class="bold">$ mkdir $HOME/go</strong></p></li>
				<li>Set your <strong class="source-inline">GOPATH</strong> in the configuration file of your terminal with the following lines. <strong class="source-inline">~/.profile</strong> is a common file to set these environment variables; let’s modify the <strong class="source-inline">.profile</strong> file:<p class="source-code"><strong class="bold">$ export PATH=$PATH:/usr/local/go/bin</strong></p><p class="source-code"><strong class="bold">$ export GOPATH=$HOME/go</strong></p></li>
				<li>Load the new configuration using the following command:<p class="source-code"><strong class="bold">$ . ~/.profile</strong></p><p class="source-code"><strong class="bold">$ mkdir $GOPATH/src</strong></p></li>
				<li>(<em class="italic">Optional</em>). If you want to, you can set these environment variables temporarily in your terminal using the following commands:<p class="source-code"><strong class="bold">$ export PATH=$PATH:/usr/local/go/bin</strong></p><p class="source-code"><strong class="bold">$ export GOPATH=$HOME/go</strong></p></li>
				<li>To check whether <strong class="source-inline">GOPATH</strong> is configured, run the following command:<p class="source-code"><strong class="bold">$ go env GOPATH</strong></p></li>
			</ol>
			<p>Now, you are <a id="_idIndexMarker061"/>ready to use Go on Linux. Let’s move to this installation using a Mac.</p>
			<h3>Installing Go on a Mac</h3>
			<p>To install <a id="_idIndexMarker062"/>Go on a Mac, execute the following steps:</p>
			<ol>
				<li value="1">Install Homebrew (called <strong class="source-inline">brew</strong>) with the following command: <p class="source-code"><strong class="bold">$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</strong></p></li>
				<li>Once it is installed, install Go with <strong class="source-inline">brew</strong>:<p class="source-code"><strong class="bold">$ brew install go</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note </p>
			<p class="callout">To find out how to install <strong class="source-inline">brew</strong>, you can check the official page at <a href="https://brew.sh">https://brew.sh</a>.</p>
			<h3>Cross-compiling from x86_64 to ARM with Go</h3>
			<p>To <a id="_idIndexMarker063"/>cross-compile from x86_64 to ARM, execute the following steps:</p>
			<ol>
				<li value="1">Create a folder to store your code:<p class="source-code"><strong class="bold">$ cd ~/</strong></p><p class="source-code"><strong class="bold">$ mkdir goproject</strong></p><p class="source-code"><strong class="bold">$ cd goproject</strong></p></li>
				<li>Create an initial Go configuration to install external Go libraries outside the <strong class="source-inline">GOPATH</strong> command; for this, execute the next command:<p class="source-code"><strong class="bold">$ go mod init main</strong></p></li>
				<li>Create the <strong class="source-inline">example.go</strong> file with <strong class="source-inline">Hello World</strong> as its contents:<p class="source-code"><strong class="bold">$ cat &lt;&lt; EOF &gt; example.go</strong></p><p class="source-code"><strong class="bold">package main</strong></p><p class="source-code"><strong class="bold">import "fmt"</strong></p><p class="source-code"><strong class="bold">func main() {</strong></p><p class="source-code"><strong class="bold">   fmt.Println("Hello World") </strong></p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code"><strong class="bold">EOF</strong></p></li>
				<li>Assuming <a id="_idIndexMarker064"/>that your environment is under x86_64 and you want to cross-compile for ARMv7 support, execute the following commands:<p class="source-code"><strong class="bold">$ env GOOS=linux GOARM=7 GOARCH=arm go build example.go</strong></p></li>
			</ol>
			<p>Use the next line for ARMv8 64-bit support:</p>
			<p class="source-code"><strong class="bold">$ env GOOS=linux GOARCH=arm64 go build example.go</strong></p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you want to see other options for cross-compiling, see <a href="https://github.com/golang/go/wiki/GoArm">https://github.com/golang/go/wiki/GoArm</a>.</p>
			<p>Set the execution permissions for the generated binary:</p>
			<p class="source-code"><strong class="bold">$ chmod 777 example</strong></p>
			<p class="source-code"><strong class="bold">$ ./example</strong></p>
			<ol>
				<li value="5">Copy <a id="_idIndexMarker065"/>the generated binary to your ARM device and test if it works.</li>
			</ol>
			<p>In the next section, we will learn how to adapt Rust to run on ARM.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Adapting Rust to run on ARM </h2>
			<p>First, it’s necessary <a id="_idIndexMarker066"/>to install Rust on your system. Here are a couple of ways to install Rust. </p>
			<h3>Installing Rust on Linux </h3>
			<p>To install <a id="_idIndexMarker067"/>Rust on Linux, execute the following steps: </p>
			<ol>
				<li value="1">Install Rust by executing the following command in the terminal: <p class="source-code"><strong class="bold">$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh </strong></p></li>
				<li>Set the path for Rust in the configuration file of your terminal. For example, if you are using Bash, add the following line to your <strong class="source-inline">.bashrc</strong>:<p class="source-code"><strong class="bold">$ export PATH=$PATH:$HOME/.cargo/bin</strong></p></li>
			</ol>
			<h3>Installing Rust on a Mac</h3>
			<p>To install <a id="_idIndexMarker068"/>Rust on a Mac, execute the following steps:</p>
			<ol>
				<li value="1">Install Homebrew with the following command: <p class="source-code"><strong class="bold">$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</strong></p></li>
				<li>Once it is installed, install <strong class="source-inline">rustup</strong> with <strong class="source-inline">brew</strong>: <p class="source-code"><strong class="bold">$ brew install rustup-init</strong></p></li>
				<li>Run the <strong class="source-inline">rustup</strong> command to install Rust and all the necessary tools for Rust with the following command: <p class="source-code"><strong class="bold">$ rustup-init</strong></p></li>
				<li>Set your <a id="_idIndexMarker069"/>terminal environment variables by adding the following line to your terminal configuration file:<p class="source-code"><strong class="bold">$ export PATH=$PATH:$HOME/.cargo/bin</strong></p></li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Mac users often use the ZSH terminal, so they have to use <strong class="source-inline">.zshrc</strong>. If you are using another terminal, look for the proper configuration file or the generic <strong class="source-inline">/etc/profile</strong>.</p>
			<h3>Cross-compiling from x86_64 to ARMv7 with Rust on a Mac</h3>
			<p>To <a id="_idIndexMarker070"/>cross-compile from x86_64 to ARM, execute the following steps:</p>
			<ol>
				<li value="1">Install the complements to match the compiler and environment variables for ARMv7 architecture on your Mac; for this, execute the following command:<p class="source-code"><strong class="bold">$ brew tap messense/macos-cross-toolchains</strong></p></li>
				<li>Download the support for ARMv7 for cross-compiling by executing the following command:<p class="source-code"><strong class="bold">$ brew install armv7-unknown-linux-gnueabihf</strong></p></li>
				<li>Now set the environment variables:<p class="source-code"><strong class="bold">$ export CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc</strong></p><p class="source-code"><strong class="bold">$ export CXX_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-g++</strong></p><p class="source-code"><strong class="bold">$ export AR_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-ar</strong></p><p class="source-code"><strong class="bold">$ export CARGO_TARGET_ARMV7_UNKNOWN_LINUX_GNUEABIHF_LINKER=armv7-unknown-linux-gnueabihf-gcc</strong></p></li>
				<li>Create a folder to store your code:<p class="source-code"><strong class="bold">$ cd ~/</strong></p><p class="source-code"><strong class="bold">$ mkdir rustproject</strong></p><p class="source-code"><strong class="bold">$ cd rustproject</strong></p></li>
				<li>Create <a id="_idIndexMarker071"/>an initial <strong class="source-inline">Hello World</strong> project with Rust:<p class="source-code"><strong class="bold">$ cargo new hello-rust</strong></p><p class="source-code"><strong class="bold">$ cd hello-rust</strong></p></li>
			</ol>
			<p>The generated Rust code will look like this:</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">  println!("Hello, world!");</p>
			<p class="source-code">}</p>
			<p>The source code will be located at <strong class="source-inline">src/main.rs</strong>.</p>
			<ol>
				<li value="6">Add the support for ARMv7:<p class="source-code"><strong class="bold">$ rustup target add armv7-unknown-linux-gnueabi</strong></p></li>
				<li>Build your software:<p class="source-code"><strong class="bold">$ cargo build --target=armv7-unknown-linux-gnueabi</strong></p></li>
				<li>Copy the binary file into your device and test whether it works:<p class="source-code"><strong class="bold">$ cargo build --target=armv7-unknown-linux-gnueabi</strong></p></li>
				<li>The generated binary will be inside the <strong class="source-inline">target/armv7-unknown-linux-gnueabi/hello-rust</strong> folder.</li>
				<li>Now copy your binary into your device and test whether it works.</li>
			</ol>
			<p class="callout-heading">Important Note</p>
			<p class="callout">For more options for cross-compiling with Rust, check out <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">https://doc.rust-lang.org/nightly/rustc/platform-support.html</a> and <a href="https://rust-lang.github.io/rustup/cross-compilation.html">https://rust-lang.github.io/rustup/cross-compilation.html</a>. For the toolchain for Mac and AArch64 (64-bit ARMv8), check out <strong class="source-inline">aarch64-unknown-linux-gnu</strong> inside the repository at <a href="https://github.com/messense/homebrew-macos-cross-toolchains">https://github.com/messense/homebrew-macos-cross-toolchains</a>.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Adapting Python to run on ARM</h2>
			<p>First, it is <a id="_idIndexMarker072"/>necessary to install Python on your system. There are a couple of ways of doing this.</p>
			<h3>Installing Python on Linux</h3>
			<p>To install <a id="_idIndexMarker073"/>Python, execute the following steps:</p>
			<ol>
				<li value="1">Update your repositories:<p class="source-code"><strong class="bold">$ sudo apt-get update</strong></p></li>
				<li>Install Python 3:<p class="source-code"><strong class="bold">$ sudo apt-get install -y python3</strong></p></li>
			</ol>
			<h3>Install Python on a Mac</h3>
			<p>To install <a id="_idIndexMarker074"/>Python on a Mac using Homebrew, execute the following steps:</p>
			<ol>
				<li value="1">Check for your desired Python version on brew’s available version list:<p class="source-code"><strong class="bold">$ brew search python</strong></p></li>
				<li>Let’s say that you choose Python 3.8; you have to install it by executing the following command:<p class="source-code"><strong class="bold">$ brew install python@3.8</strong></p></li>
				<li>Test <a id="_idIndexMarker075"/>your installation: <p class="source-code"><strong class="bold">$ python3 --version</strong></p></li>
			</ol>
			<h3>Cross-compiling from x86_64 to ARM with Python</h3>
			<p>Python is very important and one of the most popular languages now, and it is commonly <a id="_idIndexMarker076"/>used for AI and ML applications. Python is an interpreted language; it needs a runtime environment (such as Java) to run the code. In this case, you must install Python as the runtime environment. It has similar challenges running code as Java but has other challenges too. Sometimes, you need to compile libraries from scratch to use it. The standard Python libraries currently support ARM, but the issue is when you want something outside those standard libraries.</p>
			<p>As a basic example, let’s run Python code across different platforms by executing the following steps:</p>
			<ol>
				<li value="1">Create a basic file called <strong class="source-inline">example.py</strong>:<p class="source-code">def main():</p><p class="source-code">   print("hello world")</p><p class="source-code">if __name__ == "__main__":</p><p class="source-code">   main()</p></li>
				<li>Copy <strong class="source-inline">example.py</strong> to your ARM device.</li>
				<li>Install Python 3 on your ARM device by running the following command:<p class="source-code"><strong class="bold">$ sudo apt-get install -y python3</strong></p></li>
				<li>Run your code:<p class="source-code"><strong class="bold">$ python3 example.py</strong></p></li>
			</ol>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Adapting Java to run on ARM</h2>
			<p>When talking about Java to run on ARM devices, it is a little bit different. Java uses a hybrid compiler – in other words, a two-phase compiler. This means that it generates an intermediate <a id="_idIndexMarker077"/>code called bytecode and is interpreted by a <strong class="bold">Java Virtual Machine </strong>(<strong class="bold">JVM)</strong>. This bytecode <a id="_idIndexMarker078"/>is a cross-platform <a id="_idIndexMarker079"/>code and, following the Java philosophy of <em class="italic">compile once and run everywhere</em>, it means that you can compile using the platform you want, and it will run on any other platform without modifications. So, let’s see how to perform cross-compiling for a basic Java program that can run on an ARMv7 and an ARMv8 64-bit device.</p>
			<h3>Installing Java JDK on Linux</h3>
			<p>To install <a id="_idIndexMarker080"/>Java on Linux, execute the following commands:</p>
			<ol>
				<li value="1">Update the current repositories of Ubuntu:<p class="source-code"><strong class="bold">$ sudo apt-get update</strong></p></li>
				<li>Install the official JDK 8:<p class="source-code"><strong class="bold">$ sudo apt-get install openjdk-8-jre</strong></p></li>
				<li>Test whether <strong class="source-inline">javac</strong> runs:<p class="source-code"><strong class="bold">$ javac</strong></p></li>
			</ol>
			<h3>Installing Java JDK on a Mac</h3>
			<p>If you <a id="_idIndexMarker081"/>don’t have Java installed on your Mac, follow the next steps:</p>
			<ol>
				<li value="1">(<em class="italic">Optional</em>) Download Java JDK from the following link and choose the architecture that you need, such as Linux, Mac, or Windows: <a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>.</li>
				<li>(<em class="italic">Optional</em>) Download and run the installer.</li>
			</ol>
			<p>To test whether Java exists or whether it was installed correctly, run the following command:</p>
			<p class="source-code"><strong class="bold">$ java -version</strong></p>
			<ol>
				<li value="3">Test <a id="_idIndexMarker082"/>whether the compiler is installed by executing the following command:<p class="source-code"><strong class="bold">$ javac -v</strong></p></li>
			</ol>
			<h3>Cross-compiling from x86_64 to ARM with Java</h3>
			<p>Java is <a id="_idIndexMarker083"/>a language that generates an intermediate code called bytecode, which runs on the JVM. Let’s say that you have a basic code in a file called <strong class="source-inline">Example.java</strong>:</p>
			<pre class="source-code">
class Example {
   public static void main(String[] args) {
      System.out.println("Hello world!");
   }
}</pre>
			<p>To execute your code, follow these steps:</p>
			<ol>
				<li value="1">To compile it, use the following command:<p class="source-code"><strong class="bold">$ javac Example.java</strong></p></li>
			</ol>
			<p>This will generate the intermediate code in a file called <strong class="source-inline">Example.class</strong>, which can be executed by the JVM. Let’s do this in the next step.</p>
			<ol>
				<li value="2">To run the bytecode, execute the following command:<p class="source-code"><strong class="bold">$ java Example</strong></p></li>
				<li>Now, copy <strong class="source-inline">Example.class</strong> to another device and run it with the proper JVM using the <strong class="source-inline">java</strong> command.</li>
			</ol>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Summary</h1>
			<p>This chapter explained all the basic concepts about edge computing and how it relates to other concepts, such as fog computing, MEC, and cloudlets. It also explained how containers and orchestrators such as Docker, containerd, and Kubernetes can help you to build your own edge computing system, using different configurations, depending on your own use case. At the end of the chapter, we covered how you can run and compile your software on edge devices using ARM processors, using the cross-compiling technique with Go, Python, Rust, and Java languages.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Questions</h1>
			<p>Here are a few questions to test your new knowledge:</p>
			<ol>
				<li value="1">What is the difference between the edge and edge computing?</li>
				<li>What infrastructure configurations can you use to build an edge computing system?</li>
				<li>How can containers and orchestrators help you to build edge computing systems?</li>
				<li>What is cross-compiling and how can you use it to run your software on ARM devices?</li>
			</ol>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Further reading</h1>
			<p>Here are some additional resources that you can check out to learn more about edge computing:</p>
			<ul>
				<li><em class="italic">Near, Far or Tiny: Defining and Managing Edge Computing in a Cloud Native World</em>, <em class="italic">Keith Basil</em>: <a href="https://vmblog.com/archive/2021/04/27/near-far-or-tiny-defining-and-managing-edge-computing-in-a-cloud-native-world.aspx ">https://vmblog.com/archive/2021/04/27/near-far-or-tiny-defining-and-managing-edge-computing-in-a-cloud-native-world.aspx</a></li>
				<li><em class="italic">What is Edge Computing: The Network Edge Explained</em>, <em class="italic">Eric Hamilton</em>:, <em class="italic">Cloudwards</em> (2018): <a href="https://www.cloudwards.net/what-is-edge-computing ">https://www.cloudwards.net/what-is-edge-computing</a></li>
				<li><em class="italic">IoT and Edge Computing for Architects</em> – <em class="italic">Second Edition</em>, <em class="italic">Perry Lea</em>, <em class="italic">Packt Publishing</em> (2020)</li>
				<li><em class="italic">The IoT blog of Cisco</em>: <a href="https://blogs.cisco.com/internet-of-things ">https://blogs.cisco.com/internet-of-things</a></li>
				<li><em class="italic">A secure data aggregation protocol for fog computing based smart grids</em>: <a href="https://www.researchgate.net/publication/325638338_A_secure_data_aggregation_protocol_for_fog_computing_based_smart_grids.ng ">https://www.researchgate.net/publication/325638338_A_secure_data_aggregation_protocol_for_fog_computing_based_smart_grids.ng</a></li>
				<li><em class="italic">HarmonyCloud promotes edge computing implementation</em>: <a href="https://www.cncf.io/blog/2021/08/31/harmonycloud-promotes-edge-computing-implementation ">https://www.cncf.io/blog/2021/08/31/harmonycloud-promotes-edge-computing-implementation</a></li>
				<li><em class="italic">Kubernetes – Bridging the Gap between 5G and Intelligent Edge Computing</em>: <a href="https://www.cncf.io/blog/2021/03/01/kubernetes-bridging-the-gap-between-5g-and-intelligent-edge-computing ">https://www.cncf.io/blog/2021/03/01/kubernetes-bridging-the-gap-between-5g-and-intelligent-edge-computing</a></li>
				<li><em class="italic">CNCF YouTube video list of Kubernetes on Edge Day 2021</em>: <a href="https://www.youtube.com/watch?v=W1v2Gb6URsk&amp;list=PLj6h78yzYM2PuR1pP14DBLW7aku1Ia520 ">https://www.youtube.com/watch?v=W1v2Gb6URsk&amp;list=PLj6h78yzYM2PuR1pP14DBLW7aku1Ia520</a></li>
				<li><em class="italic">Cross-Compiling using Rust for Mac</em>: <a href="https://github.com/messense/homebrew-macos-cross-toolchains ">https://github.com/messense/homebrew-macos-cross-toolchains</a></li>
				<li><em class="italic">Cross-Compiling with Python</em>: <a href="https://crossenv.readthedocs.io/en/latest/quickstart.html ">https://crossenv.readthedocs.io/en/latest/quickstart.html</a></li>
				<li><em class="italic">For instructions to download and install OpenJDK</em>: <a href="https://openjdk.java.net/install">https://openjdk.java.net/install</a></li>
			</ul>
		</div>
	</body></html>