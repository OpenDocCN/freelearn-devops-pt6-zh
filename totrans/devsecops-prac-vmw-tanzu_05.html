<html><head></head><body>
<div class="IMG---Figure" id="_idContainer074">
<h1 class="chapter-number" id="_idParaDest-93"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.2.1">Defining and Managing Business APIs</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Application programming interfaces</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.5.1">APIs</span></strong><span class="koboSpan" id="kobo.6.1">) are as old as digital computing itself but more relevant </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.7.1">than ever as we continue to interconnect every aspect of modern life. </span><span class="koboSpan" id="kobo.7.2">They make up the backbone of most enterprise applications and help run the modern world. </span><span class="koboSpan" id="kobo.7.3">It is this very proliferation of APIs that makes them a big source of waste, redundancy, and bad practice </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">in enterprises.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">This chapter introduces two products aimed squarely at this problem space: </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.11.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">API Portal for VMware Tanzu</span></strong><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">As is the case with every product in the Tanzu portfolio, these products address a specific acute business need: in this case, developing, operating, publishing, securing, monitoring, documenting, searching for, and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">consuming APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">overview</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Why Spring Cloud Gateway </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">for Kubernetes?</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Why API Portal for </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">VMware Tanzu?</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Spring Cloud Gateway for Kubernetes – </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">getting started</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">API Portal for VMware Tanzu – </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">getting started</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – real-world </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">use case</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">day-2 operations</span></span></li>
</ul>
<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.31.1">Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – overview</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Before jumping </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.33.1">into the product installation, let’s revisit why we’re here. </span><span class="koboSpan" id="kobo.33.2">I like to </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.34.1">think of the API space in terms of three personas. </span><span class="koboSpan" id="kobo.34.2">There’s </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.35.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">API Developer</span></strong><span class="koboSpan" id="kobo.37.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">API Consumer</span></strong><span class="koboSpan" id="kobo.39.1">, and the </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">API Operator</span></strong><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">Each </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.42.1">has its own </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.43.1">set </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">of problems.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">If I develop APIs, there are some recurring problems that I must solve with every </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">single project:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.47.1">Exposing my API to </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">my customers</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.49.1">Terminating </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.50.1">TLS</span></em></span></li>
<li><span class="koboSpan" id="kobo.51.1">Handling </span><em class="italic"><span class="koboSpan" id="kobo.52.1">CORS</span></em><span class="koboSpan" id="kobo.53.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">browser restrictions</span></span></li>
<li><span class="koboSpan" id="kobo.55.1">Making my </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">API discoverable</span></span></li>
<li><span class="koboSpan" id="kobo.57.1">Securing my API endpoints so that only certain groups can execute </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">certain functions</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">Protecting against misuse by </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">rate-limiting requests</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">Rewriting </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">request paths</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">Rewriting request and </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">response headers</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.65.1">API terminology</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.66.1">Transport Layer Security</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.68.1">TLS</span></strong><span class="koboSpan" id="kobo.69.1">) is the cryptographic technology behind the reassuring lock </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.70.1">next to your bank’s website’s URL in </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.71.1">your web browser. </span><span class="koboSpan" id="kobo.71.2">It is especially important in the realm of APIs as most of the sensitive financial data, personal messages, and sensitive health information are delivered via an API. </span><span class="koboSpan" id="kobo.71.3">It’s especially difficult to implement correctly, and something best handled centrally by an API gateway rather than having each API developer implement </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">it themselves.</span></span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.73.1">Cross-Origin Resource Sharing</span></strong><span class="koboSpan" id="kobo.74.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.75.1">CORS</span></strong><span class="koboSpan" id="kobo.76.1">) is an especially important topic for engineers in the API space. </span><span class="koboSpan" id="kobo.76.2">CORS is the mechanism by which your browser allows one website to </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.77.1">make calls in the background (often called AJAX calls) to another website. </span><span class="koboSpan" id="kobo.77.2">There are legitimate reasons to do this, but this technique is often used by bad actors to try to steal credentials or sensitive information. </span><span class="koboSpan" id="kobo.77.3">Configuring a website and its supporting APIs such that only trusted AJAX calls are allowed is complex and easy to get wrong. </span><span class="koboSpan" id="kobo.77.4">This is one more reason why it’s best to centralize this logic in an </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">API gateway.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Now, let’s say that I need to consume APIs. </span><span class="koboSpan" id="kobo.79.2">I have an entirely different set </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">of problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.81.1">Does the API I </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">need exist?</span></span></li>
<li><span class="koboSpan" id="kobo.83.1">Where can I find the APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">I need?</span></span></li>
<li><span class="koboSpan" id="kobo.85.1">How do I </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.86.1">access those APIs </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.87.1">once I’ve </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">found them?</span></span></li>
<li><span class="koboSpan" id="kobo.89.1">Do those APIs require authentication? </span><span class="koboSpan" id="kobo.89.2">If so, </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">what scopes?</span></span></li>
<li><span class="koboSpan" id="kobo.91.1">How do I test out an API before writing a bunch of code to </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">consume it?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.93.1">Finally, if I’m a platform operator hosting APIs, I may need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.95.1">Provide developers self-service access to an API gateway that they can </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">configure themselves</span></span></li>
<li><span class="koboSpan" id="kobo.97.1">Monitor and alert on metrics around </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">the APIs</span></span></li>
<li><span class="koboSpan" id="kobo.99.1">Provide an API gateway with extremely high throughput so as not to become </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">a bottleneck</span></span></li>
<li><span class="koboSpan" id="kobo.101.1">Provide a uniform implementation of common features such as </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">the following:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.103.1">SSO</span></strong><span class="koboSpan" id="kobo.104.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.105.1">Single Sign-On</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">)</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.107.1">Rate limiting</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Header manipulation</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.109.1">Header/content enrichment</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.110.1">Where necessary, let developers build custom filters and plug them into an </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">API gateway</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">Manage the life cycle and upgrades of developers’ </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">API gateways</span></span></li>
<li><span class="koboSpan" id="kobo.114.1">Where possible, auto-generate API documentation based on what is deployed to </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the gateway</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">Provide a single searchable location where developers can discover and try out all the APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">I manage</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.118.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.119.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">API Portal for VMware Tanzu</span></strong><span class="koboSpan" id="kobo.121.1"> exist specifically to </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.122.1">provide a simple, straightforward, enterprise-wide </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.123.1">solution for all three </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">personas’ concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Now that we have a high-level overview of the topics being covered, let’s break it down into the “whys” of both products. </span><span class="koboSpan" id="kobo.125.2">We’ll start with </span><em class="italic"><span class="koboSpan" id="kobo.126.1">Spring Cloud Gateway </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">for Kubernetes</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.129.1">Why Spring Cloud Gateway for Kubernetes?</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.130.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.131.1"> is based on the open source </span><em class="italic"><span class="koboSpan" id="kobo.132.1">Spring Cloud Gateway</span></em><span class="koboSpan" id="kobo.133.1"> project: </span><a href="https://spring.io/projects/spring-cloud-gateway"><span class="koboSpan" id="kobo.134.1">https://spring.io/projects/spring-cloud-gateway</span></a><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">Spring Cloud Gateway is a library </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.136.1">for building high-performance APIs. </span><span class="koboSpan" id="kobo.136.2">You </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.137.1">deploy it like a normal Spring app and configure </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.138.1">it like you would configure a Spring app. </span><span class="koboSpan" id="kobo.138.2">Unfortunately, the open source project doesn’t do much to address many of the problems mentioned previously – problems commonly encountered in </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">the enterprise.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">In addition to their business logic, developers must also package, configure, and deploy a Spring Cloud Gateway app, or bundle it into their existing app as a library. </span><span class="koboSpan" id="kobo.140.2">Either way, it’s a significant amount of added complexity. </span><span class="koboSpan" id="kobo.140.3">Unless they’re using some advanced features of the Spring Framework, any changes to their API’s routes will involve rebuilding and redeploying </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">Furthermore, the open source Spring Cloud Gateway leaves some of the operator’s problems unsolved. </span><span class="koboSpan" id="kobo.142.2">If every development team is doing its custom deployment of Spring Cloud Gateway, the operator can’t reason about how each gateway’s routes will be exposed, or how it will emit metrics. </span><span class="koboSpan" id="kobo.142.3">In addition, there’s no easy way for multiple teams to share a gateway as they all need to configure and deploy it on </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">their schedule.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">This is where Spring Cloud Gateway for Kubernetes enters the picture. </span><span class="koboSpan" id="kobo.144.2">Spring Cloud Gateway for </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.145.1">Kubernetes is a commercial Tanzu product with a superset of the open source’s features. </span><span class="koboSpan" id="kobo.145.2">It is geared specifically toward the enterprise and managing software at scale. </span><span class="koboSpan" id="kobo.145.3">It uses a Kubernetes Operator to manage three </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">main objects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.147.1">Instances of Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">Cloud Gateway</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">API routes – instructions to the gateway on how to filter incoming requests and where to send them </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">on to</span></span></li>
<li><span class="koboSpan" id="kobo.151.1">Mappings of API routes to Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">Cloud Gateway</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.153.1">By exposing these </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.154.1">three entities as Kubernetes </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">Custom Resources</span></strong><span class="koboSpan" id="kobo.156.1">, Spring Cloud Gateway for Kubernetes can abstract away </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.158.1">Packaging and deploying Spring Cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">Gateway instances</span></span></li>
<li><span class="koboSpan" id="kobo.160.1">Managing the Spring code to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">those instances</span></span></li>
<li><span class="koboSpan" id="kobo.162.1">Dynamically updating that configuration without </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">redeploying them</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">Life cycle-managing all the gateway instances across all </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">Kubernetes clusters</span></span></li>
<li><span class="koboSpan" id="kobo.166.1">Reasoning about the gateway instances </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">in bulk:</span></span><ul><li><span class="koboSpan" id="kobo.168.1">They all emit metrics the same way, so I can easily aggregate all </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">their metrics</span></span></li><li><span class="koboSpan" id="kobo.170.1">They all expose their API configuration the same way, so I can aggregate that config and report on it or, as we will see shortly, use it to drive other useful tools such as API Portal for </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">VMware Tanzu</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.172.1">To summarize then, Spring </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.173.1">Cloud Gateway for Kubernetes uses a Kubernetes Operator and some very strategic </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">Custom Resource Definitions</span></strong><span class="koboSpan" id="kobo.175.1"> to make the already formidable open source Spring Cloud Gateway a first-class Kubernetes citizen and a truly enterprise-grade product focused on enterprise-grade problems. </span><span class="koboSpan" id="kobo.175.2">This is summed up in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 5.1 – Spring Cloud Gateway for Kubernetes at a glance" src="image/B18145_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 5.1 – Spring Cloud Gateway for Kubernetes at a glance</span></p>
<p><span class="koboSpan" id="kobo.179.1">Now that we’ve </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.180.1">covered how to deploy APIs, let’s move on to how best to consume them. </span><span class="koboSpan" id="kobo.180.2">Let’s have a look at </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">API Portal for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.182.1">VMware Tanzu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.184.1">Why API Portal for VMware Tanzu?</span></h1>
<p><span class="koboSpan" id="kobo.185.1">Just as </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.187.1"> is a self-service tool allowing developers and </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.188.1">operators to uniformly deploy, manage, and secure their APIs, </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">API Portal for VMware Tanzu</span></strong><span class="koboSpan" id="kobo.190.1"> is a self-service tool that allows developers and consumers to publish, document, search for, discover, and try out </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">those APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">Just as Spring Cloud Gateway for Kubernetes makes it easy to deploy multiple gateways for multiple use cases or environments, API Portal for Vmware Tanzu makes it easy to deploy multiple searchable catalogs across those very same use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">or environments.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">This distributed, Kubernetes-native approach to API catalogs can scale across multiple large teams and enables self-service, which, in turn, gives you greater developer productivity </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">and satisfaction.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Furthermore, it’s a </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.197.1">simple, straightforward operation to integrate API portals with enterprise SSO so that the right people can find the right APIs for </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">their needs.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Now that we know </span><em class="italic"><span class="koboSpan" id="kobo.200.1">why</span></em><span class="koboSpan" id="kobo.201.1"> we’re learning about these products, let’s get started with installing them and trying them out. </span><span class="koboSpan" id="kobo.201.2">Let’s go over some technical requirements; then, we can start with </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Spring Cloud Gateway </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.203.1">for Kubernetes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.205.1">Technical requirements</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.206.1">API Portal for VMware Tanzu</span></strong><span class="koboSpan" id="kobo.207.1"> is a subcomponent</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.208.1"> of another product covered in this book, </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Tanzu Application Platform (TAP)</span></strong><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">To get started </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.211.1">with API Portal for VMware Tanzu, we’ll first need to install a Kubernetes cluster and then install TAP on that cluster. </span><span class="koboSpan" id="kobo.211.2">You’re free to use whichever Kubernetes distribution you prefer. </span><span class="koboSpan" id="kobo.211.3">If you’d like some guidance around standing up a cluster, you can go to the appendix at the end of the book where we describe several options for getting Kubernetes up </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">and running.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">Once you have a running Kubernetes cluster, you’ll need to jump briefly to </span><a href="B18145_08.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.214.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.215.1">, </span><em class="italic"><span class="koboSpan" id="kobo.216.1">Enhancing Developer Productivity with Tanzu Application Platform</span></em><span class="koboSpan" id="kobo.217.1">, and install </span><em class="italic"><span class="koboSpan" id="kobo.218.1">Tanzu Application Platform</span></em><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">That chapter walks through a more complex end-to-end use case, while this chapter focuses solely on the </span><em class="italic"><span class="koboSpan" id="kobo.220.1">API </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.221.1">Portal</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Next, you’ll need an account on a container registry that presents a TLS certificate trusted by your </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.224.1">Kubernetes cluster. </span><span class="koboSpan" id="kobo.224.2">The easiest thing to do is sign up for a free developer account at Docker Hub. </span><span class="koboSpan" id="kobo.224.3">Simply visit </span><a href="https://hub.docker.com"><span class="koboSpan" id="kobo.225.1">https://hub.docker.com</span></a><span class="koboSpan" id="kobo.226.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">sign up.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">If you want to deploy the </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.229.1">real-world use case, you’ll need an OIDC provider for SSO. </span><span class="koboSpan" id="kobo.229.2">If you don’t already have something available, I’d recommend setting up a free developer account at Okta: </span><a href="https://developer.okta.com/signup/"><span class="koboSpan" id="kobo.230.1">https://developer.okta.com/signup/</span></a><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">Later in this chapter, there will be some detailed instructions for setting up your account to work with our real-world </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">example application.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">At the time </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.234.1">of writing, the </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.236.1"> installation requires the </span><em class="italic"><span class="koboSpan" id="kobo.237.1">helm</span></em><span class="koboSpan" id="kobo.238.1"> CLI, which you can find </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">here: </span></span><a href="https://helm.sh/docs/intro/install/"><span class="No-Break"><span class="koboSpan" id="kobo.240.1">https://helm.sh/docs/intro/install/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.241.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Finally, we’ll </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.243.1">need the </span><em class="italic"><span class="koboSpan" id="kobo.244.1">kustomize</span></em><span class="koboSpan" id="kobo.245.1"> CLI, which can be found here: </span><a href="https://kustomize.io"><span class="koboSpan" id="kobo.246.1">https://kustomize.io</span></a><span class="koboSpan" id="kobo.247.1">. </span><span class="koboSpan" id="kobo.247.2">If you just </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.248.1">want to download the binary, you can also go </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">here: </span></span><a href="https://kubectl.docs.kubernetes.io/installation/kustomize/binaries"><span class="No-Break"><span class="koboSpan" id="kobo.250.1">https://kubectl.docs.kubernetes.io/installation/kustomize/binaries</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.251.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Now that we have Kubernetes running </span><em class="italic"><span class="koboSpan" id="kobo.253.1">Tanzu Application Platform</span></em><span class="koboSpan" id="kobo.254.1">, we can install </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.256.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">API Portal for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.258.1">VMware Tanzu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">First, let’s </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.261.1">double-check that we have </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.262.1">all our prerequisites </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">in place:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.264.1">We need an up-to-date version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">kapp</span></strong><span class="koboSpan" id="kobo.266.1"> controller – at </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">least 0.29.0:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.268.1">
$ kubectl get deploy -n kapp-controller kapp-controller -ojsonpath='{.metadata.annotations.kapp-controller\.carvel\.dev/version}'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.269.1">
v0.29.0</span></pre></li>
<li><span class="koboSpan" id="kobo.270.1">We’ll also need the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">secretgen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1"> controller:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
$ kubectl get deploy -n secretgen-controller</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.274.1">
NAME                   READY   UP-TO-DATE   AVAILABLE   AGE</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.275.1">
secretgen-controller   1/1     1            1           23h</span></pre></li>
<li><span class="koboSpan" id="kobo.276.1">Let’s make sure we have up-to-date versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">helm</span></strong><span class="koboSpan" id="kobo.278.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">kustomize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1"> installed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.281.1">
$ helm version</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
version.BuildInfo{Version:"v3.5.3", GitCommit:"041ce5a2c17a58be0fcd5f5e16fb3e7e95fea622", GitTreeState:"dirty", GoVersion:"go1.15.8"}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.283.1">
$ kustomize version</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.284.1">
{Version:kustomize/v4.0.5 GitCommit:9e8e7a7fe99ec9fbf801463e8607928322fc5245 BuildDate:2021-03-08T20:53:03Z GoOs:darwin GoArch:amd64}</span></pre></li>
<li><span class="koboSpan" id="kobo.285.1">And finally, we should test that we have a writable Docker repository and a working </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.286.1">Docker CLI. </span><span class="koboSpan" id="kobo.286.2">The following is </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.287.1">a simple way to test that everything has been set up properly. </span><span class="koboSpan" id="kobo.287.2">I’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">dockerhub</span></strong><span class="koboSpan" id="kobo.289.1"> as the registry, but you can plug in whichever solution you’ve chosen </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">to use:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.291.1">
$ export DOCKER_USER=&lt;your dockerhub username&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.292.1">
$ docker pull hello-world</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
$ docker tag hello-world docker.io/$DOCKER_USER/hello-world</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.294.1">
$ docker push docker.io/$DOCKER_USER/hello-world</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.295.1">If everything worked without errors, congratulations! </span><span class="koboSpan" id="kobo.295.2">You should have all the technical requirements in place to proceed to the next section, where you will install </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.297.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">API Portal for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.299.1">VMware Tanzu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">!</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.301.1">Spring Cloud Gateway for Kubernetes – getting started</span></h1>
<p><span class="koboSpan" id="kobo.302.1">Let’s start by </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.303.1">installing </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">There are two distinct parts to this product: the Kubernetes Operator and the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">deployed gateways.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">The </span><em class="italic"><span class="koboSpan" id="kobo.308.1">Kubernetes Operator</span></em><span class="koboSpan" id="kobo.309.1"> works </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.310.1">with the Kubernetes API to handle three </span><em class="italic"><span class="koboSpan" id="kobo.311.1">Custom </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.312.1">Resource Definitions</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.314.1">SpringCloudGateway</span></strong><span class="koboSpan" id="kobo.315.1"> (abbr: </span><em class="italic"><span class="koboSpan" id="kobo.316.1">scg</span></em><span class="koboSpan" id="kobo.317.1">): This </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.318.1">is an (optionally) HA instance of Spring Cloud Gateway – centrally packaged, deployed, and life cycle-managed for </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the developer.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.320.1">SpringCloudGatewayRouteConfig</span></strong><span class="koboSpan" id="kobo.321.1"> (abbr: </span><em class="italic"><span class="koboSpan" id="kobo.322.1">scgrc</span></em><span class="koboSpan" id="kobo.323.1">): This is a set of instructions </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.324.1">for a Spring Cloud Gateway instance around what host/path to accept requests on, how to filter that request, and which backend Kubernetes service to eventually proxy </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">it onto.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.326.1">SpringCloudGatewayMapping</span></strong><span class="koboSpan" id="kobo.327.1"> (abbr: </span><em class="italic"><span class="koboSpan" id="kobo.328.1">scgm</span></em><span class="koboSpan" id="kobo.329.1">): This tells the Kubernetes operator </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.330.1">which </span><em class="italic"><span class="koboSpan" id="kobo.331.1">SpringCloudGatewayRouteConfigs</span></em><span class="koboSpan" id="kobo.332.1"> are associated with which </span><em class="italic"><span class="koboSpan" id="kobo.333.1">SpringCloudGateways</span></em><span class="koboSpan" id="kobo.334.1">. </span><span class="koboSpan" id="kobo.334.2">The </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.335.1">operator automatically reconfigures </span><em class="italic"><span class="koboSpan" id="kobo.336.1">SpringCloudGateways</span></em><span class="koboSpan" id="kobo.337.1"> with the necessary Spring configuration properties to match the contents </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">of </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.339.1">SpringCloudGatewayRouteConfig</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.341.1">The deployed instances of Spring Cloud Gateway are the other half of the product. </span><span class="koboSpan" id="kobo.341.2">The Kubernetes operator </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.342.1">stands up multiples of these gateways, which can accept incoming traffic via a Kubernetes service or ingress. </span><span class="koboSpan" id="kobo.342.2">It then looks for </span><em class="italic"><span class="koboSpan" id="kobo.343.1">SpringCloudGatewayRouteConfigs</span></em><span class="koboSpan" id="kobo.344.1"> that are mapped to a particular Spring Cloud Gateway instance and dynamically configures </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">those routes.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">The Spring Cloud Gateway deployed instances are what handle API traffic for developers’ APIs. </span><span class="koboSpan" id="kobo.346.2">The Kubernetes Operator is how developers can self-service provision Spring Cloud Gateway instances and (human, not Kubernetes) operators can monitor and manage those instances automatically, and </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">at scale.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">The installation process is as simple as running a couple of scripts to relocate the necessary container </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.349.1">images to your container registry and then deploying the necessary Kubernetes artifacts to your cluster using </span><em class="italic"><span class="koboSpan" id="kobo.350.1">Helm</span></em><span class="koboSpan" id="kobo.351.1">. </span><span class="koboSpan" id="kobo.351.2">The official installation instructions can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">here: </span></span><a href="https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-installation.html"><span class="No-Break"><span class="koboSpan" id="kobo.353.1">https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-installation.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.354.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">To paraphrase the installation, here are </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.357.1">Download the binary from this </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">link: </span></span><a href="https://network.tanzu.vmware.com/products/spring-cloud-gateway-for-kubernetes"><span class="No-Break"><span class="koboSpan" id="kobo.359.1">https://network.tanzu.vmware.com/products/spring-cloud-gateway-for-kubernetes</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.360.1">.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.361.1">Unzip it.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Run the script to take the local </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">.tgz</span></strong><span class="koboSpan" id="kobo.364.1"> image layers and push them to your </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">container repository.</span></span></li>
<li><span class="koboSpan" id="kobo.366.1">Run the script to deploy everything to your Kubernetes cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">via </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">helm</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.370.1">First, let’s relocate our images. </span><span class="koboSpan" id="kobo.370.2">The Kubernetes operator and the deployed Spring Cloud Gateway instances need to exist in an external image repository that is reachable from the Kubernetes cluster. </span><span class="koboSpan" id="kobo.370.3">At this time, Spring Cloud Gateway for Kubernetes is delivered via download and </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.371.1">all the image bits are contained in the downloaded file. </span><span class="koboSpan" id="kobo.371.2">To get those bits somewhere Kubernetes can access them, we’ll need to load them into our local Docker environment and push them to the remote repository. </span><span class="koboSpan" id="kobo.371.3">The straightforward Docker commands are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">scripts/relocate-images.sh</span></strong><span class="koboSpan" id="kobo.373.1"> file if you’re interested. </span><span class="koboSpan" id="kobo.373.2">Otherwise, simply navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">scripts</span></strong><span class="koboSpan" id="kobo.375.1"> directory and call the script. </span><span class="koboSpan" id="kobo.375.2">I’ll share the abbreviated output from my run. </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">docker.io/rhardt</span></strong><span class="koboSpan" id="kobo.377.1"> is my repository. </span><span class="koboSpan" id="kobo.377.2">If you set up a Docker Hub account, yours will </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">docker.io/&lt;your-username&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.381.1">
bash-5.0$ ./relocate-images.sh docker.io/rhardt
Relocating image
================
image name: gateway
version: 1.0.8
source repository: registry.tanzu.vmware.com/spring-cloud-gateway-for-kubernetes/gateway:1.0.8
destination repository: docker.io/rhardt/gateway:1.0.8
Loaded image: registry.tanzu.vmware.com/spring-cloud-gateway-for-kubernetes/gateway:1.0.8
The push refers to repository [docker.io/rhardt/gateway]
1dc94a70dbaa: Layer already exists
… (more layers)
824bf068fd3d: Layer already exists
1.0.8: digest: sha256:8c1deade58dddad7ef1ca6928cbdd76e401bc0afaf7c44378d296bf3c7474838 size: 4500
Relocating image
================
image name: scg-operator
version: 1.0.8
source repository: registry.tanzu.vmware.com/spring-cloud-gateway-for-kubernetes/scg-operator:1.0.8
destination repository: docker.io/rhardt/scg-operator:1.0.8
Loaded image: registry.tanzu.vmware.com/spring-cloud-gateway-for-kubernetes/scg-operator:1.0.8
The push refers to repository [docker.io/rhardt/scg-operator]
1dc94a70dbaa: Layer already exists
… (more layers)
824bf068fd3d: Layer already exists
1.0.8: digest: sha256:da9f2677e437ccd8d793427e6cafd9f4bb6287ecffdc40773cf3b1f518f075fb size: 4498</span></pre>
<p><span class="koboSpan" id="kobo.382.1">So, now, we have our container images somewhere that Kubernetes can find them. </span><span class="koboSpan" id="kobo.382.2">The other thing that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">relocate-images.sh</span></strong><span class="koboSpan" id="kobo.384.1"> script does is create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">scg-image-values.yaml</span></strong><span class="koboSpan" id="kobo.386.1"> that Helm will use when deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">to Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">The second script we will run is </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">install-spring-cloud-gateway.sh</span></strong><span class="koboSpan" id="kobo.390.1">, also in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">scripts</span></strong><span class="koboSpan" id="kobo.392.1"> directory. </span><span class="koboSpan" id="kobo.392.2">I encourage you to peruse this script as well as it’s an excellent example of a </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.393.1">comprehensive helm deployment, complete with updating an existing installation, specific instructions on timeout, error diagnostics in the event of failure, and checking to see that the </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">deployment succeeded:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.395.1">
bash-5.0$ ./install-spring-cloud-gateway.sh
chart tarball: spring-cloud-gateway-1.0.8.tgz
chart name: spring-cloud-gateway
Waiting up to 2m for helm installation to complete
Release "spring-cloud-gateway" does not exist. </span><span class="koboSpan" id="kobo.395.2">Installing it now.
</span><span class="koboSpan" id="kobo.395.3">NAME: spring-cloud-gateway
LAST DEPLOYED: Mon Feb 21 18:25:13 2022
NAMESPACE: spring-cloud-gateway
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
This chart contains the Kubernetes operator for Spring Cloud Gateway.
</span><span class="koboSpan" id="kobo.395.4">Install the chart spring-cloud-gateway-crds before installing this chart
Checking Operator pod state
deployment "scg-operator" successfully rolled out
 Operator pods are running
Checking custom resource definitions
 springcloudgatewaymappings.tanzu.vmware.com successfully installed
 springcloudgatewayrouteconfigs.tanzu.vmware.com successfully installed
 springcloudgateways.tanzu.vmware.com successfully installed
Successfully installed Spring Cloud Gateway operator
bash-5.0$</span></pre>
<p><span class="koboSpan" id="kobo.396.1">Now that </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.397.1">we’ve installed Spring Cloud Gateway for Kubernetes, let’s move on to API Portal for </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">VMware Tanzu.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.399.1">API Portal for VMware Tanzu – getting started</span></h1>
<p><span class="koboSpan" id="kobo.400.1">Unlike </span><em class="italic"><span class="koboSpan" id="kobo.401.1">Spring Cloud Gateway for Kubernetes</span></em><span class="koboSpan" id="kobo.402.1">, API Portal for VMware Tanzu comes as a part of </span><em class="italic"><span class="koboSpan" id="kobo.403.1">Tanzu Application Platform</span></em><span class="koboSpan" id="kobo.404.1">, which you installed in the </span><em class="italic"><span class="koboSpan" id="kobo.405.1">Technical requirements</span></em><span class="koboSpan" id="kobo.406.1"> section previously. </span><span class="koboSpan" id="kobo.406.2">You can verify that API Portal is installed and running by navigating to your Tanzu Application GUI, either at a local port forward address such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">http://localhost:8081</span></strong><span class="koboSpan" id="kobo.408.1"> or at your ingress domain such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">http://tap-gui.example.com</span></strong><span class="koboSpan" id="kobo.410.1">. </span><span class="koboSpan" id="kobo.410.2">This depends on your choice of Kubernetes cluster and how you installed TAP. </span><span class="koboSpan" id="kobo.410.3">Once you access your Tanzu Application Platform GUI, click the </span><strong class="bold"><span class="koboSpan" id="kobo.411.1">APIs</span></strong><span class="koboSpan" id="kobo.412.1"> menu item on the left-hand side; you should see a screen like </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.414.1"><img alt="Figure 5.2 – API Portal" src="image/B18145_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.415.1">Figure 5.2 – API Portal</span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.416.1">Spring Cloud Gateway for Kubernetes and API Portal for VMware Tanzu – real-world use case</span></h1>
<p><span class="koboSpan" id="kobo.417.1">Now, we’re going to implement a real-world use case using </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">API Portal for VMware Tanzu</span></strong><span class="koboSpan" id="kobo.419.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">This will show how these products </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.422.1">naturally work together and how, in </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.423.1">combination, you can realize significant value as a developer, consumer, or operator </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">of APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">Here’s a breakdown of our </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">next steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.427.1">We will download an API-driven application called </span><em class="italic"><span class="koboSpan" id="kobo.428.1">Animal Rescue</span></em><span class="koboSpan" id="kobo.429.1"> while approximating </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.430.1">a real-world animal adoption site, complete </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">with SSO.</span></span></li>
<li><span class="koboSpan" id="kobo.432.1">We will set up our Okta environment so that our application can use Okta for SSO. </span><span class="koboSpan" id="kobo.432.2">Then, we will take the Okta parameters and plug them into the Animal </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">Rescue application.</span></span></li>
<li><span class="koboSpan" id="kobo.434.1">We will deploy the Animal Rescue application to our Kubernetes cluster, which will create the necessary Spring Cloud Gateway artifacts. </span><span class="koboSpan" id="kobo.434.2">By doing so, we will be able to browse and interact with the Animal Rescue </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">web app.</span></span></li>
<li><span class="koboSpan" id="kobo.436.1">We will modify our API Portal installation so that it connects to the Spring Cloud Gateway Kubernetes Operator, which now knows all the API routes for the Animal Rescue app and exposes them </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">as OpenAPIv3.</span></span></li>
<li><span class="koboSpan" id="kobo.438.1">We will port-forward to our API Portal to explore and try out the Animal </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">Rescue APIs.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.440.1">Now that you know what we’re trying to accomplish, here are </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">the steps.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.442.1">Step 1 – cloning this book’s Git repository and navigating to the Animal Rescue application</span></h2>
<p><span class="koboSpan" id="kobo.443.1">Use the Git CLI </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.444.1">to clone the book </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.445.1">code repository and then navigate to the </span><em class="italic"><span class="koboSpan" id="kobo.446.1">animal-rescue</span></em><span class="koboSpan" id="kobo.447.1"> application as seen in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">code snippet:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.449.1">
bash-3.2$ git clone https://github.com/PacktPublishing/DevSecOps-in-Practice-with-VMware-Tanzu
Cloning into 'DevSecOps-in-Practice-with-VMware-Tanzu'...
</span><span class="koboSpan" id="kobo.449.2">remote: Enumerating objects: 499, done.
</span><span class="koboSpan" id="kobo.449.3">remote: Counting objects: 100% (499/499), done.
</span><span class="koboSpan" id="kobo.449.4">remote: Compressing objects: 100% (351/351), done.
</span><span class="koboSpan" id="kobo.449.5">remote: Total 499 (delta 95), reused 473 (delta 75), pack-reused 0
Receiving objects: 100% (499/499), 9.80 MiB | 10.39 MiB/s, done.
</span><span class="koboSpan" id="kobo.449.6">Resolving deltas: 100% (95/95), done.
</span><span class="koboSpan" id="kobo.449.7">bash-3.2$ cd DevSecOps-in-Practice-with-VMware-Tanzu/chapter-05/animal-rescue/
bash-3.2$</span></pre>
<h2 id="_idParaDest-103"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.450.1">Step 2 – configuring your Okta developer account to provide SSO for Animal Rescue</span></h2>
<p><span class="koboSpan" id="kobo.451.1">These steps </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.452.1">are a bit involved, so I recommend following the instructions directly from the VMware </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.453.1">documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">here: </span></span><a href="https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-sso-setup-guide.html"><span class="No-Break"><span class="koboSpan" id="kobo.455.1">https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/1.0/scg-k8s/GUID-sso-setup-guide.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.456.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">After completing the setup, we’ll need to complete one additional step for this example to work. </span><span class="koboSpan" id="kobo.457.2">We need to add two additional sign-in redirect URIs for the “gateway” application. </span><span class="koboSpan" id="kobo.457.3">This screenshot shows my </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">Okta setup:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.459.1"><img alt="Figure 5.3 – Screenshot of the Okta sign-in redirect URIs" src="image/B18145_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.460.1">Figure 5.3 – Screenshot of the Okta sign-in redirect URIs</span></p>
<p><span class="koboSpan" id="kobo.461.1">We’ll be port-forwarding the Animal Rescue app to </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">http://localhost:8084</span></strong><span class="koboSpan" id="kobo.463.1"> and the API gateway to </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">http://localhost:8085</span></strong><span class="koboSpan" id="kobo.465.1">; we’d like both to be able to authenticate </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">via Okta.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">At the end of this exercise, you’ll need three pieces of information from your Okta environment: </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">issuer-id</span></strong><span class="koboSpan" id="kobo.469.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">client-id</span></strong><span class="koboSpan" id="kobo.471.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">client-secret</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">The VMware documentation instructs you on how to configure the Animal Rescue app with that </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.476.1">information. </span><span class="koboSpan" id="kobo.476.2">I’ll include it here as well. </span><span class="koboSpan" id="kobo.476.3">These steps are relative to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">animal-rescue</span></strong><span class="koboSpan" id="kobo.478.1"> app that we cloned from GitHub in the </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">previous section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.480.1">Create </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">backend/secrets/sso-credentials.txt</span></strong><span class="koboSpan" id="kobo.482.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
jwk-set-uri=&lt;issuer uri&gt;/v1/keys</span></pre></li>
<li><span class="koboSpan" id="kobo.485.1">Create </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">gateway/sso-secret-for-gateway/secrets/test-sso-credentials.txt</span></strong><span class="koboSpan" id="kobo.487.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.489.1">
scope=openid,profile,email,groups,animals.adopt</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.490.1">
client-id=&lt;client id&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.491.1">
client-secret=&lt;client id&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.492.1">
issuer-uri=&lt;issuer uri&gt;</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.493.1">Some of the additional steps mentioned in the documentation, such as editing </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">roles-attribute-name</span></strong><span class="koboSpan" id="kobo.495.1"> or </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.496.1">configuring route security have already been done for you in the version of the app </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">you downloaded.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.498.1">Step 3 – deploying the Animal Rescue application</span></h2>
<p><span class="koboSpan" id="kobo.499.1">From the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">animal-rescue</span></strong><span class="koboSpan" id="kobo.501.1"> directory – that is, the </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.502.1">home directory of the app you cloned (</span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">DevSecOps-in-Practice-with-VMware-Tanzu/chapter-05/animal-rescue</span></strong><span class="koboSpan" id="kobo.504.1">) – run the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.506.1">
bash-5.0$ kustomize build . </span><span class="koboSpan" id="kobo.506.2">| kubectl apply -f -
namespace/animal-rescue created
secret/animal-rescue-sso created
secret/sso-credentials created
service/animal-rescue-backend created
service/animal-rescue-frontend created
deployment.apps/animal-rescue-backend created
deployment.apps/animal-rescue-frontend created
ingress.networking.k8s.io/gateway-demo created
springcloudgateway.tanzu.vmware.com/gateway-demo created
springcloudgatewaymapping.tanzu.vmware.com/animal-rescue-backend-routes created
springcloudgatewaymapping.tanzu.vmware.com/animal-rescue-frontend-routes created
springcloudgatewayrouteconfig.tanzu.vmware.com/animal-rescue-backend-route-config created
springcloudgatewayrouteconfig.tanzu.vmware.com/animal-rescue-frontend-route-config created</span></pre>
<p><span class="koboSpan" id="kobo.507.1">At this point, you can watch to see when all the pods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">animal-rescue</span></strong><span class="koboSpan" id="kobo.509.1"> namespace have </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">come up:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.511.1">
bash-5.0$ kubectl get pods -n animal-rescue -w
NAME                                     READY   STATUS    RESTARTS   AGE
animal-rescue-backend-546fc6c569-kgj2s   1/1     Running   0          27m
animal-rescue-frontend-b74f54847-rq284   1/1     Running   0          27m
gateway-demo-0                    1/1     Running   0          23m
gateway-demo-1                    1/1     Running   0          24m</span></pre>
<p><span class="koboSpan" id="kobo.512.1">Once the pods are up, we can port forward </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">localhost:8084</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">At this point, I highly recommend an </span><em class="italic"><span class="koboSpan" id="kobo.517.1">incognito</span></em><span class="koboSpan" id="kobo.518.1"> browser window to prevent the application from getting confused regarding your Okta </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">developer account.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">Open your </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.521.1">browser to </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">http://localhost:8084</span></strong><span class="koboSpan" id="kobo.523.1">; you should see the Animal Rescue web application replete with cute animals to adopt and an SSO login button in the top-right corner. </span><span class="koboSpan" id="kobo.523.2">If you configured everything correctly, clicking that button will take you to an Okta login and then back to the running application once you’ve logged in. </span><span class="koboSpan" id="kobo.523.3">This is what it looks like in my browser. </span><span class="koboSpan" id="kobo.523.4">Notice the text in the top right with my </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">Okta username:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.525.1"><img alt="Figure 5.4 – Animal Rescue screenshot" src="image/B18145_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.526.1">Figure 5.4 – Animal Rescue screenshot</span></p>
<p><span class="koboSpan" id="kobo.527.1">So far, so </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.528.1">good! </span><span class="koboSpan" id="kobo.528.2">Now, let’s take things to the next level and integrate this API with </span><strong class="bold"><span class="koboSpan" id="kobo.529.1">API Portal for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.530.1">VMware Tanzu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.532.1">Step 4 – (optional) viewing the Animal Rescue API’s OpenAPI 3.0 specification</span></h2>
<p><span class="koboSpan" id="kobo.533.1">This is, in my opinion, one of the most compelling features of this pair </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">of products.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">In practice, developers are responsible for manually keeping their API specification in some sort of </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.536.1">documentation format, usually OpenAPI 3.x or Swagger. </span><span class="koboSpan" id="kobo.536.2">This is tedious for the developer, and in the heat of battle, that API specification will be the first thing to stop being maintained. </span><span class="koboSpan" id="kobo.536.3">This means that new consumers will be basing their clients on incorrect, out-of-date </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">API documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Once you deploy the </span><em class="italic"><span class="koboSpan" id="kobo.539.1">Animal Rescue</span></em><span class="koboSpan" id="kobo.540.1"> application, the Spring Cloud Gateway Kubernetes Operator manages all the routes – that is, the Kubernetes Operator manages the configuration of Spring Cloud Gateway instances so that every API call gets properly routed to the right backend service, along with any filters, security, and metadata. </span><span class="koboSpan" id="kobo.540.2">This is sufficient information to auto-generate the API’s OpenAPI </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">3.0 specification.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">It’s hard to understate what a breakthrough this is. </span><span class="koboSpan" id="kobo.542.2">The actual Kubernetes objects that control the API’s runtime configuration are used to auto-generate always-accurate, always-up-to-date OpenAPI 3.0 documentation. </span><span class="koboSpan" id="kobo.542.3">This removes the burden of documentation creation and maintenance from the API developer, and the burden of working around out-of-date documentation from the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">API consumer.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">Let’s take a quick look at our Animal Rescue API auto-generated documentation. </span><span class="koboSpan" id="kobo.544.2">The OpenAPI 3.0 documentation for every deployed API across all gateways is available via a web endpoint on the Spring Cloud Gateway Operator. </span><span class="koboSpan" id="kobo.544.3">That web endpoint is exposed via a </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">ClusterIP service.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">In production, you may want to put a TLS-secured ingress in front of that service, but for the sake of demonstration, let’s just set up a quick </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">port forward:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.548.1">
bash-5.0$ kubectl get svc -n spring-cloud-gateway
NAME           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
scg-operator   ClusterIP   10.98.103.232   &lt;none&gt;        80/TCP    40h
bash-5.0$ kubectl port-forward -n spring-cloud-gateway svc/scg-operator 8083:80
Forwarding from 127.0.0.1:8083 -&gt; 8080
Forwarding from [::1]:8083 -&gt; 8080</span></pre>
<p><span class="koboSpan" id="kobo.549.1">First, we determined that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">spring-cloud-gateway</span></strong><span class="koboSpan" id="kobo.551.1"> service was running on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">80</span></strong><span class="koboSpan" id="kobo.553.1">, so we </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.554.1">port-forwarded our local workstation’s port </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">8083</span></strong><span class="koboSpan" id="kobo.556.1"> to that service on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">80</span></strong><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">Now, we can point a web browser to </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">http://localhost:8083</span></strong><span class="koboSpan" id="kobo.560.1">, and voila! </span><span class="koboSpan" id="kobo.560.2">You will see the OpenAPI 3.0.1 representation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Animal Rescue</span></strong><span class="koboSpan" id="kobo.562.1"> API, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.564.1"><img alt="Figure 5.5 – Animal Rescue auto-generated OpenAPI 3.0.1 specification" src="image/B18145_05_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.565.1">Figure 5.5 – Animal Rescue auto-generated OpenAPI 3.0.1 specification</span></p>
<p><span class="koboSpan" id="kobo.566.1">This is a 100% valid and accurate OpenAPI 3.0, so any tools that can generate clients or server stubs </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.567.1">from that format will work with it. </span><span class="koboSpan" id="kobo.567.2">Furthermore, the Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">SpringCloudGatewayRouteConfig</span></strong><span class="koboSpan" id="kobo.569.1"> objects contain fields for </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.571.1">Human-readable descriptions</span></span></li>
<li><span class="koboSpan" id="kobo.572.1">All the possible response codes and </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">their meanings</span></span></li>
<li><span class="koboSpan" id="kobo.574.1">Any sort of </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">authentication required</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.576.1">In other </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.577.1">words, the real-world Kubernetes objects driving the real-world runtime behavior are also driving the documentation, so it’s always accurate and up </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">to date.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.579.1">Step 5 – (optional) connecting API Portal for VMware Tanzu with the Spring Cloud Gateway for Kubernetes OpenAPI endpoint</span></h2>
<p><span class="koboSpan" id="kobo.580.1">As we </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.581.1">demonstrated earlier, </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">API Portal for VMware Tanzu</span></strong><span class="koboSpan" id="kobo.583.1"> is driven entirely by OpenAPI 3 or Swagger documents. </span><span class="koboSpan" id="kobo.583.2">It’s only </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.584.1">logical, then, that we’d set up the API Portal to consume the </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.585.1">OpenAPI 3 documents generated by </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">Spring Cloud Gateway for Kubernetes</span></strong><span class="koboSpan" id="kobo.587.1">. </span><span class="koboSpan" id="kobo.587.2">If you set up a port forward in the previous step, you can exit from it. </span><span class="koboSpan" id="kobo.587.3">Since the API Portal and Spring Cloud Gateway are on the same Kubernetes cluster, they can communicate via </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">ClusterIP services.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">We previously installed </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">API Portal for VMware Tanzu</span></strong><span class="koboSpan" id="kobo.591.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">tanzu package</span></strong><span class="koboSpan" id="kobo.593.1"> command. </span><span class="koboSpan" id="kobo.593.2">Now, let’s throw together a simple configuration file that overrides where API Portal will look for OpenAPI 3 docs, and update the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">package installation.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">First, create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">api-portal-values.yaml</span></strong><span class="koboSpan" id="kobo.597.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">following contents:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.599.1">
apiPortalServer:
   sourceUrls:  https://petstore.swagger.io/v2/swagger.json,https://petstore3.swagger.io/api/v3/openapi.json,http://scg-operator.spring-cloud-gateway.svc.cluster.local/openapi</span></pre>
<p><span class="koboSpan" id="kobo.600.1">As you can see, we’re appending the ClusterIP service of the Spring Cloud Gateway Operator to the list of places where the API Portal will search for </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">API documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">Now, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">tanzu package</span></strong><span class="koboSpan" id="kobo.604.1"> command to update the installation. </span><span class="koboSpan" id="kobo.604.2">Behind the scenes, the API Portal will be redeployed with the new configuration. </span><span class="koboSpan" id="kobo.604.3">This method of deploying software removes configuration drift as any manual configuration changes to the deployment will be overwritten by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">kapp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.606.1"> controller:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.607.1">
bash-5.0$ tanzu package installed update api-portal -n tap-install -f api-portal-values.yaml
| Updating installed package 'api-portal'
| Getting package install for 'api-portal'
| Getting package metadata for 'api-portal.tanzu.vmware.com'
| Creating secret 'api-portal-tap-install-values'
| Updating package install for 'api-portal'
/ Waiting for 'PackageInstall' reconciliation for 'api-portal'
/ 'PackageInstall' resource install status: Reconciling
Updated installed package 'api-portal' in namespace 'tap-install'
bash-5.0$</span></pre>
<p><span class="koboSpan" id="kobo.608.1">Now, let’s re-instate our port forward to our </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">API Portal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.610.1">
bash-5.0$ kubectl get svc -n api-portal
NAME                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
api-portal-server   ClusterIP   10.103.142.154   &lt;none&gt;        8080/TCP   40h
bash-5.0$ kubectl port-forward -n api-portal svc/api-portal-server 8085:8080
Forwarding from 127.0.0.1:8085 -&gt; 8080</span></pre>
<p><span class="koboSpan" id="kobo.611.1">And </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.612.1">upon opening a web browser to </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">http://localhost:8085</span></strong><span class="koboSpan" id="kobo.614.1">, we should see our </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">Animal Rescue</span></strong><span class="koboSpan" id="kobo.616.1"> API in the list, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.618.1"><img alt="Figure 5.6 – API Portal with the Animal Rescue API" src="image/B18145_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">Figure 5.6 – API Portal with the Animal Rescue API</span></p>
<p><span class="koboSpan" id="kobo.620.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">Animal Rescue</span></strong><span class="koboSpan" id="kobo.622.1"> tile, click </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">VIEW APIS</span></strong><span class="koboSpan" id="kobo.624.1">. </span><span class="koboSpan" id="kobo.624.2">Then, on the resulting screen, click </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">/api/animals</span></strong><span class="koboSpan" id="kobo.626.1">, then </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">Try it Out</span></strong><span class="koboSpan" id="kobo.628.1">, then </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">Execute</span></strong><span class="koboSpan" id="kobo.630.1">. </span><span class="koboSpan" id="kobo.630.2">If everything has been configured correctly, you </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.631.1">should see some animal data in JSON format in the </span><strong class="bold"><span class="koboSpan" id="kobo.632.1">Server response</span></strong><span class="koboSpan" id="kobo.633.1"> section, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.635.1"><img alt="Figure 5.7 – Trying out APIs from the browser" src="image/B18145_05_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.636.1">Figure 5.7 – Trying out APIs from the browser</span></p>
<p><span class="koboSpan" id="kobo.637.1">Just to be clear, you’re able to </span><em class="italic"><span class="koboSpan" id="kobo.638.1">try out</span></em><span class="koboSpan" id="kobo.639.1"> APIs directly from the API </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">Portal interface.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">After the </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.642.1">exhilarating experience of installing these two products, wiring them together, and implementing a complex real-world application, we must face the inevitable. </span><span class="koboSpan" id="kobo.642.2">Long after the fun of deploying a working piece of software has faded, the ongoing task of maintenance and support will remain. </span><span class="koboSpan" id="kobo.642.3">We’ll cover </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">that next.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.644.1">Common day-2 operations with Tanzu Application Accelerator</span></h1>
<p><span class="koboSpan" id="kobo.645.1">Congratulations! </span><span class="koboSpan" id="kobo.645.2">If you’ve made it this far, you have set up an API publishing and consumption </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.646.1">model that can unlock incredible value in your enterprise software </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">development operation.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">As is usually the case in the enterprise, the hard problem is not getting something installed and configured, it’s operating it over time. </span><span class="koboSpan" id="kobo.648.2">Let’s look at some of these </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">day-2 operations.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.650.1">Updating an API’s route definition</span></h2>
<p><span class="koboSpan" id="kobo.651.1">Let’s say </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.652.1">we identify a typo in an API route’s description. </span><span class="koboSpan" id="kobo.652.2">We’d like to be able to update that route </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.653.1">in real time and have it propagate to the API Portal without any additional configuration. </span><span class="koboSpan" id="kobo.653.2">Let’s do that. </span><span class="koboSpan" id="kobo.653.3">Navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">animal-rescue</span></strong><span class="koboSpan" id="kobo.655.1"> app that you cloned from GitHub and open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">./backend/k8s/animal-rescue-backend-route-config.yaml</span></strong><span class="koboSpan" id="kobo.657.1"> file in an editor. </span><span class="koboSpan" id="kobo.657.2">At line 17, you’ll see a description starting with </span><em class="italic"><span class="koboSpan" id="kobo.658.1">Retrieve all the anmals</span></em><span class="koboSpan" id="kobo.659.1">. </span><span class="koboSpan" id="kobo.659.2">Fix it so that it reads </span><em class="italic"><span class="koboSpan" id="kobo.660.1">Retrieve all the animals</span></em><span class="koboSpan" id="kobo.661.1">. </span><span class="koboSpan" id="kobo.661.2">If you want to be doubly sure, insert some additional text if you’d like. </span><span class="koboSpan" id="kobo.661.3">Here’s what it looked like in my editor. </span><span class="koboSpan" id="kobo.661.4">I wanted to be </span><em class="italic"><span class="koboSpan" id="kobo.662.1">especially</span></em><span class="koboSpan" id="kobo.663.1"> sure that I was seeing </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">my changes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.665.1"><img alt="Figure 5.8 – Editing the description of an API route" src="image/B18145_05_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.666.1">Figure 5.8 – Editing the description of an API route</span></p>
<p><span class="koboSpan" id="kobo.667.1">Now, we must simply update the Spring Cloud Gateway Route Config in Kubernetes, and the documentation should auto-update. </span><span class="koboSpan" id="kobo.667.2">Don’t forget the namespace, which in the original install was added </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">by </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.669.1">kustomize</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.671.1">
$ kubectl apply -f ./animal-rescue-backend-route-config.yaml -n animal-rescue
springcloudgatewayrouteconfig.tanzu.vmware.com/animal-rescue-backend-route-config configured</span></pre>
<p><span class="koboSpan" id="kobo.672.1">Now, if you still have the port-forward to </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">api-portal</span></strong><span class="koboSpan" id="kobo.674.1"> running, you can navigate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">http://localhost:8085</span></strong><span class="koboSpan" id="kobo.676.1">, click through to the Animal Rescue </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">/api/animals</span></strong><span class="koboSpan" id="kobo.678.1"> route, and see your update in </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">real time!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.680.1"><img alt="Figure 5.9 – Viewing real-time updates to our API specification" src="image/B18145_05_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.681.1">Figure 5.9 – Viewing real-time updates to our API specification</span></p>
<p><span class="koboSpan" id="kobo.682.1">At this point, we’ve </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.683.1">gone in-depth into numerous </span><em class="italic"><span class="koboSpan" id="kobo.684.1">day-0</span></em><span class="koboSpan" id="kobo.685.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.686.1">day-1</span></em><span class="koboSpan" id="kobo.687.1"> tasks, such as deploying and </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.688.1">consuming APIs. </span><span class="koboSpan" id="kobo.688.2">But anyone who has spent any time at all in the enterprise software space knows that the vast majority of our time and effort is spent on the </span><em class="italic"><span class="koboSpan" id="kobo.689.1">day-2</span></em><span class="koboSpan" id="kobo.690.1"> tasks: updating, monitoring, measuring, and improving our software. </span><span class="koboSpan" id="kobo.690.2">Let’s briefly cover some of these </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">day-2 topics.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.692.1">Updating the API Portal package</span></h2>
<p><span class="koboSpan" id="kobo.693.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">tanzu package</span></strong><span class="koboSpan" id="kobo.695.1"> commands </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.696.1">in conjunction with the kapp controller give you incredible power to life cycle-manage </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.697.1">your deployed software. </span><span class="koboSpan" id="kobo.697.2">In the case of API Portal, you can grab the currently deployed version and see which versions are currently available. </span><span class="koboSpan" id="kobo.697.3">Then, to update it, you simply execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">tanzu package installed update -n tap-install api-portal -v &lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">new version&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.701.1">
bash-5.0$ tanzu package installed list -n tap-install
| Retrieving installed packages...
</span><span class="koboSpan" id="kobo.701.2">  NAME        PACKAGE-NAME                 PACKAGE-VERSION  STATUS
  api-portal  api-portal.tanzu.vmware.com  1.0.8            Reconcile succeeded</span></pre>
<p><span class="koboSpan" id="kobo.702.1">We currently have </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">1.0.8 installed:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.704.1">
bash-5.0$ tanzu package available list -n tap-install api-portal.tanzu.vmware.com
/ Retrieving package versions for api-portal.tanzu.vmware.com...
</span><span class="koboSpan" id="kobo.704.2">  NAME                         VERSION  RELEASED-AT
  api-portal.tanzu.vmware.com  1.0.8    2021-12-15 19:00:00 -0500 EST
  api-portal.tanzu.vmware.com  1.0.9    2022-01-02 19:00:00 -0500 EST</span></pre>
<p><span class="koboSpan" id="kobo.705.1">It appears </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.706.1">that version 1.0.9 became </span><a id="_idIndexMarker238"/><span class="No-Break"><span class="koboSpan" id="kobo.707.1">available recently:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.708.1">
bash-5.0$ tanzu package installed update api-portal -n tap-install -v 1.0.9
| Updating installed package 'api-portal'
| Getting package install for 'api-portal'
| Getting package metadata for 'api-portal.tanzu.vmware.com'
| Updating package install for 'api-portal'
/ Waiting for 'PackageInstall' reconciliation for 'api-portal'
Updated installed package 'api-portal' in namespace 'tap-install'</span></pre>
<p><span class="koboSpan" id="kobo.709.1">And with a </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.710.1">simple command, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">api-portal</span></strong><span class="koboSpan" id="kobo.712.1"> package </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.713.1">auto-updates to the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">latest version.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.715.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.716.1">APIs are everywhere. </span><span class="koboSpan" id="kobo.716.2">With OpenAPI 3 and REST becoming the well-accepted standard among developers, a significant portion of an enterprise developer’s job consists of creating, publishing, discovering, and </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">consuming APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">In an environment with a significant number of developers on disparate teams, this inevitably leads to waste: a significant waste of time, effort, </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">and money.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">Developers waste energy reverse-engineering inadequately documented APIs. </span><span class="koboSpan" id="kobo.720.2">They waste time identifying the right API. </span><span class="koboSpan" id="kobo.720.3">They burn unnecessary cycles figuring out how to make their API </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">widely available.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">Once they have an API deployed, there’s a waste of time and energy making sure the API is adequately secured and that it’s shared across a large organization, not to mention making sure those APIs are maintained and kept up </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">to date.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">Architects may spend undue time building out a central clearing house for discovering APIs and a central gateway for </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">deploying them.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">Finally, operators are tasked with monitoring and measuring many polyglot APIs across </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">different platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">With the tools that you’ve now become familiar with in this chapter, I hope you can take a big bite out of that API waste, making your team, your development org, and your company wildly successful, efficient, </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">and API-driven.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">With our next chapter, we will move our focus from </span><em class="italic"><span class="koboSpan" id="kobo.731.1">building</span></em><span class="koboSpan" id="kobo.732.1"> software to </span><em class="italic"><span class="koboSpan" id="kobo.733.1">running</span></em><span class="koboSpan" id="kobo.734.1"> it. </span><span class="koboSpan" id="kobo.734.2">We’ll kick off our new area of focus with a deep dive into hosting and maintaining OCI container images and Helm Charts with the </span><strong class="bold"><span class="koboSpan" id="kobo.735.1">VMware </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.736.1">Harbor Registry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">.</span></span></p>
</div>


<div class="Content" id="_idContainer075">
<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.1.1">Part 2 – Running Cloud-Native Applications on Tanzu</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part of the book focuses on the tools and techniques that help run modern cloud-native applications on Kubernetes with multi-cloud and </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">multi-cluster deployments.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part of the book comprises the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B18145_06.xhtml#_idTextAnchor112"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Managing Container Images with Harbor</span></em></li>
<li><a href="B18145_07.xhtml#_idTextAnchor131"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Orchestrating Containers across Clouds with Tanzu Kubernetes Grid</span></em></li>
<li><a href="B18145_08.xhtml#_idTextAnchor150"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Enhancing Developer Productivity with Tanzu Application Platform</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer076">
</div>
</div>
</body></html>