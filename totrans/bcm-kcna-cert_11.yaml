- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating Cloud Native Application Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will focus on Cloud Native application lifecycle. We’ll learn
    about best practices for development and delivery of Cloud Native apps and see
    how automation helps to *develop better* and *ship faster*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers everything you need to know about *Cloud Native Application
    Delivery* domain of KCNA exam that makes up 8% of the total exam questions. The
    following topics we’re about to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Delivery of Cloud Native applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI/CD and GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure as a Code (IaC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the last technically packed chapter of the book. You’re almost ready
    to take the exam and become Kubernetes and Cloud Native associate. Carry on!
  prefs: []
  type: TYPE_NORMAL
- en: Delivery of Cloud Native applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications are often developed at a high velocity which requires efficient
    and robust delivery processes. That is why Cloud Native applications delivery
    is a rather complex, but highly automated process consisting of multiple stages.
  prefs: []
  type: TYPE_NORMAL
- en: First, developers write code and commit it to a **Version Control System (VCS)**
    such as **Git**, **Mercurial** or **Subversion** with Git being de-facto standard
    today. The code is then *built*, *tested* and *released*. Automating those stages
    makes it possible to speed up the whole process of software delivery and make
    small, frequent, and well-tested software releases.
  prefs: []
  type: TYPE_NORMAL
- en: Release
  prefs: []
  type: TYPE_NORMAL
- en: Is a version of software including the changes (new features, enhancements,
    bugfixes, etc.) to be delivered to the users. Each release has **semantic versioning**
    where v1.0.0 commonly stands for the *first stable* release (More about semantic
    versioning can be found in *Further* *Reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: '*To release* (as a verb) is also commonly used for describing the process of
    deploying to a production environment, e.g., making new software version available
    to the end users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strictly speaking, the application delivered doesn’t have to be Cloud Native.
    However, with Cloud Native architectures that are often based on microservices,
    it is pretty much impossible to do all the *build-test-release* stages manually.
    Imagine for a moment you’d have to do it 30 times for 30 different microservices
    – slow, error prone, and tedious work. That is why automation became an essential
    part of modern application lifecycle and brought us many benefits including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Faster delivery times and more frequent updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More stable releases with automated processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More productivity as manual work minimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fewer bugs with automated test runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatable results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, there is more to it than just *build-test-release* as every service
    should also be deployed, operated and monitored as suggested on *Figure* *11**.1*
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – modern application lifecycle.](img/B18970_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – modern application lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: This loop is infinite, and automation of the stages makes it possible to release
    the changes and updates even multiple times per day. In fact, it also saves a
    lot of developer’s time so that they could focus on developing new features and
    fixing bugs. It should also be possible to roll back the changes easily and fast
    in case of any issues (one example of how to do it with Kubernetes and Helm was
    discussed previously in [*Chapter 8*](B18970_08.xhtml#_idTextAnchor085)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the basics of Cloud Native application delivery, let’s
    dive into CI/CD and GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD and GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have heard it before, **CI** stands for **Continuous Integration**
    and **CD** for **Continuous Delivery** or sometimes **Continuous Deployment**.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs: []
  type: TYPE_NORMAL
- en: Is a practice and process automation targeting developers. With CI, code changes
    are regularly *built*, *tested* and *integrated* into a shared repository (branch/trunk/etc.)
  prefs: []
  type: TYPE_NORMAL
- en: CI is viewed as a solution to the problem of having too many changes in development
    at once that might conflict with each other and being hard *to merge*. The ultimate
    goal is to ensure that the software is always in the working state and in case
    automated tests fail, the team has to fix the problem first, before continuing
    with development.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery
  prefs: []
  type: TYPE_NORMAL
- en: Usually refers to an automation in the pipeline where the tested code changes
    mark a *release* that is uploaded to a package repository or container image.
    From there on, the image or a package can be *deployed* after approval.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery can be seen as a way to align development and business teams
    and its purpose is to ensure that it would take minimum time and effort to deploy
    new code. In Continuous Delivery, there is normally an approval that should be
    done by a human before the release can be deployed to a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Deployment
  prefs: []
  type: TYPE_NORMAL
- en: Is a further automation for deploying changes from the source repository to
    a development, testing or production environments. It is essentially Continuous
    Delivery except deployment happens automatically when all the tests and checks
    have passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Schematically, this can be seen as follows in *Figure 11**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – the CI/CD/CD pipelines.](img/B18970_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – the CI/CD/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, there are many ways how to implement CI or CD automation in
    any organization, and there is no *single right way* of doing it. We can use different
    tools, introduce custom checks or deployment schedules, involve various stakeholders
    for approval, etc. However, one thing that will always be present is a **Pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: Ci/CD Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Is a top-level component which implements automation processes. Pipeline typically
    consists of multiple jobs and stages where output of one job or stage can be used
    as an input for the next job/stage. Pipeline might invoke multiple tools to compile
    the code, run unit tests, perform code analysis, create binaries, package code
    into container and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Why we often refer to pipelines when talking about CI/CD is because many processes
    in software delivery have sequential steps that are executed one after another.
    You can think of it as a pipe where the source code comes in on one side and built
    and tested package come out on another side. Or, possibly, the package is being
    deployed on the other end. And this process repeats all over again as previously
    shown on *Figure 11**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about the packages and change sets, it is considered best to release
    and deploy small changes often, rather than infrequently do big changes, especially
    when implementing *Continuous Deployment*. When the change set is small, there
    is much lower risk of things going wrong, so it is recommended to release and
    deploy small, tested changes regularly instead of deploying many changes together
    as *big bang* once in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the concept, let’s mention few tools that can help us
    to implement CI/CD automation. There are many tools available today and despite
    different feature sets, they all can be used to build and run CI/CD pipelines.
    Some might be a better fit for your tech stack with better support for one or
    another VCS, some provide Kubernetes and various IaaS/PaaS integrations, and some
    are only available *as a service*. CI/CD system offered as a service means provider
    will take care of its maintenance, updates, scaling and so on for a monthly fee.
    Make sure to conduct some research before picking one for your team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listed here are a few popular CI/CD systems that you might want to check out:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ArgoCD**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gitlab CI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tekton**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Actions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spinnaker**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FluxCD**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GoCD**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CircleCI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TravisCI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The presence of *CI* or *CD* in the names does not mean you can only implement
    *CI* or *CD* with that tool. Some of the tools could be used for implementing
    both *CI* and *CD* and some not.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we’ve learned about *DevOps*, *DevSecOps*, *FinOps,* and now there
    is one more *Ops* to go – **GitOps**. Introduced in 2017, it is a further evolution
    of industry best practices and CI/CD applied for modern infrastructure and Cloud
    Native application delivery.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps
  prefs: []
  type: TYPE_NORMAL
- en: Is an operational framework combining DevOps practices such as Git version control,
    collaboration, compliance, declarative configuration, and CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – overview of GitOps.](img/B18970_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – overview of GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitOps based upon three core elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merge Requests (MR) + Infrastructure as a Code (IaC) +** **CI/CD**'
  prefs: []
  type: TYPE_NORMAL
- en: '`master`) branch and commit messages along with comments serve as an audit
    log.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IaC** is the topic of the upcoming section, but at a high-level, it is a
    practice of describing desired infrastructure configuration and setup as a code
    that is kept in Git repository. IaC is an example of *declarative configuration*
    that serves as the *source of truth* for your infrastructure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CI/CD** is an essential part of GitOps and its purpose is not just to automate
    the delivery stages described in the previous section, but also to avoid manual
    changes and eliminate **infrastructure drift**. Manual changes are not tolerated
    with GitOps.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Infrastructure (configuration) drift
  prefs: []
  type: TYPE_NORMAL
- en: Is when the real-time state of the infrastructure does not match what has been
    defined in your *IaC* configuration. Drift can be caused by manual human actions,
    applications making unintended changes, software bugs and other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Drift can cause uncertainty, application failures, and even introduce security
    holes. That is why eliminating infrastructure drift is very important and GitOps
    does this job well if implemented right. If someone did manual changes, then latest
    on the next MR being accepted and merged into the *source of truth* Git repository
    those manual changes will be overwritten and drift will be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, some advanced GitOps tools such as *ArgoCD*, *FluxCD* and *Jenkins
    X* have the capability to constantly watch the changes in Git repository and propagate
    those to a connected live environment. The system will resync and bring environment
    to the desired state automatically – any manual change on the live environment
    will be overwritten in a matter of seconds. New changes coming from code merged
    in Git will be deployed automatically and fast.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that *ArgoCD*, *FluxCD* and *Jenkins X* require
    Kubernetes cluster to run on. That does not mean it is impossible to implement
    GitOps without Kubernetes, but implementing it with Kubernetes is much easier
    due to developed ecosystem and its ultimate *reconciliation loop* functionality
    that brings cluster resources to the desired state (see [*Chapter 5*](B18970_05.xhtml#_idTextAnchor059)
    in case you’ve forgotten).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the following example to see how GitOps and K8s can complement
    each other. Imagine your team operates microservices on Kubernetes and specification
    definitions are stored in Git repository which acts as the source of truth. You
    use ArgoCD for GitOps that deploys K8s manifests to the target Kubernetes clusters.
    A new colleague has recently started in your team and got the task to decommission
    a microservice that is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the new colleague was not fully onboarded with the processes
    and started deleting Kubernetes resources manually with `kubectl` which is a GitOps
    anti-pattern. By mistake, he/she has deleted wrong K8 Deployment which belonged
    to another microservice in production environment. Kubernetes controller loop
    kicked in and started terminating Pods managed by that Deployment, bringing wrong
    microservice down. Luckily, ArgoCD had auto-sync turned on and detected that the
    state of both affected microservices has drifted away from the definition located
    in Git repository. ArgoCD kicked in and quickly created missing Deployment and
    other manually deleted resources. The service quickly came back online. A colleague
    has opened a MR to change the desired state in Git correctly which got approved
    by the teammates and merged. In an event of wrong changes been merged into Git,
    it is just as easy to roll them back by simply reverting the respective commit.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.4* demonstrates an example GitOps process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – CI/CD and GitOps example with ArgoCD and Kubernetes.](img/B18970_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – CI/CD and GitOps example with ArgoCD and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to implement similar process in your team or organization, consider
    the fact that ArgoCD is suitable for GitOps and CD, but for implementing CI, you’ll
    need an additional tool. That could be, for example, Argo Workflows or Gitlab
    CI or similar.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap it up, GitOps is a very powerful framework that primarily focuses on
    CD and CI. It allows to deliver software at a very fast pace, maximize stability,
    increase productivity and free up productive time for the team as manual operations
    are automated. All configurations are transparent, auditable and reviewable. For
    best results and maximum efficiency, you also need to implement CI to automate
    testing and building of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s talk about IaC in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as a Code (IaC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IaC is the practice of managing and provisioning infrastructure in a declarative
    way via definition files. You describe the desired state in definition files and
    let a tool apply the configuration to your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry, despite the presence of the word *Code* that does not mean you’ll
    need to learn how to code in **C++** or **Java** or other advanced programming
    language. Most IaC tools allow configuration to be defined in *YAML* or a similar
    human-readable markup language.
  prefs: []
  type: TYPE_NORMAL
- en: IaC automates and replaces manual operations for infrastructure configuration
    and provisioning. Essentially, all actions that can be done using your cloud provider
    UI or CLI manually can be done with an IaC tool. Instead of clicking through the
    dashboard to configure and provision VM every time you need one, you could describe
    the desired number and type of VMs you need in IaC and keep that configuration
    in Git or other version control. Invoking an IaC tool with desired configuration
    will establish communication with cloud provider API and create described resources.
    If resources were there before and configured correctly, IaC tool won’t do any
    further changes. Resources that IaC can provision include VMs, load balancers,
    network attached storage, firewall rules, object storage buckets and much-much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Today, **Terraform** is one of the most popular IaC tools on the market. It
    supports major public and private cloud providers and most of their IaaS/PaaS/SaaS/FaaS
    offerings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform accepts JSON as well as own `.tf` definition file format and here
    is a small example to give you an idea what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If applied, this definition file will provision a `t3.medium` type VM tagged
    `KCNAExampleInstance` in AWS public cloud in `eu-central-1` region. This VM can
    also be referenced again in other definition files, for example, if you’d like
    to attach a storage block device to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the scope of KCNA, you don’t need to memorize the format or `.tf` specifics,
    but you need to remember the advantages of IaC which were already mentioned in
    the previous section since IaC is an essential part of GitOps:'
  prefs: []
  type: TYPE_NORMAL
- en: Faster setup and reproducible results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human-readable and reviewable configuration that can be stored in VCS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elimination of infrastructure drift with desired state definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worth mentioning that some cloud providers have their own, vendor specific IaC
    tools that might offer better support for their cloud services, but obviously
    won’t be compatible with any other providers. **CloudFormation** – an IaC made
    by AWS only for AWS would be such an example.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember the exercises we did in *Chapters 5* and *6*, we basically used
    IaC with Kubernetes. Kubernetes uses declarative resource definitions to describe
    workloads but can also be used to provision load balancers (with `LoadBalancer`
    Service type) and persistent storage (as *PV* and *PVC*). When you run it in a
    public cloud environment and apply the specification, Kubernetes cloud controller
    manager will interact with provider APIs and ensure that resources are provisioned
    and in the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we’ve learned about the delivery of Cloud Native applications.
    Modern applications require CI/CD to automate all stages of software delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Where CI focuses on the first *build-test-release* stages, *Continuous Delivery*
    focuses on packaging software in container images or installable software packages
    and uploading them into container registry or package repositories respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Another CD – *Continuous Deployment* focuses on automatic deployment of the
    tested and packaged *releases* into various live environments.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ve seen how *GitOps* evolved on top of *CI/CD* by adding reviewable
    merge (or pull) requests together with IaC. This has led to an ultimate, highly
    automated, and powerful process that works especially well with Kubernetes. Some
    of the popular tools that help implementing GitOps are *ArgoCD*, *FluxCD* and
    *Jenkins X*.
  prefs: []
  type: TYPE_NORMAL
- en: IaC is the practice of managing and provisioning infrastructure in a declarative
    way with definition files. Using IaC allows to eliminate *Infrastructure Drift*
    and have reviewable and reproducible infrastructure configuration. *Terraform*
    is one of the most popular IaC tools today.
  prefs: []
  type: TYPE_NORMAL
- en: Going with IaC and GitOps means no manual changes, no manual deployments or
    live reconfiguration is allowed. The whole team should be aware and follow the
    process. Git repositories act as a source of truth and CI/CD systems ensure that
    this desired state is reached and maintained.
  prefs: []
  type: TYPE_NORMAL
- en: And with that we’ve finished the last technical chapter! Congratulations and
    well done! In the next two chapters you’ll find a mock exam to evaluate your readiness
    as well as tips on how to pass the exam and what to do after.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Correct answers can be found at __TBD__
  prefs: []
  type: TYPE_NORMAL
- en: What does CI mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Interaction
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Improvement
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Inspection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following stages are the focus of CI automation (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Build, Test
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Package
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following definitions are correct for CD (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Debugging
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Delivery
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Destruction
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous Deployment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is considered a CI/CD practice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Frequent, large releases done by the whole team together
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Frequent, small, and fully automated releases
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Frequent, small, well tested, and automated releases
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Infrequent, large, and automated releases
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following tools are suitable for GitOps (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins X
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: FluxCD
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: TravisCI
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ArgoCD
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following elements are a part of GitOps (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: IaC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Merge (or pull) Requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which VCS is used with GitOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bitbucket
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mercurial
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is infrastructure drift?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the infrastructure is fully automated and can drift on autopilot
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the number of VMs in cloud has increased due to autoscaling events
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the performance of VMs varies during the day depending on demand
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the real infrastructure state is different from what is desired and defined
    by IaC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What should NOT be done with established GitOps process in team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitoring the system state
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Opening (pull) merge requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual changes in the live environment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reviewing teammate’s code as tests are automated
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is normally defined with IaC (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System architecture
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VMs and load balancers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Database migrations
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Firewall rules
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of GitOps (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Faster and more stable software delivery
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: No need to monitor live environments anymore
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: More free time for the team due to high degree of automation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All Kubernetes operations are handled by CI/CD
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of CI (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatic deployment of tested code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatic packaging of tested code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: No developer time spent for running builds or tests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue detection with automated tests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a correct definition of a *release*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A version of software to be delivered to the users
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A current state of application in K8s cluster
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A decision to stop further development
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A complete CI/CD pipeline run
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is a CI/CD tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CloudFormation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: GitlabCI
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What normally triggers a deployment in GitOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push into any Git branch
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An event of infrastructure drift
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Approved and merged MR (PR)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual rebase in Git
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is true about GitOps (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite of manual changes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is only possible with Kubernetes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses declarative configuration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can only be used with a few popular programming languages
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following stages are NOT a part of CI/CD (pick multiple)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Build
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Plan
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Semantic versioning: [https://semver.org/](https://semver.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is GitOps: [https://www.weave.works/blog/what-is-gitops-really](https://www.weave.works/blog/what-is-gitops-really)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ArgoCD: [https://argo-cd.readthedocs.io/](https://argo-cd.readthedocs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ArgoCD examples: [https://github.com/argoproj/argocd-example-apps](https://github.com/argoproj/argocd-example-apps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FluxCD: [https://fluxcd.io/](https://fluxcd.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitLab for CI/CD: [https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terraform: [https://www.terraform.io/](https://www.terraform.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 5: KCNA Exam and Next Steps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this closing part, you’ll find tips for preparing for and passing the exam,
    along with two mock exams to verify your knowledge. Finally, we’ll discuss what
    your next steps could be after getting certified to start or advance your cloud
    native career.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18970_12.xhtml#_idTextAnchor122), *Practicing for the KCNA
    Exam with Mock Papers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18970_13.xhtml#_idTextAnchor128), *The Road Ahead*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
