- en: <st c="0">9</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">9</st>
- en: <st c="2">Exploring Future Work</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">探索未来工作</st>
- en: <st c="23">Congratulations!</st> <st c="41">You have built seven unique applications
    using multiple AWS services.</st> <st c="111">But learning is a journey that</st>
    <st c="142">never ends.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23">恭喜！</st> <st c="41">您已经使用多个 AWS 服务构建了七个独特的应用程序。</st> <st c="111">但是，学习是一个</st>
    <st c="142">永无止境的旅程。</st>
- en: <st c="153">In this theory-based chapter, you are going to learn even more about
    AWS services.</st> <st c="237">Architecture is about trade-offs; knowing what
    you can use and when will be advantageous in the future.</st> <st c="341">To illustrate
    this, we will revisit architectures from the previous chapters and</st> <st c="422">redesign
    them.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="153">在本章基于理论的章节中，您将进一步了解更多关于 AWS 服务的内容。</st> <st c="237">架构是关于权衡的；了解什么时机使用哪些服务将在未来变得更加有利。</st>
    <st c="341">为了说明这一点，我们将重新审视前面章节的架构并</st> <st c="422">对其进行重新设计。</st>
- en: <st c="436">Price is a consideration you saw highlighted in the requirements
    gathering and service selection sections throughout the book.</st> <st c="564">In
    this chapter, you will learn how to use AWS Pricing Calculator to estimate costs
    before building out</st> <st c="668">your architectures.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="436">价格是您在本书的需求收集和服务选择部分中看到的一个重点。</st> <st c="564">在本章中，您将学习如何使用 AWS
    定价计算器来估算成本，以便在构建</st> <st c="668">架构之前进行预估。</st>
- en: <st c="687">Lastly, you are going to explore multiple different resources AWS
    has to offer to help you architect and build</st> <st c="799">better applications.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="687">最后，您将探索 AWS 提供的多个不同资源，以帮助您架构和构建</st> <st c="799">更好的应用程序。</st>
- en: <st c="819">Technical requirements</st>
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="819">技术要求</st>
- en: <st c="842">This is a theory-based chapter, and because of that, there are no
    technical requirements.</st> <st c="933">If you decide to redesign any of the
    previous chapters’ architectures, based on the learnings of this chapter, you
    will need your own</st> <st c="1067">AWS account.</st>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="842">这是一个基于理论的章节，因此没有技术要求。</st> <st c="933">如果您决定根据本章的学习内容重新设计任何前面章节的架构，您将需要自己的</st>
    <st c="1067">AWS 账户。</st>
- en: <st c="1079">AWS services overview</st>
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1079">AWS 服务概览</st>
- en: <st c="1101">AWS currently offers</st> <st c="1123">over 200 services, across
    various categories, including compute, storage, databases, networking, analytics,
    machine learning, the</st> **<st c="1253">Internet of Things</st>** <st c="1272">(</st>**<st
    c="1273">IoT</st>**<st c="1276">), mobile, developer</st> <st c="1297">tools,
    management tools, security, and enterprise applications.</st> <st c="1362">The
    exact number of AWS services will change as new services are introduced.</st>
    <st c="1439">Over the previous eight chapters, you have learned about some of
    these services and built several applications</st> <st c="1550">using them.</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1101">AWS 目前提供</st> <st c="1123">超过 200 种服务，涵盖多个类别，包括计算、存储、数据库、网络、分析、机器学习、</st>
    **<st c="1253">物联网</st>** <st c="1272">(</st>**<st c="1273">IoT</st>**<st c="1276">)、移动、开发者</st>
    <st c="1297">工具、管理工具、安全性和企业应用程序。</st> <st c="1362">AWS 服务的确切数量会随着新服务的推出而变化。</st>
    <st c="1439">在过去的八章中，您已经学习了一些这些服务，并使用它们构建了多个应用程序。</st> <st c="1550">使用它们。</st>
- en: <st c="1561">The beauty of solutions architecture is that there is no single
    answer or architecture.</st> <st c="1650">It is all about trade-offs.</st> <st
    c="1678">The applications you learned how to build in previous chapters can be
    built using different approaches and services.</st> <st c="1795">In this section,
    we will study alternative architectures for past chapters’ applications using
    AWS services that you haven’t</st> <st c="1920">seen yet.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1561">解决方案架构的美妙之处在于，没有单一的答案或架构。</st> <st c="1650">这完全是关于权衡。</st> <st
    c="1678">您在前面章节中学到的应用程序可以通过不同的方式和服务来构建。</st> <st c="1795">在本节中，我们将研究使用您尚未</st>
    <st c="1920">见过的 AWS 服务来实现过去章节中应用程序的替代架构。</st>
- en: <st c="1929">Containers</st>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="1929">容器</st>
- en: <st c="1940">Containers</st> <st c="1952">are</st> <st c="1955">lightweight,
    virtualized computing environments that allow you to package and run applications
    along with their dependencies in an isolated and portable way.</st> <st c="2114">Containers
    are designed to be lightweight and efficient, as they share the host operating
    system kernel, unlike traditional</st> **<st c="2238">virtual machines</st>**
    <st c="2254">(</st>**<st c="2256">VMs</st>**<st c="2259">), which</st> <st c="2269">require
    a separate guest operating system for each instance.</st> <st c="2330">Containers
    are a computing option, just</st> <st c="2370">like VMs.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1940">容器</st> <st c="1952">是</st> <st c="1955">轻量级的虚拟化计算环境，允许您将应用程序及其依赖项打包并以隔离和可移植的方式运行。</st>
    <st c="2114">容器设计上非常轻量和高效，因为它们共享主机操作系统内核，不像传统的</st> **<st c="2238">虚拟机</st>**
    <st c="2254">(</st>**<st c="2256">VMs</st>**<st c="2259">)，后者为每个实例需要单独的操作系统。</st>
    <st c="2269">容器是一种计算选项，类似于</st> <st c="2330">虚拟机。</st>
- en: <st c="2379">Important note</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2379">重要提示</st>
- en: <st c="2394">You already used containers in</st> [*<st c="2426">Chapter 6</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="2435">; CodePipeline uses a container to run the instructions in</st> <st c="2495">each
    stage.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2394">您已经在</st> [*<st c="2426">第六章</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="2435">中使用过容器；CodePipeline 使用容器在</st> <st c="2495">每个阶段运行指令。</st>
- en: <st c="2506">Because containers are lightweight, the best practice is to isolate
    different functions in different containers, as shown in</st> *<st c="2632">Figure
    9</st>**<st c="2640">.1</st>*<st c="2642">, where a single VM became four containers.</st>
    <st c="2686">A single service can be split across more than one container.</st>
    <st c="2748">Notice how</st> **<st c="2759">Likes Service</st>** <st c="2772">is
    in two containers, while in the</st> **<st c="2808">Virtual Machine</st>** <st
    c="2823">environment, there is just a single one.</st> <st c="2865">Containers
    give you</st> <st c="2885">more flexibility.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2506">由于容器是轻量级的，最佳实践是将不同的功能隔离到不同的容器中，如</st> *<st c="2632">图 9</st>**<st
    c="2640">.1</st>*<st c="2642">所示，其中一个虚拟机变成了四个容器。</st> <st c="2686">一个单一的服务可以跨多个容器进行拆分。</st>
    <st c="2748">请注意，</st> **<st c="2759">点赞服务</st>** <st c="2772">分布在两个容器中，而在</st>
    **<st c="2808">虚拟机</st>** <st c="2823">环境中，只有一个容器。</st> <st c="2865">容器为您提供了</st>
    <st c="2885">更多的灵活性。</st>
- en: '![Figure 9.1 – VM versus container decomposition](img/B22051_09_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 虚拟机与容器分解](img/B22051_09_1.jpg)'
- en: <st c="3061">Figure 9.1 – VM versus container decomposition</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3061">图 9.1 – 虚拟机与容器分解</st>
- en: <st c="3107">As applications built with containers become more complex, it requires
    coordination across multiple containers and hosts; orchestration becomes crucial
    for efficient management and scaling.</st> <st c="3298">Container orchestration
    platforms provide a centralized control plane and APIs to simplify the deployment,
    scaling, and management of</st> <st c="3432">containerized applications.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3107">随着容器构建的应用程序变得越来越复杂，跨多个容器和主机的协调变得至关重要；因此，容器编排对于高效的管理和扩展非常重要。</st>
    <st c="3298">容器编排平台提供了一个集中控制平面和API，以简化容器化应用程序的部署、扩展和管理。</st> <st c="3432">容器化应用程序。</st>
- en: <st c="3459">In AWS, the most common container orchestration platforms are</st>
    <st c="3522">the following:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3459">在 AWS 中，最常见的容器编排平台是</st> <st c="3522">以下几种：</st>
- en: '**<st c="3536">Amazon Elastic Container Service (ECS)</st>**<st c="3575">:
    A fully managed container orchestration</st> <st c="3617">service</st> <st c="3625">that
    helps you deploy, manage, and scale containerized applications across a cluster
    of EC2 instances or Fargate instances.</st> <st c="3750">It supports Docker containers
    and allows you to run and manage containers</st> <st c="3824">at scale.</st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3536">Amazon Elastic Container Service (ECS)</st>**<st c="3575">：一项完全托管的容器编排服务，帮助您在
    EC2 实例或 Fargate 实例的集群中部署、管理和扩展容器化应用程序。</st> <st c="3617">它支持 Docker 容器，并允许您以大规模运行和管理容器。</st>
    <st c="3750">它支持 Docker 容器，允许您大规模运行和管理容器。</st>'
- en: '**<st c="3833">Amazon Elastic Kubernetes Service (EKS)</st>**<st c="3873">:
    A managed Kubernetes service that</st> <st c="3909">simplifies the deployment,
    management, and scaling of containerized applications using Kubernetes on AWS.</st>
    <st c="4016">Kubernetes is an open source container orchestration platform that
    automates the deployment, scaling, and management of</st> <st c="4136">containerized
    applications.</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3833">Amazon 弹性 Kubernetes 服务（EKS）</st>**<st c="3873">：一种托管的 Kubernetes
    服务，</st> <st c="3909">简化了在 AWS 上使用 Kubernetes 部署、管理和扩展容器化应用程序的过程。</st> <st c="4016">Kubernetes
    是一个开源的容器编排平台，能够自动化容器化应用程序的部署、扩展和管理。</st> <st c="4136">容器化应用程序。</st>'
- en: <st c="4163">You can replace</st> <st c="4179">any past chapters’ computing
    options with containers.</st> <st c="4234">The serverless architecture introduced
    in</st> [*<st c="4276">Chapter 4</st>*](B22051_04.xhtml#_idTextAnchor089) <st
    c="4285">using containers orchestrated by ECS in an EC2 environment would look
    as in</st> *<st c="4362">Figure 9</st>**<st c="4370">.2</st>*<st c="4372">. You
    replace the lambda functions such as</st> `<st c="4415">put_like</st>` <st c="4423">or</st>
    `<st c="4427">get_recipes</st>` <st c="4438">for containers that host the same
    functionality.</st> <st c="4488">Your API gateway using a private integration
    connects to an</st> <st c="4547">internal</st> **<st c="4557">Application Load
    Balancer (ALB)</st>** <st c="4588">that exposes ECS tasks.</st> <st c="4613">You
    need a private integration because the load balancer and the ECS containers live
    in a VPC, while the API gateway does not.</st> <st c="4740">You can read more
    about private integrations in the AWS</st> <st c="4796">documentation:</st> [<st
    c="4811">https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html</st>](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html)<st
    c="4917">.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4163">你可以将</st> <st c="4179">过去章节中的计算选项替换为容器。</st> <st c="4234">在</st>
    [*<st c="4276">第 4 章</st>*](B22051_04.xhtml#_idTextAnchor089) <st c="4285">中介绍的无服务器架构，使用
    ECS 在 EC2 环境中编排的容器，效果如</st> *<st c="4362">图 9</st>**<st c="4370">.2</st>*<st c="4372">。你将像</st>
    `<st c="4415">put_like</st>` <st c="4423">或</st> `<st c="4427">get_recipes</st>`
    <st c="4438">这样的 Lambda 函数替换为承载相同功能的容器。</st> <st c="4488">你的 API 网关使用私有集成连接到一个</st>
    <st c="4547">内部</st> **<st c="4557">应用负载均衡器（ALB）</st>** <st c="4588">，该负载均衡器公开
    ECS 任务。</st> <st c="4613">你需要使用私有集成，因为负载均衡器和 ECS 容器位于 VPC 中，而 API 网关则不在其中。</st>
    <st c="4740">你可以在 AWS</st> <st c="4796">文档中阅读更多关于私有集成的内容：</st> [<st c="4811">https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html</st>](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html)<st
    c="4917">。</st>
- en: '![Figure 9.2 – Chapter 4''s architecture re-designed using containers](img/B22051_09_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 使用容器重新设计的第 4 章架构](img/B22051_09_2.jpg)'
- en: <st c="5144">Figure 9.2 – Chapter 4's architecture re-designed using containers</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5144">图 9.2 – 使用容器重新设计的第 4 章架构</st>
- en: <st c="5210">As you can</st> <st c="5222">tell by</st> *<st c="5230">Figure
    9</st>**<st c="5238">.2</st>*<st c="5240">, containers can still run in VMs, in
    this case, EC2\.</st> <st c="5294">You</st> <st c="5297">can also run containers
    in a serverless manner using Fargate.</st> <st c="5360">Fargate is a serverless
    compute engine for containers that allows you to run containers without having
    to manage the underlying EC2 instances.</st> <st c="5503">It works seamlessly
    with both ECS and EKS, eliminating</st> <st c="5557">the need to provision and</st>
    <st c="5584">manage servers</st> <st c="5599">or clusters.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5210">如你所见</st> <st c="5222">，*<st c="5230">图 9</st>**<st c="5238">.2</st>*<st
    c="5240">，容器仍然可以在虚拟机中运行， 在这种情况下是 EC2\。</st> <st c="5294">你</st> <st c="5297">也可以使用
    Fargate 以无服务器方式运行容器。</st> <st c="5360">Fargate 是一种无服务器计算引擎，专为容器设计，允许你在无需管理底层 EC2
    实例的情况下运行容器。</st> <st c="5503">它与 ECS 和 EKS 无缝配合，消除了</st> <st c="5557">提供和</st>
    <st c="5584">管理服务器</st> <st c="5599">或集群的需求。</st>
- en: <st c="5611">Other API types</st>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5611">其他 API 类型</st>
- en: <st c="5627">In this book, you</st> <st c="5645">only built REST APIs.</st>
    <st c="5668">However, there are other types of APIs that are not RESTful.</st>
    <st c="5729">A very popular example</st> <st c="5752">is GraphQL.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5627">在本书中，你</st> <st c="5645">只构建了 REST API。</st> <st c="5668">然而，还有其他类型的
    API 不是 RESTful 的。</st> <st c="5729">一个非常流行的例子</st> <st c="5752">是 GraphQL。</st>
- en: <st c="5763">GraphQL is a query language and server-side runtime for APIs, originally
    developed by Facebook in 2012\.</st> <st c="5868">It provides an efficient, powerful,
    and flexible approach to building and consuming APIs and has become increasingly
    popular for use with cloud applications.</st> <st c="6026">The reason it has become
    so popular is that it solves the problems of overfetching, retrieving more data
    than needed, and underfetching, requiring multiple requests to fetch related data,
    which are common problems in traditional</st> <st c="6255">REST APIs.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5763">GraphQL 是一种查询语言和服务器端运行时环境，最初由 Facebook 于 2012 年开发。</st> <st c="5868">它提供了一种高效、强大且灵活的方法来构建和使用
    API，并且在云应用中越来越受欢迎。</st> <st c="6026">它之所以如此受欢迎，是因为它解决了传统 REST API 中常见的两个问题：超取（获取比实际需要更多的数据）和欠取（需要多次请求以获取相关数据）。</st>
    <st c="6255">这些问题在传统的 REST API 中比较常见。</st>
- en: <st c="6265">There are some important characteristics to have</st> <st c="6315">in
    mind:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6265">需要牢记一些重要特点：</st> <st c="6315"></st>
- en: <st c="6323">Instead of having multiple endpoints for different resources, GraphQL
    typically exposes a single endpoint for querying data.</st> <st c="6449">This
    simplifies the API surface and makes it easier to evolve the API</st> <st c="6519">over
    time.</st>
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6323">GraphQL 通常会为数据查询暴露一个单一端点，而不是为不同资源设置多个端点。</st> <st c="6449">这简化了
    API 接口，并使得 API 的演变变得更加容易</st> <st c="6519">随时间推移。</st>
- en: <st c="6529">It uses a strongly typed query language that allows clients to
    request exactly the data they need from the server.</st> <st c="6645">This contrasts
    with traditional REST APIs where the server often returns more data than the</st>
    <st c="6737">client needs.</st>
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6529">它使用一种强类型查询语言，允许客户端仅请求所需的数据。</st> <st c="6645">这与传统的 REST API 不同，后者通常返回超过客户端需求的数据</st>
    <st c="6737">量。</st>
- en: <st c="6750">With GraphQL, the client has more control over the data it receives,
    allowing for better performance and flexibility.</st> <st c="6869">It has a</st>
    <st c="6878">client-driven architecture.</st>
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6750">使用 GraphQL，客户端对接收到的数据有更多控制，从而实现更好的性能和灵活性。</st> <st c="6869">它具有</st>
    <st c="6878">客户端驱动的架构。</st>
- en: <st c="6905">GraphQL APIs are built around a schema that defines the types,
    queries, mutations, and relationships between different data entities.</st> <st
    c="7040">This schema acts as a contract between the client and server, ensuring
    data consistency and enabling</st> <st c="7141">powerful tooling.</st>
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6905">GraphQL API 是围绕一个模式构建的，定义了类型、查询、变更以及不同数据实体之间的关系。</st> <st c="7040">该模式充当客户端和服务器之间的契约，确保数据一致性，并使得</st>
    <st c="7141">强大的工具能够发挥作用。</st>
- en: <st c="7158">In AWS, AppSync is a managed service that makes it easy to build
    scalable GraphQL APIs.</st> <st c="7247">AppSync simplifies the process of building
    GraphQL APIs by handling the underlying infrastructure, scaling, and security
    aspects, allowing developers to focus on building their application logic; this
    is the same as what an API gateway does for</st> <st c="7492">REST APIs.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7158">在 AWS 中，AppSync 是一个托管服务，使得构建可扩展的 GraphQL API 变得更加容易。</st> <st c="7247">AppSync
    通过处理底层基础设施、扩展和安全方面的工作，简化了构建 GraphQL API 的过程，让开发人员能够专注于构建应用逻辑；这与 API 网关为</st> <st
    c="7492">REST API 所做的工作类似。</st>
- en: '[*<st c="7502">Chapter 5</st>*](B22051_05.xhtml#_idTextAnchor123)*<st c="7512">''s</st>*
    <st c="7515">architecture re-designed using AWS AppSync is similar, as shown in</st>
    *<st c="7583">Figure 9</st>**<st c="7591">.3</st>*<st c="7593">. You replace the
    API gateway with AppSync and use</st> <st c="7644">Lambda resolvers.</st>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[*<st c="7502">第 5 章</st>*](B22051_05.xhtml#_idTextAnchor123)*<st c="7512">''s</st>*
    <st c="7515">架构使用 AWS AppSync 重新设计的方式相似，如</st> *<st c="7583">图 9</st>**<st c="7591">.3</st>*<st
    c="7593">所示。你将 API 网关替换为 AppSync，并使用</st> <st c="7644">Lambda 解析器。</st>'
- en: '![Figure 9.3 – Chapter 5’s architecture re-designed using AWS AppSync](img/B22051_09_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 使用 AWS AppSync 重新设计的第 5 章架构](img/B22051_09_3.jpg)'
- en: <st c="7772">Figure 9.3 – Chapter 5’s architecture re-designed using AWS AppSync</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7772">图 9.3 – 使用 AWS AppSync 重新设计的第 5 章架构</st>
- en: <st c="7839">The way your clients interact with this application is different.</st>
    <st c="7906">You can still use curl or Postman but you need</st> <st c="7952">to
    send the query in the payload.</st> <st c="7987">This is well documented in the
    AWS</st> <st c="8022">documentation:</st> [<st c="8037">https://docs.aws.amazon.com/appsync/latest/devguide/retrieve-data-with-graphql-query.html</st>](https://docs.aws.amazon.com/appsync/latest/devguide/retrieve-data-with-graphql-query.html)<st
    c="8126">.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7839">您的客户与该应用程序的交互方式有所不同。</st> <st c="7906">您仍然可以使用 curl 或 Postman，但需要</st>
    <st c="7952">将查询发送到负载中。</st> <st c="7987">AWS 的文档对此有详细说明：</st> <st c="8022">文档链接：</st>
    [<st c="8037">https://docs.aws.amazon.com/appsync/latest/devguide/retrieve-data-with-graphql-query.html</st>](https://docs.aws.amazon.com/appsync/latest/devguide/retrieve-data-with-graphql-query.html)<st
    c="8126">。</st>
- en: <st c="8127">Generative AI</st>
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8127">生成式 AI</st>
- en: '<st c="8141">You have seen</st> <st c="8155">different AI-powered applications
    throughout this</st> <st c="8206">book: image analysis in</st> [*<st c="8230">Chapter
    5</st>*](B22051_05.xhtml#_idTextAnchor123)<st c="8239">, content translation in</st>
    [*<st c="8264">Chapter 6</st>*](B22051_06.xhtml#_idTextAnchor151)<st c="8273">,
    and Q&A in</st> [*<st c="8286">Chapter 7</st>*](B22051_07.xhtml#_idTextAnchor203)<st
    c="8295">. But there is another type of AI that is taking the world by storm:</st>
    <st c="8364">generative AI.</st>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8141">您已经在本书中看到了</st> <st c="8155">不同的 AI 驱动的应用程序：</st> <st c="8206">第
    5 章中的图像分析，</st> [*<st c="8230">第 5 章</st>*](B22051_05.xhtml#_idTextAnchor123)<st
    c="8239">，第 6 章中的内容翻译，</st> [*<st c="8264">第 6 章</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="8273">，以及第 7 章中的问答。</st> [*<st c="8286">第 7 章</st>*](B22051_07.xhtml#_idTextAnchor203)<st
    c="8295">。但还有一种 AI 正在席卷全球：</st> <st c="8364">生成式 AI。</st>
- en: <st c="8378">Generative AI refers to a class of AI models and techniques capable
    of generating new data, such as text, images, audio, or other multimedia, based
    on the training data they have been exposed to.</st> <st c="8575">Unlike traditional
    AI models that primarily focus on analyzing or classifying existing data, generative
    AI models learn the underlying patterns and characteristics of the training data
    and use this knowledge to create new,</st> <st c="8798">original content.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8378">生成式 AI 指的是一类能够基于训练数据生成新数据（如文本、图像、音频或其他多媒体内容）的 AI 模型和技术。</st> <st
    c="8575">与传统的主要关注分析或分类现有数据的 AI 模型不同，生成式 AI 模型学习训练数据的潜在模式和特征，并利用这些知识创造新的、</st>
    <st c="8798">原创内容。</st>
- en: '**<st c="8815">Foundation models</st>** <st c="8833">(</st>**<st c="8835">FMs</st>**<st
    c="8838">) are a</st> <st c="8847">powerful type of generative AI model that can
    be used for a wide range of tasks.</st> <st c="8928">Different companies have
    built their own models, such as OpenAI GPT, Anthropic Claude, and</st> <st c="9019">Meta
    Llama.</st>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="8815">基础模型</st>** <st c="8833">(</st>**<st c="8835">FM</st>**<st c="8838">)
    是一种强大的生成式 AI 模型，可用于各种任务。</st> <st c="8928">不同的公司已经构建了自己的模型，如 OpenAI GPT、Anthropic
    Claude 和</st> <st c="9019">Meta Llama。</st>'
- en: <st c="9030">You do not need to know how to build these models from scratch,
    but you should know how to get the most out</st> <st c="9139">of them.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9030">您无需从零开始构建这些模型，但您应该知道如何充分利用它们。</st>
- en: <st c="9147">In AWS, you can make use of FMs in a serverless manner using Amazon
    Bedrock.</st> <st c="9225">Amazon Bedrock is a fully managed service that offers
    a choice of high-performing FMs from leading AI companies such as AI21 Labs, Anthropic,
    Cohere, Meta, Mistral AI, Stability AI, and Amazon via a single API, along with
    a broad set of capabilities you need to build generative</st> <st c="9504">AI
    applications.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9147">在 AWS 中，您可以通过使用 Amazon Bedrock 以无服务器的方式利用 FMs。</st> <st c="9225">Amazon
    Bedrock 是一项完全托管的服务，提供来自领先 AI 公司（如 AI21 Labs、Anthropic、Cohere、Meta、Mistral AI、Stability
    AI 和 Amazon）的高性能 FMs，您可以通过单一 API 获取，并提供构建生成式</st> <st c="9504">AI 应用程序所需的广泛功能。</st>
- en: <st c="9520">All you must do is invoke a single API, as you would with any other
    type of AWS service.</st> [*<st c="9610">Chapter 5</st>*](B22051_05.xhtml#_idTextAnchor123)<st
    c="9619">’s architecture</st> <st c="9635">could be altered to use Bedrock with
    Claude 3</st> <st c="9682">Sonnet, instead of Rekognition, as shown in</st> *<st
    c="9726">Figure 9</st>**<st c="9734">.4</st>*<st c="9736">.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9520">您所需要做的只是调用一个 API，就像使用其他任何类型的 AWS 服务一样。</st> [*<st c="9610">第 5
    章</st>*](B22051_05.xhtml#_idTextAnchor123)<st c="9619">的架构</st> <st c="9635">可以修改为使用
    Bedrock 和 Claude 3</st> <st c="9682">Sonnet，而不是 Rekognition，如</st> *<st c="9726">图
    9</st>**<st c="9734">.4</st>*<st c="9736">所示。</st>
- en: '![Figure 9.4 – Chapter 5’s architecture re-designed using Amazon Bedrock](img/B22051_09_4.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 使用 Amazon Bedrock 重新设计的第 5 章架构](img/B22051_09_4.jpg)'
- en: <st c="9856">Figure 9.4 –</st> [<st c="9869">Chapter 5</st>](B22051_05.xhtml#_idTextAnchor123)<st
    c="9878">’s architecture re-designed using Amazon Bedrock</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9856">图9.4 –</st> [<st c="9869">第5章</st>](B22051_05.xhtml#_idTextAnchor123)<st
    c="9878">的架构使用Amazon Bedrock重新设计</st>
- en: <st c="9927">With this approach, you send the image and ask the model your question
    in natural language.</st> <st c="10020">For example, you might ask, "Is this person
    smiling?"</st> <st c="10074">or "Does this photo look professional?".</st> <st
    c="10115">You send that information along with the image and prompt the model
    to evaluate.</st> <st c="10196">The following is an example interaction between
    the author of this book and Claude 3 Sonnet.</st> <st c="10289">The first line,
    prefixed with</st> `<st c="10319">[author]</st>`<st c="10327">, shows the prompt,
    which consists of a question with an attached image.</st> <st c="10400">In this
    case, the image used is the same one referenced in</st> [<st c="10459">Chapter
    5</st>](B22051_05.xhtml#_idTextAnchor123)<st c="10468">'s</st> <st c="10472">code:</st>
    `<st c="10478">goodphoto.jpeg</st>`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9927">采用这种方法，你可以发送图像并用自然语言向模型提问。</st> <st c="10020">例如，你可能会问：“这个人是在微笑吗？”</st>
    <st c="10074">或者“这张照片看起来专业吗？”</st> <st c="10115">你将这些信息与图像一起发送，并提示模型进行评估。</st>
    <st c="10196">以下是本书作者与Claude 3 Sonnet之间的互动示例。</st> <st c="10289">第一行以</st> `<st
    c="10319">[author]</st>`<st c="10327">为前缀，显示了提示，内容是一个带有附图的问题。</st> <st c="10400">在这种情况下，使用的图像与在</st>
    [<st c="10459">第5章</st>](B22051_05.xhtml#_idTextAnchor123)<st c="10468">中引用的图像相同：</st>
    `<st c="10478">goodphoto.jpeg</st>`
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="11253">Generative AI is being increasingly adopted for multiple use cases,
    such as Q&A chatbots, summarizing</st> <st c="11355">text, and generating marketing</st>
    <st c="11387">content.</st> <st c="11396">Keep it in mind when building your</st>
    <st c="11431">next application.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11253">生成式AI正被越来越多地应用于多种场景，如问答聊天机器人、文本摘要</st> <st c="11355">和生成营销</st>
    <st c="11387">内容。</st> <st c="11396">在构建下一个应用程序时，请记住这一点。</st>
- en: <st c="11448">Other communication patterns</st>
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="11448">其他通信模式</st>
- en: <st c="11477">The most prevalent</st> <st c="11496">communication pattern is
    synchronous request/response.</st> <st c="11552">For example, when you visit a
    web page (request), your browser fetches and renders the result (response).</st>
    <st c="11658">This process occurs synchronously, meaning you wait for the response
    after making the request.</st> <st c="11753">But in modern distributed architectures,
    you will sometimes encounter the need for different communication patterns, for
    example, in long processing tasks, where blocking the client while waiting for
    a response interferes with the customer experience, or when you need to deliver
    the exact same content to many</st> <st c="12064">different receivers.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11477">最常见的</st> <st c="11496">通信模式是同步请求/响应。</st> <st c="11552">例如，当你访问一个网页（请求）时，你的浏览器会获取并渲染结果（响应）。</st>
    <st c="11658">这个过程是同步的，意味着在发出请求后你需要等待响应。</st> <st c="11753">但是在现代分布式架构中，有时你会遇到需要不同通信模式的情况，例如在长时间处理任务中，当等待响应时阻塞客户端会干扰客户体验，或者当你需要将相同的内容传递给许多</st>
    <st c="12064">不同的接收者。</st>
- en: <st c="12084">Some popular patterns are asynchronous processing, fan-out and
    broadcasting, and event-driven.</st> <st c="12180">Let’s start by looking at</st>
    <st c="12206">asynchronous processing.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12084">一些常见的模式包括异步处理、分发和广播，以及事件驱动。</st> <st c="12180">让我们从异步处理开始。</st>
    <st c="12206">异步处理</st>
- en: <st c="12230">Asynchronous processing</st>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="12230">异步处理</st>
- en: '<st c="12254">Imagine you need to</st> <st c="12275">build an</st> <st c="12283">application,
    like the one in</st> [*<st c="12313">Chapter 5</st>*](B22051_05.xhtml#_idTextAnchor123)<st
    c="12322">, that receives a photo and processes.</st> <st c="12361">However, the
    processing is not as lightweight as it was in</st> [*<st c="12420">Chapter 5</st>*](B22051_05.xhtml#_idTextAnchor123)<st
    c="12429">. Instead.</st> <st c="12440">It takes four hours to complete and is
    done by EC2 machines.</st> <st c="12501">Many things can happen in four hours:
    processing can fail, the client can timeout, and so on.</st> <st c="12595">In
    this case, a decoupled architecture adds</st> <st c="12639">multiple advantages:</st>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12254">假设你需要</st> <st c="12275">构建一个</st> <st c="12283">应用程序，像在</st>
    [*<st c="12313">第5章</st>*](B22051_05.xhtml#_idTextAnchor123)<st c="12322">中那样，它接收一张照片并进行处理。</st>
    <st c="12361">然而，处理的复杂度并不像在</st> [*<st c="12420">第5章</st>*](B22051_05.xhtml#_idTextAnchor123)<st
    c="12429">中那样轻便。</st> <st c="12440">相反，它需要四小时才能完成，并且是由EC2机器完成的。</st> <st c="12501">在四小时内可能会发生许多事情：处理可能失败，客户端可能超时，等等。</st>
    <st c="12595">在这种情况下，解耦架构带来了</st> <st c="12639">多个优势：</st>
- en: <st c="12659">Clients can send requests without waiting for subscribers to</st>
    <st c="12721">process them.</st>
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="12659">客户端可以发送请求，而无需等待订阅者</st> <st c="12721">处理它们。</st>
- en: <st c="12734">Subscribers can consume messages at their</st> <st c="12777">own
    pace.</st>
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="12734">订阅者可以按</st> <st c="12777">自己的节奏消费消息。</st>
- en: <st c="12786">In the case of a failure on the subscriber side, another subscriber
    can work on the same request.</st> <st c="12885">It will not simply</st> <st c="12904">be
    lost.</st>
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="12786">如果订阅者端出现故障，另一个订阅者可以继续处理相同的请求。</st> <st c="12885">它不会简单地</st> <st
    c="12904">丢失。</st>
- en: <st c="12912">One way to accomplish asynchronous processing is using queues.</st>
    <st c="12976">AWS has Amazon</st> **<st c="12991">Simple Queue Service</st>**
    <st c="13011">(</st>**<st c="13013">SQS</st>**<st c="13016">), a</st> <st c="13021">fully
    managed distributed message</st> <st c="13056">queuing service.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12912">实现异步处理的一种方式是使用队列。</st> <st c="12976">AWS提供了亚马逊</st> **<st c="12991">简单队列服务</st>**
    <st c="13011">(</st>**<st c="13013">SQS</st>**<st c="13016">)，这是一个</st> <st c="13021">完全托管的分布式消息</st>
    <st c="13056">队列服务。</st>
- en: <st c="13072">The architecture from</st> [*<st c="13095">Chapter 5</st>*](B22051_05.xhtml#_idTextAnchor123)
    <st c="13104">can be updated to support asynchronous processing, as shown in</st>
    *<st c="13168">Figure 9</st>**<st c="13176">.5</st>*<st c="13178">. Messages are
    stored in SQS and the EC2 fleet is subscribed to SQS for message processing.</st>
    <st c="13270">Each message is only</st> <st c="13291">processed once.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13072">来自</st> [*<st c="13095">第5章</st>*](B22051_05.xhtml#_idTextAnchor123)
    <st c="13104">的架构可以更新为支持异步处理，如</st> *<st c="13168">图9</st>**<st c="13176">.5</st>*<st
    c="13178">所示。消息存储在SQS中，EC2集群订阅了SQS进行消息处理。</st> <st c="13270">每条消息只会</st> <st c="13291">被处理一次。</st>
- en: '![Figure 9.5 – Chapter 5’s architecture re-designed using asynchronous processing
    with SQS and EC2](img/B22051_09_5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 使用异步处理和SQS与EC2重新设计的第5章架构](img/B22051_09_5.jpg)'
- en: <st c="13435">Figure 9.5 – Chapter 5’s architecture re-designed using asynchronous
    processing with SQS and EC2</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13435">图9.5 – 使用异步处理和SQS与EC2重新设计的第5章架构</st>
- en: <st c="13531">Note that</st> <st c="13542">this</st> <st c="13547">architecture
    does not consider how the client would receive a notification of the</st> <st
    c="13629">task’s completion.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13531">请注意</st> <st c="13542">该</st> <st c="13547">架构并未考虑客户端如何接收任务</st>
    <st c="13629">完成的通知。</st>
- en: <st c="13647">Fan-out and broadcasting</st>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="13647">Fan-out和广播</st>
- en: '<st c="13672">Fan-out is used when you need to deliver a single message to
    multiple endpoints of your choice.</st> <st c="13769">Broadcasting applies the
    same concept but sends the message to all endpoints rather than just the selected
    ones.</st> <st c="13882">Imagine you have a phonebook: fan-out is like messaging
    every single person individually, while broadcasting is like creating a group
    chat and sending the message to everyone in the group.</st> <st c="14071">This
    approach is common in notification systems, data replication or synchronization
    tasks, and</st> <st c="14167">event-driven architectures.</st>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13672">当你需要将单条消息发送到多个端点时，使用Fan-out。</st> <st c="13769">广播应用相同的概念，但将消息发送到所有端点，而不仅仅是选择的那些。</st>
    <st c="13882">假设你有一本电话簿：fan-out就像是逐一发送消息给每个人，而广播就像是创建一个群聊并将消息发送给群里的所有人。</st> <st
    c="14071">这种方法在通知系统、数据复制或同步任务中很常见，且在</st> <st c="14167">事件驱动架构中也经常使用。</st>
- en: <st c="14194">In AWS, there is Amazon</st> **<st c="14219">Simple Notification
    Service</st>** <st c="14246">(</st>**<st c="14248">SNS</st>**<st c="14251">).</st>
    <st c="14255">It is a fully managed pub/sub messaging</st> <st c="14294">service.</st>
    <st c="14304">Unlike SQS, it allows for a single message to be delivered to multiple
    consumers.</st> <st c="14386">It functions on a push-based mechanism, instead
    of pull-based</st> <st c="14448">like SQS.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14194">在 AWS 中，有一个 Amazon</st> **<st c="14219">简单通知服务</st>** <st c="14246">(</st>**<st
    c="14248">SNS</st>**<st c="14251">)。</st> <st c="14255">它是一个完全托管的发布/订阅消息</st>
    <st c="14294">服务。</st> <st c="14304">与 SQS 不同，它允许将一条消息发送到多个消费者。</st> <st c="14386">它采用基于推送的机制，而不是像
    SQS 那样基于拉取的机制。</st>
- en: <st c="14457">Considering the previous asynchronous processing scenario, this
    time you needed to process the same submitted image twice, and you have two different
    computing clusters for this.</st> <st c="14637">With SQS, messages are only processed
    once.</st> *<st c="14681">Figure 9</st>**<st c="14689">.6</st>* <st c="14691">shows
    how to accomplish this using SNS and SQS in a fan-out configuration.</st> <st
    c="14767">When SNS is triggered, it replicates the received message and delivers
    it to both SQS queues.</st> <st c="14861">Each of the two compute clusters then
    polls its respective SQS queue and processes</st> <st c="14944">the message.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14457">考虑到之前的异步处理场景，这次你需要处理同一提交的图像两次，并且你有两个不同的计算集群来处理它。</st> <st c="14637">使用
    SQS，消息只会被处理一次。</st> *<st c="14681">图 9</st>**<st c="14689">.6</st>* <st c="14691">展示了如何使用
    SNS 和 SQS 在扇出配置中实现这一目标。</st> <st c="14767">当 SNS 被触发时，它会复制接收到的消息并将其发送到两个 SQS 队列。</st>
    <st c="14861">然后，两个计算集群中的每一个会轮询各自的 SQS 队列并处理</st> <st c="14944">消息。</st>
- en: "![Figure 9.6 – \uFEFFArchitecture using the fan-out pattern to distribute the\
    \ same message to two different compute clusters](img/B22051_09_6.jpg)"
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 使用扇出模式将相同消息分发到两个不同计算集群的架构](img/B22051_09_6.jpg)'
- en: <st c="15126">Figure 9.6 – Architecture using the fan-out pattern to distribute
    the same message to two different compute clusters</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15126">图 9.6 – 使用扇出模式将相同消息分发到两个不同计算集群的架构</st>
- en: <st c="15242">Lastly, let us</st> <st c="15257">look at the</st> <st c="15270">event-driven
    pattern.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15242">最后，让我们</st> <st c="15257">看看</st> <st c="15270">事件驱动模式。</st>
- en: <st c="15291">Event-driven</st>
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="15291">事件驱动</st>
- en: <st c="15304">Event-driven</st> <st c="15317">refers to a programming</st> <st
    c="15341">paradigm or architectural pattern where the flow of a program is determined
    by events.</st> <st c="15429">In an event-driven system, the program’s execution
    path is triggered by the occurrence of specific events, rather than following
    a predefined sequential flow of instructions.</st> <st c="15604">Events can be
    generated by various sources, such as user interactions (e.g., clicks or key presses),
    system notifications (e.g., file changes or network events), hardware interruptions
    (e.g., timer or sensor data), or messages from other components</st> <st c="15853">or
    systems.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15304">事件驱动</st> <st c="15317">指的是一种编程</st> <st c="15341">范式或架构模式，在这种模式下，程序的流程由事件决定。</st>
    <st c="15429">在事件驱动系统中，程序的执行路径是由特定事件的发生触发的，而不是按照预定义的顺序执行指令。</st> <st c="15604">事件可以由各种来源生成，例如用户交互（如点击或按键）、系统通知（如文件变化或网络事件）、硬件中断（如定时器或传感器数据）或来自其他组件</st>
    <st c="15853">或系统的消息。</st>
- en: <st c="15864">All services in AWS generate events.</st> <st c="15902">You can
    take actions based on them using AWS EventBridge (formerly known as Amazon CloudWatch
    Events).</st> <st c="16005">It is a serverless event</st> <st c="16030">bus service.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15864">AWS 中的所有服务都会生成事件。</st> <st c="15902">你可以使用 AWS EventBridge（前身为
    Amazon CloudWatch Events）基于这些事件采取相应的行动。</st> <st c="16005">它是一个无服务器的事件</st> <st
    c="16030">总线服务。</st>
- en: '<st c="16042">A common example of the use of event-driven architecture is as
    follows: a client uploads a file to your S3 bucket, which emits an event.</st>
    <st c="16180">Based on this event, you trigger a processing pipeline for the</st>
    <st c="16243">uploaded file.</st>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16042">事件驱动架构的一个常见示例如下：一个客户端将文件上传到你的 S3 桶，触发一个事件。</st> <st c="16180">基于这个事件，你触发一个处理流水线来处理</st>
    <st c="16243">上传的文件。</st>
- en: <st c="16257">All these topics are vast but well documented.</st> <st c="16305">Familiarize
    yourself with them.</st> <st c="16337">If you would like to learn more about it,
    we recommend the AWS whitepaper</st> *<st c="16411">Implementing Microservices
    on</st>* *<st c="16441">AWS</st>*<st c="16444">:</st> [<st c="16447">https://docs.aws.amazon.com/whitepapers/latest/microservices-on-aws/communication-mechanisms.html</st>](https://docs.aws.amazon.com/whitepapers/latest/microservices-on-aws/communication-mechanisms.html)<st
    c="16544">.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16545">AWS Pricing Calculator</st>
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="16568">Before building</st> <st c="16585">your architecture, it is important
    to know whether it fits your cost requirements.</st> <st c="16668">It is also
    important to compare different</st> <st c="16710">service options.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16726">There are many ways to accomplish this, for example, using the
    AWS services’ pricing pages.</st> <st c="16819">However, AWS Pricing Calculator
    is the recommended manner.</st> <st c="16878">It allows you to create an estimate
    for the cost of your use on AWS by adding each service individually to</st> <st
    c="16985">a calculator.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16998">Navigate to</st> [<st c="17011">https://calculator.aws/</st>](https://calculator.aws/)
    <st c="17034">and create an estimate.</st> <st c="17059">Add each service individually
    and configure it.</st> <st c="17107">The configuration parameters differ per service.</st>
    <st c="17156">The result will be an estimate of both monthly and</st> <st c="17207">yearly
    costs.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17220">Pricing the solution from Chapter 2</st>
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="17256">Revisit</st> [*<st c="17265">Chapter 2</st>*](B22051_02.xhtml#_idTextAnchor032)
    <st c="17274">and recall the architecture depicted in</st> *<st c="17315">Figure
    2</st>**<st c="17323">.1</st>*<st c="17325">. It used two services: CloudFront
    and S3\.</st> <st c="17368">CloudWatch basic monitoring metrics are free.</st>
    <st c="17414">Recreate this architecture in AWS</st> <st c="17448">Pricing Calculator.</st>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17467">Add S3 to your estimate.</st> <st c="17493">Specify the region
    you plan to use; pricing can differ per region.</st> <st c="17560">To estimate
    S3 costs, you will need to know how much storage in GB/month you will use, the
    amount and type of</st> <st c="17670">requests, and</st> **<st c="17684">data
    transfer out</st>** <st c="17701">(</st>**<st c="17703">DTO</st>**<st c="17706">)</st>
    <st c="17709">in GB/month.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17721">To store the three website files from</st> [<st c="17760">Chapter
    2</st>](B22051_02.xhtml#_idTextAnchor032) <st c="17769">–</st> `<st c="17772">index.html</st>`<st
    c="17782">,</st> `<st c="17784">index.css</st>`<st c="17793">, and</st> `<st c="17799">avatar.png</st>`<st
    c="17809">, you need 100 KB.</st> <st c="17828">100 KB is 0.0001 GB.</st> <st
    c="17849">If you have altered the files, check the size of</st> <st c="17898">your
    files.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17909">CloudFront will mostly</st> <st c="17933">make GET requests to
    your S3\.</st> <st c="17963">Since</st> [*<st c="17969">Chapter 2</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="17978">'s project is a website for displaying your CV, you do not expect more
    than 500 monthly views.</st> <st c="18074">Thus, you anticipate 500 GET requests</st>
    <st c="18112">to S3.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17909">CloudFront 主要</st> <st c="17933">会向你的 S3 发出 GET 请求。</st> <st c="17963">由于</st>
    [*<st c="17969">第二章</st>*](B22051_02.xhtml#_idTextAnchor032)<st c="17978">的项目是一个展示个人简历的网站，你预计每月不会超过
    500 次浏览。</st> <st c="18074">因此，你预计会有 500 次 GET 请求</st> <st c="18112">到 S3。</st>
- en: <st c="18118">Regarding DTO, select CloudFront as the destination.</st> <st
    c="18172">This makes</st> <st c="18183">DTO free.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18118">关于 DTO，选择 CloudFront 作为目标。</st> <st c="18172">这使得</st> <st c="18183">DTO
    免费。</st>
- en: <st c="18192">Next, add the second service, CloudFront.</st> <st c="18235">In
    the region where your users will access your site, enter your expected number
    of requests per month and the amount of DTO.</st> <st c="18361">For the number
    of requests, use the same logic as for S3 requests.</st> <st c="18428">Since this
    is a simple website to display your CV, you estimate 500 monthly requests.</st>
    <st c="18514">For the DTO, calculate 500 times the size of your files.</st> <st
    c="18571">With the website files totaling approximately 100 KB, this amounts to
    roughly</st> <st c="18649">0.05 GB.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18192">接下来，添加第二个服务，CloudFront。</st> <st c="18235">在用户访问你的网站的区域，输入每月预期的请求次数和
    DTO 的数量。</st> <st c="18361">请求次数的计算方法与 S3 请求相同。</st> <st c="18428">由于这是一个简单的展示个人简历的网站，你估计每月会有
    500 次请求。</st> <st c="18514">对于 DTO，计算 500 次请求乘以你文件的大小。</st> <st c="18571">网站文件总大小大约为
    100 KB，折算下来大约是</st> <st c="18649">0.05 GB。</st>
- en: <st c="18657">Although both services have a free tier, it is not automatically
    accounted for by the calculator.</st> <st c="18756">For most AWS services, you
    need to determine what the free tier offers and subtract it from your values before
    entering them into the calculator.</st> <st c="18902">For example, the S3 free
    tier includes 20,000 GET requests.</st> <st c="18962">If you forecasted 40,000
    GET requests for your project, you should only enter 20,000 GET requests into</st>
    <st c="19065">the calculator.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18657">尽管这两个服务都有免费层，但计算器不会自动考虑这一点。</st> <st c="18756">对于大多数 AWS 服务，你需要确定免费层提供的内容，并在输入到计算器之前从你的值中减去这些内容。</st>
    <st c="18902">例如，S3 的免费层包括 20,000 次 GET 请求。</st> <st c="18962">如果你预计项目需要 40,000
    次 GET 请求，你应该只输入 20,000 次 GET 请求到</st> <st c="19065">计算器中。</st>
- en: <st c="19080">For</st> [*<st c="19085">Chapter 2</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="19094">, the final calculator output is $0, regardless of whether you subtract
    the free tier, as shown in</st> *<st c="19193">Figure 9</st>**<st c="19201">.7</st>*<st
    c="19203">. This is because the project's scale is</st> <st c="19244">very low.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19080">对于</st> [*<st c="19085">第二章</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="19094">，最终的计算器输出是 0 美元，无论你是否减去免费层，如</st> *<st c="19193">图 9</st>**<st c="19201">.7</st>*<st
    c="19203">所示。这是因为项目的规模</st> <st c="19244">非常小。</st>
- en: '![Figure 9.7 – AWS Pricing Calculator for Chapter 2’s project](img/B22051_09_7.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 第二章项目的 AWS 定价计算器](img/B22051_09_7.jpg)'
- en: <st c="19779">Figure 9.7 – AWS Pricing Calculator for Chapter 2’s project</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19779">图 9.7 – 第二章项目的 AWS 定价计算器</st>
- en: <st c="19838">One of the non-functional requirements for this chapter was low-cost.</st>
    <st c="19909">You certainly accomplished that.</st> <st c="19942">Play with the
    calculator to understand how costs rise for a static website with thousands or
    millions</st> <st c="20044">of users.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19838">本章的非功能需求之一是低成本。</st> <st c="19909">你无疑达成了这个目标。</st> <st c="19942">使用计算器来了解当静态网站拥有数千或数百万用户时，成本如何上升。</st>
- en: <st c="20053">Pricing the solution from Chapter 6</st>
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="20053">定价第六章中的解决方案</st>
- en: <st c="20089">Revisit</st> [*<st c="20098">Chapter 6</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="20107">. Use</st> <st c="20113">AWS Pricing Calculator to calculate the pricing
    for this solution.</st> <st c="20180">Start with the static website hosting part
    of the architecture, which includes the S3 buckets and the</st> <st c="20282">CloudFront
    distribution.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20089">请回顾</st> [*<st c="20098">第六章</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="20107">。使用</st> <st c="20113">AWS 定价计算器计算此解决方案的定价。</st> <st c="20180">从架构的静态网站托管部分开始，包括
    S3 存储桶和</st> <st c="20282">CloudFront 分发。</st>
- en: <st c="20306">Add S3\.</st> <st c="20315">The website files from</st> [*<st
    c="20338">Chapter 6</st>*](B22051_06.xhtml#_idTextAnchor151)<st c="20347">,</st>
    `<st c="20349">index.html</st>` <st c="20359">and</st> `<st c="20364">index.css</st>`<st
    c="20373">, are each less than 10 KB in size.</st> <st c="20409">Since these files
    are stored in two different S3 buckets, the total storage required is 20 KB, or
    0.00002 GB.</st> <st c="20519">This is an event website, and you expect around
    100,000 views per month.</st> <st c="20592">In terms of S3, this translates to</st>
    <st c="20627">100,000 requests.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20306">添加 S3\。</st> <st c="20315">来自</st> [*<st c="20338">第6章</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="20347">的网站文件</st>，`<st c="20349">index.html</st>` <st c="20359">和</st> `<st
    c="20364">index.css</st>`<st c="20373">，每个文件大小都小于 10 KB。</st> <st c="20409">由于这些文件存储在两个不同的
    S3 存储桶中，因此总存储需求为 20 KB，或 0.00002 GB。</st> <st c="20519">这是一个事件网站，预计每月约 100,000
    次访问。</st> <st c="20592">就 S3 而言，这意味着</st> <st c="20627">100,000 次请求。</st>
- en: <st c="20644">For CloudFront, it’s the same 100,000 requests and it totals 2
    GB DTO.</st> <st c="20716">However, CloudFront also uses Lambda@Edge.</st> <st
    c="20759">Add Lambda.</st> <st c="20771">This service allows to include or exclude
    the free tier.</st> <st c="20828">Add the same 100,000 requests using the minimum
    memory possible, 128 MB, and assume a 10 ms</st> <st c="20920">execution time.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20644">对于 CloudFront，它也有 100,000 次请求，总计 2 GB DTO。</st> <st c="20716">然而，CloudFront
    还使用 Lambda@Edge。</st> <st c="20759">添加 Lambda。</st> <st c="20771">此服务允许包含或排除免费层。</st>
    <st c="20828">添加相同的 100,000 次请求，使用最小内存，128 MB，并假设执行时间为 10 毫秒。</st>
- en: <st c="20935">Now, you have completed the static website architecture.</st>
    <st c="20993">Your calculator should output roughly 0.40 USD a month.</st> <st
    c="21049">However, if you drill down to each service cost, you will find that
    most of the cost comes from CloudFront.</st> <st c="21157">The calculator does
    not include this service’s free tier, as it does with Lambda.</st> <st c="21239">The
    CloudFront free tier includes</st> <st c="21273">the following:</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20935">现在，您已经完成了静态网站架构。</st> <st c="20993">您的计算器应该输出大约每月 0.40 美元。</st>
    <st c="21049">然而，如果您深入了解每项服务的费用，您会发现大部分费用来自 CloudFront。</st> <st c="21157">计算器没有包括此服务的免费层，就像它没有包括
    Lambda 一样。</st> <st c="21239">CloudFront 的免费层包括</st> <st c="21273">以下内容：</st>
- en: <st c="21287">1 TB of DTO to the internet</st> <st c="21316">per month</st>
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="21287">每月 1 TB DTO 到互联网</st> <st c="21316">每月</st>
- en: <st c="21325">10,000,000 HTTP or HTTPS requests</st> <st c="21360">per month</st>
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="21325">每月 10,000,000 次 HTTP 或 HTTPS 请求</st> <st c="21360">每月</st>
- en: <st c="21369">Therefore, this architecture at the scale of our solution is almost
    free.</st> <st c="21444">You will be charged less than 0.10 USD</st> <st c="21483">a
    month.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21369">因此，这个架构在我们解决方案的规模下几乎是免费的。</st> <st c="21444">您的费用将低于每月 0.10 美元。</st>
    <st c="21483">每月。</st>
- en: '<st c="21491">Start another calculator or add in the same calculator the CI/CD
    components from</st> [*<st c="21573">Chapter 6</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="21582">: CodeBuild, CodePipeline, and</st> <st c="21614">Amazon Translate.</st>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21491">启动另一个计算器，或在相同计算器中添加来自</st> [*<st c="21573">第6章</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="21582">的 CI/CD 组件：</st> CodeBuild、CodePipeline 和<st c="21614">Amazon Translate。</st>
- en: '<st c="21631">Add CodeCommit.</st> <st c="21648">It will ask for the number
    of active users.</st> <st c="21692">In your case, there is just one active</st>
    <st c="21731">user: you.</st>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21631">添加 CodeCommit。</st> <st c="21648">它将询问活跃用户的数量。</st> <st c="21692">在您的情况下，只有一个活跃</st>
    <st c="21731">用户：您。</st>
- en: <st c="21741">Add CodeBuild.</st> <st c="21757">In</st> [*<st c="21760">Chapter
    6</st>*](B22051_06.xhtml#_idTextAnchor151)<st c="21769">, we described the use
    of 2 GB on-demand Lambdas for compute.</st> <st c="21831">Assume you make at least
    one change a week; that runs for</st> <st c="21889">10 seconds.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21741">添加 CodeBuild。</st> <st c="21757">在</st> [*<st c="21760">第6章</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="21769">中，我们描述了使用 2 GB 按需 Lambda 进行计算。</st> <st c="21831">假设您每周至少进行一次更改；每次更改的运行时间为</st>
    <st c="21889">10 秒。</st>
- en: <st c="21900">Add CodePipeline.</st> <st c="21919">You have a single pipeline
    for</st> <st c="21950">this project.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21900">添加 CodePipeline。</st> <st c="21919">您为</st> <st c="21950">此项目拥有一个单独的管道。</st>
- en: <st c="21963">Lastly, add Amazon</st> <st c="21983">Translate.</st> <st c="21994">Select</st>
    `<st c="22045">index.html</st>` <st c="22055">has over 2,400 characters.</st>
    <st c="22083">If you translate it four times a month to a single language, that
    is almost 10,000 characters translated</st> <st c="22188">per month.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21963">最后，添加 Amazon</st> <st c="21983">Translate。</st> <st c="21994">选择</st>
    `<st c="22045">index.html</st>` <st c="22055">有超过 2400 个字符。</st> <st c="22083">如果你每月将其翻译四次为一种语言，那么每月大约翻译
    10,000 个字符。</st> <st c="22188">每月。</st>
- en: '*<st c="22198">Figure 9</st>**<st c="22207">.8</st>* <st c="22209">shows the
    calculator for the project.</st> <st c="22248">S3 and CloudFront costs will be
    waived by the services’ free tiers.</st> <st c="22316">Amazon Translate does not
    have a free tier for real-time document translation, and the AWS Lambda calculator
    already includes the free tier.</st> <st c="22457">The result is 0.22 USD per
    month, or 2.64 USD</st> <st c="22503">per year.</st>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="22198">图 9</st>**<st c="22207">.8</st>* <st c="22209">显示了该项目的计算器。</st>
    <st c="22248">S3 和 CloudFront 的费用将由服务的免费套餐免除。</st> <st c="22316">Amazon Translate
    没有实时文档翻译的免费套餐，而 AWS Lambda 计算器已经包括了免费套餐。</st> <st c="22457">结果是每月 0.22 美元，或每年
    2.64 美元。</st> <st c="22503">每年。</st>'
- en: '![Figure 9.8 – AWS Pricing Calculator for Chapter 6’s project](img/B22051_09_8.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 第 6 章项目的 AWS 定价计算器](img/B22051_09_8.jpg)'
- en: <st c="23267">Figure 9.8 – AWS Pricing Calculator for Chapter 6’s project</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23267">图 9.8 – 第 6 章项目的 AWS 定价计算器</st>
- en: <st c="23326">Change these estimates to represent the project you built.</st>
    <st c="23386">For example, if you are translating your website to multiple languages,
    you will need to alter Amazon Translate’s costs.</st> <st c="23507">If</st> <st
    c="23509">you are making changes more often than once a week, you will need to
    alter the number of CodeBuild executions.</st> <st c="23621">If you are using
    any components not on AWS, for example, GitHub, as in</st> [*<st c="23692">Chapter
    6</st>*](B22051_06.xhtml#_idTextAnchor151)<st c="23701">, add those costs to the</st>
    <st c="23726">final calculator.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23326">将这些估算更改为与你构建的项目相符。</st> <st c="23386">例如，如果你正在将网站翻译成多种语言，你需要调整
    Amazon Translate 的费用。</st> <st c="23507">如果</st> <st c="23509">你每周更改的次数超过一次，则需要调整
    CodeBuild 的执行次数。</st> <st c="23621">如果你使用的是 AWS 以外的任何组件，例如 GitHub，如在</st> [*<st
    c="23692">第 6 章</st>*](B22051_06.xhtml#_idTextAnchor151)<st c="23701">所示，</st>
    <st c="23726">则需要将这些费用添加到最终计算器中。</st>
- en: <st c="23743">Important note</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23743">重要提示</st>
- en: <st c="23758">You can export estimates in JSON, PDF, or CSV format.</st> <st
    c="23813">You can also share a link to your calculator.</st> <st c="23859">This
    is helpful for sharing your architecture with colleagues</st> <st c="23921">and
    customers.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23758">你可以将估算结果导出为 JSON、PDF 或 CSV 格式。</st> <st c="23813">你还可以分享计算器的链接。</st>
    <st c="23859">这对于与同事</st> <st c="23921">和客户共享架构非常有帮助。</st>
- en: <st c="23935">When you are making pricing estimates, you will have to guess
    capacity and certain characteristics of the project, such as the expected number
    of requests.</st> <st c="24092">Most of the time, you do not need to estimate
    single- or double-digit units.</st> <st c="24169">Use round numbers for easier
    calculations; for example, instead of 87 KB, use 100 KB.</st> <st c="24255">Instead
    of 1 request per second, that is, 86,000 requests per day, use 100,000 requests
    per day.</st> <st c="24352">This is informally called back-of-the-envelope calculations,
    and it is widely applied when</st> <st c="24443">building architectures.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23935">当你进行定价估算时，你需要估算项目的容量和某些特征，例如预期的请求数量。</st> <st c="24092">大多数时候，你不需要估算个位数或两位数的单位。</st>
    <st c="24169">使用整数进行计算更为简单；例如，不要使用 87 KB，而使用 100 KB。</st> <st c="24255">不要使用每秒
    1 次请求（即每天 86,000 次请求），而使用每天 100,000 次请求。</st> <st c="24352">这种方法通常被称为“简易估算”，并且在</st>
    <st c="24443">构建架构时广泛应用。</st>
- en: <st c="24466">Practice makes</st> <st c="24482">perfect; practice by creating
    calculators for all the projects in</st> <st c="24548">this book.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24466">实践成就</st> <st c="24482">完美；通过为本书中的所有项目创建计算器来进行练习。</st> <st c="24548">本书中的所有项目。</st>
- en: <st c="24558">AWS re:Post</st>
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="24558">AWS re:Post</st>
- en: <st c="24570">Wouldn’t it be great if</st> <st c="24595">you could ask other
    experts questions about errors when you have development or architecture doubts?</st>
    <st c="24696">You can.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24570">如果你能在遇到开发或架构疑问时，向其他专家提问关于错误的问题，那该多好呢？</st> <st c="24595">你可以。</st>
- en: <st c="24704">AWS re:Post is a repository of official Knowledge Center articles,
    videos, and other resources created by AWS to help customers better understand
    and use AWS services.</st> <st c="24873">But re:Post also allows you to post your</st>
    <st c="24914">own questions.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24704">AWS re:Post 是一个由 AWS 创建的官方知识中心文章、视频及其他资源的知识库，旨在帮助客户更好地理解和使用 AWS
    服务。</st> <st c="24873">但是，re:Post 也允许你发布自己的问题。</st>
- en: <st c="24928">Visit</st> [<st c="24935">https://repost.aws</st>](https://repost.aws)
    <st c="24953">and navigate to a topic of your choice.</st> <st c="24994">You will
    see hundreds of questions, many answered by AWS professionals or other users.</st>
    <st c="25081">This is a great resource for getting assistance, collaborating with
    others, and making your knowledge and work visible in the</st> <st c="25207">wider
    industry.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24928">访问</st> [<st c="24935">https://repost.aws</st>](https://repost.aws)
    <st c="24953">并导航至你选择的主题。</st> <st c="24994">你将看到成百上千的问题，许多问题已由 AWS 专业人员或其他用户回答。</st>
    <st c="25081">这是一个获取帮助、与他人合作以及让你的知识和工作在更广泛的行业中可见的绝佳资源。</st>
- en: <st c="25222">However, re:Post, as mentioned, is not just a technical forum.</st>
    <st c="25286">AWS re:Post includes the official AWS Knowledge Center,</st> [<st
    c="25342">https://repost.aws/knowledge-center</st>](https://repost.aws/knowledge-center)<st
    c="25377">, which is a repository covering the most frequent questions and requests
    that AWS receives from customers.</st> <st c="25485">In short, questions that
    are asked often are identified by AWS and become articles.</st> <st c="25569">Many,
    if not all, errors you will face while building your applications will have a
    prescriptive</st> <st c="25666">solution here.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25222">然而，如前所述，re:Post 不仅仅是一个技术论坛。</st> <st c="25286">AWS re:Post 包括官方的
    AWS 知识中心，</st> [<st c="25342">https://repost.aws/knowledge-center</st>](https://repost.aws/knowledge-center)<st
    c="25377">，这是一个涵盖 AWS 客户最常见问题和请求的知识库。</st> <st c="25485">简而言之，AWS 会识别出经常被问到的问题，并将其转化为文章。</st>
    <st c="25569">你在构建应用程序时遇到的许多错误，如果不是全部，都会在这里有针对性的解决方案。</st> <st c="25666">解决方案在这里。</st>
- en: <st c="25680">Some useful examples are</st> <st c="25706">as follows:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25680">一些有用的示例如下：</st>
- en: '*<st c="25717">How do I create and activate a new AWS</st>* *<st c="25757">account?</st>*<st
    c="25765">:</st> [<st c="25768">https://repost.aws/knowledge-center/create-and-activate-aws-account</st>](https://repost.aws/knowledge-center/create-and-activate-aws-account)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="25717">如何创建并激活一个新的 AWS</st>* *<st c="25757">账户？</st>*<st c="25765">:</st>
    [<st c="25768">https://repost.aws/knowledge-center/create-and-activate-aws-account</st>](https://repost.aws/knowledge-center/create-and-activate-aws-account)'
- en: '*<st c="25835">How do I troubleshoot HTTP 403 errors from API</st>* *<st c="25883">Gateway?</st>*<st
    c="25891">:</st> [<st c="25894">https://repost.aws/knowledge-center/api-gateway-troubleshoot-403-forbidden</st>](https://repost.aws/knowledge-center/api-gateway-troubleshoot-403-forbidden)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="25835">如何排查 API</st>* *<st c="25883">网关的 HTTP 403 错误？</st>*<st c="25891">:</st>
    [<st c="25894">https://repost.aws/knowledge-center/api-gateway-troubleshoot-403-forbidden</st>](https://repost.aws/knowledge-center/api-gateway-troubleshoot-403-forbidden)'
- en: '*<st c="25968">How do I terminate active resources that I no longer need on
    my AWS</st>* *<st c="26037">account?</st>*<st c="26045">:</st> [<st c="26048">https://repost.aws/knowledge-center/terminate-resources-account-closure</st>](https://repost.aws/knowledge-center/terminate-resources-account-closure)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="25968">如何终止我在 AWS</st>* *<st c="26037">账户上不再需要的活动资源？</st>*<st c="26045">:</st>
    [<st c="26048">https://repost.aws/knowledge-center/terminate-resources-account-closure</st>](https://repost.aws/knowledge-center/terminate-resources-account-closure)'
- en: <st c="26119">Lastly, people who don’t work for AWS can also share prescriptive
    guidance with others.</st> <st c="26208">They can do this through community articles,</st>
    [<st c="26253">https://repost.aws/articles</st>](https://repost.aws/articles)<st
    c="26280">. As an exercise, write an</st> <st c="26307">article about something
    you have learned while reading this book and share it as a community article</st>
    <st c="26408">on re:Post.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26119">最后，不仅仅是 AWS 的员工，其他人也可以与他人分享具有指导性的建议。</st> <st c="26208">他们可以通过社区文章来分享这些建议，</st>
    [<st c="26253">https://repost.aws/articles</st>](https://repost.aws/articles)<st
    c="26280">。作为练习，写一篇你在阅读本书时学到的内容，并将其作为社区文章分享</st> <st c="26307">到 re:Post 上。</st>
- en: <st c="26419">AWS documentation, Solutions Library and Prescriptive Guidance</st>
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="26419">AWS 文档、解决方案库和指导性建议</st>
- en: <st c="26482">More important than knowing everything is knowing where to find
    information about something if you</st> <st c="26582">need it.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26482">了解一切的知识可能不如知道在哪里可以找到所需信息重要。</st> <st c="26582">如果你需要某些信息，这一点尤其重要。</st>
- en: '<st c="26590">Throughout this book, you have already visited multiple pages
    of the AWS documentation, AWS Architecture Center, and others.</st> <st c="26716">It
    is important to know of the various options you have at your disposal.</st> <st
    c="26790">In this section, you will delve into three specific ones: AWS documentation,
    AWS Solutions Library, and AWS</st> <st c="26898">Prescriptive Guidance.</st>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26590">在本书中，你已经访问过 AWS 文档、AWS 架构中心等多个页面。</st> <st c="26716">了解可用的多种选项非常重要。</st>
    <st c="26790">在本节中，你将深入了解三种具体选项：AWS 文档、AWS 解决方案库和 AWS</st> <st c="26898">指导性建议。</st>
- en: <st c="26920">AWS documentation</st>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="26920">AWS 文档</st>
- en: <st c="26938">Every service</st> <st c="26953">on AWS has extensive official
    documentation.</st> <st c="26998">On top of that, there is unofficial documentation
    such as</st> [<st c="27056">medium.com</st>](http://medium.com)<st c="27066">,
    community articles, this very book,</st> <st c="27104">and others.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26938">AWS 上的每项服务</st> <st c="26953">都有详尽的官方文档。</st> <st c="26998">除此之外，还有如</st>
    [<st c="27056">medium.com</st>](http://medium.com)<st c="27066">、社区文章、本书本身</st>
    <st c="27104">等非官方文档。</st>
- en: <st c="27115">Throughout this book, you have visited several documentation pages.</st>
    <st c="27184">Nonetheless, it is worth highlighting a couple of</st> <st c="27234">documentation
    pages:</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27115">在本书中，你已经访问过多个文档页面。</st> <st c="27184">然而，值得特别强调的是几个</st> <st c="27234">文档页面：</st>
- en: <st c="27254">AWS</st> <st c="27259">FAQs:</st> [<st c="27265">https://aws.amazon.com/faqs/</st>](https://aws.amazon.com/faqs/)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27254">AWS</st> <st c="27259">常见问题：</st> [<st c="27265">https://aws.amazon.com/faqs/</st>](https://aws.amazon.com/faqs/)
- en: <st c="27293">AWS technical</st> <st c="27308">documentation:</st> [<st c="27323">https://docs.aws.amazon.com/</st>](https://docs.aws.amazon.com/)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27293">AWS 技术</st> <st c="27308">文档：</st> [<st c="27323">https://docs.aws.amazon.com/</st>](https://docs.aws.amazon.com/)
- en: <st c="27351">AWS</st> <st c="27356">blog:</st> [<st c="27362">https://aws.amazon.com/blogs/</st>](https://aws.amazon.com/blogs/)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27351">AWS</st> <st c="27356">博客：</st> [<st c="27362">https://aws.amazon.com/blogs/</st>](https://aws.amazon.com/blogs/)
- en: <st c="27391">What’s New with</st> <st c="27408">AWS?:</st> [<st c="27414">https://aws.amazon.com/new/</st>](https://aws.amazon.com/new/)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27391">AWS 新动态：</st> <st c="27408">AWS?</st>：[<st c="27414">https://aws.amazon.com/new/</st>](https://aws.amazon.com/new/)
- en: <st c="27441">AWS Skill</st> <st c="27452">Builder:</st> [<st c="27461">https://explore.skillbuilder.aws/learn</st>](https://explore.skillbuilder.aws/learn)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27441">AWS 技能</st> <st c="27452">Builder：</st> [<st c="27461">https://explore.skillbuilder.aws/learn</st>](https://explore.skillbuilder.aws/learn)
- en: <st c="27499">Familiarize yourself with these resources, so you know where to
    find them when you</st> <st c="27583">need them.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27499">熟悉这些资源，以便在需要时能够找到它们。</st>
- en: <st c="27593">AWS Solutions Library</st>
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27593">AWS 解决方案库</st>
- en: <st c="27615">The AWS Architecture</st> <st c="27636">Center was your initial
    search engine in every chapter after defining your project requirements.</st>
    <st c="27734">This is a one-stop destination that allows you to browse, search
    for, and even request reference architectures, architecture patterns, best practices,
    and prescriptive guidance all in</st> <st c="27918">one location.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27615">AWS 架构中心</st> <st c="27636">是你在每章定义项目需求后最初的搜索引擎。</st> <st c="27734">这是一个一站式的目的地，允许你浏览、搜索，甚至请求参考架构、架构模式、最佳实践和指导性建议，所有这些都可以在</st>
    <st c="27918">一个地方找到。</st>
- en: <st c="27931">But if you are searching for something pre-built, tested and vetted
    by others, and accompanied by an IaC template such as CloudFormation, AWS Solutions
    Library (</st>[<st c="28093">https://aws.amazon.com/solutions/</st>](https://aws.amazon.com/solutions/)<st
    c="28127">) is the place to go.</st> <st c="28150">The library also includes AWS</st>
    <st c="28180">Partner solutions.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27931">但是，如果你正在寻找经过他人预构建、测试和验证的内容，并且附带如 CloudFormation 这样的 IaC 模板，AWS
    解决方案库（</st>[<st c="28093">https://aws.amazon.com/solutions/</st>](https://aws.amazon.com/solutions/)<st
    c="28127">）是理想之地。</st> <st c="28150">该库还包括 AWS</st> <st c="28180">合作伙伴解决方案。</st>
- en: <st c="28198">Let’s add a new requirement to the project from</st> [*<st c="28247">Chapter
    6</st>*](B22051_06.xhtml#_idTextAnchor151)<st c="28256">. The company requires
    extensive load testing before deploying the event website to make sure it can
    handle</st> <st c="28364">heavy loads.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28198">让我们为项目添加一个新需求，来自于</st> [*<st c="28247">第六章</st>*](B22051_06.xhtml#_idTextAnchor151)<st
    c="28256">。公司要求在部署活动网站之前进行广泛的负载测试，以确保它能够承受</st> <st c="28364">高负载。</st>
- en: <st c="28376">If you are not an expert in load testing, search for and navigate
    to</st> *<st c="28446">Distributed Load Testing on AWS</st>* <st c="28477">in
    Solutions</st> <st c="28491">Library:</st> [<st c="28500">https://aws.amazon.com/solutions/implementations/distributed-load-testing-on-aws/?did=sl_card&trk=sl_card</st>](https://aws.amazon.com/solutions/implementations/distributed-load-testing-on-aws/?did=sl_card&trk=sl_card)<st
    c="28605">.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是负载测试方面的专家，请搜索并导航到 *<st c="28446">AWS上的分布式负载测试</st>* 在解决方案库中：[<st c="28500">https://aws.amazon.com/solutions/implementations/distributed-load-testing-on-aws/?did=sl_card&trk=sl_card</st>](https://aws.amazon.com/solutions/implementations/distributed-load-testing-on-aws/?did=sl_card&trk=sl_card)。
- en: <st c="28606">This is a typical Solutions Library documentation.</st> <st c="28658">Within
    it, you will find</st> <st c="28683">three components:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的解决方案库文档。在其中，您将找到三个组件：
- en: <st c="28700">An</st> <st c="28704">architecture diagram</st>
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个架构图
- en: <st c="28724">An</st> <st c="28728">implementation guide</st>
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实施指南
- en: <st c="28748">A one-click</st> <st c="28761">deployment option</st>
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一键部署选项
- en: <st c="28778">This architecture diagram, as shown in</st> *<st c="28818">Figure
    9</st>**<st c="28826">.9</st>*<st c="28828">, depicts the flow in a</st> <st c="28852">step-by-step
    manner.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 *<st c="28818">图9</st>**<st c="28826">.9</st>* 所示，此架构图以逐步方式展示了流程。
- en: '![Figure 9.9 – Distributed load testing architecture](img/B22051_09_9.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 分布式负载测试架构](img/B22051_09_9.jpg)'
- en: <st c="29127">Figure 9.9 – Distributed load testing architecture</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 分布式负载测试架构
- en: <st c="29177">The implementation guide,</st> [<st c="29204">https://docs.aws.amazon.com/solutions/latest/distributed-load-testing-on-aws/solution-overview.html</st>](https://docs.aws.amazon.com/solutions/latest/distributed-load-testing-on-aws/solution-overview.html)<st
    c="29303">, has in-depth documentation of how the solution works, including monitoring
    and troubleshooting information.</st> <st c="29413">Notice also how the implementation
    guide has a dedicated section for</st> <st c="29482">estimated costs.</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实施指南，[<st c="29204">https://docs.aws.amazon.com/solutions/latest/distributed-load-testing-on-aws/solution-overview.html</st>](https://docs.aws.amazon.com/solutions/latest/distributed-load-testing-on-aws/solution-overview.html)，深入介绍了该解决方案的工作原理，包括监控和故障排除信息。另请注意，实施指南中有专门的部分用于估算成本。
- en: <st c="29498">Lastly, it includes</st> <st c="29519">a one-click deployment
    option,</st> **<st c="29550">Launch in the AWS Console</st>**<st c="29575">, which
    allows you to deploy it and immediately test your event website without having
    to architect another project</st> <st c="29691">from scratch.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它包括一个一键部署选项，**<st c="29550">在AWS控制台中启动</st>**，您可以使用它进行部署并立即测试您的事件网站，而无需从头开始设计另一个项目。
- en: <st c="29704">AWS Prescriptive Guidance</st>
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS规范指导
- en: '**<st c="29730">AWS Prescriptive Guidance</st>** <st c="29756">(</st>**<st
    c="29758">APG</st>**<st c="29761">) (</st>[<st c="29765">https://aws.amazon.com/prescriptive-guidance/</st>](https://aws.amazon.com/prescriptive-guidance/)<st
    c="29811">) can also be found on the AWS Architecture</st> <st c="29855">Center,
    but it is focused on time-tested strategies, guides, and patterns to help accelerate
    your cloud migration, modernization, and</st> <st c="29990">optimization projects.</st>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="29730">AWS规范指导</st>** (<st c="29758">APG</st>)（[<st c="29765">https://aws.amazon.com/prescriptive-guidance/</st>](https://aws.amazon.com/prescriptive-guidance/)）也可以在AWS架构中心找到，但它侧重于经过时间验证的策略、指南和模式，以帮助加速您的云迁移、现代化和优化项目。'
- en: <st c="30012">Unlike Solutions Library, not all are practical, nor accompanied
    by architecture diagrams</st> <st c="30103">and code.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与解决方案库不同，并非所有内容都具有实用性，也没有架构图和代码。
- en: <st c="30112">There are three types</st> <st c="30135">of resources:</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的资源：
- en: '**<st c="30148">Strategies</st>**<st c="30159">: Business</st> <st c="30171">perspectives,
    methodologies, and frameworks for cloud migration and modernization, for CxOs
    and</st> <st c="30267">senior managers.</st>'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30148">策略</st>**：云迁移和现代化的商业视角、方法论和框架，适用于CxO和高级经理。'
- en: '**<st c="30283">Guides</st>**<st c="30290">: Guidance for planning and implementing
    strategies, with a focus on best practices and tools, for architects, managers,
    and</st> <st c="30416">technical leads.</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30283">指南</st>**<st c="30290">：为架构师、经理和</st> <st c="30416">技术负责人提供的规划和实施策略的指导，重点介绍最佳实践和工具。</st>'
- en: '**<st c="30432">Patterns</st>**<st c="30441">: Steps, architectures, tools,
    and code for implementing common migration, optimization, and</st> <st c="30534">modernization
    scenarios, for builders and other</st> <st c="30583">hands-on users.</st>'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30432">模式</st>**<st c="30441">：用于实现常见迁移、优化和现代化场景的步骤、架构、工具和代码，适用于构建者和其他</st>
    <st c="30583">实践用户。</st>'
- en: <st c="30598">When you are starting out, patterns are the most useful.</st>
    <st c="30656">They detail popular</st> <st c="30676">service configurations.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30598">当你刚开始时，模式是最有用的。</st> <st c="30656">它们详细描述了流行的</st> <st c="30676">服务配置。</st>
- en: <st c="30699">You have deployed several CloudFront distributions while building
    the projects in this book.</st> <st c="30793">Are they all as secure as they can
    be?</st> <st c="30832">Do you know how to verify this?</st> <st c="30864">You
    can easily automate these</st> <st c="30893">types of verifications with the APG
    pattern</st> *<st c="30938">Check an Amazon CloudFront distribution for access
    logging, HTTPS, and TLS version</st>*<st c="31020">:</st> [<st c="31023">https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/check-an-amazon-cloudfront-distribution-for-access-logging-https-and-tls-version.html?did=pg_card&trk=pg_card</st>](https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/check-an-amazon-cloudfront-distribution-for-access-logging-https-and-tls-version.html?did=pg_card&trk=pg_card)<st
    c="31198">. It uses Lambda to check new and modified CloudFront distributions
    for TLS 1.2, HTTPS, and</st> <st c="31290">logging configurations.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30699">在构建本书中的项目时，你已经部署了几个 CloudFront 分发。</st> <st c="30793">它们都像你期望的那样安全吗？</st>
    <st c="30832">你知道如何验证吗？</st> <st c="30864">你可以轻松地使用 APG 模式自动化这些</st> <st c="30893">验证类型</st>
    *<st c="30938">检查 Amazon CloudFront 分发的访问日志、HTTPS 和 TLS 版本</st>*<st c="31020">：</st>
    [<st c="31023">https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/check-an-amazon-cloudfront-distribution-for-access-logging-https-and-tls-version.html?did=pg_card&trk=pg_card</st>](https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/check-an-amazon-cloudfront-distribution-for-access-logging-https-and-tls-version.html?did=pg_card&trk=pg_card)<st
    c="31198">。它使用 Lambda 检查新的和已修改的 CloudFront 分发，确保其配置了 TLS 1.2、HTTPS 和</st> <st
    c="31290">日志记录配置。</st>
- en: <st c="31313">Summary</st>
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="31313">总结</st>
- en: <st c="31321">In this chapter, you learned about other AWS services that you
    could have used to build the different sample projects throughout the book.</st>
    <st c="31461">This has shown how architecture is about trade-offs more than it
    is about building the</st> <st c="31548">perfect solution.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31321">在本章中，你了解了其他可以用于构建本书中不同示例项目的 AWS 服务。</st> <st c="31461">这表明架构更多的是关于权衡取舍，而非构建</st>
    <st c="31548">完美的解决方案。</st>
- en: <st c="31565">You also learned about AWS Pricing Calculator and how it can help
    you estimate costs before building your projects.</st> <st c="31682">You created
    pricing estimates for the projects from</st> *<st c="31734">Chapters 2</st>* <st
    c="31744">and</st> *<st c="31749">6</st>*<st c="31750">.</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31565">你还了解了 AWS 定价计算器，以及它如何帮助你在构建项目之前估算成本。</st> <st c="31682">你为来自</st>
    *<st c="31734">第二章</st>* <st c="31744">和</st> *<st c="31749">第六章</st>*<st c="31750">的项目创建了定价估算。</st>
- en: <st c="31751">Lastly, you explored many of AWS’ learning resources.</st> <st
    c="31806">Some of them may have been new to you, such as AWS re:Posts, while others
    are part of the now-familiar AWS Architecture Center, the one-stop shop for prescriptive
    guidance</st> <st c="31978">and resources.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31751">最后，你探索了许多 AWS 的学习资源。</st> <st c="31806">其中一些可能是你之前没有接触过的，比如 AWS
    re:Posts，而另一些则属于现在已经熟悉的 AWS 架构中心，这是一个提供指导</st> <st c="31978">和资源的一站式平台。</st>
- en: <st c="31992">There are too many AWS services, architectural patterns, and techniques
    to cover in a single book.</st> <st c="32092">But if you know the fundamentals,
    that should raise the level of everything</st> <st c="32168">you do.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31992">AWS 服务、架构模式和技术种类繁多，无法在一本书中覆盖所有内容。</st> <st c="32092">但如果你了解基础知识，那应该能提升你所做的一切的水平。</st>
    <st c="32168">你所做的每件事都会有所提高。</st>
- en: <st c="32175">Congratulations on finishing this extensive journey, packed with
    hands-on projects and cloud knowledge.</st> <st c="32280">Although this is the
    end of the book, it is just the beginning of your AWS</st> <st c="32355">cloud
    journey.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32175">恭喜你完成了这段充满实践项目和云计算知识的广泛旅程。</st> <st c="32280">虽然这本书已经结束，但这只是你AWS</st>
    <st c="32355">云计算旅程的开始。</st>
