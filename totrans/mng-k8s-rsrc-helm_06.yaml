- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Understanding Helm Templates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Helm 模板
- en: One of the fundamental features of Helm is to create and maintain the Kubernetes
    resources that comprise an application. Helm accomplishes this with a concept
    called **templates**. Templates represent the core component comprising Helm charts,
    as they are used to configure Kubernetes resources based on a given set of **values**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 的一个基本功能是创建和维护构成应用程序的 Kubernetes 资源。Helm 通过一个名为 **模板** 的概念来实现这一点。模板代表 Helm
    Charts 的核心组件，因为它们用于根据给定的一组 **值** 配置 Kubernetes 资源。
- en: In [*Chapter 4*](B17979_04.xhtml#_idTextAnchor139), *Scaffolding a New Helm
    Chart*, you scaffolded a new Helm chart by using the `helm create` command, which
    created basic templates under the chart’s `templates/` folder. In this chapter,
    we will dive deep into the world of Helm templates, and at the end, we will revisit
    the scaffolded templates to make improvements and deploy the Guestbook frontend.
    By the end of the chapter, your Helm chart will be able to deploy the full Guestbook
    architecture—from the Redis backend added in [*Chapter 5*](B17979_05.xhtml#_idTextAnchor154),
    *Helm Dependency Management*, to the frontend that we will add later in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B17979_04.xhtml#_idTextAnchor139)中，*搭建新的 Helm Chart*，你使用 `helm create`
    命令搭建了一个新的 Helm Chart，并在 chart 的 `templates/` 文件夹下创建了基本模板。在本章中，我们将深入探讨 Helm 模板的世界，最后我们将回顾搭建的模板，进行改进并部署
    Guestbook 前端。在本章结束时，你的 Helm Chart 将能够部署完整的 Guestbook 架构——从 [*第 5 章*](B17979_05.xhtml#_idTextAnchor154)
    中添加的 Redis 后端，到本章稍后将添加的前端。
- en: 'Here are the main topics for this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的主要内容：
- en: Helm template basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 模板基础
- en: Template values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板值
- en: Built-in objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置对象
- en: Helm template functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 模板函数
- en: Helm template control structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 模板控制结构
- en: Generating release notes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成发布说明
- en: Helm template variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 模板变量
- en: Helm template validation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 模板验证
- en: Enabling code reuse with named templates and library charts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过命名模板和库 chart 启用代码重用
- en: Creating **custom resource definitions** (**CRDs**)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 **自定义资源定义** (**CRDs**)
- en: Post rendering
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后渲染
- en: Updating and deploying the Guestbook chart
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新并部署 Guestbook Chart
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following tools:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下工具：
- en: minikube
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube
- en: kubectl
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Helm
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: Git
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: 'We will use minikube to explore several examples throughout this chapter, so
    feel free to start your minikube environment by running the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 minikube 在本章中探索多个示例，所以请随时通过运行以下命令启动你的 minikube 环境：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once minikube has started, create a new namespace for this chapter, like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 minikube 启动完成，为本章创建一个新的命名空间，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have not already cloned the example Git repository in previous chapters,
    do so by running the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前面的章节中尚未克隆示例 Git 仓库，请通过运行以下命令进行克隆：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that your environment is set up, let’s explore this chapter’s first topic—Helm
    templating.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的环境已经设置好了，让我们来探索本章的第一个主题——Helm 模板。
- en: Helm template basics
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 模板基础
- en: 'Helm templates are used to dynamically generate Kubernetes `helm create` command,
    which generated a set of starter templates. In the Git repository cloned previously,
    these templates are located at `chapter6/guestbook/templates/`. Here’s a short
    snippet of the `deployment.yaml` Helm template, located within the `chapter6/guestbook/templates/deployment.yaml`
    file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 模板用于动态生成 Kubernetes `helm create` 命令，生成一组启动模板。在之前克隆的 Git 仓库中，这些模板位于 `chapter6/guestbook/templates/`。以下是
    `chapter6/guestbook/templates/deployment.yaml` 文件中 Helm 模板的一个简短片段：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may find the syntax from the preceding code snippet to be odd, as it resembles
    a YAML file, but it contains characters that are invalid per the YAML specification.
    To understand this syntax, we must first talk about **Go**. Go is a programming
    language developed by Google in 2009\. It is the programming language used by
    Kubernetes, Helm, and many other tools in the container community. A core component
    of the Go programming language is **templates**, which are used to generate files
    of many different formats. Helm’s template engine is built off of Go and can be
    thought of as a superset of Go templates. Go templates provide the fundamental
    syntax and control, while Helm adds extra capabilities to enhance the template
    engine’s capabilities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得前面的代码片段的语法有些奇怪，因为它类似于 YAML 文件，但包含了一些在 YAML 规范中无效的字符。要理解这种语法，我们首先需要谈谈**Go**。Go
    是 Google 在 2009 年开发的一种编程语言。它是 Kubernetes、Helm 以及许多容器社区工具使用的编程语言。Go 编程语言的核心组件之一是**模板**，它们用于生成多种不同格式的文件。Helm
    的模板引擎基于 Go 构建，可以看作是 Go 模板的超集。Go 模板提供了基本的语法和控制结构，而 Helm 添加了额外的功能，以增强模板引擎的能力。
- en: Helm templates contain various different actions, or strings, that begin with
    two opening curly braces ( `{{` ) and end with accompanying two closing curly
    braces ( `}}` ). Actions mark locations where data processing occurs or where
    control structures such as conditionals and loops are implemented. You can see
    different actions located throughout the code snippets and in other Helm chart
    templates under the `templates/` directory. While actions appear in local template
    files, they are processed and removed during processing, such as during an installation
    or upgrade, to produce a valid Kubernetes YAML resource.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 模板包含各种不同的操作或字符串，它们以两个左花括号（ `{{` ）开始，并以两个右花括号（ `}}` ）结束。操作标记了数据处理发生的地方或控制结构（如条件语句和循环）被实现的位置。你可以在代码片段中以及
    `templates/` 目录下的其他 Helm chart 模板中看到不同的操作。尽管操作出现在本地模板文件中，但它们在处理过程中会被处理并移除，例如在安装或升级过程中，以生成有效的
    Kubernetes YAML 资源。
- en: There are many different components such as objects, functions, and control
    structures that you can leverage to write actions throughout your Helm chart templates.
    We will explore each of these throughout this chapter. Let’s begin by discussing
    how the `values` component can be used within chart templates.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Helm chart 模板中，你可以利用许多不同的组件，如对象、函数和控制结构来编写操作。我们将在本章中探讨这些内容。让我们从讨论如何在 chart
    模板中使用 `values` 组件开始。
- en: Template values
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板值
- en: In previous chapters, we described values as parameters that are used to configure
    a Helm chart. Now, we will gain an understanding of how values are integrated
    into chart templates to dynamically generate Kubernetes resources.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们将值描述为用于配置 Helm chart 的参数。现在，我们将理解值是如何集成到 chart 模板中的，从而动态生成 Kubernetes
    资源。
- en: 'Here is a basic `ConfigMap` template from the Git repository at `chapter6/examples/values-example/templates/configmap.yaml`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 Git 仓库的基本 `ConfigMap` 模板，位于 `chapter6/examples/values-example/templates/configmap.yaml`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last two lines of this template contain `{{ .Values.chapterNumber }}` and
    `{{ .Values.chapterName }}` actions, which are used as placeholders for the `chapterNumber`
    and `chapterName` values. This allows the ConfigMap to be parameterized based
    on the default chart values and the values the user provides during installation
    or upgrade.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板的最后两行包含 `{{ .Values.chapterNumber }}` 和 `{{ .Values.chapterName }}` 操作，这些操作用作
    `chapterNumber` 和 `chapterName` 值的占位符。这样，ConfigMap 就可以基于默认 chart 值和用户在安装或升级过程中提供的值进行参数化。
- en: 'Let’s take a look at the default chart values located at `chapter6/examples/values-example/values.yaml`.
    You can see these here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下位于 `chapter6/examples/values-example/values.yaml` 的默认 chart 值。你可以在这里看到这些内容：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Given this `Values` file, we would expect the default ConfigMap to be rendered
    like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个 `Values` 文件，我们预计默认的 ConfigMap 会像这样渲染：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You could verify this on your own by running the `helm install` command, as
    we have demonstrated in previous chapters, but it may be more convenient to leverage
    a new command, `helm template`, which is used to render template resources locally,
    but not install them to the Kubernetes cluster. The `helm template` command, as
    shown here, has the same syntax as `helm install`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `helm install` 命令来自行验证这一点，正如我们在前几章中所演示的那样，但使用一个新的命令 `helm template`
    可能更为方便，该命令用于本地渲染模板资源，而不是将它们安装到 Kubernetes 集群中。`helm template` 命令，如下所示，语法与 `helm
    install` 相同：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s use this command to render the `values-example` chart templates locally.
    Proceed as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用此命令在本地渲染 `values-example` 图表模板。请按以下步骤操作：
- en: 'Run the `helm template` command, pointing the `<CHART_NAME>` parameter to the
    `values-example` folder, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `helm template` 命令，指向 `<CHART_NAME>` 参数为 `values-example` 文件夹，如下所示：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see the ConfigMap rendered as shown previously, with the actions
    replaced by `chapterNumber` and `chapterName` values, as illustrated in the following
    code snippet:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到配置图表按之前的方式渲染，其中的操作被 `chapterNumber` 和 `chapterName` 的值替换，示例如下代码片段所示：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unless we intend to install resources to the minikube environment, we will use
    the `helm template` command to quickly demonstrate templating constructs throughout
    this chapter. That way, you won’t have to worry about cleaning up after each exercise.
    We will return to using `helm install` at the end of this chapter when we install
    an updated version of the Guestbook Helm chart.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们打算将资源安装到 minikube 环境中，否则我们将在本章中使用 `helm template` 命令快速演示模板构造。这样，你就不必担心每个练习后的清理工作。我们将在本章末尾安装更新版的
    Guestbook Helm 图表时，返回使用 `helm install`。
- en: As you saw in the preceding example, templates that reference values refer to
    a construct called `.Values` each time an action is being used as a placeholder
    for chart values. `.Values` is one of several built-in objects that are at your
    disposal as a Helm chart developer. Let’s explore these built-in objects next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的示例中所看到的，每次使用占位符表示图表值时，模板都会引用一个名为 `.Values` 的构造。`.Values` 是你作为 Helm 图表开发者可以使用的几个内建对象之一。接下来我们将进一步探索这些内建对象。
- en: Built-in objects
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内建对象
- en: Built-in objects are essential building blocks that you can use to write your
    own Helm charts. As mentioned previously, they provide access to chart values
    by using the `.Values` object, but there are many more objects to explore that
    provide access to additional information and features.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 内建对象是你编写 Helm 图表时可以使用的基本构建块。如前所述，它们通过 `.Values` 对象提供对图表值的访问，但还有许多其他对象可供探索，它们提供对额外信息和功能的访问。
- en: 'The following table lists these built-in objects:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了这些内建对象：
- en: '| **Object** | **Definition** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **定义** |'
- en: '| `.Values` | Used to access values in the `values.yaml` file or values that
    were provided using the `--values` and `--set` flags |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `.Values` | 用于访问 `values.yaml` 文件中的值或通过 `--values` 和 `--set` 标志提供的值 |'
- en: '| `.Release` | Used to access metadata about the Helm release, such as its
    name, namespace, and revision number |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `.Release` | 用于访问 Helm 发布的元数据，如名称、命名空间和修订号 |'
- en: '| `.Chart` | Used to access metadata about the Helm chart, such as its name
    and version |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `.Chart` | 用于访问有关 Helm 图表的元数据，如其名称和版本 |'
- en: '| `.Template` | Used to access metadata about chart templates, such as their
    filename and path |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `.Template` | 用于访问有关图表模板的元数据，如文件名和路径 |'
- en: '| `.Capabilities` | Used to access information about the Kubernetes cluster
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `.Capabilities` | 用于访问有关 Kubernetes 集群的信息 |'
- en: '| `.Files` | Used to access arbitrary files within a Helm chart directory |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `.Files` | 用于访问 Helm 图表目录中的任意文件 |'
- en: '| `.` | The root object |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 根对象 |'
- en: Table 6.1 – Built-in Helm objects
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – 内建 Helm 对象
- en: 'Each object contains fields and functions that are accessible by using dot
    notation. Dot notation is used to access an object’s properties. For example,
    imagine the following `Values` file is provided:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象包含可以通过点表示法访问的字段和函数。点表示法用于访问对象的属性。例如，假设提供了以下 `Values` 文件：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `.Values` object would now contain the following properties:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Values` 对象现在将包含以下属性：'
- en: '`.Values.books.harryPotter` (list of strings)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Values.books.harryPotter`（字符串列表）'
- en: .`Values.books.lotr` (list of strings)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Values.books.lotr`（字符串列表）'
- en: In Helm (and Go templates), a dot (`.`) is also used to represent object scope.
    The dot represents global scope, from which all objects are accessible. A dot
    followed by an object name limits the scope of that object. For example, the `.Values`
    scope limits visibility to the chart’s values, and the `.Release` scope limits
    visibility to the release’s metadata. Scopes play a significant role in loops
    and control structures, which we will explore later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Helm（以及 Go 模板）中，点（`.`）也用于表示对象作用域。点表示全局作用域，从中可以访问所有对象。点后跟对象名称会限制该对象的作用域。例如，`.Values`
    作用域限制了对图表值的可见性，而 `.Release` 作用域限制了对发布元数据的可见性。作用域在循环和控制结构中起着重要作用，接下来我们将在本章中详细探讨。
- en: While the `.Values` object is the most common object that you will use throughout
    Helm chart development, there are other built-in objects that we will discuss.
    We’ll start with the `.Release` object next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `.Values` 对象是你在 Helm chart 开发过程中最常用的对象，但还有其他一些内置对象我们将会讨论。接下来我们将从 `.Release`
    对象开始。
- en: The .Release object
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`.Release` 对象'
- en: The `.Release` object is used to retrieve metadata about the Helm release being
    installed. Two common attributes that are used from within the `.Release` object
    are `.Release.Name` and `.Release.Namespace`, which allow chart developers to
    substitute the release name and namespace in their chart templates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Release` 对象用于检索关于正在安装的 Helm release 的元数据。从 `.Release` 对象中常用的两个属性是 `.Release.Name`
    和 `.Release.Namespace`，它们允许 chart 开发者在 chart 模板中替换 release 的名称和命名空间。'
- en: 'Consider the following example template, located at `chapter6/examples/release-example/templates/configmap.yaml`
    in the Git repository:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例模板，该模板位于 Git 仓库中的 `chapter6/examples/release-example/templates/configmap.yaml`：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the template, we are setting the ConfigMap’s name to the name of the Helm
    release, and we are setting the namespace property to the release namespace.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们将 ConfigMap 的名称设置为 Helm release 的名称，并将命名空间属性设置为 release 的命名空间。
- en: 'When running the Helm `install`, `upgrade`, or `template` commands, you can
    see the `{{ .Release.Name }}` and `{{ .Release.Namespace }}` actions get replaced
    with their actual values, as illustrated in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 Helm 的 `install`、`upgrade` 或 `template` 命令时，你可以看到 `{{ .Release.Name }}`
    和 `{{ .Release.Namespace }}` 操作被替换为它们的实际值，如下代码片段所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the ConfigMap name has been generated as `release-example`,
    and the `namespace` property has been generated as `default` (if we had selected
    a different namespace using the `-n` flag, that value would have been reflected
    instead). By using the `.Release` object, we were able to leverage the name and
    namespace that were provided when invoking Helm rather than creating repetitive
    values in `values.yaml` for the name and namespace.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，ConfigMap 的名称被生成为 `release-example`，`namespace` 属性被生成为 `default`（如果我们使用
    `-n` 标志选择了其他命名空间，则该值会被相应反映）。通过使用 `.Release` 对象，我们能够利用在调用 Helm 时提供的名称和命名空间，而不是在
    `values.yaml` 中为名称和命名空间创建重复的值。
- en: 'There are several more objects besides `name` and `namespace` under `.Release`
    that you can leverage in your chart templates. The following table lists each
    `.Release` object, with the descriptions quoted from the Helm documentation at
    [https://helm.sh/docs/chart_template_guide/builtin_objects/#helm](https://helm.sh/docs/chart_template_guide/builtin_objects/#helm):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.Release` 下，除了 `name` 和 `namespace` 之外，还有多个其他对象可以在你的 chart 模板中使用。下表列出了每个
    `.Release` 对象，描述内容引用自 Helm 文档：[https://helm.sh/docs/chart_template_guide/builtin_objects/#helm](https://helm.sh/docs/chart_template_guide/builtin_objects/#helm)：
- en: '| **Object** | **Description** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **描述** |'
- en: '| `.Release.Name` | The release name |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `.Release.Name` | release 名称 |'
- en: '| `.Release.Namespace` | The namespace to be released into |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `.Release.Namespace` | 要发布到的命名空间 |'
- en: '| `.Release.IsUpgrade` | This is set to `true` if the current operation is
    an upgrade or rollback |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `.Release.IsUpgrade` | 如果当前操作是升级或回滚，则设置为 `true` |'
- en: '| `.Release.IsInstall` | This is set to `true` if the current operation is
    an install |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `.Release.IsInstall` | 如果当前操作是安装，则设置为 `true` |'
- en: '| `.Release.Revision` | The revision number for this release |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `.Release.Revision` | 此 release 的修订号 |'
- en: '| `.Release.Service` | The service that is rendering the template (this is
    always equivalent to the `"Helm"` string) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `.Release.Service` | 渲染模板的服务（这个值始终等于字符串 `"Helm"`） |'
- en: Table 6.2 – .Release objects
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 – `.Release` 对象
- en: We will explore the `.Chart` object next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将探索 `.Chart` 对象。
- en: The .Chart object
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`.Chart` 对象'
- en: 'The `.Chart` object is used to retrieve metadata from the `Chart.yaml` file
    of the Helm chart that is being installed. It is commonly used for labeling chart
    resources with the chart name and version. Let’s take a look at the example template
    at `chapter6/examples/chart-example/templates/configmap.yaml` from the Git repository.
    You can view this here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Chart` 对象用于从正在安装的 Helm chart 的 `Chart.yaml` 文件中检索元数据。它通常用于为 chart 资源标注 chart
    名称和版本。我们来看一下 Git 仓库中 `chapter6/examples/chart-example/templates/configmap.yaml`
    的示例模板。你可以在这里查看：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see in the `metadata.labels` section, the template is using the
    `{{ .Chart.Name }}`, `{{ .Chart.Version }}`, and `{{ .Chart.AppVersion }}` actions,
    which retrieve the `name`, `version`, and `appVersion` fields from the `Chart.yaml`
    file. Here, you can see the `Chart.yaml` file for this example chart:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `metadata.labels` 部分看到的，模板正在使用 `{{ .Chart.Name }}`、`{{ .Chart.Version }}`
    和 `{{ .Chart.AppVersion }}` 动作，这些动作从 `Chart.yaml` 文件中检索 `name`、`version` 和 `appVersion`
    字段。在这里，你可以看到这个示例图表的 `Chart.yaml` 文件：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we use the `helm template` command to render this template locally, we
    see the fields from the `Chart.yaml` file are used in the ConfigMap resource,
    as illustrated here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `helm template` 命令在本地渲染此模板时，我们看到来自 `Chart.yaml` 文件的字段被用在了 ConfigMap 资源中，如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `.Chart` object can reference any field from the `Chart.yaml` file. For
    a full list of `Chart.yaml` fields, please refer to [*Chapter 4*](B17979_04.xhtml#_idTextAnchor139),
    *Scaffolding a New Helm Chart*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Chart` 对象可以引用 `Chart.yaml` 文件中的任何字段。有关 `Chart.yaml` 字段的完整列表，请参考 [*第4章*](B17979_04.xhtml#_idTextAnchor139)，*创建新的
    Helm 图表*。'
- en: The .Template object
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .Template 对象
- en: 'The `.Template` object is used to retrieve metadata about the current template
    that is being rendered. It is the simplest built-in object (besides `.Values`)
    and contains only two objects underneath, as outlined here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Template` 对象用于检索当前正在渲染的模板的元数据。它是最简单的内置对象（除了 `.Values`），并且只有两个下级对象，如下所示：'
- en: '`.Template.Name`—The file path to the template being rendered (such as `mychart/templates/mytemplate.yaml`)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Template.Name`—正在渲染的模板的文件路径（例如 `mychart/templates/mytemplate.yaml`）'
- en: '`.Template.BasePath`—The path leading up to the `templates` directory (such
    as `mychart/templates`)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Template.BasePath`—指向 `templates` 目录的路径（例如 `mychart/templates`）'
- en: In our experience, the `.Template` object is rarely used, but it can be useful
    if you need to reference the template’s file path in your chart.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，`.Template` 对象很少使用，但如果您需要在图表中引用模板的文件路径，它会很有用。
- en: The .Capabilities object
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .Capabilities 对象
- en: The `.Capabilities` object is used for getting information about the target
    Kubernetes cluster. There are many objects underneath `.Capabilities`, but the
    most common are `.Capabilities.APIVersions.Has` and `.Capabilities.KubeVersion`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Capabilities` 对象用于获取关于目标 Kubernetes 集群的信息。`.Capabilities` 下有许多对象，但最常见的是 `.Capabilities.APIVersions.Has`
    和 `.Capabilities.KubeVersion`。'
- en: 'The `.Capabilities.APIVersions.Has` object is a function that returns a Boolean
    based on whether or not the Kubernetes cluster has a given **application programming
    interface** (**API**) version. Here is an example invocation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Capabilities.APIVersions.Has` 对象是一个函数，根据 Kubernetes 集群是否具有给定的 **应用程序编程接口**（**API**）版本返回布尔值。以下是一个示例调用：'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This action would return `true` or `false` based on whether or not the cluster
    contains the "`batch/v1`” API version. `.Capabilities.APIVersions.Has` is most
    commonly used in conditional logic to install a resource only if the cluster contains
    a particular API version. Conditional logic will be covered in the *Helm template
    control structures* section later in this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作将根据集群是否包含 "`batch/v1`” API 版本返回 `true` 或 `false`。`.Capabilities.APIVersions.Has`
    最常用于条件逻辑中，只在集群包含特定 API 版本时才安装资源。条件逻辑将在本章后续的 *Helm 模板控制结构* 部分中介绍。
- en: 'The other commonly used `.Capabilities` object is `.Capabilities.KubeVersion`.
    Use this property to retrieve the version of the Kubernetes cluster. For example,
    the following action would return a `v1.21.2` string (or similar, based on the
    version of Kubernetes being used):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的 `.Capabilities` 对象是 `.Capabilities.KubeVersion`。使用该属性可以检索 Kubernetes
    集群的版本。例如，以下操作将返回一个 `v1.21.2` 字符串（或类似的字符串，具体取决于使用的 Kubernetes 版本）：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Other `.Capabilities` objects, such as `.Capabilities.KubeVersion.Major` and
    `.Capabilities.KubeVersion.Minor`, allow chart developers to get only the major
    or minor version of the Kubernetes cluster (as opposed to the whole `.Capabilities`,
    visit the Helm documentation at [https://helm.sh/docs/chart_template_guide/builtin_objects/#helm](https://helm.sh/docs/chart_template_guide/builtin_objects/#helm).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 `.Capabilities` 对象，如 `.Capabilities.KubeVersion.Major` 和 `.Capabilities.KubeVersion.Minor`，允许图表开发人员仅获取
    Kubernetes 集群的主版本或次版本（与整个 `.Capabilities` 相对，访问 Helm 文档 [https://helm.sh/docs/chart_template_guide/builtin_objects/#helm](https://helm.sh/docs/chart_template_guide/builtin_objects/#helm)）。
- en: The .Files object
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .Files 对象
- en: Occasionally, you may encounter use cases where you need to include contents
    from files in your chart templates. You can include file contents by using the
    `.Files` object. This is used primarily with ConfigMap and Secret resources, where
    the `data` section is provided or supplemented by a separate configuration file.
    Note that files must be located within the Helm chart directory (but outside of
    the `templates/` folder) in order to be referenced with `.Files`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到需要在图表模板中包含文件内容的情况。你可以使用 `.Files` 对象来包含文件内容。这主要用于 ConfigMap 和 Secret
    资源，其中 `data` 部分由单独的配置文件提供或补充。请注意，文件必须位于 Helm 图表目录内（但在 `templates/` 文件夹外），才能通过
    `.Files` 引用。
- en: 'The `.Files` object contains several other objects underneath. The most basic
    is `.Files.Get`, which is a function that retrieves the contents of the provided
    filename. Imagine a ConfigMap template such as this (this template is also located
    in the Git repository at `chapter6/examples/files-example/get`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Files` 对象下包含了几个其他的对象。最基础的是 `.Files.Get`，这是一个函数，用于检索提供的文件名的内容。假设有如下的 ConfigMap
    模板（此模板也位于 Git 仓库中的 `chapter6/examples/files-example/get` 目录下）：'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `.Files.Get` function in the example is being used to get the contents
    of the `files/config.properties` file, which is a path relative to the Helm chart
    root. This file is located at `chapter6/examples/files-example/get/files/config.properties`
    in the Git repository and contains the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的 `.Files.Get` 函数用于获取 `files/config.properties` 文件的内容，这个路径是相对于 Helm 图表根目录的。该文件位于
    Git 仓库中的 `chapter6/examples/files-example/get/files/config.properties`，其内容如下：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, when we render this template, we will see the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们渲染此模板时，我们将看到以下输出：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Three other important objects under `.Files` are `.Files.Glob`, `.Files.AsConfig`,
    and `.Files.AsSecret`. First, `.Files.Glob`, is a function that returns a list
    of file objects that match a provided `*`). For example, the `files/*` glob would
    match each file under the `files/` folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Files` 下有三个其他重要的对象：`.Files.Glob`、`.Files.AsConfig` 和 `.Files.AsSecret`。首先，`.Files.Glob`
    是一个函数，返回与提供的 `*` 模式匹配的文件对象列表。例如，`files/*` 通配符将匹配 `files/` 文件夹下的每个文件。'
- en: The `.Files.Glob` object is commonly used with `.Files.AsConfig` and `.Files.AsSecrets`
    objects. `.Files.AsConfig` is a function used to return the file as a YAML dictionary,
    where the key is the name of the file and the value is the file contents. It is
    called `AsConfig` because it is useful when formatting different ConfigMap data
    entries. The `.Files.AsSecrets` function is similar, but in addition to returning
    files as a YAML map, `AsSecrets` also Base64-encodes the contents of the file—this
    is useful for creating data for Kubernetes Secrets. Do keep in mind that sensitive
    files should never be checked into a Git repository in plaintext (though we have
    one such file in the example Git repository for demonstration purposes).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Files.Glob` 对象通常与 `.Files.AsConfig` 和 `.Files.AsSecrets` 对象一起使用。`.Files.AsConfig`
    是一个函数，用于将文件作为 YAML 字典返回，其中键是文件名，值是文件内容。它被称为 `AsConfig`，因为它在格式化不同的 ConfigMap 数据条目时非常有用。`.Files.AsSecrets`
    函数类似，但除了将文件作为 YAML 映射返回，`AsSecrets` 还会对文件内容进行 Base64 编码——这对于创建 Kubernetes Secrets
    数据非常有用。请记住，敏感文件绝不应该以明文形式被提交到 Git 仓库中（尽管我们在示例 Git 仓库中有一个这样的文件用于演示目的）。'
- en: 'The following templates demonstrate the usage of these objects and are also
    located in the Git repository at `chapter6/examples/files-example/glob`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模板展示了这些对象的用法，并且也位于 Git 仓库中的 `chapter6/examples/files-example/glob` 目录下：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `files` folder contains the following files:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`files` 文件夹包含以下文件：'
- en: '`chapter.properties`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter.properties`'
- en: '`secret.properties`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret.properties`'
- en: 'When this template is rendered, the contents of both files are generated as
    YAML maps under the ConfigMap’s `data`, as illustrated in the following code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染此模板时，两个文件的内容会作为 YAML 映射生成在 ConfigMap 的 `data` 下，如以下代码片段所示：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous example, you likely noticed the usage of `| indent 2`. This
    represents a pipeline and function that will be explored thoroughly in the next
    section, *Helm template functions*. For now, all you need to worry about is that
    the output is indented by two spaces in order to produce properly formatted ConfigMap
    and Secret resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可能注意到了 `| indent 2` 的使用。这代表着一个管道操作和一个函数，我们将在下一节中详细探讨，*Helm 模板函数*。现在，你只需关心输出会被缩进两个空格，以便生成格式正确的
    ConfigMap 和 Secret 资源。
- en: Other `.Files` objects are `.Files.GetBytes`, which returns a file as an array
    of bytes, and `.Files.Lines`, which is used to iterate over each line of a file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其他`.Files`对象包括`.Files.GetBytes`，它返回一个字节数组形式的文件，以及`.Files.Lines`，用于逐行遍历文件。
- en: Helm template functions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm模板函数
- en: One of the common traits of any templating language is the ability to transform
    data. Thus far, when referring to `.Values` or any of the other built-in objects
    within Helm, we have only made reference to the resource as-is, without any form
    of data manipulation. Where Helm really begins to shine and show its true power
    is its ability to perform complex data processing within templates through the
    use of template functions and pipelines.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任何模板语言的一个常见特征是能够转换数据。到目前为止，当我们提到`.Values`或Helm中的其他内置对象时，我们只是引用了资源本身，并未进行任何数据处理。Helm真正展现其强大之处的是其通过模板函数和管道在模板中执行复杂数据处理的能力。
- en: Since Helm uses Go as the basis for its own templating language, it inherits
    the capabilities provided by functions. A Go template function is comparable to
    any other function that you may have interacted with in another programming language.
    Functions contain logic designed to consume certain inputs and provide an output
    based on the inputs that were provided.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Helm使用Go作为其模板语言的基础，它继承了Go提供的函数能力。Go模板函数类似于你在其他编程语言中可能接触过的任何函数。函数包含逻辑，旨在消耗特定的输入并根据提供的输入提供输出。
- en: 'When using Go templates, functions make use of the following syntax:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go模板时，函数使用以下语法：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A function that is commonly used within Helm charts is the `quote` function,
    as it encompasses quotation marks surrounding an input string. Take the following
    ConfigMap located in `chapter6/examples/functions-example/templates/configmap.yaml`
    from the Git repository:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Helm图表中常用的一个函数是`quote`函数，它会将输入字符串用引号括起来。以下是来自Git存储库中`chapter6/examples/functions-example/templates/configmap.yaml`的ConfigMap示例：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `path` property in the preceding ConfigMap represents a filesystem location
    that is consumed by an application, as shown in the following code snippet. The
    value referenced by this property is located in the `values.yaml` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述ConfigMap中的`path`属性表示应用程序使用的文件系统位置，如以下代码片段所示。该属性引用的值位于`values.yaml`文件中：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resulting template would be rendered as follows (some fields were omitted
    for brevity):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染后的模板如下所示（为了简洁，省略了一些字段）：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A potential downstream issue within a consuming application could result if
    it did not contain logic to appropriately manage whether spaces could be present
    within the input.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消费应用程序未包含适当的逻辑来管理输入中是否可能存在空格，那么可能会导致潜在的下游问题。
- en: 'To avoid these potential issues, add the `quote` function that will surround
    the property with quotation marks, as shown in the following code snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些潜在问题，添加`quote`函数，它会将属性用引号括起来，如以下代码片段所示：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the `helm template` command to render the chart locally to see the function
    in action, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`helm template`命令在本地渲染图表以查看其功能，方法如下：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result upon template rendering produces a`/var/props/../configs/my app/config.cfg`
    string that not only enhances the readability of the property but protects any
    consuming application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 模板渲染后的结果是`/var/props/../configs/my app/config.cfg`字符串，这不仅增强了属性的可读性，还保护了任何使用该属性的应用程序。
- en: '`quote` is just one of over 60 functions included within Helm. While some of
    the functions are sourced from Go templates, the majority are part of the `Sprig`
    template library. The `Sprig` library includes functions to implement more complex
    capabilities within charts, such as the ability to perform mathematical formulas,
    conversion operations, and the management of data structures, including lists
    and dictionaries.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote`是Helm中超过60个函数之一。虽然一些函数来自Go模板，但大多数函数是`Sprig`模板库的一部分。`Sprig`库包含用于在图表中实现更复杂功能的函数，如执行数学公式、转换操作以及管理数据结构，包括列表和字典。'
- en: The functions inherited from Go and Sprig can be found in the Go documentation
    at [https://pkg.go.dev/text/template#hdr-Functions](https://pkg.go.dev/text/template#hdr-Functions)
    and in the Sprig template library at [http://masterminds.github.io/sprig/](http://masterminds.github.io/sprig/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从Go和Sprig继承的函数可以在Go文档中找到，链接为[https://pkg.go.dev/text/template#hdr-Functions](https://pkg.go.dev/text/template#hdr-Functions)，在Sprig模板库中也可以找到，链接为[http://masterminds.github.io/sprig/](http://masterminds.github.io/sprig/)。
- en: One of the more recent functions added to Helm is the ability to query resources
    from a running Kubernetes environment through the use of the `lookup` function.
    Helm chart developers can make reference to a single resource or references of
    a given type across a namespace or cluster and inject the results within their
    templates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Helm中最近添加的一个功能是通过使用`lookup`函数从正在运行的Kubernetes环境中查询资源。Helm chart开发人员可以引用单个资源或跨命名空间或集群的指定类型的引用，并将结果注入到他们的模板中。
- en: 'The `lookup` function takes the following form:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup`函数的形式如下：'
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For example, to query a ConfigMap called `props` in the `chapter6` namespace,
    use the following function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查询`chapter6`命名空间中的名为`props`的ConfigMap，请使用以下函数：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result from the `lookup` function is a dictionary that can be further navigated
    as necessary to retrieve individual properties on the returned resource.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup`函数的结果是一个字典，可以根据需要进一步导航，以检索返回资源上的单个属性。'
- en: 'So, to extract a property defined on a ConfigMap called `author` containing
    the default name of the author for all WordPress posts, the following code would
    be added within a Helm template:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，要提取一个名为`author`的ConfigMap中的属性，该属性包含所有WordPress文章的默认作者姓名，可以在Helm模板中添加以下代码：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we are first retrieving a dictionary of values containing the
    `props` ConfigMap and then navigating to the `author` property on the ConfigMap
    data structure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先检索包含`props` ConfigMap的值的字典，然后导航到ConfigMap数据结构中的`author`属性。
- en: 'You are not limited to querying for a single resource when using the `lookup`
    function and can instead search for all resources of a given type within a single
    namespace or within all namespaces. This can be accomplished by substituting empty
    quotes for either the namespace and/or resource name, as shown in the following
    template:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lookup`函数时，你不仅限于查询单个资源，还可以在单一命名空间内或所有命名空间内搜索所有给定类型的资源。这可以通过将命名空间和/或资源名称替换为空引号来实现，如下模板所示：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: One final important note when working with the `lookup` function is that it
    can only be used when resources are being deployed to a Kubernetes cluster, such
    as through the `helm install` and `helm upgrade` commands. This is due to the
    requirement that there be an active connection to a Kubernetes cluster as part
    of the execution process being performed. For commands such as `helm template`,
    where templates are being rendered locally and there is no interaction with a
    Kubernetes cluster, the `lookup` function will not return any meaningful results.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lookup`函数时的一个重要注意事项是，它仅在资源被部署到Kubernetes集群时才能使用，例如通过`helm install`和`helm
    upgrade`命令。这是因为执行过程中需要与Kubernetes集群保持活动连接。对于像`helm template`这样的命令，模板是在本地渲染的，并且没有与Kubernetes集群的交互，因此`lookup`函数不会返回任何有意义的结果。
- en: Helm functions and their ability to influence Helm template commands are just
    the first steps toward adding more dynamic mechanisms to chart templates. Multiple
    template commands can also be chained together to perform a series of complex
    actions through the use of **pipelines**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Helm函数及其对Helm模板命令的影响只是向chart模板中添加更多动态机制的第一步。多个模板命令也可以通过使用**管道**（pipelines）连接在一起，执行一系列复杂的操作。
- en: 'Pipelines are a borrowed concept from Unix where the result from one command
    is fed in as the input of another command. You can see an illustration of this
    in the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一个借用自Unix的概念，其中一个命令的结果作为另一个命令的输入。你可以在以下代码片段中看到这个概念的示例：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Commands are separated by the pipe (`|`) character (hence the name *pipeline*)
    where in this case, the output of the contents of the `file.txt` file is provided
    as an input to the `grep` command. `grep` processes the input, filters out any
    presence of the word `helm` from the input, and provides it as an output that
    is printed to the screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 命令通过管道（`|`）字符分隔（因此得名*管道*），在这种情况下，`file.txt`文件的内容作为输入提供给`grep`命令。`grep`处理输入，过滤掉输入中任何`helm`的出现，并将其作为输出打印到屏幕上。
- en: 'Pipelines can be applied to Helm in a similar fashion. Let’s return to the
    prior example where we introduced the `quote` function to add quotation marks
    to a filesystem path. Instead of using the `value` property as a function argument,
    inverse the order to pipe the contents of the value into the `quote` function,
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 管道可以以类似的方式应用于 Helm。让我们回到之前的示例，我们介绍了 `quote` 函数来为文件系统路径添加引号。与其直接将 `value` 属性作为函数参数，不如反过来将值的内容通过管道传入
    `quote` 函数，如下所示：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The end result remains the same whether calling the function directly or using
    the pipeline approach. However, in practice, you will find that pipelines are
    the preferred option over directly invoking functions, given the extensibility
    of chinning template commands.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是直接调用函数还是使用管道方法，最终结果是相同的。然而，在实际应用中，你会发现，管道通常是首选的方式，因为它具有扩展性，可以连锁模板命令。
- en: 'You may also have noticed that the `fs.path` value includes a reference to
    a relative path (denoted by `..`). This may be difficult for some to read and
    or understand if they are unfamiliar with the syntax. Fortunately, there is a
    function included in the Sprig library called `clean` that can resolve the path
    fully and remove any relative paths automatically. This function can be added
    to the existing pipeline, as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，`fs.path` 值中包括对相对路径（由 `..` 表示）的引用。如果某些人不熟悉语法，这可能会让他们感到难以阅读或理解。幸运的是，Sprig
    库中包含了一个名为 `clean` 的函数，可以完全解析路径并自动去除任何相对路径。可以将此函数添加到现有管道中，如下所示：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the ConfigMap within the `functions-example` Helm chart from the Git repository,
    apply the preceding changes and then use the `helm template` command to see the
    changes in action. Upon instantiation, the rendered template would look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 仓库中的 `functions-example` Helm chart 的 ConfigMap 中，应用之前的更改，然后使用 `helm template`
    命令查看更改后的效果。实例化后，渲染的模板将如下所示：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Functions and pipelines are both extensively used within Helm, and it is important
    that as a chart developer, you have insights into the available options in order
    to design charts effectively. Let’s take a moment to look at a few more commonly
    used functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和管道在 Helm 中被广泛使用，作为一个 chart 开发者，了解可用选项非常重要，这样才能有效地设计 charts。让我们花点时间来看一些更常用的函数。
- en: '`Values` files, as we have seen, contain a dictionary of key/value pairs. While
    individual key/value pairs can be referenced, there are plenty of situations where
    a deeply nested structure would want to be injected instead. Fortunately, several
    Helm functions can help in this situation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Values` 文件包含一个键/值对的字典。虽然可以引用单个的键/值对，但在许多情况下，可能需要注入一个深度嵌套的结构。幸运的是，有几个
    Helm 函数可以在这种情况下提供帮助。
- en: 'As you recall, the YAML language is very particular about the specific indentation
    and spacing of content. To account for this, Helm provides the `toYaml` function,
    which allows a dictionary of values to be provided, and for it to be formatted
    appropriately, regardless of how deeply nested it is. An example of this can be
    found within the ConfigMap that we have been using thus far in this section where
    a dictionary of annotations is injected from properties defined in the `Values`
    file, as illustrated in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你记得的那样，YAML 语言对内容的缩进和间距非常讲究。为了应对这一点，Helm 提供了 `toYaml` 函数，它允许提供一个值的字典，并根据需要正确地格式化它，无论它嵌套得多深。在我们这一节中一直在使用的
    ConfigMap 中，你可以看到一个从 `Values` 文件中定义的属性中注入的注解字典，以下代码片段展示了这一点：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following content is defined within the chart `values.yaml` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容在 chart 的 `values.yaml` 文件中定义：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You may also notice that the result of the `toYaml` function is then piped to
    another function called `nindent`. The use of this function is a necessary requirement
    to manage the formatting of the content; otherwise, a rendering error would occur.
    Both `indent` and `nindent` provide formatting capabilities by indenting content
    a certain number of spaces, crucial when working with YAML. The difference between
    `indent` and `nindent` is that `nindent` will add a newline character after each
    line of input, a required step in our use case as there are multiple annotation
    properties defined within the `Values` file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，`toYaml` 函数的结果被传递到另一个名为 `nindent` 的函数中。使用该函数是管理内容格式化的必要要求；否则会发生渲染错误。`indent`
    和 `nindent` 都提供通过缩进一定数量的空格来格式化内容的功能，这在处理 YAML 时至关重要。`indent` 和 `nindent` 的区别在于，`nindent`
    在每行输入后会添加一个换行符，这在我们的使用场景中是必需的，因为 `Values` 文件中定义了多个注解属性。
- en: 'Process the chart using the `helm template` command to visualize how these
    values would be rendered, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `helm template` 命令处理图表，查看这些值如何被渲染，如下所示：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The final Helm function that we will look at in detail is used when performing
    more complex rendering of templates. Earlier in this chapter, you learned how
    external files can be referenced within charts and their values injected into
    templates using the built-in `.Files` object. While Helm’s templating capabilities
    can be used to evaluate resources within template files, there are cases where
    there is a need to perform evaluation against externally sourced files. Take a
    look here at the ConfigMap once again and note the `config.properties` key:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论的最后一个 Helm 函数用于执行更复杂的模板渲染。在本章前面，你已经了解了如何在图表中引用外部文件，并使用内置的 `.Files` 对象将它们的值注入模板。虽然
    Helm 的模板功能可以用于评估模板文件中的资源，但也有需要对外部源文件进行评估的情况。请再次查看 ConfigMap，并注意 `config.properties`
    键：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Instead of including the values directly within the ConfigMap, they are instead
    sourced from a file located at `files/chapter-details.cfg`, as illustrated in
    the following code snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 值并非直接包含在 ConfigMap 中，而是来自位于 `files/chapter-details.cfg` 的文件，如下代码片段所示：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, when the chart is rendered using `helm template`, the desired values
    are not substituted as we would expect, as we can see here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用 `helm template` 渲染图表时，期望的值并未如预期替换，正如我们在这里所见：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This situation occurs since template processing only occurs by default, within
    files in the `templates` folder and not in any externally sourced content. To
    apply templating to external sources that are brought into templates, the `tpl`
    function can be used, as shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况发生是因为模板处理默认只在 `templates` 文件夹中的文件内进行，而不会处理任何外部源的内容。要将模板应用于引入模板的外部源，可以使用
    `tpl` 函数，如下所示：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What you may be wondering about when looking at the updated content of the ConfigMap
    is the presence of the period (`.`) before the pipe. This character indicates
    the scope that will be passed to the templating engine. We will cover this topic
    in detail in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看更新后的 ConfigMap 内容时，可能会对管道前的句点（`.`）感到疑惑。这个字符表示将传递给模板引擎的作用域。我们将在下一节中详细介绍这个话题。
- en: 'Use the `helm template` command to confirm that values are substituted appropriately
    thanks to the inclusion of the `tpl` function, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `helm template` 命令确认由于包含了 `tpl` 函数，值被适当地替换，如下所示：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The template functions addressed in this section only scratch the surface of
    the functions provided by Helm. The following table lists a few other important
    functions that chart developers should be aware of in order to fully take advantage
    of what Helm has to offer:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的模板函数仅仅是 Helm 提供的函数的冰山一角。下表列出了一些图表开发人员应该了解的其他重要函数，以便充分利用 Helm 的功能：
- en: '| **Function** | **Description** | **Example** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** | **示例** |'
- en: '| `printf` | Returns a string based upon a formatting string and arguments
    | `printf "A cat named %s has %d lives." $name $numLives` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `printf` | 根据格式字符串和参数返回一个字符串 | `printf "一只名叫 %s 的猫有 %d 条命。" $name $numLives`
    |'
- en: '| `default` | Assigns a string “placeholder” if the content of `$value` is
    `nil` or empty | `default "placeholder" $value` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 如果 `$value` 的内容为 `nil` 或为空，则赋值为字符串 “placeholder” | `default "placeholder"
    $value` |'
- en: '| `list` | Returns a new list based upon a series of inputs | `list "ClusterIP"
    "NodePort" "LoadBalancer"` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 基于一系列输入返回一个新列表 | `list "ClusterIP" "NodePort" "LoadBalancer"` |'
- en: '| `has` | Determines if an element is present in a list | `has 4 $list` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `has` | 确定列表中是否存在某个元素 | `has 4 $list` |'
- en: '| `b64enc`/`b64dec` | Encodes or decodes with Base64\. Useful when working
    with Secrets. | `b64enc $mySecret` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `b64enc`/`b64dec` | 使用 Base64 编码或解码。适用于处理 Secrets。 | `b64enc $mySecret` |'
- en: '| `atoi` | Convert a string to an integer | `atoi $myIntegerString` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `atoi` | 将字符串转换为整数 | `atoi $myIntegerString` |'
- en: '| `add` | Adds a list of integers | `add 1 2 3` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 添加一组整数 | `add 1 2 3` |'
- en: '| `upper`/`lower` | Convert the entire string to uppercase or lowercase | `upper
    $myString` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `upper`/`lower` | 将整个字符串转换为大写或小写 | `upper $myString` |'
- en: '| `now` | Gets the current date and time | `Now` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `now` | 获取当前日期和时间 | `Now` |'
- en: '| `date` | Formats a date in the specified format | `now &#124; date "2006-01-02"`
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `date` | 以指定格式格式化日期 | `now &#124; date "2006-01-02"` |'
- en: Table 6.3 – A list of common Helm functions
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3 – 常见 Helm 函数列表
- en: With a better understanding of the ways that Helm can be used to manipulate
    and format content within templates using functions, let’s turn to how we can
    introduce flow control to manage the content that will be rendered.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在更好地理解如何使用 Helm 操作和格式化模板中的内容后，让我们来看看如何引入流程控制来管理将要渲染的内容。
- en: Helm template control structures
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 模板控制结构
- en: The way in which templates are generated can be managed by chart developers
    thanks to the functionality provided by control structures. Included in the `actions`
    component of the `Go` templates, control structures enable fine-grained flow control
    for determining the types of resources that should be generated and how they are
    rendered.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的生成方式可以通过 chart 开发者管理，这得益于控制结构提供的功能。控制结构作为`Go`模板中的`actions`组件的一部分，使得能够精细控制流，以确定应生成哪些资源及其渲染方式。
- en: 'The following control-structure keywords are available:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下控制结构关键字可用：
- en: '`if`/`else`—Creating conditional blocks for resource generation'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`/`else`—为资源生成创建条件块'
- en: '`with`—Modifying the *scope* of resources being generated'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`—修改正在生成的资源的*作用域*'
- en: '`range`—Looping over a set of resources'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`—遍历一组资源'
- en: 'There are occasions where portions of a template would need to be included
    or excluded based on some sort of condition. In this situation, an `if`/`else`
    action can be used. Here is a basic example for conditionally determining whether
    to include a readiness probe as part of a deployment resource:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，模板的某些部分需要根据某种条件被包含或排除。在这种情况下，可以使用`if`/`else`操作。以下是一个基本示例，用于条件性地确定是否将就绪探针作为部署资源的一部分：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `readinessProbe` section will only be included when the condition evaluates
    to `true`. However, it is important to note that the condition is actually a pipeline
    where multiple statements can be chained together to aid in the creation of complex
    conditionals. The logic behind the `if`/`else` action can also be interpreted
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`readinessProbe`部分仅在条件求值为`true`时才会包含。然而，值得注意的是，该条件实际上是一个管道，可以将多个语句链在一起，以帮助创建复杂的条件。`if`/`else`操作背后的逻辑也可以这样理解：'
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The conditional statements and their associated `if`/`else` action should look
    familiar to anyone with prior programming experience. But what is the logic behind
    determining whether a pipeline is `true` or `false`?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句及其关联的`if`/`else`操作对任何具有编程经验的人来说应该都很熟悉。但是，确定管道是`true`还是`false`的逻辑是什么呢？
- en: 'A pipeline fails to evaluate to `true` when the following is returned:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回以下内容时，管道未能求值为`true`：
- en: A `false` Boolean
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`false`布尔值
- en: A numeric `0`
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字`0`
- en: An empty string
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空字符串
- en: '`nil` (whether it be empty or `null`)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil`（无论是空的还是`null`）'
- en: An empty collection
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空集合
- en: So, in the previous scenario where conditional logic is applied to the readiness
    probe, the probe would only be included if the value is `readinessProbe.enabled=true`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的场景中，当条件逻辑应用于就绪探针时，只有在值为`readinessProbe.enabled=true`时，探针才会被包含。
- en: 'Nesting of conditionals can also be applied within templates. The following
    code snippet illustrates how conditionals can be used to determine the type of
    probe that should be applied to `readinessProbe`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 条件嵌套也可以在模板中应用。以下代码片段演示了如何使用条件判断来确定应应用于`readinessProbe`的探针类型：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: An `httpGet` probe type will be applied when the `readinessProbe.type` property
    is equal to `"http"`. Otherwise, a **Transmission Control Protocol** (**TCP**)
    probe will be used.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当`readinessProbe.type`属性等于`"http"`时，将应用`httpGet`探针类型。否则，将使用**传输控制协议**（**TCP**）探针。
- en: '`eq` (short for *equals*) within the `if` statement is one of the available
    Boolean functions that test the equality of the two arguments. When the `readinessProbe.type`
    is equal to `http`, the `httpGet` probe type will be applied. Otherwise, a TCP
    probe type will be used.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq`（*等于*的缩写）在`if`语句中是用于测试两个参数是否相等的布尔函数之一。当`readinessProbe.type`等于`http`时，将应用`httpGet`探针类型。否则，将使用TCP探针类型。'
- en: 'A full list of available Boolean functions is provided here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了完整的可用布尔函数列表：
- en: '`and`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`or`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`not`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`'
- en: '`eq` (short for *equals*)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq`（*等于*的缩写）'
- en: '`ne` (short for *not equals*)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ne`（*不等于*的缩写）'
- en: '`lt` (short for *less than*)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt`（*小于*的缩写）'
- en: '`le` (short for *less than or equal to*)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`le`（*小于或等于*的缩写）'
- en: '`gt` (short for *greater than*)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt`（*大于*的缩写）'
- en: '`ge` (short for greater than or *equal to*)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ge`（*大于或等于*的缩写）'
- en: Another method of flow control available for chart developers is the ability
    to modify the scope of the resources being rendered. A period (`.`) represents
    the *current scope*, and thus far, we have been operating at the root or top-level
    scope. Each of the built-in objects that were covered earlier in this chapter
    is available at this level. However, when working with objects with deeply nested
    structures, there may be a desire to modify the scope being applied to avoid rather
    unwieldy property references.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图表开发者可以使用的另一种流控制方法是修改正在渲染的资源的作用域。句点（`.`）表示*当前作用域*，到目前为止，我们一直在根作用域或顶级作用域下操作。本章前面介绍的每个内置对象都可以在这个级别上使用。然而，当处理具有深度嵌套结构的对象时，可能需要修改应用的作用域，以避免较为笨重的属性引用。
- en: The `with` action provides these necessary capabilities to modify the current
    scope.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`动作提供了这些必要的功能来修改当前作用域。'
- en: 'Take a look at the `flowcontrol-example` Helm chart located at `chapter6/examples/flowcontrol-example`
    within the Git repository. Included within the `values.yaml` file is a deeply
    nested dictionary of properties, as illustrated here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位于Git仓库中`chapter6/examples/flowcontrol-example`的`flowcontrol-example` Helm图表。在`values.yaml`文件中包含了一个深度嵌套的属性字典，如下所示：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These values should look familiar given that they have been used several times
    in this chapter, but note that they are now placed into a deeply nested dictionary.
    They could be referenced in the following manner:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值应该看起来很熟悉，因为在本章中它们已经被多次使用，但请注意，它们现在被放置在一个深度嵌套的字典中。它们可以通过以下方式引用：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However, by using the `with` action, the current scope is changed so that references
    within the block begin at `.Values.book.chapter6.props`, greatly increasing the
    readability and reducing the complexity. You can see an illustration of this in
    the following code snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用`with`动作，当前作用域会发生变化，从而使得该块内的引用从`.Values.book.chapter6.props`开始，大大提高了可读性并减少了复杂性。你可以在以下代码片段中看到这个示例：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is illustrated within the ConfigMap located at `chapter6/examples/flowcontrol-example/templates/configmap.yaml`.
    Render the chart using the `helm template` command to confirm that values within
    the ConfigMap are generated properly, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这在位于`chapter6/examples/flowcontrol-example/templates/configmap.yaml`的ConfigMap中进行了说明。使用`helm
    template`命令渲染图表，以确认ConfigMap中的值是否正确生成，如下所示：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: One very important note when modifying scope is that chart developers may be
    caught off guard when attempting to reference any built-in objects such as `.Release`
    or `.Chart` within a block where the current scope has changed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 修改作用域时有一个非常重要的注意事项，那就是图表开发者在尝试引用任何内置对象（如`.Release`或`.Chart`）时，可能会感到意外，尤其是在作用域发生变化的块中。
- en: 'Attempting to use the following templating within the ConfigMap would result
    in an error upon instantiation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在ConfigMap中使用以下模板时，在实例化时会导致错误：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is due to the fact that the current scope within the `with` statement
    is no longer at the root scope where the built-in objects reside. Fortunately,
    Helm provides a way to reference the root scope by using `$`. By adding `$` to
    the `.Chart.Name` reference, a rendering error will no longer occur. You can see
    this in use in the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`with`语句中的当前作用域不再位于根作用域，根作用域是内置对象所在的位置。幸运的是，Helm提供了一种通过使用`$`引用根作用域的方法。通过在`.Chart.Name`引用前加上`$`，就不会再发生渲染错误。你可以在以下代码片段中看到这个用法：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The final flow-control action that chart developers need to be aware of is `range`—this
    is useful when performing `foreach` style iteration over lists and dictionaries.
    Similar to the `with` action, the `range` action also modifies the scope of resources
    being rendered.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图表开发人员需要注意的最终流控制操作是`range`—当对列表和字典进行`foreach`风格的迭代时，这个操作非常有用。与`with`操作类似，`range`操作也会修改正在渲染的资源范围。
- en: 'For example, say the following were included as values within a `values.yaml`
    file to represent ports associated with a Service resource:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设以下内容作为`values.yaml`文件中的值，表示与服务资源相关联的端口：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'By using the `range` action, these values can be then applied to the Service,
    as shown in the following example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`range`操作，这些值可以应用于服务，如以下示例所示：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `range` action modifies the scope in a similar fashion as the `with` action
    so that within the block, the current scope represents each port within the `ports`
    list during each iteration of the loop and can be referenced accordingly. An example
    of this in practice can be found in the `flowcontrol-example` chart within the
    Git repository located at `chapter6/examples/flowcontrol-example`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`操作的作用类似于`with`操作，在块内，当前范围代表`ports`列表中每个端口在每次迭代中的值，并可以相应地引用它。这个实践示例可以在Git仓库中的`flowcontrol-example`图表中找到，路径是`chapter6/examples/flowcontrol-example`。'
- en: Generating release notes
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成发布说明
- en: One special type of Helm template is called the `NOTES.txt` file, located in
    a Helm chart’s `templates/` folder. This file is used to dynamically generate
    usage instructions (or other details) for applications once they are installed
    with Helm.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Helm模板的一种特殊类型是`NOTES.txt`文件，位于Helm图表的`templates/`文件夹中。这个文件用于在通过Helm安装应用程序后动态生成使用说明（或其他细节）。
- en: 'A `NOTES.txt` file uses the same exact templating syntax as Kubernetes resource
    templates and can be seen in the following example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOTES.txt`文件使用与Kubernetes资源模板完全相同的模板语法，如以下示例所示：'
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: These examples would provide instructions on how to access applications deployed
    by the chart. They would be displayed during the install, upgrade, and rollback
    phases, and can be recalled by running the `helm get notes` command. By providing
    a `NOTES.txt` file, chart developers can provide additional insight on how to
    better use applications that have just been deployed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例将提供有关如何访问由图表部署的应用程序的说明。在安装、升级和回滚阶段，这些信息将会显示出来，并且可以通过运行`helm get notes`命令来调用。通过提供一个`NOTES.txt`文件，图表开发人员可以为刚刚部署的应用程序提供更多的使用建议。
- en: In the next section, we will discuss Helm template variables.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Helm模板变量。
- en: Helm template variables
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm模板变量
- en: In addition to leveraging values and other built-in objects, chart developers
    can create variables of their own within chart templates to provide additional
    processing options. A common use case for this approach is flow control, but template
    variables can serve other use cases as well.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了利用值和其他内置对象外，图表开发人员还可以在图表模板中创建自己的变量，以提供额外的处理选项。这种方法的常见用例是流控制，但模板变量也可以用于其他用例。
- en: 'A variable in a chart template is defined as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图表模板中的变量定义如下：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding example creates a variable called `myvar` and sets the value
    to a string equaling to `Hello World!`. Variables can be assigned to objects as
    well, such as a chart’s values, as illustrated here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了一个名为`myvar`的变量，并将其值设置为等于`Hello World!`的字符串。变量也可以赋值给对象，如图表的值，如这里所示：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once a variable is defined, it can be referenced in the following way:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了变量，可以通过以下方式引用它：
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Another example of using variables is in a `range` block, where variables capture
    the index and value of list iterations, as illustrated in the following code snippet:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量的另一个例子是在`range`块中，变量捕获列表迭代的索引和值，如以下代码片段所示：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`index` represents the current loop iteration number and `value` represents
    the value from the list for the iteration. The previous snippet is rendered as
    follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`表示当前循环迭代的编号，而`value`表示迭代中来自列表的值。前面的代码片段渲染结果如下：'
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Variables can also simplify the processing of map iterations, as shown here:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 变量还可以简化映射迭代的处理，如下所示：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A possible result might look like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的结果可能如下所示：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Another common use case for Helm variables is to refer to values outside of
    the current scope.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Helm变量的另一个常见用例是引用当前范围之外的值。
- en: 'Consider the following `with` block:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`with`块：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A template such as this one would fail to process since `.Release.Name` is
    not under the scope of `.Values.application.configuration`. One way this can be
    remedied is by setting a variable to `.Release.Name` above the `with` block, as
    follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的模板会失败处理，因为`.Release.Name`不在`.Values.application.configuration`的作用域下。解决这个问题的一种方法是在`with`块上方设置一个变量为`.Release.Name`，如下所示：
- en: '[PRE65]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'While this is a possible solution to this problem, the approach of using a
    dollar sign (`$`) to refer to the global scope is preferred as it requires fewer
    lines to configure and is easier to read as the complexity increases. In this
    case, this template could be rewritten like so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个可能的解决方案，但使用美元符号（`$`）引用全局作用域的方法更为推荐，因为它配置的行数较少，随着复杂度增加，它的可读性更好。在这种情况下，这个模板可以重写为如下：
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We will explore template validation next.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将探索模板验证。
- en: Helm template validation
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm模板验证
- en: When working with Kubernetes and Helm, input validation is automatically performed
    by the Kubernetes API server when a new resource is created. This means that if
    an invalid resource is created by Helm, an error message will be returned by the
    API server, resulting in a failed installation. Although Kubernetes performs input
    validation, there may still be cases in which chart developers will want to perform
    validation before the resources reach the API server, such as to return a simple
    error message or to limit the range of possibilities to the user.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Kubernetes和Helm时，输入验证会在创建新资源时由Kubernetes API服务器自动执行。这意味着如果Helm创建了一个无效资源，API服务器会返回错误信息，导致安装失败。尽管Kubernetes执行输入验证，仍然可能存在一些情况下，图表开发人员希望在资源到达API服务器之前执行验证，例如返回简单的错误信息或限制用户的选择范围。
- en: 'In Helm, input validation refers to validating user-provided values to ensure
    that users have provided a proper set of values. You can perform this validation
    in three different ways (or a combination of these three), as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在Helm中，输入验证指的是验证用户提供的值，以确保用户提供了适当的值集。你可以通过以下三种方式（或它们的组合）来执行这种验证：
- en: Using the `fail` function
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fail`函数
- en: Using the `required` function
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`required`函数
- en: Using a `values.schema.json` file
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`values.schema.json`文件
- en: Let’s begin exploring input validation by first looking at the `fail` function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过查看`fail`函数来开始探索输入验证。
- en: The fail function
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`fail`函数'
- en: The `fail` function is used to immediately fail the Helm installation and is
    often used in cases where users have provided an invalid value. In this section,
    we’ll explore an example use case of the `fail` function that restricts user input
    and halts the installation if the user has provided a value outside of the expected
    set of values.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`fail`函数用于立即使Helm安装失败，通常用于用户提供了无效值的情况。在本节中，我们将探索一个`fail`函数的示例用例，该函数限制用户输入，并在用户提供的值不在预期值集之外时停止安装。'
- en: 'Many Helm charts support values for setting the Kubernetes Service type. There
    are many different Service types that a user could choose from, but here are a
    few:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Helm图表支持为设置Kubernetes服务类型提供值。用户可以选择多种服务类型，以下是一些常见类型：
- en: '`ClusterIP`: Assigns an **Internet Protocol** (**IP**) address to the Service.
    Reachable only from within the cluster.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterIP`：为Service分配一个**Internet协议**（**IP**）地址，仅在集群内可访问。'
- en: '`NodePort`: Exposes a port on each Kubernetes node. Reachable from outside
    the cluster.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NodePort`：在每个Kubernetes节点上公开一个端口。集群外部可以访问。'
- en: '`LoadBalancer`: Creates a load balancer on the cloud provider where Kubernetes
    is deployed, if applicable.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadBalancer`：如果适用，创建一个负载均衡器，在Kubernetes部署的云提供商上创建。'
- en: Let’s assume that we want to restrict users to be able to only create a `ClusterIP`
    or `NodePort` Service. We can use the `fail` function to fail and provide an error
    message if the Service type is not one of these two types.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望限制用户只能创建`ClusterIP`或`NodePort`类型的Service。如果Service类型不是这两种类型中的任何一种，我们可以使用`fail`函数使其失败并提供错误信息。
- en: 'The example in the Git repository, located at `chapter6/examples/fail-example`,
    demonstrates this use case. In the `values.yaml` file, we see the following value:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`chapter6/examples/fail-example`的Git仓库中的示例演示了这个用例。在`values.yaml`文件中，我们看到如下的值：
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `service.yaml` template (located in the chart’s `templates/` folder),
    we see the following lines of code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service.yaml`模板（位于图表的`templates/`文件夹中）中，我们看到以下代码行：
- en: '[PRE68]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the previous template snippet, we first created a variable called `serviceTypes`
    and set it to a list of strings, containing the `ClusterIP` and `NodePort` types.
    Then, in an `if` action, we used the `has` function to determine whether or not
    the `service.type` value was included in the `serviceTypes` list, representing
    the set of permitted values. If the value provided was found, then we assume that
    the input was valid and render the service type and proceed with the installation.
    Otherwise, the `fail` function would be invoked, failing the installation and
    displaying to the user a message that explains the reason for the failure.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板片段中，我们首先创建了一个名为 `serviceTypes` 的变量，并将其设置为一个字符串列表，包含 `ClusterIP` 和 `NodePort`
    类型。然后，在 `if` 操作中，我们使用 `has` 函数来确定 `service.type` 值是否包含在 `serviceTypes` 列表中，表示允许的值集。如果找到提供的值，则我们假设输入有效，并渲染服务类型并继续安装。否则，将调用
    `fail` 函数，失败安装，并向用户显示解释失败原因的消息。
- en: 'Since the default service is already `ClusterIP` (as seen in the `values.yaml`
    file), we know that running `helm template` or `helm install` without providing
    any additional values would be successful. But let’s see what happens if we try
    to set the `service.type` value to an invalid setting, such as `LoadBalancer`.
    This is what we’d see:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认服务已经是 `ClusterIP`（如在 `values.yaml` 文件中所见），我们知道运行 `helm template` 或 `helm
    install` 而不提供任何额外值将会成功。但让我们看看如果尝试将 `service.type` 值设置为无效设置（例如 `LoadBalancer`）会发生什么：
- en: '[PRE69]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you can see in the error message, the `fail` function caused rendering to
    fail early and displays an error message that was coded in the Service template.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在错误消息中所见，`fail` 函数导致渲染提前失败，并显示在服务模板中编码的错误消息。
- en: Let’s look at the next way to perform input validation—the `required` function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下执行输入验证的下一个方式 —— `required` 函数。
- en: The required function
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: required 函数
- en: The `required` function, as with `fail`, is also used to halt template rendering.
    The difference is that, unlike `fail`, the `required` function is used to ensure
    that a value is not left blank when a chart’s templates are rendered. It is named
    as such because it requires a user to provide a value when specified.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `fail` 不同，`required` 函数也用于停止模板渲染。不同之处在于，与 `fail` 不同，`required` 函数用于确保在渲染图表模板时不会留空值。它被命名为此，因为当指定时它要求用户提供一个值。
- en: 'Take a look at this snippet of the `values.yaml` file from the chart at `chapter6/examples/required-example`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下图表中 `chapter6/examples/required-example` 的 `values.yaml` 文件的片段：
- en: '[PRE70]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the `service.yaml` template for this chart, we see the following output:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图表的 `service.yaml` 模板中，我们看到以下输出：
- en: '[PRE71]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This invocation of `required` checks to see if the string represented by the
    `service.type` value is empty. If it is empty, rendering fails and an error message
    is displayed. Otherwise, it renders the `service.type` value.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此次调用的 `required` 检查`service.type` 值所表示的字符串是否为空。如果为空，则渲染失败并显示错误消息。否则，它将渲染 `service.type`
    值。
- en: 'We can see this in action by using the `helm template` command, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `helm template` 命令，我们可以看到它的实际效果，如下所示：
- en: '[PRE72]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As expected, we receive an error message stating that the `service.type` value
    is required. The user can then remedy this error by providing a value for `service.type`
    by using either the `--set` or `--values` flags.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们收到了一个错误消息，指出 `service.type` 值是必需的。用户可以通过使用 `--set` 或 `--values` 标志为
    `service.type` 提供一个值来解决此错误。
- en: Let’s explore the final validation method that we will touch upon—the `values.schema.json`
    file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下我们将涉及的最终验证方法 —— `values.schema.json` 文件。
- en: The values.schema.json file
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`values.schema.json` 文件'
- en: The `values.schema.json` file is used to define and enforce a schema for your
    chart’s values. Whereas the `required` and `fail` functions are invoked from within
    chart templates, the `values.schema.json` file allows you to set value requirements
    and constraints in a single location. This file also adds additional validation
    capabilities, such as setting minimums and maximums for integer values.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`values.schema.json` 文件用于定义和强制执行图表值的模式。而 `required` 和 `fail` 函数是从图表模板内调用的，`values.schema.json`
    文件允许您在单个位置设置值要求和约束。此文件还添加了其他验证功能，如设置整数值的最小值和最大值。'
- en: The `values.schema.json` file is based on the **JSON Schema** vocabulary. An
    exhaustive overview of JSON Schema is out of scope for this book, but you can
    explore the vocabulary yourself by visiting [http://json-schema.org/specification.html](http://json-schema.org/specification.html).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`values.schema.json` 文件基于**JSON Schema**词汇。关于 JSON Schema 的详细概述超出了本书的范围，但您可以访问
    [http://json-schema.org/specification.html](http://json-schema.org/specification.html)
    来探索词汇表。'
- en: 'Let’s review an example `values.schema.json` file, located in the chart at
    `chapter6/examples/schema-example` within the Git repository. You can see a representation
    of this here:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下位于 Git 仓库 `chapter6/examples/schema-example` 中的示例 `values.schema.json`
    文件。您可以在这里看到它的表示：
- en: '![Figure 7.8 – The Guestbook frontend after the pre-rollback phase'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.8 – The Guestbook frontend after the pre-rollback phase'
- en: '](img/Figure_6.1_B17979.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B17979.jpg)'
- en: Figure 6.1 – Sample values.schema.json file
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 示例 `values.schema.json` 文件
- en: 'This schema provides validation for the following objects under `.Values`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式为`.Values`下的以下对象提供验证：
- en: '| **Object** | **Validation** |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **验证** |'
- en: '| `.Values.image` | Ensures that the image object exists |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `.Values.image` | 确保`image`对象存在 |'
- en: '| `.Values.image.repository` | Ensures that the `image.repository` value exists
    and is a string |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `.Values.image.repository` | 确保`image.repository`值存在并且是字符串类型 |'
- en: '| `.Values.image.tag` | Ensures that the `image.tag` value exists and is a
    string |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `.Values.image.tag` | 确保`image.tag`值存在并且是字符串类型 |'
- en: '| `.Values.service` | Ensures that the service object exists |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `.Values.service` | 确保服务对象存在 |'
- en: '| `.Values.service.type` | Ensures that the `service.type` value exists and
    is set to either `ClusterIP` or `NodePort` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `.Values.service.type` | 确保`service.type`值存在并设置为`ClusterIP`或`NodePort` |'
- en: '| `.Values.service.port` | Ensures that the `service.port` value exists and
    is greater than or equal to `8080` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `.Values.service.port` | 确保`service.port`值存在且大于或等于`8080` |'
- en: Table 6.4 – Values that are validated in the example values.schema.json file
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 – 在示例 `values.schema.json` 文件中验证的值
- en: As shown in the preceding table, there is a lot of robust validation being performed
    by providing the `values.schema.json` file. More values could be added to the
    schema file, but we’ve only included a small amount for demonstration purposes.
    Sometimes, it is useful to include all supported values in the `values.schema.json`
    file for purposes of self-documentation or to ensure that all values are strictly
    validated.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，通过提供`values.schema.json`文件，执行了大量的强大验证。可以向模式文件中添加更多值，但我们这里只包含了少量内容用于演示。有时，将所有支持的值都包含在`values.schema.json`文件中是有用的，目的是为了自我文档化或确保所有值都经过严格验证。
- en: 'When using a `values.schema.json` file, error messages are handled for you
    automatically. For example, let’s see what happens if we try to set `service.type`
    to `LoadBalancer` (which is not supported in the **enumerator** (**enum**) defined
    in the schema). Here’s the result:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`values.schema.json`文件时，错误消息会自动处理。例如，我们可以看到如果尝试将`service.type`设置为`LoadBalancer`（这是模式中**枚举器**（**enum**）未支持的值）会发生什么。以下是结果：
- en: '[PRE73]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice we did not have to specify the specific error message to return to the
    user—the JSON Schema library provided it for us.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要指定返回给用户的具体错误信息—JSON Schema 库会自动提供。
- en: In this section, we reviewed three different input validation strategies. Next,
    we’ll look at enabling template reuse with named templates and library charts.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了三种不同的输入验证策略。接下来，我们将探讨如何通过命名模板和库图表启用模板重用。
- en: Enabling code reuse with named templates and library charts
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过命名模板和库图表启用代码重用
- en: When creating template files, there may be boilerplate or repetitive blocks
    of YAML among the different Kubernetes resources in a chart.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模板文件时，可能会在不同的 Kubernetes 资源之间出现冗余或重复的 YAML 代码块。
- en: 'For example, you may strive to use a consistent set of labels for each resource,
    as illustrated here:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能会努力为每个资源使用一致的标签集，如下所示：
- en: '[PRE74]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The preceding labels could be copy-pasted manually throughout your templates,
    but this would be cumbersome, especially if you wanted to make updates to these
    labels in the future. To help reduce the amount of boilerplate code and to enable
    reuse, Helm provides a construct called **named templates**.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的标签可以手动复制粘贴到您的模板中，但这会显得繁琐，特别是当您想在未来更新这些标签时。为了帮助减少冗余代码并启用重用，Helm 提供了一个构造机制，称为**命名模板**。
- en: Named templates, as with regular Kubernetes templates, are defined under the
    `templates/` directory. They begin with an underscore and end with the `.tpl`
    file extension. Many charts (including our Guestbook chart) leverage a file called
    `_helpers.tpl` that contains these named templates, though the file does not need
    to be called `helpers`. When creating a new chart with the `helm create` command,
    this file is included in the scaffolded set of resources.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 命名模板与常规的 Kubernetes 模板一样，都是在`templates/`目录下定义的。它们以下划线开头，并以`.tpl`文件扩展名结尾。许多图表（包括我们的
    Guestbook 图表）利用一个名为`_helpers.tpl`的文件，其中包含这些命名模板，尽管文件不需要叫做`helpers`。使用`helm create`命令创建新图表时，这个文件将包含在生成的资源集中。
- en: 'To create a named template, chart developers can leverage the `define` action.
    The following example creates a named template that can be used to encapsulate
    resource labels:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个命名模板，图表开发者可以利用`define`操作。以下示例创建了一个命名模板，用于封装资源标签：
- en: '[PRE75]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `define` action takes a template name as an argument. In the preceding example,
    the template name is called `mychart.labels`. The common convention for naming
    a template is `$CHART_NAME.$TEMPLATE_NAME`, where `$CHART_NAME` is the name of
    the Helm chart and `$TEMPLATE_NAME` is a short, descriptive name that describes
    the purpose of the template. The `mychart.labels` name implies that the template
    is native to the `mychart` Helm chart and will generate labels for resources it
    is applied to.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`define`操作接受模板名称作为参数。在上面的示例中，模板名称称为`mychart.labels`。命名模板的常见约定是`$CHART_NAME.$TEMPLATE_NAME`，其中`$CHART_NAME`是
    Helm 图表的名称，`$TEMPLATE_NAME`是描述模板用途的简短描述性名称。`mychart.labels`名称意味着该模板是`mychart`
    Helm 图表特有的，并且将为应用它的资源生成标签。'
- en: 'To use a named template in a Kubernetes YAML template, you can use the `include`
    function, which has the following usage:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kubernetes YAML 模板中使用命名模板，可以使用`include`函数，其用法如下所示：
- en: '[PRE76]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `TEMPLATE_NAME` parameter is the name of the named template that should
    be processed. The `SCOPE` parameter is the scope in which values and built-in
    objects should be processed. Most of the time, this parameter is a dot (`.`) to
    denote the current top-level scope, but any scope could be provided including
    the dollar-sign ( `$` ) symbol, which should be used if the named template references
    values outside of the current scope.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEMPLATE_NAME`参数是应该处理的命名模板的名称。`SCOPE`参数是应该处理值和内置对象的范围。大多数情况下，这个参数是一个点（`.`），表示当前顶层范围，但可以提供任何范围，包括美元符号（`$`），如果命名模板引用当前范围外的值，则应使用美元符号。'
- en: 'The following example demonstrates how the `include` function is used to process
    a named template:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用`include`函数来处理命名模板：
- en: '[PRE77]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This example begins by setting the name of the resource to the name of the
    release. It then uses the `include` function to process the labels and indents
    each line by two spaces, as declared by the pipeline. When processing is finished,
    a rendered resource may appear as follows for a release called `template-demonstration`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例首先将资源的名称设置为发布的名称。然后，它使用`include`函数来处理标签，并将每行缩进两个空格，如流水线所声明的。处理完成后，渲染的资源可能会如下所示，用于名为`template-demonstration`的发布：
- en: '[PRE78]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Helm also provides a `template` action that can also expand named templates.
    This action has the same usage as `include`, but with one major limitation—it
    cannot be used in a pipeline to provide additional formatting and processing capabilities.
    The `template` action is used to simply display data inline. Because of this limitation,
    chart developers should use the `include` function over the `template` action
    since `include` has feature parity with `template` but also provides additional
    processing options.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 还提供了一个`template`操作，可以展开命名模板。这个操作与`include`的用法相同，但有一个主要限制——它不能在流水线中用于提供额外的格式化和处理能力。`template`操作用于简单地内联显示数据。因此，图表开发者应该优先使用`include`函数而不是`template`操作，因为`include`不仅具有与`template`相同的功能对等性，还提供了额外的处理选项。
- en: Named templates are excellent for reducing boilerplate in a single Helm chart,
    but imagine you want to share common boilerplate (such as labels) across multiple
    Helm charts. To do this, you can leverage `type` field in `Chart.yaml` is set
    to `library`. Library charts also differ in that they cannot be installed—a library
    chart’s purpose is to provide a set of helper templates that can then be imported
    among different application charts by using dependency management.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 命名模板对于减少单个 Helm chart 中的样板代码非常有用，但假设你想在多个 Helm chart 中共享通用的样板代码（如标签）。为此，你可以利用在
    `Chart.yaml` 中将 `type` 字段设置为 `library`。库 chart 与其他 chart 的不同之处在于它不能被安装——库 chart
    的目的是提供一组帮助模板，然后可以通过依赖管理在不同的应用程序 chart 中导入这些模板。
- en: 'An example of a library chart is Bitnami’s `common` chart, which can be seen
    at the following link: [https://github.com/bitnami/charts/tree/master/bitnami/common](https://github.com/bitnami/charts/tree/master/bitnami/common).
    There, you will find that each of the chart’s templates is actually a `tpl` file
    that contains named templates within. Here is an abbreviated list from Bitnami’s
    common library chart:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一个库 chart 的示例是 Bitnami 的 `common` chart，可以在以下链接找到：[https://github.com/bitnami/charts/tree/master/bitnami/common](https://github.com/bitnami/charts/tree/master/bitnami/common)。在这里，你会发现该
    chart 的每个模板实际上都是一个包含命名模板的 `tpl` 文件。以下是来自 Bitnami common 库 chart 的一个简化列表：
- en: '`_affinities.tpl`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_affinities.tpl`'
- en: '`_capabilities.tpl`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_capabilities.tpl`'
- en: '`_errors.tpl`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_errors.tpl`'
- en: '`_images.tpl`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_images.tpl`'
- en: 'These named templates can be used by adding the following dependency to any
    application Helm chart:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命名模板可以通过将以下依赖项添加到任何应用程序 Helm chart 中来使用：
- en: '[PRE79]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Then, any chart importing this dependency can leverage any template by referencing
    the template name with the `include` function—for example, `{{ include "common.names.fullname"
    . }}`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，任何导入此依赖项的 chart 都可以通过使用 `include` 函数引用模板名称来使用任何模板——例如，`{{ include "common.names.fullname"
    . }}`。
- en: In the next section, we will explore how Helm can handle the creation of Kubernetes
    **custom resources** (**CRs**).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨 Helm 如何处理 Kubernetes **自定义资源**（**CR**）的创建。
- en: Creating CRDs
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CRD（自定义资源定义）
- en: While Helm is often used to create traditional Kubernetes resources, it can
    also be used to create CRDs and CRs. CRDs are used to define resources that are
    not native to the Kubernetes API. You may want to use this functionality to augment
    the abilities that Kubernetes provides. CRs are resources that implement the CRD’s
    specification. As a result, it’s important to ensure that a CRD is always created
    before the CRs that implement it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Helm 通常用于创建传统的 Kubernetes 资源，但它也可以用于创建 CRD 和 CR。CRD 用于定义 Kubernetes API 中没有的资源。你可能希望使用这个功能来扩展
    Kubernetes 提供的能力。CR 是实现 CRD 规范的资源。因此，确保在创建实现它的 CR 之前总是先创建 CRD 非常重要。
- en: Helm is able to ensure CRDs are created and registered to Kubernetes before
    CRs are included in a Helm chart when CRDs are included in the chart’s `crds/`
    folder. All CRDs defined under this folder are created before those in `templates/`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CRD 被包含在 Helm chart 的 `crds/` 文件夹中时，Helm 能够确保在 CR 包含在 Helm chart 中之前，CRD 已经在
    Kubernetes 中创建并注册。该文件夹下定义的所有 CRD 会在 `templates/` 文件夹中的 CRD 之前创建。
- en: 'An example `crds/` folder is shown here:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 `crds/` 文件夹的示例：
- en: '[PRE80]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `my-custom-resource-crd.yaml` file may have the following contents:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`my-custom-resource-crd.yaml` 文件可能包含以下内容：'
- en: '[PRE81]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, the `templates/` directory can contain an instance of the `MyCustomResource`
    resource (that is, the CR), as illustrated here:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`templates/` 目录可以包含 `MyCustomResource` 资源的一个实例（即 CR），如下所示：
- en: '[PRE82]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: There are a few important caveats to note when creating CRDs with Helm. First,
    CRDs cannot be templated, so they are created exactly as defined under the CRDs
    folder. Second, CRDs cannot be deleted with Helm, and as a result, they also cannot
    be upgraded or rolled back. Third, creating CRDs requires `cluster-admin` privileges
    within the Kubernetes cluster. Note that these caveats apply to CRDs, not CRs.
    Since CRs are created in the `templates/` folder, they are treated by Helm like
    regular Kubernetes resource templates. CRs also typically do not require elevated
    permissions to the level of `cluster-admin`, so they can typically be installed
    by normal users.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Helm 创建 CRD 时，有几个重要的注意事项。首先，CRD 不能被模板化，因此它们会按在 CRD 文件夹中定义的方式创建。其次，CRD 不能使用
    Helm 删除，因此也无法升级或回滚。第三，创建 CRD 需要 Kubernetes 集群中的 `cluster-admin` 权限。请注意，这些限制仅适用于
    CRD，而不是 CR。由于 CR 是在 `templates/` 文件夹中创建的，它们会被 Helm 视为普通的 Kubernetes 资源模板。CR 通常也不需要提升到
    `cluster-admin` 级别的权限，因此通常可以由普通用户安装。
- en: Throughout this chapter, we have discussed using templates to render Kubernetes
    resources with Helm. In the next section, we will discuss how advanced Helm chart
    users can further process Kubernetes resources while running an installation.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用模板通过 Helm 渲染 Kubernetes 资源。在下一节中，我们将讨论高级 Helm 图表用户如何在运行安装时进一步处理
    Kubernetes 资源。
- en: Post rendering
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后渲染
- en: When developing Helm charts, you should carefully consider each of the different
    values that need to be included in your chart. For example, if you know users
    may need to change the Service type within Service templates, you should expose
    a value to do so to keep your chart flexible. The same idea holds true for image
    names, resources, health checks, and other settings users would need to configure
    based on your use case.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Helm 图表时，你应仔细考虑图表中需要包含的每一个不同值。例如，如果你知道用户可能需要修改 Service 模板中的 Service 类型，那么你应该暴露一个值来实现这一点，以保持图表的灵活性。对于镜像名称、资源、健康检查以及其他用户需要根据使用案例配置的设置，采用相同的思路。
- en: Sometimes, however, users will still require additional flexibility that is
    not provided by a Helm chart. This is where post rendering comes into play. Post
    rendering is an advanced feature of Helm that allows users to perform further
    modifications to rendered chart templates when they install your chart. It is
    often seen as a last resort if they require modifications that your Helm chart
    does not allow.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时用户仍然需要一些 Helm 图表未提供的额外灵活性。这时，后渲染功能就派上用场了。后渲染是 Helm 的一个高级功能，它允许用户在安装图表时对渲染后的模板进行进一步修改。如果用户需要的修改是
    Helm 图表不支持的，后渲染通常被视为最后的解决方案。
- en: 'Post rendering is applied by adding the `--post-renderer` flag to the `install`,
    `upgrade`, or `template` commands. Here is an example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 后渲染通过将 `--post-renderer` 标志添加到 `install`、`upgrade` 或 `template` 命令来应用。以下是一个示例：
- en: '[PRE83]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `<path-to-executable>` parameter is an executable file that invokes the
    post-renderer. The executable could be anything from a Go program to a shell script
    invoking another tool, such as **Kustomize**. Kustomize is a tool used for patching
    YAML files, so it is often used for post rendering.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`<path-to-executable>` 参数是一个可执行文件，它调用后渲染器。该可执行文件可以是从 Go 程序到调用其他工具（如 **Kustomize**）的
    shell 脚本。Kustomize 是一个用于修补 YAML 文件的工具，因此它通常用于后渲染。'
- en: 'We won’t dive deep into Kustomize because it is out of scope for this book.
    However, we have included an example of using Kustomize as a post-renderer in
    the Git repository at `chapter6/examples/post-renderer-example` that can be invoked
    as follows, assuming that the `kustomize` command-line tool is available on the
    local machine:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论 Kustomize，因为它超出了本书的范围。然而，我们在 Git 仓库中提供了一个使用 Kustomize 作为后渲染器的示例，位置在
    `chapter6/examples/post-renderer-example`，可以按照以下方式调用，假设本地机器上已安装 `kustomize` 命令行工具：
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `hook.sh` file invokes Kustomize, which patches the deployment and service
    YAML resources with custom environment variables and the `NodePort` service type,
    as defined in the `kustomization.yaml` file.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`hook.sh` 文件调用 Kustomize，它将使用自定义环境变量和在 `kustomization.yaml` 文件中定义的 `NodePort`
    服务类型来修补部署和服务 YAML 资源。'
- en: In this section, we discussed post rendering. One note before we depart from
    this topic is that post rendering should not be considered part of normal Helm
    usage. As a chart developer, you should ensure that your chart is flexible enough
    for users to leverage your chart as-is out of the box. As a chart user, you should
    try to avoid using post renders unless absolutely necessary. This is because you
    need to remember to use the `--post-renderer` flag on each Helm upgrade, or the
    patch will be inadvertently omitted. Post-renderers also require additional effort
    from the user to maintain, as there may be tooling or other prerequisites needed.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了后渲染。在我们结束这个话题之前，有一点需要说明：后渲染不应被视为 Helm 的常规使用方式。作为图表开发者，你应确保你的图表足够灵活，让用户可以开箱即用，直接利用图表。而作为图表用户，除非绝对必要，否则应该尽量避免使用后渲染。这是因为你需要记得在每次
    Helm 升级时使用 `--post-renderer` 标志，否则补丁可能会被遗漏。后渲染还需要用户额外的维护工作，因为可能需要工具或其他先决条件。
- en: Throughout this chapter, we have covered each of the key components of Helm
    templates. Next, we will tie this all in by returning to our Guestbook chart.
    We will make small updates to the scaffolded `values.yaml` file and the `deployment.yaml`
    template, and we will deploy our Guestbook Helm chart.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Updating and deploying the Guestbook chart
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to successfully deploy our Guestbook application, we need to add values
    to configure the following details:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Configure the Redis service names and disable Redis authentication
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create environment variables for defining the names of the Redis leader and
    follower
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will begin by first handling Redis values.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Updating Redis values
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B17979_05.xhtml#_idTextAnchor154), *Helm Dependency Management*,
    we created a Redis dependency for creating a backend. Now, we will add a couple
    of values to our `values.yaml` file to complete the configuration.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'The values that we need to add are in the Git repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L5-L8](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L5-L8)
    and are shown in the following snippet:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `redis.fullnameOverride` value is used to ensure that deployed Redis instances
    are prefixed with `redis`. This will help ensure the Guestbook application is
    talking to consistently named instances.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `redis.auth.enabled` value to `false` will disable Redis authentication.
    This is necessary because the Guestbook frontend is not configured to authenticate
    with Redis.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: That’s all the changes needed for Redis. Let’s update the Guestbook values and
    templates next.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Updating Guestbook’s deployment template and values.yaml file
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `helm create` command we used in [*Chapter 4*](B17979_04.xhtml#_idTextAnchor139),
    *Scaffolding a New Helm Chart,* did an excellent job of giving us almost all of
    the templating features we need for this application, but there is one gap that
    we need to fill in order to deploy Guestbook. We need to be able to set environment
    variables in the Guestbook deployment in order to tell the frontend how to connect
    to Redis.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'If we observe the Guestbook source code at [https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/main/guestbook/php-redis/guestbook.php](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/main/guestbook/php-redis/guestbook.php),
    we can see three different environment variables that need to be set, as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '`GET_HOSTS_FROM`: Informs Guestbook whether or not it should retrieve the Redis
    hostnames from the environment. We will set this to `env` so that hostnames are
    retrieved from the two environment variables defined next.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REDIS_LEADER_SERVICE_HOST`: Provides the hostname of the Redis leader. Because
    the Redis dependency we are using specifies the leader as `redis-master`, we will
    set this value to `redis-master`.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REDIS_FOLLOWER_SERVICE_HOST`: Provides the hostname of the Redis follower.
    The Redis dependency we are using specifies the follower as `redis-replicas`,
    so we will set this value to `redis-replicas`.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REDIS_FOLLOWER_SERVICE_HOST`：提供 Redis 从节点的主机名。我们正在使用的 Redis 依赖项指定从节点为 `redis-replicas`，因此我们将这个值设置为
    `redis-replicas`。'
- en: 'Since the scaffolded `deployment.yaml` template did not allow for environment
    variables to be created, we need to write this logic into the template ourselves.
    We can do this by adding the lines located at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/templates/deployment.yaml#L50-L51](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/templates/deployment.yaml#L50-L51),
    which are also shown here:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由于框架生成的 `deployment.yaml` 模板未能创建环境变量，我们需要将这一逻辑自己写入模板。我们可以通过添加位于[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/templates/deployment.yaml#L50-L51](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/templates/deployment.yaml#L50-L51)的代码行来实现这一点，这里也展示了这些代码：
- en: '[PRE86]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here, we added a new `env` object. Underneath, we are using the `toYaml` function
    to format the `env` value (which we will add shortly) as a YAML object. Then,
    we are using a pipeline and the `nindent` function to form a new line and indent
    by 12 spaces.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的 `env` 对象。在其下方，我们使用 `toYaml` 函数将 `env` 值（我们稍后会添加）格式化为 YAML 对象。然后，我们使用管道和
    `nindent` 函数形成新的一行，并缩进12个空格。
- en: 'Next, we need to add the `env` object with the associated content to our `values.yaml`
    file. An example of this is located at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L10-L16](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L10-L16)
    and is also displayed here:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将带有相关内容的 `env` 对象添加到我们的 `values.yaml` 文件中。一个示例位于[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L10-L16](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter6/guestbook/values.yaml#L10-L16)并且这里也展示了这个示例：
- en: '[PRE87]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: With the Guestbook chart’s values and template updated, let’s move on to the
    next section.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Guestbook 图表的值和模板更新，我们可以进入下一部分。
- en: Deploying the Guestbook chart
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Guestbook 图表
- en: 'Now, it’s time to deploy a fully functional Guestbook instance with our Helm
    chart! First, start your minikube environment and create a new namespace for this
    chapter, as shown here. If you already started and created the `chapter6` name
    at the beginning of this chapter, you can skip the next two commands:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用我们的 Helm 图表部署一个功能完整的 Guestbook 实例了！首先，启动你的 minikube 环境并为本章创建一个新的命名空间，如下所示。如果你在本章开始时已经创建了
    `chapter6` 命名空间，你可以跳过接下来的两个命令：
- en: '[PRE88]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, use the `helm install` command to deploy the Guestbook instance, as illustrated
    here. You should also watch the pods in the namespace for the Redis pods to become
    ready:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `helm install` 命令来部署 Guestbook 实例，如下所示。你还应该监视该命名空间中的 pod，等待 Redis pod
    准备就绪：
- en: '[PRE89]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Once the Redis instances are ready, hit *Ctrl+C* to stop watching resources
    and then use the `kubectl port-forward` command to expose your Guestbook frontend
    to localhost on port `8080`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Redis 实例准备就绪，按 *Ctrl+C* 停止监视资源，然后使用 `kubectl port-forward` 命令将 Guestbook
    前端暴露到本地 `8080` 端口：
- en: '[PRE90]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once the Guestbook service is exposed, you can navigate to the `http://localhost:8080`
    **Uniform Resource Locator** (**URL**) in your browser. The Guestbook frontend
    should appear. Try entering a message, such as **Hello world!**, and a message
    should appear under the blue **Submit** button, as illustrated here:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Guestbook 服务被暴露，你可以在浏览器中导航到 `http://localhost:8080` **统一资源定位符**（**URL**）。Guestbook
    前端页面应该会出现。尝试输入一条信息，例如 **Hello world!**，并且一条信息应出现在蓝色 **Submit** 按钮下方，如下所示：
- en: '![Figure 6.2 – The Guestbook frontend after the Hello world! message has been
    submitted'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 提交 Hello world! 消息后的 Guestbook 前端'
- en: '](img/Figure_6.2_B17979.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B17979.jpg)'
- en: Figure 6.2 – The Guestbook frontend after the Hello world! message has been
    submitted
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 提交 Hello world! 消息后的 Guestbook 前端
- en: If you are able to load the page in a browser and enter a message, then congratulations!
    You have successfully built and deployed your first Helm chart! However, as with
    any software product, you can always continue to make improvements. We will enhance
    this chart in the next chapter by adding upgrade and rollback hooks for performing
    backup and restore of the Redis database.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够在浏览器中加载页面并输入消息，那么恭喜你！你已经成功构建并部署了你的第一个 Helm 图表！然而，和任何软件产品一样，你总是可以继续改进。我们将在下一章中通过添加升级和回滚钩子来增强这个图表，从而实现
    Redis 数据库的备份和恢复。
- en: 'For now, when you are done working, feel free to clean up your environment
    and stop your minikube instance, as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你完成工作后，可以随时清理你的环境并停止 minikube 实例，操作如下：
- en: '[PRE91]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This brings us to the end of the section.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 本节到此结束。
- en: Summary
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Templates represent the core of Helm’s functionality. They allow you to create
    a variety of different Kubernetes resource configurations by enabling dynamic
    YAML generation. Helm’s template engine, based on Go templates, contains several
    built-in objects upon which chart developers can build charts, such as the `.Values`
    and `.Release` objects. Templates also provide many different functions to provide
    robust formatting and manipulation, along with control structures for enabling
    conditional logic and loops. Besides rendering Kubernetes resources, templates
    can also be used to abstract boilerplate by using named templates and library
    charts.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代表了 Helm 功能的核心。它们通过启用动态 YAML 生成，允许你创建各种不同的 Kubernetes 资源配置。基于 Go 模板的 Helm
    模板引擎包含多个内置对象，图表开发者可以基于这些对象构建图表，例如 `.Values` 和 `.Release` 对象。模板还提供了许多不同的函数，用于提供强大的格式化和操作功能，以及启用条件逻辑和循环的控制结构。除了渲染
    Kubernetes 资源外，模板还可以通过使用命名模板和库图表来抽象化模板代码。
- en: By incorporating the capabilities provided by templates, we were able to make
    small modifications to the Guestbook chart at the end of the chapter by enhancing
    the content of the values and the `deployment.yaml` chart template, which resulted
    in the ability to deploy the Guestbook application successfully. In the next chapter,
    we will continue to explore templates and enhance our Helm chart by learning about
    and leveraging lifecycle hooks.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合模板提供的功能，我们能够在本章末尾对 Guestbook 图表进行小的修改，通过增强值和 `deployment.yaml` 图表模板的内容，成功部署了
    Guestbook 应用程序。在下一章中，我们将继续探索模板，并通过学习和利用生命周期钩子来增强我们的 Helm 图表。
- en: Further reading
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about the basics behind creating Helm charts, consult the *Chart
    Template Developer’s Guide* page on the Helm documentation at [https://helm.sh/docs/chart_template_guide/](https://helm.sh/docs/chart_template_guide/).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于创建 Helm 图表的基础知识，请参考 Helm 文档中的*图表模板开发者指南*页面，网址：[https://helm.sh/docs/chart_template_guide/](https://helm.sh/docs/chart_template_guide/)。
- en: Questions
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'See if you can answer the following questions:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能回答以下问题：
- en: Which Helm templating construct can you take advantage of to generate repeating
    YAML portions?
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以利用哪种 Helm 模板构造来生成重复的 YAML 部分？
- en: What is the purpose of the `with` action?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`with` 动作的目的是什么？'
- en: What are the different built-in objects in Helm templates?
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm 模板中有哪些不同的内置对象？
- en: How does a Kubernetes resource template differ from a named template?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 资源模板与命名模板有什么不同？
- en: How does an application chart differ from a library chart?
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用图表与库图表有什么区别？
- en: What can a chart developer do to perform input validation?
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图表开发者可以做些什么来执行输入验证？
- en: What are some examples of different functions commonly used in Helm templates?
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Helm 模板中常用的不同函数有哪些例子？
- en: What is the difference between a template variable and a value?
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板变量和数值之间有什么区别？
