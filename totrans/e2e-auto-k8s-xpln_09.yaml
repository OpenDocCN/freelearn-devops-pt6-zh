- en: '*Chapter 7*: Extending and Scaling Crossplane'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*：扩展和扩展 Crossplane'
- en: The chapter will deep-dive into a few characteristics that make Crossplane extendable
    and scalable. The initial sections of the chapter will discuss developing new
    Crossplane providers for external resources that are not yet supported. We will
    examine the standards to be considered while designing a provider and the approaches
    available to make provider development comparatively comfortable. The following
    sections will cover configuration, the method to package the XR/Claim APIs, and
    how to test our XR. The final part of the chapter will cover different patterns
    supported by Crossplane to scale the control plane into a multi-tenant ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨一些使 Crossplane 可扩展和可扩展的特性。本章的初始部分将讨论为尚未支持的外部资源开发新的 Crossplane 提供者。我们将研究在设计提供者时需要考虑的标准以及可用的方法，使得提供者开发相对轻松。接下来的部分将涵盖配置、打包
    XR/Claim API 的方法，以及如何测试我们的 XR。本章的最后部分将介绍 Crossplane 支持的不同模式，如何将控制平面扩展为多租户生态系统。
- en: 'The following are the topics covered in the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Building a new provider
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建新的提供者
- en: XRD detailed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XRD 详细信息
- en: A framework to build a provider
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建提供者的框架
- en: Packaging and distribution of XR/Claim
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XR/Claim 的打包和分发
- en: Testing the configurations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试配置
- en: Multi-tenant control plane patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多租户控制平面模式
- en: Building a new provider
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建新的提供者
- en: Crossplane providers are nothing but a bundle of related **Managed Resources**
    (**MRs**). MRs are opinionated custom controllers and custom resources combined
    into one-to-one mapping with external resources, enabling us to manage those resources
    from Kubernetes. Onboarding new resources as MRs into an existing or new provider
    is a time-consuming process. The Crossplane community has worked hard to onboard
    most of the essential resources with Crossplane-native controllers in the last
    few years. With the recent development in the Crossplane community to auto-generate,
    Crossplane providers from Terraform provider enabled 100% resource coverage for
    all cloud resources. In addition to the provider for all primary cloud providers,
    we also have providers for other external resources, such as GitLab, Helm, SQL,
    and Argo CD. Visit the Crossplane website or Upbound Registry to explore the available
    providers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane 提供者仅仅是相关的**托管资源**（**MRs**）的集合。MR 是有观点的自定义控制器和自定义资源的组合，能够与外部资源进行一对一映射，使我们能够从
    Kubernetes 中管理这些资源。将新资源作为 MRs 纳入现有或新提供者是一个耗时的过程。在过去几年里，Crossplane 社区已努力将大多数重要资源与
    Crossplane 原生控制器结合起来。随着 Crossplane 社区最近在自动生成 Terraform 提供者的 Crossplane 提供者方面的进展，实现了
    100% 的云资源覆盖。除了所有主要云提供者的提供者外，我们还为其他外部资源提供了提供者，如 GitLab、Helm、SQL 和 Argo CD。访问 Crossplane
    网站或 Upbound Registry 探索可用的提供者。
- en: When we attempt to automate all application and infrastructure concerns, we
    might end up in a scenario where some external resources do not have a provider.
    You might decide to onboard a new provider yourself – for example, currently,
    there is no provider to manage Bitbucket repository resources. This section of
    the chapter will cover the essential aspects of the **Crossplane Resource Model**
    (**XRM**) required for new provider developers and explore the frameworks available
    to ease the development process. First, we will look at XRM, an opinionated subset
    of the **Kubernetes Resource Model** (**KRM**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试自动化所有应用程序和基础设施的问题时，我们可能会遇到某些外部资源没有提供者的情况。你可能决定自己添加一个新的提供者——例如，目前没有提供者来管理
    Bitbucket 仓库资源。本章的这一部分将介绍新提供者开发者所需的**Crossplane 资源模型**（**XRM**）的关键方面，并探讨可用的框架，以简化开发过程。首先，我们将了解
    XRM，这是一个对**Kubernetes 资源模型**（**KRM**）的有观点的子集。
- en: Tip
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Looking at the standards defined by the XRM to support the new provider development
    also enables us to understand existing MRs much better. It will further help us
    build our XR with the same XRM standards. Following these standards with the XRs
    will enable a uniform and easy understanding for the consuming teams.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 XRM 定义的标准以支持新的提供者开发，也使我们能够更好地理解现有的 MRs。它将进一步帮助我们使用相同的 XRM 标准构建我们的 XR。遵循这些标准与
    XR 一起使用将使消费团队对其有统一且容易理解的认识。
- en: The following section will dive into the details of the XRM specification.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将深入探讨 XRM 规范的细节。
- en: XRM detailed
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XRM 详细信息
- en: 'Being an extension of the KRM, XRM inherits most of the standards. As discussed
    in *Chapters 3* and *4*, Crossplane inherits many standards from the Kubernetes
    CRDs. The opinionated XRM standards over the basic Kubernetes standards define
    a uniform bridge between Kubernetes and the external resource. The XRM standards
    cover the following characteristics:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 KRM 的扩展，XRM 继承了大多数标准。如*第 3 章*和*第 4 章*所述，Crossplane 继承了许多来自 Kubernetes CRD
    的标准。基于 Kubernetes 标准的 XRM 独特标准定义了 Kubernetes 与外部资源之间的统一桥梁。XRM 标准涵盖了以下特点：
- en: Configuration fidelity
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置保真度
- en: Spec and status configuration
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规格与状态配置
- en: Naming the custom and external resources
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名自定义和外部资源
- en: Configuration ownership
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置所有权
- en: Sensitive input and output fields
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感的输入和输出字段
- en: We can dive into the details of each of these characteristics in the following
    sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中深入探讨这些特点的细节。
- en: Configuration fidelity
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置保真度
- en: The MR should have all possible fields available for configuration in the external
    resource API. It delivers every configuration combination at the control plane
    level. We should leave the abstractions to encode policy and the recipe creation
    for the platform developers via XR. Every field available for configuration in
    the external resource API should be present in the MR with the same name. Having
    the same name for the attributes will make it easy for users to compare and troubleshoot.
    Before starting a new provider’s development, it’s essential to ensure that the
    resources have well-defined CRUD APIs with granular controls. Control theory implementation
    cannot work well without such API standards. The following section will talk more
    about the API input and output.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MR 应该包含外部资源 API 中所有可用的配置字段。它在控制平面级别提供所有配置组合。我们应该将抽象留给通过 XR 为平台开发人员编码策略和创建配方。外部资源
    API 中每个可配置字段都应在 MR 中以相同名称呈现。属性使用相同名称将使用户更容易进行比较和故障排除。在开始新提供者的开发之前，必须确保资源具有明确定义的
    CRUD API 和细粒度的控制。没有这样的 API 标准，控制理论实现将无法有效运行。接下来的章节将进一步讨论 API 输入和输出。
- en: Spec and status configuration
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规格与状态配置
- en: '**Spec** is the configuration section that acts as the input of the API, and
    **status** is the attributes that are the output of the API. Let’s look at the
    spec section first. We can have three types of configuration knobs in the spec
    section – initial initialization, late initialization, and immutable configuration
    are the three types. Initial initializations are the configurations used while
    resource provisioning as configured by the users. Many of the parameters fall
    under this category. The database version in RDS provisioning can be an example
    of initial initializations. The late-initialization attributes are initialized
    with default values by the provider when the resource is created and later updated
    with the actual value, configured by the user in the reconciliation loop. It is
    typically helpful for external resource fields that are only available after creating
    the resource. Resource tagging with labels is the most common example.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**规格**是作为 API 输入的配置部分，**状态**是作为 API 输出的属性。首先来看规格部分。我们可以在规格部分中设置三种类型的配置选项——初始初始化、延迟初始化和不可变配置。初始初始化是用户在资源配置时使用的配置，许多参数都属于这一类。例如，RDS
    配置中的数据库版本就属于初始初始化。延迟初始化属性由提供者在资源创建时初始化为默认值，之后在调和循环中根据用户配置更新为实际值。这通常对那些在资源创建后才可用的外部资源字段非常有用。资源标签和标签是最常见的例子。'
- en: Immutable configurations are attributes whose value cannot be changed after
    initial provisioning – for instance, we cannot change the RDS region after creating
    the resource. Such configurations should be marked immutable in the MR. A reconciliation
    failure event is made if a user attempts to update the same. The mandatory fields
    required from Create and Update API operations should be marked as required fields
    in the MR. Optional fields should be of `pointer` type – a standard inherited
    from Kubernetes. We do this because some non-pointer types may resolve to zero
    when the user does not specify any value – for example, we should use `*bool`
    instead of `bool`. This concern is not applicable for a required field, as the
    value has to be specified by the user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变配置是指在初始配置后其值无法更改的属性——例如，在创建资源后我们无法更改RDS区域。这些配置应在MR中标记为不可变。如果用户尝试更新相同的配置，将触发协调失败事件。从创建和更新API操作中要求的必填字段应在MR中标记为必填字段。可选字段应为`pointer`类型——这是从Kubernetes继承的标准。我们之所以这样做，是因为一些非指针类型在用户未指定值时可能会解析为零——例如，我们应该使用`*bool`而不是`bool`。这个问题不适用于必填字段，因为用户必须指定值。
- en: Information
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Some fields can hold `struct` type value, as the underlying resource API supports
    it that way. We saw an example of this in the previous chapter. The `Policy` object
    from AWS IAM was taking a JSON policy as an input.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字段可以包含`struct`类型的值，因为底层资源API以这种方式支持它。我们在上一章中看到过一个例子，AWS IAM中的`Policy`对象就是作为输入接受JSON格式的策略。
- en: The *status* section represents the current state of the external resource.
    It holds attributes observed back from the external resource after every reconciliation
    loop. The fields that can be recreated if deleted are eligible candidates to be
    added to the *status* section. If a configuration and its sub-attribute represent
    another external resource, we should not include the relevant fields both in *spec*
    and *stats* – for example, we can also cocreate the subnet while creating Azure
    Virtual Network. In other words, the cloud API for Azure Virtual Network also
    has a section to define the subnet. From the Crossplane control pane, we should
    manage this as two unique resources with references.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态*部分表示外部资源的当前状态。它包含每次协调循环后从外部资源返回的观察到的属性。如果某个配置及其子属性代表另一个外部资源，则这些字段可以添加到*状态*部分。如果一个配置及其子属性可以在删除后重新创建，那么它们是合适的候选项。例如，我们在创建Azure虚拟网络时，也可以同时创建子网。换句话说，Azure虚拟网络的云API也有一个部分用于定义子网。在Crossplane控制面板中，我们应将其作为两个独立的资源进行管理，并进行引用。'
- en: Naming the custom and external resource
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义和外部资源的命名
- en: 'Each MR represents a unique kind, categorized under a specific API group, and
    it can exist under multiple versions. It is a behavior that is inherited from
    the Kubernetes standards. We have two important names when we create an object
    of a specific MR kind:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MR代表一种独特的类型，属于特定的API组，并且可以存在于多个版本中。这是一种从Kubernetes标准继承的行为。在创建特定MR类型的对象时，我们有两个重要的名称：
- en: The name of the resource within the control plane
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面内资源的名称
- en: The name of the resource in the external ecosystem
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部生态系统中资源的名称
- en: The resource name in the control plane can also be called the **Custom Resource**
    (**CR**) name. At the end of the day, be it MR, Claim, or XR, it’s an opinionated
    CR. When the user creates the MR/XR/Claim, they will provide a name parallel to
    the kind, version, and API group. This name will uniquely identify a resource
    within the cluster. If it’s an MR/XR, the name is unique throughout the cluster.
    In the case of a Claim, it’s unique per namespace. As these names are not autogenerated,
    the consuming teams may choose a random value. Such random names are challenging
    to cross-reference resources. A predictable naming strategy and labels will help
    resource references be straightforward. We can govern such standers in the configuration
    using admission controller tools such as **Open Policy Agent** (**OPA**).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面中的资源名称也可以称为**自定义资源**（**CR**）名称。归根结底，无论是MR、Claim还是XR，它们都是一种有意见的CR。当用户创建MR/XR/Claim时，他们会提供一个与类型、版本和API组并行的名称。这个名称将唯一标识集群中的一个资源。如果是MR/XR，则该名称在整个集群中唯一；如果是Claim，则它在每个命名空间内唯一。由于这些名称不是自动生成的，使用的团队可以选择一个随机值。这样的随机名称难以进行资源交叉引用。可预测的命名策略和标签将有助于资源引用变得直接明了。我们可以使用准入控制工具，如**Open
    Policy Agent**（**OPA**），在配置中管理这些标准。
- en: The external name is the resource’s name in the external ecosystem. The resource
    provider may or may not allow us to influence the name – for example, with the
    S3 bucket, we can determine the bucket’s name in AWS. We control this name through
    properties such as ID, name, or UID. If the user does not configure these attributes,
    the controller can autogenerate with the <`CR Name>-<Namespace>-<Random 5 character
    assigned by Kubernetes>` template. Amazon VPC is a typical example where we cannot
    influence the name. AWS generates a unique ID called `vpcID` as a name. If we
    wish to link our MR/XR/Claim to an existing external resource, we can add an `crossplane.io`/`external-name`
    annotation with the resource’s name to the external ecosystem. If a resource with
    a specified name does not exist, a new resource with the provided name is created.
    If it’s a resource where naming is not allowed, the final name is copied back
    to the `crossplane.io/external-name` attribute. When designing our new MR, we
    need to keep these naming behaviors in mind.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 外部名称是资源在外部生态系统中的名称。资源提供者可能允许或不允许我们影响这个名称——例如，在 S3 存储桶中，我们可以在 AWS 中确定存储桶的名称。我们通过诸如
    ID、名称或 UID 等属性来控制此名称。如果用户未配置这些属性，控制器可以使用<`CR Name>-<Namespace>-<Kubernetes 分配的随机
    5 个字符>`模板自动生成名称。Amazon VPC 是一个典型的例子，我们无法影响其名称。AWS 会生成一个唯一的 ID，称为 `vpcID`，作为名称。如果我们希望将
    MR/XR/Claim 链接到现有的外部资源，我们可以添加一个 `crossplane.io`/`external-name` 注释，将资源的名称与外部生态系统关联。如果指定名称的资源不存在，则会创建一个新资源，并使用提供的名称。如果是一个不允许命名的资源，则最终名称将复制回
    `crossplane.io/external-name` 属性。在设计新 MR 时，我们需要牢记这些命名行为。
- en: Information
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The KRM also recommends adding labels to the resources in the external environment
    with the kind, the CR name, and the provider name. It will help use cases such
    as identifying resources in the external environment, bulk operations based on
    the label, monitoring, and debugging. Note that all resources may not support
    such tags.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: KRM 还建议在外部环境中的资源上添加标签，包含资源类型、CR 名称和提供者名称。这将有助于诸如在外部环境中识别资源、基于标签的批量操作、监控和调试等用例。需要注意的是，并非所有资源都支持此类标签。
- en: Configuration ownership
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置所有权
- en: Some fields are relevant only to the control plane, both in the Spec and the
    Status section – for example, `ProviderConfigRef` in the Spec section indicates
    which credentials to use. We have other attributes that apply to the external
    resource only. There can be a conflict between these fields – for example, `CreationTimestamp`
    can exist at both the cluster and external resource levels. The KRM proposes the
    `spec.forProvider` and the `status.atProvider` sections as the owner for the external
    resource-related fields.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有些字段仅与控制平面相关，无论是在 Spec 部分还是在 Status 部分——例如，Spec 部分中的 `ProviderConfigRef` 指示使用哪个凭证。我们还有一些仅适用于外部资源的其他属性。这些字段之间可能会发生冲突——例如，`CreationTimestamp`
    可以同时存在于集群和外部资源级别。KRM 提出了 `spec.forProvider` 和 `status.atProvider` 部分作为外部资源相关字段的所有者。
- en: Sensitive input and output fields
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏感的输入和输出字段
- en: There can be sensitive information in both the input and the output fields of
    an MR. Configuring the database master password is an example of sensitive data
    in the MR input. The IAM AccessKey credential is an example of sensitive data
    in the MR output. It is not sensible to directly expose these field values in
    the MR/XR/Claim. In the case of sensitive information in the MR output, the Kubernetes
    Secret should store the data. The Crossplane community is also coming up with
    *vault* integrations to publish credentials. Similarly, input fields with secret
    information should be confidential references. The controller should fetch the
    value for such fields from the secret source. The naming convention for such a
    field in the MR should be `<Field name>SecretRef`. The `MasterPasswordSecretRef`
    field in the `RDSInstance` MR is an example of such a field.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MR 的输入和输出字段中可能包含敏感信息。配置数据库主密码就是 MR 输入中敏感数据的一个例子。IAM AccessKey 凭证是 MR 输出中敏感数据的一个例子。直接暴露这些字段值在
    MR/XR/Claim 中是不明智的。对于 MR 输出中的敏感信息，Kubernetes Secret 应该存储这些数据。Crossplane 社区也在制定
    *vault* 集成来发布凭证。类似地，包含机密信息的输入字段应为保密引用。控制器应从机密源获取这些字段的值。此类字段在 MR 中的命名约定应为 `<字段名称>SecretRef`。`RDSInstance`
    MR 中的 `MasterPasswordSecretRef` 字段就是这种字段的一个例子。
- en: KRM is an area that evolves continuously with new requirements. Creating KRM
    standards to support resource reference in a Terraform-generated Crossplane provider
    is in progress. Another example of an in-progress standard is using Crossplane
    only as an observer, especially for existing resources managed by other automation
    tools such as Helm and Terraform. Regularly checking the Crossplane Slack channel
    or release notes can keep us updated on evolving standards. This concludes the
    KRM discussion. In the next section, we will look at a couple of approaches available
    for provider development.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: KRM是一个不断发展的领域，具有新的需求。正在创建KRM标准，以支持Terraform生成的Crossplane提供者中的资源引用。另一个正在进行中的标准示例是仅将Crossplane用作观察者，特别是对于由其他自动化工具（如Helm和Terraform）管理的现有资源。定期查看Crossplane
    Slack频道或发布说明可以帮助我们保持对发展中的标准的了解。KRM的讨论到此为止。在接下来的部分中，我们将了解几种提供者开发的可用方法。
- en: Framework to build a provider
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建提供者的框架
- en: 'To bring down the cognitive load required to develop a new provider, the Crossplane
    community has identified a couple of comparatively painless ways, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了降低开发新提供者所需的认知负担，Crossplane社区已确定了几种相对无痛的方式，如下所示：
- en: '`ProviderConfig`, which can read credentials from the Kubernetes Secrets to
    manage external provider authentication and authorization. It also has a sample
    MR along with a controller. We can add all our new MRs and respective controllers
    with appropriate control theory implementation, using the CRUD APIs of the external
    resources. The video at [https://www.youtube.com/watch?v=dhuqH308Tc0](https://www.youtube.com/watch?v=dhuqH308Tc0)
    walks us through the provider development using provider template with a hands-on
    example.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProviderConfig`，可以从Kubernetes Secrets中读取凭证，以管理外部提供者的身份验证和授权。它还具有一个示例MR和一个控制器。我们可以使用外部资源的CRUD
    API，将所有新的MR及其相应的控制器与适当的控制理论实现添加到其中。[https://www.youtube.com/watch?v=dhuqH308Tc0](https://www.youtube.com/watch?v=dhuqH308Tc0)上的视频带我们通过一个实践示例，介绍了使用提供者模板进行提供者开发。'
- en: '`Create`, `Read`, `Update`, and `Delete` operations on the external resource.
    The configuration knobs from the MR are converted to JSON and used as input to
    the `CRUD` operations, using the Terraform CLI. Step-by-step instruction on how
    to develop such a provider is available at [https://github.com/crossplane/terrajet/blob/main/docs/generating-a-provider.md](https://github.com/crossplane/terrajet/blob/main/docs/generating-a-provider.md).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对外部资源的`创建`、`读取`、`更新`和`删除`操作。MR中的配置参数将转换为JSON，并作为输入用于使用Terraform CLI进行的`CRUD`操作。有关如何开发此类提供者的逐步指南，请参见[https://github.com/crossplane/terrajet/blob/main/docs/generating-a-provider.md](https://github.com/crossplane/terrajet/blob/main/docs/generating-a-provider.md)。
- en: Most of us may not have a requirement to develop a provider ourselves. Already,
    we have 100% resource coverage for all significant cloud provider resources. The
    Crossplane community will create a Terrajet Crossplane provider soon for every
    available Terraform provider, provided we have a less cognitive load. If you still
    have a requirement, this section will have guided you in the appropriate direction.
    Additionally, learning the KRM will have taken your understanding of MR to the
    next level. The book’s next section will cover ways to package and distribute
    the XRs/Claims.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人可能不需要自己开发一个提供者。现在，我们已经为所有主要云提供商的资源提供了100%的资源覆盖。Crossplane社区将很快为每个可用的Terraform提供商创建一个Terrajet
    Crossplane提供者，只要我们减少认知负担。如果你仍然有此需求，本节将引导你朝着正确的方向前进。此外，学习KRM将使你对MR的理解更上一层楼。接下来的章节将介绍如何打包和分发XR/Claims。
- en: Packaging and distribution of XR/Claim
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XR/Claim的打包与分发
- en: 'Crossplane configuration is a way to package our XR and Claim APIs. This packaging
    will help us reliably establish these APIs into any Kubernetes cluster where Crossplane
    is enabled. Crossplane configuration is primarily a composition distribution mechanism.
    Along with the distribution, we also can manage versions and dependencies. We
    may end up using Crossplane configuration for three different use cases:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane配置是一种打包我们XR和Claim API的方式。这种打包将帮助我们可靠地将这些API建立到任何启用了Crossplane的Kubernetes集群中。Crossplane配置主要是一种组合分发机制。随着分发，我们还可以管理版本和依赖关系。我们最终可能会使用Crossplane配置来处理三种不同的用例：
- en: It is useful when a large organization wants more than one control plane distributed
    across different team boundaries.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个大型组织希望在不同的团队边界之间分发多个控制平面时，它非常有用。
- en: It is also useful when someone is interested in building a control plane platform
    to sell as a product.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有人有兴趣构建一个控制平面平台并将其作为产品出售时，这也很有用。
- en: Open source developers who want to share their XR/Claim recipes with the community
    can also use the Crossplane configuration.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望与社区分享其 XR/Claim 配方的开源开发者也可以使用 Crossplane 配置。
- en: This section of the chapter will go through a hands-on journey so that you can
    learn Crossplane configurations. To start with, let’s look at packaging and distribution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分将带你进行一个实践之旅，让你学习 Crossplane 配置。首先，让我们来看一下打包和分发。
- en: Packaging and distribution
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包和分发
- en: 'With Crossplane configurations, we pack the compositions as an OCI-compliant
    image for distribution. Packing the compositions as configurations is a simple
    two three-step process:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Crossplane 配置时，我们将组合打包为符合 OCI 标准的镜像以进行分发。将组合打包为配置是一个简单的两三步过程：
- en: 'As a first step, create a `crossplane.yaml` file. It’s a simple YAML of `Configuration.meta.pkg.crossplane.io`
    kind. It defines the configuration name, the minimum-supported Crossplane version,
    and the dependencies. Both the provider and another configuration can be defined
    as dependencies. The following is the sample configuration YAML:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步，创建一个 `crossplane.yaml` 文件。这是一个简单的 `Configuration.meta.pkg.crossplane.io`
    类型的 YAML 文件。它定义了配置名称、最低支持的 Crossplane 版本以及依赖关系。提供者和其他配置都可以定义为依赖关系。以下是示例配置 YAML
    文件：
- en: '[PRE0]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example is available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/configuration](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/configuration).
    We will pack our last Amazon S3 bucket example in a configuration named `aws-bucket`,
    which is designed to work in any Crossplane version greater than or equal to v1.6.0\.
    The AWS Crossplane provider is added as a dependency for the package.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在 [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/configuration](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/configuration)
    中找到。我们将把最后一个 Amazon S3 桶示例打包为名为 `aws-bucket` 的配置，该配置设计为支持任何版本大于或等于 v1.6.0 的 Crossplane。AWS
    Crossplane 提供程序被添加为该包的依赖项。
- en: 'Next, we will execute the Crossplane CLI command build to generate the `configuration`
    package. We will run the command in the folder where we have the `crossplane.yaml`
    file and all our compositions. This step will output a file with a `**.xpkg` extension.
    Once the package is generated, the next step is to push the package into any OCI-compliant
    image registry. The Crossplane CLI `push` command will create an OCI-compliant
    image and move it into the registry. The following are the commands to build and
    push the configuration:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将执行 Crossplane CLI 命令 build 来生成 `configuration` 包。我们将在包含 `crossplane.yaml`
    文件和所有组合的文件夹中运行该命令。此步骤将输出一个具有 `**.xpkg` 扩展名的文件。一旦包生成，下一步是将包推送到任何符合 OCI 标准的镜像注册表中。Crossplane
    CLI 的 `push` 命令将创建一个符合 OCI 标准的镜像并将其移动到注册表中。以下是构建和推送配置的命令：
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you don’t have the Crossplane CLI set up, use the following two commands:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有设置 Crossplane CLI，请使用以下两个命令：
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Refer to the following screen for the installation in macOS:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下屏幕截图以了解 macOS 上的安装：
- en: '![Figure 7.1 – The Crossplane CLI install'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – Crossplane CLI 安装'
- en: '](img/B17830_07_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_07_01.jpg)'
- en: Figure 7.1 – The Crossplane CLI install
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Crossplane CLI 安装
- en: Note that the default image registry is the Docker hub. You should log in to
    the Docker hub in your CLI using `docker login`. You can see that the image is
    available at [https://hub.docker.com/repository/docker/arunramakani/aws-bucket](https://hub.docker.com/repository/docker/arunramakani/aws-bucket).
    You can also configure another image registry of your choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认的镜像注册表是 Docker Hub。你应该使用 `docker login` 在 CLI 中登录到 Docker Hub。你可以看到该镜像可在
    [https://hub.docker.com/repository/docker/arunramakani/aws-bucket](https://hub.docker.com/repository/docker/arunramakani/aws-bucket)
    上找到。你也可以配置其他你选择的镜像注册表。
- en: Information
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note that each composition and XRD combination is kept in different folders
    (`Bucket` and `IAM`). It will help the `build` command map and validate the composition
    and XRD combination. You will see a build error if all compositions and XRD are
    kept in the same folder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个组合和 XRD 组合都保存在不同的文件夹中（`Bucket` 和 `IAM`）。这将帮助 `build` 命令映射和验证组合和 XRD 组合。如果所有组合和
    XRD 都保存在同一文件夹中，你将看到构建错误。
- en: 'Refer to the following screenshot, where we create the configuration and OCI-compliant
    image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图，我们在其中创建了配置和符合OCI标准的镜像：
- en: '![Figure 7.2 – Package and push the OCI configuration image'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 打包并推送 OCI 配置镜像'
- en: '](img/B17830_07_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_07_02.jpg)'
- en: Figure 7.2 – Package and push the OCI configuration image
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 打包并推送 OCI 配置镜像
- en: Once the configuration is available as an image in the registry, we can install
    the `configuration` package into the Crossplane control plane and start using
    the composition. We will look at that in detail in the following section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置作为镜像存储在注册表中，我们可以将 `configuration` 包安装到 Crossplane 控制平面中，并开始使用组合。我们将在接下来的章节中详细讨论这一点。
- en: Installing and using the configuration
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和使用配置
- en: 'We have two options to install the configuration in the Crossplane ecosystem.
    The first option is to use the following Crossplane CLI:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方式可以在 Crossplane 生态系统中安装配置。第一种方式是使用以下 Crossplane CLI：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The CLI takes the name and image as two parameters for installation. It will
    even install the dependent AWS provider that we defined. Once you have the configuration
    installed, look at the details of the configuration and ConfigurationRevision
    with the following command. Every configuration update will create a new ConfigurationRevision,
    and only one revision will be active at a given time:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 将名称和镜像作为两个参数进行安装。它甚至会安装我们定义的依赖 AWS 提供者。一旦配置安装完成，可以使用以下命令查看配置和 ConfigurationRevision
    的详细信息。每次配置更新都会创建一个新的 ConfigurationRevision，并且在任何给定时间只有一个修订版是活动的：
- en: '![Figure 7.3 – Install configuration'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 安装配置'
- en: '](img/B17830_07_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_07_03.jpg)'
- en: Figure 7.3 – Install configuration
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 安装配置
- en: 'The second way to install configuration is using the `Configuration.pkg.crossplane.io`
    kind YAML. Note that there are two configuration kinds in the Crossplane core
    with different API groups. The first API group, `meta.pkg.crossplane.io`, is used
    for building the `Configuration` package. The second API group, `pkg.crossplane.io`,
    is used for installing the `Configuration` package. The following is a sample
    configuration YAML:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种安装配置的方法是使用 `Configuration.pkg.crossplane.io` 类型的 YAML。请注意，Crossplane 核心中有两种不同
    API 组的配置类型。第一个 API 组 `meta.pkg.crossplane.io` 用于构建 `Configuration` 包。第二个 API 组
    `pkg.crossplane.io` 用于安装 `Configuration` 包。以下是一个示例配置 YAML：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have not used the `PackagePullPolicy`, `RevisionActivationPolicy`, and `RevisionHistoryLimit`
    attributes in the CLI. `PackagePullPolicy` works very similar to `ImagePullPolicy`
    with other Kubernetes kinds. `RevisionActivationPolicy` can hold either `Automatic`
    or `Manual`, with `Automatic` as the default value. When it is automatic, the
    new XRs from the package are installed, XRs from the old package will become inactive,
    and the new XRs will become active to take charge of the resource reconciliation.
    You will see two ConfigurationRevisions after upgrading the `Configuration` package
    by one version increment. When a new ConfigurationRevision is created, you can
    also see that CompositionRevision is made for the changing composition. Refer
    to the following screenshot with one active and one inactive ConfigurationRevision:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CLI 中，我们没有使用 `PackagePullPolicy`、`RevisionActivationPolicy` 和 `RevisionHistoryLimit`
    属性。`PackagePullPolicy` 的工作方式与其他 Kubernetes 类型的 `ImagePullPolicy` 类似。`RevisionActivationPolicy`
    可以是 `Automatic` 或 `Manual`，默认为 `Automatic`。当设置为自动时，包中的新 XRs 将被安装，旧包中的 XRs 将变为非活动状态，新的
    XRs 将变为活动状态并负责资源的协调。当升级 `Configuration` 包时，你会看到两个 ConfigurationRevisions，每次版本递增都会创建一个新的
    ConfigurationRevision。同时，也可以看到 CompositionRevision 伴随着组合的变化而被创建。请参考以下截图，其中有一个活动的和一个非活动的
    ConfigurationRevision：
- en: '![Figure 7.4 – Configuration update and revision'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 配置更新和修订版'
- en: '](img/B17830_07_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_07_04.jpg)'
- en: Figure 7.4 – Configuration update and revision
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 配置更新和修订版
- en: If we have set `RevisionActivationPolicy` in `Manual` mode, we must edit the
    revision manually to make it `Active`. The `RevisionHistoryLimit` field is the
    maximum number of revisions that Crossplane will keep track of. The following
    section will investigate ways to test Crossplane configuration.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `RevisionActivationPolicy` 设置为 `Manual` 模式，我们必须手动编辑修订版并将其设为 `Active`。`RevisionHistoryLimit`
    字段是 Crossplane 跟踪的最大修订版数量。以下章节将探讨测试 Crossplane 配置的方法。
- en: Testing the configurations
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试配置
- en: The platform developers require a way to test the XRs and configurations they
    develop. Also, many teams might be interested in practicing test-driven development.
    This section of the book will explore **KUbernetes Test TooL** (**KUTTL**) as
    the test tool for practicing test-driven development and configuration-testing
    pipelines. KUTTL is a declarative test tool that tests for the best Kubernetes
    controller states and CRDs. The critical feature of KUTTL is writing declarative
    test cases against the CR. Being able to work well with CRs and CRDs, KUTTL can
    also work well with XR, XRDs, and Claim. First, we will look at the basic installation
    and setup required.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 平台开发者需要一种方法来测试他们开发的 XRs 和配置。此外，许多团队可能有兴趣实践测试驱动开发。本书的这一部分将探讨 **KUbernetes Test
    TooL**（**KUTTL**）作为测试驱动开发和配置测试流水线的测试工具。KUTTL 是一个声明式测试工具，用于测试最佳的 Kubernetes 控制器状态和
    CRDs。KUTTL 的关键特性是针对 CR 编写声明式测试用例。由于 KUTTL 能够很好地与 CR 和 CRDs 配合使用，它也能够与 XR、XRDs
    和 Claim 良好配合。首先，我们将了解所需的基本安装和设置。
- en: Installing KUTTL
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 KUTTL
- en: 'The KUTTL CLI is an extension to kubectl. To install KUTTL, we will first install
    Krew. This is a kubectl plugin manager that helps discover, install, and update
    kubectl plugins. To install on a macOS/Linux operating system, run the following
    script:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: KUTTL CLI 是 kubectl 的扩展。要安装 KUTTL，我们首先需要安装 Krew。这是一个 kubectl 插件管理器，帮助发现、安装和更新
    kubectl 插件。要在 macOS/Linux 操作系统上安装，请运行以下脚本：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set the path, making sure we can access Krew in the terminal, using the following
    command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置路径，确保我们可以在终端中访问 Krew，使用以下命令：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The instruction to install Krew in other operating systems is different. To
    download and install Krew on different operating systems, refer to [https://krew.sigs.k8s.io/docs/user-guide/setup/install/](https://krew.sigs.k8s.io/docs/user-guide/setup/install/).
    Once you have Krew installed, the KUTTL set is a simple step – executing the following
    instruction:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他操作系统上安装 Krew 的指令是不同的。要在不同操作系统上下载并安装 Krew，请参考 [https://krew.sigs.k8s.io/docs/user-guide/setup/install/](https://krew.sigs.k8s.io/docs/user-guide/setup/install/)。安装
    Krew 后，KUTTL 设置只需一个简单的步骤——执行以下指令：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After executing the preceding command, you will have KUTTL successfully installed
    in your local environment. The next step is to look at the anatomy of the KUTTL
    project and the basics of setting up tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，您将在本地环境中成功安装 KUTTL。下一步是了解 KUTTL 项目的结构以及设置测试的基础。
- en: KUTTL test setup
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KUTTL 测试设置
- en: 'There are three critical components to the KUTTL setup. `TestSuite.kuttl.dev`
    is the first component and the core configuration. It holds the configuration
    for the entire test suite. The following is a sample `TestSuite` configuration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: KUTTL 设置有三个关键组件。`TestSuite.kuttl.dev` 是第一个组件，也是核心配置。它包含整个测试套件的配置。以下是一个 `TestSuite`
    配置示例：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the name of the `TestSuite` file should be `kuttl-test.yaml` to enable
    the KUTTL CLI to look for the test configurations. `StartKIND`, `KindContext`,
    and `SkipClusterDelete` are some of the configurations that defined the Kubernetes
    cluster for testing. We use an existing Kubernetes cluster from GCP in the preceding
    example. With `KindContext`, I have specified the name of the Kubernetes cluster
    from kubeconfig. Instead, we can create a new kind Kubernetes cluster for testing
    and destroy the same at the end of testing. It will be beneficial for test pipelines.
    Refer to KUTTL documentation to understand full cluster configuration options.
    The `Commands` section of the `TestSuite` file will enable us to run all initialization.
    We are initializing `ProviderConfig` in our hands-on example. Look at the complete
    example at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/test-configuration](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/test-configuration).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`TestSuite` 文件的名称应该是 `kuttl-test.yaml`，以便 KUTTL CLI 查找测试配置。`StartKIND`、`KindContext`
    和 `SkipClusterDelete` 是定义 Kubernetes 集群用于测试的配置项。在上面的示例中，我们使用了来自 GCP 的现有 Kubernetes
    集群。通过 `KindContext`，我指定了 kubeconfig 中 Kubernetes 集群的名称。我们也可以创建一个新的 kind Kubernetes
    集群进行测试，并在测试结束时销毁它。这对于测试流水线非常有用。参考 KUTTL 文档以了解完整的集群配置选项。`TestSuite` 文件的 `Commands`
    部分将使我们能够执行所有初始化。在我们的实践示例中，我们正在初始化 `ProviderConfig`。完整示例请查看 [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/test-configuration](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter07/Hand-on-examples/test-configuration)。
- en: Note that our `ProviderConfig` does not carry any actual AWS credentials. `ProviderConfig`
    is available in the `init` folder in the Git repository. We initialize `ProviderConfig`
    to ensure that the Crossplane will not complain about missing configuration. Remember
    that scope of testing is to validate whether our XR and Claim are correctly converted
    into an MR. In other words, we will be testing our composition logic. If an MR
    will create the resource as expected, it is the scope of provider testing. If
    we use a dynamic kind Kubernetes cluster, we should install Crossplane, AWS provider,
    and the configuration as part of the initialization. It is out of scope for us,
    as we use an existing cluster.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的 `ProviderConfig` 并不包含任何实际的 AWS 凭证。`ProviderConfig` 位于 Git 仓库的 `init`
    文件夹中。我们初始化 `ProviderConfig` 是为了确保 Crossplane 不会因为缺少配置而报错。请记住，测试的范围是验证我们的 XR 和
    Claim 是否正确转换为 MR。换句话说，我们将测试我们的组合逻辑。如果 MR 按预期创建资源，那是供应商测试的范围。如果我们使用动态类型的 Kubernetes
    集群，我们应该在初始化过程中安装 Crossplane、AWS 提供程序以及相关配置。由于我们使用的是现有集群，这不在我们的测试范围内。
- en: Tip
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Provide the actual cloud credentials in `ProviderConfig` if you wish to do end-to-end
    testing, or if your test case depends on some status field that we will get back
    from the external resource.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望进行端到端测试，或者你的测试用例依赖于我们从外部资源返回的一些状态字段，请在 `ProviderConfig` 中提供实际的云凭证。
- en: The second key component is the test folders and test steps. KUTTL will scan
    for the test case from all the subfolders of the `TestDirs` folder specified in
    the `TestSuite` file. Each folder is a test case. In our case, we have two test
    folders. The `bucket-failure` folder holds a test case that will fail, and `bucket-success`
    contains a test case that will pass. Each test case can have multiple steps executed
    in a specified order. KUTTL can recognize the step number from the filename prefix.
    Note that the files inside the test case folder (in the Git example) have a numerical
    prefix.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键组件是测试文件夹和测试步骤。KUTTL 会扫描 `TestSuite` 文件中指定的 `TestDirs` 文件夹的所有子文件夹中的测试用例。每个文件夹就是一个测试用例。在我们的例子中，有两个测试文件夹。`bucket-failure`
    文件夹包含一个会失败的测试用例，`bucket-success` 文件夹包含一个会成功的测试用例。每个测试用例可以有多个按指定顺序执行的步骤。KUTTL 可以从文件名的前缀识别步骤的编号。请注意，测试用例文件夹中的文件（在
    Git 示例中）有一个数字前缀。
- en: 'The final section is to implement the individual test step. Each test step
    can have the configuration we apply in the Kubernetes cluster (XR/Claim) and the
    respective assert configurations (MR). The asserts do not have to define the whole
    MR but can have the fields we want to validate. We can define multiple assert
    configurations in a single assert step file. In the preceding example, we apply
    the bucket Claim and validate whether the composition patches the bucket name
    correctly (refer to the `bucketwithcredential` folder from the Git repository
    example). We can even assert and validate status fields in the MR, provided with
    a valid `ProviderConfig`. Execute the test from the root folder where we have
    the `kuttl-test.yaml` file with the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是实现单个测试步骤。每个测试步骤可以包含我们在 Kubernetes 集群中应用的配置（XR/Claim）以及相应的断言配置（MR）。这些断言不必定义整个
    MR，而是可以包含我们想要验证的字段。我们可以在一个断言步骤文件中定义多个断言配置。在前面的例子中，我们应用了 bucket Claim，并验证组合是否正确地修补了
    bucket 名称（参考 Git 仓库中的 `bucketwithcredential` 文件夹）。我们甚至可以断言并验证 MR 中的状态字段，只要提供有效的
    `ProviderConfig`。通过以下命令从根文件夹执行测试，该文件夹中有 `kuttl-test.yaml` 文件：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that the `bucket-failure` folder assert configuration has a different
    bucket name different from the bucket Claim; hence, the test case will fail. Refer
    to the following screenshot, where one test case fails and the other succeeds:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`bucket-failure` 文件夹的断言配置中的 bucket 名称与 bucket Claim 中的名称不同，因此测试用例会失败。请参见以下截图，其中一个测试用例失败，另一个测试用例成功：
- en: '![Figure 7.5 – The KUTTL test case'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – KUTTL 测试用例'
- en: '](img/B17830_07_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_07_05.jpg)'
- en: Figure 7.5 – The KUTTL test case
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – KUTTL 测试用例
- en: Information
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We just covered the fundamental aspects of KUTTL. To explore the tool in more
    detail, visit [https://kuttl.dev/docs/](https://kuttl.dev/docs/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了 KUTTL 的基本内容。要更详细地了解这个工具，请访问 [https://kuttl.dev/docs/](https://kuttl.dev/docs/)。
- en: The following section will discuss the possibility of using KUTTL as a **Test-Driven
    Development** (**TDD**) tool for XR/Claim development.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将讨论将 KUTTL 用作 **测试驱动开发**（**TDD**）工具进行 XR/Claim 开发的可能性。
- en: TDD
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD
- en: 'TDD is a software development practice where developers develop test cases
    first from the requirements and then write code that passes the test cases. It
    is an iterative model of development where we start with failing test cases and
    slowly evolve code to pass. There are a lot of benefits to using TDD, including
    clean code and full test coverage. It’s beyond the scope of this book to look
    at all the benefits. This section will focus on using TTD in XR development. The
    following figure represents the iterative TDD process for an XR/Claim:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）是一种软件开发实践，开发者首先从需求中编写测试用例，然后编写通过测试用例的代码。这是一种迭代开发模型，我们从失败的测试用例开始，逐步演化代码使其通过测试。使用
    TDD 有很多好处，包括干净的代码和全面的测试覆盖率。讨论所有的好处超出了本书的范围。本节将重点讨论在 XR 开发中使用 TDD。下图表示了 XR/Claim
    的迭代 TDD 过程：
- en: '![Figure 7.6 – TDD for XR/Claim'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – XR/Claim 的 TDD'
- en: '](img/B17830_07_06.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_07_06.jpg)'
- en: Figure 7.6 – TDD for XR/Claim
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – XR/Claim 的 TDD
- en: 'The following steps describe the stages in TDD for XR/Claim:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了 XR/Claim 的 TDD 阶段：
- en: Define the API scope and boundary using the trade-off analysis discussed in
    the previous chapter.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一章讨论的权衡分析来定义 API 范围和边界。
- en: Create the XR/Claim API specification using the XRD configuration, using the
    scope and boundary definition. It will be a requirement from the perspective of
    API consumers.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 XRD 配置创建 XR/Claim API 规范，采用范围和边界定义。这将是 API 消费者的一个要求。
- en: Define the final MR state of each resource in the composition. This only has
    an API implementation requirement. Organization policy and compliance requirements
    will become part of the implementation requirement.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组合中定义每个资源的最终 MR 状态。这仅有 API 实现要求。组织政策和合规性要求将成为实现要求的一部分。
- en: Develop the KUTTL test cases for all the requirements defined in *Steps 2* and
    *3*. Run the test cases to see that all instances fail.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 *步骤 2* 和 *3* 中定义的所有需求开发 KUTTL 测试用例。运行测试用例，查看所有实例均未通过。
- en: Develop the compositions and rerun the test cases. Iterate until all the test
    cases succeed.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发组合并重新运行测试用例。迭代直到所有测试用例成功。
- en: Refine the API scope and boundary requirements to continue the cycle.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完善 API 范围和边界需求，继续循环。
- en: We can combine KUTTL with other Kubernetes ecosystem tools such as Skaffold
    to make our TDD easy. This concludes our discussion on testing the configuration/composition.
    In the final section of the chapter, we will cover the different ways to scale
    Crossplane into a multi-tenant ecosystem.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 KUTTL 与 Kubernetes 生态系统中的其他工具（如 Skaffold）结合使用，使 TDD 更加简便。本节讨论完了配置/组合的测试。在本章的最后一节，我们将讨论如何将
    Crossplane 扩展为多租户生态系统。
- en: Multi-tenant control plane patterns
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多租户控制平面模式
- en: 'Typically, multiple product teams will have to access the control plane platform
    to take advantage of the composition recipes built by the platform engineers.
    The section covers different patterns that Crossplane supports to enable a multi-tenant
    control plane. The following are the key two patterns Crossplane users can choose
    from:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，多个产品团队必须访问控制平面平台，以利用平台工程师构建的组合配方。本节将介绍 Crossplane 支持的不同模式，以启用多租户控制平面。以下是
    Crossplane 用户可以选择的两个关键模式：
- en: Multi-tenancy with a single cluster
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个集群的多租户
- en: Multi-tenancy with multiple clusters
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多租户与多个集群
- en: Multi-tenancy with a single cluster
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单个集群的多租户
- en: 'Multi-tenancy with a single cluster is a pattern where all the product teams
    use a single Crossplane control plane. The control plane is configured to enable
    multi-tenancy in the same cluster itself. The following facts describe what this
    setup will look like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个集群的多租户是一种模式，在这种模式下，所有的产品团队使用一个单一的 Crossplane 控制平面。控制平面被配置为支持在同一集群内实现多租户。以下事实描述了这种设置的样子：
- en: The product teams are isolated with the namespace Kubernetes construct. Each
    product team should be assigned a namespace.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品团队通过命名空间 Kubernetes 构造进行隔离。每个产品团队应分配一个命名空间。
- en: As mentioned previously in an earlier discussion about the difference between
    XR and Claim, Claims are namespace-scoped and the XR is of cluster scope.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，XR 和 Claim 之间的区别，Claim 是命名空间范围的，而 XR 是集群范围的。
- en: Also, we discussed earlier that XRs are meant to be used only by the platform
    team.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们之前提到过，XR 仅应由平台团队使用。
- en: Precise RBAC can be applied to the Claim API in the given namespace, based on
    team member roles and the API group.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确的 RBAC 可以应用于给定命名空间中的 Claim API，基于团队成员角色和 API 组。
- en: An organization can implement RBAC, either using the default Kubernetes RBAC
    API or a general-purpose policy engine, such as the OPA (Gatekeeper).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织可以实现RBAC，使用默认的Kubernetes RBAC API，或者使用通用的策略引擎，如OPA（Gatekeeper）。
- en: 'In addition to the preceding points, each team should have different external
    provider credentials to track the usage, cost, monitoring, audit, and so on. It
    can be easily achieved using the ProviderConfig named after the namespaces. We
    should also be patching the ProviderConfigRef from the Claims namespace reference
    in the composition. The following figure shows the architecture that can help
    you visualize the single cluster multi-tenancy:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述要点外，每个团队还应拥有不同的外部提供商凭证，以便跟踪使用情况、成本、监控、审计等。这可以通过使用以命名空间命名的ProviderConfig轻松实现。我们还应当在组合中补丁来自Claims命名空间引用的ProviderConfigRef。下图展示了帮助你可视化单集群多租户架构：
- en: '![Figure 7.7 – The single cluster multi-tenancy'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 单集群多租户'
- en: '](img/B17830_07_07.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_07_07.jpg)'
- en: Figure 7.7 – The single cluster multi-tenancy
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 单集群多租户
- en: 'The following is the code snippet referring to the pattern:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是参考该模式的代码片段：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Under each resource in the composition, patch `ProviderConfigRef` with the
    Claims namespace dynamically:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合中的每个资源下，动态地补丁`ProviderConfigRef`，指向Claims命名空间：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The following section will look at the multi-tenancy setup with multiple clusters.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将探讨多个集群下的多租户设置。
- en: Multi-tenancy with multiple clusters
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多租户与多个集群
- en: 'Some organization setups may have multiple independent business units with
    different infrastructure requirements, such as monitoring, cost management, and
    compliance. We might have the condition to set up multiple Crossplane control
    planes. The following two basic patterns in Crossplane will support such an environment:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织设置可能有多个独立的业务单元，具有不同的基础设施需求，如监控、成本管理和合规性。我们可能需要设置多个Crossplane控制平面。以下两种基本模式将支持这种环境：
- en: '**Configuration**: We can leverage the XR/Claim packaging mechanism discussed
    earlier in this chapter to develop and distribute XR/Claim reliably.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：我们可以利用本章前面讨论的XR/Claim打包机制来可靠地开发和分发XR/Claim。'
- en: '**Nested crossplane**: One central Crossplane control plane can manage other
    Kubernetes clusters for each business unit. We can use the Helm provider from
    the central Crossplane cluster to set up Crossplane across the other clusters.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套Crossplane**：一个中央Crossplane控制平面可以管理每个业务单元的其他Kubernetes集群。我们可以从中央Crossplane集群使用Helm提供者，在其他集群中设置Crossplane。'
- en: We can also attempt multiple Crossplane setups within a single cluster, one
    for every tenant/team. We can try this with tools such as `vcluster` or similar
    tools. It is an advanced pattern. What we attempt here is Kubernetes inside another
    Kubernetes. If you have a similar use case, try the setup using vcluster. This
    concludes the multi-tenancy discussion.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试在单个集群中进行多个Crossplane设置，每个租户/团队一个。我们可以尝试使用`vcluster`等工具。它是一个高级模式。我们在这里尝试的是在一个Kubernetes内部运行另一个Kubernetes。如果你有类似的用例，可以尝试使用vcluster进行设置。这也结束了多租户的讨论。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter discussed various aspects that extend and scale Crossplane. We
    have taken a step-by-step journey to learn Crossplane from its basics to many
    advanced concepts in the last few chapters. We covered many nuances of building
    a state-of-the-art control plane for automation using Kubernetes and Crossplane.
    This takes us to the end of part 2 of the book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了扩展和扩展Crossplane的各个方面。在过去几章中，我们已经逐步学习了从Crossplane的基础知识到许多高级概念。我们涵盖了使用Kubernetes和Crossplane构建现代化控制平面的许多细节。这也标志着本书第二部分的结束。
- en: The book’s third part will explore an approach to managing configuration along
    with some configuration management tools and recipes. It will be a journey to
    unify application and infrastructure automation with Crossplane and other configuration
    management tools.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的第三部分将探讨一种配置管理方法以及一些配置管理工具和技巧。这将是一次将应用程序和基础设施自动化与Crossplane及其他配置管理工具统一的旅程。
