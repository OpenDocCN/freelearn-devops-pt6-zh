- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Developer Productivity with Tanzu Application Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of enterprise software, we have the concept of *Big A* applications
    and *Little A* applications. *Big A* might be a giant corporate billing system
    with hundreds of components, whereas a *Little A* application might be a single
    job that pulls records from a mainframe and writes them to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there are *Big P* and *Little P* problems that need to be solved
    when delivering software in the enterprise. An example of a *Little P* problem
    I faced today was moving some container images from the VMware corporate container
    registry to a customer’s private registry so they could use them internally without
    having to allow egress to the internet. On the other hand, some *Big P* problems
    you might face in the enterprise space might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a company’s developers measurably more productive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting applications into production quickly, safely, and consistently – minimizing
    toil and blockers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting developers, operators, and security specialists all pointed in the same
    direction and focused on the same problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivering applications to modern container platforms such as Kubernetes when
    developers have limited exposure and experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coincidentally, those are exactly the four problems we talk about when we discuss
    **Tanzu** **Application Platform**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why should I use Tanzu Application Platform?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The building blocks of Tanzu Application Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day 1 – installing and configuring Tanzu Application Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day 2 – deploying applications to Tanzu Application Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day 3 – common operational activities on Tanzu Application Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what we’re going to accomplish in this chapter, let’s jump
    in and talk about the reasons you and your team might need to use Tanzu Application
    Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Why should I use Tanzu Application Platform?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I mentioned in the chapter introduction, there are small problems that can
    be encountered when writing software, such as efficiently sorting a list in place
    or moving streaming data from a legacy database to the latest NoSQL offering,
    and there are big problems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer productivity**: Enterprise software only exists because big companies
    hire software developers to write the software that they use to bring in revenue
    and differentiate the company from their competition. Companies with good platforms
    can focus their developers’ time and effort on meaningful tasks that directly
    affect the company’s bottom line. This makes the developers feel valued. Those
    without a good platform grow to view their developers as an expensive cost center,
    sparking a painful downward spiral into low morale and low productivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getting software into production**: If you haven’t written software for a
    large company, you may be surprised at how difficult it is to get a piece of software
    into production. There are often dozens of manual, tedious tasks to check all
    the boxes for security, compliance, and downstream risk. The enlightened players
    in this space have figured out how to automate away the tedium, building these
    steps into an automated process, abstracted away from developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Align developers, operators, and security toward the same goal**: By building
    compliance, governance, best practices, and security into a streamlined automated
    process, you eliminate the friction often found between developers, operators,
    and security specialists. While the operators push back against any sort of change,
    security specialists want releases scrutinized down to the last bit. This can
    swallow up weeks of time and effort on a development team while crushing morale.
    By building checks and controls into the software supply chain, operators and
    security specialists can rest easy that their guidance is being followed, while
    developers are freed up to deliver software at a consistently high velocity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**On-ramp to Kubernetes**: Enterprise adoption of Kubernetes is on an upswing
    and shows few signs of slowing down. Kubernetes is a very powerful platform that
    enables some big outcomes. However, it comes with considerable complexity and
    a steep learning curve. Tanzu Application Platform abstracts away some of this
    complexity, allowing software teams to leverage Kubernetes while benefitting from
    some abstractions that simplify the path to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, Tanzu Application Platform is an end-to-end supply chain for delivering
    software to production safely, securely, and reliably at scale. Now that we know
    at a high level what it is, let’s proceed to break it down and look at the individual
    components.
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of Tanzu Application Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tanzu Application Platform is an opinionated set of technologies working together
    to deliver significant outcomes for platform operators, developers, and security
    professionals. Covering each component in depth would require more space than
    this chapter allows, so I encourage you to visit the official documentation for
    more detail on any of these components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram that follows offers a high-level view of Tanzu Application Platform:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.1 – Tanzu Application Platform components](img/B18145_08_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Tanzu Application Platform components
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram attempts to group and categorize the various components. Here’s
    a breakdown of the products that follow the hierarchy from the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tanzu` CLI command or a `workload.yaml` file. Developers can deploy workloads
    directly to a Kubernetes cluster from their IDEs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live Update**: Developers can make a local change on their workstations and
    see it running live on a Kubernetes cluster in seconds. This uses *Tilt* under
    the covers to sync the local code base with the workload running remotely on Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote Debug**: Sometimes log messages just aren’t sufficient and you need
    to step through your code, examining local and wider-scoped variables in the process.
    As we just mentioned, this is straightforward on a local workstation, but in a
    modern environment, this often isn’t sufficient to debug an issue occurring in
    Kubernetes. Directly debugging a workload on Kubernetes often entails a messy
    array of startup parameters and port forwards. This plugin automates the whole
    process, giving developers a one-click solution to remote debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running Workloads**: With this VS Code-only feature, developers get a panel
    inside their IDE to visualize all workloads running in their current Kubernetes
    context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "**Tanzu Application Platform GUI**: The Tanzu Application GUI, based on the\
    \ *Backstage* open source project, is a central dashboard for Tanzu Application\
    \ Platform. It provides some out-of-the-box functionality that it gets from Backstage,\
    \ as well as a number of very useful custom plugins that are only available to\
    \ Tanzu Application Platform users. Here’s a quick peek at what you can expect\
    \ to see in the Tanzu Application Platform GUI, starting with a visual overview\
    \ of the UI and its layout:![Figure \uFEFF8.2 – Tanzu Application Platform GUI](img/B18145_08_02.jpg)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 8.2 – Tanzu Application Platform GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the screen you’ll see when first accessing the Tanzu Application GUI.
    The following is a breakdown of the GUI’s components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Organization Catalog**: Tanzu Application Platform GUI provides a central
    repository for an entire organization to publish and catalog their software. If
    we dig into **tanzu-java-web-app** in the preceding screenshot, we’ll see the
    following screen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.3 – Tanzu Application Platform GUI catalog entry](img/B18145_08_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Tanzu Application Platform GUI catalog entry
  prefs: []
  type: TYPE_NORMAL
- en: 'The catalog entry allows teams to provide a “one-stop shop” for their application’s
    source code, tech docs, API definition, and any relevant links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TechDocs**: This is a backstage plugin that allows development teams to create
    documentation in Markdown format, and will present that documentation as part
    of the application’s entry in the organization catalog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime Resources Visibility**: Users of other Tanzu products, such as *Tanzu
    Application Service* ([https://tanzu.vmware.com/application-service](https://tanzu.vmware.com/application-service)),
    have benefitted from being able to see all their runtime resources in one place.
    The Tanzu team brought this to Tanzu Application Platform GUI as well. Anything
    associated with a registered catalog entity will be visible here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Live View**: This feature works with other components, such as
    *Convention Service*, to provide deep insight into the runtime state of a running
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Accelerator**: This feature, which we covered in depth in [*Chapter
    2*](B18145_02.xhtml#_idTextAnchor033)*, Developing Cloud-Native Applications*,
    is part of Tanzu Application Platform GUI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Documentation**: This feature, which we covered in depth in [*Chapter
    5*](B18145_05.xhtml#_idTextAnchor093)*, Defining and Managing Business APIs*,
    is also part of Tanzu Application Platform GUI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supply Chain Choreographer Visualization**: Supply Chain Choreographer, which
    lies at the heart of Tanzu Application Platform, is just what it sounds like,
    a chained set of inputs and outputs that guide an application from its source
    to a running application in a production environment. This plugin provides a compelling
    visualization of those supply chains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supply Chain Choreographer**: If you think of Tanzu Application Platform
    GUI as the “eyes and ears” of the platform, then Supply Chain Choreographer would
    be its beating heart. Supply Chain Choreographer is based on the open source *Cartographer*
    project ([https://github.com/vmware-tanzu/cartographer](https://github.com/vmware-tanzu/cartographer)),
    and it allows platform operators and software architects to preconfigure and pre-approve
    multiple paths to production. There might be a path to production for Spring Boot
    APIs that fall under PCI controls and another path to production for event-driven
    data processing applications. Just as was the case with Tanzu Application Platform
    GUI, Supply Chain Choreographer is a feature of the platform that bundles and
    contains other features. Here’s a list of some of the platform features that fall
    within the realm of Supply Chain Choreographer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live View Convention Service**: One of the features mentioned in our discussion
    of Tanzu Application Platform GUI was the *Application Live View* GUI plugin.
    For this plugin to work, an application needs to expose its inner workings via
    an opinionated, well-known API. A naïve approach to this might be to require all
    application teams to implement this themselves, by bringing in a particular version
    of Spring Boot Actuator with its own web listener running on a specific port with
    specific endpoint naming conventions. This would result in added burden on the
    development teams as well as the potential for misconfiguration. A better approach
    would be to modify every workload as it passes through the supply chain to expose
    the inner workings in a consistent, opinionated way. That’s exactly what this
    service does. It sits in the supply chain and adds consistent Java or .NET Core
    configuration parameters to every eligible application that uses the supply chain.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cartographer Conventions**: Application Live View isn’t the only feature
    for which supply chain conventions are a good fit. Any features that a platform
    operator or a DevOps lead wants to apply across the entire portfolio are a good
    fit here. One example is labeling all application artifacts with the owner of
    the project. Another might be to configure sane upper and lower limits to an app
    that auto-scales with *Cloud Native Runtimes*. The possibilities are endless,
    and Cartographer Conventions is a convenient way to apply conventions across a
    wide range of applications running on the platform.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Native Runtimes**: This is the component that runs your deployable
    application artifacts on Kubernetes. It is based on the open source *Knative*
    project ([https://github.com/knative](https://github.com/knative)), which, while
    it is often thought of as a serverless runtime, is also an excellent way to run
    regular web-facing workloads. It has a unique approach to load balancing that
    allows for auto-scaling based on configurable metrics while minimizing lost or
    dropped requests.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services Toolkit**: This is another feature that evolved from the much-loved
    *Tanzu Application Service*. That product allowed users to request a service to
    be provisioned, perhaps a database or a message queue, and bind the credentials
    of that service to an application at runtime. *Services Toolkit* brings that same
    functionality to Kubernetes. You can think of it as data services for developers
    who, first, don’t want to think about managing data services, and second, don’t
    want to manually wire up their application to those data services.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tanzu Build Service**: In a previous bullet, we talked about running deployable
    artifacts. Tanzu Build Service is the component that takes an application’s source
    code as input and outputs a deployable artifact in the form of an OCI container
    image. We did a thorough deep-dive into this feature in [*Chapter 3*](B18145_03.xhtml#_idTextAnchor048)*,
    Building Secure Container Images with* *Build Service*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workload Types**: You can think of this as a set of preconfigured, pre-curated
    supply chains that you can use to get started quickly with several different kinds
    of workloads:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web**: This is a standard web-facing application that you want to be able
    to scale up and down'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP**: This is a good fit for running a legacy application that handles its
    own web interactions and you want to pass network traffic directly to it'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queues**: These are applications that run in the background and process events
    as they arrive on a queue'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: These are a hybrid of web and queue applications that allow
    developers to implement a single piece of functionality that only gets instantiated
    and called when a request comes in'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App and Platform Security**: Here are some of the components that make security
    a first-class citizen on Tanzu Application Platform:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tanzu Application Platform Authentication and RBAC Authorization**: Tanzu
    Application Platform GUI uses the single sign-on functionality that comes with
    Backstage. This allows platform operators to configure providers such as Okta,
    Google, Azure, and GitHub. Furthermore, the GUI can be configured such that it
    can monitor running resources across multiple Kubernetes clusters, not just the
    cluster it is running on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App single sign-on**: This is a very common request among application developers.
    They don’t want to manage their own login, user **authentication** (**authN**),
    or **authorization** (**authZ**). Rather, they want to delegate those functions
    to the platform and have it taken care of for them. That’s exactly what this feature
    does. It allows platform operators to stand up preconfigured, opinionated deployments
    of Spring Authorization Server, and make that server available to applications
    via integrations into the platform’s software supply chains. The idea of this
    service is to integrate single sign-on into the application from the very beginning
    rather than as a last-minute bolt-on solution.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supply Chain Security Tools**: Software supply chain attacks are top-of-mind
    for many in the enterprise software space, and for good reason. Supply Chain Security
    Tools is a suite of tools that plug directly into a software supply chain such
    that whenever any part of that supply chain changes, the source code, bundled
    dependencies, and generated container images get scanned for all known vulnerabilities
    using a constantly updated database. These tools handle scanning the artifacts,
    storing the scan results, reporting on the stored results, and cryptographically
    signing the generated artifacts so they can’t be changed after they’ve been scanned.
    This allows platform operators to enable best-of-breed security for all their
    running workloads simply by incorporating them into a supply chain.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enablement**: Any product of the size and scope of Tanzu Application Platform
    needs a way for users and operators of the product to get up to speed. Tanzu Application
    Platform bundles its own learning platform for enabling those users. This allows
    platform operators to quickly and easily set up hands-on workshops that walk the
    various personas through the product. It also includes a brief built-in workshop
    on how to build your own workshops. Here’s a quick look at **Learning Center for
    Tanzu Application Platform** showing my favorite feature, the browser-embedded
    VS Code editor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.4 – Learning Center with the Embedded VS Code editor](img/B18145_08_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Learning Center with the Embedded VS Code editor
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows architects and operators to build hands-on real-world workshops
    that automatically provision and run completely self-contained in the browser.
    Here’s a quick list of some of the available features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` pointing to a live Kubernetes cluster and embedded *Docker*, so anything
    requiring the Docker CLI, builds, runs, pushes, and so on, are also possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded comprehension questions**: Workshop builders can embed questions
    right into the workshop to make sure users are properly understanding the concepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded VS Code editor**: Not only can workshop builders embed VS Code right
    into their workshop, but they can provide links that will open files, select code
    blocks in the editor window, and even paste additional fragments in just the right
    location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded web pages**: This allows users to deploy something to their dedicated
    workshop Kubernetes instance and immediately see it running right in the same
    window. It also enables tools like the Kubernetes web console to be exposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verify Workshop State**: Users can click a link that will trigger Kubernetes
    commands that don’t appear in a console. This allows workshop developers to ensure
    that the workshop state is as desired before moving on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker builds**: The embedded console uses **Docker in Docker** (**DIND**)
    to allow for the full range of Docker commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download files**: Workshop developers can enable users to download a local
    copy of any or all workshop files for future reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve covered whom Tanzu Application Platform is targeted to and what
    it consists of, it’s time to get our hands dirty and install it, which is exactly
    what we’ll do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Day 1 – installing and configuring Tanzu Application Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install Tanzu Application Platform, we’ll need a few things in place first.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites and technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to install and run Tanzu Application Platform, there are some technical
    prerequisites that must be in place. Here’s a list of what is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A (large)** **Kubernetes cluster**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Tanzu Application Platform documentation lists several supported Kubernetes
    clusters, including Tanzu Kubernetes Grid and Minikube. However, to keep these
    instructions manageable, I’m going to recommend three public cloud Kubernetes
    clusters. These clusters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elastic Kubernetes** **Service** (**EKS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Kubernetes** **Service** (**AKS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes** **Engine** (**GKE**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a number of reasons for this. Here are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy out-of-the-box load balancer services. While we can make Tanzu Application
    Platform work with node ports, load balancer services make things much easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy out-of-the-box persistent volume claims. The same reasoning behind easy
    load balancers also applies to dynamic storage, which is also required for Tanzu
    Application Platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy (albeit pricey) access to sufficient resources. While you can install Tanzu
    Application Platform on Minikube on a laptop, you’ll come up against RAM and CPU
    limitations. The public cloud options make it easy to stand up a cluster that
    can scale up to a size that runs Tanzu Application Platform without issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Tanzu Application Platform documentation has some recommendations for RAM
    and CPU, but here’s what has worked for me:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more control plane nodes. If your Kubernetes cluster gives you access
    to the control plane, the node should have at least two vCPUs and 8 GB of RAM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Five or more worker nodes. Each node should have at least two vCPUs and 8 GB
    of RAM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Tanzu** **Network account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The software installation is via container images hosted on the container registry
    associated with the Tanzu Network. You can sign up here: [https://network.tanzu.vmware.com/.](https://network.tanzu.vmware.com/.
    )'
  prefs: []
  type: TYPE_NORMAL
- en: '**A production** **container registry**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, there are multiple options here, but I’ll recommend two that will
    help things go more smoothly. These require paid accounts, but they greatly simplify
    the installation. I’ll point out that Amazon Elastic Container Registry isn’t
    yet supported. Here are the currently supported options for a container registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A paid Docker** **Hub account**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub does offer a free tier, but the Tanzu Application Platform install
    requires a significant amount of space (at least 1 GB) and significant repeated
    image pushes and pulls. Docker limits both on their free tier and this will hinder
    smooth operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Container** **Registry (gcr.io)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is my preferred solution as you can quickly set up a registry for your
    GCP project and push to multiple repositories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Container** **Registry (azurecr.io)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is another good option, especially if you have an Azure account already
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Harbor (DIY)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’d urge caution in using bring-your-own Harbor unless you’re comfortable standing
    up trusted TLS with a public **certificate authority** (**CA**) or *Let’s Encrypt*.
    If your Harbor presents a self-signed certificate, the Tanzu Application Platform
    installation gets more complicated. Harbor works great as a container registry,
    but if you don’t already have it up and running, you’ll need to spend some time
    getting it properly set up.
  prefs: []
  type: TYPE_NORMAL
- en: '**A custom domain with a** **DNS server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the public cloud providers will register a domain for you and provide DNS
    lookup for that domain. You can also do this with dedicated registrars such as
    GoDaddy. The only requirement here is that you’re able to create wildcard *A*
    and *CNAME* records that resolve publicly.
  prefs: []
  type: TYPE_NORMAL
- en: '**(Optional but recommended) A production** **Git server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get through the demos without your own Git server or an account on a
    public service, but any significant real-world work with Tanzu Application Platform
    requires one. There are free options on GitLab ([gitlab.com](http://gitlab.com))
    and GitHub ([github.com](http://github.com)) that work great for our purposes.
    You simply need to create an account and get a set of SSH or user/password credentials
    that the platform can use to push to and pull from a remote Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: The `kubcectl` CLI as well as the *Carvel* tools. You can find them at [https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)
    and [https://carvel.dev/#install](https://carvel.dev/#install), respectively.
    `Kubectl` should be version 1.22 or 1.23\. It should also be authorized with cluster-admin
    privileges on the Kubernetes cluster you’ll be installing to. All the Carvel tools
    are useful, but for this install, you only need `imgpkg`. You’ll also need the
    Docker CLI installed such that you don’t need to be root to run it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s do some quick spot-checks that we have all our prerequisites in place:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s double-check our *Docker* for the dreaded **permission denied** error.
    This is what you can expect to see if your Docker daemon doesn’t allow non-root
    access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what a successful installation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s verify `kubectl` and our Carvel `imgpkg` tool:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once your command-line tools are in order, you’re ready to proceed with installation
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting end user license agreements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can commence with moving packages to our custom registry and installing
    them, we need to accept the **End User License Agreements** (**EULAs**). After
    logging into the Tanzu Network, navigate to the two products listed here and select
    the latest version of each. If you need to accept the EULA, you will see a yellow
    box right below the version dropdown. You can click the link in the yellow box
    to be prompted to accept the EULA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://network.tanzu.vmware.com/products/tanzu-application-platform/](https://network.tanzu.vmware.com/products/tanzu-application-platform/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://network.tanzu.vmware.com/products/tanzu-cluster-essentials/](https://network.tanzu.vmware.com/products/tanzu-cluster-essentials/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relocating Tanzu Application Platform packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this step isn’t absolutely necessary, it’s highly recommended to move
    all of the container images from the Tanzu repository to your own. If you think
    about how Kubernetes works, when any of the dozens (or hundreds!) of pods that
    constitute Tanzu Application Platform needs to start or restart, the `kubelet`
    process on a worker node will need to pull down that pod’s container images. If
    you don’t relocate those container images to your own registry, they’ll have to
    come directly from the Tanzu Network container registry, meaning you’ll have `registry.tanzu.vmware.com`
    in your runtime critical path. That means anytime you need to restart a pod on
    a Kubernetes worker that doesn’t already contain that pod’s container images,
    the Tanzu registry must be up and responsive. Now, the Tanzu team has very good
    SREs who do an excellent job of keeping the Tanzu registry up and responsive,
    but their **Service Level Objectives** (**SLOs**) may not line up with your apps’
    SLOs, so it’s a good idea to manage your own destiny and maintain your own container
    registry. Furthermore, the Tanzu registry is shared with every other Tanzu customer,
    so you can’t rule out spikes in demand making container images temporarily unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the `imgpkg` tool to copy all the Tanzu Application Platform images
    from the Tanzu registry into our custom registry. The examples here will use `gcr.io`,
    but the steps are very similar for Azure Container Registry, Harbor, or Docker
    Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s use the Docker CLI to log in to the Tanzu registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, log in once again to your personal registry. Here’s how you do it for
    `gcr.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For Docker Hub, Harbor, or Azure, you can issue `docker login <registry-host>`
    and type a username and password in at the prompts. At this point, we are authenticated
    to both the Tanzu registry and our custom registry (`gcr.io`). The `imgpkg` tool
    requires the local Docker daemon to be authenticated before it can copy over the
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use `imgpkg` to pull images from the Tanzu registry and push them
    to our custom registry. We’ll set some environment variables for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, all the container images needed to install and run Tanzu Application
    Platform are available at `gcr.io/my-gcr-project/tap-packages`. Specific instructions
    for logging in to and relocating images into Dockerub, Harbor, and Azure are available
    in the Tanzu Application Platform install documentation here: [https://docs.vmware.com/en/VMware-Tanzu-Application-Platform/1.3/tap/GUID-install.html#relocate-images-to-a-registry-0](https://docs.vmware.com/en/VMware-Tanzu-Application-Platform/1.3/tap/GUID-install.html#relocate-images-to-a-registry-0).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Tanzu CLI and Tanzu Application Platform plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t already have the Tanzu CLI installed from other chapters, you can
    do that now. Furthermore, even if you have the Tanzu CLI, we’ll install some plugins
    to help us work more efficiently with Tanzu Application Platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll visit the Tanzu Application Platform page on Tanzu Network and
    download the CLI. The link is here: [https://network.tanzu.vmware.com/products/tanzu-application-platform/#/releases/1222090/file_groups/10484](https://network.tanzu.vmware.com/products/tanzu-application-platform/#/releases/1222090/file_groups/10484).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve downloaded the `tanzu-framework-bundle` tarfile for your platform,
    copy it to your home directory. Then, on Mac and Linux, you can follow these steps.
    On Windows, you may have to adapt them a bit, or, as I would recommend, use *VirtualBox*
    to stand up a Linux VM and follow the Linux instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the whole process. I’ll add some comments inline to describe what’s
    going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! If you made it this far, you have a working Tanzu CLI with
    all the plugins you’ll need to install and run Tanzu Application Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cluster Essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Cluster Essentials toolset is how we land Tanzu packages on our Kubernetes
    cluster. Perhaps you’re familiar with tools such as Helm. The Cluster Essentials
    tools do something similar, but in addition to what Helm does, they do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Store a desired application state in etcd as a CR so the application can be
    continuously reconciled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage a complex hierarchy of dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store and maintain templatized app configuration in such a way as to avoid configuration
    drift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow selective sharing of secrets across namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won’t sugarcoat the fact that Tanzu Application Platform is a complex piece
    of software, and it needs a fully realized enterprise-ready toolset to install
    it onto Kubernetes and keep it running smoothly. Cluster Essentials is that toolset.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Cluster Essentials, we follow a similar script to what we did for
    the CLI. In this case, we need to make sure that `kubectl` is pointing to the
    Kubernetes cluster we plan on deploying to as the install script will initiate
    the deployment. Once again, I’ll narrate the process with comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As the *kapp* CLI waits for the install to complete successfully, you’ll see
    quite a lot of output to the console describing the progress of the install. If
    you get the `Succeeded` message at the end, you know that the installation did
    in fact succeed. Now that you have Cluster Essentials installed and the installation
    packages relocated, we’re almost ready to install Tanzu Application Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a developer namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Tanzu Application Platform official documentation puts this step after the
    install, but I find that the install goes more smoothly if we do it first. This
    step involves creating a secret in a namespace where developers will deploy a
    workload as well as some Kubernetes RBAC artifacts so that the namespace’s default
    service account can interact with the CRs that make up Tanzu Application Platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the namespace and add a secret to it that will allow us
    to read from and write to our container registry. This example works for `gcr.io`,
    as we need to pass the password as a file. To create a secret for Azure, Docker
    Hub, or Harbor, you would use the `--username` and `--password` flags. My namespace-naming
    preference is `workload1`, `workload2`, and so on. This makes it clear to anyone
    perusing the cluster where the workloads are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to give the default service account in our namespace some roles
    and secrets that will enable Tanzu Application Platform workloads to run in this
    namespace with the default service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll proceed to install some tools that run on our Kubernetes cluster
    that will manage the installation for us.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a package repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have all the client- and server-side tools ready to go, we can finally
    kick off our install. First, we need to set up a package repository. This is like
    a Docker or Apt repository. It’s simply a service on the network that stores and
    serves software packages. In this case, we’re installing a *Kapp* package repository
    on our Kubernetes cluster from which the Kapp controller can install packages.
    Previously, we relocated packages from the Tanzu registry to our own container
    registry. One of those packages is called `tap`. That `tap` package functions
    as our repository. It knows about all the other packages in the container registry.
    This will make more sense shortly. This repository and all its packages will live
    in their own namespace on our Kubernetes cluster. We’ll assume that you still
    have your environment variables set from when we relocated the images. If they’re
    not set, you’ll need to go back and set them again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’ll install these packages to stand up a running instance of Tanzu Application
    Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling down and formatting tap-values.yaml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need a config file to install Tanzu Application Platform. You can
    pull down this file as a starting point: [https://github.com/PacktPublishing/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-09/tap-values.yaml](https://github.com/PacktPublishing/DevSecOps-in-Practice-with-VMware-Tanzu/blob/main/chapter-09/tap-values.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have that file locally, follow the inline instructions to plug in
    registry credentials and domain information. Once that file is filled out, we
    can install the `tap` package from our package repository, referencing that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This installation can take several minutes. Furthermore, it will sometimes
    tell you that it failed when in truth, a component was taking a little too long.
    One thing you can do to get a little more feedback on the install is to monitor
    the **PackageInstall** (**pkgi**) objects in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have a running instance of Tanzu Application Platform.
    Now let’s configure the remaining components necessary for you to interact with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DNS records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve installed Tanzu Application Platform, you’ll want to be able to
    reach the tools and deployed applications from a web browser. This is where you
    go to your domain’s DNS service and point it at your Tanzu Application Platform
    installation. First, let’s find out the endpoint of our load balancer service
    and point a wildcard DNS entry at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the envoy service in `tanzu-system-ingress` has a hostname as
    it’s `EXTERNAL-IP`. If I controlled `mydomain.com`, I would go into the DNS configuration
    settings for my domain and create a CNAME record, `*.mydomain.com`, and point
    it to the `LoadBalancer` host from the `kubectl` command. In you’re using Azure
    or GCP, you might get an IPv4 address rather than a hostname. In that case, you’ll
    need to create an `A` record rather than a CNAME.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a real-world example. I did my Tanzu Application Platform install with
    the `*.packtinstall.k10s.io` domain. After configuring my DNS records properly,
    I can use the dig command to verify that any subdomain of `packtinstall.k10s.io`
    will return a CNAME pointing to the AWS load balancer associated with the `tanzu-system-ingress/envoy`
    Kubernetes LoadBalancer service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, if everything worked perfectly the first time, you should be able to access
    the Tanzu Application Platform GUI with a browser pointed to `tap-gui.<your-domain>.com`.
    Success!
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.5 – Tanzu Application Platform GUI](img/B18145_08_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Tanzu Application Platform GUI
  prefs: []
  type: TYPE_NORMAL
- en: I’d encourage you to explore the *TAP GUI*. *Chapters 2* and *5* of this book
    cover the Application Accelerator and API Portal components in detail. Next, let’s
    install some local developer tools to enhance our experience interacting with
    Tanzu Application Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the VS Code developer tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To really see Tanzu Application Platform in action, it’s helpful to set up a
    true-to-life developer toolchain. At this point, you have a Kubernetes cluster
    running Tanzu Application Platform and you have `kubectl` and the Tanzu CLI with
    the necessary plugins. With just a few more additions, we’ll have that toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you don’t already have it, download and install VS Code from here:
    [https://code.visualstudio.com/download](https://code.visualstudio.com/download).
    Then, download and install Tilt from here: [https://docs.tilt.dev/install.html](https://docs.tilt.dev/install.html).
    Finally, download the developer tools for VS Code from Tanzu Network here: [https://network.tanzu.vmware.com/products/tanzu-application-platform](https://network.tanzu.vmware.com/products/tanzu-application-platform).
    You install the developer tools from the VS Code Command Palette. You can open
    the Command Palette from the `Extensions: Install from VSIX`. Once the auto-complete
    comes up, select that option, and navigate to the VSIX file you just downloaded
    to install it.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve completed the installation and configuration of a very
    complex piece of software. Our day-1 tasks are complete. Now, let’s move on to
    day 2 and put our powerful new toolkit to use!
  prefs: []
  type: TYPE_NORMAL
- en: Day 2 – deploying applications to Tanzu Application Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B18145_02.xhtml#_idTextAnchor033)*, Developing Cloud-Native
    Applications*, we went in depth into Application Accelerator. To deploy an application
    to Tanzu Application Platform, we’ll revisit that product. Navigate to the *TAP
    GUI* that you just finished installing. It should be at `tap-gui.<your-domain>`.
    Then, in the menu down the left-hand side, click on `gcr.io`, it might be something
    such as `gcr.io/<your-project-id>/tanzu-java-web-app`. The value you provide will
    be used in the Tiltfile to tell the Tilt tool where to push your app’s source
    code so it can be picked up by a Tanzu Application Platform supply chain. This
    will make more sense shortly. Here’s a reminder of what the accelerator screen
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.6 – Filling out the Accelerator form](img/B18145_08_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Filling out the Accelerator form
  prefs: []
  type: TYPE_NORMAL
- en: Once you click **NEXT**, you’ll shortly be presented with a button to download
    the ZIP file. Download the ZIP, unzip it, and open VS Code to the application
    directory you just unzipped. Then, we’ll need to update a couple of settings in
    VS Code. Go into the VS Code Settings window and navigate to **Extensions** |
    **Tanzu**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `workload1` or whichever namespace you set up for developer use in the
    previous steps. Finally, double-check that `gcr.io`, it might be `gcr.io/<your-project-id>/tanzu-java-web-app-remote-src`,
    depending on what you supplied to the Application Accelerator UI in the previous
    steps. Here’s what my settings look like:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.7 – VS Code developer settings](img/B18145_08_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – VS Code developer settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can close the `Tiltfile`. When you right-click on the Tiltfile, you
    should see the **Tanzu: Live Update Start** option. The following screenshot gives
    you a good idea of what to look for:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.8 – Tanzu Java web app in VS Code](img/B18145_08_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Tanzu Java web app in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to start the live update by clicking on the **Tanzu: Live Update
    Start** context menu item. It’s likely that you’ll be met with a message like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: No worries. The Tilt tool is being extra cautious that you don’t accidentally
    start a live update session in a production environment. Follow the instructions
    and add the `allow_k8s_contexts('<your-k8s-context>')` command to the bottom of
    the Tiltfile, then try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first deployment may take a while, but eventually, you can open a terminal
    and look at all the pods in the `workload1` namespace (`kubectl get pods -n workload1`),
    and see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.9 – Pod listing of \uFEFFthe running app](img/B18145_08_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Pod listing of the running app
  prefs: []
  type: TYPE_NORMAL
- en: The pods containing the word `build` are those that take your source code and
    turn it into a container image. The pods containing `config-writer` are those
    that take the source for a deployable Kubernetes artifact and write it to Git
    or a container registry where it can be picked up and deployed. Finally, the pod
    containing `deployment` is your application’s running pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s view our app in a browser. Execute this command to get the URL
    of the running Knative Service that belongs to your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, plug the URL into your browser. This is what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF8.10 – Running the Tanzu application](img/B18145_08_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Running the Tanzu application
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have a Spring Boot application up and running on Tanzu
    Application Platform. Furthermore, there was no need to install a local Java runtime
    or any tools beyond the Tanzu toolchain. The plugin transported your raw source
    code onto the platform where it was built and deployed. Next, let’s put the *Live
    Update* function to the test.
  prefs: []
  type: TYPE_NORMAL
- en: In VS Code, navigate to `/src/main/java/com/example/springboot/HelloController.java`,
    then change the greeting. Perhaps add `and Packt!!!` to the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when you save your change, the VS Code plugin automatically detects
    the change and deploys it. Here’s a timeline of what happens when you make a change
    to a file in VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: The Tilt plugin notices that a file has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The plugin bundles up your source code and stores it in your container registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The plugin updates the workload object on your Kubernetes cluster such that
    the `.spec.source.image` field points to the updated source code image in the
    container registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cartographer controller on Kubernetes notices the change in the workload
    and triggers a new iteration of the supply chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The supply chain pulls the source code, builds it, pushes the container image
    of the built artifact, and runs that artifact, applying multiple conventions in
    the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a minute or two, you can refresh your browser and see your local changes
    reflected live in the app running in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying workloads directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve now seen the developer workflow where local source code is packaged up
    and stored in a container repository and workloads are created from that source.
    In a real-world scenario, though, local source code doesn’t go straight from the
    IDE onto a platform. Rather, that code goes into source control, which then drives
    some sort of continuous integration onto the platform. Let’s briefly explore that
    use case now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/config` directory of the app that we downloaded and unzipped, you
    should see a file called `workload.yaml`. This instructs the platform to pull
    the source code from this URL: [https://github.com/sample-accelerators/tanzu-java-web-app](https://github.com/sample-accelerators/tanzu-java-web-app).
    Tanzu Application Platform will watch that Git repository and whenever it detects
    a change, it will pull the latest source code and update the running workload.
    Let’s try this out now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to avoid namespace collisions, let’s delete the existing workload. Let’s
    stop Tilt by right-clicking on the Tiltfile and selecting **Tanzu Live Update
    Stop**. Then, let’s delete our workload with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, there’s a small bug in some versions of Tanzu Application Platform that
    we need to work around. Although the Git repo we’re referencing is public, the
    platform still wants a secret to exist for authN. Let’s create an empty secret
    as a workaround:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s deploy the workload directly, taking special care to specify the
    correct namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can watch the pods progress as the workload deploys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can verify that your workload is visible in the browser at `tanzu-java-web-app.workload1.yourdomain.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re practically experts at using the platform, let’s have a look
    at what we might want to do next as platform operators.
  prefs: []
  type: TYPE_NORMAL
- en: Day 3 – common operational activities on Tanzu Application Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we’ve installed a fully functional application platform, but in some
    ways, it still may feel like a toy. For instance, no enterprise is going to allow
    workloads to be deployed without TLS. Also, the platform is a bit of a black box
    that takes our source code and turns it into a running application. How can we
    know that what’s running on the platform is the exact code we checked in? Going
    in depth into these topics is a bit beyond the scope of this book, but what I
    will do is describe some additional operational tasks and the problems they solve,
    and point you to some useful in-depth resources for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Securing running workloads with TAP GUI with TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For an application platform in the enterprise, securing all web endpoints with
    TLS is non-negotiable. There are a few options that I’ll list here. Some involve
    procuring the certificate outside of Kubernetes and supplying it directly, and
    others involve using an open source project called *cert-manager* ([https://www.jetstack.io/open-source/cert-manager/](https://www.jetstack.io/open-source/cert-manager/)),
    which gets installed automatically with Tanzu Application Platform. Here are some
    ways you might procure and deploy a TLS certificate into Tanzu Application Platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly supplied with a third-party certificate (*DigiCert*, *Verisign*, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly supplied with a self-managed CA (OpenSSL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly supplied with a corporate CA-signed certificate (e.g., *Nokia NetGuard*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly supplied with *Let’s Encrypt*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via *cert-manager* with a self-managed CA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via *cert-manager* with *Let’s Encrypt* (my preference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are many options, which could easily double the length
    of this chapter. If you don’t have a strong preference, I’d recommend *Let’s Encrypt*
    + *cert-manager*. If you’re managing your domain’s DNS via a major cloud provider
    such as AWS Route 53, the process can be simple and painless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve decided how you’ll obtain a certificate, you’ll need to decide
    what `mydomain.com`; then, the SANs you’d configure would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*.``mydomain.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.``workload1.mydomain.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.``workload2.mydomain.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.``workload3.mydomain.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will give you TLS that will work for workloads deployed to the `workload1`,
    `workload2`, and `workload3` namespaces. There are ways to work around the limitation
    so you can deploy to any arbitrary namespace, but I’ll refer you to the documentation
    for how to do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve decided on how we’ll obtain a certificate and identified our
    SANs, I’ll send you to this excellent blog post, which goes into detail on how
    to install Tanzu Application Platform with TLS support: [https://tanzu.vmware.com/content/blog/tanzu-application-platform-install-with-tls-and-azure-ad](https://tanzu.vmware.com/content/blog/tanzu-application-platform-install-with-tls-and-azure-ad).'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling testing and scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another non-negotiable for running enterprise software on a platform is that
    it needs to deploy with a guarantee that it has passed all its unit tests and
    that it has been scanned for known vulnerabilities. Tanzu Application Platform
    can provide both these guarantees with a bit of extra configuration.
  prefs: []
  type: TYPE_NORMAL
- en: First, regarding testing, there’s no way that any platform could account for
    every testing framework across every programming language, so rather than moving
    forward with a half-baked attempt, the architects of Tanzu Application Platform
    decided to put automated testing in the hands of the app’s developer via Tekton
    Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Tekton ([https://cloud.google.com/tekton/](https://cloud.google.com/tekton/))
    provides Kubernetes-native continuous integration and delivery. Tanzu Application
    Platform, then, will look for a Tekton pipeline that knows how to run an application’s
    tests and run it. The documentation also gives some sample pipelines for languages
    such as Java and Maven.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scanning for vulnerabilities is a bit simpler. Tanzu Application Platform will
    scan an app’s source code and generated container images using two well-known
    scanning tools: *Grype* or *Snyk*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn how to enable testing and scanning for your application supply
    chains here: [https://docs.vmware.com/en/VMware-Tanzu-Application-Platform/1.2/tap/GUID-getting-started-add-test-and-security.html](https://docs.vmware.com/en/VMware-Tanzu-Application-Platform/1.2/tap/GUID-getting-started-add-test-and-security.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve tackled these topics, you should have a thorough knowledge of Tanzu
    Application Platform and have a good intuition for what *good* looks like in the
    enterprise. What comes next? Let’s brainstorm some next steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’re a veritable Tanzu Application Platform expert, where can you
    go next? Here are some thoughts:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy Tanzu Application Platform across multiple Kubernetes clusters with dedicated
    clusters for viewing, building, and running workloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable managed services (databases, message queues, etc.) that can automatically
    bind their credentials to workloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable custom GitOps workflows that require an approved pull request before
    deploying to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build your own custom supply chains using the Cartographer tools ([https://cartographer.sh/](https://cartographer.sh/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tanzu Application Platform is likely the most complex piece of software we cover
    in this book and could benefit from a dedicated book of its own. Mastering this
    technology will make you indispensable to any enterprise looking to run software
    in the cloud at scale. With Tanzu Application Platform done, we’re going to wrap
    up the second part of the book where we covered *running* applications on Tanzu,
    and transition to the next section, where we talk about *managing* them with tools
    such as Tanzu Mission Control, VMware Aria operations for Applications, and Tanzu
    Service Mesh. This wraps up our treatment of running applications on Tanzu. I
    encourage you to continue on to the next section where we cover managing those
    applications. We’ll start with **Tanzu Mission Control**, a single point of control
    for all of your enterprise Kubernetes assets across multiple clouds.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 – Managing Modern Applications on the Tanzu Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part will cover some important Tanzu tools that help to manage, secure,
    and proactively observe the container applications and the underlying Kubernetes
    platform for important day-2 activities of multi-cloud-based deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 9*, *Managing and Controlling Kubernetes Clusters with Tanzu Mission
    Control*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18145_10.xhtml#_idTextAnchor193), *Realizing Full-Stack Visibility
    with VMware Aria Operations for Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18145_11.xhtml#_idTextAnchor220), *Enabling Secure Inter-Service
    Communication with Tanzu Service Mesh*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18145_12.xhtml#_idTextAnchor239), *Bringing It All Together*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18145_13.xhtml#_idTextAnchor259), *Appendix*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
