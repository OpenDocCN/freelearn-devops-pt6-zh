- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Helm to Manage a Kubernetes Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we described how you can deploy a simple application
    using kubectl and a standard Kubernetes manifest. The challenge with using this
    approach is the manifest files are fixed. If you wanted to change the tag for
    a web server in a manifest for different environments (development, test, production,
    etc.) you would need to have multiple manifests or alter the manifest content
    every time you deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we introduce **Helm**, a tool that can be used to define,
    install, and upgrade complex applications and allows you to easily customize deployments
    for different environments. Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Helm and its architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Helm binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a sample Kubernetes application with Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, deploying, updating, and rolling back a Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an application via Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Helm chart with Lens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Helm is an abstraction on top of Kubernetes, and, as such, there is no difference
    between using Helm on EKS or another Kubernetes distribution or Deployment. We
    will focus on the basic functionality of Helm in this chapter. More advanced operations/configurations
    can be found by following the link in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting this chapter, please ensure that the following is in place:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a working EKS cluster and are able to perform administrative tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl is installed and properly configured on your workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have network connectivity to your EKS API endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are familiar with YAML, basic networking, and EKS architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Helm and its architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapters, Kubernetes YAML templates are fine for simple
    applications. However, as you try and cope with complex applications where you
    have multiple components, several dependencies between these components, and the
    need to deploy and update these components frequently using techniques such as
    blue/green deployments, you need something more; you need a package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Package management is not a new idea; you can see a similar concept and critical
    software package management tools in software such as APT/YUM on Linux, Homebrew
    on Mac, or Chocolatey on Windows. Similarly, Helm can be considered the package
    management tool for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Charts**: A package of pre-configured Kubernetes resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Releases**: A specific instance of a chart that has been deployed to the
    cluster using Helm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repositories**: A group of published charts that can be made available to
    others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helm binary**: A tool used to deploy a chart/release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few sections, we will explore these components in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary benefit of using Helm is to simplify the way Kubernetes resources
    are created and deployed. Helm allows developers to adopt a **don’t repeat yourself**(**DRY**)
    approach, allows default attributes to be set but still allows them to be modified
    (overridden) to support different use cases or environments.
  prefs: []
  type: TYPE_NORMAL
- en: Developers also can easily share the template through a *Helm Chart Repository*.
    For example, if you want to install Prometheus (an open source monitoring system
    on Kubernetes) in development, you can manually create the manifests, specify
    the standard images, set up any supporting resources – such as ingress, deployment,
    and service – configure any environment variables, and repeat the process for
    production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of all this work, you can simply add the Helm Chart Repository for
    Prometheus using the following commands and then deploy it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are some alternatives to Helm, namely Kustomize ([https://kustomize.io/](https://kustomize.io/)),
    which builds on layers of YAML while also creating a custom operator for your
    application to manage its life cycle; an example of this is the Kafka operator.
    Helm, however, remains the simplest way to customize and deploy applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Helm charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic configuration item in Helm is the chart. A template that consists
    of a Kubernetes application that is used by Helm, is called a `$ helm create <mychartname>`
    command to create this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at each of the components of a chart:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.helmignore` file works like a `.gitignore` file and specifies files or
    directories to be ignored by the Helm command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Chart.yaml` file holds metadata about the chart you are packaging, such
    as your version of the chart itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `values.yaml` file stores any values used for the deployment. You will normally
    see one file, the default values, but multiple value files can be used for different
    environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `charts` directory is used to store other charts that your chart may depend
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `templates` directory holds the actual manifest you have created to support
    the deployment of your application. This may consist of multiple YAML files to
    deploy pods, config maps, secrets, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Values are transposed into the chart using the `{{ define }}` directive, which
    means the templates are significantly more flexible than standard Kubernetes manifests.
    What follows is an example of Helm manifest that shows a resource, in this case,
    a ConfigMap can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the name of the ConfigMap will be a combination of `Release.Name`
    and the `-configmap` string. For example, if your chart name is *CM1*, the resulting
    ConfigMap will be named `CM1-configmap`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the basic configuration, let’s look at how we actually
    install and use Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Helm binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Helm can be easily installed and can be compliable with many different operating
    systems. You can refer to the following instruction to set up Helm on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)'
  prefs: []
  type: TYPE_NORMAL
- en: You must configure kubectl to work for Amazon EKS. If you have not already done
    this, please refer to [*Chapter 3*](B18129_03.xhtml#_idTextAnchor047), *Building
    Your First EKS Cluster*, to help you configure kubectl properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, you can use the following command to download and install the Helm
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing this book, Helm 3.9.x had some issues using the AWS authenticator
    plugin, so v3.8.2 is used. You will need to make sure that the `/usr/local/bin/`
    directory is in your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a sample Kubernetes application with Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we deployed the NGINX ingress controller using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to install it using Helm, we need to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the public stable repository to your Helm configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refresh the repository information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then show the charts in the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One of the charts will be `nginx-ingress`, which can be installed using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The chart release can be viewed using either of these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also view the Kubernetes resources using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s look at how we create a new Helm chart from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, deploying, updating, and rolling back a Helm chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see from the previous example, deploying pre-packaged applications
    with Helm is pretty simple. Deploying your own application is also easy. We start
    with the following command, which will create a directory in your current directory
    called `myhelmchart` and populate it with the relevant files and templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `values.yaml` file created by this command contains references
    to a single NGINX pod and creates a `ClusterIP` service, which is only accessible
    from within the cluster. The key values from the default file are shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily deploy this new Helm chart using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will override the `service.type` value seen in the `values.yaml` file
    with a `NodePort` service, so it is now exposed outside of the cluster. We can
    then validate the chart deployment with the following command and see the name
    of the `NodePort` service that was created, along with the other Kubernetes resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the following command using the service name from the previous step,
    you will be able to extract the IP address and port of the service and curl the
    `NodePort` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the Helm deployment, we are going to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `values.yaml` file and increase `replicaCount:` to `2`. We can also
    change the `service.type` value to `NodePort`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `Chart.yaml` file and update `version` to `0.2.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Validate the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then roll out the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then validate the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice the revision number shown next when you run the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also validate that two Pods exist for the Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can easily roll back to a previous revision using the `helm rollback example
    1` command, where `1` represents the revision you want to return to. This is one
    of the major advantages of Helm over basic Kubernetes manifests, each change to
    the manifest can be versioned and deployed as a new revision, and if issues occur,
    you can easily roll back to a previous version/revision.
  prefs: []
  type: TYPE_NORMAL
- en: The `helm list` command can show all the revisions in the cluster, which are
    stored as Kubernetes Secrets in the namespace where the release is deployed. Next,
    let’s look at how we remove our Helm application.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an application via the Helm command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Helm provides a simple `uninstall` command to delete the application release.
    The first step is to determine which Helm deployment you want to remove using
    the `helm` `list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we want to remove the example deployment, so we can simply
    run the `$ helm uninstall example` command and all the resources created by the
    chart or charts will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This will remove all deployment history as well. Please also make sure you have
    removed all the Helm charts using the `$ helm` `uninstall` command.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed using the Helm binary to deploy public charts and
    create, update, roll back, and delete your own charts. In the next section, we
    will show you how to use Lens to deploy charts.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Helm chart with Lens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to visualize your Kubernetes resources
    using Lens. However, you can also use Lens to manage Helm charts. Please refer
    to [*Chapter 4*](B18129_04.xhtml#_idTextAnchor067), *Running Your First Application
    on EKS* (the *Visualizing your workloads* section), for guidance on the setup
    of Lens.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Lens will fetch available Helm repositories from the public Artifact
    Hub ([https://artifacthub.io/](https://artifacthub.io/)) and Bitnami. As we are
    going to redeploy the NGINX ingress controller we deployed using the Helm **Command
    Line Interface** **(CLI)**, we need to add a custom repository. To do this, follow
    these steps while referring to *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose **Lens** | **Preferences** from the main toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select **Kubernetes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Add custom Helm Repo** from the Kubernetes panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will display a pop-up box, which works in the same way as the `helm repo
    add` command. Here, we are going to add the NGINX repository we used in a previous
    example: [https://helm.nginx.com/stable](https://helm.nginx.com/stable).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Adding a custom Helm repository in Lens](img/B18129_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Adding a custom Helm repository in Lens
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the repository has been added, we can now deploy charts from it. To do
    this, follow these steps while referring to *Figure 5**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: Select your cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Helm** | **Charts**. This will show all the charts available to you
    based on the repositories you’ve added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Filter out NGINX as we have done in the following screenshot, and you will
    see two NGINX ingress controller charts: one from Bitnami and the other from NGINX.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Finding the required chart in Lens](img/B18129_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Finding the required chart in Lens
  prefs: []
  type: TYPE_NORMAL
- en: Click on the NGINX chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring up another panel where you must click on **Install**. Fill
    in the details (or leave them unchanged) and click **Install** again. The chart
    will be deployed, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Installing a chart in Lens](img/B18129_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Installing a chart in Lens
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now click on the **Releases** tab, and you will see all the deployed
    Helm charts. In the following example, we only have the NGINX ingress controller
    deployed. From the **Releases** tab, you can also upgrade and delete the release
    by clicking on the three dots (the kebab menu) on the right of the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Viewing Releases in Lens](img/B18129_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Viewing Releases in Lens
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Lens performs the same functions that the Helm binary does but
    just provides it in a graphical view. As discussed in the previous chapter, Lens
    also allows you to review the running workloads, something we had to do with Kubectl.
    Hence, Lens helps bring together these tools, but it is still recommended that
    you know how to use both Kubectl and Helm if you’re going to work with multiple
    clusters in production.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Helm to accelerate application deployment
    on Kubernetes and improve the efficiency of template creation. This included how
    to install the Helm CLI and use it to deploy applications (charts) hosted in a
    public repository. We then created our own chart, customized it, deployed it,
    modified the configuration, deployed the new revision, rolled back to a previous
    revision, and finally deleted it from our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed how we could perform similar activities using a third-party
    tool, Lens, and how it achieves the same things but provides a graphical user
    interface while also integrating multiple views such as Kubernetes resources (kubectl)
    and Helm releases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look deeper into how you access and secure your
    EKS cluster, focusing on how you access the EKS cluster endpoints and authenticate
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An example operator: [https://docs.confluent.io/5.5.1/installation/operator/index.html](https://docs.confluent.io/5.5.1/installation/operator/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding Helm in more detail: [https://helm.sh/docs/](https://helm.sh/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Deep Dive into EKS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dive deeper into EKS and its various components. This
    part aims to demystify key aspects such as security, networking, and node groups,
    providing you with a comprehensive understanding of each feature. Finally, you
    will take away strategies regarding how to upgrade your EKS cluster version and
    follow the upstream Kubernetes release cadence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18129_06.xhtml#_idTextAnchor095), *Securing and Accessing Clusters
    on EKS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18129_07.xhtml#_idTextAnchor107), *Networking in EKS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18129_08.xhtml#_idTextAnchor123), *Managing Worker Nodes on
    EKS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18129_09.xhtml#_idTextAnchor135), *Advanced Networking with
    EKS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18129_10.xhtml#_idTextAnchor146), *Upgrading EKS Clusters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
