- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing and Accessing Clusters on EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce the general concepts for authentication and authorization
    in Kubernetes, and will also discuss the differences between these concepts and
    **Elastic Kubernetes Service** (**EKS**). We will also look at how to configure
    EKS and client tools to securely communicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication verifies the identity of a user or service, and authorization
    manages what they can do. In this chapter, we will review the mechanism used in
    EKS to implement authentication and authorization so you to use them to build
    secure clusters. Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding key Kubernetes concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring EKS cluster access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding key Kubernetes concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes clusters have two categories of users: service accounts managed
    by Kubernetes, and normal users (administrators, developers, etc.). **Kubernetes**
    (**K8s**) is extensible by design and supports multiple authentication plugins.
    We will focus on the most common one, client certificates, while discussing generic
    user authentication/authorization in Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the client certificates’ plugin, users are considered authenticated when
    they furnish a valid certificate signed by the cluster’s **certificate** **authority**
    (**CA**).
  prefs: []
  type: TYPE_NORMAL
- en: With a valid certificate, Kubernetes determines the username from the common
    name field in the `/CN=bob`) while the group information is provided in the `/O=dev`).
    From this point onwards, the **role-based access control** (**RBAC**) sub-system
    will determine whether the user is authorized to perform a particular operation
    on a resource.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates this concept. Please note that service accounts
    will be discussed in [*Chapter 13*](B18129_13.xhtml#_idTextAnchor193), *Using
    IAM for Granting Access* *to Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Standard Kubernetes RBAC sub-system](img/B18129_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Standard Kubernetes RBAC sub-system
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the certificate for a normal user, you need to generate
    a PKI private key and CSR using an operating system tool such as OpenSSL (see
    the following example) and then export the CSR request in base64 encoding for
    signing by the cluster CA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting encoded string can be submitted to the K8s cluster for signing
    using the `CertificateSigningRequest` kind. An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how standard K8s authentication works, let’s move on
    to how it works in EKS by default.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the default EKS authentication method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managing users, groups, and certificates for one or more K8s clusters can be
    an operational challenge. Thankfully, EKS offloads this by default to the AWS
    **Identity and Access Management** (**IAM**) service. IAM is a globally distributed
    service that allows you to create users and groups, as well as assign AWS permissions
    including the AWS EKS API.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when you create an EKS cluster, the IAM entity that creates that
    cluster is automatically granted `system:masters` permissions, effectively making
    it the system administrator role for the EKS cluster. This means that without
    additional configuration, the IAM identity used for cluster creation is the only
    identity that can perform any functions on the EKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical error when starting out with EKS, as a CI/CD pipeline may
    be used to create your cluster, but its IAM identity is different to that of the
    regular users. Therefore, when they go to interact with the cluster, they have
    no K8s privileges. The EKS cluster comes pre-integrated with AWS IAM. The following
    diagram illustrates how the user and the EKS cluster interact with the IAM service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – EKS authentication flow](img/B18129_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – EKS authentication flow
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now discuss in detail each of the steps in the EKS authentication flow
    shown in *Figure 6**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '0. The starting point is for the client to retrieve the cluster configuration
    and update your `update-kubeconfig` CLI command is the simplest way to do this
    and will use the `DescribeCluster` API operation. Any user using this API call
    must have an IAM identity and the privilege to use this API to automatically update
    the config file. An example is shown here for the cluster called `mycluster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A bearer token now needs to be generated and used in each EKS API (`get-token`
    CLI command or automatically using the AWS IAM Authenticator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The bearer token is added to the request either manually (on the `kubectl` command
    line for example) or automatically by the IAM authenticator/`kubectl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This bearer token is now validated against the AWS IAM service using a token—`authentication-webhook`—which
    is being used by the IAM authenticator service in EKS. If it is valid, then a
    request is passed to the K8s RBAC sub-system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The set of permissions granted by IAM policies associated with an authenticated
    IAM identity has no bearing EKS cluster permissions. The bridge between the IAM
    and RBAC sub-systems is the `aws-auth` ConfigMap that provides the mappings between
    IAM principals (roles/users/groups) and Kubernetes subjects (users/groups).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operation (in the case of authorization) is returned to the client, or alternatively
    they receive a "not authorized" response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we’ve discussed how user identities are authenticated. The next section
    describes how the request from an authenticated user is authorized.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the aws-auth ConfigMap for authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will see how to configure and maintain the `aws-auth` ConfigMap later on
    in this section, but it’s important to understand that this ConfigMap manages
    the relationship between the AWS IAM identity, and the Kubernetes identity and
    permissions. Without a corresponding entry in the `aws-auth` ConfigMap, IAM users
    or groups won’t have any permissions to perform any K8s operations, regardless
    of what permissions are assigned through the IAM role or policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'EKS uses **OpenID Connect** (**OIDC**) identity providers as a method to authenticate/authorize
    users to your cluster. This means that each cluster is given a unique OIDC identity
    that can be used as a trusted entity in the AWS IAM policy. You can validate the
    identity of the cluster using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: OIDC identity providers can be used with AWS IAM or with other OIDC-compliant
    providers. This means you can manage users/passwords and permissions in a platform
    such as GitHub Enterprise or GitLab instead of AWS IAM, and use the OIDC provider
    to authenticate/authorize users. You can associate one OIDC identity provider
    to your cluster so you cannot use IAM and another identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the cluster endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have talked about the ability to authenticate and authorize operations
    on an EKS cluster; however, to do so you will need to be able to communicate with
    the cluster’s endpoint over HTTPS. Once you’ve updated your `certificate-authority-data`).
    How you access that endpoint will depend on how you have configured your EKS endpoint,
    either as public only, private only, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed previously, EKS is a managed service, so the control plane (API/etcd)
    servers run in a VPC managed by AWS. The worker nodes (typically EC2) run in the
    customer’s VPC and communicate with the control plane using whatever IP address
    is returned through the DNS lookup of the server. The following diagram illustrates
    how the user accesses public or private EKS endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – EKS endpoint access](img/B18129_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – EKS endpoint access
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps needed to access EKS endpoint, as shown in the preceding diagram,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial requirement is to obtain the EKS cluster’s DNS name. In most user
    access scenarios, this step has already been done using the `update-kubeconfig`
    CLI command but when worker nodes are created, they will make a call to the AWS
    EKS API to get the cluster configuration and DNS information. At time of writing,
    the AWS EKS API is a public API only (no private endpoint) so all worker nodes
    need access to the public API through a NAT, internet, and/or transit gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For public endpoints, the DNS name resolves to a public **Network Load Balancer**
    (**NLB**) hosted in the AWS-managed VPC. This means all user and worker node communication
    goes through this public endpoint (although worker node traffic doesn’t leave
    the AWS backbone).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a private endpoint, the DNS name resolves to the private endpoint attached
    to the customer’s VPC (this uses a privately hosted Route 53 zone managed by AWS).
    More specifically, it resolves to a VPC private IP address, meaning it is only
    accessible in the VPC or through a private connection using a transit gateway,
    a VPN, and/or Direct Connect. In this case, the private connection between the
    customer’s VPC and the VPC managed by AWS is bidirectional, being used by the
    control plane and the users/worker nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to enable both public and private endpoints, in which case users
    can access the K8s API through the public NLB, and also through the private endpoint.
    In this model, all API server/worker node communication occurs through the private
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring EKS cluster access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look in more detail at the configuration of the two
    key files needed to securely access your cluster, `kubeconfig` and `aws-auth`,
    along with the use of IP controls to secure EKS endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring .kube/config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `clusters` list has an entry for each cluster you want to access, containing
    both the DNS name and the TLS certificate to allow communication to take place.
    These entries can be added manually or through the `update-kubeconfig` CLI command.
    The following is an example `kubeconfig` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `context` section in the `kubeconfig` file is used to group access parameters
    together for a client tool such as kubectl. You can have different contexts to
    access a single cluster. In the following example, we are grouping the `myuser`
    user and `mycluster` cluster together in the `mycontext` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `users` section in the `kubeconfig` file holds the specific parameters
    for the user (associated with the context). In the following example, the user
    uses the `aws eks get-token` command to automatically provide the bearer token
    for authentication based on the IAM identity configured for the caller of the
    `mycluster` cluster, which is in the `eu-central-1` Region in account `111999`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring your `kubeconfig` file is a critical part of establishing communication
    with the EKS cluster and the following commands can be used to validate/view the
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So far, we’ve reviewed the way a K8s client, such as kubectl, can provide the
    identity of a user to the API servers. The next section reviews how that user’s
    identity is authorized using the `aws-auth` Config Map.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the aws-auth Config Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A correctly configured client’s `kubeconfig` file provides the bearer token
    that allows EKS to identify and validate the user. Once their identity has been
    validated, the RBAC subsystem and `aws-auth` ConfigMap will then validate whether
    they have the correct permissions. We add users’ permissions via role details
    in the ConfigMap, under the `data` section. Each entry supports the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groups`: A list of Kubernetes groups to which the role is mapped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rolearn`: The ARN of the IAM role associated with the user bearer token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: A username within Kubernetes to map to the IAM role. As discussed
    previously, this is something that is not used and need not be mapped to an existing
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, the `myIAMRole` IAM role in account `111999` is mapped
    to the `system:masters` group and assigned the K8s username of `creator-account`.
    This is an example of the default configuration you will see in the `aws-auth`
    ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can modify the ConfigMap directly using either `kubectl` or an IAC tool
    such as `eksctl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is not advised as there is no version/change control. A better
    approach is to place the ConfigMap manifest into a Git repository and then use
    a CI/CD pipeline to push/pull changes. You can still use `kubectl` or `eksctl`
    to make the changes, but it’s done using a file under version control and managed
    through an audited pipeline that could have any number of build checks or tests.
    Typically, the following steps will be followed for the deployment of the EKS
    cluster and the incremental management of ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the EKS cluster using your preferred infrastructure-as-code tool and/or
    pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Export the default `aws-auth` ConfigMap into a separate version-controlled
    repository/manifest with its own deployment pipeline. This can be done by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leverage a suitable code review process, to add new groups/users and role mappings.
    Please note, the IAM role referenced in the configuration must exist, due to which
    it must be created first in the AWS IAM service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update your cluster using a push (CI/CD) or pull (GitOps) method using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Steps 3 and 4 need to be repeated on an ongoing basis as you add and delete
    users/groups to and from the `aws-auth` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, we’ve discussed how users are authenticated/authorized when a request
    arrives at the K8s API server endpoint. In the next section, we consider how you
    can secure access to the API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting EKS endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the whole, it is generally better to use private EKS endpoints. While accessing
    any EKS endpoint requires a valid TLS certificate (if using client certificates)
    and the appropriate IAM/RBAC permissions, if these were compromised and you had
    a public endpoint, then your cluster would be accessible from anywhere in the
    world. If you need to use a public endpoint, then make sure to configure public
    access CIDR ranges to restrict which public IP addresses have access. In the following
    example, access to the `mycluster` public cluster has been restricted to a single
    `/32` IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The EKS API network interfaces are protected by a separate security group that
    provides stateful IP ingress protection. So, while EKS private endpoints can only
    be accessed from the VPC or connected private networks, the security groups associated
    with the API endpoint (shown as `securityGroupIds` in the following example) can
    be used as an additional control to restrict access to any specific IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the API security groups are different from the `clusterSecurityGroupId`
    security group, which is used to protect worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have now understood or have at least gained familiarity with
    how EKS performs authentication and authorization and how to protect your API
    endpoints. We’ll now revisit the key learning points from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basic concepts of authentication and authorization
    in native Kubernetes and how EKS differs. We described how EKS, by default, is
    integrated with AWS IAM and that a bearer code needs to be generated by a client
    tool such as `kubectl` in order for EKS to authenticate the user. This bearer
    code can be generated manually using the `get-token` CLI action or automatically
    using the `kubeconfig` file and will be submitted on every API request and be
    automatically validated by EKS.
  prefs: []
  type: TYPE_NORMAL
- en: We also described how the `aws-auth` ConfigMap is used by the Kubernetes RBAC
    sub-system to accept or deny any API request. It is important to place this file
    under version control and manage changes using a CI/CD pipeline as, by default,
    only the cluster creator has permission to do anything on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we talked about how you can secure access to the API endpoints using
    IP whitelisting and/or security groups and how it is typically better to use private
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss Kubernetes networking and how EKS can be
    configured to use an **AWS Virtual Private** **Cloud** (**VPC**).
  prefs: []
  type: TYPE_NORMAL
- en: Further readings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Overview of the AWS IAM authenticator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html](https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overview of webhook authentication in K8s:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/reference/access-authn-autWhz/authentication/#webhook-token-authentication](https://kubernetes.io/docs/reference/access-authn-autWhz/authentication/#webhook-token-authentication)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overview of the AWS OIDC Provider Integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/awsdocs/amazon-eks-user-guide/blob/master/doc_source/authenticate-oidc-identity-provider.md](https://github.com/awsdocs/amazon-eks-user-guide/blob/master/doc_source/authenticate-oidc-identity-provider.md)'
  prefs: []
  type: TYPE_NORMAL
