- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Kubernetes architecture is crucial to properly leverage its capabilities.
    In this chapter, we will go over the main components and concepts that make up
    a Kubernetes cluster. Getting familiar with these building blocks will allow you
    to understand how Kubernetes works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at the different components that make up a Kubernetes
    cluster – the control plane and the worker nodes. The control plane—made up of
    components such as the API server, controller manager, and etcd—is responsible
    for managing and maintaining the desired state of the cluster. The worker nodes
    run your containerized applications in pods.
  prefs: []
  type: TYPE_NORMAL
- en: After covering the cluster architecture, we will dive into the main Kubernetes
    abstractions and API resources such as pods, deployments, StatefulSets, services,
    ingress, and persistent volumes. These resources allow you to declare the desired
    state of your applications and have Kubernetes reconcile the actual state to match
    it. Understanding these concepts is key to being able to deploy and manage applications
    on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at supporting resources such as ConfigMaps and Secrets, which
    allow you to separate configuration from code. Jobs provide support for batch
    workloads.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how a Kubernetes
    cluster is put together and how you can leverage its capabilities by utilizing
    its API resources. This will enable you to start deploying your own applications
    and managing them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be covering these concepts under the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cluster architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ingress and ingress controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConfigMaps and Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no technical requirements for this chapter. All code presented here
    is generic and practical executable examples will be given in [*Chapter 3*](B21927_03.xhtml#_idTextAnchor053).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a cluster architecture. This means that in a full production environment,
    you will usually have several machines running your workloads simultaneously to
    create a reliable and scalable architecture. (Note that Kubernetes can run on
    one machine also, which is great for testing but misses the whole point for production.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To coordinate cluster functionalities, Kubernetes has two main feature groups:
    the **control plane** responsible for cluster management and the **node components**
    that communicate with the control plane and execute tasks in the worker machines.
    *Figure 2**.1* shows a representation of the whole system.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Kubernetes architecture](img/B21927_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Kubernetes architecture
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at each group and its components.
  prefs: []
  type: TYPE_NORMAL
- en: Control plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main components of the control plane are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: kube-apiserver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kube-scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kube-controller-manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running a cloud-based Kubernetes cluster, we also have another component
    called cloud-controller-manager.
  prefs: []
  type: TYPE_NORMAL
- en: kube-apiserver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Kubernetes API is exposed to the administrator with **kube-apiserver**.
    It can be considered the “frontend” of the control plane. It is through the API
    server that we will interact with Kubernetes, sending instructions to the cluster
    or getting data from it. It is highly scalable and scales horizontally (deploying
    more worker nodes to the cluster).
  prefs: []
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes utilizes etcd, a distributed key-value database, to persistently
    store all cluster data and state. Etcd serves as the backing store for the Kubernetes
    API server, providing a secure and resilient foundation for the orchestration
    of containers across nodes in a cluster. By leveraging etcd’s capabilities for
    consistency, high availability, and distribution, Kubernetes can reliably manage
    the desired state of applications and infrastructure. etcd is fault tolerant even
    if the failure happens in a leader node of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: kube-scheduler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**kube-scheduler** is responsible for distributing work or containers across
    multiple nodes. It watches for newly created pods that are not assigned to any
    node and selects a node for them to run on. To make scheduling decisions, kube-scheduler
    analyzes individual and collective available resources, hardware/software/policy
    constraints, affinity and anti-affinity instructions, deadlines, data locality
    and eventual interferences between workloads.'
  prefs: []
  type: TYPE_NORMAL
- en: kube-controller-manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**kube-controller-manager** runs controllers that regulate behavior in the
    cluster, such as node controllers, job controllers, EndpointSlice controllers,
    and ServiceAccount controllers. The controllers reconcile the desired state with
    the current state.'
  prefs: []
  type: TYPE_NORMAL
- en: cloud-controller-manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**cloud-controller-manager** interacts with the underlying cloud providers
    and sets up cloud-based networking services (such as networking routes and load
    balancers). It separates components that interact with the cloud provider from
    the components that run only inside the cluster. This controller manager only
    runs controllers that are specific to the cloud provider in use, thus, if you
    are running a test local Kubernetes instance, cloud-controller-manager will not
    be used, since it only deals with cloud-based services.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at the node components.
  prefs: []
  type: TYPE_NORMAL
- en: Node components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node components are present in every single worker node of the cluster and
    are responsible for communicating with the control plane, running and maintaining
    workloads, and providing a runtime environment. The main components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kube-proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A container runtime** is the underlying software that is responsible for
    running containers. Kubernetes supports several container runtimes, but the most
    common ones are Docker and containerd. The container runtime is responsible for
    pulling the images from the registries, running the containers, and managing containers’
    lifecycles.'
  prefs: []
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**kubelet** is the primary node agent that watches the assigned pods and ensures
    containers are running and healthy. It interacts with the container runtime to
    pull images and run containers.'
  prefs: []
  type: TYPE_NORMAL
- en: kube-proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**kube-proxy** is a network proxy and load balancer that implements Kubernetes
    networking services on each node by maintaining network rules and performing connection
    forwarding.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move our attention to the Kubernetes components we will use to build
    our workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pods** are the smallest deployable units in Kubernetes and represent a single
    instance of an application. Pods contain one or more containers (although the
    most common case is to have just one container inside a pod). When multiple containers
    live inside a pod, they are guaranteed to be co-located on the same node and can
    share resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pods provide two main benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost` and share resources such as volumes. This facilitates easy communication
    between related containers. It is important to notice, though, that this is an
    advanced use case and should be used only when your containers are tightly coupled.
    We regularly use pods for single-container deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management and deployment**: Pods are the units that get deployed, scaled,
    and managed in Kubernetes. You don’t directly create or manage the containers
    within pods. This entire process is fully automated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, you do not define pods directly. Pods can be created and managed though
    other resources such as deployments, jobs, and `StatefulSets`. Nevertheless, you
    can define a pod with a proper YAML file manifest.
  prefs: []
  type: TYPE_NORMAL
- en: '`.yaml` file. **YAML files** are often used for configuration. They are very
    close to JSON files, but they are more readable since they rely on indentation
    for code hierarchy structure rather than brackets and braces. The following is
    an example of a manifest to deploy a single pod:'
  prefs: []
  type: TYPE_NORMAL
- en: pod.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a closer look at each part of this manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`: The Kubernetes API version for the objects in this manifest.
    For pods this is `v1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind`: The type of object being created, which is `Pod` for this manifest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`: This section contains metadata for the pod, such as the name and
    labels. The name is a unique identifier. Labels will be particularly important
    in the future as they serve as identifiers for other Kubernetes resources such
    as deployments and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec`: This section defines the desired state of the pod including its containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containers`: Specifies the container(s) that run inside the pod. Includes
    the image, ports, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: The Docker image to use for the container. It can be a public or private
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: Defines the ports exposed by the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This covers the basic structure of a pod manifest. Pods provide a simple way
    to deploy and manage containers in Kubernetes. Now that we have discussed pods
    and how to define them, let’s discuss a way of automating more complex pod structures
    with deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deployments** are one of the most important resources in Kubernetes for running
    applications. They provide a declarative way to manage pods and replicas.'
  prefs: []
  type: TYPE_NORMAL
- en: A deployment defines the desired state for your application, including the container
    image, number of replicas, resource limits, and more. The Kubernetes control plane
    works to match the actual state of your cluster to the desired state in the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a simple deployment manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: deployment.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down section by section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`: This specifies the Kubernetes API version for the Deployment
    resource. We want the `apps/v1` version which includes Deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind: Deployment`: The type of resource we are creating, in this case, a Deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`: Standard metadata for the resource like a unique name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec`: The specification for the Deployment. This defines the desired state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replicas: 3`: We want three pod replicas to be running. Kubernetes will maintain
    this number of pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selector`: Used to match pods managed by this Deployment. Pods will be selected
    based on the label selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`: The template for the pods that will be created. It defines the
    pod specifications. Note that the deployment will relate to the label specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec: containers`: Pod spec including the container(s) to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image: nginx:1.16`: The container image to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: Ports exposed by the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this Deployment is applied, Kubernetes will launch three pods matching
    the template, each running an Nginx container. The Deployment controller will
    monitor the pods and ensure the desired state matches the actual state, restarting
    pods if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployments provide powerful capabilities for running scalable and resilient
    applications on Kubernetes. Using declarative configuration makes deployments
    easy. Next, we will discuss a different approach for managing pods and replicas:
    StatefulSets.'
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: StatefulSets are a Kubernetes resource used to manage stateful applications
    such as databases. They are similar to Deployments but are designed to handle
    stateful workloads that require persistent storage and unique network identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: A StatefulSet manages Pods that contain stateful applications (applications
    that must keep track of data for other applications or other user sessions). The
    Pods in a StatefulSet have a sticky, unique identity that persists across rescheduling.
    This allows each Pod to maintain its state when restarted or rescheduled onto
    a new node. This makes StatefulSets ideal for stateful apps such as databases
    that require data persistence. Deployments, on the other hand, are designed for
    stateless workloads and provide identical Pods with no persistent storage. Thus,
    they are better for stateless web apps.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets operate by creating PersistentVolumes (which will be covered later
    in this chapter) for each Pod to mount. This ensures data persists across Pod
    restarts. StatefulSets also provide a unique hostname and stable network ID per
    Pod using a predictable naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a statefulset manifest for deploying a MySQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: statefulset.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This manifest creates a StatefulSet for MySQL with one replica. It uses a `volumeClaimTemplate`
    to dynamically provision a PersistentVolume for each Pod. The MySQL data will
    be persisted in the `/``var/lib/mysql` path.
  prefs: []
  type: TYPE_NORMAL
- en: Each Pod gets a unique name, such as `mysql-0`, and a stable hostname. If the
    Pod gets rescheduled, it will remount its PersistentVolume to continue running
    statefully.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, StatefulSets provide powerful stateful management for databases
    and other stateful apps in Kubernetes. They ensure persistence, stable networking,
    ordered deployment, and graceful scaling. Next, we will continue with a discussion
    about Kubernetes jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jobs** are a fundamental resource type in Kubernetes used to run batch processes
    that run to completion. Unlike long-running services such as web servers, jobs
    are intended to terminate when the batch process finishes.'
  prefs: []
  type: TYPE_NORMAL
- en: A job creates one or more pods that run a defined workload and then terminates
    when the workload is complete. This is useful for tasks such as data processing,
    machine learning training, or any finite computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a job, you define a Job resource in a YAML manifest like this:'
  prefs: []
  type: TYPE_NORMAL
- en: job.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a closer look at this code, part by part:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion` `''` `batch/v1` for jobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind` `''` `Job`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata.name` `''` Name of the job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.template` `''` Pod template defining the container(s) to run the same
    way we saw in the previous resource definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.template.spec.restartPolicy` `''` Set to `Never` since jobs shouldn’t
    restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.backoffLimit` `''` Optional limit on failed job retries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pod template under `spec.template` defines the container(s) to run just
    like a pod manifest. You can specify the image, commands, environment variables,
    and so on. An important setting is the `restartPolicy`, which should be `Never`
    for jobs. This ensures pods are not restarted if they fail or exit. The `backoffLimit`
    is optional and specifies the number of times a failed job pod can be retried.
    The default is **6**. Set this lower if jobs should not retry too many times on
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: When you create the job, Kubernetes will schedule one or more pods matching
    the template to run your workload. As the pods finish, Kubernetes will track their
    status and know when the job is completed. You can view job status and pod logs
    to monitor progress. Jobs make it easy to run batch computational workloads on
    Kubernetes. In the next section, we will take a look at Kubernetes services.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Services** provide stable endpoints to access pods running in a cluster,
    thus exposing our applications to users online. They allow pods to die and replicate
    without interrupting access to the applications running in those pods. There are
    several types of services in Kubernetes. We will discuss three of them in detail:
    ClusterIP, NodePort, and load balancer.'
  prefs: []
  type: TYPE_NORMAL
- en: ClusterIP Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ClusterIP service provides an IP address that is only accessible inside the
    cluster. This IP does not change for the lifetime of the service, providing a
    stable endpoint to access the pods. Here is an example ClusterIP service manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: service_clusterip.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This manifest creates a service called `my-service` that will forward requests
    to pods with the label `app: my-app` on `port 80`. Requests will be forwarded
    to `port 9376` on the target pods. The ClusterIP will not change while this service
    exists.'
  prefs: []
  type: TYPE_NORMAL
- en: NodePort Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A NodePort service makes an internal ClusterIP service accessible externally
    through a port allocated on each node. The NodePort is allocated from a configured
    range (by default, `30000`-`32767`) and will be the same on every node. Traffic
    to `<NodeIP>:<NodePort>` will be forwarded to the ClusterIP service. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: service_nodeport.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This exposes the internal ClusterIP on port `30007` on every node. Requests
    to `<NodeIP>:30007` will be forwarded to the service.
  prefs: []
  type: TYPE_NORMAL
- en: LoadBalancer Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A load balancer service provisions an external load balancer to expose the service
    to external traffic. A ClusterIP exposes the service on an internal IP address
    within the Kubernetes cluster. This makes the service only reachable within the
    cluster. Load balancer, on the other hand, exposes the service externally using
    the cloud provider’s load balancer implementation. This makes the service reachable
    from outside the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The load balancer implementation depends on the environment. For example, on
    AWS, this would create an **Elastic Load Balancer** (**ELB**), an AWS service
    to provide a managed load balancer. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: service_loadbalancer.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates a load balancer and assigns an external IP address. Traffic to
    the external IP is forwarded to the internal ClusterIP service. Next, we will
    discuss a different way of defining services with Ingress and Ingress Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Ingress and Ingress Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Ingress** resource defines rules for external connectivity to Kubernetes
    services. It enables inbound HTTP and HTTPS connections to reach services running
    within the cluster. Traffic routing is controlled by rules defined on the Ingress
    resource. For an ingress to be able to run, you need to have a running ingress
    controller on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: An **Ingress controller** is responsible for fulfilling the Ingress, usually
    with a load balancer. It watches for Ingress resources and configures the load
    balancer accordingly. Different load balancers require different Ingress controller
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of Ingress controllers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'NGINX Ingress Controller: Uses NGINX as a load balancer and reverse proxy.
    It is one of the most common and fully featured controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HAProxy Ingress Controller: Uses HAProxy for load balancing. Provides high
    performance and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Traefik Ingress Controller: A cloud-native controller that integrates with
    Let’s Encrypt for automatic HTTPS certificate generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS ALB Ingress Controller: Uses the AWS **Application Load Balancer** (**ALB**).
    Integrates natively with other AWS services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Ingress resource contains two main parts – a backend and rules. The backend
    specifies the default service to route unmatched requests. The rules contain a
    set of paths and the services to route them to:'
  prefs: []
  type: TYPE_NORMAL
- en: ingress.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, requests to the root path `/` will be routed to the `example-service`
    on port `80`. The `pathType:` prefix indicates that any subpath should also be
    routed to the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple rules can be defined to route different paths to different services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, requests to `/foo` will go to `foo-service` and requests
    to `/bar` will go to `bar-service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we have to configure secure connections with in-transit encryption.
    When this is the case, we can configure advanced encryption options in Ingress
    controllers using annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Host-based routing can also be configured by specifying host names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now `foo.example.com` will route to `foo-service` and `bar.example.com` to `bar-service`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Ingress provides a way to intelligently route HTTP and HTTPS traffic
    to services in a Kubernetes cluster. Ingress controllers handle the actual load
    balancing and reverse proxy functionality. Common use cases for Ingress include
    exposing services to external users and handling TLS/SSL. Careful Ingress configuration
    is crucial for production-grade Kubernetes deployments.
  prefs: []
  type: TYPE_NORMAL
- en: '**It is important to note that the ingress API is frozen.** That means that
    this API will not be receiving any more updates. It is replaced by the Gateway
    API. Nevertheless, it is important to know it since a lot of the big data tools
    that we will use in this book are still deployed using Ingress instructions. Now,
    let’s move to the Gateway API and understand how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Gateway API is a Kubernetes API that provides a way to dynamically configure
    load balancing and service mesh capabilities on Kubernetes. The Gateway API allows
    defining routes and policies to manage external traffic to Kubernetes services
    in a centralized, declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main resources in Gateway API are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GatewayClass` `''` Defines a set of gateways with a common configuration and
    behavior. It is like the concept of StorageClass for persistent volumes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gateway` `''` Defines a set of routes for a given hostname. This binds GatewayClass,
    TLS certificate, and other configurations to a set of routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTPRoute/TCPRoute` `''` Defines the actual routes to Kubernetes services
    and their policies, such as timeouts, retries, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example GatewayClass resource:'
  prefs: []
  type: TYPE_NORMAL
- en: gateway_class.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This defines a GatewayClass named `external-lb` that will be handled by a `lb.acme.io/gateway-controller`
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Gateway resource binds a hostname and TLS certificate to the GatewayClass
    as we can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: gateway.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This Gateway named `my-gateway` uses the `external-lb` GatewayClass defined
    earlier. It handles HTTP traffic on port `80`. Note that the `addresses` field
    is not specified, so an address or hostname will be assigned to the gateway by
    its controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, HTTPRoute and TCPRoute resources define the actual routes to backend
    services. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: http_route.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This HTTPRoute is a child of the `my-gateway` Gateway defined earlier. It routes
    requests to the `/foo` path to the `my-foo-service` service on port `80` and requests
    to `/bar` are routed to `my-bar-service` on port `80`. Also, additional features
    such as request timeouts, retries, and traffic splitting can be configured on
    the Route resources.
  prefs: []
  type: TYPE_NORMAL
- en: Gateways are a new and great way of configuring networking and routing in Kubernetes.
    The centralized configuration for ingress traffic management acts as a single
    source of truth. While the Ingress resource presents a simple, declarative interface
    focused specifically on exposing HTTP applications, the Gateway API resource offers
    a more generalized abstraction for proxying diverse protocols beyond HTTP. Also,
    they decouple the data plane from the control plane. Any gateway controller can
    be used, including NGINX, HAProxy, and Istio. Gateways provide improved security
    with TLS handling and authentication and fine-grained traffic control using advanced
    routing rules and policies. Finally, they have easier management and operation
    for complex ingress configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will approach persistent volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes was originally designed for stateless applications. So, one of the
    key challenges when running stateful applications on Kubernetes is managing storage.
    Kubernetes provides abstractions that allow storage to be provisioned and consumed
    in a portable manner across different environments. When designing storage infrastructure
    on Kubernetes, there are two main resources to understand: **PersistentVolumes**
    (**PVs**) and **PersistentVolumeClaims** (**PVCs**). A PV represents a networked
    storage unit provisioned by the cluster administrator. Much like compute nodes,
    PVs become a pool of cluster resources. In contrast, PVCs allow end users to request
    abstract storage with defined capacity and access modes. The PVC functions similarly
    to a pod resource request, but instead of CPU and memory, users can specify their
    desired volume size and read/write permissions. The Kubernetes control plane handles
    binding matching PV and PVC resources to provision storage for pods as declared.
    With this separation of roles, the underlying storage layer gains lifecycle independence
    from individual pods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example PersistentVolume YAML manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: persistent_volume.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This defines an `/tmp` on the NFS server at `172.17.0.2`. The reclaim policy
    is set to `Recycle`, which means the volume will be recycled rather than deleted
    when released. `storageClassName` is set to `slow`, which can be used to match
    this PV to PVCs requesting specific storage classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example PersistentVolumeClaim YAML manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: pvc.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This PVC requests 8GB of storage with `ReadWriteOnce` access. It specifies the
    `slow` `storageClassName`, which will match it to the preceding PV with the same
    storage class. There is also a selector that will match PVs with a `stable` release
    label.
  prefs: []
  type: TYPE_NORMAL
- en: When a PVC is created, the Kubernetes control plane looks for a matching PV
    to bind to the PVC. This matching takes into account access modes, storage capacity,
    and `storageClassName` among other factors. Once bound, that storage is then available
    to be mounted by pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a pod YAML that mounts the preceding PVC:'
  prefs: []
  type: TYPE_NORMAL
- en: pod_with_pvc.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This pod mounts the PVC into the container at `/var/www/html`. The PVC provides
    durable storage for the pod that persists even if the pod is deleted or moved
    to a different node.
  prefs: []
  type: TYPE_NORMAL
- en: StorageClasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The StorageClass objects define different *classes* of storage that can be
    requested. This allows administrators to offer different tiers of storage within
    the same cluster. The following code defines a standard hard disk StorageClass
    and a fast SSD StorageClass on GCE:'
  prefs: []
  type: TYPE_NORMAL
- en: storage_classes.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `---` line tells Kubernetes that we aggregated two YAML manifests in just
    one file. After defining a StorageClass, PVCs can then request a particular class:'
  prefs: []
  type: TYPE_NORMAL
- en: pvc2.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows a cluster to provide different types of storage without requiring
    users to understand how the details are implemented. Next, we will discuss the
    final subject in this chapter and one that is very important for security in Kubernetes:
    ConfigMaps and Secrets.'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps and Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ConfigMaps and Secrets are two important Kubernetes objects that allow you to
    separate configuration data from your application code. This makes your applications
    more portable, manageable, and secure.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ConfigMaps provide a convenient way to pass configuration data into pods in
    a declarative manner. They allow you to store configuration information without
    putting them directly in a pod definition or container image. Pods can access
    the data stored in a ConfigMap through environment variables, command-line arguments,
    or by mounting the ConfigMap as a volume. Using ConfigMaps enables you to separate
    your configuration data from your application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following manifest, you can create a ConfigMap to store configuration
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: config_map.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This ConfigMap contains a `config.properties` file that pods can mount and consume.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create ConfigMaps from directories, files, or literal values.
    The following commands show an example of each ConfigMap definition. Those commands
    are run in a shell using the `kubectl` executable (we will take a deeper look
    at it in the next chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To consume a ConfigMap in a pod, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set environment variables from ConfigMap data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set command-line arguments from ConfigMap data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consume ConfigMap values in volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This following YAML file defines a Kubernetes Pod that consumes configuration
    data from a ConfigMap using environment variables and consuming it as a volume.
    Let’s see how that is done:'
  prefs: []
  type: TYPE_NORMAL
- en: pod_with_configmap.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this code and understand what it’s doing:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines a Pod with the name `configmap-demo`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pod has one container called `demo` that uses the `alpine` image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The container has two environment variables set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_COLOR` is set from the `app.color` key in the `app-config` ConfigMap'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_MODE` is set from the `app.mode` key in the `app-config` ConfigMap (this
    is defined as an argument to the run command)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The container has one volume mount called `config-volume` that mounts the `/``etc/config`
    path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pod defines a volume called `config-volume` that uses the `app-config` ConfigMap
    as a data source. This makes the data from the ConfigMap available to the container
    on the mount path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although ConfigMaps are really useful, they don’t provide secrecy for confidential
    data. For that, Kubernetes provides Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Secret is an object that contains a small amount of sensitive data such as
    passwords, tokens, or keys. Secrets allow you to store and manage this sensitive
    data without exposing it in your application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can create a Secret from literal values using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would create a Secret containing confidential database credentials.
    You can also create Secrets from files or directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Secrets store data encoded in `base64` format. This prevents the values from
    being exposed as `plaintext` in `etcd`. However, the data is not encrypted. You
    can consume your secret data from pods like this:'
  prefs: []
  type: TYPE_NORMAL
- en: pod_with_secrets.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding YAML file defines a Kubernetes Pod that consumes secrets from
    the Kubernetes API. Let’s go through the code:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines a Pod named `secret-demo`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pod has one container named `demo` based on the NGINX image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The container has three environment variables that get their values from secrets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_HOST` gets its value from the `DB_HOST` key in the `db-secret` secret'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_USER` gets its value from the `DB_USER` key in the `db-secret` secret'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DB_PASSWORD` gets its value from the `DB_PASSWORD` key in the `db-secret`
    secret'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The container mounts a volume called `secrets-volume` at the `/etc/secrets`
    path. This volume is read-only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `secrets-volume` volume uses the `app-secret` secret as its backing store.
    So, any keys/values in `app-secret` will be exposed as files in `/etc/secrets`
    in the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamental architecture and components that
    make up a Kubernetes cluster. Understanding the control plane, nodes, and their
    components is crucial for operating Kubernetes effectively.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how the API server, etcd, controller manager, and schedulers in
    the control plane manage and maintain desired cluster state. kubelet and kube-proxy
    run on nodes to communicate with the control plane and manage containers. Getting
    familiar with these building blocks provides a mental model for how Kubernetes
    functions internally.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the main API resources used to deploy and manage applications,
    including Pods, Deployments, StatefulSets, Jobs, and Services. Pods encapsulate
    containers and provide networking and storage for closely related containers.
    Deployments and StatefulSets allow declarative management of pod replicas and
    provide self-healing capabilities. Jobs enable batch workloads to run to completion.
    Services enable loose coupling between pods and provide stable networking.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how ingress resources and ingress controllers configure external
    access to cluster services through routing rules. The new Gateway API provides
    a centralized way to manage ingress configuration. PersistentVolumes and PersistentVolumeClaims
    allow portable, network-attached storage to be provisioned and consumed efficiently.
    StorageClasses enable different classes of storage to be offered.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at how ConfigMaps and Secrets allow configuration data and
    sensitive data to be injected into pods in a decoupled manner. Overall, these
    API resources provide powerful abstractions for deploying and managing applications
    robustly.
  prefs: []
  type: TYPE_NORMAL
- en: Learning these fundamental concepts equips you to use Kubernetes effectively.
    You now understand how a cluster is put together, how applications can be deployed
    and managed in line with the desired state, and how the supporting resources including
    storage, configuration, and secrets work. This critical foundation enables you
    to start deploying applications on Kubernetes and leverage its automation capabilities
    for self-healing, scaling, and management. The knowledge gained in this chapter
    will be indispensable as we move forward.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will do some hands-on exercises with Kubernetes to apply
    all the concepts that we studied here.
  prefs: []
  type: TYPE_NORMAL
