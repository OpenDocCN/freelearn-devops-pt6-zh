- en: '*Chapter 4*: Composing Infrastructure with Crossplane'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing is a powerful construct of Crossplane that makes it unique among its
    peers, such as the Open Service Broker API or AWS Controllers for Kubernetes.
    The ability to organize infrastructure recipes in a no-code way perfectly matches
    the organization’s agile expectation of building a lean platform team. This chapter
    will take us on a journey to learn about composing from end to end. We will start
    with a detailed understanding of how Crossplane **Composite Resources** (**XRs**)
    work and then cover a hands-on journey to build an XR step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Feeling like an API developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do XRs work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postprovisioning of an XR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprovisioned resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an XR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feeling like an API developer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traditionally, infrastructure engineers know the most profound infrastructure
    configuration options and different infrastructure setup patterns. But they may
    not have experience in building APIs. Building an infrastructure platform with
    Crossplane will be a shift from these usual ways. Modern infrastructure platform
    developers should have both pieces of knowledge, that is, infrastructure and API
    engineering. Building infrastructure APIs as a platform developer means implementing
    the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Evolving the APIs as time passes by. This involves introducing new APIs, updating
    an existing API version, and deprecating the old APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying API cross-cutting concerns for consuming product teams, such as authentication,
    authorization, caching, and auditing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating different infrastructure policies within the APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reusable infrastructure recipes used across teams. For example, some
    product teams might develop their applications with the **MEAN** stack (**MongoDB,
    Express.js, AngularJS, and Node.js**). We might be interested in developing infrastructure
    provisioning for this stack as a template API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the required shared infrastructure used across teams. For example,
    we might want to provision a virtual private network shared by different infrastructure
    resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving and evolving correct API boundaries considering the different infrastructure
    recipes and shared infrastructure. We must perform trade-off analysis to deal
    with conflicting concerns between infrastructure recipes and shared infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Infrastructure recipes and shared infrastructure are vital elements in API-bounded
    context trade-offs. We will examine this in detail in an upcoming chapter. The
    following figure represents the nuances of API infrastructure engineering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – API infrastructure engineering'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – API infrastructure engineering
  prefs: []
  type: TYPE_NORMAL
- en: We are looking at these aspects to understand XR architecture in the best possible
    way. Every element of the Crossplane composite is designed to cover infrastructure
    engineering practices from the perspective of an API.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We can use the learnings from microservices architecture pattern to define infrastructure
    API boundaries. There is no perfect boundary, and every design option will have
    advantages and disadvantages. In [*Chapter 6*](B17830_06_ePub.xhtml#_idTextAnchor092),
    *More Crossplane Patterns*, we can look for ways to adopt microservices with the
    Crossplane infrastructure platform.
  prefs: []
  type: TYPE_NORMAL
- en: How do XRs work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An XR can do two things under the hood. The first purpose is to combine related
    **Managed Resources** (**MRs**) into a single stack and build reusable infrastructure
    template APIs. When we do this, we might apply different patterns, such as shared
    resources between applications or cached infrastructure for faster provisioning.
    The second one is to expose only limited attributes of the infrastructure API
    to the application team after abstracting all organization policies. We will get
    into the details of achieving these aspects as we progress in this chapter. The
    following are the critical components in an XR:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Composite Resource Definition** (**XRD**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Claim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start looking at the purpose of each component and how they interact with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: XRD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CompositeResourceDefinition` is the Crossplane configuration element used
    to define an XRD. Creating this configuration is like writing an OpenAPI Specification
    or Swagger API definition. The following are the critical aspects of the `CompositeResourceDefinition`
    configuration YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kind` attribute of the new API. Note that it’s standard practice to use *X*
    as a prefix for the XR name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API group**: This will help us to group the API logically, avoid naming conflicts,
    and manage authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<resource plural name>.<API group>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versions` element is an array and can hold configuration for multiple versions
    of the same XR API. Typically, when we start, we will have just one version. As
    time progresses, we will increment the API version with changes. The old version
    can become a technical debt to deprecate later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`served` element will indicate whether the XR API is served with the given
    version. The `referenceable` flag will determine whether we can define an implementation
    for the given API version. We can look at version management and these attributes
    in more depth in [*Chapter 5*](B17830_05_ePub.xhtml#_idTextAnchor074), *Exploring
    Infrastructure Platform Patterns*. For now, both flags will be `true` when we
    have only one version defined in the XRD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema**: This is a section under each version covering the actual OpenAPI
    specification. It covers details such as parameter lists, data types, and required
    parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection secret keys**: This will hold the list of keys that need to be
    created and populated in the Kubernetes Secrets after the resource provisioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultCompositionRef` and `EnforcedCompositionRef` are a couple of attributes
    providing this flexibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Claim names**: These are optional parameters that create a proxy API for
    the given XR API with the specified name. Applying the claim object’s create,
    delete, and update action will create, delete, and update the underlying XR. Claims
    are a critical component in Crossplane, and we will look at that in a dedicated
    topic shortly in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The XRD is nothing but an opinionated **Custom Resource Definition** (**CRD**),
    and many parts of the configuration look like a CRD. These are just a few possible
    parameters. We will look at a few more parameters as we progress through the book.
    The complete API documentation is available at [https://doc.crds.dev/github.com/crossplane/crossplane](https://doc.crds.dev/github.com/crossplane/crossplane).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We are looking at v1.5.1 of the Crossplane documentation, which is the latest
    at the time of writing this chapter. Refer to the latest version at the time of
    reading for more accurate details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that some of the configurations discussed previously are not part of the
    following YAML, such as `DefaultCompositionRef` and `ConnectionSecretKeys`. These
    configurations are injected by Crossplane with default behavior if not specified.
    Refer to the following YAML for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once we are done with the API specification, the next step is to build the API
    implementation. Composition is the Crossplane construct used for providing API
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The composition will link one or more MRs with an XR API. When we create, update,
    and delete an XR, the same operation will happen on all the linked MRs. We can
    consider XRD as the CRD and composition as the custom controller implementation.
    The following diagram represents how XR, XRD, composition, and MRs are related:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – XRM, composition, and XR'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – XRM, composition, and XR
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We have referred to XR in this book in two contexts. We can use XR to refer
    to a new infrastructure API that we are building. Also, the composition resources
    list can hold both an MR and an existing XR. We will also refer to an XR from
    that context. Look at *Figure 4.2* where XR is referred to in both dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of the crucial elements from the composition configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kind` and `apiVersion` are the two configuration elements defined under `CompositeTypeRef`.
    While `kind` specifies the XR name, `apiVersion` will refer to a specific version
    defined in the XRD. The mapped version should be configured as referenceable in
    the XRD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WriteConnectionSecretsToNamespace**: This will specify the namespace for
    storing the connection Secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: This section is an array that holds the list of MRs to be created,
    updated, and deleted when someone creates, updates, and deletes the XR. We can
    even define another XR under this section. It is a mandatory section, and we should
    define at least one resource, either an MR or XR. The base is the critical object
    under each resource that holds the XR/MR configuration template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromCompositeFieldPath` is the default type and is used most frequently. It
    is helpful to patch an attribute from the XR into the composition resource base
    template, that is, feeding the user input into the composing resources. `FromFieldPath`
    and `ToFieldPath` are the subattributes that perform the actual patching. There
    is a patch type called `ToCompositeFieldPath`, which does the reverse of `FromCompositeFieldPath`.
    We could copy fields from the resources back into the XR using this patch type.
    The `CombineFromComposite` patch type is the most suitable option when combining
    multiple attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convert` for typecasting, `math` for mathematical operations, and `map` for
    key-value operations. We could have a list of transform functions on a given patch,
    and they are executed in the order specified in the configuration. Both patches
    and transforms are vital patterns. We will look at different configuration examples
    for patches and transforms throughout the book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy**: These are under each patch and will determine the patching behavior.
    We can mandate the patch path presence because the default behavior is to skip
    the patch if the field is absent. Also, we can configure the behavior of merge
    when the patching is performed over an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConnectionDetails**: These are specified under each resource and will hold
    the list of secret keys we want to propagate back into the XR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReadinessChecks**: These will allow us to define any custom readiness logic.
    If this section is not provided, the default behavior is to make the XR state
    ready when all the composing resources are ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.parameters.storageSize` or `spec.versions[0].name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We covered most of the configuration options available with the composition.
    Have a look at the Crossplane documentation for the complete list. The following
    figure represents the composition configuration options and the relationship between
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Composition configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Composition configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample composition configuration YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We will cover an example with more configuration elements in the *Building an
    XR* section. An XRD version can have more than one composition, that is, one-to-many
    relationships between the XRD version and composition. It provides polymorphic
    behavior for our infrastructure API to work based on the context. For example,
    we could have different compositions defined for production and staging. The `CompositionRef`
    attribute defined in the XR can refer to a specific composition. Instead of `CompositionRef`,
    we can also use `CompositionSelector` to match the compositions based on labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – XR and composition relation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – XR and composition relation
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at **XR claims**, also known as **claims**.
  prefs: []
  type: TYPE_NORMAL
- en: Claim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A claim is a proxy API to the XR, created by providing claim name attributes
    in XRD configurations. As a general practice, we provide the exact name of the
    XR after removing the initial `X`. In the preceding example, `xclouddb` is the
    XR name and `Clouddb` is the claim name but following such naming conventions
    is not mandatory. Claims are very similar to the XR, and it might tempt us to
    think that it’s an unnecessary proxy layer. Having a claim is helpful in many
    ways, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: XRs are cluster-level resources, while the claims are namespace level. It enables
    us to create namespace-level authorization. For example, we can assign different
    permissions for different product teams based on their namespace ownership.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can keep some of the XR only as a private API at the cluster level for the
    platform team’s use. For example, the platform team may not be interested in exposing
    the XR API that creates a virtual private network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not ideal to manage some of the resources at the namespace level as they
    are shared between teams and do not fit into the context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use this pattern to support the preprovisioning of infrastructure.
    A claim can just reference itself with a preprovisioned XR infrastructure, keeping
    the provisioning time low. It is very similar to caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure represents how claims, XR, XRD, composition, and MRs are
    related, giving an end-to-end view of how the whole concept works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – How does composition work?'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – How does composition work?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the sample claim and XR YAML. The claim YAML is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'A namespace is not part of the preceding claim YAML. Hence, it will create
    the resource in the default namespace, the Kubernetes standard. An equivalent
    XR YAML to the preceding claim YAML is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note that the XR is always created at the cluster level and namespace configuration
    under metadata is not applicable. We can look at a more detailed claim and XR
    configurations in the *Building an XR* section. Let’s explore a few more XR, XRD,
    composition, and claim configurations from the perspective of postprovisioning
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Postprovisioning of an XR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After performing CRUD operations over a claim or XR resource, the following
    are some critical aspects to bring the API request to a close:'
  prefs: []
  type: TYPE_NORMAL
- en: Readiness check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propagating the credentials back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with learning about readiness checks.
  prefs: []
  type: TYPE_NORMAL
- en: Readiness check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The XR state will be ready by default when all the underlying resources are
    ready. Every resource element in the composition can define its custom readiness
    logic. Let’s look at a few of the custom readiness check configurations. If you
    want to match one of the composing resource status fields to a predefined string,
    use `MatchString`. A sample configuration for `MatchString` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '`MatchInteger` will perform a similar function when two integers are matched.
    The following sample configuration will check the `state` attribute with integer
    `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `None` type to consider the readiness as soon as the resource is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `NonEmpty` to make the resource ready as soon as some value exists in the
    field of our choice. The following example will make the readiness true as soon
    as some value exists under the mentioned field path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at an example of patching a status attribute
    after resource provisioning. Note that `fieldPath` falls under the `status` attribute.
    These are the attributes filled by MR during resource provisioning based on the
    values it gets back from the cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: Patch status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ToCompositeFieldPath` is a patch type for copying any attribute from a specific
    composed resource back into the XR. Generally, we use it to copy the status fields.
    We can look at these as a way to define the API response. While there is a set
    of existing default status fields, patched fields are custom defined to enhance
    our debugging, monitoring, and audit activities. First, we need to define the
    state fields as a part of openAPIV3Schema in the XRD to make the new status fields
    available in the XR. The next step is to define a patch under the specific composing
    resource. The following patch will copy the current disk size of the CloudSQLInstance
    to the XR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `CombineToComposite` patch type if we need to copy a combination
    of multiple fields.
  prefs: []
  type: TYPE_NORMAL
- en: Propagating credentials back
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can see that the connection secret-related configuration is part of the
    XRD, XR, claim, and composition. We must understand the relationship between these
    configurations to configure it correctly and get it working:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the list of connection secret keys in the XRD using the `ConnectionSecretKeys`
    configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the composing resources to define how to populate connection keys
    defined in the XRD. Connection details configuration can be of different types.
    The `FromConnectionSecretKey` type is correct when copying the secret from an
    existing secret key. We have the `FromFieldPath` type for copying the connection
    details from one of the composing resource fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The claim or XR should save the Secrets using the `WriteConnectionSecretToRef`
    configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram can help create a mind map of these configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Propagating the Secrets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Propagating the Secrets
  prefs: []
  type: TYPE_NORMAL
- en: The section covered different patterns that we can use with composition after
    the resources are provisioned. It is like customizing the API responses. Now we
    can look at the usefulness of reusing existing resources.
  prefs: []
  type: TYPE_NORMAL
- en: Preprovisioned resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few use cases where we may not create a new external resource and
    instead will reuse an existing provisioned resource. We will look at two such
    use cases in this section. The first use case is when we decide to cache the composed
    recourses because new resource provisioning may take too long to complete. The
    platform team can provision an XR and keep the resources in the resource pool.
    Then, the product team can claim these resources by adding the `ResourceRef` configuration
    under the spec of a claim YAML. With this pattern, we should ensure that the new
    claim attributes match the attributes in the existing pre-provisioned XR. If some
    of the attributes are different, Crossplane will try to update the XR specifications
    to match what is mentioned in the claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second use case is about importing the existing resources from the external
    provider into the Crossplane. The `crossplane.io/external-name` annotation can
    help with this. Crossplane will look for an existing resource with the name mentioned
    in this configuration. The external name configuration mentioned in a claim will
    automatically be propagated into the XR. Still, it’s our responsibility to patch
    this configuration into the composing resource. The following is a sample MR YAML
    where we onboard an existing VPC with the name `alpha-beta-vpc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you apply the YAML, you will see that it’s ready for use in Crossplane.
    This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – VPC reference status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – VPC reference status
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `alpha-beta-vpc` VPC is an existing VPC we created manually in
    GCP. What we achieve here is to map the manual resource to a Claim.The section
    covered different ways we can use preprovisioned resources with an XR/claim. The
    following section will be a hands-on journey to build an XR from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Building an XR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to go through a hands-on journey to build an XR from scratch. We will
    start with writing down the infrastructure API requirement at a high level, then
    provide an API specification with XRD and finally provide an implementation with
    a composition. We will cover the API requirement in such a way as to learn most
    of the configuration discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure API requirement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will develop an API to provision a database from Google Cloud. The following
    are the compliance, architecture, and product team’s requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`us-central` region to comply with the data storage regulations from the government.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architecture policy**: We should have two tiers of the database. For small,
    the disk size should be 20 GB, and it should be 40 GB for big.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db-g1-small`, and `db-n1-standard-1` for the big tier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product team**: We should have the option to choose between Postgres and
    MySQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SMALL` or `BIG`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform team**: Patch the zone in which the database is created back into
    the XR/claim status field for monitoring requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to write the XRD configuration YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the XRD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When defining the API specification with an XRD, the following configurations
    should be encoded into the YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `alpha-beta.imarunrk.com` as the API group to organize all APIs for alpha
    and beta teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will provide the XR name as `XGCPdb` and the claim name as `GCPdb`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with a new API version, v1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create `size` as an input parameter and `zone` as the response status attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the example XRD is oversized, we will cover only the schema definition here.
    Refer to the entire XRD file at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml).
    Without wasting much time, let’s look at the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the YAML from GitHub and apply it to the cluster with `kubectl apply -f
    xrd.yaml`. Refer to the following screenshot, which shows successful XRD creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – XRD creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – XRD creation
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `ESTABLISHED` and `OFFERED` flags in the screenshot are `True`.
    This means that the XRD is created correctly. If these statuses are not `True`,
    use kubectl to describe the details of the XRD and look for an error.
  prefs: []
  type: TYPE_NORMAL
- en: Providing implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to provide an API implementation. As a part of the implementation,
    we should be providing a composition configuration. We will create two compositions,
    one for Postgres and the other for MySQL. It will be an example of the polymorphic
    behavior implementation. The following are the steps to remember when we build
    the composition YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the v1 XRD API version with the `CompositeTypeRef` configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `CloudSQLInstance` configuration under the resource base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hardcode the region to `us-central1` to meet the compliance requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The database tier and disk size will hold default values, but the patch configuration
    will overlay them using the `FromCompositeFieldPath` patch type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Map` transformation to convert the `SMALL` tier size to the `db-g1-small`
    machine tier. Use the `Map` and `Convert` transformations to map the `SMALL` tier
    size to the 20 GB disk size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similar mapping will be done for the `BIG` configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Patch the `GceZone` attribute from the MR status to the XR/claim for monitoring.
    We can achieve this using the `ToCompositeFieldPath` patch type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a mapping between the MR connection secret key to the XR/claim keys
    with the `ConnectionDetails` configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will look at the Postgres composition example in four parts. The XRD and
    resource definition section of the composition will look like the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Read through the comments between the code snippets to understand concepts
    in detail. The following configuration uses the map transform to patch the virtual
    machine tier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can look at the configuration to patch the disk size. The patch will
    have two transform operations. The first operation is to map the disk size, and
    the second one is to convert the mapped string to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following patch adds the resource zone into the API response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: The composition configuration for MySQL will be the same as the preceding configuration,
    excluding two changes. We should be changing the name of the composition in the
    metadata, and in the resource definition, we should change the database version
    to `MYSQL_5_7`. We can implement this with an additional parameter in the XR as
    well. Building two different compositions does not make sense when the difference
    is so small. We can capture the difference as a parameter in the XR. We are building
    two compositions, as an example. All composition examples and the upcoming claim
    examples are available for reference at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR).
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot, which shows the successful creation of both
    compositions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Composition created'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Composition created
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to use the claim API and create the database resources.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the resources with a claim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we can start provisioning the GCP database with an XR or a claim.
    The `CompositionRef` configuration will specify which composition implementation
    to use. Note that the claims are namespace resources, and we provision them in
    the `alpha` namespace here. The following is a sample claim YAML for the MySQL
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'The Postgres YAML as well will look similar with minor changes. Refer to the
    following screenshot, which shows a successful database creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Claim status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Claim status
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the zone information is made available as the part of claim status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Zone information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17830_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Zone information
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the journey to build an XR. We will look at a few troubleshooting
    tips.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we face issues with our infrastructure API, these tips could help us debug
    the problem in the best possible way:'
  prefs: []
  type: TYPE_NORMAL
- en: Status attributes and events are essential elements to debug issues. These details
    can be viewed by running `kubectl describe` on the given resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we start looking for issues, we take a top-down approach. This is because
    Crossplane follows the same convention as Kubernetes to hold the errors close
    to the resource where it happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debugging order will be *claim*, then *XR*, and then *each composing resource*.
    We should start with a claimed object. If we cannot locate the issue, we go deep
    into the XR and then the composing resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.resourceRef` from the claim description can help us to identify the XR
    name. Again, the same attribute can be used to find the composing resources from
    the XR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an intentional mistake in the resource configuration of the composition
    to go through the debugging experience. You learn more when you debug issues.
    This concludes our troubleshooting section. Next, we will look at the chapter
    summary before moving on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we covered one of the critical aspects of Crossplane, the
    XR. We started with understanding how an XR works and configuring an XR. Above
    all, we went through a hands-on journey to build a fresh infrastructure API from
    end to end. The chapter also covered some advanced XR configuration patterns and
    ways to approach debugging when there is an issue. This will be the base knowledge
    for what we will learn in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover different advanced infrastructure platform patterns.
  prefs: []
  type: TYPE_NORMAL
