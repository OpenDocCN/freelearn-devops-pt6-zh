- en: '*Chapter 4*: Composing Infrastructure with Crossplane'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*: 使用 Crossplane 组合基础设施'
- en: Composing is a powerful construct of Crossplane that makes it unique among its
    peers, such as the Open Service Broker API or AWS Controllers for Kubernetes.
    The ability to organize infrastructure recipes in a no-code way perfectly matches
    the organization’s agile expectation of building a lean platform team. This chapter
    will take us on a journey to learn about composing from end to end. We will start
    with a detailed understanding of how Crossplane **Composite Resources** (**XRs**)
    work and then cover a hands-on journey to build an XR step by step.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是 Crossplane 的一个强大构造，使其在同类产品中独树一帜，如 Open Service Broker API 或 AWS Kubernetes
    控制器。以无代码的方式组织基础设施方案的能力，完美契合了组织在构建精益平台团队时对敏捷的期望。本章将带我们从头到尾学习组合。我们将从详细了解 Crossplane
    **复合资源**（**XR**）如何工作开始，然后一步步深入了解如何构建一个 XR。
- en: 'The following are the topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主题：
- en: Feeling like an API developer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感觉像一个 API 开发者
- en: How do XRs work?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XR 如何工作？
- en: Postprovisioning of an XR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XR 后配置
- en: Preprovisioned resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预配置资源
- en: Building an XR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 XR
- en: Troubleshooting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除
- en: Feeling like an API developer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感觉像一个 API 开发者
- en: 'Traditionally, infrastructure engineers know the most profound infrastructure
    configuration options and different infrastructure setup patterns. But they may
    not have experience in building APIs. Building an infrastructure platform with
    Crossplane will be a shift from these usual ways. Modern infrastructure platform
    developers should have both pieces of knowledge, that is, infrastructure and API
    engineering. Building infrastructure APIs as a platform developer means implementing
    the following aspects:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，基础设施工程师了解最深刻的基础设施配置选项和不同的基础设施设置模式。但他们可能没有构建 API 的经验。使用 Crossplane 构建基础设施平台将是这些传统方式的一种转变。现代基础设施平台开发者应该具备两方面的知识，即基础设施和
    API 工程。作为平台开发者，构建基础设施 API 意味着实现以下方面：
- en: Evolving the APIs as time passes by. This involves introducing new APIs, updating
    an existing API version, and deprecating the old APIs.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，API 会不断演变。这包括引入新的 API、更新现有的 API 版本以及废弃旧的 API。
- en: Applying API cross-cutting concerns for consuming product teams, such as authentication,
    authorization, caching, and auditing.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为消费产品团队应用 API 跨领域关注点，如认证、授权、缓存和审计。
- en: Encapsulating different infrastructure policies within the APIs.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 API 中封装不同的基础设施策略。
- en: Building reusable infrastructure recipes used across teams. For example, some
    product teams might develop their applications with the **MEAN** stack (**MongoDB,
    Express.js, AngularJS, and Node.js**). We might be interested in developing infrastructure
    provisioning for this stack as a template API.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建跨团队共享的可复用基础设施方案。例如，一些产品团队可能使用 **MEAN** 技术栈（**MongoDB、Express.js、AngularJS
    和 Node.js**）开发应用程序。我们可能有兴趣为这个技术栈开发作为模板 API 的基础设施配置。
- en: Building the required shared infrastructure used across teams. For example,
    we might want to provision a virtual private network shared by different infrastructure
    resources.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建跨团队共享的基础设施。例如，我们可能希望提供一个虚拟私人网络，供不同的基础设施资源共享。
- en: Achieving and evolving correct API boundaries considering the different infrastructure
    recipes and shared infrastructure. We must perform trade-off analysis to deal
    with conflicting concerns between infrastructure recipes and shared infrastructure.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到不同的基础设施方案和共享基础设施，达成并不断演进正确的 API 边界。我们必须进行权衡分析，以处理基础设施方案和共享基础设施之间的冲突。
- en: 'Infrastructure recipes and shared infrastructure are vital elements in API-bounded
    context trade-offs. We will examine this in detail in an upcoming chapter. The
    following figure represents the nuances of API infrastructure engineering:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施方案和共享基础设施是 API 边界上下文权衡中的重要因素。我们将在接下来的章节中详细探讨这一点。下图展示了 API 基础设施工程的细节：
- en: '![Figure 4.1 – API infrastructure engineering'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – API 基础设施工程'
- en: '](img/B17830_04_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_01.jpg)'
- en: Figure 4.1 – API infrastructure engineering
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – API 基础设施工程
- en: We are looking at these aspects to understand XR architecture in the best possible
    way. Every element of the Crossplane composite is designed to cover infrastructure
    engineering practices from the perspective of an API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从这些方面入手，以便尽可能最佳地理解 XR 架构。Crossplane 复合体的每个元素都是从 API 角度设计的，以覆盖基础设施工程实践。
- en: Tip
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We can use the learnings from microservices architecture pattern to define infrastructure
    API boundaries. There is no perfect boundary, and every design option will have
    advantages and disadvantages. In [*Chapter 6*](B17830_06_ePub.xhtml#_idTextAnchor092),
    *More Crossplane Patterns*, we can look for ways to adopt microservices with the
    Crossplane infrastructure platform.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用微服务架构模式的经验来定义基础设施 API 边界。没有完美的边界，每种设计方案都会有优缺点。在[*第 6 章*](B17830_06_ePub.xhtml#_idTextAnchor092)《更多
    Crossplane 模式》中，我们可以寻找将微服务与 Crossplane 基础设施平台结合的方法。
- en: How do XRs work?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XR 是如何工作的？
- en: 'An XR can do two things under the hood. The first purpose is to combine related
    **Managed Resources** (**MRs**) into a single stack and build reusable infrastructure
    template APIs. When we do this, we might apply different patterns, such as shared
    resources between applications or cached infrastructure for faster provisioning.
    The second one is to expose only limited attributes of the infrastructure API
    to the application team after abstracting all organization policies. We will get
    into the details of achieving these aspects as we progress in this chapter. The
    following are the critical components in an XR:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: XR 可以在后台做两件事。第一个目的是将相关的**托管资源**（**MRs**）组合成一个堆栈，并构建可重用的基础设施模板 API。当我们这样做时，可能会应用不同的模式，例如应用之间共享资源或用于更快速提供的缓存基础设施。第二个目的是在抽象了所有组织策略后，只向应用团队公开有限的基础设施
    API 属性。随着本章的深入，我们将详细探讨实现这些方面的细节。以下是 XR 中的关键组件：
- en: '**Composite Resource Definition** (**XRD**)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合资源定义**（**XRD**）'
- en: Composition
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组成
- en: Claim
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明
- en: Let’s start looking at the purpose of each component and how they interact with
    each other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始查看每个组件的目的以及它们如何相互作用。
- en: XRD
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XRD
- en: 'The `CompositeResourceDefinition` is the Crossplane configuration element used
    to define an XRD. Creating this configuration is like writing an OpenAPI Specification
    or Swagger API definition. The following are the critical aspects of the `CompositeResourceDefinition`
    configuration YAML:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositeResourceDefinition` 是用于定义 XRD 的 Crossplane 配置元素。创建此配置就像编写 OpenAPI
    规范或 Swagger API 定义。以下是 `CompositeResourceDefinition` 配置 YAML 的关键方面：'
- en: '`kind` attribute of the new API. Note that it’s standard practice to use *X*
    as a prefix for the XR name.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新 API 的 `kind` 属性。请注意，使用 *X* 作为 XR 名称的前缀是标准做法。
- en: '**API group**: This will help us to group the API logically, avoid naming conflicts,
    and manage authorization.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 组**: 这将帮助我们逻辑地分组 API，避免命名冲突，并管理授权。'
- en: '`<resource plural name>.<API group>`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<resource plural name>.<API group>`。'
- en: '`versions` element is an array and can hold configuration for multiple versions
    of the same XR API. Typically, when we start, we will have just one version. As
    time progresses, we will increment the API version with changes. The old version
    can become a technical debt to deprecate later.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions` 元素是一个数组，可以容纳同一 XR API 的多个版本配置。通常，在我们开始时，只会有一个版本。随着时间的推移，我们将随着变化增加
    API 版本。旧版本可能会变成技术负担，需要在之后弃用。'
- en: '`served` element will indicate whether the XR API is served with the given
    version. The `referenceable` flag will determine whether we can define an implementation
    for the given API version. We can look at version management and these attributes
    in more depth in [*Chapter 5*](B17830_05_ePub.xhtml#_idTextAnchor074), *Exploring
    Infrastructure Platform Patterns*. For now, both flags will be `true` when we
    have only one version defined in the XRD.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`served` 元素将指示给定版本的 XR API 是否已经提供服务。`referenceable` 标志将决定我们是否可以为给定的 API 版本定义实现。我们可以在[*第
    5 章*](B17830_05_ePub.xhtml#_idTextAnchor074)《探索基础设施平台模式》中更深入地研究版本管理和这些属性。现在，当我们在
    XRD 中定义了唯一版本时，两个标志都将为 `true`。'
- en: '**Schema**: This is a section under each version covering the actual OpenAPI
    specification. It covers details such as parameter lists, data types, and required
    parameters.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Schema**: 这是每个版本下的一个部分，涵盖了实际的 OpenAPI 规范。它包括诸如参数列表、数据类型和必需参数等详细信息。'
- en: '**Connection secret keys**: This will hold the list of keys that need to be
    created and populated in the Kubernetes Secrets after the resource provisioning.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接密钥**: 这将包含需要在资源提供后创建并填充到 Kubernetes Secrets 中的密钥列表。'
- en: '`DefaultCompositionRef` and `EnforcedCompositionRef` are a couple of attributes
    providing this flexibility.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultCompositionRef` 和 `EnforcedCompositionRef` 是提供这种灵活性的几个属性。'
- en: '**Claim names**: These are optional parameters that create a proxy API for
    the given XR API with the specified name. Applying the claim object’s create,
    delete, and update action will create, delete, and update the underlying XR. Claims
    are a critical component in Crossplane, and we will look at that in a dedicated
    topic shortly in this chapter.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Claim 名称**：这些是可选参数，用于为指定名称的 XR API 创建一个代理 API。应用 claim 对象的创建、删除和更新操作将创建、删除和更新底层
    XR。Claims 是 Crossplane 中的关键组件，我们将在本章稍后的专门主题中讨论它。'
- en: The XRD is nothing but an opinionated **Custom Resource Definition** (**CRD**),
    and many parts of the configuration look like a CRD. These are just a few possible
    parameters. We will look at a few more parameters as we progress through the book.
    The complete API documentation is available at [https://doc.crds.dev/github.com/crossplane/crossplane](https://doc.crds.dev/github.com/crossplane/crossplane).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: XRD 仅仅是一个有特定意见的 **自定义资源定义**（**CRD**），许多配置部分看起来像 CRD。这些只是一些可能的参数。随着我们继续阅读本书，我们还会看到更多参数。完整的
    API 文档可以在 [https://doc.crds.dev/github.com/crossplane/crossplane](https://doc.crds.dev/github.com/crossplane/crossplane)
    上找到。
- en: Tip
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We are looking at v1.5.1 of the Crossplane documentation, which is the latest
    at the time of writing this chapter. Refer to the latest version at the time of
    reading for more accurate details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在查看 Crossplane 文档的 v1.5.1 版本，这是本章撰写时的最新版本。请参考阅读时的最新版本以获取更准确的详细信息。
- en: 'Note that some of the configurations discussed previously are not part of the
    following YAML, such as `DefaultCompositionRef` and `ConnectionSecretKeys`. These
    configurations are injected by Crossplane with default behavior if not specified.
    Refer to the following YAML for an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，之前讨论的一些配置并不包含在下面的 YAML 中，例如 `DefaultCompositionRef` 和 `ConnectionSecretKeys`。如果未指定，这些配置会由
    Crossplane 注入并采用默认行为。请参考以下 YAML 示例：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once we are done with the API specification, the next step is to build the API
    implementation. Composition is the Crossplane construct used for providing API
    implementation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 API 规范之后，下一步是构建 API 实现。Composition 是 Crossplane 用于提供 API 实现的构造。
- en: Composition
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Composition
- en: 'The composition will link one or more MRs with an XR API. When we create, update,
    and delete an XR, the same operation will happen on all the linked MRs. We can
    consider XRD as the CRD and composition as the custom controller implementation.
    The following diagram represents how XR, XRD, composition, and MRs are related:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Composition 将一个或多个 MRs 与 XR API 关联。当我们创建、更新和删除 XR 时，相同的操作将应用于所有关联的 MRs。我们可以将
    XRD 看作是 CRD，而 composition 则是自定义控制器实现。下面的图示展示了 XR、XRD、composition 和 MRs 之间的关系：
- en: '![Figure 4.2 – XRM, composition, and XR'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – XRM、composition 和 XR'
- en: '](img/B17830_04_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_02.jpg)'
- en: Figure 4.2 – XRM, composition, and XR
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – XRM、composition 和 XR
- en: Tip
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We have referred to XR in this book in two contexts. We can use XR to refer
    to a new infrastructure API that we are building. Also, the composition resources
    list can hold both an MR and an existing XR. We will also refer to an XR from
    that context. Look at *Figure 4.2* where XR is referred to in both dimensions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们提到 XR 有两种上下文。我们可以使用 XR 来指代我们正在构建的新基础设施 API。并且，composition 资源列表可以同时包含一个
    MR 和一个现有的 XR。我们也会在那个上下文中提到 XR。请看 *图 4.2*，在其中 XR 被提及于两个维度。
- en: 'Let’s look at some of the crucial elements from the composition configuration:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 composition 配置中的一些关键元素：
- en: '`kind` and `apiVersion` are the two configuration elements defined under `CompositeTypeRef`.
    While `kind` specifies the XR name, `apiVersion` will refer to a specific version
    defined in the XRD. The mapped version should be configured as referenceable in
    the XRD.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind` 和 `apiVersion` 是在 `CompositeTypeRef` 下定义的两个配置元素。`kind` 用于指定 XR 名称，`apiVersion`
    将引用在 XRD 中定义的特定版本。映射的版本应配置为在 XRD 中可以引用。'
- en: '**WriteConnectionSecretsToNamespace**: This will specify the namespace for
    storing the connection Secrets.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WriteConnectionSecretsToNamespace**：此项将指定用于存储连接密钥的命名空间。'
- en: '**Resources**: This section is an array that holds the list of MRs to be created,
    updated, and deleted when someone creates, updates, and deletes the XR. We can
    even define another XR under this section. It is a mandatory section, and we should
    define at least one resource, either an MR or XR. The base is the critical object
    under each resource that holds the XR/MR configuration template.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：这一部分是一个数组，包含创建、更新和删除 XR 时需要创建、更新和删除的 MR 列表。我们甚至可以在这一部分定义另一个 XR。这是一个必填部分，我们必须定义至少一个资源，可以是
    MR 或 XR。Base 是每个资源下的关键对象，保存 XR/MR 配置模板。'
- en: '`FromCompositeFieldPath` is the default type and is used most frequently. It
    is helpful to patch an attribute from the XR into the composition resource base
    template, that is, feeding the user input into the composing resources. `FromFieldPath`
    and `ToFieldPath` are the subattributes that perform the actual patching. There
    is a patch type called `ToCompositeFieldPath`, which does the reverse of `FromCompositeFieldPath`.
    We could copy fields from the resources back into the XR using this patch type.
    The `CombineFromComposite` patch type is the most suitable option when combining
    multiple attributes.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromCompositeFieldPath` 是默认类型，使用最为频繁。它有助于将 XR 中的属性补丁到组合资源基础模板中，即将用户输入传入组合资源。`FromFieldPath`
    和 `ToFieldPath` 是执行实际补丁操作的子属性。有一个补丁类型叫做 `ToCompositeFieldPath`，它的作用是执行与 `FromCompositeFieldPath`
    相反的操作。我们可以使用这个补丁类型将字段从资源复制回 XR。`CombineFromComposite` 补丁类型在组合多个属性时最为适用。'
- en: '`convert` for typecasting, `math` for mathematical operations, and `map` for
    key-value operations. We could have a list of transform functions on a given patch,
    and they are executed in the order specified in the configuration. Both patches
    and transforms are vital patterns. We will look at different configuration examples
    for patches and transforms throughout the book.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convert`用于类型转换，`math`用于数学运算，`map`用于键值操作。我们可以在给定的补丁中列出转换函数，它们按配置中指定的顺序执行。补丁和转换都是关键模式。在本书中，我们将查看不同的补丁和转换配置示例。'
- en: '**Policy**: These are under each patch and will determine the patching behavior.
    We can mandate the patch path presence because the default behavior is to skip
    the patch if the field is absent. Also, we can configure the behavior of merge
    when the patching is performed over an object.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Policy**：这些配置在每个补丁下，决定补丁行为。我们可以强制要求补丁路径的存在，因为默认行为是在字段缺失时跳过补丁。同时，我们可以配置在对对象执行补丁时的合并行为。'
- en: '**ConnectionDetails**: These are specified under each resource and will hold
    the list of secret keys we want to propagate back into the XR.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConnectionDetails**：这些是在每个资源下指定的，将保存我们希望回传到 XR 的密钥列表。'
- en: '**ReadinessChecks**: These will allow us to define any custom readiness logic.
    If this section is not provided, the default behavior is to make the XR state
    ready when all the composing resources are ready.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReadinessChecks**：这些允许我们定义任何自定义的就绪检查逻辑。如果没有提供该部分，则默认行为是在所有组合资源就绪时将 XR 状态标记为已就绪。'
- en: '`spec.parameters.storageSize` or `spec.versions[0].name`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.parameters.storageSize` 或 `spec.versions[0].name`。'
- en: 'We covered most of the configuration options available with the composition.
    Have a look at the Crossplane documentation for the complete list. The following
    figure represents the composition configuration options and the relationship between
    them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已覆盖了组合配置中大部分可用的选项。请查看 Crossplane 文档，了解完整的选项列表。下图展示了组合配置选项及其相互关系：
- en: '![Figure 4.3 – Composition configuration'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 组合配置](img/B17830_04_03.jpg)'
- en: '](img/B17830_04_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_03.jpg)'
- en: Figure 4.3 – Composition configuration
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 组合配置
- en: 'The following is a sample composition configuration YAML:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例的组合配置 YAML：
- en: '[PRE40]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We will cover an example with more configuration elements in the *Building an
    XR* section. An XRD version can have more than one composition, that is, one-to-many
    relationships between the XRD version and composition. It provides polymorphic
    behavior for our infrastructure API to work based on the context. For example,
    we could have different compositions defined for production and staging. The `CompositionRef`
    attribute defined in the XR can refer to a specific composition. Instead of `CompositionRef`,
    we can also use `CompositionSelector` to match the compositions based on labels.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*构建 XR*一节中介绍一个包含更多配置元素的示例。一个 XRD 版本可以有多个组合，也就是 XRD 版本与组合之间的一对多关系。它为我们的基础设施
    API 提供了多态行为，以便根据上下文进行工作。例如，我们可以为生产和暂存环境定义不同的组合。XR 中定义的 `CompositionRef` 属性可以引用特定的组合。除了
    `CompositionRef`，我们还可以使用 `CompositionSelector` 基于标签匹配组合。
- en: '![Figure 4.4 – XR and composition relation'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – XR 和组合关系'
- en: '](img/B17830_04_04.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_04.jpg)'
- en: Figure 4.4 – XR and composition relation
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – XR 和组合关系
- en: In the next section, we will look at **XR claims**, also known as **claims**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看**XR 声明**，也称为**声明**。
- en: Claim
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明
- en: 'A claim is a proxy API to the XR, created by providing claim name attributes
    in XRD configurations. As a general practice, we provide the exact name of the
    XR after removing the initial `X`. In the preceding example, `xclouddb` is the
    XR name and `Clouddb` is the claim name but following such naming conventions
    is not mandatory. Claims are very similar to the XR, and it might tempt us to
    think that it’s an unnecessary proxy layer. Having a claim is helpful in many
    ways, such as the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 声明是对 XR 的代理 API，通过在 XRD 配置中提供声明名称属性来创建。一般做法是提供 XR 的精确名称，并去掉最前面的 `X`。在上述示例中，`xclouddb`
    是 XR 名称，`Clouddb` 是声明名称，但遵循这种命名约定并非强制要求。声明与 XR 非常相似，可能会让我们认为它是一个不必要的代理层。然而，声明在许多方面都是有帮助的，例如：
- en: XRs are cluster-level resources, while the claims are namespace level. It enables
    us to create namespace-level authorization. For example, we can assign different
    permissions for different product teams based on their namespace ownership.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XRs 是集群级别的资源，而声明是命名空间级别的。这使我们能够创建命名空间级别的授权。例如，我们可以根据不同产品团队的命名空间所有权，分配不同的权限。
- en: We can keep some of the XR only as a private API at the cluster level for the
    platform team’s use. For example, the platform team may not be interested in exposing
    the XR API that creates a virtual private network.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将某些 XR 仅作为集群级别的平台团队专用私有 API。例如，平台团队可能不希望公开创建虚拟专用网络的 XR API。
- en: It’s not ideal to manage some of the resources at the namespace level as they
    are shared between teams and do not fit into the context.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间级别管理某些资源并不理想，因为这些资源是多个团队共享的，无法适应上下文。
- en: We can also use this pattern to support the preprovisioning of infrastructure.
    A claim can just reference itself with a preprovisioned XR infrastructure, keeping
    the provisioning time low. It is very similar to caching.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用这种模式来支持基础设施的预配置。声明可以通过引用已经预配置的 XR 基础设施，保持较低的配置时间。这与缓存非常相似。
- en: 'The following figure represents how claims, XR, XRD, composition, and MRs are
    related, giving an end-to-end view of how the whole concept works:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示声明、XR、XRD、组合和 MR 之间的关系，提供了一个端到端的视图，展示了整个概念的工作方式：
- en: '![Figure 4.5 – How does composition work?'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 组合是如何工作的？'
- en: '](img/B17830_04_05.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_05.jpg)'
- en: Figure 4.5 – How does composition work?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 组合是如何工作的？
- en: 'The following are the sample claim and XR YAML. The claim YAML is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例声明和 XR 的 YAML。声明 YAML 如下：
- en: '[PRE74]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'A namespace is not part of the preceding claim YAML. Hence, it will create
    the resource in the default namespace, the Kubernetes standard. An equivalent
    XR YAML to the preceding claim YAML is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 YAML 中不包含命名空间部分。因此，它将在默认命名空间中创建资源，这是 Kubernetes 的标准。与上述声明 YAML 等效的 XR YAML
    如下：
- en: '[PRE89]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note that the XR is always created at the cluster level and namespace configuration
    under metadata is not applicable. We can look at a more detailed claim and XR
    configurations in the *Building an XR* section. Let’s explore a few more XR, XRD,
    composition, and claim configurations from the perspective of postprovisioning
    requirements.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，XR 总是以集群级别创建，元数据下的命名空间配置不适用。我们可以在*构建 XR*一节中查看更详细的声明和 XR 配置。让我们从后置配置的角度，探索更多
    XR、XRD、组合和声明配置。
- en: Postprovisioning of an XR
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XR 的后置配置
- en: 'After performing CRUD operations over a claim or XR resource, the following
    are some critical aspects to bring the API request to a close:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在对声明或 XR 资源执行 CRUD 操作后，以下是完成 API 请求的一些关键方面：
- en: Readiness check
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就绪检查
- en: Patch status
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补状态
- en: Propagating the credentials back
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将凭据传播回来
- en: Let’s start with learning about readiness checks.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习就绪检查开始。
- en: Readiness check
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就绪检查
- en: 'The XR state will be ready by default when all the underlying resources are
    ready. Every resource element in the composition can define its custom readiness
    logic. Let’s look at a few of the custom readiness check configurations. If you
    want to match one of the composing resource status fields to a predefined string,
    use `MatchString`. A sample configuration for `MatchString` is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有底层资源都准备就绪时，XR 状态将默认就绪。组合中的每个资源元素都可以定义其自定义的就绪逻辑。让我们看一些自定义就绪检查配置。如果你想将某个组合资源的状态字段与预定义的字符串匹配，使用
    `MatchString`。`MatchString` 的示例配置如下：
- en: '[PRE101]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '`MatchInteger` will perform a similar function when two integers are matched.
    The following sample configuration will check the `state` attribute with integer
    `1`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`MatchInteger` 在匹配两个整数时将执行类似的功能。以下示例配置将检查 `state` 属性与整数 `1`：'
- en: '[PRE104]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Use the `None` type to consider the readiness as soon as the resource is available:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `None` 类型，将资源一旦可用就认为就绪：
- en: '[PRE107]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Use `NonEmpty` to make the resource ready as soon as some value exists in the
    field of our choice. The following example will make the readiness true as soon
    as some value exists under the mentioned field path:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NonEmpty` 使资源在指定字段中存在某个值时立即就绪。以下示例将使就绪状态为真，只要在指定的字段路径下存在某个值：
- en: '[PRE108]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In the next section, we will look at an example of patching a status attribute
    after resource provisioning. Note that `fieldPath` falls under the `status` attribute.
    These are the attributes filled by MR during resource provisioning based on the
    values it gets back from the cloud provider.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看在资源配置后修补状态属性的示例。请注意，`fieldPath` 属于 `status` 属性。这些是由 MR 在资源配置过程中根据从云提供商返回的值填写的属性。
- en: Patch status
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修补状态
- en: '`ToCompositeFieldPath` is a patch type for copying any attribute from a specific
    composed resource back into the XR. Generally, we use it to copy the status fields.
    We can look at these as a way to define the API response. While there is a set
    of existing default status fields, patched fields are custom defined to enhance
    our debugging, monitoring, and audit activities. First, we need to define the
    state fields as a part of openAPIV3Schema in the XRD to make the new status fields
    available in the XR. The next step is to define a patch under the specific composing
    resource. The following patch will copy the current disk size of the CloudSQLInstance
    to the XR:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToCompositeFieldPath` 是一种补丁类型，用于将特定组合资源中的任何属性复制回 XR。通常，我们用它来复制状态字段。我们可以将这些视为定义
    API 响应的一种方式。虽然已有一组默认的状态字段，修补的字段是自定义定义的，用于增强我们的调试、监控和审计活动。首先，我们需要在 XRD 中将状态字段定义为
    openAPIV3Schema 的一部分，以便在 XR 中使新状态字段可用。下一步是在特定的组合资源下定义补丁。以下补丁将把 CloudSQLInstance
    当前的磁盘大小复制到 XR：'
- en: '[PRE110]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We can also use the `CombineToComposite` patch type if we need to copy a combination
    of multiple fields.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要复制多个字段的组合，可以使用 `CombineToComposite` 补丁类型。
- en: Propagating credentials back
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将凭据传播回来
- en: 'We can see that the connection secret-related configuration is part of the
    XRD, XR, claim, and composition. We must understand the relationship between these
    configurations to configure it correctly and get it working:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到与连接密钥相关的配置是 XRD、XR、声明和组合的一部分。我们必须理解这些配置之间的关系，以便正确配置并使其正常工作：
- en: Define the list of connection secret keys in the XRD using the `ConnectionSecretKeys`
    configuration.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConnectionSecretKeys` 配置在 XRD 中定义连接密钥列表。
- en: Configure the composing resources to define how to populate connection keys
    defined in the XRD. Connection details configuration can be of different types.
    The `FromConnectionSecretKey` type is correct when copying the secret from an
    existing secret key. We have the `FromFieldPath` type for copying the connection
    details from one of the composing resource fields.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置组合资源以定义如何填充 XRD 中定义的连接密钥。连接详情的配置可以有不同的类型。当从现有的密钥复制秘密时，`FromConnectionSecretKey`
    类型是正确的。我们有 `FromFieldPath` 类型用于从某个组合资源字段中复制连接详情。
- en: The claim or XR should save the Secrets using the `WriteConnectionSecretToRef`
    configuration.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明或XR应该使用`WriteConnectionSecretToRef`配置来保存机密。
- en: 'The following diagram can help create a mind map of these configurations:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示有助于创建这些配置的思维导图：
- en: '![Figure 4.6 – Propagating the Secrets'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 传播机密](img/B17830_04_06.jpg)'
- en: '](img/B17830_04_06.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_06.jpg)'
- en: Figure 4.6 – Propagating the Secrets
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 传播机密
- en: The section covered different patterns that we can use with composition after
    the resources are provisioned. It is like customizing the API responses. Now we
    can look at the usefulness of reusing existing resources.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了在资源配置后我们可以与组合一起使用的不同模式。这就像定制API响应。现在我们可以看看重用现有资源的实用性。
- en: Preprovisioned resources
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预配置资源
- en: There are a few use cases where we may not create a new external resource and
    instead will reuse an existing provisioned resource. We will look at two such
    use cases in this section. The first use case is when we decide to cache the composed
    recourses because new resource provisioning may take too long to complete. The
    platform team can provision an XR and keep the resources in the resource pool.
    Then, the product team can claim these resources by adding the `ResourceRef` configuration
    under the spec of a claim YAML. With this pattern, we should ensure that the new
    claim attributes match the attributes in the existing pre-provisioned XR. If some
    of the attributes are different, Crossplane will try to update the XR specifications
    to match what is mentioned in the claim.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些使用场景下，我们可能不会创建新的外部资源，而是会重用现有的已配置资源。本节将介绍两个此类使用场景。第一个使用场景是当我们决定缓存已组合的资源时，因为新的资源配置可能需要较长时间才能完成。平台团队可以配置一个XR并将资源保持在资源池中。然后，产品团队可以通过在声明YAML的spec下添加`ResourceRef`配置来申请这些资源。在这种模式下，我们应确保新声明的属性与现有预配置XR中的属性匹配。如果某些属性不同，Crossplane将尝试更新XR规范，以匹配声明中提到的内容。
- en: 'The second use case is about importing the existing resources from the external
    provider into the Crossplane. The `crossplane.io/external-name` annotation can
    help with this. Crossplane will look for an existing resource with the name mentioned
    in this configuration. The external name configuration mentioned in a claim will
    automatically be propagated into the XR. Still, it’s our responsibility to patch
    this configuration into the composing resource. The following is a sample MR YAML
    where we onboard an existing VPC with the name `alpha-beta-vpc`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个使用场景是将现有资源从外部提供者导入到Crossplane中。`crossplane.io/external-name`注释可以帮助实现这一点。Crossplane将查找配置中提到的名称的现有资源。在声明中提到的外部名称配置将自动传播到XR中。然而，我们有责任将此配置补丁到组合资源中。以下是一个示例MR
    YAML，其中我们将现有的名为`alpha-beta-vpc`的VPC引入：
- en: '[PRE113]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Once you apply the YAML, you will see that it’s ready for use in Crossplane.
    This can be seen in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了YAML文件，您将看到它已准备好在Crossplane中使用。以下截图可以看到这一点：
- en: '![Figure 4.7 – VPC reference status'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – VPC引用状态](img/B17830_04_07.jpg)'
- en: '](img/B17830_04_07.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_07.jpg)'
- en: Figure 4.7 – VPC reference status
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – VPC引用状态
- en: Note that the `alpha-beta-vpc` VPC is an existing VPC we created manually in
    GCP. What we achieve here is to map the manual resource to a Claim.The section
    covered different ways we can use preprovisioned resources with an XR/claim. The
    following section will be a hands-on journey to build an XR from scratch.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`alpha-beta-vpc` VPC是我们在GCP中手动创建的现有VPC。我们在这里的目标是将手动资源映射到一个Claim。本节介绍了我们如何使用预配置资源与XR/声明结合的不同方式。接下来的部分将是从零开始构建XR的动手实践。
- en: Building an XR
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建XR
- en: It’s time to go through a hands-on journey to build an XR from scratch. We will
    start with writing down the infrastructure API requirement at a high level, then
    provide an API specification with XRD and finally provide an implementation with
    a composition. We will cover the API requirement in such a way as to learn most
    of the configuration discussed in this chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始动手构建一个从零开始的XR了。我们将从高层次编写基础设施API需求开始，然后提供XRD的API规范，最后通过组合提供实现。我们将在本章中讨论的大部分配置都将涵盖在API需求中。
- en: The infrastructure API requirement
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施API需求
- en: 'We will develop an API to provision a database from Google Cloud. The following
    are the compliance, architecture, and product team’s requirements:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个API，从Google Cloud中配置一个数据库。以下是合规性、架构和产品团队的需求：
- en: '`us-central` region to comply with the data storage regulations from the government.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us-central`区域，以遵守政府的数据存储规定。'
- en: '**Architecture policy**: We should have two tiers of the database. For small,
    the disk size should be 20 GB, and it should be 40 GB for big.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构政策**：我们应该有两个数据库层级。对于小型配置，磁盘大小应为20 GB，对于大型配置，应为40 GB。'
- en: '`db-g1-small`, and `db-n1-standard-1` for the big tier.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db-g1-small`，和`db-n1-standard-1`用于大型层级。'
- en: '**Product team**: We should have the option to choose between Postgres and
    MySQL.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品团队**：我们应该有选择Postgres和MySQL的选项。'
- en: '`SMALL` or `BIG`).'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SMALL`或`BIG`)。'
- en: '**Platform team**: Patch the zone in which the database is created back into
    the XR/claim status field for monitoring requirements.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台团队**：将数据库创建的区域补丁回XR/声明状态字段中，以满足监控要求。'
- en: The next step is to write the XRD configuration YAML.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写XRD配置YAML。
- en: Creating the XRD
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建XRD
- en: 'When defining the API specification with an XRD, the following configurations
    should be encoded into the YAML:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义XRD的API规范时，以下配置应编码到YAML中：
- en: Use `alpha-beta.imarunrk.com` as the API group to organize all APIs for alpha
    and beta teams.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`alpha-beta.imarunrk.com`作为API组，组织所有alpha和beta团队的API。
- en: We will provide the XR name as `XGCPdb` and the claim name as `GCPdb`.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将提供XR名称为`XGCPdb`，声明名称为`GCPdb`。
- en: We will start with a new API version, v1.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从新的API版本v1开始。
- en: Create `size` as an input parameter and `zone` as the response status attribute.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`size`作为输入参数，并将`zone`作为响应状态属性。
- en: 'As the example XRD is oversized, we will cover only the schema definition here.
    Refer to the entire XRD file at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml).
    Without wasting much time, let’s look at the schema:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于示例XRD过大，这里仅介绍模式定义。请参考完整的XRD文件：[https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter04/Hand-on-examples/Build-an-XR/xrd.yaml)。节省时间，我们来看看模式：
- en: '[PRE126]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Save the YAML from GitHub and apply it to the cluster with `kubectl apply -f
    xrd.yaml`. Refer to the following screenshot, which shows successful XRD creation:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub保存YAML并使用`kubectl apply -f xrd.yaml`应用到集群中。请参阅以下截图，显示了成功创建XRD：
- en: '![Figure 4.8 – XRD creation'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – XRD 创建'
- en: '](img/B17830_04_08.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_08.jpg)'
- en: Figure 4.8 – XRD creation
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – XRD 创建
- en: Note that the `ESTABLISHED` and `OFFERED` flags in the screenshot are `True`.
    This means that the XRD is created correctly. If these statuses are not `True`,
    use kubectl to describe the details of the XRD and look for an error.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意截图中的`ESTABLISHED`和`OFFERED`标志为`True`。这意味着XRD已正确创建。如果这些状态不是`True`，请使用kubectl描述XRD的详细信息并查找错误。
- en: Providing implementation
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供实施方案
- en: 'The next step is to provide an API implementation. As a part of the implementation,
    we should be providing a composition configuration. We will create two compositions,
    one for Postgres and the other for MySQL. It will be an example of the polymorphic
    behavior implementation. The following are the steps to remember when we build
    the composition YAML:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是提供API实现。作为实现的一部分，我们应该提供一个组合配置。我们将创建两个组合，一个用于Postgres，另一个用于MySQL。这将是多态行为实现的示例。以下是在构建组合YAML时需要记住的步骤：
- en: Refer to the v1 XRD API version with the `CompositeTypeRef` configuration.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CompositeTypeRef`配置引用v1 XRD API版本。
- en: Define the `CloudSQLInstance` configuration under the resource base.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源基础下定义`CloudSQLInstance`配置。
- en: Hardcode the region to `us-central1` to meet the compliance requirement.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬编码区域为`us-central1`以满足合规性要求。
- en: The database tier and disk size will hold default values, but the patch configuration
    will overlay them using the `FromCompositeFieldPath` patch type.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库层级和磁盘大小将保持默认值，但补丁配置将使用`FromCompositeFieldPath`补丁类型覆盖它们。
- en: Use the `Map` transformation to convert the `SMALL` tier size to the `db-g1-small`
    machine tier. Use the `Map` and `Convert` transformations to map the `SMALL` tier
    size to the 20 GB disk size.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Map`转换将`SMALL`层级大小转换为`db-g1-small`机器层级。使用`Map`和`Convert`转换将`SMALL`层级大小映射到20
    GB磁盘大小。
- en: Similar mapping will be done for the `BIG` configuration.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似的映射将应用于`BIG`配置。
- en: Patch the `GceZone` attribute from the MR status to the XR/claim for monitoring.
    We can achieve this using the `ToCompositeFieldPath` patch type.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 MR 状态将 `GceZone` 属性补丁到 XR/声明以进行监控。我们可以使用 `ToCompositeFieldPath` 补丁类型来实现这一点。
- en: Provide a mapping between the MR connection secret key to the XR/claim keys
    with the `ConnectionDetails` configuration.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供 MR 连接密钥与 XR/声明密钥之间的映射，使用 `ConnectionDetails` 配置。
- en: 'We will look at the Postgres composition example in four parts. The XRD and
    resource definition section of the composition will look like the following configuration:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分四个部分查看 Postgres 组成示例。组成的 XRD 和资源定义部分将类似于以下配置：
- en: '[PRE152]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Read through the comments between the code snippets to understand concepts
    in detail. The following configuration uses the map transform to patch the virtual
    machine tier:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读代码片段之间的注释，以详细理解概念。以下配置使用映射转换来补丁虚拟机层级：
- en: '[PRE177]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Next, we can look at the configuration to patch the disk size. The patch will
    have two transform operations. The first operation is to map the disk size, and
    the second one is to convert the mapped string to an integer:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以查看配置以补丁磁盘大小。补丁将包含两个转换操作。第一个操作是映射磁盘大小，第二个操作是将映射的字符串转换为整数：
- en: '[PRE191]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Finally, the following patch adds the resource zone into the API response:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下补丁将资源区域添加到 API 响应中：
- en: '[PRE208]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: The composition configuration for MySQL will be the same as the preceding configuration,
    excluding two changes. We should be changing the name of the composition in the
    metadata, and in the resource definition, we should change the database version
    to `MYSQL_5_7`. We can implement this with an additional parameter in the XR as
    well. Building two different compositions does not make sense when the difference
    is so small. We can capture the difference as a parameter in the XR. We are building
    two compositions, as an example. All composition examples and the upcoming claim
    examples are available for reference at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 的组成配置与前面的配置相同，除了两个变化。我们应该在元数据中更改组成的名称，在资源定义中，我们应将数据库版本更改为 `MYSQL_5_7`。我们也可以通过在
    XR 中添加一个额外的参数来实现这一点。当差异如此之小时，构建两个不同的组成并不合理。我们可以将差异作为 XR 中的一个参数来捕捉。我们正在构建两个组成作为示例。所有组成示例和接下来的声明示例可以参考
    [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter04/Hand-on-examples/Build-an-XR)。
- en: 'Refer to the following screenshot, which shows the successful creation of both
    compositions:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图，显示了成功创建两个组成：
- en: '![Figure 4.9 – Composition created'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 组成创建完成'
- en: '](img/B17830_04_09.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_09.jpg)'
- en: Figure 4.9 – Composition created
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 组成创建完成
- en: The final step is to use the claim API and create the database resources.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤是使用声明 API 创建数据库资源。
- en: Provisioning the resources with a claim
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用声明配置资源
- en: 'Finally, we can start provisioning the GCP database with an XR or a claim.
    The `CompositionRef` configuration will specify which composition implementation
    to use. Note that the claims are namespace resources, and we provision them in
    the `alpha` namespace here. The following is a sample claim YAML for the MySQL
    database:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始使用 XR 或声明来配置 GCP 数据库。`CompositionRef` 配置将指定使用哪个组成实现。请注意，声明是命名空间资源，我们在这里的
    `alpha` 命名空间中进行配置。以下是 MySQL 数据库的一个示例声明 YAML：
- en: '[PRE213]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'The Postgres YAML as well will look similar with minor changes. Refer to the
    following screenshot, which shows a successful database creation:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres YAML 也将类似，只是有一些小的变化。请参考以下截图，显示成功创建数据库：
- en: '![Figure 4.10 – Claim status'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 声明状态'
- en: '](img/B17830_04_10.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_10.jpg)'
- en: Figure 4.10 – Claim status
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 声明状态
- en: 'Note that the zone information is made available as the part of claim status:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，区域信息作为声明状态的一部分提供：
- en: '![Figure 4.11 – Zone information'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 区域信息'
- en: '](img/B17830_04_11.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_04_11.jpg)'
- en: Figure 4.11 – Zone information
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 区域信息
- en: This concludes the journey to build an XR. We will look at a few troubleshooting
    tips.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着构建 XR 的旅程结束。接下来，我们将查看一些故障排除技巧。
- en: Troubleshooting
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If we face issues with our infrastructure API, these tips could help us debug
    the problem in the best possible way:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到基础设施API的问题，以下提示可能帮助我们以最佳方式调试问题：
- en: Status attributes and events are essential elements to debug issues. These details
    can be viewed by running `kubectl describe` on the given resource.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态属性和事件是调试问题的重要元素。可以通过在给定资源上运行`kubectl describe`命令查看这些细节。
- en: When we start looking for issues, we take a top-down approach. This is because
    Crossplane follows the same convention as Kubernetes to hold the errors close
    to the resource where it happens.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们开始寻找问题时，我们采取自上而下的方法。这是因为Crossplane遵循与Kubernetes相同的约定，将错误紧密绑定到发生错误的资源上。
- en: The debugging order will be *claim*, then *XR*, and then *each composing resource*.
    We should start with a claimed object. If we cannot locate the issue, we go deep
    into the XR and then the composing resources.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试顺序将是*声明*，然后是*XR*，接着是*每个组成资源*。我们应从声明的对象开始。如果我们无法定位问题，就深入查看XR，然后是组成资源。
- en: '`spec.resourceRef` from the claim description can help us to identify the XR
    name. Again, the same attribute can be used to find the composing resources from
    the XR.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自声明描述的`spec.resourceRef`可以帮助我们识别XR名称。同样，使用该属性也可以从XR中找到组成资源。
- en: Make an intentional mistake in the resource configuration of the composition
    to go through the debugging experience. You learn more when you debug issues.
    This concludes our troubleshooting section. Next, we will look at the chapter
    summary before moving on to the next chapter.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在组成的资源配置中故意犯一个错误，以体验调试过程。调试问题时你会学到更多。这部分内容就是我们的故障排除部分。接下来，在进入下一章之前，我们将回顾本章的总结。
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this chapter, we covered one of the critical aspects of Crossplane, the
    XR. We started with understanding how an XR works and configuring an XR. Above
    all, we went through a hands-on journey to build a fresh infrastructure API from
    end to end. The chapter also covered some advanced XR configuration patterns and
    ways to approach debugging when there is an issue. This will be the base knowledge
    for what we will learn in the next chapter.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了Crossplane的一个关键方面——XR。我们从理解XR的工作原理和配置XR开始。最重要的是，我们通过动手实践，完整构建了一个全新的基础设施API。本章还介绍了一些高级XR配置模式以及在遇到问题时的调试方法。这将成为我们下一章学习的基础知识。
- en: The next chapter will cover different advanced infrastructure platform patterns.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖不同的高级基础设施平台模式。
