- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Worker Nodes on EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have focused on **Elastic Kubernetes Service** (**EKS**)
    architecture and APIs, deploying workloads with both kubectl and Helm. EKS can
    use both EC2 and Fargate to host these workloads. In this chapter, we will focus
    on how to configure, deploy, and manage the different **Elastic Compute Cloud**
    (**EC2**) configurations you will see in EKS. We will also discuss the benefits
    of using EKS-optimized images and managed node groups over self-managed images
    and instances. Fargate configuration will be discussed in more detail in [*Chapter
    15*](B18129_15.xhtml#_idTextAnchor220).
  prefs: []
  type: TYPE_NORMAL
- en: 'But for now, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Launching a node with Amazon Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching self-managed Amazon Linux nodes with CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching self-managed Bottlerocket nodes with eksctl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding managed nodes with eksctl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom **Amazon Machine Image** (**AMI**) for EKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reader should have a familiarity with YAML, basic networking, and EKS architecture.
    Before getting started with this chapter, please ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You have an EKS cluster and are able to perform administrative tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have network connectivity to your EKS API endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Amazon Web Services** (**AWS**) CLI and **kubectl** binary are installed
    on your workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching a node with Amazon Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss what is needed to launch a single EC2 instance
    and connect it to a cluster. We will then build on this as we discuss managed
    node groups.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for launching a node with Amazon Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A worker node is simply an EC2 instance that is used by EKS to actually host
    the Pods deployed on the cluster. Any EC2 instance will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An **Identity and Access Management** (**IAM**) role that allows it to talk
    to the AWS API (EKS, EC2, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A security group that, at a minimum, allows communication to the EKS control
    plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operating system image that has the Kubernetes agents (kubelet, and so on)
    installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `init`/`boot` script to register with a specific EKS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAM role and permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each worker node and EC2 instance requires an IAM role to be attached to it
    that allows communication with the AWS EKS API, **Elastic Container Registry**
    (**ECR**), and the EC2 API. There are three AWS managed policies that need to
    be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AmazonEKSWorkerNodePolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonEKS_CNI_Policy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmazonEC2ContainerRegistryReadOnly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, if you want to SSH into your worker nodes using Systems Manager,
    you should also add the following policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AmazonSSMManagedInstanceCore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The worker node role must be added to the `aws-auth` ConfigMap to allow the
    instances to register with the cluster. If you are creating self-managed nodes,
    you will need to modify the ConfigMap yourself; tools such as eksctl or the AWS
    Console will make these changes for you.
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every EC2 **elastic network interface** (**ENI**) needs to be associated with
    at least one security group. Worker nodes are normally given their own security
    group, which ensures network access to those nodes can be controlled.
  prefs: []
  type: TYPE_NORMAL
- en: Typically the EC2 worker node, a security group is referenced in the main EKS
    cluster security group that controls access to the control plane ENIs and allows
    the `create Pod`.
  prefs: []
  type: TYPE_NORMAL
- en: AWS AMIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An EC2 AMI is the base image any EC2 instance uses and contains the operating
    system (Windows- or Linux-based) and, typically, a set of utilities to enable
    the EC2 instance to work in AWS. EKS supports multiple AMIs, but in this section,
    we will discuss two: **Amazon Linux** and **Bottlerocket**.'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon EKS-optimized Amazon Linux AMIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Amazon EKS-optimized Amazon Linux AMI is built on top of Amazon Linux 2
    and is configured to work with Amazon EKS including Docker (this is replaced with
    containerd in later versions of the AMI), kubelet, and the AWS IAM authenticator.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to align the AMI with the version of Kubernetes; the following URL
    can be used to find the right image ID: https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
    For example, for x86, Kubernetes 1.21 in the `eu-central-1` region, the AMI ID
    is `ami-03fa8a7508f8f3ccc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon EKS-optimized Bottlerocket AMIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bottlerocket is an open source Linux-based operating system that is purpose-built
    by AWS for running containers. As with a container, it only includes the bare-minimum
    packages required to run containers, reducing the attack surface of the node itself.
    EKS-optimized Bottlerocket is configured to work with Amazon EKS, and it includes
    containerd and `eu-central-1` region, the AMI ID is `ami-0674d57b3d6b6ef14`.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A bootstrap script is needed to configure the various agents and EC2 metadata
    and needs to be run once. The bootstrap script is published by AWS and can be
    found at the following link: [https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh](https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh).
    It needs to be integrated into the EC2 boot process or run manually.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together and creating a standalone worker node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to just create a single EC2 worker node, but in practice, you
    will always want to use EC2 Auto Scaling to recover from failure and scale your
    worker nodes. The following steps are used only to illustrate the activities you
    need to go through to get a worker node up and running and should only be used
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have a running cluster with some worker nodes already (if not, see
    [*Chapter 3*](B18129_03.xhtml#_idTextAnchor047)), note down the security group,
    IAM role, VPC, and subnet used by the existing node group/EC2 instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command, replacing the attributes with the values you collected
    in *step 1*, to create the EC2 worker node. Please note that the `image-id` value
    is region- and Kubernetes version-specific, so you may need to modify it as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the instance has booted and is available, you can SSH to it using AWS
    Session Manager or using the SSH key you specified in *step 2*. You should then
    verify whether you have permission to get the cluster description using the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It may be easier to run the `aws configure` command and specify the default
    region (only) so that changes are preserved across different shells or logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'As root, you can now download and run the bootstrap script to configure the
    worker node using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exit the SSH session, go back onto the Kubernetes admin machine, and run the
    `kubectl get nodes --watch` command. What you should see are the original worker
    nodes and *NOT* the new worker node you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Kubernetes admin machine, verify that the role assigned to the newly
    created worker node is configured in the `aws-auth` ConfigMap using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to allow a specific EKS cluster to claim a worker node and monitor
    things such as auto scaling events, you need to add a `kubernetes.io/cluster/<clustername>`
    instance tag to the EC2 instance. In the AWS Console, navigate to your instance
    by going to `kubernetes.io/cluster/…` tag with a value of `owned` to the instance,
    click `--watch` command should now show the new worker node registering and becoming
    ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please refer to [https://docs.aws.amazon.com/eks/latest/userguide/worker.html](https://docs.aws.amazon.com/eks/latest/userguide/worker.html)
    for more details on self-managed worker nodes and how to configure them. You will
    normally use an auto scaling group to support your worker nodes, so the next example
    will use a pre-created CloudFormation template to configure this using the Amazon
    Linux AMI we used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Launching self-managed Amazon Linux nodes with CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS provides a CloudFormation script hosted at [https://s3.us-west-2.amazonaws.com/amazon-eks/cloudformation/2020-10-29/amazon-eks-nodegroup.yaml](https://s3.us-west-2.amazonaws.com/amazon-eks/cloudformation/2020-10-29/amazon-eks-nodegroup.yaml)
    that can also be used to create a self-managed node group. Let’s take a look at
    how that works!
  prefs: []
  type: TYPE_NORMAL
- en: 'From the AWS Console, select the **CloudFormation** service and click on the
    **Create stack** button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Launching a CloudFormation stack](img/B18129_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Launching a CloudFormation stack
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `nodegroup.yaml` file in the **Amazon S3 URL** box and click **Next**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.2 – \uFEFFThe Create stack window](img/B18129_08_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The Create stack window
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now be asked to configure the stack properties; most of these are
    the same as in the previous example. A subset of the parameters typically used
    is shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Parameter name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ClusterName` | The name of the existing cluster. If it is incorrect, nodes
    will not be able to join the cluster. |'
  prefs: []
  type: TYPE_TB
- en: '| `ClusterControlPlaneSecurityGroup` | The security group used by the cluster
    control plane. |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeGroupName` | A unique name for the node group. |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeAutoScalingGroupMinSize` | The minimum number of nodes in the auto scaling
    group. |'
  prefs: []
  type: TYPE_TB
- en: '| `Desired capacity of Node` `Group ASG`. | The desired number of nodes in
    the auto scaling group. |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeAutoScalingGroupMaxSize` | The maximum number of nodes in the auto scaling
    group. Set to at least 1 greater than desired capacity. |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeInstanceType` | The EC2 instance type for the worker nodes. |'
  prefs: []
  type: TYPE_TB
- en: '| `NodeVolumeSize` | The worker node **Elastic Block Store** (**EBS**) volume
    size. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyName` | The EC2 key pair to allow SSH access to the instances. |'
  prefs: []
  type: TYPE_TB
- en: '| `DisableIMDSv1` | Set to `true` or `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `VpcId` | The VPC of the worker instances. |'
  prefs: []
  type: TYPE_TB
- en: '| `Subnets` | The subnets where workers can be created. |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – CloudFormation parameter list
  prefs: []
  type: TYPE_NORMAL
- en: As this template uses an auto scaling group, you need to specify the minimum,
    maximum, and desired capacity of the auto scaling group (refer to [https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-capacity-limits.html](https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-capacity-limits.html)
    for more details). Please also note that the security group is the one defined
    for the cluster API, as the template creates a new security group for the instances
    in the auto scaling group.
  prefs: []
  type: TYPE_NORMAL
- en: 4. Enter the parameters (use the ones from the previous example) and click through
    the stack workflow until the stack starts to be deployed. Once the stack has been
    deployed, you can use the `kubectl get nodes` command to verify whether the node/s
    have been registered. Again, the node/s should *NOT* be visible, but this time
    it’s a different problem.
  prefs: []
  type: TYPE_NORMAL
- en: '5. This template creates a new IAM role that needs to be added to the `aws-auth`
    file. You can use the `kubectl edit cm aws-auth -n kube-system` command from the
    Kubernetes admin workstation to edit the ConfigMap and add the following entry
    to the `mapRoles` key, where `<rolearn>` is the role assigned to the EC2 instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '6. Once you have added the role and deployed the ConfigMap, you can use the
    following command to see the node register and become ready for the scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Amazon Linux is based on a standard Linux kernel, while Bottlerocket has been
    built from the ground up to support containers. In the next section, we will look
    at how you can deploy self-managed nodes based on the Bottlerocket operating system,
    which provides better support for containers.
  prefs: []
  type: TYPE_NORMAL
- en: Launching self-managed Bottlerocket nodes with eksctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bottlerocket is gaining momentum as a secure platform for running container
    workloads. One of the key benefits is that it runs two operating system partitions,
    which means that it is simpler to upgrade with minimal downtime. This is discussed
    in more detail in [*Chapter 10*](B18129_10.xhtml#_idTextAnchor146), *Upgrading*
    *EKS Clusters*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have created a managed node using the AWS CLI, the console, and
    a pre-made CloudFormation template. **eksctl** is a tool jointly developed by
    *Weaveworks* and AWS and will generate and deploy CloudFormation stacks based
    on a configuration file or CLI options. You can install it using the following
    URL: [https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html](https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to version 0.40.0 of eksctl, you could only modify clusters that had been
    created using eksctl. However, later versions allow a subset of operations on
    clusters not created by eksctl—this includes adding node groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use an existing cluster (see [*Chapter 3*](B18129_03.xhtml#_idTextAnchor047),
    *Building Your First EKS Cluster*) and add two self-managed Bottlerocket nodes.
    The following configuration file is used; please note it is split into multiple
    sections to make it more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding section, we define the cluster `name`, `region`, and `version`
    values, along with the VPC details as we will reuse an existing VPC. In the following
    section, we define a node group. Make sure the `privateNetworking` key is set
    to `true` if you are using a set of private subnets (without an **internet gateway**
    (I**GW)**); otherwise, the deployment will fail!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is using an existing cluster, the `vpc:` section must be included.
    The `securityGroup` key refers to the cluster security group, not the worker node
    one. As this is also a private cluster, the `privateNetworking: true` key-value
    pair needs to be included. The `nodegroups` keyword is used for self-managed nodes.
    Please adjust the configuration file (keys in `code style`) and save it as `bottlerocket.yaml`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once eksctl has been installed and the configuration file saved, you can run
    the following command to create a cluster using the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the following command to see the nodes be registered and become ready
    for the scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Please note that eksctl will tag nodes and modify the `aws-auth` ConfigMap,
    so as long as the `eksctl` command is successful, the nodes will automatically
    register and become available.
  prefs: []
  type: TYPE_NORMAL
- en: Self-managed node groups are useful if you have a lot of custom operating system
    configurations or you need a specific AMI. If you need to do any node updates,
    you will be responsible for draining nodes, moving Pods, adjusting scheduler logic,
    and replacing nodes. Managed node groups allow you to do this at the click of
    a button (or with an API call) and so generally should be preferred over self-managed
    nodes. In the next section, we will see how you can use managed node groups instead.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding managed nodes with eksctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A managed node group leverages auto scaling groups to provide the basic functionality
    used to do upgrades and modifications to worker nodes. Each auto scaling group
    specifies a launch template, which specifies the configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you replace the launch configuration—changing the EKS AMI ID, for example—any
    new instances that are created use the new launch template and, therefore, the
    new AMI. You can then terminate old instances, and the auto scaling group will
    automatically replace them using the new launch template. This process is automated
    for managed node groups, and the EKS control plane performs the following steps
    for a managed node group:'
  prefs: []
  type: TYPE_NORMAL
- en: It randomly selects a node and drains the Pods from the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It ordons the node after every Pod is evicted so that the Kubernetes scheduler
    doesn’t send any new requests to this node and removes this node from its list
    of active nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sends a termination request to the Auto Scaling group for the cordoned node.
    This in turn will trigger a new node deployment with the new launch template/AMI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It repeats *steps 1-3* until there are no nodes in the node group that are deployed
    with the earlier version of the launch template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s deploy a new managed node group using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the following command to see the nodes be registered and become ready
    for the scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following configuration file should be used; again, this is split into
    multiple sections for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous template, but make sure you change the `nodeGroups:`
    key to `managedNodeGroups:`. You also need to remove the Bottlerocket-specific
    `amiFamily:` and `ami:` keys and (optionally) add the `labels:` key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding section is no different from the unmanaged node group; we define
    the cluster and VPC information (using an existing VPC). In the following section,
    we replace the `nodeGroups` key with the `managedNodeGroups` key and also add
    a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the nodes have been registered, if you go into the AWS Console and select
    **EKS** | **Clusters** | **mycluster** and the **Compute** tab, you will see the
    managed node group registered and showing an **Active** status. In the following
    screenshot, you can see the new node group along with the old node group, which
    is at an older AMI version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Node groups window](img/B18129_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Node groups window
  prefs: []
  type: TYPE_NORMAL
- en: This can now be automatically upgraded (with kubelet, containerd, and so on)
    by clicking the **Update now** link. This process is discussed in more detail
    in [*Chapter 10*](B18129_10.xhtml#_idTextAnchor146), *Upgrading* *EKS Clusters*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used standard AMIs without any customization. In the final section
    of this chapter, we will look at how you can build a custom AMI for use with EKS,
    which might be needed if you want to harden the operating system or make some
    kernel changes.
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom AMI for EKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of reasons why you may want to use a custom AMI—for example,
    security hardening, updates to Kubernetes agent binaries, and so on. There are
    also many ways you can do this, but we are going to look at using Packer from
    HashiCorp (https://learn.hashicorp.com/packer), which is an open source tool that
    can be used to create a number of different types of operating system images.
    Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we need to install Packer on our workstation using the following
    link: [https://learn.hashicorp.com/collections/packer/aws-get-started](https://learn.hashicorp.com/collections/packer/aws-get-started).
    This will then allow us to create a custom AMI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can then clone the following Git repository and change into the new `amazon-eks-ami`
    directory: [https://github.com/awslabs/amazon-eks-ami](https://github.com/awslabs/amazon-eks-ami).
    This is the same process used to create official AMIs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the root of the cloned repository, you can now run the `make` command
    shown next to create a basic `1.21` AMI (ensure the region you are using has a
    default VPC configured):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will take 15-20 minutes to spin up a new EC2 instance. Connect to from the
    Packer machine using SSH and then configure the instance using the scripts in
    the `/scripts` directory. Once configured, the EBS volume is converted into an
    AMI and the instance is terminated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can validate that the image exists using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to customize the build, you can make changes to the makefile, the
    Packer build file (`eks-worker-al2.json`), and/or add/modify the scripts in the
    `/scripts` directory. This requires detailed knowledge of Packer and Linux and
    so is out of the scope of this book, but there is a useful post on the following
    link that describes some of this customization in more detail (you will need an
    AWS login to access this): https://aws.amazon.com/premiumsupport/knowledge-center/eks-custom-linux-ami/.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at the variety of ways you can configure and deploy
    EC2 worker nodes, we’ll revisit the key learning points from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basic requirements for any EC2-based worker
    node, including the need to configure an IAM role, the Kubernetes agents (kubelet,
    and so on), and security groups to allow communication with the EKS control plane
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how you can use Amazon Linux and Bottlerocket (a secure container
    operating system developed by AWS) AMIs to create self-managed node groups using
    the AWS Console/CLI, CloudFormation, and eksctl. It’s important to understand
    there are several options when it comes to choosing operating systems, from Amazon
    EKS-optimized Linux and Bottlerocket through to the completely customized operating
    systems you define. Amazon Linux is the easiest operating system choice as images
    are created and managed by AWS, and it will also allow access to the standard
    Linux kernel if you want to make changes. Bottlerocket is more secure but is quite
    a different architecture from standard Linux kernels, so requires a lot more investment
    in training and design. If you have some very specific hardening requirements
    or particular management tools you use, then you will need to use custom AMIs.
    We then talked about how managed node groups simplify the operation burden of
    updating worker node operating systems and Kubernetes agents and showed how, with
    some simple changes, we can use eksctl to deploy them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we briefly explored how you can use HashiCorp’s Packer and an AWS repository
    to create custom AMIs that could support a more customized EC2-based worker node.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the overall process of upgrading your cluster
    and build on some of the concepts discussed in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deeper dive into Amazon Linux EKS-optimized AMIs: https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deeper dive into Bottlerocket EKS-optimized AMIs: https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami-bottlerocket.html'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'eksctl user guide: https://eksctl.io/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deeper dive into EC2 auto scaling: https://docs.aws.amazon.com/autoscaling/ec2/userguide/what-is-amazon-[ec2-auto-scaling.html](https://ec2-auto-scaling.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
