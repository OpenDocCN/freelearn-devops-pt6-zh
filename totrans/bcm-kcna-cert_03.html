<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-39" class="chapter-number"><a id="_idTextAnchor038"/>3</h1>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Getting Started with Containers</h1>
			<p>In this chapter, we’ll take a closer look at containers, dive deeper into container technology and the container ecosystem, and discover tooling that is <span class="No-Break">commonly used.</span></p>
			<p>An old Chinese proverb states, “<em class="italic">What I hear, I forget. What I see, I remember. What I do, </em><span class="No-Break"><em class="italic">I understand</em></span><span class="No-Break">.”</span></p>
			<p>Starting with this chapter, we will get our hands dirty and try building images and running containers to get a deeper understanding and first-hand practical experience. Even though KCNA is a multi-choice exam, it is very important to do things first-hand as this experience will help you in the future. <strong class="bold">Don’t just read the code snippets – make sure you execute them completely, especially if you have no previous experience with containers.</strong> You’ll need any computer running a recent version of Linux, Windows, or macOS and a working <span class="No-Break">internet connection.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Introducing Docker</span></li>
				<li>Exploring <span class="No-Break">container technology</span></li>
				<li>Installing Docker and <span class="No-Break">running containers</span></li>
				<li>Building <span class="No-Break">container images</span></li>
			</ul>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Technical requirements</h1>
			<p>All the example files and code snippets used in this chapter have been uploaded to this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Becoming-KCNA-Certified"><span class="No-Break">https://github.com/PacktPublishing/Becoming-KCNA-Certified</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Introducing Docker</h1>
			<p>Docker <a id="_idIndexMarker115"/>has been around for quite a few years, so you may have heard about it before. For many people, the name <em class="italic">Docker</em> itself is synonymous with <em class="italic">container</em>. However, there are so many things called <em class="italic">Docker</em> that it is easy to <span class="No-Break">get confused:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Docker Inc.</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Docker Engine</strong></span></li>
				<li><strong class="bold">dockerd</strong> (<span class="No-Break"><strong class="bold">Docker daemon</strong></span><span class="No-Break">)</span></li>
				<li><span class="No-Break"><strong class="bold">Docker CLI</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Docker Hub</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Docker Registry</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Docker Swarm</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Docker Compose</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Docker Desktop</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Dockershim</strong></span></li>
			</ul>
			<p>Let’s clarify <span class="No-Break">each one.</span></p>
			<p>For starters, <em class="italic">Docker Inc.</em> (as a company) did not invent the technology behind containers, but it created easy-to-use tools from the list that helped kickstart broader container adoption. The company was founded in 2008 and was initially <span class="No-Break">called dotCloud.</span></p>
			<p><em class="italic">Docker Engine</em> is an <a id="_idIndexMarker116"/>open source software bundle for building and containerizing applications. It is a piece of client-server software that consists of a daemon service known as <strong class="bold">dockerd</strong> (<strong class="bold">Docker daemon</strong>) that <a id="_idIndexMarker117"/>provides a REST API (for other programs to talk to it) and <a id="_idIndexMarker118"/>a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) that is simply <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Containerization</p>
			<p class="callout">Containerization is the process of packaging software application code with dependencies (libraries, frameworks, and more) in a container. Containers can be moved between environments independently of the infrastructure’s <span class="No-Break">operating system.</span></p>
			<p>When you install a Docker engine, you essentially install two things – the <strong class="source-inline">dockerd</strong> service and the CLI. <strong class="source-inline">dockerd</strong> constantly runs and listens for commands to do any operations with containers such as starting new, stopping existing, restarting containers, and so on. Those commands might be issued using the <strong class="source-inline">docker</strong> CLI, or a common tool such as <strong class="source-inline">curl</strong>. We will be using the <strong class="source-inline">docker</strong> CLI in this <span class="No-Break">chapter’s examples.</span></p>
			<p>Next on our <a id="_idIndexMarker119"/>list is <em class="italic">Docker Hub</em> (<a href="https://hub.docker.com/">https://hub.docker.com/</a>), a public container image registry. As <a id="_idIndexMarker120"/>you may recall, a container image is a predefined static template that we use as a base for starting new containers. Now, where do we get the images from? Docker Hub can be one such place. It is an online repository service offered by Docker Inc. where thousands of container images with different environments (<strong class="bold">Ubuntu</strong>, <strong class="bold">Centos</strong>, <strong class="bold">Fedora</strong>, and <strong class="bold">Alpine Linux</strong>) as well as popular software such as <strong class="bold">Nginx</strong>, <strong class="bold">Postgres</strong>, <strong class="bold">MySQL</strong>, <strong class="bold">Redis</strong>, and <strong class="bold">Elasticsearch</strong> are hosted. Docker Hub allows you to find, share, and store container images that can be easily pulled (downloaded) over the internet to the host where you need to create a new container. It’s worth mentioning <a id="_idIndexMarker121"/>that <a id="_idIndexMarker122"/>Docker Hub is not the only such service – others<a id="_idIndexMarker123"/> include <strong class="bold">Quay</strong> (<a href="https://quay.io/">https://quay.io/</a>), <strong class="bold">Google Container Registry</strong> (<a href="https://cloud.google.com/container-registry">https://cloud.google.com/container-registry</a>), and <strong class="bold">Amazon Elastic Container </strong><span class="No-Break"><strong class="bold">Registry</strong></span><span class="No-Break"> (</span><a href="https://aws.amazon.com/ecr/"><span class="No-Break">https://aws.amazon.com/ecr/</span></a><span class="No-Break">).</span></p>
			<p>Let’s move on to <em class="italic">Docker Registry </em>which is today managed at CNCF as a project named<em class="italic"> Distribution</em>. It is<a id="_idIndexMarker124"/> an open source server-side application that can be used for storing and distributing Docker images. The main difference compared to Docker Hub is that Docker Registry is a piece of software that you can just take, install, and run within your organization at no cost, whereas Docker Hub is a <em class="italic">registry as a service</em> with some additional paid features. Docker Registry can be used to store and serve container images with software that your <em class="italic">dev</em> teams <span class="No-Break">are developing.</span></p>
			<p><em class="italic">Docker Swarm</em> is <a id="_idIndexMarker125"/>next on our list and its purpose is cluster management and container orchestration. Swarm is similar to Kubernetes; however, it is only compatible with Docker Engine (meaning no other container runtimes are supported) and has significantly fewer features and limited customizations compared to Kubernetes. That is the reason it did not receive such wide adoption as <span class="No-Break">Kubernetes did.</span></p>
			<p><em class="italic">Docker Compose</em> is <a id="_idIndexMarker126"/>another Docker tool that allows you to define and share multi-container applications specifications. With Compose, you can define multiple containers that need to communicate with each other as a part of one application in a <a id="_idIndexMarker127"/>single <strong class="bold">YAML</strong> formatted file. For example, you can bootstrap a <em class="italic">Django</em> web application with a database running in two containers and define that the database has to start first, as well as expose certain ports of containers. Compose might be handy for some local development with Docker, but it is not compatible with Kubernetes, so we are not going to cover it in any <span class="No-Break">more detail.</span></p>
			<p><em class="italic">Docker Desktop</em> is a <a id="_idIndexMarker128"/>combination of Docker Engine, the <strong class="source-inline">docker</strong> CLI, Docker Compose, Kubernetes, and some other tools for Windows/macOS that comes with its <a id="_idIndexMarker129"/>own <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>). That’s right – Docker Desktop even packages Kubernetes and K8s clients for local development. Docker Desktop is free for non-commercial use but paid if used in organizations. There is also a beta version available for Ubuntu and <span class="No-Break">Debian Linux.</span></p>
			<p><em class="italic">Dockershim</em> is a <a id="_idIndexMarker130"/>software compatibility layer that was created to allow Kubernetes (its <em class="italic">kubelet</em> component, to be precise) to communicate with <strong class="source-inline">dockerd</strong> (Docker daemon). As you might remember from the previous chapters, Kubernetes does not have its own container runtime (software for performing basic operations with containers such as starting, stopping, and deleting). In the early versions, Kubernetes only supported Docker to operate containers. As the container ecosystem evolved <a id="_idIndexMarker131"/>with <strong class="bold">Open Container Initiative</strong> (<strong class="bold">OCI</strong>), support for new runtimes was added through structured and standardized interfaces. Since <strong class="source-inline">dockerd</strong> did not have an OCI standardized interface, a translation layer between Kubernetes and <strong class="source-inline">dockerd</strong> called <strong class="bold">Dockershim</strong> was created. <em class="italic">Dockershim</em> has been deprecated since Kubernetes version 1.20 and with the 1.24 release, it has been completely removed <span class="No-Break">from K8s.</span></p>
			<p>Finally, we’ve reached the end of our list. Despite the number of alternatives that have appeared over the years, Docker Engine and the Docker tooling are still actively used by thousands of development teams and organizations across the globe. The following diagram demonstrates how, using the Docker CLI, we can communicate with the Docker daemon, which fetches the images from Docker Registry to create <span class="No-Break">containers locally:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18970_03_01.jpg" alt="Figure 3.1 – Docker architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Docker architecture</p>
			<p>In the upcoming sections, we will <a id="_idIndexMarker132"/>install some of the Docker tools to see it in action and finally get our hands <span class="No-Break">on containers.</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Exploring container technology</h1>
			<p>Before <a id="_idIndexMarker133"/>we move on to the practical part, we still need to figure out the technology behind containers and who created it. The technology behind Linux containers was developed quite a long time ago and is based on two fundamental <span class="No-Break">kernel features:</span></p>
			<ul>
				<li><strong class="bold">cgroups</strong> (<span class="No-Break"><strong class="bold">control groups</strong></span><span class="No-Break">)</span></li>
				<li><span class="No-Break"><strong class="bold">Namespaces</strong></span></li>
			</ul>
			<p class="callout-heading">cgroups</p>
			<p class="callout">cgroups<a id="_idIndexMarker134"/> is a mechanism that allows processes to be organized into hierarchical groups. How resources (CPU, memory, disk I/O throughput, and so on) are used by those groups can be limited, monitored, <span class="No-Break">and controlled.</span></p>
			<p><em class="italic">cgroups</em> were<a id="_idIndexMarker135"/> initially developed by engineers at Google and first released in 2007. Since early 2008, cgroups functionality was merged into the Linux kernel and has been present ever since. In 2016, a revised version of cgroups was released and it is now known as cgroups <span class="No-Break">version 2.</span></p>
			<p>Even<a id="_idIndexMarker136"/> before cgroups, in 2002, the Linux namespaces feature <span class="No-Break">was developed.</span></p>
			<p class="callout-heading">Linux kernel namespaces</p>
			<p class="callout">This <a id="_idIndexMarker137"/>Linux feature allows you to partition kernel resources in such a way that one set of processes sees one set of resources while another set of processes sees a different set of resources. Linux namespaces are used to isolate processes from <span class="No-Break">each other.</span></p>
			<p>There are different types of namespaces, each with its <span class="No-Break">own properties:</span></p>
			<ul>
				<li><strong class="bold">User namespace</strong>: This <a id="_idIndexMarker138"/>allows a process to have its own user and group IDs. This makes it possible for a process to run as <strong class="source-inline">root</strong> (superuser) but be limited to its <span class="No-Break">own namespace.</span></li>
				<li><strong class="bold">Process ID (PID) namespace</strong>: This <a id="_idIndexMarker139"/>allows you to have a set of process IDs in one namespace that are independent of other namespaces. For example, multiple processes on the same host can have PID <strong class="source-inline">1</strong> thanks <span class="No-Break">to namespaces.</span></li>
				<li><strong class="bold">Network namespace</strong>: This<a id="_idIndexMarker140"/> allows you to run an independent network stack with its own routing table, IP addresses, connection tracking, and more for a set of processes. </li>
				<li><strong class="bold">Mount namespace</strong>: This <a id="_idIndexMarker141"/>allows you to have independent mount points within a namespace. This means a process in a namespace can have different mounts without it affecting the <span class="No-Break">host filesystem.</span></li>
				<li><strong class="bold">Interprocess communication (IPC)</strong>: This <a id="_idIndexMarker142"/>allows you to isolate Linux interprocess communication mechanisms such as shared memory, semaphores, and <span class="No-Break">message queues.</span></li>
				<li><strong class="bold">UNIX Time-Sharing (UTS)</strong>: This<a id="_idIndexMarker143"/> allows you to have different hostnames and domain names for <span class="No-Break">different processes.</span></li>
			</ul>
			<p>This may sound complicated, but don’t worry – namespaces and cgroups are not part of the KCNA exam, so you don’t need to know about every namespace and what they do. However, since those are at the core of container technology, it is helpful to have an idea, plus you are always given bonus points if you can explain how containers work under <span class="No-Break">the hood.</span></p>
			<p>To summarize, <em class="italic">cgroups</em> and <em class="italic">namespaces</em> are the building blocks of containers. cgroups allow you to monitor and control computational resources for a process (or a set of processes), whereas namespaces isolate the processes at different system levels. Both functionalities can also be used without containers, and there’s plenty of software that makes use of <span class="No-Break">this functionality.</span></p>
			<p>Enough theory – let’s get some practice! In the next section, we will install Docker tooling and start our <span class="No-Break">first container.</span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Installing Docker and running containers</h1>
			<p>If you are<a id="_idIndexMarker144"/> running Windows or macOS, you can download and install Docker Desktop from https://docs.docker.com/desktop/. If you are running a recent version of Ubuntu Linux, there is a version of Docker Desktop for you too. If you are running another Linux distribution, you’ll have to install Docker Engine. You can find detailed instructions for your distribution at https://docs.docker.com/engine/install/. Please pick a <em class="italic">stable</em> release <span class="No-Break">for installation.</span></p>
			<p>If you restart your computer, make sure that Docker Desktop is running. On Linux, you might have to execute the following code in <span class="No-Break">your Terminal:</span></p>
			<pre class="source-code">
$ sudo systemctl start docker</pre>
			<p>If you want it to start automatically in case of a system restart, you can run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ sudo systemctl enable docker</pre>
			<p>Regardless of the OS or tooling that you’ve installed (Desktop or Engine), it will come with the Docker CLI that we will be using, which is simply <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break">.</span></p>
			<p>First, let’s make sure<a id="_idIndexMarker145"/> that Docker was installed correctly and running by checking the version. Open the terminal and type <span class="No-Break">the following:</span></p>
			<pre class="source-code">
$ docker --version
Docker version 20.10.10, build b485636</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are on Linux and you have not added your user to the docker group after the installation, you’ll have to call the Docker CLI with superuser privileges, so all docker commands should be prefixed with <strong class="source-inline">sudo</strong>. For the preceding example, the command will be <strong class="source-inline">sudo </strong><span class="No-Break"><strong class="source-inline">docker --version</strong></span><span class="No-Break">.</span></p>
			<p>Your output<a id="_idIndexMarker146"/> might look slightly different – perhaps you’ll have a newer version installed. If the preceding command did not work, but Docker is installed, make sure that Docker Desktop (if you’re on macOS or Windows) or the Docker daemon (if you’re on Linux) <span class="No-Break">is running.</span></p>
			<p>Now, let’s start our first container with <span class="No-Break">Ubuntu 22.04:</span></p>
			<pre class="source-code">
$ docker run -it ubuntu:22.04 bash</pre>
			<p>The output that you’ll see should be similar to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Unable to find image ‘ubuntu:22.04’ locally
22.04: Pulling from library/ubuntu
125a6e411906: Pull complete
Digest: sha256:26c68657ccce2cb0a31b330cb0be2b5e108d467f641c62e13ab40cbe c258c68d
Status: Downloaded newer image for ubuntu:22.04
root@d752b475a54e:/#</pre>
			<p>Wow! We are now running <strong class="source-inline">bash</strong> inside an Ubuntu container. It might take a few seconds for the image to be downloaded, but as soon as it is ready, you’ll see the command-line prompt running as a <strong class="source-inline">root</strong> user inside a newly <span class="No-Break">spawned container.</span></p>
			<p>So, what exactly happened when we called <span class="No-Break"><strong class="source-inline">docker run</strong></span><span class="No-Break">?</span></p>
			<p><strong class="source-inline">docker run</strong> executes a command inside a new container; it requires the name of the container image where the command will be executed (<strong class="source-inline">ubuntu</strong> in the preceding example), optionally the tag of the image (<strong class="source-inline">22.04</strong> here), and the command to be executed (simply <span class="No-Break"><strong class="source-inline">bash</strong></span><span class="No-Break"> here).</span></p>
			<p>The <strong class="source-inline">-i</strong> argument<a id="_idIndexMarker147"/> is the same as <strong class="source-inline">--interactive</strong>, and it means we’d like to be running our command in interactive mode. <strong class="source-inline">-t</strong>, which is the same as <strong class="source-inline">--tty</strong>, will allocate a pseudo-TTY (<span class="No-Break">emulated terminal).</span></p>
			<p>As you may remember, images are templates for container environments. We have asked for an <strong class="source-inline">ubuntu</strong> environment tagged with version <strong class="source-inline">22.04</strong>. In the first few lines of output, we saw that the image was not <span class="No-Break">found locally:</span></p>
			<pre class="source-code">
Unable to find image ‘ubuntu:22.04’ locally
22.04: Pulling from library/ubuntu
125a6e411906: Pull complete</pre>
			<p>If the requested image with a particular tag was not downloaded previously, it will be automatically downloaded (pulled) from the Docker Hub library and you should be able to see the download progress while it <span class="No-Break">is happening.</span></p>
			<p>Now, let’s exit the container and try running it again. Simply type <strong class="source-inline">exit</strong> in <span class="No-Break">the terminal:</span></p>
			<pre class="source-code">
root@d752b475a54e:/# exit
exit</pre>
			<p>Now, execute the same command we <span class="No-Break">did previously:</span></p>
			<pre class="source-code">
$ docker run -it ubuntu:22.04 bash
root@e5d98a473adf:/#</pre>
			<p>Was it faster this time? Yes, because we already have the <strong class="source-inline">ubuntu:22.04</strong> image cached locally, so we don’t need to download it again. Therefore, the container was <span class="No-Break">started immediately.</span></p>
			<p>Did you notice that the hostname after <strong class="source-inline">root@</strong> is different this time – <strong class="source-inline">e5d98a473adf</strong> versus <strong class="source-inline">d752b475a54e</strong>? <em class="italic">(Note: you will see your unique container names here.)</em> This is because we have started a new container that is based on the same <strong class="source-inline">ubuntu</strong> image. When we start a new container, we don’t modify the read-only source image; instead, we create a new writable filesystem layer on top of the image. The following diagram shows such a <span class="No-Break">layered approach:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B18970_03_02.jpg" alt="Figure 3.2 – Container layers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Container layers</p>
			<p>When we <a id="_idIndexMarker148"/>start a container, we add a new layer, which allows modifications to be made to the container image copy. This way, we can create any number of containers from the same base image without modifying the initial read-only image layer. The major benefit of this approach is that <strong class="bold">in container layers, we only store the difference with the image layer</strong>, which means significant disk space savings when used <span class="No-Break">at scale.</span></p>
			<p>The images can also consist of multiple layers, where one layer might be originating from another one. In the following section, we will learn how to build new images and include the software that we <span class="No-Break">like inside.</span></p>
			<p>Feel free to<a id="_idIndexMarker149"/> explore our container environment and <strong class="source-inline">exit</strong> it when <span class="No-Break">you’re done:</span></p>
			<pre class="source-code">
$ docker run -it ubuntu:22.04 bash
root@e5d98a473adf:/# echo “Hello World” &gt; /root/test
root@e5d98a473adf:/# hostname
e5d98a473adf
root@e5d98a473adf:/# date
Sun May 1 13:40:01 UTC 2022
root@e5d98a473adf:/# exit
exit</pre>
			<p>When <a id="_idIndexMarker150"/>we called <strong class="source-inline">exit</strong> in the first container, it exited; later, when we called <strong class="source-inline">docker run</strong> again, a new container was created. Now that both containers have exited, we have an image layer stored on the disk, as well as two different container layers based on the <span class="No-Break"><strong class="source-inline">ubuntu:22.04</strong></span><span class="No-Break"> base.</span></p>
			<p>Since the container layers only keep track of differences from the base image, we won’t be able to remove the base image until all the container layers have been deleted. Let’s get the list of images we have locally by running the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
$ docker images
REPOSITORY    TAG       IMAGE ID       CREATED      SIZE
ubuntu       22.04    d2e4e1f51132   39 hours ago  77.8MB</pre>
			<p>If we attempt to delete the <strong class="source-inline">ubuntu:22.04</strong> image with the <strong class="source-inline">docker rmi</strong> command, we’ll get <span class="No-Break">an error:</span></p>
			<pre class="source-code">
$ docker rmi ubuntu:22.04
Error response from daemon: conflict: unable to remove repository reference “ubuntu:22.04” (must force) – container e5d98a473adf is using its referenced image d2e4e1f51132</pre>
			<p>We can also execute the <strong class="source-inline">docker ps</strong> command to see all <span class="No-Break"><em class="italic">running</em></span><span class="No-Break"> containers:</span></p>
			<pre class="source-code">
$ docker ps
CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES</pre>
			<p>An empty table means no containers are <span class="No-Break">currently running.</span></p>
			<p>Finally, we can execute <strong class="source-inline">docker ps --all</strong> to see all the containers on the local system, including those that <span class="No-Break">have exited:</span></p>
			<pre class="source-code">
$ docker ps --all
CONTAINER ID    IMAGE    COMMAND    CREATED              STATUS         PORTS   NAMES
e5d98a473adf  ubuntu:22.04  “bash” 8 minutes ago  Exited (0) 2 minutes ago vibrant_jenn
d752b475a54e  ubuntu:22.04  “bash” 18 minutes ago  Exited (0) 12 minutes ago  cool_perl</pre>
			<p>Try<a id="_idIndexMarker151"/> removing those exited containers with <strong class="source-inline">docker rm </strong><span class="No-Break"><strong class="source-inline">CONTAINER ID</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$ docker rm d752b475a54e
d752b475a54e
$ docker rm e5d98a473adf
e5d98a473adf</pre>
			<p>Now, the image should be <span class="No-Break">deleted too:</span></p>
			<pre class="source-code">
$ docker rmi ubuntu:22.04
Untagged: ubuntu:22.04
Untagged: ubuntu@sha256:26c68657ccce2cb0a31b330cb0be2b5e108d467f641c62e13ab40cbe c258c68d
Deleted: sha256:d2e4e1f511320dfb2d0baff2468fcf0526998b73fe10c8890b4684bb 7ef8290f
Deleted: sha256:e59fc94956120a6c7629f085027578e6357b48061d45714107e79f04 a81a6f0c</pre>
			<p><strong class="source-inline">sha256</strong> are the digests of image layers; they are unique and immutable identifiers. If we assign a different tag to our <strong class="source-inline">ubuntu</strong> image instead of <strong class="source-inline">22.04</strong> and try to pull (download) the same image from Docker Hub again, Docker will recognize that we already have an image with this digest and will do nothing except tag <span class="No-Break">it again.</span></p>
			<p>Let’s try one more thing – pulling another Docker image without any tags. If you simply <strong class="source-inline">pull</strong> the image, no container is going to be started, but this will save download time the next time a new container is started from <span class="No-Break">that image:</span></p>
			<pre class="source-code">
$ docker pull centos
Using default tag: latest
latest: Pulling from library/centos
a1d0c7532777: Pull complete
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473 f432b177
Status: Downloaded newer image for centos:latest
docker.io/library/centos:latest</pre>
			<p>As you can <a id="_idIndexMarker152"/>see, if we don’t specify the tag explicitly, <strong class="source-inline">latest</strong> will be taken by default. </p>
			<p>In the upcoming section, we will learn more about the meaning of the <strong class="source-inline">latest</strong> tag, tagging in general, and building images <span class="No-Break">with Docker.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Building container images</h1>
			<p>Now<a id="_idIndexMarker153"/> that we know how to start containers and pull images, we’ll learn what should be done to create new container images. Since the image layer is immutable, you can create new images with the software of your choice to build an image by adding new layers on top of existing ones. There are two ways this can be done <span class="No-Break">with Docker:</span></p>
			<ul>
				<li><span class="No-Break">Interactively</span></li>
				<li><span class="No-Break">Using Dockerfile</span></li>
			</ul>
			<p>The interactive way is to create an image from an existing container. Let’s say you start a container with the Ubuntu 22.04 environment, install additional packages, and expose port <strong class="source-inline">80</strong>. To create a new image, we can use the <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">commit</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
 $ docker commit CONTAINER_ID [REPOSITORY[:TAG]] </pre>
			<p>The image name will be in the <strong class="source-inline">REPOSITORY:TAG</strong> format. If no tag is given, then <strong class="source-inline">latest</strong> will be added automatically. If no repository was specified, the image name will be<a id="_idIndexMarker154"/> a <strong class="bold">unique identifier</strong> (<strong class="bold">UUID</strong>). The tag, as well as the name (which is the same as the image repository’s name), can be changed or applied after <span class="No-Break">the build.</span></p>
			<p>While the <a id="_idIndexMarker155"/>interactive method is quick and easy, it should not be used under normal circumstances because it is a manual, error-prone process and the resulting images might be larger with many <span class="No-Break">unnecessary layers.</span></p>
			<p>The second, better option for building images is <span class="No-Break">using Dockerfiles.</span></p>
			<p class="callout-heading">Dockerfile</p>
			<p class="callout">A Dockerfile is<a id="_idIndexMarker156"/> a text file containing instructions for building an image. It supports running shell scripts, installing additional packages, adding and copying files, defining commands executed by default, exposing ports, <span class="No-Break">and more.</span></p>
			<p>Let’s have a look at a <span class="No-Break">simplistic Dockerfile:</span></p>
			<pre class="source-code">
FROM ubuntu:22.04
RUN apt-get update &amp;&amp; apt-get install -y curl vim
LABEL description=”My first Docker image”</pre>
			<p>As you’ve probably already guessed, the <strong class="source-inline">FROM</strong> instruction defines the base image with a tag for the image we are going to build. The base image can also be one of our previously built local images or an image from the registry. <strong class="source-inline">RUN</strong> instructs to execute <strong class="source-inline">apt-get update</strong> and then install <strong class="source-inline">curl</strong> and <strong class="source-inline">vim</strong> packages. <strong class="source-inline">LABEL</strong> is simply any metadata you’d like to add to the image. If you copy the preceding contents to a file called <strong class="source-inline">Dockerfile</strong>, you’ll be able to build a new image by calling <strong class="source-inline">docker build</strong> in the <span class="No-Break">same folder:</span></p>
			<pre class="source-code">
$ docker build . -t myubuntuimage
[+] Building 11.2s (6/6) FINISHED
 =&gt; [internal] load build definition from Dockerfile                                                                                                                                                                                   0.0s
 =&gt; =&gt; transferring dockerfile: 153B                                                                                                                                                                                                     0.0s
 =&gt; [internal] load .dockerignore                                                                                                                                  
                                                        0.0s
 =&gt; =&gt; transferring context: 2B                                                                                                                                                                                                       0.0s
 =&gt; [internal] load metadata for docker.io/library/ubuntu:22.04                                                                                                                                                                        0.0s
 =&gt; [1/2] FROM docker.io/library/ubuntu:22.04                                                                                                                                                                                             0.0s
 =&gt; [2/2] RUN apt-get update &amp;&amp; apt-get install -y curl vim                                                                                                                                                                            9.9s
 =&gt; exporting to image                                                                                                                                                                                                    1.1s
 =&gt; =&gt; exporting layers                                                                                                                                          
                                                        1.1s
 =&gt; =&gt; writing image sha256:ed53dcc2cb9fcf7394f8b03818c02e0ec4 5da57e89b550b68fe93c5fa9a74b53                                                                                                                                           0.0s
 =&gt; =&gt; naming to docker.io/library/myubuntuimage                                                                                                                                                                                       0.0s</pre>
			<p>With <strong class="source-inline">-t myubuntuimage</strong>, we have specified the name of the image without the actual tag. This <a id="_idIndexMarker157"/>means that the <strong class="source-inline">latest</strong> tag will be applied to the image <span class="No-Break">by default:</span></p>
			<pre class="source-code">
$ docker images
REPOSITORY      TAG     IMAGE ID       CREATED       SIZE
myubuntuimage  latest  ed53dcc2cb9f   6 minutes ago   176MB
centos         latest  5d0da3dc9764   7 months ago    231MB</pre>
			<p>There are a few things we need to clarify about the <strong class="source-inline">latest</strong> tag, as it can <span class="No-Break">be misleading:</span></p>
			<ul>
				<li><strong class="source-inline">latest</strong> is applied by default if no tag is given during <span class="No-Break">the build</span></li>
				<li><strong class="source-inline">latest</strong> is pulled by default if no tag is given during image download or <span class="No-Break">container run</span></li>
				<li><strong class="source-inline">latest</strong> is not updated dynamically; you can tag any image as <strong class="source-inline">latest</strong> – even an older version of the <span class="No-Break">same image</span></li>
			</ul>
			<p>Therefore, the <a id="_idIndexMarker158"/>best practice is to tag images with something more descriptive rather than relying on <strong class="source-inline">latest</strong>. For instance, an incrementable version of the packaged application (v.0.32, v.1.7.1, and so on) can be used as a tag or even the build timestamp. The timestamp allows us to determine when the image was built without the need to inspect each <span class="No-Break">image metadata.</span></p>
			<p>Let’s quickly go back to the instructions supported in Dockerfiles. We’ve already learned about <strong class="source-inline">FROM</strong>, <strong class="source-inline">RUN</strong>, and <strong class="source-inline">LABEL</strong>, but there <span class="No-Break">are more:</span></p>
			<ul>
				<li><strong class="source-inline">ADD</strong>: This is used to copy files and directories <em class="italic">into</em> the Docker image (from a build location or <span class="No-Break">remote URLs).</span></li>
				<li><strong class="source-inline">COPY</strong>: This is used to copy files <em class="italic">within</em> the <span class="No-Break">Docker image.</span></li>
				<li><strong class="source-inline">CMD</strong>: This is used to define the default executable of a Docker image (only the last <strong class="source-inline">CMD</strong> instruction will be respected). <strong class="source-inline">CMD</strong> can be easily overridden at <span class="No-Break">container runtime.</span></li>
				<li><strong class="source-inline">ENTRYPOINT</strong>: This is similar to <strong class="source-inline">CMD</strong> and allows us to define the executable of an image when a container is started. It can ban be used together <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">CMD</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">EXPOSE</strong>: This tells us that the application in an image will be listening on a particular network port <span class="No-Break">at runtime.</span></li>
				<li><strong class="source-inline">ENV</strong>: This is used to set any environment variables in <span class="No-Break">the image.</span></li>
				<li><strong class="source-inline">USER</strong>: This sets the username<a id="_idIndexMarker159"/> or <strong class="bold">user ID</strong> (<strong class="bold">UID</strong>) for any <strong class="source-inline">RUN</strong>, <strong class="source-inline">CMD</strong>, or <span class="No-Break"><strong class="source-inline">ENTRYPOINT</strong></span><span class="No-Break"> instructions.</span></li>
				<li><strong class="source-inline">VOLUME</strong>: This is used to create a mount point with the given name and marks it for use with externally mounted volumes (for example, from the host where the container will <span class="No-Break">be started).</span></li>
				<li><strong class="source-inline">WORKDIR</strong>: This sets the working (current) directory for <strong class="source-inline">RUN</strong>, <strong class="source-inline">CMD</strong>, and <span class="No-Break"><strong class="source-inline">ENTRYPOINT</strong></span><span class="No-Break"> instructions.</span></li>
			</ul>
			<p>A <a id="_idIndexMarker160"/>quick note about <strong class="source-inline">CMD</strong> and <strong class="source-inline">ENTRYPOINT</strong>: they are similar, yet not the same. We could specify either <strong class="source-inline">CMD</strong>, <strong class="source-inline">ENTRYPOINT</strong>, or both in our Dockerfile. If we specify both, then <strong class="source-inline">CMD</strong> acts as a parameter for <strong class="source-inline">ENTRYPOINT</strong>. Since <strong class="source-inline">CMD</strong> is a bit easier to override at runtime, then typically, <strong class="source-inline">ENTRYPOINT</strong> is the executable and <strong class="source-inline">CMD</strong> is the argument in such scenarios. For example, we could set <strong class="source-inline">ENTRYPOINT</strong> to <strong class="source-inline">/bin/cat</strong> and use <strong class="source-inline">CMD</strong> to give a path to a file we want to concatenate (<strong class="source-inline">/etc/hosts</strong>; <strong class="source-inline">/etc/group</strong>, and so on). For many public images from Docker Hub, <strong class="source-inline">ENTRYPOINT</strong> is set to <strong class="source-inline">/bin/sh -c</strong> <span class="No-Break">by default.</span></p>
			<p>This list is not meant to be a complete reference of instructions supported by Dockerfiles, but it mentions the most used instructions that cover 99% of scenarios. In addition, you don’t often build containers on your laptop or local workstation; instead, you use a modern CI/CD system or an automated build from Docker Hub as an alternative. </p>
			<p>Now, let’s understand <a id="_idIndexMarker161"/>what a development workflow might look like when containers are <span class="No-Break">in use:</span></p>
			<ol>
				<li>Software<a id="_idIndexMarker162"/> developers <a id="_idIndexMarker163"/>write application code in their language of choice – for <a id="_idIndexMarker164"/>instance, <strong class="bold">Python</strong>, <strong class="bold">Java</strong>, <strong class="bold">Ruby</strong>, <strong class="bold">Node.js</strong>, <strong class="bold">Golang</strong>, or <a id="_idIndexMarker165"/>anything else. </li>
			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">There is no need to learn a new programming language – any software that runs in a Linux environment will run inside a <span class="No-Break">container too.</span></p>
			<ol>
				<li value="2">The code is tested and pushed to a GitHub repository or other version control system. The CI/CD or a third-party solution is triggered when a change is made to the source code; the application is packaged inside a container image according to the defined Dockerfile. </li>
				<li>Dockerfile instructions will be used to copy the code and run and install it inside the container image layer. These instructions vary, depending on the language and the OS environment that’s chosen. For example, a Node.js application will likely require <strong class="source-inline">yarn install</strong> to run, whereas a Python application will be installed with the help of a <strong class="source-inline">pip</strong> command, and <span class="No-Break">so on.</span></li>
				<li>The<a id="_idIndexMarker166"/> image is built, tagged, and pushed (uploaded) to an image registry. This might be, for example, a private repository in Docker Hub, a repository offered by a cloud provider, or even your own registry maintained within <span class="No-Break">the company.</span></li>
				<li>At this point, the image can be downloaded and run by a container orchestrator such as Kubernetes, by a server with a container runtime, or simply by other team members with the Docker tooling they <span class="No-Break">have installed.</span></li>
			</ol>
			<p>As you may remember, one of the main features of containers is <em class="italic">portability</em> – a container running on one host will also run on another host. This means that you can have a container image with Alpine Linux and run it on both your laptop with Fedora Linux or on an Ubuntu-based <span class="No-Break">Kubernetes cluster.</span></p>
			<p>But wait – can we run Linux containers on Windows or vice versa? Not really. First, we need to distinguish between Linux containers and Windows containers. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Everything in this book and the KCNA exam itself is only about <span class="No-Break">Linux containers.</span></p>
			<p>Even if you are running Docker Desktop on Windows, it is using a minimal <strong class="bold">Linuxkit</strong> virtual machine<a id="_idIndexMarker167"/> in the background. Windows containers are different and might use one of the two distinct<a id="_idIndexMarker168"/> isolation modes (<strong class="bold">WSL 2</strong> or <strong class="bold">Hyper-V</strong>) available<a id="_idIndexMarker169"/> today in the Microsoft operating system. Docker Desktop allows you to switch between <em class="italic">Windows containers</em> and <em class="italic">Linux containers</em> if you are running on Windows. However, keep in mind that more than 90% of the servers in the world run Linux, so unless you are going to run Windows-only applications in containers, you are fine to only learn about and use <span class="No-Break">Linux containers.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Summary</h1>
			<p>In this chapter, we gained experience with (Linux) containers and learned that the technology behind containers has existed for many years and is based on <em class="italic">cgroups</em> and <span class="No-Break">kernel </span><span class="No-Break"><em class="italic">namespaces</em></span><span class="No-Break">.</span></p>
			<p>Docker has introduced tooling that’s aimed at developers and engineers looking for a universal and simple way to package and share applications. Before containers, it has often been the case that an application could work in the development environment but fail in the production environment because of unmet dependencies or incorrect versions that have been installed. Containers have fixed this problem by bundling the application with all the dependencies and system packages in a template known as a <span class="No-Break">container image.</span></p>
			<p>Container images can be stored in registries that support private and public repositories and allow you to share them with different teams. <strong class="bold">Docker Hub</strong>, <strong class="bold">Quay</strong>, and <strong class="bold">Google Container Registry</strong> (<strong class="bold">GCR</strong>) are some of the most well-known container image registries today that can be reached over the internet. An image that’s pushed (uploaded) to the registry can then be pulled (downloaded) by a container orchestrator such as Kubernetes or simply by a server with a container runtime over <span class="No-Break">the internet.</span></p>
			<p>Images are used to create containers, so a container is a running instance of an image. When a container is started with a writable filesystem, a layer is created on top of the immutable image layer. Containers and images can have multiple layers and we can start as many containers as we want from a single image. Containers are more lightweight compared to VMs and are very fast <span class="No-Break">to start.</span></p>
			<p>We also learned that to build a container image with Docker, we can leverage an interactive or Dockerfile method. With Dockerfile, we define a set of instructions that will be executed to build an image with our <span class="No-Break">containerized application.</span></p>
			<p>In the next chapter, we will continue exploring containers by learning about the runtimes and pluggable interfaces provided <span class="No-Break">by Kubernetes.</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Questions</h1>
			<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter’s material. You will find the answers in the <em class="italic">Assessments</em> section of <span class="No-Break">the </span><span class="No-Break"><em class="italic">Appendix</em></span><span class="No-Break">:</span></p>
			<ol>
				<li value="1">Which of the following features describes containers (<span class="No-Break">pick two)?</span><ol><li>Portability <span class="No-Break">between environments</span></li><li>Large <span class="No-Break">image size</span></li><li>Small <span class="No-Break">image size</span></li><li><span class="No-Break">High security</span></li></ol></li>
				<li>Which of the following is true (<span class="No-Break">pick two)?</span><ol><li>Applications are easy to package <span class="No-Break">in containers</span></li><li>Applications are easy to package in <span class="No-Break">virtual machines</span></li><li>Container images are easy <span class="No-Break">to share</span></li><li>VM images are easy <span class="No-Break">to share</span></li></ol></li>
				<li>What programming language do developers have to learn to run their code <span class="No-Break">in containers?</span><ol><li><span class="No-Break">Dockerlang</span></li><li><span class="No-Break">Golang</span></li><li><span class="No-Break">Python</span></li><li>None – containers allow the same languages that are supported by the <span class="No-Break">OS environment</span></li></ol></li>
				<li>Which of the following problems do containers address (<span class="No-Break">pick two)?</span><ol><li>Unmet dependencies <span class="No-Break">between environments</span></li><li>Bugs in <span class="No-Break">application code</span></li><li>Need to test <span class="No-Break">application code</span></li><li>Long VM <span class="No-Break">startup times</span></li></ol></li>
				<li>Which of the following is used by containers (<span class="No-Break">pick two)?</span><ol><li><span class="No-Break"><strong class="source-inline">cgroups</strong></span></li><li><span class="No-Break"><strong class="source-inline">hwmon</strong></span></li><li><span class="No-Break"><strong class="source-inline">acpi</strong></span></li><li><span class="No-Break"><strong class="source-inline">kernel namespaces</strong></span></li></ol></li>
				<li>Which of the following can be used to share container images (<span class="No-Break">pick two)?</span><ol><li><span class="No-Break">Docker Hub</span></li><li><span class="No-Break">Docker Swarm</span></li><li><span class="No-Break">Docker Registry</span></li><li><span class="No-Break">Docker Compose</span></li></ol></li>
				<li>Which of the following is true about container images (<span class="No-Break">pick two)?</span><ol><li>They can only be built <span class="No-Break">with Dockerfiles</span></li><li>They include immutable <span class="No-Break">filesystem layers</span></li><li>The newest image is always tagged as <span class="No-Break">the latest</span></li><li>They can be <span class="No-Break">built interactively</span></li></ol></li>
				<li>Which of the following applies when starting a new container (<span class="No-Break">pick two)?</span><ol><li>A new writable filesystem layer <span class="No-Break">is created</span></li><li>The requested image is <span class="No-Break">always pulled</span></li><li>An image is pulled if the requested tag (SHA digest) is not <span class="No-Break">found locally</span></li><li>A new Linux kernel <span class="No-Break">is loaded</span></li></ol></li>
				<li>Which of the following is true about container image tags (<span class="No-Break">pick two)?</span><ol><li>Every image must <span class="No-Break">have tags</span></li><li>The latest tag is applied automatically on build, <span class="No-Break">unless overridden</span></li><li>The same image cannot have <span class="No-Break">multiple tags</span></li><li>The same image can have multiple names (repositories) <span class="No-Break">and tags</span></li></ol></li>
				<li>How can a new container be created using <span class="No-Break">Docker tooling?</span><ol><li><span class="No-Break"><strong class="source-inline">docker run</strong></span></li><li><span class="No-Break"><strong class="source-inline">docker exec</strong></span></li><li><span class="No-Break"><strong class="source-inline">docker spawn</strong></span></li><li><span class="No-Break"><strong class="source-inline">docker launch</strong></span></li></ol></li>
			</ol>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Further reading</h1>
			<p>While this chapter provided an insight into the container ecosystem and the knowledge needed to pass the KCNA exam, it doesn’t cover all the features of Docker tooling nor describes cgroups and namespaces in detail. If you’d like to go the extra mile, you are encouraged to check out the <span class="No-Break">following resources:</span></p>
			<ul>
				<li>cgroups v1: <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt</a> </li>
				<li>Namespaces: <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">https://man7.org/linux/man-pages/man7/namespaces.7.html</a> </li>
				<li>Getting started with <span class="No-Break">Docker: </span><a href="https://docs.docker.com/get-started/ "><span class="No-Break">https://docs.docker.com/get-started/</span></a></li>
				<li>Best practices for writing <span class="No-Break">Dockerfiles: </span><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/"><span class="No-Break">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</span></a></li>
			</ul>
		</div>
	</body></html>