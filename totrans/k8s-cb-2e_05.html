<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Continuous Delivery Pipelines</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will cover the following recipes: </p>
<ul>
<li>Moving monolithic to microservices</li>
<li>Working with the private Docker registry</li>
<li>Integrating with Jenkins </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>Kubernetes is a perfect match for applications featuring the microservices architecture. However, most of the old applications are built in the monolithic style. We will give you an idea about how to move from the monolithic to the microservices world. As for microservices, deployment will become a burden if you are doing it manually. We will learn how to build up our own continuous delivery pipeline by coordinating Jenkins, the Docker registry, and Kubernetes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving monolithic to microservices</h1>
                </header>
            
            <article>
                
<p><span>Typically, application architecture is the monolithic design that contains a</span> <strong>Model-View- Controller</strong> (<strong>MVC</strong><span>) and every component within a single, big binary. A</span> monolithic <span>design has some</span> <span>benefits, such as less latency within components, being all in one straightforward package,</span> <span>and being easy to deploy and test.</span></p>
<p><span>However, a</span> monolithic <span>design has some downsides because the binary will be getting bigger and bigger. You always need to take care of the side effects when adding or modifying the code, therefore making release cycles longer.</span></p>
<p class="column"><span>Containers and Kubernetes give more flexibility when using</span> microservices <span>for your application.</span> <span>The</span> microservices <span>architecture is very simple and can be divided into some modules or some service classes together with MVC:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/9459422c-7fe8-4107-9f7c-2d0718edd145.png" style="width:132.25em;height:68.42em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Monolithic and microservices design</span></div>
<div class="page">
<p class="layoutArea"><span>Each microservice provides a </span><strong>Remote Procedure Call</strong> (<strong>RPC</strong><span>) using RESTful or some standard</span> <span>network APIs to other</span> microservices. <span>The benefit is that each</span> microservice <span>is independent.</span> <span>There are minimal side effects when adding or modifying the code. Release the cycle</span> <span>independently, so it perfectly ties in with the Agile software development methodology and allows</span> <span>for the reuse of these</span> microservices <span>to construct another application that builds the</span> microservices <span>ecosystem.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Prepare the simple microservices program. In order to push and pull your</span> microservices<span>, please register to Docker hub (</span><a href="https://hub.docker.com/"><span>https://hub.docker.com/</span></a><span>) to create your free Docker ID in advance.</span></p>
<div class="packt_tip"><span>If you push the Docker image to Docker hub, it will be public; anyone can pull your image. Therefore, don't put any confidential information into the image.</span></div>
<p><span>Once you successfully log in to your Docker ID, you will be redirected to your</span> <span class="packt_screen">Dashboard</span> <span>page as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2fa69dc3-7110-456f-9da3-b049acaa6b28.png" style="width:87.75em;height:45.17em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>After logging in to Docker hub</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Prepare both microservices and the frontend WebUI as a Docker image. Then, deploy them using the Kubernetes replication controller and service.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices</h1>
                </header>
            
            <article>
                
<p>Build a microservice which provides a simple math function by using following steps:</p>
<ol>
<li class="mce-root"><span>Here is the simple microservice using Python <kbd>Flask</kbd> (<a href="http://flask.pocoo.org/">http://flask.pocoo.org/</a>):</span></li>
</ol>
<pre style="padding-left: 90px"><span>$ cat entry.py<br/></span><span>from flask import Flask, request <br/></span><span>app = Flask(__name__)<br/><br/></span><span>@app.route("/")<br/>def hello():<br/></span><span>    return "Hello World!" <br/><br/></span><span>@app.route("/power/&lt;int:base&gt;/&lt;int:index&gt;")<br/>def power(base, index): <br/></span><span>    return "%d" % (base ** index)
<br/></span><span>@app.route("/addition/&lt;int:x&gt;/&lt;int:y&gt;")
def add(x, y):<br/></span><span>    return "%d" % (x+y)<br/><br/></span><span>@app.route("/substraction/&lt;int:x&gt;/&lt;int:y&gt;")
def substract(x, y):<br/></span><span>    return "%d" % (x-y)
<br/></span><span>if __name__ == "__main__":<br/>    app.run(host='0.0.0.0')
</span></pre>
<ol start="2">
<li><span>Prepare a</span> <kbd>Dockerfile</kbd> <span>as follows in order to build the Docker image:</span></li>
</ol>
<pre class="page" style="padding-left: 90px"><span>$ cat Dockerfile<br/>FROM ubuntu:14.04 <br/><br/></span><span># Update packages
RUN apt-get update -y<br/></span><span><br/># Install Python Setuptools<br/></span><span>RUN apt-get install -y python-setuptools git telnet curl<br/><br/></span><span># Install pip<br/></span><span>RUN easy_install pip<br/><br/></span><span># Bundle app source<br/>ADD . /src<br/>WORKDIR /src</span><span><br/></span><span><br/></span><span># Add and install Python modules<br/></span><span>RUN pip install Flask<br/></span><span><br/># Expose<br/></span><span>EXPOSE 5000<br/></span><span><br/># Run<br/></span><span>CMD ["python", "entry.py"]</span></pre>
<ol start="3">
<li><span>Then, use the</span> <kbd><span>docker build</span></kbd> <span>command to build the Docker image as follows:</span></li>
</ol>
<pre style="padding-left: 90px">//name as “your_docker_hub_id/my-calc”<br/>$ sudo docker build -t hidetosaito/my-calc .<br/>Sending build context to Docker daemon 3.072 kB<br/>Step 1 : FROM ubuntu:14.04<br/> ---&gt; 6cc0fc2a5ee3<br/>Step 2 : RUN apt-get update -y<br/> ---&gt; Using cache<br/><br/><br/>(snip)<br/><br/><br/>Step 8 : EXPOSE 5000<br/> ---&gt; Running in 7c52f4bfe373<br/> ---&gt; 28f79bb7481f<br/>Removing intermediate container 7c52f4bfe373<br/>Step 9 : CMD python entry.py<br/> ---&gt; Running in 86b39c727572<br/> ---&gt; 20ae465bf036<br/>Removing intermediate container 86b39c727572<br/>Successfully built 20ae465bf036<br/><br/><br/>//verity your image<br/>$ sudo docker images<br/>REPOSITORY            TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br/>hidetosaito/my-calc   latest              20ae465bf036        19 seconds ago      284 MB<br/>ubuntu                14.04               6cc0fc2a5ee3        3 weeks ago         187.9 MB</pre>
<ol start="4">
<li>Then, use the <kbd>docker login</kbd> command to log in to Docker hub:</li>
</ol>
<pre class="CommandLinePACKT" style="padding-left: 90px">//type your username, password and e-mail address in Docker hub<br/>$ sudo docker login<br/>Username: hidetosaito<br/>Password:<br/>Email: hideto.saito@yahoo.com<br/>WARNING: login credentials saved in /home/ec2-user/.docker/config.json<br/>Login Succeeded</pre>
<ol start="5">
<li><span>Finally, use the</span> <kbd><span>docker push</span></kbd> <span>command to register to your Docker hub repository as follows:</span></li>
</ol>
<pre class="CommandLinePACKT" style="padding-left: 90px">//push to your docker index<br/>$ sudo docker push hidetosaito/my-calc<br/>The push refers to a repository [docker.io/hidetosaito/my-calc] (len: 1)<br/>20ae465bf036: Pushed<br/> <br/>(snip)<br/> <br/>92ec6d044cb3: Pushed<br/>latest: digest: sha256:203b81c5a238e228c154e0b53a58e60e6eb3d1563293483ce58f48351031a474 size: 19151</pre>
<ol start="6">
<li>Upon access to Docker hub, you can see your microservice in the repository:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-342 image-border" src="assets/0126d63d-fb96-4007-aacc-43f4518fb247.png" style="width:36.67em;height:22.75em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Your microservice Docker image on Docker hub</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Frontend WebUI</h1>
                </header>
            
            <article>
                
<p>Build WebUI that uses preceding microservice by following steps:</p>
<ol>
<li><span>Here is the simple frontend WebUI that also uses Python <kbd>Flask</kbd>:</span></li>
</ol>
<pre style="padding-left: 90px">$ cat <span>entry.py</span><br/>import os<br/>import httplib<br/>from flask import Flask, request, render_template<br/><br/>app = Flask(__name__)<br/><br/>@app.route("/")<br/>def index():<br/>    return render_template('index.html')<br/><br/><br/>@app.route("/add", methods=['POST'])<br/>def add():<br/>    #<br/>    # from POST parameters<br/>    #<br/>    x = int(request.form['x'])<br/>    y = int(request.form['y'])<br/><br/>    #<br/>    # from Kubernetes Service(environment variables)<br/>    #<br/>    my_calc_host = os.environ['MY_CALC_SERVICE_SERVICE_HOST']<br/>    my_calc_port = os.environ['MY_CALC_SERVICE_SERVICE_PORT']<br/><br/>    #<br/>    # REST call to MicroService(my-calc)<br/>    #<br/>    client = httplib.HTTPConnection(my_calc_host, my_calc_port)<br/>    client.request("GET", "/addition/%d/%d" % (x, y))<br/>    response = client.getresponse()<br/>    result = response.read()<br/>    return render_template('index.html', add_x=x, add_y=y,<br/>add_result=result)<br/><br/>if __name__ == "__main__":<br/>    app.debug = True<br/>    app.run(host='0.0.0.0')</pre>
<div class="column packt_tip"><span>Kubernetes service generates the Kubernetes service name and port number as an environment variable to the other pods. Therefore, the environment variable's name and the Kubernetes service name must be consistent. </span><span>In this scenario, the</span> <kbd><span>my-calc</span></kbd> <span>service name must be</span> <kbd>my-calc-service</kbd><span>. </span></div>
<ol start="2">
<li><span>The frontend WebUI uses the <kbd>Flask</kbd> HTML template; it is similar to PHP and JSP in that</span> <kbd>entry.py</kbd> <span>will pass the parameter to the template (</span><kbd>index.html</kbd><span>) to render the HTML:</span></li>
</ol>
<pre style="padding-left: 90px">$ cat <span>templates/index.html</span><br/>&lt;html&gt;<br/>   &lt;body&gt;<br/>   &lt;div&gt;<br/>         &lt;form method="post" action="/add"&gt;<br/>           &lt;input type="text" name="x" size="2"/&gt;<br/>           &lt;input type="text" name="y" size="2"/&gt;<br/>           &lt;input type="submit" value="addition"/&gt;<br/>       &lt;/form&gt;<br/>       {% if add_result %}<br/>       &lt;p&gt;Answer : {{ add_x }} + {{ add_y }} = {{ add_result }}&lt;/p&gt;<br/>       {% endif %}<br/>   &lt;/div&gt;<br/>   &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<ol start="3">
<li><kbd>Dockerfile</kbd> <span>is exactly the same as the microservice</span> <kbd>my-calc</kbd><span>. So, eventually, the file structure</span> <span>will be as follows. Note that</span> <kbd>index.html</kbd> <span>is a jinja2 template file; therefore, put it under</span> <span>the</span> <kbd>/templates</kbd> <span>directory:</span></li>
</ol>
<pre style="padding-left: 90px"><span>/Dockerfile<br/></span><span>/entry.py<br/></span><span>/templates/index.html</span></pre>
<ol start="4">
<li>Then, build a Docker image and push to Docker hub as follows:</li>
</ol>
<div class="packt_infobox"><span>In order to push your image to Docker hub, you need to log in using the</span> D<span>ocker login</span> <span>command. It is needed only once; the system checks</span> <kbd><span>~/.docker/config.json</span></kbd> <span>to read from there.</span></div>
<pre style="padding-left: 90px">//build frontend Webui image <br/>$ sudo docker build -t hidetosaito/my-frontend .<br/><br/>//login to docker hub<br/>$ sudo docker login<br/><br/>//push frontend webui image<br/>$ sudo docker push hidetosaito/my-frontend</pre>
<ol start="5">
<li>Upon access to Docker hub, you can see your WebUI application in the repository:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-343 image-border" src="assets/0c2579a3-2e7c-470e-a056-0ecec6d0a1ca.png" style="width:166.58em;height:93.58em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Microservices and frontend WebUI image on Docker Hub</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's <span>prepare two YAML configurations to </span>launch a microservice container and frontend WebUI container using Kubernetes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices</h1>
                </header>
            
            <article>
                
<p><span>Microservices (</span><kbd><span>my-calc</span></kbd><span>) uses the Kubernetes deployment and service, but it needs to communicate to other pods only. In other words, there's no need to expose it to the outside Kubernetes network. Therefore, the service type is set as</span> <kbd>ClusterIP</kbd><span>:</span></p>
<pre>$ cat my-calc.yaml <br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-calc-deploy<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      run: my-calc<br/>  template:<br/>    metadata:<br/>      labels:<br/>        run: my-calc<br/>    spec:<br/>      containers:<br/>      - name: my-calc<br/>        image: hidetosaito/my-calc<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-calc-service<br/>spec:<br/>  ports:<br/>    - protocol: TCP<br/>      port: 5000<br/>  type: <strong>ClusterIP</strong><br/>  selector:<br/>     run: my-calc</pre>
<p class="column"><span>Use the</span> <kbd><span>kubectl</span></kbd> <span>command to load the</span> <kbd>my-calc</kbd> <span>pods as follows:</span></p>
<pre>$ kubectl create -f my-calc.yaml <br/>deployment.apps "my-calc-deploy" created<br/>service "my-calc-service" created</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Frontend WebUI</h1>
                </header>
            
            <article>
                
<p><span>Frontend WebUI also uses the deployment and service, but it exposes the port (TCP port</span> <kbd><span>30080</span></kbd><span>) in order to access it from an external web browser:</span></p>
<pre>$ cat my-frontend.yaml <br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-frontend-deploy<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      run: my-frontend<br/>  template:<br/>    metadata:<br/>      labels:<br/>        run: my-frontend<br/>    spec:<br/>      containers:<br/>      - name: my-frontend<br/>        image: hidetosaito/my-frontend<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-frontend-service<br/>spec:<br/>  ports:<br/>    - protocol: TCP<br/>      port: 5000<br/>      <strong>nodePort: 30080</strong><br/>  type: <strong>NodePort</strong><br/>  selector:<br/>     run: my-frontend<br/><br/><br/>$ kubectl create -f my-frontend.yaml <br/>deployment.apps "my-frontend-deploy" created<br/>service "my-frontend-service" created</pre>
<p><span> </span><span>Let's try to access</span> <span><kbd>my-frontend-service</kbd> </span><span>using a web browser. You can access any Kubernetes node's IP address; specify the port number</span> <span>30080. If you are using</span> minikube<span>, simply type <kbd>minikube service my-frontend-service</kbd> to access. Then you can see the </span><kbd>my-frontend </kbd><span>application as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-344 image-border" src="assets/c7aed4df-0a7b-4e57-812a-91e75552352e.png" style="width:43.08em;height:13.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Access to the frontend WebUI</div>
<p><span>When you click on the</span> <span class="packt_screen">addition</span> <span>button, it will forward a parameter to microservices (</span><kbd>my-calc</kbd><span>). Microservices compute the addition (yes, just an addition!) and then return the result back to the frontend WebUI as follows:</span></p>
<div class="column packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-345 image-border" src="assets/75836636-1a08-480c-8683-294f03a36740.png" style="width:45.08em;height:15.00em;"/></div>
<div class="column packt_figref CDPAlignCenter CDPAlign"><span>Getting a result from microservices and rendering the HTML</span></div>
<p><span>So now, it is easy to scale the pod for the frontend WebUI and microservices independently. For example, scale WebUI pod from <kbd>2</kbd> to <kbd>8</kbd> and microservice pod from <kbd>2</kbd> to <kbd>16</kbd>, as shown:</span></p>
<pre>$ kubectl get deploy<br/><span>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/></span><span>my-calc-deploy       2         2         2            2           30m<br/></span><span>my-frontend-deploy   2         2         2            2           28m<br/></span><br/>$ kubectl scale deploy my-frontend-deploy --replicas=8<br/>deployment "my-frontend-deploy" scaled<br/><br/>$ kubectl scale deploy my-calc-deploy --replicas=16<br/>deployment "my-calc-deploy" scaled<br/><br/><span>$ kubectl get deploy<br/></span><span>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/></span><span>my-calc-deploy       16        16        16           16          31m<br/></span><span>my-frontend-deploy   8         8         8            8           29m<br/></span></pre>
<p><span>Also, if there's a need to fix some bugs, for example, if there's a frontend need to validate<br/>
the input parameter to check whether it is numeric or a string (yes, if you type string and<br/>
then submit, it will show an error!), it will not affect the build and deploy the cycle against<br/>
microservices:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/085ae157-527d-4a9f-b15d-174e0acfe8b0.png" style="width:35.08em;height:30.17em;"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><span>Frontend and microservice pods and services</span></div>
<p><span>In addition, if you want to add another microservice, for example, subtraction microservices, you may need to create another Docker image and deploy with another deployments and service, so it will be independent from the current microservices. </span><span>Then, you can keep accumulating your own microservice ecosystem to reuse in another application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with the private Docker registry</h1>
                </header>
            
            <article>
                
<div class="page">
<p><span>Once you start to build your microservice application via Docker, you'll need to have a Docker registry to put your container image in. Docker hub offers you free public repositories, however, in some cases you might want to make your image private due to business needs or organization policy.</span></p>
<p><span>Docker hub offers the <strong>private repository</strong>, which only allows authenticated users to push and pull your images, and is not visible to other users. However, there is only one quota (repository) for a free plan. You may pay to increase the number of private repositories, but if you adopt the microservices architecture, you will need a large number of private repositories:</span></p>
</div>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-347 image-border" src="assets/f17ae140-cc38-4932-95b1-cfadf4a27a26.png" style="width:39.67em;height:23.08em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Docker hub private repositories price list</span></div>
<p><span>Docker hub with a paid plan is the easiest way to set up your private registry, but </span><span>there are some other ways to set up your own private Docker registry, which the unlimited Docker image quota locates inside your network. In addition, you can also use other cloud-provided registry services to manage your private registry.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, we will show you three different ways to set up your own private registries:</span></p>
<ul>
<li>Using Kubernetes to run a private registry image (<a href="https://hub.docker.com/_/registry/">https://hub.docker.com/_/registry/</a>)</li>
<li>Using Amazon elastic container registry (<a href="https://aws.amazon.com/ecr/">https://aws.amazon.com/ecr/</a>)</li>
<li>Using Google container registry (<a href="https://cloud.google.com/container-registry/">https://cloud.google.com/container-registry/</a>)</li>
</ul>
<p>When using a Kubernetes to set up a private registry, you may use your own Kubernetes cluster on the private or public cloud, which allows you to have full control and utilize most of your physical resources.</p>
<p>On the other hand, when using a public cloud-provided service, such as AWS or GCP, you can be relieved of the management of servers and storage. Whatever you need, those public clouds provide you with elastic resources. We'll just have to set the credentials to Kubernetes and let the nodes know. The following recipes will go through these three different options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Kubernetes to run a Docker registry server</h1>
                </header>
            
            <article>
                
<p>If you want to launch a private registry server using Kubernetes, you need your own Kubernetes cluster. You will have set up your own Kubernetes while exploring this book. If you haven't done yet, please read <a href="4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml" target="_blank">Chapter 1</a>, <em>Building Your Own Kubernetes <span>Cluster</span></em>, to choose the easiest way.</p>
<p>Please note that Docker registry will store some of your Docker images. You must have a <kbd>PersistentVolume</kbd> to manage your storage via Kubernetes. In addition, we should expect that multiple pods will read and write to the same <kbd>PersistentVolume</kbd> due to scalability. Therefore, you must have the <strong>ReadWriteMany</strong> (<strong>RWX</strong>)<strong> </strong>access mode of <kbd>PersistentVolume</kbd>, such as GlusterFS or NFS.</p>
<p>Details of <kbd>PersistentVolume</kbd> are described in the <em>Working with volumes</em> section in <a href="e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml" target="_blank">Chapter 2</a>, <em><span>Walking through Kubernetes Concepts</span></em>. Let's create a <kbd>PersistentVolume</kbd> that uses NFS and the name <kbd>pvnfs01</kbd> to allocate <kbd>100</kbd> GB: </p>
<pre>//my NFS server(10.138.0.5) shares /nfs directory<br/>$ showmount -e 10.138.0.5<br/>Export list for 10.138.0.5:<br/>/nfs *<br/><br/><br/>//please change spec.nfs.path and spec.nfs.server to yours<br/>$ cat pv_nfs.yaml <br/>apiVersion: "v1"<br/>kind: "PersistentVolume"<br/>metadata:<br/>  name: pvnfs01<br/>spec:<br/>  capacity:<br/>    storage: "100Gi"<br/>  accessModes:<br/>    - "ReadWriteMany"<br/>  nfs:<br/>    path: "/nfs"<br/>    server: "10.138.0.5"<br/><br/><br/>$ kubectl create -f pv_nfs.yaml <br/>persistentvolume "pvnfs01" created<br/><br/>$ kubectl get pv<br/>NAME    CAPACITY ACCESS MODES RECLAIM POLICY STATUS    CLAIM STORAGECLASS REASON AGE<br/>pvnfs01 100Gi    RWX          Retain         Available                           5s</pre>
<div class="packt_tip">If you can't prepare RWX <kbd>PersistentVolume</kbd>, you may still be able to set up Docker registry by Kubernetes, but <span>you can launch </span>only one pod (replicas: one). As an alternative, you may use AWS S3 or GCP PD as private registry backend storage; please visit <a href="https://docs.docker.com/registry/configuration/">https://docs.docker.com/registry/configuration/</a> to learn how to configure backend storage for your registry.</div>
<p>Next, create <kbd>PersistentVolumeClaim</kbd> that decouples NFS <kbd>PersistentVolume</kbd> and pod configuration. Let's create one <kbd>PersistentVolumeClaim</kbd> named <kbd>pvc-1</kbd>. <span>Make sure <kbd>accessModes</kbd> is</span> <kbd>ReadWriteMany</kbd> <span>and that <kbd>STATUS</kbd> became</span> <kbd>Bound</kbd><span> after creation:</span></p>
<pre>$ cat pvc-1.yml <br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>    name: pvc-1<br/>spec:<br/>  storageClassName: ""<br/>  accessModes:<br/>    - <strong>ReadWriteMany</strong><br/>  resources:<br/>    requests:<br/>      storage: 100Gi<br/><br/>$ kubectl create -f pvc-1.yml <br/>persistentvolumeclaim "pvc-1" created<br/><br/>$ kubectl get pvc<br/>NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE<br/>pvc-1 <strong>Bound</strong> pvnfs01 100Gi RWX 5s</pre>
<p>This is enough to set up your private registry. It has some prerequisites; alternatively, using the public cloud is much simpler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Amazon elastic container registry</h1>
                </header>
            
            <article>
                
<p>Amazon <strong>elastic container registry</strong> (<strong>ECR</strong>) was introduced as a part of Amazon <strong>elastic container service</strong> (<strong>ECS</strong>). This recipe won't touch on ECS itself; instead, just use ECR as a private registry.</p>
<p>In order to use Amazon ECR, you have to have an AWS account and install AWS CLI on your machine. It will be described in more detail in <a href="b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml" target="_blank">Chapter 6</a>, <em>Building Kubernetes on AWS. </em>You'll have to create an IAM user with <kbd>ACCESS KEY ID</kbd> <span>and</span> <kbd>SECRET ACCESS KEY</kbd>, and associated<span> </span><kbd>AmazonEC2ContainerRegistryFullAccess</kbd> policies, which allow full administrator access to Amazon ECR:</p>
<pre>{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": [<br/>        "ecr:*"<br/>      ],<br/>      "Resource": "*"<br/>    }<br/>  ]<br/>}</pre>
<p><span>Then configure the default settings in AWS CLI via the</span> <kbd>aws configure</kbd> <span>command:</span></p>
<pre><span>$ aws configure<br/></span><span>AWS Access Key ID [None]: &lt;Your AWS ACCESS KEY ID&gt;<br/></span><span>AWS Secret Access Key [None]: &lt;Your AWS SECRET ACCESS KEY&gt;<br/></span><span>Default region name [None]: us-east-1<br/></span><span>Default output format [None]: </span></pre>
<p>Then we can start to play with Amazon ECR.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Google cloud registry</h1>
                </header>
            
            <article>
                
<div>
<p><strong>Google container registry</strong> (<a href="https://cloud.google.com/container-registry/">https://cloud.google.com/container-registry/</a>) is a part of the GCP. Similar to AWS, having a GCP account is required, as well as Cloud SDK (<a href="https://cloud.google.com/sdk/" target="_blank">https://cloud.google.com/sdk/</a>), which is the command-line interface in GCP. More details about GCP will be described in <a href="dfc46490-f109-4f07-ba76-1a381b006d76.xhtml" target="_blank">Chapter 7</a>, <em>Building Kubernetes on GCP</em>. </p>
</div>
<div>
<p><span>On GCP, we'll just need to create a</span> project <span>and enable b</span>illing <span>and the c</span>ontainer registry API for our project. Otherwise, any operation in <kbd>gcloud</kbd> will display an error:</p>
</div>
<div>
<pre>$ gcloud container images list <br/><span>ERROR: (gcloud.container.images.list) Bad status during token exchange: 403 </span></pre></div>
<div>
<p><span>In order to enable billing and container registry API, visit the GCP web console (<a href="https://console.cloud.google.com">https://console.cloud.google.com</a>), navigate to the billing page and container registry page, then just enable those. </span><span>Once activation is done, you can use the <kbd>gcloud container</kbd> command:</span></p>
</div>
<div>
<pre>$ gcloud container images list <br/><span>Listed 0 items. </span><span> </span></pre></div>
<p>Now we can start to use Google container registry.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We have set up the preparation steps. Let's see how to configure your private registry step by step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching a private registry server using Kubernetes</h1>
                </header>
            
            <article>
                
<p><span>In order to launch a private registry, it is necessary to configure these files in order to configure a private registry with appropriate security settings:</span></p>
<ul>
<li><span>SSL certificate</span></li>
<li><span>HTTP secret</span></li>
<li><span>HTTP basic authentication file</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a self-signed SSL certificate</h1>
                </header>
            
            <article>
                
<p><span>There is a pitfall—people tend to set up a plain HTTP (disable TLS) registry without authentication in the beginning.</span> Then it also needs to configure a Docker client <span>(Kubernetes node) to allow an insecure registry and so on. It is a bad practice that requires many steps to set up an insecure environment.</span></p>
<p><span>The best practice is always using the official SSL certificate that is issued by the certificate authority. However, a self-signed certificate is always handy, especially in the testing phase. An official certificate can wait until we have FQDN defined. Therefore, this recipe will show you how to use OpenSSL to create a</span><span> self-signed SSL certificate via the following steps:</span></p>
<ol>
<li>Create a <kbd>secrets</kbd> directory:</li>
</ol>
<pre style="padding-left: 90px">$ mkdir secrets</pre>
<ol start="2">
<li>Run the <kbd>openssl</kbd> command to specify the options to generate a certificate (<kbd>domain.crt</kbd>) and a private key (<kbd>domain.key</kbd>) under the <span class="packt_screen">secrets</span> directory. Note that you may type <kbd>.</kbd> to skip to input location and email info:</li>
</ol>
<pre style="padding-left: 90px">$ openssl req -newkey rsa:4096 -nodes -sha256 -keyout secrets/domain.key -x509 -days 365 -out secrets/domain.crt<br/>Generating a 4096 bit RSA private key<br/>.............................................++<br/>...........................................................++<br/>writing new private key to 'secrets/domain.key'<br/>-----<br/>You are about to be asked to enter information that will be incorporated<br/>into your certificate request.<br/>What you are about to enter is what is called a Distinguished Name or a DN.<br/>There are quite a few fields but you can leave some blank<br/>For some fields there will be a default value,<br/>If you enter '.', the field will be left blank.<br/>-----<br/>Country Name (2 letter code) []:us<br/>State or Province Name (full name) []:California<br/>Locality Name (eg, city) []:Cupertino<br/>Organization Name (eg, company) []:packtpub<br/>Organizational Unit Name (eg, section) []:chapter5<br/>Common Name (eg, fully qualified host name) []:.<br/>Email Address []:.</pre>
<ol start="3">
<li>Check whether both certificate and private keys are generated under the <kbd>secrets</kbd> directory:</li>
</ol>
<pre style="padding-left: 90px">$ ls secrets/<br/>domain.crt domain.key</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating HTTP secret</h1>
                </header>
            
            <article>
                
<p><span>Regarding HTTP secret, it will be randomly generated by the private registry instance upon startup by default. However, it is a problem if you run multiple pods, because each pod may have a different HTTP secret</span> that occur an error when Docker client push or pull the image. So we explicitly state that all pods will use the same HTTP secret, via the following steps:</p>
<ol>
<li>Use the <kbd>openssl</kbd> command to create a <kbd>http.secret</kbd> file under the <kbd>secrets</kbd> directory:</li>
</ol>
<pre style="padding-left: 90px">//create 8 byte random HEX string by OpenSSL <br/>$ openssl rand -hex -out secrets/http.secret 8</pre>
<ol start="2">
<li class="mce-root">Check the <kbd>secrets</kbd> directory, which has three files now:</li>
</ol>
<pre style="padding-left: 90px">$ ls secrets/<br/>domain.crt domain.key http.secret</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the HTTP basic authentication file</h1>
                </header>
            
            <article>
                
<p>Finally, regarding the HTTP basic authentication file, if you set up a private registry, authentication is needed when you interact with the Docker registry. You'll have to do <kbd>docker login</kbd> to get a token when pushing and pulling images. In order to create an HTTP basic authentication file, use the <kbd>htpasswd</kbd> command that is provided by Apache2 as this is easiest. Let's create a HTTP basic authentication file via the following steps:</p>
<ol start="1">
<li>Run Docker with Apache2 Docker image (<kbd>httpd</kbd>) to run the <kbd>htpasswd</kbd> command with the <kbd>bcrypt</kbd> (<kbd>-B</kbd>) option and generate a basic authentication file (<kbd>registry_passwd</kbd>) under the <kbd>secrets</kbd> directory:</li>
</ol>
<pre style="padding-left: 90px"><span>//set user=user01, passwd=my-super-secure-password<br/>$ docker run -i httpd /bin/bash -c 'echo my-super-secure-password | /usr/local/apache2/bin/htpasswd -nBi user01' &gt; secrets/registry_passwd<br/></span></pre>
<ol start="2">
<li>Check the <kbd>secrets</kbd> directory so that now you have four files:</li>
</ol>
<pre style="padding-left: 90px"><span>$ ls secrets/<br/></span><span>domain.crt<span class="Apple-tab-span"> </span>domain.key<span class="Apple-tab-span"> </span>http.secret<span class="Apple-tab-span"> </span>registry_passwd</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Kubernetes secret to store security files</h1>
                </header>
            
            <article>
                
<p>There are four files. We use <strong>Kubernetes Secret</strong> so that all pods can access it via an environment variable or mount a volume and access as a file. For more details about secrets, please refer to the <em>Working with secrets</em> section in <a href="e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml" target="_blank">Chapter 2</a>, <em><span>Walking through Kubernetes Concepts</span></em>. You can use the <kbd>kubectl</kbd> command to load these four files to store to the Kubernetes secret via the following steps:</p>
<ol>
<li>Run the <kbd>kubectl create</kbd> command with the <kbd>--from-file</kbd> parameter to specify the secrets directory:</li>
</ol>
<pre style="padding-left: 90px">$ kubectl create secret generic registry-secrets --from-file secrets/<br/>secret "registry-secrets" created</pre>
<ol start="2">
<li>Check the status via the <kbd>kubectl describe</kbd> command:</li>
</ol>
<pre style="padding-left: 90px"><span>$ kubectl describe secret registry-secrets<br/></span><span>Name:         registry-secrets<br/></span><span>Namespace:    default<br/></span><span>Labels:       &lt;none&gt;<br/></span><span>Annotations:  &lt;none&gt;<br/></span><span>Type:  Opaque<br/></span><span>Data<br/></span><span>====<br/></span><span>domain.key:       3243 bytes<br/></span><span>http.secret:      17 bytes<br/></span><span>registry_passwd:  69 bytes<br/></span><span>domain.crt:       1899 bytes</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a private registry to load a Kubernetes secret</h1>
                </header>
            
            <article>
                
<p><span>On the other hand, the private registry itself supports reading the HTTP secret as an environment variable in string format. It also can support specifying the file path for the SSL certificate and</span> HTTP basic authentication file as environment variables:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Environment variable name</strong></td>
<td><strong>Description</strong></td>
<td><strong>Sample value</strong></td>
</tr>
<tr>
<td><kbd>REGISTRY_HTTP_SECRET</kbd></td>
<td>HTTP secret string</td>
<td>
<p><span><kbd>valueFrom</kbd>:</span></p>
<p><span>    <kbd>secretKeyRef:</kbd></span></p>
<p><kbd><span>        name: registry-secrets</span></kbd></p>
<p><kbd><span>        key: http.secret</span></kbd></p>
</td>
</tr>
<tr>
<td><kbd>REGISTRY_HTTP_TLS_CERTIFICATE</kbd></td>
<td>File path for certificate  (<kbd>domain.crt</kbd>)</td>
<td><kbd>/mnt/domain.crt</kbd></td>
</tr>
<tr>
<td><kbd>REGISTRY_HTTP_TLS_KEY</kbd></td>
<td>File path for private key (<kbd>domain.key</kbd>)</td>
<td><kbd>/mnt/domain.key</kbd></td>
</tr>
<tr>
<td><kbd>REGISTRY_AUTH_HTPASSWD_REALM</kbd></td>
<td>The realm in which the registry server authenticates</td>
<td><kbd><span>basic-realm</span></kbd></td>
</tr>
<tr>
<td><kbd>REGISTRY_AUTH_HTPASSWD_PATH</kbd></td>
<td>File path for <kbd>htpasswd</kbd> file (<kbd>registry_passwd</kbd>)</td>
<td><kbd><span>/mnt/registry_passwd</span></kbd></td>
</tr>
<tr>
<td><kbd>REGISTRY_HTTP_HOST</kbd></td>
<td>Specify one of Kubernetes node IP and <kbd>nodePort</kbd></td>
<td><kbd>10.138.0.3:30500</kbd></td>
</tr>
</tbody>
</table>
<div class="packt_tip">Ideally, you should have a load balancer and set up a Kubernetes Service type as <kbd>LoadBalancer</kbd>. And then <kbd>REGISTRY_HTTP_HOST</kbd> could be the load balancer IP and port number. For simplicity, we'll just use <kbd>NodePort</kbd> in this recipe. For more information about <kbd>LoadBalancer</kbd>, refer to the <em>Working with services</em> section in <a href="e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml" target="_blank">Chapter 2</a>, <span><em>Walking through Kubernetes Concepts</em>,</span> and the <em>Forwarding container ports</em> section in <a href="51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml" target="_blank">Chapter 3</a>, <em><span>Playing with Containers</span></em>.</div>
<p><span>We'll conduct a</span> deployment <span>to a Kubernetes YAML file for creating a registry, and include the preceding variables inside it, so the registry pods can use them. </span><span>Now we have <kbd>PersistentVolumeClaim</kbd> as</span> <kbd>pvc-1</kbd><span> that supplies the container image store, and mounts SSL certificate files (</span><kbd>domain.crt</kbd> and <kbd>domain.key</kbd><span>) and an HTTP basic authentication file (<kbd>registry_passwd</kbd>) via Secret <kbd>registry-secrets</kbd>.</span> <span>As well as reading the HTTP Secret string as an environment variable by Secret <kbd>registry-secrets</kbd>.  The entire YAML configuration is as follows:</span></p>
<pre><span>$ cat private_registry.yaml <br/></span><span>apiVersion: apps/v1<br/></span><span>kind: Deployment<br/></span><span>metadata:<br/></span><span>  name: my-private-registry<br/></span><span>spec:<br/></span><span>  replicas: 1<br/></span><span>  selector:<br/></span><span>    matchLabels:<br/></span><span>      run: my-registry<br/></span><span>  template:<br/></span><span>    metadata:<br/></span><span>      labels:<br/></span><span>        run: my-registry<br/></span><span>    spec:<br/></span><span>      containers:<br/></span><span>      - name: my-registry<br/></span><span>        image: registry<br/></span><span>        env:<br/></span><span>          - name: REGISTRY_HTTP_HOST<br/></span><span>            value: 10.138.0.3:30500<br/></span><span>          - name: REGISTRY_HTTP_SECRET<br/></span><span>            valueFrom:<br/></span><span>               secretKeyRef:<br/></span><span>                 name: registry-secrets<br/></span><span>                 key: http.secret<br/></span><span>          - name: REGISTRY_HTTP_TLS_CERTIFICATE<br/></span><span>            value: /mnt/domain.crt<br/></span><span>          - name: REGISTRY_HTTP_TLS_KEY<br/></span><span>            value: /mnt/domain.key<br/></span><span>          - name: REGISTRY_AUTH_HTPASSWD_REALM<br/></span><span>            value: basic-realm<br/></span><span>          - name: REGISTRY_AUTH_HTPASSWD_PATH<br/></span><span>            value: /mnt/registry_passwd<br/></span><span>        ports:<br/></span><span>          - containerPort: 5000<br/></span><span>        volumeMounts:<br/></span><span>          - mountPath: /var/lib/registry<br/></span><span>            name: registry-storage<br/></span><span>          - mountPath: /mnt<br/></span><span>            name: certs<br/></span><span>      volumes:<br/></span><span>      - name: registry-storage<br/></span><span>        persistentVolumeClaim:<br/></span><span>          claimName: "pvc-1"<br/></span><span>      - name: certs<br/></span><span>        secret:<br/></span><span>           secretName: registry-secrets<br/></span><span>           items:<br/></span><span>           - key: domain.key<br/></span><span>             path: domain.key<br/></span><span>           - key: domain.crt<br/></span><span>             path: domain.crt<br/></span><span>           - key: registry_passwd<br/></span><span>             path: registry_passwd</span><span><br/></span><span>---<br/></span><span>apiVersion: v1<br/></span><span>kind: Service<br/></span><span>metadata:<br/></span><span>  name: private-registry-svc<br/></span><span>spec:<br/></span><span>  ports:<br/></span><span>    - protocol: TCP<br/></span><span>      port: 5000<br/></span><span>      nodePort: 30500<br/></span><span>  type: NodePort<br/></span><span>  selector:<br/></span><span>     run: my-registry<br/><br/><br/></span><span>$ kubectl create -f private_registry.yaml <br/></span><span>deployment.apps "my-private-registry" created<br/></span><span>service "private-registry-svc" created</span><span> <br/><br/></span><span><br/>//can scale to multiple Pod (if you have RWX PV set)<br/></span><span>$ kubectl scale deploy my-private-registry --replicas=3<br/></span><span>deployment "my-private-registry" scaled<br/></span><span><br/><br/></span><span>$ kubectl get deploy<br/></span><span>NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/></span><span>my-private-registry   3         3         3            3           2m</span><span> </span></pre>
<p>Now your own private registry is ready to use!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create a repository on the AWS elastic container registry</h1>
                </header>
            
            <article>
                
<p>In order to push a container image to Amazon ECR, you need to create a repository beforehand. Unlike Docker hub or private registry, Amazon ECR doesn't create a repository <span>automatically when it is the first time to push the image</span>. Therefore, if you want to push three container images, you have to create three repositories in advance:</p>
<p>It is simple to type the <kbd>aws ecr create-repository</kbd> command to specify the repository name:</p>
<pre>$ aws ecr create-repository --repository-name my-nginx<br/>{<br/>    "repository": {<br/>        "registryId": "************", <br/>        "repositoryName": "my-nginx", <br/>        "repositoryArn": "arn:aws:ecr:us-east-1:************:repository/my-nginx", <br/>        "createdAt": 1516608220.0, <br/>        "repositoryUri": "<strong>************.dkr.ecr.us-east-1.amazonaws.com/my-nginx</strong>"<br/>    }<br/>}</pre>
<p>That's it! You need to remember the <kbd>repositoryUri</kbd> (in the previous case, <kbd>************.dkr.ecr.us-east-1.amazonaws.com/my-nginx</kbd>) that will be used as the private image URL.</p>
<div class="packt_infobox">The previous URL is masked as an ID as <kbd>************</kbd>. It is tied with your AWS account ID.</div>
<p>On the other hand, if you see something like the following error message, your IAM user doesn't have the permission of the <kbd>CreateRepository</kbd> operation. In this case, you need to attach an IAM policy from <span><kbd>AmazonEC2ContainerRegistryFullAccess</kbd>:</span></p>
<pre><span>$ aws ecr create-repository --repository-name chapter5<br/></span><span>An error occurred (AccessDeniedException) when calling the CreateRepository operation: User: arn:aws:iam::************:user/ecr-user is not authorized to perform: ecr:CreateRepository on resource: *</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining your repository URL on Google container registry</h1>
                </header>
            
            <article>
                
<p>In order to push a container image to Google container registry, there is an important consideration regarding the repository URL. First of all, there are several Google container registry region hosts available:</p>
<ul>
<li><kbd>gcr.io</kbd> (currently USA region)</li>
<li><kbd>us.gcr.io</kbd> (USA region)</li>
<li><kbd>eu.gcr.io</kbd> (Europe region)</li>
<li><kbd>asia.gcr.io</kbd> (Asia region)</li>
</ul>
<div class="packt_infobox">Note that these region hosts are network latency purpose, doesn't mean to restrict to a particular region. They are still accessible worldwide.</div>
<p>Second of all, while you tag the container image, you also need to specify your <kbd>project-id</kbd> on which you've enabled billing and API. Therefore, the entire repository URL could be:</p>
<pre>&lt;gcr region&gt;/&lt;project-id&gt;/&lt;image name&gt;:tag</pre>
<p><span>In my case, I used the region USA default, the project ID is </span><kbd>kubernetes-cookbook</kbd>, and the image name is <kbd>my-nginx</kbd>; therefore, my repository URL is:</p>
<pre>gcr.io/kubernetes-cookbook/my-nginx:latest</pre>
<p>Other than that, Google container registry is ready to use now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When you start to use private registry with Kubernetes, you must configure a credential properly. Amazon ECR and Google cloud registry need special consideration. Let's configure a credential for private registry, Amazon ECR and Google cloud registry.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Push and pull an image from your private registry</h1>
                </header>
            
            <article>
                
<p>Now you can push your container image to your private registry. Because we have set up an HTTP basic authentication, you need to do <kbd>docker login</kbd> first. Otherwise you get a <kbd>no basic auth credentials</kbd> error:</p>
<pre>//just tag nginx to your own private image<br/>$ docker tag nginx 10.138.0.3:30500/my-nginx<br/><br/>//will be failed when push without login information. using complete image name with private registry as prefix<br/>$ docker push 10.138.0.3:30500/my-nginx<br/>The push refers to a repository [10.138.0.3:30500/my-nginx]<br/>a103d141fc98: Preparing <br/>73e2bd445514: Preparing <br/>2ec5c0a4cb57: Preparing <br/><strong>no basic auth credentials</strong></pre>
<p>Therefore, you need <kbd>docker login</kbd> to specify the username and password, which you set onto the <kbd>registry_passwd</kbd> file:</p>
<pre>//docker login<br/>$ docker login 10.138.0.3:30500<br/>Username: user01<br/>Password: <br/>Login Succeeded<br/><br/>//successfully to push<br/>$ docker push 10.138.0.3:30500/my-nginx<br/>The push refers to a repository [10.138.0.3:30500/my-nginx]<br/>a103d141fc98: Pushed <br/>73e2bd445514: Pushed <br/>2ec5c0a4cb57: Pushed <br/>latest: digest: sha256:926b086e1234b6ae9a11589c4cece66b267890d24d1da388c96dd8795b2ffcfb size: 948</pre>
<p>On the other hand, as for pulling an image from a private registry, Kubernetes nodes also needs to have a credential for your private registry. But using the <kbd>docker login</kbd> command on every node is not realistic. Instead, Kubernetes supports storing this credential as a Kubernetes secret and each node will use <span>this credential while pulling an image</span>.</p>
<p>To do that, we need to create a <kbd>docker-registry</kbd> resource that needs to specify:</p>
<ul>
<li><kbd>--docker-server</kbd>: In this example, <kbd>10.138.0.3:30500</kbd></li>
<li><kbd>--docker-username</kbd>: In this example, <kbd>user01</kbd></li>
<li><kbd>--docker-password</kbd>: In this example, <kbd>my-super-secure-password</kbd></li>
<li><kbd>--docker-email</kbd>: Your email address</li>
</ul>
<pre><span>//create secret named "</span><span>my-private-credential"</span><span><br/>$ kubectl create secret docker-registry my-private-credential \<br/>&gt; --docker-server=10.138.0.3:30500 \<br/>&gt; --docker-username=user01 \<br/>&gt; --docker-password=my-super-secure-password \<br/>&gt; --docker-email=hideto.saito@example.com<br/></span><span>secret "my-private-credential" created<br/><br/>//successfully to created<br/></span><span>$ kubectl get secret my-private-credential<br/></span><span>NAME TYPE DATA AGE<br/></span><span>my-private-credential kubernetes.io/dockerconfigjson 1 18s</span></pre>
<p><span> </span>Finally, you can pull your private image from the private registry that is specifying the <kbd>my-private-credential</kbd> secret. To do that, set <kbd>spec.imagePullSecrets</kbd> as follows:</p>
<pre><span>$ cat private-nginx.yaml <br/></span><span>apiVersion: v1<br/></span><span>kind: Pod<br/></span><span>metadata:<br/></span><span>  name: private-nginx<br/></span><span>spec:<br/></span><span>  containers:<br/></span><span>  - name: private-nginx<br/></span><span>    image: <strong>10.138.0.3:30500/my-nginx</strong><br/></span><span>  imagePullSecrets:<br/></span><span>  - name: <strong>my-private-credential</strong><br/><br/></span><span>$ kubectl create -f private-nginx.yaml <br/></span><span>pod "private-nginx" created<br/></span><span><br/>//successfully to launch your Pod using private image<br/>$ kubectl get pods private-nginx<br/></span><span>NAME            READY     STATUS    RESTARTS   AGE<br/></span><span>private-nginx   1/1       Running   0          10s</span><span> </span></pre>
<p>Congratulations! Now you can feel free to push your private images to your private registry run by Kubernetes. Also, pull an image from Kubernetes too. At any time, you can scale out based on client traffic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Push and pull an image from Amazon ECR</h1>
                </header>
            
            <article>
                
<p>Amazon ECR has an authentication mechanism to <span>provide access to</span> your private repositories. AWS CLI has a functionality to generate an access token using the <kbd>aws ecr get-login</kbd> command:</p>
<pre><span>$ aws ecr get-login --no-include-email<br/></span></pre>
<p>It outputs the <kbd>docker login</kbd> command with the ID and password:</p>
<pre><span>docker login -u AWS -p eyJwYXlsb2FkIjoiNy(very long strings)... https://************.dkr.ecr.us-east-1.amazonaws.com</span></pre>
<p>Therefore, just copy and paste to your terminal to acquire a token from AWS. Then try <kbd>docker push</kbd> to upload your Docker image to ECR:</p>
<pre>$ docker tag nginx ************.dkr.ecr.us-east-1.amazonaws.com/my-nginx<br/><br/>$ docker push ************.dkr.ecr.us-east-1.amazonaws.com/my-nginx<br/>The push refers to repository [************.dkr.ecr.us-east-1.amazonaws.com/my-nginx]<br/>a103d141fc98: Pushed <br/>73e2bd445514: Pushing 8.783MB/53.23MB<br/>2ec5c0a4cb57: Pushing 4.333MB/55.26MB</pre>
<p>On the other hand, pulling an image from ECR to Kubernetes follows exactly the same steps as the private registry that uses a Kubernetes secret to store the token:</p>
<pre><span>$ kubectl create secret docker-registry my-ecr-secret \<br/>&gt; --docker-server=https://************.dkr.ecr.us-east-1.amazonaws.com \<br/>&gt; --docker-email=hideto.saito@example.com \<br/>&gt; --docker-username=AWS \<br/>&gt; --docker-password=eyJwYXlsb2FkIjoiS...<br/></span><span>secret "my-ecr-secret" created<br/><br/><br/></span><span>$ kubectl get secret my-ecr-secret<br/></span><span>NAME            TYPE                             DATA      AGE<br/></span><span>my-ecr-secret   kubernetes.io/dockerconfigjson   1         10s</span></pre>
<p>Now, <kbd>spec.imagePullSecrets</kbd> needs to specify <kbd>my-ecr-secret</kbd>. As well as the image URL, it also specifies the ECR repository:</p>
<pre><span>$ cat private-nginx-ecr.yaml <br/></span><span>apiVersion: v1<br/></span><span>kind: Pod<br/></span><span>metadata:<br/></span><span>  name: private-nginx-ecr<br/></span><span>spec:<br/></span><span>  containers:<br/></span><span>  - name: private-nginx-ecr<br/></span><span>    image: <strong>************.dkr.ecr.us-east-1.amazonaws.com/my-nginx</strong><br/></span><span>  imagePullSecrets:<br/></span><span>  - name: <strong>my-ecr-secret</strong><br/><br/><br/></span><span>$ kubectl create -f private-nginx-ecr.yaml <br/></span><span>pod "private-nginx-ecr" created<br/><br/><br/></span><span>$ kubectl get pods private-nginx-ecr<br/></span><span>NAME                READY     STATUS    RESTARTS   AGE<br/></span><span>private-nginx-ecr   1/1       Running   0          1m</span></pre>
<p>Note that this token is short-lived: it's valid up to 12 hours. So, 12 hours later, you need to run <kbd>aws ecr get-login</kbd> again to acquire a new token, then update the secret <kbd>my-ecr-secret</kbd>. It is absolutely not ideal to do this.</p>
<p>The good news is that Kubernetes supports the updating of the ECR token automatically via <kbd>CloudProvider</kbd>. However, it requires that your Kubernetes runs on an AWS environment such as EC2. In addition, the EC2 instance has to have an IAM role that is equivalent or higher than the <kbd>AmazonEC2ContainerRegistryReadOnly</kbd> policy. It will be described in <a href="b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml" target="_blank">Chapter 6</a>, <em>Building Kubernetes on AWS</em>.</p>
<p>If you really want to use your Kubernetes cluster outside of AWS by pulling an image from the ECR repository, there is a challenge in that you need to update the ECR token every 12 hours. Maybe you can do this using a cron job or by adopting some automation tools. </p>
<div class="packt_infobox">For more detail, please visit the AWS online document at <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html">https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Push and pull an image from Google cloud registry</h1>
                </header>
            
            <article>
                
<p><span>According to GCP documentation (</span><a href="https://cloud.google.com/container-registry/docs/advanced-authentication">https://cloud.google.com/container-registry/docs/advanced-authentication</a><span>), there are several way to push/pull to a container registry.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using gcloud to wrap the Docker command</h1>
                </header>
            
            <article>
                
<div>
<p>The <kbd>gcloud</kbd> command has a wrapper function to run a <kbd>docker</kbd> command to push and pull. For example, if you want to push the image <kbd>gcr.io/kubernetes-cookbook/my-nginx</kbd>, use the <kbd>gcloud</kbd> command:</p>
</div>
<div>
<pre>$ gcloud docker -- push gcr.io/kubernetes-cookbook/my-nginx </pre></div>
<div>
<p>It is sufficient to push the image from your machine, however, it is not ideal if you integrate with Kubernetes. This is because it is not easy to wrap the <kbd>gcloud</kbd> command on the Kubernetes node. </p>
</div>
<p>Fortunately, there is a solution that creates a GCP service account and grants a permission (role) to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the GCP service account to grant a long-lived credential</h1>
                </header>
            
            <article>
                
<p><span>We need to integrate to pull an image from the Kubernetes node, which requires a long-lived credential that can be stored to the Kubernetes secret. To do that, perform the following steps:</span></p>
<ol>
<li><span>Create a GCP service account (</span><kbd>container-sa</kbd><span>):</span></li>
</ol>
<div>
<pre style="padding-left: 90px">$ gcloud iam service-accounts create container-sa <br/><span>Created service account [container-sa]. <br/><br/></span><span>//full name is as below <br/></span><span>$ gcloud iam service-accounts list | grep container <br/></span><strong>container-sa@kubernetes-cookbook.iam.gserviceaccount.com</strong><span> </span></pre></div>
<div>
<ol start="2">
<li>Assign <kbd>container-sa</kbd> (use full name) to the <kbd>roles/storage.admin</kbd> role:</li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">$ gcloud projects add-iam-policy-binding kubernetes-cookbook \<br/>&gt; --member serviceAccount:container-sa@kubernetes-cookbook.iam.gserviceaccount.com \<br/>&gt; --role=roles/storage.admin </pre></div>
<ol start="3">
<li>
<p>Generate a key file (<kbd>container-sa.json</kbd>) for <kbd>container-sa</kbd>:</p>
</li>
</ol>
<div>
<pre style="padding-left: 90px">$ gcloud iam service-accounts keys create container-sa.json \<br/>&gt; --iam-account container-sa@kubernetes-cookbook.iam.gserviceaccount.com <br/><span><br/>created key [f60a81235a1ed9fbce881639f621470cb087149c] of type [json] as [container-sa.json] for [</span>container-sa@kubernetes-cookbook.iam.gserviceaccount.com<span>] </span></pre></div>
<div>
<ol start="4">
<li>Use <kbd>docker login</kbd> to check whether the key file is working or not:</li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">//note that username must be _json_key <br/><span>$ cat container-sa.json | docker login </span><span>--username <strong>_json_key </strong></span><span>--password-stdin gcr.io <br/></span><span>Login Succeeded</span></pre></div>
<div>
<ol start="5">
<li>Use <kbd>docker pull</kbd> to check whether you can pull from container registry or not:</li>
</ol>
</div>
<div>
<pre style="padding-left: 90px">$ docker pull gcr.io/kubernetes-cookbook/my-nginx <br/><span>Using default tag: latest <br/></span><span>latest: Pulling from kubernetes-cookbook/my-nginx <br/></span><span>e7bb522d92ff: Pulling fs layer  <br/></span><span>6edc05228666: Pulling fs layer  <br/>...</span><span> </span></pre></div>
<div>
<p style="padding-left: 60px"><span>Looks all fine! Now you can use the Kubernetes secret the exact same way with the private registry or AWS ECR. </span></p>
<ol start="6">
<li>Create a Kubernetes secret (<kbd>my-gcr-secret</kbd>) to specify <kbd>_json_key</kbd> and <kbd>container-sa.json</kbd>:</li>
</ol>
<pre style="padding-left: 90px"><span>$ kubectl create secret docker-registry my-gcr-secret \<br/></span><span>&gt; --docker-server=gcr.io \<br/></span><span>&gt; --docker-username=_json_key \<br/></span><span>&gt; --docker-password=`cat container-sa.json` \<br/></span><span>&gt; --docker-email=hideto.saito@example.com<br/></span><span>secret "my-gcr-secret" created</span></pre></div>
<ol start="7">
<li>Specify <kbd>my-gcr-secret</kbd> to <kbd>imagePullSecrets</kbd> <span>to launch a pod:</span></li>
</ol>
<pre style="padding-left: 90px"><span>$ cat private-nginx-gcr.yaml <br/></span><span>apiVersion: v1<br/></span><span>kind: Pod<br/></span><span>metadata:<br/></span><span>  name: private-nginx-gcr<br/></span><span>spec:<br/></span><span>  containers:<br/></span><span>  - name: private-nginx-gcr<br/></span><span>    image: <strong>gcr.io/kubernetes-cookbook/my-nginx</strong><br/></span><span>  imagePullSecrets:<br/></span><span>  - name: <strong>my-gcr-secret</strong><br/></span><span><br/><br/>$ kubectl create -f private-nginx-gcr.yaml <br/></span><span>pod "private-nginx-gcr" created<br/><br/><br/></span><span>$ kubectl get pods<br/></span><span>NAME                READY     STATUS    RESTARTS   AGE<br/></span><span>private-nginx-gcr   1/1       Running   0          47s</span></pre>
<p>Congratulations! Now you can use Google container registry for your private registry that is fully managed by GCP. And Kubernetes can pull your private image from there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating with Jenkins</h1>
                </header>
            
            <article>
                
<p><span>In software engineering,</span> <strong>c<span>ontinuous integration</span></strong> <span>(</span><strong><span>CI</span></strong><span>) (</span><a href="https://en.wikipedia.org/wiki/Continuous_integration"><span>https://en.wikipedia.org/wiki/Continuous_integration</span></a><span>) and</span> <strong>c<span>ontinuous delivery</span></strong> <span>(</span><strong><span>CD</span></strong><span>) (</span><a href="https://en.wikipedia.org/wiki/Continuous_delivery"><span>https://en.wikipedia.org/wiki/Continuous_delivery</span></a><span>), abbreviated as CI/CD, have the ability to simplify the procedure of the traditional development process with continuous developing, testing, and delivering mechanisms in order to reduce the</span> <span>panic of serious conflict, namely, to deliver small changes one at a time and to narrow down the problems</span> <span>immediately, if any. Furthermore, through automatic tools, a product delivered</span> by<span> the CI/CD system can achieve better efficiency and shorten time-to-market.</span></p>
<p><span>Jenkins</span> <span>is one of the well-known CI systems, which can be configured as a continuous delivery system. Jenkins can pull your project codes from the source code control system, run the tests, and then deploy based on your configuration. In this recipe, we will show you how to integrate Jenkins to Kubernetes to achieve continuous delivery.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Before you start this recipe, prepare a Docker hub account (</span><a href="https://hub.docker.com"><span>https://hub.docker.com</span></a><span>) or you may use your private registry that is described in the previous section. But the important part is you must have a credential to pull and push to the registry. If you use Docker hub, make sure <kbd>docker login</kbd> with your credentials works.</span></p>
<p><span>Next, make sure your Kubernetes is ready. But we will use</span> RBAC <span>authentication for access from the Jenkins pod to the Kubernetes master API. If you use <kbd>minikube</kbd>, you need to add the <kbd>--extra-config=apiserver.Authorization.Mode=RBAC</kbd> option when starting a minikube:</span></p>
<pre><span>//enable RBAC and allocate 8G memory<br/>$ minikube start --memory=8192 <strong>--extra-config=apiserver.Authorization.Mode=RBAC</strong></span></pre>
<p><span>Then, you can set up your own Jenkins server through Kubernetes as well; the details are in this section.</span></p>
<div class="packt_tip">Some minikube versions have a <kbd>kube-dns</kbd> issue that can't resolve the external domain name, such as <a href="https://github.com/">https://github.com/</a> and <a href="https://jenkins.io/">https://jenkins.io/</a>, that can't process this recipe. Replacing the <kbd>kube-dns</kbd> add-on with the <kbd>coredns</kbd> add-on could resolve the issue after launching <kbd>minikube</kbd> with the following command:<br/>
<br/>
<kbd>$ minikube addons disable kube-dns</kbd><br/>
<kbd>$ minikube addons enable coredns</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>There are two important parts to go through in the Jenkins setup:</p>
<ol>
<li>Jenkins needs to run a <kbd>docker</kbd> command to build your application to compose your container image</li>
<li>Jenkins need to communicate with the Kubernetes master to control deployment</li>
</ol>
<p class="mce-root">To achieve step 1, there is a tricky part that needs something like a <strong>Docker-in-Docker</strong> (<strong>dind</strong>). This is because Jenkins is run by Kubernetes as a pod (Docker container), and Jenkins also needs to invoke a <kbd>docker</kbd> command to build your application. It can be achieved by mounting <kbd>/var/run/docker.sock</kbd> from the Kubernetes node to the Jenkins pod that can communicate <span>with Jenkins, the Kubernetes node, and the Docker daemon</span>.</p>
<div class="column packt_infobox">Docker-in-Docker and mounting <kbd>/var/run/docker.sock</kbd> have been described at <a href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/">https://blog.docker.com/2013/09/docker-can-now-run-within-docker/</a> and <a href="http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/.</a></div>
<p class="mce-root"><span>In order to achieve step 2, we will set up a Kubernetes service account and assign one <kbd>ClusterRole</kbd> so that the Jenkins service account can have a necessary privilege.</span></p>
<p><span>Let's do it step by step.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a custom Jenkins image</h1>
                </header>
            
            <article>
                
<p>Run Jenkins by Kubernetes, we use an official image (<a href="https://hub.docker.com/u/jenkins/">https://hub.docker.com/u/jenkins/</a>) but customize it to install the following applications on it:</p>
<ul>
<li>Docker CE</li>
<li>kubectl binary</li>
<li>Jenkins Docker plugin</li>
</ul>
<p>To do that, prepare <kbd>Dockerfile </kbd>to maintain your own Jenkins image:</p>
<pre><span>$ cat Dockerfile<br/></span><span>FROM jenkins/jenkins:lts<br/></span><span><br/></span><span>EXPOSE 8080 50000<br/><br/></span><span># install Docker CE for Debian : https://docs.docker.com/engine/installation/linux/docker-ce/debian/<br/></span><span>USER root<br/></span><span>RUN apt-get update<br/></span><span>RUN apt-get install -y sudo apt-transport-https ca-certificates curl gnupg2 software-properties-common<br/></span><span>RUN curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | apt-key add -<br/></span><span>RUN add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") $(lsb_release -cs) stable"<br/></span><span>RUN apt-get update &amp;&amp; apt-get install -y docker-ce<br/><br/></span><span># install kubectl binary<br/></span><span>RUN curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.9.2/bin/linux/amd64/kubectl<br/></span><span>RUN chmod +x ./kubectl<br/></span><span>RUN mv ./kubectl /usr/local/bin/kubectl<br/><br/></span><span># setup Jenkins plubins : https://github.com/jenkinsci/docker#script-usage<br/></span><span>RUN /usr/local/bin/install-plugins.sh docker<br/></span></pre>
<p>Use <kbd>docker build</kbd> to build your Jenkins image and then  <kbd>docker push</kbd> command to upload to your own <span>registry</span> in Docker hub, as shown:</p>
<pre><span>//build your own Jenkins image<br/></span><span>$ docker build -t &lt;your-docker-hub-account&gt;/my-jenkins .<br/></span><span><br/>//push to Docker Hub<br/></span><span>$ docker push &lt;your-docker-hub-account&gt;/my-jenkins</span></pre>
<p><span> </span>Or, alternatively, you could upload that to your private registry or any other cloud-provided registry.</p>
<p>Hurray! We have our build system image ready now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Kubernetes service account and ClusterRole</h1>
                </header>
            
            <article>
                
<p>Imagine that after using Jenkins successfully to build your application container, you then use <kbd>kubectl</kbd> to update deployment to roll out a new binary. To do that, invoke a <kbd>kubectl</kbd> command from the inside of a Jenkins pod. In this scenario, we need a credential to communicate to the Kubernetes master.</p>
<p>Fortunately, Kubernetes supports this kind of scenario, which uses a service account. It is described in detail in <a href="d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml" target="_blank">Chapter 8</a>, <em>Advanced Cluster Administration</em>. So, this recipe will use the simplest way, which uses the <kbd>default</kbd> namespace and <kbd>cluster-admin ClusterRole</kbd>.</p>
<p>To check whether RBAC is enabled and also if the <kbd>cluster-admin ClusterRole</kbd> exists or not, type the <kbd>kubectl get clusterrole</kbd> command:</p>
<pre><span>$ kubectl get clusterrole cluster-admin<br/></span><span>NAME            AGE<br/></span><span>cluster-admin   42m</span></pre>
<p> Next, create a service account, <kbd>jenkins-sa</kbd>, which will be used by a Jenkins pod. Prepare the following YAML configuration, and type the <kbd>kubectl create</kbd> command to create it:</p>
<pre><span>$ cat jenkins-serviceaccount.yaml <br/></span><span>apiVersion: v1<br/></span><span>kind: ServiceAccount<br/></span><span>metadata:<br/></span><span>  name: jenkins-sa<br/></span><span>  namespace: default<br/><br/><br/></span><span>$ kubectl create -f jenkins-serviceaccount.yaml <br/></span><span>serviceaccount "jenkins-sa" created</span><span> </span></pre>
<p>Now we can associate the <kbd>jenkins-sa</kbd> service account with a <kbd>cluster-admin</kbd> <kbd>ClusterRole</kbd>. Prepare a <kbd>ClusterRoleBinding</kbd> configuration and run the <kbd>kubectl create</kbd> command:</p>
<pre><span>$ cat jenkins-cluteradmin.yaml <br/></span><span>apiVersion: rbac.authorization.k8s.io/v1<br/></span><span>kind: ClusterRoleBinding<br/></span><span>metadata:<br/></span><span>  name: jenkins-cluster-admin<br/></span><span>roleRef:<br/></span><span>  apiGroup: rbac.authorization.k8s.io<br/></span><span>  kind: ClusterRole<br/></span><span>  name: cluster-admin<br/></span><span>subjects:<br/></span><span>- kind: ServiceAccount<br/></span><span>  name: jenkins-sa<br/></span><span>  namespace: default<br/><br/><br/></span><span>$ kubectl create -f jenkins-cluster-admin.yaml <br/></span><span>clusterrolebinding.rbac.authorization.k8s.io "jenkins-cluster-admin" created</span><span> </span></pre>
<p>In the result, if a pod is launched with the service account <kbd>jenkins-sa</kbd>, this Pod has the privilege to control a Kubernetes cluster because of the <kbd>cluster-admin ClusterRole</kbd>.</p>
<div class="packt_tip">It should create a custom <kbd>ClusterRole</kbd> that has minimal privilege for Jenkins usage. But this recipe is to focus on the Jenkins setup itself. If you want to create a custom <kbd>ClusterRole</kbd>, please go to <a href="d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml" target="_blank">Chapter 8</a>, <em>Advanced Cluster Administration</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching the Jenkins server via Kubernetes deployment</h1>
                </header>
            
            <article>
                
<p>Based on the previous recipes, now you have:</p>
<ul>
<li>A custom Jenkins container image</li>
<li>A service account</li>
</ul>
<p>Finally, you can launch your custom Jenkins server on your Kubernetes cluster. Remember that we need to run a <kbd>docker</kbd> command in the Docker environment, which needs to mount <kbd>/var/run/docker.sock</kbd> from the local Kubernetes node.</p>
<p>In addition, we need to use a <kbd>jenkins-sa </kbd>service account to launch a Jenkins pod. It needs to specify <kbd>spec.template.spec.serviceAccountName: jenkins-sa</kbd> in the deployment configuration.</p>
<p>It is also recommended to have a <kbd>PersistentVolume</kbd> to preserve Jenkins home (<kbd>/var/jenkins_home</kbd>), in case a pod is restarted. We just simply use the <kbd>hostPath /data/jenkins-data</kbd> directory (assuming you use minikube). You may change to another path or other types of <kbd>PersistentVolume</kbd> to fit with your environment.</p>
<p>Overall, the deployments YAML configuration for Jenkins is as follows:</p>
<pre><span>$ cat jenkins.yaml <br/></span><span>apiVersion: apps/v1<br/></span><span>kind: Deployment<br/></span><span>...<br/></span><span>    spec:<br/></span><span>      <strong>serviceAccountName: jenkins-sa</strong><br/></span><span>      containers:<br/></span><span>      - name: my-jenkins<br/></span><span>        image: <strong>hidetosaito/my-jenkins<br/></strong></span><span>        readinessProbe:<br/></span><span>          initialDelaySeconds: 40<br/></span><span>          tcpSocket:<br/></span><span>            port: 8080</span><span><br/></span><span>        volumeMounts: <br/></span><span>        - mountPath: <strong>/var/run/docker.sock</strong><br/></span><span>          name: docker-sock <br/>        - mountPath: <strong>/var/jenkins_home</strong><br/>          name: jenkins-data<br/></span><span>      volumes: <br/></span><span>      - name: docker-sock<br/></span><span>        hostPath: <br/></span><span>          path: <strong>/var/run/docker.sock<br/></strong></span><span>      - name: jenkins-data<br/>        hostPath:<br/>          path: /data/jenkins-data<br/></span><span>...<br/><br/><br/></span><span>$ kubectl create -f jenkins.yaml </span><span><br/></span><span>deployment.apps "my-jenkins" created<br/></span><span>service "my-jenkins-service" created</span></pre>
<p>After a few minutes, Kubernetes pulls your custom Jenkins image and runs a Jenkins pod which is capable of running a <kbd>docker</kbd> command and a <kbd>kubectl</kbd> command without any configuration due to mounting the <kbd>/var/run/docker.sock</kbd> and <kbd>jenkins-sa</kbd> service account: </p>
<pre><span>//check Jenkins Pod status<br/>$ kubectl get pods<br/></span><span>NAME                          READY     STATUS    RESTARTS   AGE<br/></span><span>my-jenkins-758b89849c-t2sm9   1/1       Running   0          17m<br/><br/><br/>//access to Jenkins Pod<br/></span><span>$ kubectl exec -it my-jenkins-758b89849c-t2sm9 -- /bin/bash<br/></span><span><br/><br/></span><span>//within Jenkins Pod, you can run docker command<br/></span><span>root@my-jenkins-758b89849c-t2sm9:/# docker pull nginx<br/></span><span>Using default tag: latest<br/></span><span>latest: Pulling from library/nginx<br/></span><span>e7bb522d92ff: Pull complete <br/></span><span>6edc05228666: Pull complete <br/></span><span>cd866a17e81f: Pull complete <br/></span><span>Digest: sha256:926b086e1234b6ae9a11589c4cece66b267890d24d1da388c96dd8795b2ffcfb<br/></span><span>Status: Downloaded newer image for nginx:latest</span><span> <br/></span><span><br/><br/></span><span>//within Jenkins Pod, you can run kubectl command<br/>root@my-jenkins-758b89849c-t2sm9:/# kubectl get nodes<br/></span><span>NAME                                      STATUS    ROLES     AGE       VERSION<br/></span><span>gke-chapter5-default-pool-97f6cad9-19vm   Ready     &lt;none&gt;    1h        v1.8.6-gke.0<br/></span><span>gke-chapter5-default-pool-97f6cad9-1qxc   Ready     &lt;none&gt;    1h        v1.8.6-gke.0<br/></span><span>gke-chapter5-default-pool-97f6cad9-cglm   Ready     &lt;none&gt;    1h        v1.8.6-gke.0<br/><br/><br/></span><span>//go back to your terminal<br/>root@my-jenkins-758b89849c-t2sm9:/# exit<br/></span><span>exit</span><span> </span></pre>
<p>You are all set! Now you can configure a Jenkins job to build your application, build a container, and deploy to Kubernetes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Now we start to configure Jenkins to build your application. However, to access the WebUI of your custom Jenkins, you need to access the Kubernetes service that binds to your Jenkins pod. It is easier to use <kbd>kubectl port-forward</kbd> to access remotely to configure Jenkins:</p>
<pre><span>//check pod name<br/>$ kubectl get pods<br/></span><span>NAME                         READY     STATUS    RESTARTS   AGE<br/></span><span>my-jenkins-cbdd6446d-ttxj5   1/1       Running   0          1m<br/><br/>//port forward from your machine :58080 to Jenkins :8080<br/></span><span>$ kubectl port-forward my-jenkins-cbdd6446d-ttxj5 58080:8080<br/></span><span>Forwarding from 127.0.0.1:58080 -&gt; 8080</span></pre>
<p>The initial configuration of Jenkins is done via the following steps:</p>
<ol>
<li>Access the <kbd>http://127.0.0.1:58080</kbd> Jenkins WebUI; it asks you to input <kbd>initialAdminPassword</kbd>.</li>
<li>U<span>se <kbd>kubectl exec</kbd> to acquire the</span> <kbd>initialAdminPassword</kbd><span>. Then copy and paste to the Jenkins WebUI to proceed with the initial configuration to install the suggested plugin and create an admin user:</span></li>
</ol>
<pre style="padding-left: 90px"><span>$ kubectl get pods<br/></span><span>NAME                         READY     STATUS    RESTARTS   AGE<br/></span><span>my-jenkins-cbdd6446d-ttxj5   1/1       Running   0          1m<br/><br/></span><span>//now you see initialAdminPassword<br/>$ kubectl exec my-jenkins-cbdd6446d-ttxj5 -- /bin/bash -c 'cat /var/jenkins_home/secrets/initialAdminPassword'<br/></span><strong>47e236f0bf334f838c33f80aac206c22</strong></pre>
<ol start="3">
<li>You will see a Jenkins top page. Then click <span class="packt_screen">Manage Jenkins</span>, then <span class="packt_screen">Configure System</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-348 image-border" src="assets/7ba133a9-48d4-4227-a747-9eeeb386699e.png" style="width:164.67em;height:40.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Navigate to Jenkins configuration</span></div>
<ol start="4">
<li>Scroll to the bottom and find a <span class="packt_screen">Cloud</span> section. Click <span class="packt_screen">Add a new cloud</span> to select <span class="packt_screen">Docker</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-354 image-border" src="assets/7ee5f4ab-dbfb-4e9c-a3ad-cf7b4f5c1ef2.png" style="width:141.75em;height:39.08em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Adding a Docker setting</div>
<ol start="5">
<li>Put <span class="packt_screen">Name</span> as your desired name (<span>example</span>: <kbd>my-docker</kbd>) and specify the <span class="packt_screen">Docker Host URI</span> and Docker domain socket as <kbd>unix:///var/run/docker.sock</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-352 image-border" src="assets/53073463-06d0-4b8c-8e2e-7f27070df8c2.png" style="width:152.08em;height:47.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Configure Docker on Jenkins</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Jenkins to build a Docker image</h1>
                </header>
            
            <article>
                
<p>Let's configure a Jenkins job to build a sample microservice application, which was introduced in the previous recipe (<kbd>my-calc</kbd>). Perform the following steps to configure and build a Docker image:</p>
<ol>
<li>On the left navigation, click <span class="packt_screen">New Item</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-353 image-border" src="assets/7eafbe4f-c882-454c-8ff4-994766bc6922.png" style="width:166.58em;height:35.08em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Navigating to create a new item</span></div>
<ol start="2">
<li>Put your in desired item name (example: <kbd>my-calc</kbd>), select <span class="packt_screen">Freestyle project</span>, then click <span class="packt_screen">OK</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-356 image-border" src="assets/911c131b-08a8-48e4-a814-5971bd062314.png" style="width:166.58em;height:100.92em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Creating a new Jenkins Job</span></div>
<ol start="3">
<li>In the <span class="packt_screen"><span class="packt_screen"><span class="packt_screen">Source</span></span> Code Management</span> tab, select <span class="packt_screen">Git</span> and set the <span class="packt_screen">Repository URL</span> as <a href="https://github.com/kubernetes-cookbook/my-calc.git">https://github.com/kubernetes-cookbook/my-calc.git</a>, or you may use your own repository which has a <kbd>Dockerfile</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-357 image-border" src="assets/a9dbdb04-69e8-428c-98ee-6e5682bab7c7.png" style="width:147.33em;height:54.83em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Source Code Management settings</span></div>
<ol start="4">
<li>On the <span class="packt_screen">Build Environment</span> tab, click <span class="packt_screen">Add build step</span> to add <span class="packt_screen">Build / Publish Docker Image</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-358 image-border" src="assets/680b49b0-db5f-4d42-95fe-77730fdef7ad.png" style="width:166.58em;height:65.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Build Environment settings</div>
<ol start="5">
<li>In the <span class="packt_screen">Build / Publish Docker Image</span> panel:
<ol>
<li>Directory for <kbd>Dockerfile</kbd> as current (<kbd>.</kbd>)</li>
<li>Choose <span class="packt_screen">my-docker</span> in the <span class="packt_screen">Cloud</span> that we've set up</li>
<li>Put image as your Docker repository, but append <kbd>:${BUILD_NUMBER}</kbd> (example: <kbd>hidetosaito/my-calc:${BUILD_NUMBER}</kbd>)</li>
<li>Enable <span class="packt_screen">Push image</span></li>
<li>Click <span class="packt_screen">Add</span> to add your Docker hub ID credential</li>
<li>Then, click <span class="packt_screen">Save</span>:</li>
</ol>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-359 image-border" src="assets/ba62d487-3f1e-44b8-ab7e-f6aa82789d55.png" style="width:166.58em;height:100.92em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Docker build/publish settings</div>
<ol start="6">
<li>Finally, you can click <span class="packt_screen">Build Now</span> to trigger a build; for testing purposes you can click five times to see how it works:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-360 image-border" src="assets/fcf5a03d-8960-48c0-91f2-20dc0cec5646.png" style="width:166.58em;height:52.17em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Trigger a build</div>
<ol start="7">
<li>Note that you can see a <span class="packt_screen">Console</span> that knows it performs a Docker build and push:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-361 image-border" src="assets/b4447718-f02a-4986-8ed3-6588a887ebc0.png" style="width:159.33em;height:101.17em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Showing a build log</div>
<ol start="8">
<li>Access your Docker hub repository; it has been pushed five times (because of clicking on <span class="packt_screen">build</span> five times):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-362 image-border" src="assets/277bd7dc-f403-4ab2-a8b6-8fd847de4e6a.png" style="width:166.58em;height:85.83em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Docker hub repository</div>
<p>That's it! You can achieve continuous integration to build a Docker image so that when you update a source in GitHub, you can continuously build and push the latest image to your Docker hub repository by Jenkins.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the latest container image to Kubernetes</h1>
                </header>
            
            <article>
                
<p>After each build, Jenkins <span>keeps pushing</span> your container image on your Docker hub repository at the end of the CI process. Next, update the Jenkins job configuration to use the latest image to deploy to Kubernetes, via the following steps:</p>
<ol>
<li>The first time, we pre-deploy microservice application manually via <kbd>kubectl deploy --record</kbd>. Note that you may change <kbd>spec.template.spec.containers.image: hidetosaito/my-calc</kbd> to your repository:</li>
</ol>
<pre style="padding-left: 90px"><span>$ cat my-calc.yaml <br/></span><span>apiVersion: apps/v1<br/></span><span>kind: Deployment<br/></span><span>metadata:<br/></span><span>  name: <strong>my-calc-deploy</strong><br/></span><span>spec:<br/></span><span>  replicas: 2<br/></span><span>  selector:<br/></span><span>    matchLabels:<br/></span><span>      run: my-calc<br/></span><span>  template:<br/></span><span>    metadata:<br/></span><span>      labels:<br/></span><span>        run: my-calc<br/></span><span>    spec:<br/></span><span>      containers:<br/></span><span>      - name: <strong>my-calc</strong><br/></span><span>        image: <strong>hidetosaito/my-calc</strong><br/><br/><br/>//use --record to trace the history<br/></span><span>$ kubectl create -f my-calc-deploy.yaml --record<br/></span><span>deployment.apps "my-calc-deploy" created</span></pre>
<ol start="2">
<li>Open Jenkins Job configuration; on the <span class="packt_screen">Build</span> tab, right after the <span class="packt_screen">Docker build settings</span>, click <span class="packt_screen">Add build step</span> and choose <span class="packt_screen">Execute shell</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-363 image-border" src="assets/c473e1c8-40ee-4416-bb22-facf3f7438e8.png" style="width:121.75em;height:42.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Adding a build step</span></div>
<ol start="3">
<li>Add this shell script and click <span class="packt_screen">Save</span>:</li>
</ol>
<pre style="padding-left: 90px">#!/bin/sh<br/><br/>set +x<br/><br/># These 2 are defined in Deployment YAML<br/>DEPLOYMENT_NAME=<strong>my-calc-deploy</strong><br/>CONTAINER_NAME=<strong>my-calc</strong><br/><br/># change to your Docker Hub repository<br/>REPOSITORY=<strong>hidetosaito/my-calc</strong><br/><br/><br/>echo "*********************"<br/>echo "*** before deploy ***"<br/>echo "*********************"<br/>kubectl rollout history deployment $DEPLOYMENT_NAME<br/>kubectl set image deployment $DEPLOYMENT_NAME $CONTAINER_NAME=$REPOSITORY:$BUILD_NUMBER<br/><br/><br/>echo "******************************************"<br/>echo "*** waiting to complete rolling update ***"<br/>echo "******************************************"<br/>kubectl rollout status --watch=true deployment $DEPLOYMENT_NAME<br/><br/><br/>echo "********************"<br/>echo "*** after deploy ***"<br/>echo "********************"<br/>kubectl rollout history deployment $DEPLOYMENT_NAME<br/><br/></pre>
<ol start="4">
<li>Trigger a new build; you can see that after Docker push, it runs the preceding script:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-364 image-border" src="assets/7b881532-d1b1-4322-b3ef-d27217f4b377.png" style="width:127.58em;height:98.92em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Kubernetes rollout result</span></div>
<p>Now you can extend continuous integration to continuous delivery! You may extend to add a unit test or integration test and roll back mechanisms onto the above script to make your CI/CD work stronger.</p>


            </article>

            
        </section>
    </body></html>