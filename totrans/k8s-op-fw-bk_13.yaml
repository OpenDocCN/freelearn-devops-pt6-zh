- en: '*Chapter 10*: Case Study for Optional Operators – the Prometheus Operator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The point of this book is to introduce, discuss, and demonstrate the main processes
    for developing an Operator for Kubernetes using the Operator Framework. To do
    this, a sample Operator with the basic functionality of managing an nginx deployment
    was built. This example was intended to serve as a tutorial on Operator development
    without overwhelming the reader with excessive features or the requirement of
    significant background knowledge to understand the use case. Hopefully, it has
    served that purpose well.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the simplicity of that nginx Operator might make some of the steps in the
    Operator Framework seem excessive. It''s also a big jump to go from learning about
    an example Operator to understanding the applications of real-world use cases.
    So, in this chapter, we will examine the Prometheus Operator ([https://prometheus-operator.dev/](https://prometheus-operator.dev/)),
    which is used to manage individual deployments of the Prometheus monitoring service
    (which was used to gather metrics from the nginx Operator earlier in the book).
    In this chapter, we are calling this an *optional* Operator because the Operand
    it manages is an application-level component and is not critical to the running
    of the cluster (in contrast, the next chapter will discuss how Operators can manage
    core cluster-level components). The Prometheus Operator will be discussed in the
    following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: A real-world use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator distribution and development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates and maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, while there are going to be many parallels to draw between the Prometheus
    Operator and the example nginx Operator from this book (which strictly followed
    the Operator Framework template), it is just as important to highlight the differences,
    too. Some of these will be covered throughout the chapter to show that even within
    the Operator Framework, there is no one-size-fits-all way to develop an Operator.
    That is the beauty of open source software such as this: its patterns and divergences
    promote a broad community of diverse projects.'
  prefs: []
  type: TYPE_NORMAL
- en: A real-world use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prometheus ([https://github.com/prometheus/prometheus](https://github.com/prometheus/prometheus))
    is a tool that is used for monitoring applications and clusters by collecting
    metrics exported by those applications and storing them in a time series manner.
    In [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an Operator
    – Advanced Functionality*, we implemented basic Prometheus metrics in the nginx
    Operator to expose aggregate information about the total reconciliation attempts
    made by the Operator. This was just one small example of the potential application
    architecture designs that rely on Prometheus for monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with scraping and aggregating metrics, Prometheus also defines a data
    model for creating different types of metrics and implementing them in applications.
    This model is instrumented via the clients provided by Prometheus in various languages,
    including Ruby, Python, Java, and Go. These clients make it easy for application
    developers to export metrics in a format that is compatible with the Prometheus
    server's API (just as we did for the example nginx Operator).
  prefs: []
  type: TYPE_NORMAL
- en: Besides the counter metric type (which was used to sum the `reconciles_total`
    metric in the nginx Operator), the other metric types offered by Prometheus include
    Gauge, Histogram, and Summary. Each of these metrics can export additional attributes
    in the form of labels to give additional dimensions to the data they report.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Prometheus allows users to search metrics using its own query language
    called **PromQL**. The functionality of this language combined with the flexible
    and broad implementation possibilities of the metrics themselves has helped Prometheus
    grow to become one of the (if not the) leading metrics-gathering tools for cloud-native
    applications beyond just Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the book, we briefly discussed how to use Prometheus clients to create
    new metrics and retrieve those metrics using PromQL ([*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*) while also building the sample
    Operator. These topics, while important, do not relate much to the Prometheus
    Operator (regardless, they are briefly described here for the full context of
    the real-world use case). The more relevant aspects of Prometheus that the Operator
    addresses are the installation and configuration of Prometheus as an Operand.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running Prometheus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building and Deploying
    Your Operator*, we demonstrated one way to install Prometheus in a cluster by
    instrumenting the `kube-prometheus` library in the nginx Operator project. The
    advantage of kube-prometheus is that it installs a full monitoring stack, including
    components such as **Grafana**, but also including the Prometheus Operator itself.
    But what does it mean to install Prometheus in a cluster? And what steps do we
    save by using kube-prometheus (and, by extension, the Prometheus Operator)? To
    answer those questions, first, let's take a step back and understand how Prometheus
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Central to an instance of Prometheus is the Prometheus server, which runs as
    a single binary that retrieves metrics and serves them to the web UI, notification
    services, or long-term storage. Similar to an Operator (or any application intended
    to be deployed to Kubernetes), this binary must be compiled and packaged into
    a container image. As described in the Prometheus documentation, the precompiled
    binary is available to download directly (as an executable or a container image),
    or it can be built from source ([https://github.com/prometheus/prometheus#install](https://github.com/prometheus/prometheus#install)).
    This is accessible enough for running locally, but for deployment to a Kubernetes
    cluster (especially a production one), further setup is required.
  prefs: []
  type: TYPE_NORMAL
- en: First, it is rarely acceptable to deploy a container directly into a cluster
    without some form of configuration. Kubernetes objects such as Deployments wrap
    the container in a managed and configurable representation that exposes options
    such as replica count and rollout strategies. So, installing Prometheus in a Kubernetes
    cluster manually would require defining the Kubernetes Deployment yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Once it's running in a cluster, Prometheus then needs access to the applications
    that are exposing metrics. This requires additional resources such as `ClusterRoles`
    and `RoleBindings` to ensure the Prometheus Pod has permission to scrape metrics
    from the cluster and its applications. Those RBAC permissions must be bound to
    the Prometheus Pod via a `ServiceAccount` instance. Then, user access to the web
    UI requires a Service to make that frontend reachable in a web browser. That Service
    can only be exposed outside the cluster with an Ingress object.
  prefs: []
  type: TYPE_NORMAL
- en: These are already a lot of steps for an initial installation. However, managing
    that installation by hand also requires constant vigilance and a schematic understanding
    of each resource and its role. While certainly possible, having an Operator to
    handle these resources frees up engineering time and enables better scaling by
    abstracting complex manifest declarations.
  prefs: []
  type: TYPE_NORMAL
- en: However, as discussed throughout this book, many (if not most) Operators do
    more than simply install their Operand. Usually, they continue to manage the life
    cycle of the installed application, including allowing you to make changes to
    the running Operand's configuration. The Prometheus Operator does this for Prometheus,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Prometheus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a full-featured application, Prometheus provides a rich set of configuration
    options to fit different scenarios. This configuration is documented in the official
    Prometheus documentation at [https://prometheus.io/docs/prometheus/latest/configuration/configuration/](https://prometheus.io/docs/prometheus/latest/configuration/configuration/).
    Within these settings, there are two sets of options for configuring Prometheus:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line flags: They control the settings that affect the Prometheus server
    itself, such as persistent storage access and logging settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The YAML config: This is passed to Prometheus via a command-line flag (`--config.file`
    or `--web.config.file`) and provides declarative controls over the behavior of
    Prometheus'' monitoring; for example, the metrics scraping settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This separation of setting types is a good design that is often employed in
    Kubernetes applications, Operators, and non-Kubernetes software. It has the benefit
    of clearly decoupling the runtime application settings from behavioral options,
    and this distinction is evident to users. However, from an administrative perspective,
    this creates two separate areas of concern that must be individually tracked.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The full list of command-line flags that are available to the Prometheus binary
    is available by running `prometheus -h`. There are a few dozen options in total,
    but they are roughly organized into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these categories has up to 10 (or more) individual settings controlling
    different aspects of the Prometheus server. In addition, there is the `--enable-feature`
    flag, which accepts a comma-separated list of features to enable (for example,
    `--enable-feature=agent,exemplar-storage,expand-internal-labels,memory-snapshot-on-shutdown`
    enables these four additional feature gates).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Kubernetes Deployment manifest, these flags would be controlled in the
    `spec.template.spec.containers.command` (or `.args`) field. For example, a simple
    Prometheus Deployment YAML with a config file passed to it and the preceding features
    enabled would look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the config file also needs to be mounted into the Prometheus Pod
    so that it can be accessed, as shown in the following code. This shows the preceding
    Deployment YAML modified to add a `VolumeMount` instance, which makes the config
    file accessible to the Prometheus Pod as if it were a local file (the new code
    has been highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: That config file (mounted as `/etc/prom/config-file.yaml`) will then need to
    be created as its own ConfigMap. This brings us to the second set of Prometheus
    options that the config file controls.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML config settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Prometheus YAML configuration format exposes settings that control the general
    scraping (metrics-gathering) behavior of Prometheus. Among the available options
    are the platform-specific **Service Discovery** (**SD**) controls for individual
    cloud providers, including Azure, Amazon EC2, and Google Compute Engine instances.
    There are also options to relabel the metrics, enable the remote reading and writing
    of metrics data, and configure AlertManager notifications, tracing, and exemplars.
    Finally, the config offers TLS and OAuth settings for secure metrics scraping.
  prefs: []
  type: TYPE_NORMAL
- en: All of these options already present complex possibilities for a Prometheus
    config. Even the sample config file provided by Prometheus is almost 400 lines
    long! (However, it is intended to demonstrate many different types of metric setup.
    For example, take a look at [https://github.com/prometheus/prometheus/blob/release-2.34/config/testdata/conf.good.yml](https://github.com/prometheus/prometheus/blob/release-2.34/config/testdata/conf.good.yml).)
    This can quickly seem overwhelming, especially if you only want a simple metrics
    solution (as many users do). For this reason, we will mainly focus on a basic
    `scrape_config` section in a Prometheus config file. This is the main section
    of the config file that tells Prometheus where and how to find the metrics it
    is interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction is carried out by defining a series of `job` instances. Each
    job provides information about certain metrics targets and instructs Prometheus
    on how it can discover new metrics from targets that match those criteria. For
    example, the `kubernetes_sd_config` settings (which are relevant to scraping Kubernetes
    applications: [https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config))
    can control metrics gathering for Nodes, Pods, Services, Endpoints, and Ingress
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the problems with manual Prometheus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is not meant to be an introduction to how to run Prometheus. Rather,
    the intent of the earlier sections was to demonstrate, through specific examples,
    the potential complexities that can arise when running any sophisticated application
    and how these complexities multiply when that application is deployed to a platform
    such as Kubernetes, which demands its own maintenance overhead, too.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the problems discovered earlier fall into a few categories, as we
    will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Excessive platform knowledge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the very beginning (when installing Prometheus inside a cluster), it was
    necessary to know more about the platform and deployment resources than about
    running the actual application itself. From ClusterRoles and RoleBindings to even
    just the Deployment manifest declaration, an administrator must understand the
    Kubernetes installation architecture before they can even begin to run Prometheus
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: This is bad because it distracts from engineering time, which could be otherwise
    allocated. However, it also creates an unstable environment, where this architectural
    knowledge is likely only learned once (at the time of installation) and promptly
    forgotten, or at the very least, not documented as well as other application-relevant
    resources. In the event of a disaster, this costs precious recovery time as the
    knowledge must be reacquired.
  prefs: []
  type: TYPE_NORMAL
- en: Complex configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once Prometheus has been installed inside a cluster, immutable server settings
    must be passed via flags, and the individual metrics scraping jobs must be configured
    within a YAML file. For both of these steps, the vast number of available settings
    and flexible options for each setting present complex overall configurations.
    For metrics jobs, this complexity can potentially grow over time as more services
    are added to the cluster with metrics that must be gathered. This configuration
    must be maintained, and any changes need to be done with care to ensure they are
    rolled out effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Restarts are required to enable changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speaking of changes, neither command-line flags nor config file settings take
    effect immediately. The Prometheus application must be restarted to notice the
    changes. This is not a big problem with changes to command-line flags, as doing
    so obviously requires the current running replica to stop (and, usually, making
    changes to a Kubernetes Deployment manifest will trigger a new replica with those
    changes anyway).
  prefs: []
  type: TYPE_NORMAL
- en: But it is less obvious for config file settings, which can lead to frustrating
    confusion as it might appear as though the changes are not taking effect. This
    might seem like a silly mistake, but it is one that is far too easy to make to
    consider risking it in a production environment. Even worse, it can lead to frustrated
    users making multiple changes at once before the mistake is realized, causing
    the new Deployment to pick up multiple unintended changes at once when it is finally
    restarted.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few simple examples of the problems that can be encountered
    when running applications without Operators. In the next section, we'll look more
    in detail at how the Prometheus Operator specifically approaches these issues
    with the goal of presenting an abstractable set of solutions that can be considered
    when building your own Operator for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Operator design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Prometheus Operator is designed to alleviate the issues mentioned earlier
    in regard to the complexity involved with running an instance of Prometheus in
    a Kubernetes cluster. It does so by abstracting the various configuration options
    that are available for Prometheus into **CustomResourceDefinitions** (**CRDs**),
    which are reconciled by the Operator's controllers to maintain that the cluster's
    Prometheus installation is consistent with the desired state, whatever that might
    be (and however it might change).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in contrast to the example nginx Operator from earlier tutorials,
    the Prometheus Operator manages a far more complex application with many more
    possible states that it must be able to reconcile. But the general approach is
    still the same, so we can evaluate this Operator through the lens of the same
    development steps that have been shown throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: CRDs and APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed many times already, CRDs are the main objects upon which many Operators
    are built. This is because they allow developers to define custom API types that
    can be consumed by the Operator. Usually, this is how the user interacts with
    the Operator, setting their desired cluster state through the CRD that pertains
    to their Operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this book has mainly focused on the concept of an Operator providing
    only a single configuration CRD (in the examples, this was just the `NginxOperators`
    object), the reality is that Operators can provide multiple different CRDs depending
    on their functionality. This is what the Prometheus Operator does. In fact, it
    provides eight different CRDs (which are described in detail at [https://github.com/prometheus-operator/prometheus-operator/blob/v0.55.1/Documentation/design.md](https://github.com/prometheus-operator/prometheus-operator/blob/v0.55.1/Documentation/design.md)).
    The full list of available CRDs it provides defines the following object types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Prometheus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alertmanager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThanosRuler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceMonitor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PodMonitor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Probe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrometheusRule`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlertmanagerConfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will discuss some of these object types in more detail next. In general,
    the purposes of these CRDs can be roughly broken down into a few categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Operand deployment management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring configuration settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional config objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to keep the context of this chapter focused, we will only dive deeper
    into the first two groups of CRDs, as listed earlier. (The third, which is, here,
    referred to as *additional config objects*, includes the `Probe`, `PrometheusRule`,
    and `AlertmanagerConfig` types, which go into advanced monitoring settings that
    are beyond the scope of understanding Operator use cases.)
  prefs: []
  type: TYPE_NORMAL
- en: Operand deployment management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first three CRDs, `Prometheus`, `Alertmanager`, and `ThanosRuler`, allow
    users to control the settings for Operand deployments. For comparison, our example
    `NginxOperator` CRD controlled the Kubernetes Deployment for an instance of nginx,
    exposing options such as `port` and `replicas`, which directly affected how that
    Deployment was configured. These Prometheus Operator CRDs serve the same purpose,
    just for three different types of Operand deployments. (Technically, the Prometheus
    Operator runs these Operands as StatefulSets, which is another type of Kubernetes
    object, not Deployments, but the same principles apply.)
  prefs: []
  type: TYPE_NORMAL
- en: 'These Operand-related CRDs are defined in the Operator''s code at `pkg/apis/monitoring/v1/types.go`
    (note that the `pkg/api/<version>` pattern is similar to the one used in our Operator
    SDK code path). Talking specifically about the `Prometheus` object''s top-level
    definition, it is exactly the same as our `NginxOperator` CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: 'prometheus-operator/pkg/apis/monitoring/v1/types.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With just the `TypeMeta`, `ObjectMeta`, `Spec`, and `Status` fields, this definition
    seems very straightforward. However, looking more closely at the `PrometheusSpec`
    object, the number of configuration options available becomes more evident:'
  prefs: []
  type: TYPE_NORMAL
- en: 'prometheus-operator/pkg/apis/monitoring/v1/types.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: For the purposes of this chapter, it's not necessary to know what each option
    does. But the myriad of fields demonstrates how much an Operator's CRD can grow,
    emphasizing the need for careful management of an Operator's API. The list of
    available options goes even deeper with the embedded `CommonPrometheusFields`
    type, which offers controls over the number of replicas of Prometheus to run,
    the ServiceAccount settings for the Operand Pods, and a number of other settings
    related to the Prometheus deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, from a user''s perspective, the `Prometheus` custom resource object
    they create in the cluster could look much simpler. This is because all of the
    fields in its type definition are marked with the `omitempty` JSON tag (for clarity,
    they were removed from all of the fields in the preceding code block except one).
    This denotes the fields as optional in the Kubebuilder CRD generator and does
    not print them if they are not set. Therefore, an example `Prometheus` object
    could be as simple as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Altogether, the `Prometheus` CRD offers a single spot for controlling some of
    the settings from either category, as discussed in the *Configuring Prometheus*
    section. That is, it exposes both command-line flag options and config file options
    in a single spot (along with Kubernetes-specific Deployment settings such as the
    replica count). It takes another step to disentangle some of these settings with
    the CRDs that control the monitoring options, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring configuration settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the `Prometheus` CRD allows users to configure the settings of the Prometheus
    metrics service itself, the `ServiceMonitor` and `PodMonitor` CRDs effectively
    translate to the Prometheus `job` config YAML settings, as described in the *Configuring
    Prometheus* section. In this section, we'll discuss how `ServiceMonitor` works
    to configure Prometheus to scrape metrics from specific Services (the same basic
    ideas apply to PodMonitor, which scrapes metrics from Pods directly).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this translation, the following `ServiceMonitor` object will
    be used to make the Prometheus Operator configure Prometheus so that it scrapes
    metrics from Service endpoints that are labeled with the `serviceLabel: webapp`
    labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'More specifically, this object is broken down into two sections that are common
    to most Kubernetes objects: `metadata` and `spec`. Each serves an important role:'
  prefs: []
  type: TYPE_NORMAL
- en: The `metadata` field defines the labels that describe this `ServiceMonitor`
    object. These labels must be passed to the Prometheus Operator (in a `Prometheus`
    object, as described in the *Operand deployment management* section) to inform
    it about which `ServiceMonitor` objects the Operator should watch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `spec` field defines a `selector` field, which specifies which application
    Services to scrape for metrics based on the labels on those Services. Here, Prometheus
    will ultimately know to scrape application metrics from Services labeled with
    `serviceLabel: webapp`. It will collect those metrics by querying the named `http`
    port on the Endpoints of each Service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To gather this service discovery information (and, eventually, process it inside
    a Prometheus YAML configuration), the Prometheus Operator must be set up to watch
    `ServiceMonitors` with the `app: web` label. To do this, a `Prometheus` CRD object
    can be created similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'With this `Prometheus` object, the Prometheus Operator watches for instances
    of these `ServiceMonitor` objects and automatically generates the equivalent Prometheus
    YAML config. For the earlier `ServiceMonitor` object, that Prometheus configuration
    file looks similar to the following (note that this code is only shown here as
    an example to emphasize the complexity of a Prometheus config, and it is not necessary
    to understand it in depth):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this full YAML config is very long, and it would require significant
    effort to create (much less maintain) by hand. It's not important for the purpose
    of this discussion to explain the full config in detail. It is mainly shown here
    to emphasize the work done by an Operator to abstract such a complex configuration
    into a relatively simple CRD.
  prefs: []
  type: TYPE_NORMAL
- en: It is the relationship between CRDs such as `Prometheus` and `ServiceMonitor`
    that enables such abstraction in reasonable ways. For example, it would be easy
    to ship a single large `Prometheus` CRD that includes the settings for the monitoring
    services. This would also simplify the Operator's code by only requiring it to
    monitor one type of CRD for changes.
  prefs: []
  type: TYPE_NORMAL
- en: But decoupling these settings allows each CRD object to remain manageable and
    readable. Additionally, it provides granular access control over the modification
    of the Operand settings (in other words, specific teams can be granted the ability
    to create `ServiceMonitor` objects within their own namespaces in the cluster).
    This ad hoc configuration design gives cluster tenants control over the consumption
    of their own projects.
  prefs: []
  type: TYPE_NORMAL
- en: With this general understanding of the CRDs used by the Prometheus Operator
    (and how their design creates a cohesive API), next, we will look, in more detail,
    at how the Operator reconciles these objects from a technical perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Reconciliation logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand the role of all the Prometheus Operator CRDs, it helps
    to know more about how the Operator configures the Prometheus Operand. Under the
    hood, the Prometheus Operator manages the Prometheus Pods' configuration through
    a secret (that is, the Kubernetes object designed to contain sensitive data of
    an arbitrary nature). That Secret is mounted into the Prometheus Pods as if it
    were a file and, thereby, passed to the Prometheus binary's `--config.file` flag.
  prefs: []
  type: TYPE_NORMAL
- en: The Operator knows to update this secret (and redeploy the Prometheus Operand,
    reloading the config file in the process) because it watches its `Prometheus`
    CRD (along with other CRDs such as `ServiceMonitor` and `PodMonitor`) in the cluster
    for changes.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading Config Changes with Prometheus
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the Prometheus Operator reloads the Prometheus config when it is
    changed without needing to redeploy the entire Operand. It does this with a sidecar
    container, running `/-/reload` endpoint on the Prometheus server. While Prometheus
    supports runtime config reloading this way, many applications do not. So, for
    demonstration purposes, this chapter glosses over this technical detail to focus
    on the capabilities of the Operator and the more common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Operator is able to monitor these CRD objects once it has been granted appropriate
    RBAC permissions to do so. This is because even though it defines those objects
    in its own project, the Kubernetes authentication services don't know that. To
    the cluster, the Operator is simply another Pod running an arbitrary application,
    so it needs permission to list, watch, get, or perform any other action on any
    type of API object.
  prefs: []
  type: TYPE_NORMAL
- en: In the nginx Operator example, the RBAC rules for accessing our Operator's CRD
    objects were automatically generated using Kubebuilder markers. Instead, the Prometheus
    Operator provides sample YAML files for its users with the appropriate permissions
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: The Prometheus Operator creates three separate controllers for the three different
    Operands it supports (that is, Prometheus, Alertmanager, and Thanos). With the
    Operator SDK, the same design could be achieved by running `operator-sdk create
    api --controller` for each CRD that requires its own reconciliation logic.
  prefs: []
  type: TYPE_NORMAL
- en: Each controller watches for adds, updates, and deletes for the relevant objects
    that inform its reconciliation. For the Prometheus controller, these include the
    `Prometheus`, `ServiceMonitor`, and `PodMonitor` CRDs. But it also watches for
    changes to things such as Secrets and StatefulSets because, as mentioned earlier,
    these are the objects that are used to deploy the Prometheus Operand. So, by watching
    for these too, it can ensure that the Operand objects themselves are maintained
    at the appropriate settings and can recover from any deviations (for example,
    accidental manual changes to the Secret that holds the current Prometheus config
    YAML).
  prefs: []
  type: TYPE_NORMAL
- en: The main controller logic is implemented in a function called `sync()`, which
    is the equivalent to the Operator SDK's automatically created `Reconcile()` function.
    The `sync()` function follows the same general outline, as described for our sample
    nginx Operator, too. Some of the relevant code snippets from the Prometheus `sync()`
    function are detailed next.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the function gets the `Prometheus` CRD object that is necessary for
    the Prometheus Operand deployment to exist. If the object cannot be found, the
    controller returns an error. If it is found, then it creates a copy to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it parses the `Prometheus` object (and gathers any relevant `ServiceMonitor`
    objects or `PodMonitor` objects to parse too) in order to generate the YAML configuration
    Secret. This is done in a helper function that also checks for an existing Secret
    and creates one if none exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it creates the Prometheus StatefulSet, which runs the Operand deployment.
    Similar to generating the config Secret, this part also uses helper functions
    to check for the presence of an existing StatefulSet and then decides whether
    to update it or create a new StatefulSet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to how the example nginx Operator created a Kubernetes Deployment
    object. However, rather than using a file-embedding library as we eventually did,
    the Prometheus Operator builds the StatefulSet object in memory. Without going
    into too much detail, that makes sense for this application because much of the
    StatefulSet definition is dependent on variable options that are set by logic
    in the code. So, there is not much advantage to maintaining an embedded file to
    represent this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this reconciliation loop, the Operator makes extensive use of structured
    logs and metrics to inform the user about its health. And while it doesn''t report
    any `Condition` updates as our Nginx operator did, it does report other custom-defined
    fields in the `PrometheusStatus` field of the `Prometheus` CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: 'pkg/apis/monitoring/v1/types.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: This is a good demonstration of the fact that Operator CRDs can provide application-specific
    health information rather than only relying on existing patterns and upstream
    API types to convey a detailed status report. Combined with the fact that multiple
    `Prometheus` CRD objects can be created, with each representing a new deployment
    of Prometheus, the status information of individual Operand deployments is separated.
  prefs: []
  type: TYPE_NORMAL
- en: This is all a very high-level overview of the Prometheus Operator's reconciliation
    logic, with many specific implementation details omitted in order to draw more
    comparisons between the concepts discussed throughout the book related to Operator
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Operator distribution and deve[lopment](https://github)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[The Pr](https://github)ometheus Operator is hosted on GitHub at [https://github.com/prometheus-operator/prometheus-operator](https://github.com/prometheus-operator/prometheus-operator),
    where most of its documentation is also [maintained. It is](https://operatorhub)
    also distributed via OperatorHub at [https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The Prometheus Operator page on OperatorHub.io](img/Figure_10.1_B18147.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The Prometheus Operator page on OperatorHub.io
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building
    and Deploying Your Operator*, there are many different ways to run an Operator.
    From local builds to container deployments, each offers advantages for different
    development use cases. Then, in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*, the function
    of OperatorHub was explained as both a distribution index and an installation
    method when combined with the **Operator Lifecycle Manager** (**OLM**).
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this spectrum of distribution and installation options is illustrated
    by the Prometheus Operator. Inside its GitHub repository, the Prometheus Operator
    maintainers provide a single `bundle.yaml` file that allows curious users to quickly
    install all of the resources that are necessary to run the Operator with a simple
    `kubectl create` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that while this is similar in function to the bundle that's created to
    package an Operator for OperatorHub and OLM, technically, it is not the same.
    That's because it doesn't contain a **ClusterServiceVersion** (**CSV**) or other
    metadata that could be used by the OLM to manage an installation of the Prometheus
    Operator.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Prometheus Operator does provide this information on OperatorHub.
    The backing CSV, along with the Operator's CRD files, are hosted for OperatorHub
    in its GitHub repository at [https://github.com/k8s-operatorhub/community-operators/tree/main/operators/prometheus](https://github.com/k8s-operatorhub/community-operators/tree/main/operators/prometheus).
    This directory follows the same structure that was described in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*. Each new
    version of the Prometheus Operator's bundle is kept in its own numbered directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The Prometheus Operator version directories on OperatorHub](img/Figure_10.2_B18147.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The Prometheus Operator version directories on OperatorHub
  prefs: []
  type: TYPE_NORMAL
- en: The individual versions contain the YAML definitions for each CRD used by the
    Operator alongside a CSV that provides the metadata about the Operator and its
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the use case of this CSV, we can briefly look at some of the
    relevant sections, as shown in the following code. First, it describes the Operator''s
    descriptive information, including its capability level (in this case, the Prometheus
    Operator is a Level IV Operator providing *Deep Insights* such as metrics about
    itself and its Operand):'
  prefs: []
  type: TYPE_NORMAL
- en: 'prometheusoperator.0.47.0.clusterserviceversion.yaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it embeds the various CRDs and a description of their fields. The following
    is an excerpt from the `Prometheus` CRD description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSV goes on to define the deployment of the Operator. This maps directly
    to the Kubernetes Deployment object, which will run the Operator Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the CSV provides the RBAC permissions needed by the Operator to monitor
    its relevant resources in the cluster. Additionally, it also creates the RBAC
    permissions needed by the actual Prometheus Pods, which are separate from what
    the Operator needs. This is because the Operator and its Operand are separate
    entities in the cluster, and the Prometheus Server itself needs access to different
    resources to gather metrics (this is in contrast to the Prometheus Operator, which
    needs to access its CRDs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the RBAC permissions used to access its own CRDs, with wildcard (`*`)
    access under `verbs` indicating that the Operator can perform any API action against
    these objects (such as `get`, `create`, `delete`, and more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: The CSV concludes with contact information for the maintainers, along with links
    to the documentation and the version number of this release.
  prefs: []
  type: TYPE_NORMAL
- en: Offering a variety of distribution channels, in this case, GitHub and OperatorHub,
    has the obvious benefit of enabling an Operator to reach a broader audience of
    users. But this range of users can often be defined less by where the Operator
    is distributed and more by how the Operator is intended to be used. In other words,
    a user installing from OperatorHub is more likely to be evaluating (or actively
    running) the Operator in a production environment (with the full OLM stack) than
    a user installing the Operator from GitHub. In the latter case, such installations
    are probably more experimental, possibly from users seeking to contribute to the
    project themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Accommodating the different use cases of an Operator in your distribution choices
    helps not only with the growth of a project but also its health. Recall that in
    [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032), *Understanding How Operators
    Interact with Kubernetes*, we identified several types of potential users such
    as cluster users and administrators. While, in theory, an Operator's function
    might only apply to one type of user, the way that Operator is installed and run
    could vary for different kinds of users, including developers. Understanding these
    users and providing usage pathways for them increases the coverage of an Operator's
    functionality, improving the odds that bugs and potential features are identified.
  prefs: []
  type: TYPE_NORMAL
- en: As with many other topics in this book, these concepts are not specific to Operator
    design. But they are worth noting in the context of an Operator discussion to
    reiterate the ways in which they apply here. Similarly, while the topics of maintaining
    software and providing updates are not strictly specific to Operators, in the
    next section, we will still examine them through the lens of this Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Updates and maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Prometheus Operator's community of maintainers is very active. With over
    400 contributors to date ([https://github.com/prometheus-operator/prometheus-operator/graphs/contributors](https://github.com/prometheus-operator/prometheus-operator/graphs/contributors)),
    its code base remains fresh through ongoing maintenance. This allows the Prometheus
    Operator to publish regular releases on its GitHub Releases page ([https://github.com/prometheus-operator/prometheus-operator/releases](https://github.com/prometheus-operator/prometheus-operator/releases)).
    As with any application, releasing regular updates promotes confidence in potential
    users by demonstrating an active investment in the project's support by its owners.
    In Kubernetes projects, such as Operators, this is even more important due to
    the relatively fast-paced and highly fluctuant developments in the underlying
    Kubernetes platform. Otherwise, with the current Kubernetes deprecation policy,
    an Operator might become unusable in new clusters in as little as a year (see
    [*Chapter 8*](B18147_08_ePub.xhtml#_idTextAnchor126), *Preparing for Ongoing Maintenance
    of Your Operator*).
  prefs: []
  type: TYPE_NORMAL
- en: In reality, in most cases, the main dependencies used by an Operator project
    will not frequently introduce breaking changes that require manual updates to
    remain compatible with existing users. Instead, most updates will simply be version
    bumps that bring in security, performance, and edge-case optimization improvements.
    To automate this process, the Prometheus Operator uses GitHub's Dependabot, which
    automatically creates pull requests to update any dependencies with new releases
    ([https://docs.github.com/en/code-security/dependabot](https://docs.github.com/en/code-security/dependabot)).
  prefs: []
  type: TYPE_NORMAL
- en: Automated dependency management tools such as Dependabot are a great way to
    ensure your Operator remains up to date with its dependencies, and thereby compatible
    with the most recent environment updates made by users. However, depending on
    your own scenario, you might still choose to manually update your Operator (for
    example, if you are aligning with a different release cadence where upstream patch
    releases might not be of significance to your own release).
  prefs: []
  type: TYPE_NORMAL
- en: Besides dependency updates, most Operators will also ship their own updates;
    for example, shipping a new API version (as covered in the *Releasing new versions
    of your operator* section of [*Chapter 8*](B18147_08_ePub.xhtml#_idTextAnchor126),
    *Preparing for Ongoing Maintenance*). In the case of the Prometheus Operator,
    the transition from API version `v1alpha1` to `v1` also involved a migration from
    Kubernetes `AlertManager` CRD from `v1alpha1` to `v1beta1`, leveraging conversion
    webhooks to translate betwe[en the two (th](https://github)is proposal is tracked
    and documented at [https://github.com/prometheus-operator/prometheus-operator/issues/4677](https://github.com/prometheus-operator/prometheus-operator/issues/4677)).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Prometheus Operator maintains its own Slack channel for community
    support and discussion. Because the Operator is a third-party open source effort
    not directly affiliated with Prometheus itself, openly advertising the proper
    channels for support not only helps users find the right contacts but also respects
    the Prometheus maintainers' scope of responsibility. In this way, it is perfectly
    acceptable to publish an Operator that manages an Operand that you do not own.
    However, if this is not made clear, it can be very disruptive to your users and
    the owners of that Operand if the distinction between Operator and Operand is
    blurred.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used the Prometheus Operator as an example to apply many
    of the concepts covered throughout the book. This Operator makes a good example
    because, aside from serving a common need by managing a popular application, it
    is actually one of the earliest Operators (having published its first release,
    v0.1.1, in December 2016). This predates the formalized Operator Framework, which
    developers can benefit from today, explaining idiosyncrasies such as its lack
    of Operator SDK libraries, but demonstrating the influence of early development
    decisions in the design of the Operator Framework.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we gave a brief overview of Prometheus itself.
    This gave us a foundational understanding of the use case for a Prometheus Operator,
    particularly regarding the installation and configuration of Prometheus. This
    laid the groundwork to understand what the Prometheus Operator does to alleviate
    these pain points. By examining the CRDs it uses and how they are reconciled,
    we demonstrated how the Prometheus Operator abstracts that underlying functionality
    from the user, drawing parallels with the earlier chapters in the book (and the
    much simpler Nginx operator used to build the examples in those chapters). Finally,
    we looked at the more intangible aspects of the Prometheus Operator, such as its
    distribution and maintenance, to show how popular Operators apply these concepts
    from the Operator Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will follow a similar case study but for a different
    Operator, that is, the etcd Operator.
  prefs: []
  type: TYPE_NORMAL
