# 14

# 结论及 Kubernetes Secrets 管理的未来

本手册为您提供了确保容器编排平台安全的基本组成部分，作为持续改进安全态势的参考，同时关注外部解决方案的需求，以增强或改进当前 Kubernetes 设计，尤其是在管理 Secrets 方面。

在本章中，我们将讨论以下主要主题：

+   当前 Kubernetes 的状态以及它在 Secrets 管理方面的改进

+   Kubernetes 项目带来的未来以及如何影响它

+   如何保持与最新趋势和实践同步

# 当前 Kubernetes 的状态

随着 Kubernetes 的广泛采用，本手册展示了可以利用 Kubernetes 本地构件作为内部保险库解决方案的方案，以及来自 Azure、AWS、GCP 和 HashiCorp 的外部解决方案。两者的结合可能是改善安全态势的关键，尤其是在管理平台组件和应用程序的 Secrets 时。

这些解决方案作为保护措施，确保存储在 Kubernetes 集群中的敏感信息的安全，围绕着存储、管理和分发 API 密钥、密码和证书的原则，确保在没有或有限的安全暴露下安全地处理这些数据。

## 本地解决方案

Kubernetes 项目使用**Kubernetes 增强提案**（**KEP**）来记录设计变更，以及这些变更的目标版本（包括 alpha、beta 和**正式发布**（**GA**）版本）。

### KMS 提供商

KEP 自 1.25 版本以来一直记录与本地 Kubernetes Secrets 管理相关的安全变更，涉及以下主题：

+   实现无缝的密钥轮换

+   引入可靠性的健康检查

+   在不妥协可恢复性和安全性的前提下提高性能

+   改善 Kubernetes API 服务器、KMS 插件和 KMS 之间的端到端可观察性，并具备审计功能

这些改进与我们在本手册中观察到并通过相应措施缓解的挑战保持一致，有助于提高并维护 Kubernetes 集群的安全态势。

截至写作时，Kubernetes 的最新版本是 1.28。它带来了一系列关于本地 Secrets 管理的改进，具体内容已记录在*KEP-3299*、*KMSv2 改进*中：

+   以下是相关变更：

    +   放弃之前的`KMSv1`功能，转而支持`KMSv2`；此变更旨在推动`KMSv2`的 GA（正式发布），该版本计划在 1.29 版本中发布。

    +   实现新的`KMSv2KDF`功能门控或为每次加密生成新的 DEK。此变更为运营团队提供了一种可选行为，可以启用此功能以遵守那些不接受默认`KMSv2`行为（即在 Kubernetes API 服务器启动时生成单一 DEK）的法规。

这是 KEP 3299 的 GitHub 链接：[`github.com/kubernetes/enhancements/blob/master/keps/sig-auth/3299-kms-v2-improvements/README.md`](https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/3299-kms-v2-improvements/README.md)。

请参阅*第三章*中的*键值数据*部分，了解`KMSv1`和`KMSv2`实现之间的技术演变概述。

请注意，`KMSv2` 在 Kubernetes 1.28 版本中仍被视为*测试版*，并计划在 1.29 版本中达到 GA 状态（写作时的情况）。

### CSI 密钥存储

由于依赖于外部保管库服务，CSI 密钥存储可以被视为 Kubernetes 的外部解决方案。然而，CSI 密钥存储是：

+   基于**容器存储接口**（**CSI**）架构，这是一个原生的 Kubernetes 接口

+   由 Kubernetes 项目的**兴趣小组**（**SIG**）推动

+   利用原生的 Kubernetes API 对象，无需代理、侧车容器或非原生的 Kubernetes 模式

这是 CSI 密钥存储项目的链接：[`secrets-store-csi-driver.sigs.k8s.io/`](https://secrets-store-csi-driver.sigs.k8s.io/)。

不仅如此，这种模型可以简化从外部保管库向应用程序注入密钥，还可以在需要时将密钥同步为原生的 Kubernetes 密钥对象。

同步密钥能力

使用同步密钥功能时，CSI 密钥存储会将外部密钥同步为原生 Kubernetes 密钥对象，这要求设置数据静态加密，以确保这些对象中的敏感数据负载被加密。

请参阅*第三章*的*键值数据*部分，了解关于不同选项的概述，标题为《以 Kubernetes 原生方式加密密钥》。

就像 Kubernetes 的`kms`提供程序一样，CSI 密钥存储遵循相同的最小要求，以拥抱 DevSecOps 模型，包括以下内容：

+   一个原生的 CSI 模型，供平台团队实现与外部保管服务的简单连接

+   通过原生 Kubernetes API 对象提供的自服务模型，供应用团队使用密钥

+   度量、日志记录和密钥自动旋转，以遵守安全法规和框架

+   从路线图的角度来看，以及当前实施状态，可以在此查看：[`secrets-store-csi-driver.sigs.k8s.io/design-docs`](https://secrets-store-csi-driver.sigs.k8s.io/design-docs)

CSI 密钥存储项目是一个优雅且原生的解决方案，越来越受欢迎，甚至已经完全集成到企业 Kubernetes 发行版中，如 Red Hat OpenShift 版本 4.14。

## 外部解决方案

在上一节中，我们查看了 Kubernetes 项目的原生解决方案的路线图，因为它们是开源的。然而，在这里做这件事比较困难，因为并非所有解决方案都是开源的。

我们在本手册中审查的外部解决方案是最常见的，它们在各自领域处于领先地位，或是云服务提供商的原生解决方案。

与 Kubernetes 项目类似，这些生态系统解决方案正在迅速发展，以支持更多的模式并改善业务连续性规划，但更重要的是，提升平台和运行在其上的应用程序的安全态势。

由于解决方案的种类繁多，我们在撰写时暂时聚焦于一个例子。HashiCorp 最近推出的 Vault Radar 提供了扫描器，可以识别应用程序代码中泄漏或硬编码的 Secrets。Vault Radar 为安全暴露提供了修复路径，并通过风险优先级对其进行排序。

在提升和维护安全态势的过程中，随着多云架构的普及，识别敏感信息的扩散对于减少攻击面至关重要。

# Kubernetes 的未来状态

在考虑某个软件或解决方案的未来状态时，有两个考虑因素：

+   与特定、未来和缺失的用例相关的需求或愿望

+   现有路线图、其与当前架构的关系以及如何纳入未来的增强功能

正如我们在本手册中所观察到的，没有一个软件能解决所有需求。它通常涉及将多个项目结合起来，组成一个解决方案，朝着我们的最终目标迈进，同时管理 Kubernetes 平台和运行在其上的应用程序的密钥。因此，让我们对未来可能期望的解决方案进行一个以解决问题为驱动的概述。

## 思考的食粮和增强功能

从 Kubernetes 项目提供的原生栈开始，提议的变更和路线图已在 KEP-3299 中进行了文档记录。负责 CSI Secrets Store 的 SIG 设计文档也同样如此。

一般来说，尽管我们对 Kubernetes 的 API 驱动设计表示尊重，但以下主题将非常受欢迎：

+   `aesgcm`和`aescbc`带来了一系列挑战，这些挑战相对增加了实现的复杂性，暴露了它们的加密密钥或缺乏商业版 KMS 插件来提供企业支持和服务。此变更不仅有助于加密存储在`etcd`中的敏感数据负载，还可以加密来自 API 对象的任何其他数据负载。例如，部署定义可能会提供关于平台和应用程序的足够有价值的信息，供恶意攻击者利用。

+   **动态密钥**：根据特定场景更新密钥的能力，这是符合大多数（如果不是所有）法规和框架的要求。相关的努力正在通过以下倡议进行考虑：

    +   KEP-3299 在加密轮换自动化方面具有优先权，以减少潜在的攻击。

    +   CSI Secrets Store 会在外部源发生变化时触发机密负载的更新。

    +   虽然前两个点可以观察并操作密钥或机密的生命周期，但审核机密负载的实际使用情况和唯一性将大大有助于减少相同负载在多个平台和应用程序中的扩散，从而在相关负载被泄露时避免大规模曝光。

+   `etcd` 以避免潜在的安全暴露，那么用外部保险库替换该数据存储，利用 Kubernetes KMS 插件提供者如何？这将大大减轻知识负担、时间和知识成本以及维护工作。

+   `etcd` 数据存储。此类解决方案的前提是将多个服务实例（至少三个以满足明显的高可用性要求）绑定到定义的网络段，并且在该网络段的边界内存储部分加密密钥。采用这种加密密钥服务模型，并结合使用`aesgcm`和`aescbc`，可以比现在更安全，且部署外部服务的数量有限。

+   **丰富日志功能**：通过**安全信息与事件管理**（**SIEM**）系统，可以从与机密相关的角度提供更详细的安全态势视图。这通常是企业组织的请求，它们希望利用集中日志系统的强大功能，关联事件，并在安全事件响应过程中迅速审核潜在受影响的系统，尤其是考虑到多平台和多云架构中对象的扩散。

这些是你在阅读本手册并实现共享解决方案后可能想到的五个例子。

## 如何分享你的想法

我们都有改进可用性和支持组织生存的需求。就像之前的五个例子一样，这些可能尚未在任何软件项目和供应商的增强请求、路线图或设计文档中提到。

那么，我们如何影响开发呢？一般规则是打开问题或工单来表达你的增强请求。

对于专有解决方案，可以通过联系供应商并请求开放与您的增强请求相关的工单来进行翻译，这可能（也可能不会）进入供应商的工程组织。在这个阶段，类似请求的发展过程和跟踪黑洞活动的方式差不多。

对于开源项目，包括 Kubernetes，过程更加开放。首先，建议你在 Slack 上或在聚会上与相关 SIG 讨论你的想法。这将帮助你发现是否有类似的工作流正在进行，你可以参与，或者是否值得将其介绍给 Kubernetes 项目开发团队。

在这个阶段，下一步是创建一个新的 GitHub 问题。让我们看看 GitHub 问题 #111532，关于 Kubernetes API 服务器默认行为如何处理 `EncryptionConfiguration` API 对象：

*你希望添加什么？*

*EncryptionConfiguration API 对提供商列表的当前行为是基于顺序的，因此 API 服务器必须重新启动才能识别新定义的顺序。*

*举个例子，我们可以考虑从* *这个定义开始：*

```
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - identity: {}
      - kms:
          name: myKmsPlugin
          endpoint: unix:///tmp/myKmsPlugin.sock
          cachesize: 100
```

*迁移到以下内容将需要重新启动 API 服务器：*

```
---
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - kms:
          name: myKmsPlugin
          endpoint: unix:///tmp/myKmsPlugin.sock
          cachesize: 100
      - identity: {}
```

*通过提案 #111405，所需的构造支持* *此实现。*

*为什么* *需要这样做？*

*当前行为是服务视角中的中断来源，要求具备提升权限的用户，并且不允许在托管 Kubernetes 环境中利用 KMS 提供商的插件功能（无法访问控制* *平面节点）。*

*此更改将改善以下方面：*

+   *第二天操作；将 EncryptionConfiguration API 移动到常规 CRUD* *API 对象*

+   *通过避免重新启动* *API 服务器，增强韧性和服务持续性*

+   *使用 KMS 提供商插件来管理* *Kubernetes 服务*

关于 GitHub 问题 #111532 的说明

这个例子是来自本书 GitHub 仓库的原始摘录，未经语言修正或格式化处理。

模板很简单 —— 明确解释“做什么”和“为什么”，并附上清晰的例子，如果可能，提供如何操作以及代码来说明更改。

Kubernetes SIG 认证负责 KMSv2 实现，接手了 GitHub 问题 #111532，并通过实施 GitHub #111919 的代码更改解决了增强请求。此更改的结果是，当修改 `EncryptionConfiguration` API 对象时，可以重新加载配置而无需重新启动 Kubernetes API 服务器。

以下链接将为你提供直接访问资源的途径，帮助你为 Kubernetes 项目做出贡献：

+   如何联系 Kubernetes 社区：[`kubernetes.io/community/`](https://kubernetes.io/community/)

+   Kubernetes GitHub 组织：[`github.com/kubernetes`](https://github.com/kubernetes)

+   Kubernetes SIGs：[`github.com/kubernetes-sigs`](https://github.com/kubernetes-sigs)

+   GitHub 问题 #111532 作为示例：[`github.com/kubernetes/kubernetes/issues/111532#issue-1321971248`](https://github.com/kubernetes/kubernetes/issues/111532#issue-1321971248)

+   GitHub issue #111919 用于解决增强功能 #111532：[`github.com/kubernetes/kubernetes/issues/111919`](https://github.com/kubernetes/kubernetes/issues/111919)

尽管对于一个如此庞大的项目来说，提出一个问题可能显得有些令人生畏，但围绕 Kubernetes 的开源社区一直在为任何人分享想法和经验创造安全空间。现在轮到你来贡献了！

# 持续改进

本手册采用了持续改进的方法，考虑了 DevSecOps 最佳实践。在设计、架构、实施和保护任何平台或软件时，应该考虑各种原则。让我们来看看。

## 技能获得

大多数安全暴露都与知识或意识的缺乏有关。DevSecOps 的一个原则是跨团队协作，成员可以分享他们的经验和发现，因为他们共同承担着确保最终用户和客户的系统安全的责任。

参加培训、网络研讨会和聚会应该是任何组织的优先事项，以理解安全性的重要性并提升其安全态势。

最后，通过分享经验、知识、代码和想法，贡献开源项目，回馈组织。

## 及早开始，快速失败，持续迭代

大多数组织在构建基础设施时仍倾向于采用瀑布式方法，缺乏创新。

尽管这种项目方法论对于许多领域都是有效的，但如果等到最后时刻再实施解决方案，可能会导致显著的延迟，产生次优结果，甚至更糟，项目失败。

另一个考虑采用这种方法论的原因是，在过去二十年里，构建新平台的创新受限。因此，Kubernetes 的采用往往伴随着遗留模式的痕迹，导致实施效果不佳或给应用和运维团队带来额外负担。

对于像 Kubernetes 这样的云原生平台，一个好的实践是及早开始实施，确保所有利益相关者参与其中，并与项目一起学习，持续反馈成功、失败和未来的改进。这将形成一种混合项目模型，兼顾瀑布式和敏捷项目管理风格，从而满足企业对规划和加速交付的需求。

## 自动化作为策略，Everything as Code (EaC)

大多数安全漏洞都与缺乏自动化有关。当团队在处理安全问题或事件时，通常是在系统上执行任务，将其记录在工单中，工作就此止步。

作为最佳实践，实施系统的每一个动作都应该被编码、通过源代码修订系统进行审查，并且自动化。包括所有团队的活动，因为从安全角度来看，它们都对现有程序以及与事件或新发现的漏洞相关的未来程序负责。

从那里开始，需要不断地进行偏差检测，以确保所有系统都能及时更新最新的安全修复。

一个好的实践是将**一切视为代码**（**EaC**）用于自动化你的基础设施、应用程序、治理、合规性和安全性。这样做时，整个堆栈，从硬件到运行在容器中的应用程序，再到业务连续性计划，都可以成为你的**持续集成与持续交付**（**CI/CD**）流水线的一部分。这种方法将充当防止在不安全平台上部署关键应用程序的守门人。

## 威胁建模

威胁建模在平台和应用程序的实施与部署过程中，能够及早识别潜在的安全威胁和漏洞。安全团队应成为每个领域核心团队的一部分，帮助发现可能出错的地方，并规划相关的缓解措施。

通过借助适当的工具和协作文化，威胁建模有助于创建一个积极主动的安全态势，从而减少甚至防止重大安全问题在成为现实之前发生。

## 事件响应

在实施所有这些预防措施时，安全事件将会发生或后续发生。DevSecOps 实践包括响应计划，以简化一旦检测到安全事件后如何处理。安全团队将通过定义角色、沟通渠道以及采取的行动来培训组织，以遏制和缓解安全风险。

事件响应不仅仅是一个文档化的过程，它应该是一个定期的演练，能够随机触发，并且可以像锁盾演习一样通过游戏化的方式提升团队的能力，尤其是在面对网络攻击时。

这里有一个链接，展示了国际层面的年度“锁盾”演习：[`ccdcoe.org/exercises/locked-shields/`](https://ccdcoe.org/exercises/locked-shields/)。

# 总结

恭喜你——你做到了！你已经阅读了本手册，它作为任何采用 Kubernetes 并关注密钥管理话题的组织的参考。通常从传统平台的角度来看，这一问题似乎是可控的，但对于作为领先云原生容器平台的 Kubernetes 来说，情况完全不同。

本手册提供了一个全面的技术示例 walkthrough，讲解如何应对挑战、回答业务连续性的问题，并提供有关审计和合规的必要考虑。但是，如果这些内容被视为一次性实施的终极目标，而不是采纳 DevSecOps 思维方式，它们将不具有太大意义。

尽管大多数人将 DevSecOps 视为一个流行词，但它是一个根本性的转变，组织可以通过这一转变快速学习并采用新技术。这种方法需要支持组织基础设施的各团队之间的跨部门协作。通过培养*分享即关怀*的文化，自动化安全策略、检查和修复的任务将成为一种自然而然的活动，无需将安全视为创新的瓶颈。

采纳本手册中分享的文化、流程和技术将使组织能够更快速、更安全、更可靠且符合合规性地向客户交付价值。

技术是简单的，不应成为组织变革的替代品。希望本书能够帮助你选择合适的工具集来管理你的秘密，并激发你在注入 DevSecOps 文化和持续变革的旅程中的转型。
