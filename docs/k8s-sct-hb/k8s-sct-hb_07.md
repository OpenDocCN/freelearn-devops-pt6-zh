

# 第七章：管理 Secrets 的挑战与风险

在 Kubernetes 环境中管理 Secrets 是保护敏感信息（如 API 密钥、密码和凭据）的关键组成部分。有效管理 Secrets 可以帮助防止未经授权访问重要信息，并确保 Kubernetes 集群中服务的正常运行。然而，这项任务也伴随着一系列挑战和潜在的安全风险，需要得到妥善处理。在本章中，我们将探讨管理 Kubernetes 中 Secrets 的各种挑战和风险，并讨论缓解策略，以增强 Secrets 的安全性。

到本章结束时，您将全面了解与 Kubernetes 中 Secrets 管理相关的挑战和风险。更重要的是，您将学到实际的策略来减轻这些风险，从而能够在 Kubernetes 环境中以安全高效的方式管理 Secrets。

在本章中，我们将涵盖以下主要主题：

+   理解 Kubernetes Secrets 及其安全风险

+   不同阶段管理 Secrets 时的挑战和风险

+   安全风险的缓解策略

这些信息将使您能够有效应对 Kubernetes 中 Secrets 管理的复杂性，确保敏感数据的机密性和完整性，并最终增强您 Kubernetes 应用的整体安全性。

# 技术要求

要跟随本章内容并实施所讨论的策略和实践，您需要以下技术和安装：

+   **Kubernetes 集群**：您将需要一个工作中的 Kubernetes 集群来管理环境中的 Secrets。您可以使用托管的 Kubernetes 服务，如 **Amazon Elastic Kubernetes Service**（**Amazon EKS**）、**Azure Kubernetes Service**（**AKS**）或 **Google Kubernetes Engine**（**GKE**），或者使用 minikube 或 Kind 设置本地集群。

+   **kubectl**：这是 Kubernetes 命令行工具，可以让您与 Kubernetes 集群进行交互。它是部署和管理集群资源的必备工具。

+   **Secrets 管理工具**：需要具备如何使用内部或外部工具管理 Secrets 的基本了解，或熟悉如 HashiCorp Vault、CyberArk、AWS Secrets Manager、Azure Key Vault 和 GCP Secret Manager 等工具。此外，建议您在阅读 *第八章*、*第九章* 和 *第十章* 后，重新阅读本章作为参考。

# 掌握 Secrets 管理系统的复杂性

Secrets 管理系统从 *简单工具到复杂实体* 发展，过程中面临独特的挑战和风险。这个过程包括多个阶段：

+   设置 Secrets 管理系统

+   实施细粒度访问控制

+   与目录服务集成

+   解决跨领域的关注点，如弹性、可用性和审计

+   符合合规性和监管要求

在 Secrets 管理系统的初始阶段，主要挑战是建立一个具有安全存储和加密的基本结构。在这一阶段，访问控制仅限于专属的管理访问，主要的安全风险涉及安全存储和加密的基本问题。这里的挑战是明确划分谁有管理员访问 Secrets 的权限。

随着系统的扩展以适应用户和服务调用者，挑战变得更加复杂。实施细粒度访问控制至关重要；这一点必须在不造成安全漏洞的情况下完成。此阶段还引入了认证风险，特别是在管理人工认证与机器或服务认证时。

下一阶段涉及与各种平台的集成，如**活动目录**、**轻量级目录访问协议**（**LDAP**）或**特定操作符**。这带来了新的挑战和风险。集成挑战包括确保无缝集成而不产生新的漏洞。同步数据时，尤其是在与像 LDAP 这样的系统进行同步时，*数据同步*也存在风险，特别是在保持数据完整性方面。*委托授权*，即将授权委托给其他系统并确保其安全，也提出了另一个挑战。

第四阶段引入了可用性功能、弹性、可用性和审计。在这一阶段，挑战包括安全地加密和访问远程备份，设计强大的灾难恢复计划（**DR**），以及实施安全和合规的审计跟踪。平衡可用性与安全性也成为需要解决的风险。

最后，第五阶段涉及遵守法规。这里的挑战是与法规对接，而不妨碍功能性。还存在与管理长期存储的法律要求相关的长期存储风险。这个阶段对于确保 Secrets 管理系统的持续合法性和安全性至关重要。

Secrets 管理系统的开发历程在每个阶段都会带来新的挑战和风险。从最初关注基本安全到复杂的集成、可用性增强、弹性、审计和合规，每一步都增加了复杂性。理解这些方面对于管理 Secrets 至关重要，特别是在像 Kubernetes 这样的环境中，Secrets 管理必须足够强大和灵活，以满足各种需求。

# 秘密管理中的一般安全风险

在第一部分探讨了秘密管理系统的基本机制和复杂性之后，我们将转向详细审视这一领域内具体的安全风险。本部分深入探讨了组织在管理秘密时面临的实际挑战。从单一主密钥问题到访问控制的增长与委派，再到与其他平台的集成，这些挑战需要周密的策略和解决方案。跟随我们一起分析这些安全风险，提供对其复杂性的洞察，并给出缓解策略的指导。

## 秘密零

秘密零指的是所有秘密都受到一个单一主密钥或最终秘密的保护，这个密钥控制着一切，就像传说中的“*王国的钥匙*”。

想象一下将所有密码存储在云端，并由一个单独的密码保护。然后，为了增加便利性，你将这个主密码放在云中的一个文本文件里。现在，黑客只需要发现或猜出这个密码，就能解锁一切。这个主密钥被称为“*秘密零*”。它就像是将所有鸡蛋放在一个篮子里，或者将所有钥匙锁在抽屉里，而抽屉的钥匙则在你口袋里。仅仅保护你的秘密是不够的；对这些秘密的访问也必须得到保护。

这种设置会形成一个重要的攻击点。这个密钥如果被泄露，攻击者将可以不受限制地访问，因为它能解锁其他所有内容。想象一下，你所有的密码和敏感数据都被锁在一扇门后，而这扇门的钥匙就放在门垫下。这就是秘密零的严重性。

### 风险与挑战

秘密零存在一些风险，缓解这些风险是具有挑战性的：

+   **单点故障（SPOF）**：主密钥成为恶意攻击者的诱人目标。如果他们获取了这个密钥，就能访问一切。

+   **管理主密钥的复杂性**：保护这个主密钥变得至关重要且富有挑战性，因为其泄露可能会带来灾难性的后果。

+   **潜在的内部威胁**：拥有主密钥访问权限的员工或利益相关者可能会故意或无意地滥用该密钥。

+   **合规问题**：根据不同的监管环境，拥有单一主密钥可能会违反某些标准或最佳实践。

### 秘密零的解决方案

为了增强主密钥的安全性，一项有效措施是使用**多因素认证**（**MFA**），它通过要求多种身份验证方式才能授权访问，增加了安全性。另一种策略是*密钥分割*，即将主密钥分成几部分并分开存储，确保泄露一部分不会导致完全访问。除此之外，**硬件安全模块**（**HSM**）可以用来存储主密钥或其碎片，增加了一层物理保护以防止未经授权的访问。此外，**夏密尔秘密共享**（**SSS**）提供了另一种强大的技术。这种方法高效地将私密信息（“*秘密*”）分配给一个小组，确保除非小组中的多数成员共同行动，否则秘密无法泄露。最后，持续监控未经授权的访问尝试，以及定期审计访问日志，有助于及早发现可疑活动。

此外，对于像 AWS、Azure 和 GCP 这样的公共云提供商，由于现有的身份和访问机制管理角色和权限，秘密零问题通常不存在。但在本地或私有云环境中，问题依然存在，需要采取措施确保单一的秘密不会被窃取。

一些供应商选择使用 API 密钥和其他机器参数（如 CPU ID 或 IP 地址）进行机器身份验证。但这些方法可能会受到攻击——API 密钥可以被窃取，IP 等参数可能会被伪造，从而无法解决秘密零问题。

## 秘密访问膨胀

*秘密访问膨胀*指的是 IT 组织中对秘密信息访问的无理扩展。最初，秘密可能只由一个特定的 LDAP 组访问；然而，随着时间的推移，该组的规模可能会扩大，甚至包括其他子组，从而将访问人数从最初的几个个体膨胀到数百人。这种情况可能发生在外部工程师需要一次性访问某些秘密时，但并没有仅授予临时访问权限，而是某人将整个组添加为管理员，导致组人数急剧增加。以下示例说明了这种情况的发生：

+   **组增长示例**：一个最初由 10 人组成的 LDAP 组，增长到 400 人，包含多个子组，失去了其细粒度和特定性。

+   **管理员组扩展示例**：外部工程师被添加为临时管理员，但仍然留在该组中，导致管理员组呈指数级增长。

### 风险与挑战

对秘密访问的无差别扩展会随着时间的推移带来不断增加的风险：

+   **细粒度控制丧失**：如第一个示例中所示，从 10 人增长到 400 人，导致对谁有权访问秘密失去精确控制。

+   **暴露于威胁的增加**：将外部工程师增加为永久管理员会增加秘密被意外披露或滥用的风险。

+   **管理复杂性**：管理膨胀的访问权限变得越来越复杂且耗时。

+   **合规性问题**：访问权限的爆炸性增长可能导致违反合规性规定。

### 解决秘密访问膨胀问题

为了管理日益增加的秘密访问风险，可以采取几种策略。一项有效的措施是实施严格的组策略，例如防止在管理员组内创建子组，因为这有助于保持对秘密访问的控制。此外，定期扫描访问权限和组成员身份，可能每隔几周或几个月一次，可以帮助在问题变得严重之前识别出访问权限膨胀的情况。此外，实施**基于角色的访问控制**（**RBAC**）可确保用户仅能访问与其角色相关的信息，从而进一步减少秘密访问膨胀的风险。同时，**即时访问**（**JIT**）是一种安全方法，它限制了对应用程序或系统的访问，仅在特定的、需要的时间段内进行。另一方面，逐步认证要求用户进行与保护资源需求相等或更高级别的认证。

最后，将访问增长作为衡量指标进行追踪，反映任何增加的情况，并将这些指标与既定标准进行对比，可以作为访问膨胀的早期预警信号。这可以使组织在访问膨胀成为安全风险之前采取行动。

## 秘密代客泊车

在现代技术环境中，*秘密代客泊车*概念展示了一种常见的委托管理模式，用于管理机密信息。类似于将车钥匙交给代客泊车员，秘密被交给一个集成的子系统，该子系统将秘密传输到主机的文件系统中，以供特定工作负载或任务使用。

例如，在**持续集成**（**CI**）系统中，这可能涉及获取构建、测试和部署代码所需的所有秘密。虽然这种方法简化了工作流程，但必须小心管理，确保在秘密的用途完成后将其安全删除，就像代客泊车员停车后归还车钥匙一样。

这种便利性与安全性之间的微妙平衡反映了机密管理的复杂挑战，并生动地展示了在处理如秘密等关键资产时所需的信任、责任和小心。

### 风险与挑战

与秘密代客泊车概念相关的主要关注点和风险：

+   **委托身份问题**：信任子系统正确管理秘密需要信任该子系统在不再需要时能够安全删除文件中的秘密。如果未能做到这一点，秘密将暴露。

+   **缺乏强制执行机制**：如果没有适当的检查，无法保证集成系统在使用后成功删除秘密，从而可能导致未授权访问。

+   **爆炸范围问题**：如果密钥被提取并存储在整个主机上，而不仅仅是当需要时提取，它可能在主机或特定模块被攻击时导致广泛曝光的风险。

### 秘密代客停车的解决方案

为了降低与秘密代客停车相关的风险，可以采取几种策略。一个有效的方法是实施动态密钥，这些密钥按需生成，并且仅在短时间内有效，只有在特定工作负载需要时才提取密钥。使用后，这些密钥会被失效，从而最小化未授权访问和泄露的风险。

另一种方法是建立一个*监控和验证系统*，该系统持续观察并确认秘密的删除，确保符合预期的秘密处理协议。另一种方法是*仅在特定工作负载需要时提取秘密*。这可以最小化潜在的爆炸范围，减少不必要的暴露以及未授权访问的风险。最后，*定期进行秘密管理流程的审查和审计*可以确保遵守最佳实践，并识别在管理秘密方面的潜在改进。通过结合这些策略，组织可以减少与秘密代客停车相关的风险，并改善其整体安全态势。

## 秘密泄露

当提到*秘密泄露*时，我们指的是秘密在我们基础设施各个部分的广泛分布。这些秘密被分散并存储在许多地方，导致在管理和审计合规性时面临重大挑战。通常，您可能会发现一个数据库的用户名和密码被硬编码在应用程序的源代码中。它也可能以明文形式出现在配置文件中、配置管理中、版本控制中、Dropbox 账户中或 Wiki 中。从本质上讲，这些秘密分散在整个基础设施中，存在于不同的位置。

### 风险与挑战

阅读前面的内容就足以开始识别当秘密分散在整个基础设施中时可能出错的地方，包括以下几个方面：

+   **缺乏知识**：秘密无处不在，追踪它们几乎不可能。

+   **访问控制有限**：传统系统没有保持详细日志，也没有提供足够的访问控制，导致安全风险。

+   **泄露响应**：在发生泄露时，找出源头并处理问题变得复杂，尤其是当秘密被硬编码在应用程序源代码中时。

### 秘密泄露问题的解决方案

解决方案在于*集中化*。通过将密钥集中到一个具有严格控制的单一位置（例如 HashiCorp Vault 和 CyberArk），其管理变得更加安全。可以根据需要限制访问，并且审计日志提供详细信息，简化了对泄露的响应以及凭证管理的整个生命周期。

## 秘密岛屿

*秘密岛屿*指的是一种工具或平台，配备了用于管理密钥、访问控制、审计、合规性等的内置组件，但与其他工具缺乏互操作性，也没有集中管理策略和数据。

### 风险与挑战

在使用具有上述特征的工具时，以下风险和挑战可能会显现：

+   **隔离**：它将子系统隔离开来，使得整体密钥管理变得更加困难。如果没有细粒度的访问控制或安全存储，你必须处理零散的密钥，而没有集中式的监督。

+   **缺乏整合**：在安全岛屿中，你失去了整合审计和控制的能力。管理子系统变得混乱，缺乏对安全环境的统一视图。

+   **可扩展性问题**：例如，在 Jenkins CI/CD 流水线和 AWS 中使用不同的密钥来部署应用程序，最初可能会有效，但随着复杂性增加，可能变得难以管理且不安全。

+   **人类安全岛屿**：也叫做*影子 IT*，当安全变得过于复杂时，团队可能会绕过官方政策，进一步恶化安全态势。*例如*，想象在 Jenkins 中为暂存和生产环境使用不同的凭证，同时使用 AWS Secrets Manager 管理数据库密钥和 API 密钥。扩展这种配置变得十分困难，尤其是在委派、管理和审计方面。增加另一个团队、多个云平台，或者处理密钥一致性问题，只会加剧这一问题。

现在，让我们来看一下应对这一挑战的解决方案。

### 解决秘密岛屿问题的方案

为了降低与秘密岛屿相关的风险，实施集中式密钥管理至关重要。集中管理密钥使组织能够执行一致的策略，简化操作，并清晰地了解其整体安全环境。此外，制定标准化的安全协议，并强制各个秘密岛屿遵循，可以确保一致性并减少漏洞。利用允许不同秘密岛屿进行沟通和互动的集成工具和 API，可以帮助打破孤岛，推动更加统一的方法。定期进行安全审计和持续监控对于发现和纠正秘密岛屿中的不一致性和漏洞至关重要。此外，促进管理秘密岛屿的团队之间的沟通与协作，能够进一步增强组织的整体安全态势。通过这些缓解策略，组织能够有效应对秘密岛屿带来的挑战。

在管理秘密的关键领域，本部分深入探讨了几个既独立又相互关联的挑战和风险。从*秘密零*的问题，其中单点故障（SPOF）可能会危及整个系统，到*秘密访问膨胀*的问题，其中对访问控制的管理可能变得难以掌控，这些复杂性具有多面性。*秘密代客泊车*突出了集成系统中的信任与委托问题，而*秘密蔓延*和*秘密孤岛*则探讨了在日益复杂的环境中保持系统一致性和互操作性的问题。总的来说，这些话题强调了处理秘密时所需的细致且常常脆弱的平衡，突出了战略规划、警觉性和强大解决方案的必要性。

在上一节中，我们已经概述了与一般秘密管理相关的广泛挑战和风险，现在我们将重点讨论 Kubernetes（也称为 K8s）环境中的具体问题。

# 管理 Kubernetes 秘密的挑战和风险

Kubernetes 在秘密管理方面呈现出一系列独特的挑战和风险。本节将深入探讨在 Kubernetes 环境中管理秘密的具体细节，分析这一广泛使用的编排平台的独特特性和漏洞。请加入我们，一起探索 Kubernetes 秘密的复杂性，认识到其中的独特难题和应对这些问题的定制策略。

在进一步讨论之前，澄清一些与 Kubernetes 和秘密管理相关的概念是很重要的。Kubernetes 提供了一种名为“*秘密*”的原生资源类型，但使用 Kubernetes 的原生秘密资源并不是在 Kubernetes 环境中管理秘密的唯一方式。

在本节中，我们将讨论 Kubernetes 中两种不同的秘密管理方法：

+   **直接使用 Kubernetes 原生秘密**：这种方法涉及将 Kubernetes 内置的秘密资源作为秘密管理的主要机制。

+   **利用 Kubernetes 原生秘密作为最终状态**：这种方法使用 Kubernetes 的原生秘密资源作为 Kubernetes 平台内秘密消费的最终状态。从 Kubernetes 作为平台的角度来看待安全风险至关重要。

Kubernetes 的原生 Secrets 资源存储在 `etcd` 中，这是 Kubernetes 对象的主要数据存储。默认情况下，这些 Secrets 使用 `base64` 编码；它们没有加密，使得任何能够访问 `etcd` 的人都可以解码。未经授权访问集群的 API 服务器或运行使用这些 Secrets 的工作负载的节点，也会带来风险。为了增强安全性，Kubernetes 允许为 `etcd` 配置静态加密。有关启用和配置此加密的详细说明，请参阅官方 Kubernetes 文档：*加密静态数据* ([`kubernetes.io/docs/tasks/administer-cluster/encrypt-data/`](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/))。

此外，还有一些场景，其中外部 Secrets 管理系统在运行时直接将 Secrets 提供给 Kubernetes 工作负载。在这种情况下，大多数安全问题通常由 Secrets 管理工具处理，相关的安全风险可能会根据具体情况有所不同。有关 Secrets 管理的通用安全风险的更多信息，请参阅上一节。

## 管理 Kubernetes Secrets 的安全风险

Kubernetes Secrets 面临多个安全风险，包括在集群的 API 服务器或节点中的暴露。默认情况下，Secrets 存储在 `etcd` 中，这是 Kubernetes 对象的主要数据存储，使用 `base64` 编码，但没有加密。这使得任何可以访问 `etcd` 的人都可以轻松读取它们。此外，未经授权访问集群的 API 服务器或节点也可能导致 Secrets 的暴露。

Root 利用是另一个重要的风险。Kubernetes 并不会按 *知情必要* 的原则发送 Secrets。因此，任何具有根权限的节点用户都可以通过伪装成 kubelet 来读取任何秘密。

Secrets 通常会在 Kubernetes 清单中暴露。它们通常使用 JSON 或 YAML 文件配置，且密钥以 `base64` 编码。如果这些文件被共享或提交到仓库中，秘密就会被泄露。

通常，控制平面到工作节点 kubelet 的通信采用 TLS 模式，但 Kubernetes 没有原生功能加密跨节点传输的数据。重要的是在直接使用 Pod 时使用 Secrets，而不是在不传输的情况下转移 Secrets。

在 Kubernetes 中，虽然默认的 Secrets 管理系统允许使用 RBAC 创建自定义角色和绑定，但必须小心避免授予过于宽泛的权限，例如对所有资源包括 Secrets 的 "`*`" 权限。自定义角色应专门设计用于控制对 Secrets 的访问，定义谁有权查看、创建、编辑或删除它们。

日志记录和审计问题带来了额外的挑战。一旦机密被访问，它可能以明文形式记录，或者被传输给不受信任的方，从而使其易受攻击。此外，Kubernetes 并未提供针对 Secrets 的直接审计或变更管理功能。

最后，在 Kubernetes 中，由于缺乏零信任机制，机密访问通常是以未加密的形式由授权人员访问。这种情况表明需要更严格的访问模型。在这种模型中，即使是授权人员也应以确保安全的方式处理 Secrets，以符合零信任原则，即在每个阶段都进行验证。

# 缓解策略

在 Kubernetes 环境中保护和管理机密信息时，应考虑多个策略。

首先，推荐使用具有先进安全功能的集中式机密存储来管理 Kubernetes Secrets。这种方法不仅可以减少未经授权访问的风险，还可以简化管理过程，并提供全面的安全态势视图。常用的工具包括 HashiCorp Vault、CyberArk、AWS Secrets Manager 和 Azure Key Vault。

此外，应使用 Kubernetes 平台特定的配置来限制潜在的风险因素：

+   禁用 Pod 的 root 用户，方法如下：

    ```
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx-sample
      labels:
        app: nginx
        environment: production
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: nginx
      template:
        metadata:
          labels:
            app: nginx
        spec:
          containers:
          - name: nginx
            image: nginx:latest
            ports:
            - containerPort: 80
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              runAsNonRoot: true
          restartPolicy: Always
    ```

+   加密 Secrets，无论是在传输中还是静态存储中，都是至关重要的。Kubernetes 原生的机密加密或第三方工具可以实现这一点。加密确保即使发生未经授权的访问，机密数据仍然无法被解密，除非拥有适当的解密密钥。

    以下是启用 `EncryptionConfiguration` 的示例用法：

    1.  将您的 `EncryptionConfiguration` YAML 文件放置在 Kubernetes API 服务器运行的主节点上。

    1.  修改 API 服务器的启动参数，包含 `--encryption-provider-config`，并指向您的 `EncryptionConfiguration` YAML 文件的文件路径。

    执行以下命令启用它：

    ```
    kube-apiserver --encryption-provider-config=/etc/kubernetes/encryption-config.yaml
    ```

    启用 API 服务器的加密配置后，您现在可以配置在 Kubernetes 集群中使用加密资源，如 Secrets：

    ```
    ---
    #
    # CAUTION: this is an example configuration.
    #          Do not use this for your own cluster!
    #
    apiVersion: apiserver.config.k8s.io/v1
    kind: EncryptionConfiguration
    resources:
    - providers:
      - aesgcm:
          keys:
          - name: key1
            secret: c2VjcmV0IGlzIHNlY3VyZQ==
          - name: key2
            secret: dGhpcyBpcyBwYXNzd29yZA==
      resources:
      - secrets
    ```

+   严格的访问控制至关重要。推荐通过像 RBAC 这样的机制来限制对 Secrets 的访问。重要的是定义细粒度的权限，明确谁可以访问、创建或修改 Secrets。

    在 Kubernetes 中，针对秘密访问的具体审计涉及详细记录每次与秘密资源交互的日志。审计捕获关键信息，例如谁访问了秘密，何时访问，以及访问的性质。审计帮助管理员确定每个操作的具体细节，如发生了什么、何时发生、谁发起了操作，以及其来源和目的地。监控和审计对于监督秘密访问、时机和目的至关重要，有助于及时调查可疑活动以保护 Secrets。标准审计记录应显示谁在何时访问了什么。在 Kubernetes 中，所有对 Secrets 的访问都应进行记录，这些日志可用于在潜在泄露的情况下进行事件应对。

    一个针对秘密访问的审计日志条目示例如下：

    ```
    {
      "kind": "Event",
      "apiVersion": "audit.k8s.io/v1",
      "metadata": {
        "creationTimestamp": "2023-12-01T12:34:56Z"
      },
      "level": "Metadata",
      "timestamp": "2023-12-01T12:34:56Z",
      "auditID": "abcd1234",
      "stage": "ResponseComplete",
      "requestURI": "/api/v1/namespaces/default/secrets/mysecret",
      "verb": "get",
      "user": {
        "username": "admin",
        "groups": ["system:masters", "system:authenticated"]
      },
      "sourceIPs": ["192.0.2.0"],
      "objectRef": {
        "resource": "secrets",
        "namespace": "default",
        "name": "mysecret",
        "apiVersion": "v1"
      },
      "responseStatus": {
        "metadata": {},
        "status": "Success",
        "reason": ""
      }
    }
    kube-apiserver --audit-policy-file=/etc/kubernetes/policy.yaml
    ```

    在 Kubernetes API 服务器中启用审计策略后，用户可以配置并指定特定资源访问的输出日志。以访问 Secrets 为例：

    ```
    # Log secrets access within request and response.
    apiVersion: audit.k8s.io/v1
    kind: Policy
    rules:
    - level: RequestResponse
      resources:
      - resources:
        - secrets
    apiVersion: audit.k8s.io/v1
    kind: Policy
    rules:
    - level: RequestResponse
      resources:
        - group: ""
          resources: ["secrets"]
    ```

    可以使用命名空间隔离来分离敏感的工作负载。此外，可以使用网络策略来限制这些隔离命名空间之间的通信，从而减少 Secrets 暴露的潜在风险：

    ```
    apiVersion: v1
    kind: Secret
    metadata:
      name: test
      namespace: test
    type: Opaque
    data:
      password: dGVzdA==
      username: dGVzdA==
    ```

此外，避免将秘密存储在配置文件中（如 JSON 或 YAML 文件），这些文件可能会被提交到版本库或共享也是非常重要的。相反，应该使用环境变量或专用的秘密管理工具来存储秘密。

采纳零信任系统的概念也是一个明智的选择。实施仅在必要时解密秘密的解决方案，并防止任何人直接解密秘密是至关重要的。

在访问 Secrets 后，必须采取预防措施，确保秘密数据不会以明文形式记录或传输给不信任的方。

最后，定期轮换密钥和 Secrets 对于安全至关重要，组织通常遵循审计和合规政策，在设定的间隔（如 30、60 或 90 天）内进行轮换。**国家标准与技术研究院**（**NIST**）提供了关于密钥管理的详细指南，包括最佳实践和管理策略，详见其*《特别出版物 800-57 第一部分，第 5 版》*和*《第二部分，第 1 版》*。这些指南有助于确保即使密钥被泄露，其风险暴露也能最小化，因为它会在长时间内保持不可用状态。

通过采取这些策略，组织可以在 Kubernetes 环境中实现一个强大且安全的秘密管理系统。

# 总结

在本章中，我们集中讨论了机密管理背后的关键概念及其在确保数据保护和安全访问资源中的重要性。我们讨论了机密是如何创建、管理和在应用程序和服务之间共享的。我们探讨了管理机密时面临的关键安全风险、这些风险对机密管理构成的挑战，以及应采取的有效缓解策略。接下来，我们深入分析了 Kubernetes 机密的安全风险，包括在集群的 API 服务器或节点中的暴露、根用户漏洞、传输中缺乏加密、不足的访问控制等问题。随后，我们重点讨论了缓解策略，如使用机密管理工具、加密机密、实施访问控制以及监控和审计对机密的访问。在接下来的几章中，我们将看到如何处理在流行云服务提供商的机密管理和第三方机密管理工具中遇到的敏感问题。

# 第三部分：Kubernetes 机密提供者

在本部分中，您将了解外部机密存储及其在 Kubernetes 中管理机密的优势，以及如何将它们与 Kubernetes 集成。完成后，您将理解不同类型的外部机密存储，如何在 Kubernetes 中配置外部机密存储，并将其与现有的机密管理解决方案集成。

本部分包含以下章节：

+   *第八章**，探索 AWS 上的云机密存储*

+   *第九章**，探索 Azure 上的云机密存储*

+   *第十章**，探索 GCP 上的云机密存储*

+   *第十一章**，探索外部机密存储*

+   *第十二章**，与机密存储的集成*

+   *第十三章**，案例研究与真实世界示例*

+   *第十四章**，总结与 Kubernetes 机密管理的未来*
