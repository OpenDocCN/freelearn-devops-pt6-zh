- en: '*Chapter 1*: Introducing the Operator Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：介绍操作符框架'
- en: Managing a Kubernetes cluster is hard. This is partly due to the fact that any
    microservice architecture is going to be inherently based on the interactions
    of many small components, each introducing its own potential point of failure.
    There are, of course, many benefits to this type of system design, such as graceful
    error handling thanks to the separation of responsibilities. However, diagnosing
    and reconciling such errors requires significant engineering resources and a keen
    familiarity with an application's design. This is a major pain point for project
    teams who migrate to the Kubernetes platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 Kubernetes 集群很难。这部分是因为任何微服务架构本质上都基于许多小组件的交互，每个组件都有可能成为故障点。当然，这种系统设计也有很多好处，比如由于责任分离，能够优雅地处理错误。然而，诊断和解决这些错误需要大量的工程资源，并且需要对应用程序的设计有深入的了解。这是项目团队迁移到
    Kubernetes 平台时的一个主要痛点。
- en: 'The Operator Framework was introduced to the Kubernetes ecosystem to address
    these problems. This chapter will go over a few general topics to give a broad
    overview of the Operator Framework. The intent is to provide a brief introduction
    to the Operator Framework, the problems it solves, how it solves them, and the
    tools and patterns it provides to users. This will highlight key takeaways for
    the goals and benefits of using Operators to help administrate a Kubernetes cluster.
    These topics include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符框架被引入 Kubernetes 生态系统，以解决这些问题。本章将介绍一些基本的主题，提供操作符框架的概览。目的是简要介绍操作符框架、它所解决的问题、解决方法以及它为用户提供的工具和模式。通过这些内容，我们可以总结出使用操作符来帮助管理
    Kubernetes 集群的目标和好处。以下是这些话题的概述：
- en: Managing clusters without Operators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有操作符的集群管理
- en: Introducing the Operator Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍操作符框架
- en: Developing with the Operator **software development kit** (**SDK**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符**软件开发工具包**（**SDK**）进行开发
- en: Managing Operators with the **Operator Lifecycle Manager** (**OLM**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**操作符生命周期管理器**（**OLM**）管理操作符
- en: Distributing Operators on `OperatorHub.io`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`OperatorHub.io`上分发操作符
- en: Defining Operator functions with the Capability Model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用能力模型定义操作符功能
- en: Using Operators to manage applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符来管理应用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not have any technical requirements because we will only be
    covering general topics. In later chapters, we will discuss these various topics
    in depth and include technical prerequisites for following along with them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有任何技术要求，因为我们只会讨论一些通用话题。在后续章节中，我们将深入探讨这些话题，并提供相关的技术前提，帮助你更好地跟随。
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3GKJfmE](https://bit.ly/3GKJfmE)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的《代码实战》视频可以通过以下链接观看：[https://bit.ly/3GKJfmE](https://bit.ly/3GKJfmE)
- en: Managing clusters without Operators
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有操作符的集群管理
- en: Kubernetes is a powerful microservice container orchestration platform. It provides
    many different controllers, resources, and design patterns to cover almost any
    use case, and it is constantly growing. Because of this, applications designed
    to be deployed on Kubernetes can be very complex.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个强大的微服务容器编排平台，提供了许多不同的控制器、资源和设计模式，几乎可以覆盖任何用例，并且它在不断发展。因此，设计部署到
    Kubernetes 上的应用程序可能非常复杂。
- en: When designing an application to use microservices, there are a number of concepts
    to be familiar with. In Kubernetes, these are mainly the native **application
    programming interface** (**API**) resource objects included in the core platform.
    Throughout this book, we will assume a foundational familiarity with the common
    Kubernetes resources and their functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个使用微服务的应用时，有许多概念需要熟悉。在 Kubernetes 中，这些概念主要是核心平台中包含的本地**应用程序编程接口**（**API**）资源对象。在本书中，我们将假设读者对常见的
    Kubernetes 资源及其功能有基本的了解。
- en: These objects include Pods, Replicas, Deployments, Services, Volumes, and more.
    The orchestration of any microservice-based cloud application on Kubernetes relies
    on integrating these different concepts to weave a coherent whole. This orchestration
    is what creates a complexity that many application developers struggle to manage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象包括 Pods、Replicas、Deployments、Services、Volumes 等。任何基于微服务的云应用在 Kubernetes
    上的编排，都依赖于将这些不同的概念整合在一起，形成一个协调一致的整体。这种编排是造成复杂性的原因，许多应用开发者在管理时都会遇到困难。
- en: Demonstrating on a sample application
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在示例应用中进行演示
- en: Take, for example, a simple web application that accepts, processes, and stores
    user input (such as a message board or chat server). A good, containerized design
    for an application such as this would be to have one Pod presenting the frontend
    to the user and a second backend Pod that accepts the user's input and sends it
    to a database for storage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的 web 应用程序为例，它接受、处理并存储用户输入（如留言板或聊天服务器）。这种应用程序的良好容器化设计应该是，设置一个 Pod 来向用户展示前端界面，另一个后台
    Pod 接受用户输入并将其发送到数据库进行存储。
- en: Of course, you will then need a Pod running the database software and a Persistent
    Volume to be mounted by the database Pod. These three Pods will benefit from Services
    to communicate with each other, and they will also need to share some common environment
    variables (such as access credentials for the database and environment variables
    to tweak different application settings).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你将需要一个运行数据库软件的 Pod，以及一个由数据库 Pod 挂载的持久卷。这三个 Pods 将通过服务相互通信，并且它们还需要共享一些公共环境变量（例如数据库访问凭证和用于调整不同应用设置的环境变量）。
- en: 'Here is a diagram of what a sample application of this sort could look like.
    There are three Pods (frontend, backend, and database), as well as a Persistent
    Volume:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例应用程序的图示。它包含三个 Pods（前端、后端和数据库），以及一个持久卷：
- en: '![Figure 1.1 – Simple application diagram with three Pods and a Persistent
    Volume](img/B18147_Figure_1.1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 带有三个 Pod 和一个持久卷的简单应用程序图示](img/B18147_Figure_1.1.jpg)'
- en: Figure 1.1 – Simple application diagram with three Pods and a Persistent Volume
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 带有三个 Pod 和一个持久卷的简单应用程序图示
- en: This is just a small example, but it's already evident how even a simple application
    can quickly involve tedious coordination between several moving parts. In theory,
    these discrete components will all continue to function cohesively as long as
    each individual component does not fail. But what about when a failure does occur
    somewhere in the application's distributed design? It is never wise to assume
    that an application's valid state will consistently remain that way.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小例子，但已经可以明显看出，即使是一个简单的应用程序，也很快会涉及多个活动组件之间的繁琐协调。从理论上讲，只要每个独立组件没有发生故障，这些离散的组件就会继续协同工作。但如果应用程序的分布式设计中某个地方发生故障时，该怎么办呢？假设应用程序的有效状态会始终保持不变是非常不明智的。
- en: Reacting to changing cluster states
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对集群状态变化的反应
- en: There are a number of reasons a cluster state can change. Some may not even
    technically be considered a failure, but they are still changes of which the running
    application must be aware. For example, if your database access credentials change,
    then that update needs to be propagated to all the Pods that interact with it.
    Or, a new feature is available in your application that requires tactful rollout
    and updated settings for the running workloads. This requires manual effort (and,
    more importantly, time), along with a keen understanding of the application architecture.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 集群状态变化的原因有很多。有些可能甚至不被技术上视为故障，但它们仍然是运行中的应用程序必须注意的变化。例如，如果你的数据库访问凭证发生更改，那么该更新需要传递到所有与其交互的
    Pods。或者，如果应用程序中有一个新功能，需要巧妙地进行发布，并更新正在运行的工作负载的设置。这需要手动操作（更重要的是，需要时间），以及对应用程序架构的深入理解。
- en: Time and effort are even more critical in the case of an unexpected failure.
    These are the kinds of problems that the Operator Framework addresses automatically.
    If one of the Pods that make up this application hits an exception or the application's
    performance begins to degrade, these scenarios require intervention. That means
    a human engineer must not only know the details of the deployment, but they must
    also be on-call to maintain uptime at any hour.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生意外故障时，时间和精力变得更加关键。这正是 Operator 框架自动处理的问题。如果构成此应用程序的其中一个 Pod 遇到异常，或者应用程序的性能开始下降，这些场景需要干预。这意味着人工工程师不仅必须了解部署的细节，还必须随时待命以确保系统正常运行。
- en: There are additional components that can help administrators monitor the health
    and performance of their applications, such as metrics aggregation servers. However,
    these components are essentially additional applications that must also be regularly
    monitored to make sure they are working, so adding them to a cluster can reintroduce
    the same issues of managing an application manually.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他组件可以帮助管理员监控应用程序的健康状况和性能，例如指标聚合服务器。然而，这些组件本质上是额外的应用程序，也必须定期监控以确保它们正常工作，因此将它们添加到集群中可能会重新引入手动管理应用程序的相同问题。
- en: Introducing the Operator Framework
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Operator Framework
- en: The concept of Kubernetes Operators was introduced in a blog post in 2016 by
    CoreOS. CoreOS created their own container-native Linux operating system that
    was optimized for the needs of cloud architecture. Red Hat acquired the company
    in 2018, and while the CoreOS operating system's official support ended in 2020,
    their Operator Framework has thrived.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Operators 的概念是在 2016 年由 CoreOS 在一篇博客文章中提出的。CoreOS 创建了他们自己的容器原生 Linux
    操作系统，专为云架构的需求进行了优化。2018 年，Red Hat 收购了该公司，虽然 CoreOS 操作系统的官方支持在 2020 年结束，但他们的 Operator
    Framework 依然蓬勃发展。
- en: The principal idea behind an Operator is to automate cluster and application
    management tasks that would normally be done manually by a human. This role can
    be thought of as an automated extension of support engineers or **development-operations**
    (**DevOps**) teams.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 的主要思想是自动化那些通常由人工完成的集群和应用程序管理任务。这个角色可以看作是对支持工程师或 **开发运维** (**DevOps**)
    团队的自动化扩展。
- en: Most Kubernetes users will already be familiar with some of the design patterns
    of Operators, even if they have never used the Operator Framework before. This
    is because Operators are a seemingly complicated topic, but ultimately, they are
    not functionally much different than many of the core components that already
    automate most of a Kubernetes cluster by default. These components are called
    controllers, and at its core, any Operator is essentially just a controller.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使大多数 Kubernetes 用户从未使用过 Operator Framework，他们也已经熟悉 Operators 的一些设计模式。这是因为 Operators
    看起来是一个复杂的话题，但归根结底，它们在功能上与已经默认自动化大多数 Kubernetes 集群的许多核心组件没有太大区别。这些组件被称为控制器，本质上，任何
    Operator 都只是一个控制器。
- en: Exploring Kubernetes controllers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Kubernetes 控制器
- en: Kubernetes itself is made up of many default controllers. These controllers
    maintain the desired state of the cluster, as set by users and administrators.
    Deployments, ReplicaSets, and Endpoints are just a few examples of cluster resources
    that are managed by their own controllers. Each of these resources involves an
    administrator declaring the desired cluster state, and it is then the controller's
    job to maintain that state. If there is any deviation, the controller must act
    to resolve what they control.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 本身由许多默认的控制器组成。这些控制器保持集群的期望状态，状态由用户和管理员设置。Deployments、ReplicaSets
    和 Endpoints 只是一些由其各自控制器管理的集群资源的例子。每个这些资源都涉及管理员声明期望的集群状态，随后由控制器来维持这个状态。如果出现任何偏差，控制器必须采取行动来解决其控制的内容。
- en: These controllers work by monitoring the current state of the cluster and comparing
    it to the desired state. One example is a ReplicaSet with a specification to maintain
    three replicas of a Pod. Should one of the replicas fail, the ReplicaSet quickly
    identifies that there are now only two running replicas. It then creates a new
    Pod to bring stasis back to the cluster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制器通过监控集群的当前状态并将其与期望状态进行比较来工作。一个例子是 ReplicaSet，它指定需要维护一个 Pod 的三个副本。如果其中一个副本失败，ReplicaSet
    会迅速识别出当前只有两个副本在运行。然后，它会创建一个新的 Pod 以使集群恢复到稳定状态。
- en: In addition, these core controllers are collectively managed by the **Kube Controller
    Manager**, which is another type of controller. It monitors the state of controllers
    and attempts to recover from errors if one fails or reports the error for human
    intervention if it cannot automatically recover. So, it is even possible to have
    controllers that manage other controllers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些核心控制器由 **Kube Controller Manager** 集中管理，后者也是一种控制器。它监控控制器的状态，并在控制器发生故障时尝试从错误中恢复，或者如果无法自动恢复，则报告错误并进行人工干预。因此，也有可能存在管理其他控制器的控制器。
- en: In the same way, Kubernetes Operators put the development of operational controllers
    in the hands of users. This provides administrators with the flexibility to write
    a controller that can manage any aspect of a Kubernetes cluster or custom application.
    With the ability to define more specific logic, developers can extend the main
    benefits of Kubernetes to the unique needs of their own applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Kubernetes Operators 将操作控制器的开发交给用户。这为管理员提供了灵活性，可以编写一个控制器来管理 Kubernetes 集群或自定义应用程序的任何方面。通过定义更具体的逻辑，开发人员可以将
    Kubernetes 的主要优势扩展到自己应用程序的独特需求中。
- en: The Operators that are written following the guidelines of the Operator Framework
    are designed to function very similarly to native controllers. They do this by
    also monitoring the current state of the cluster and acting to reconcile it with
    the desired state. Specifically, an Operator is tailored to a unique workload
    or component. The Operator then knows how to interact with that component in various
    ways.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 Operator Framework 的指南编写的 Operator 设计得非常类似于本地控制器。它们通过监控集群的当前状态并采取措施将其与期望状态调和来实现这一点。具体来说，Operator
    是为特定的工作负载或组件量身定制的。然后，Operator 知道如何与该组件以不同的方式进行交互。
- en: Knowing key terms for Operators
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Operator 的关键术语
- en: The component that is managed by an Operator is its **Operand**. An Operand
    is any kind of application or workload whose state is reconciled by an Operator.
    Operators can have many Operands, though most Operators manage—at most—just a
    few (usually just one). The key distinction is that Operators exist to manage
    Operands, where the Operator is a meta-application in the architectural design
    of the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Operator 管理的组件是其**操作数**。操作数是任何由 Operator 调和状态的应用程序或工作负载。Operator 可以管理多个操作数，但大多数
    Operator 管理的操作数—通常最多只有一个。关键的区别是，Operator 存在的目的是管理操作数，其中 Operator 是系统架构设计中的元应用。
- en: Operands can be almost any type of workload. While some Operators manage application
    deployments, many others deploy additional, optional cluster components offering
    meta-functionality such as database backup and restoration. Some Operators even
    make core native Kubernetes components their Operands, such as `etcd`. So, an
    Operator doesn't even need to be managing your own workloads; they can help with
    any part of a cluster.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数几乎可以是任何类型的工作负载。虽然一些 Operator 管理应用程序部署，但许多 Operator 部署了额外的、可选的集群组件，提供如数据库备份和恢复等元功能。某些
    Operator 甚至将核心的本地 Kubernetes 组件作为操作数，例如 `etcd`。因此，Operator 不一定管理你自己的工作负载，它们可以帮助集群的任何部分。
- en: No matter what the Operator is managing, it must provide a way for cluster administrators
    to interact with it and configure settings for their application. An Operator
    exposes its configuration options through a **Custom Resource**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 Operator 管理的是什么，它都必须为集群管理员提供一种与之交互并配置其应用程序设置的方式。Operator 通过**自定义资源**暴露其配置选项。
- en: Custom Resources are created as API objects following the constraints of a matching
    **CustomResourceDefinition** (**CRD**). CRDs are themselves a type of native Kubernetes
    object that allows users and administrators to extend the Kubernetes platform
    with their own resource objects beyond what is defined in the core API. In other
    words, while a Pod is a built-in native API object in Kubernetes, CRDs allow cluster
    administrators to define *MyOperator* as another API object and interact with
    it the same way as native objects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源作为 API 对象创建，遵循匹配的**CustomResourceDefinition**（**CRD**）的约束。CRD 本身是一种本地 Kubernetes
    对象，允许用户和管理员将自己的资源对象扩展到 Kubernetes 平台上，超出核心 API 定义的内容。换句话说，虽然 Pod 是 Kubernetes
    中内置的本地 API 对象，但 CRD 允许集群管理员定义 *MyOperator* 作为另一个 API 对象，并以与本地对象相同的方式与之交互。
- en: Putting it all together
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: The Operator Framework strives to define an entire ecosystem for Operator development
    and distribution. This ecosystem comprises three pillars that cover the coding,
    deployment, and publishing of Operators. They are the Operator SDK, OLM, and OperatorHub.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Operator Framework 力求定义一个完整的 Operator 开发和分发生态系统。这个生态系统由三个支柱组成，涵盖了 Operator 的编码、部署和发布。它们分别是
    Operator SDK、OLM 和 OperatorHub。
- en: These three pillars are what have made the Operator Framework so successful.
    They transform the framework from just development patterns to an encompassing,
    iterative process that spans the entire lifecycle of an Operator. This helps support
    the contract between Operator developers and users to provide consistent industry
    standards for their software.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个支柱是使 Operator 框架如此成功的关键因素。它们将框架从仅仅是开发模式转变为一个涵盖整个 Operator 生命周期的循环过程。这有助于支持
    Operator 开发者和用户之间的契约，为他们的软件提供一致的行业标准。
- en: The lifecycle of an Operator begins with development. To help with this, the
    Operator SDK exists to guide developers in the first steps of creating an Operator.
    Technically, an Operator does not have to be written with the Operator SDK, but
    the Operator SDK provides development patterns to significantly reduce the effort
    needed to bootstrap and maintain an Operator's source code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 的生命周期始于开发阶段。为了帮助这一过程，Operator SDK 存在以指导开发者创建 Operator 的第一步。从技术上讲，Operator
    并不一定要使用 Operator SDK 编写，但 Operator SDK 提供了开发模式，显著减少了启动和维护 Operator 源代码所需的工作量。
- en: While coding and development are certainly important parts of creating an Operator,
    any project's timeline does not end once the code is compiled. The Operator Framework
    community recognized that a coherent ecosystem of projects must offer guidance
    beyond just the initial development stage. Projects need consistent methods for
    installation, and as software evolves, there is a need to publish and distribute
    new versions. OLM and OperatorHub help users to install and manage Operators in
    their cluster, as well as share their Operators in the community.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编码和开发当然是创建 Operator 的重要部分，但任何项目的时间表并不会在代码编译后结束。Operator 框架社区认识到，项目的一致生态系统必须在初始开发阶段之外提供指导。项目需要一致的安装方法，并且随着软件的演变，需要发布和分发新版本。OLM
    和 OperatorHub 帮助用户在他们的集群中安装和管理 Operator，并在社区中分享他们的 Operator。
- en: Finally, the Operator Framework provides a scale of Operator functionality called
    the Capability Model. The Capability Model provides developers with a way to classify
    the functional abilities of their Operator by answering quantifiable questions.
    An Operator's classification, along with the Capability Model, gives users information
    about what they can expect from the Operator.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Operator 框架提供了称为能力模型的 Operator 功能规模。能力模型为开发者提供了一种通过回答可量化问题对其 Operator 的功能能力进行分类的方法。Operator
    的分类，连同能力模型，向用户提供了关于他们可以从 Operator 中期待什么的信息。
- en: Together, these three pillars establish the basis of the Operator Framework
    and form the design patterns and community standards that distinguish Operators
    as a concept. Along with the Capability Model, this standardized framework has
    led to an explosion in the adoption of Operators in Kubernetes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个支柱共同奠定了 Operator 框架的基础，并形成了区分 Operator 概念的设计模式和社区标准。连同能力模型一起，这一标准化框架导致了 Kubernetes
    中 Operator 的广泛采用。
- en: At this point, we have discussed a brief introduction to the core concepts of
    the Operator Framework. In contrast with a Kubernetes application managed without
    an Operator, the pillars of the Operator Framework address problems met by application
    developers. This understanding of the core pillars of the Operator Framework will
    set us up for exploring each of them in more depth.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了 Operator 框架核心概念的简要介绍。与没有 Operator 管理的 Kubernetes 应用相比，Operator
    框架的支柱解决了应用开发者遇到的问题。对 Operator 框架核心支柱的理解将为我们深入探讨每个支柱奠定基础。
- en: Developing with the Operator SDK
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Operator SDK 进行开发
- en: The first pillar of the Operator Framework is the Operator SDK. As with any
    other software development toolkit, the Operator SDK provides packaged functionality
    and design patterns as code. These include predefined APIs, abstracted common
    functions, code generators, and project scaffolding tools to easily start an Operator
    project from scratch.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 框架的第一个支柱是 Operator SDK。与任何其他软件开发工具包一样，Operator SDK 以代码形式提供打包功能和设计模式。这些包括预定义的
    API、抽象化的常见函数、代码生成器和项目搭建工具，以便从头开始轻松启动 Operator 项目。
- en: The Operator SDK is primarily written in Go, but its tooling allows Operators
    to be written using Go code, Ansible, or Helm. This gives developers the ability
    to write their Operators from the ground up by coding the CRDs and reconciliation
    logic themselves, or by taking advantage of automated deployment tools provided
    by Ansible and Helm to generate their APIs and reconciliation logic depending
    on their needs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Operator SDK 主要是用 Go 编写的，但其工具链允许使用 Go 代码、Ansible 或 Helm 编写 Operators。这使得开发人员可以从头开始编写自己的
    Operators，通过自己编写 CRD 和调和逻辑，或者根据需求利用 Ansible 和 Helm 提供的自动化部署工具生成他们的 API 和调和逻辑。
- en: Developers interact with the Operator SDK through its `operator-sdk` command-line
    binary. The binary is available on Homebrew for Mac and is also available directly
    from the Operator Framework GitHub repository ([https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk))
    as a release, where it can also be compiled from source.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通过 `operator-sdk` 命令行二进制文件与 Operator SDK 进行交互。该二进制文件可以通过 Homebrew 在 Mac
    上获取，也可以直接从 Operator Framework 的 GitHub 仓库（[https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)）作为发布版本获取，您也可以从源代码编译它。
- en: Whether you are planning to develop an Operator with `operator-sdk init` and
    `operator-sdk create api`. The first command initializes a project's source directory
    with boilerplate Go code, dependencies, hack scripts, and even a `Dockerfile`
    and `Makefile` for compiling the project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是计划使用 `operator-sdk init` 和 `operator-sdk create api` 开发一个 Operator，第一条命令会用标准的
    Go 代码、依赖项、hack 脚本，甚至为编译项目提供 `Dockerfile` 和 `Makefile`，初始化一个项目的源目录。
- en: Creating an API for your Operator is necessary to define the CRD required to
    interact with the Operator once it is deployed in a Kubernetes cluster. This is
    because CRDs are backed by API type definitions written in Go code. The CRD is
    generated from these code definitions, and the Operator has logic built in to
    translate between CRD and Go representations of the object. Essentially, CRDs
    are how users interact with Operators, and Go code is how the Operator understands
    the settings. CRDs also add benefits such as structural validation schemas to
    automatically validate inputs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的 Operator 创建 API 是必需的，以便定义 CRD，供 Operator 部署到 Kubernetes 集群后与之交互。这是因为 CRD
    是由 Go 代码编写的 API 类型定义所支持的。CRD 是从这些代码定义生成的，Operator 内置了逻辑来转换 CRD 和 Go 表示的对象之间的关系。实质上，CRD
    是用户与 Operators 交互的方式，而 Go 代码是 Operator 理解设置的方式。CRD 还提供了结构化验证模式的好处，用于自动验证输入。
- en: The Operator SDK binary has flags to specify the name and version of the API.
    It then generates the API types as Go code and corresponding **YAML Ain't Markup
    Language** (**YAML**) files based on best-practice standard definitions. However,
    you are free to modify the definitions of your API in whichever way you choose.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Operator SDK 二进制文件具有标志来指定 API 的名称和版本。然后，它根据最佳实践的标准定义生成 Go 代码和相应的 **YAML Ain't
    Markup Language**（**YAML**）文件。然而，您可以自由修改 API 的定义，以任何您选择的方式进行修改。
- en: 'If we were to initialize a basic Operator for an application such as the one
    first demonstrated at the start of this chapter, the steps would be relatively
    simple. They would look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为一个应用程序初始化一个基本的 Operator，就像本章开头首次展示的那样，步骤相对简单。它们将如下所示：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After this, you would go on to develop the logic of the Operator based on the
    method you choose. If that's to write Go code directly, it would start by modifying
    the `*.go` files in the project tree. For Ansible and Helm deployments, you would
    begin working on the Ansible roles or Helm chart for your project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将根据选择的方法开发 Operator 的逻辑。如果选择直接编写 Go 代码，首先会修改项目树中的 `*.go` 文件。对于 Ansible 和
    Helm 部署，您将开始着手编写项目的 Ansible 角色或 Helm 图表。
- en: Finally, the Operator SDK binary provides a set of commands to interact with
    OLM. These include the ability to install OLM in a running cluster, but also install
    and manage specific Operators within OLM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Operator SDK 二进制文件提供了一套与 OLM 交互的命令。这些命令包括在运行的集群中安装 OLM 的能力，还可以在 OLM 内安装和管理特定的
    Operators。
- en: Managing Operators with OLM
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OLM 管理 Operators
- en: OLM is the second pillar of the Operator Framework. Its purpose is to facilitate
    the deployment and management of Operators in a Kubernetes cluster. It is a component
    that runs within a Kubernetes cluster and provides several commands and features
    for interacting with Operators.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OLM 是 Operator Framework 的第二个支柱。它的目的是简化在 Kubernetes 集群中部署和管理 Operators。它是一个在
    Kubernetes 集群中运行的组件，提供了几个命令和功能，用于与 Operators 进行交互。
- en: OLM is primarily used for the installation and upgrade of Operators—this includes
    fetching and installing any dependencies for those Operators. Users interact with
    OLM via commands provided by the Operator SDK binary, the Kubernetes command-line
    tool (`kubectl`), and declarative YAML.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: OLM 主要用于操作员的安装和升级——这包括获取和安装操作员的任何依赖项。用户通过操作员 SDK 二进制文件提供的命令、Kubernetes 命令行工具（`kubectl`）和声明式
    YAML 与 OLM 进行交互。
- en: 'To get started, OLM can be initialized in a cluster with the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，OLM 可以通过以下命令在集群中初始化：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Besides installing Operators, OLM can also make Operators that are currently
    installed discoverable to users on the cluster. This provides a catalog of already
    installed Operators available to cluster users. Also, by managing all the known
    Operators in the cluster, OLM can watch for conflicting Operator APIs and settings
    that would destabilize the cluster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装操作员，OLM 还可以使当前安装的操作员对集群中的用户可见。这为集群用户提供了一个已安装操作员的目录。此外，通过管理集群中所有已知的操作员，OLM
    可以监控可能导致集群不稳定的冲突的操作员 API 和设置。
- en: Once an Operator's Go code is compiled into an image, it is ready to be installed
    into a cluster with OLM running. Technically, OLM is not required to run an Operator
    in any cluster. For example, it is completely possible to deploy an Operator manually
    in the cluster, just as with any other container-based application. However, due
    to the advantages and security measures described previously (including its ability
    to install Operators and its awareness of other installed Operators), it is highly
    recommended to use OLM to manage cluster Operators.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作员的 Go 代码被编译成镜像，它就可以准备安装到运行 OLM 的集群中。技术上讲，OLM 并不是在任何集群中运行操作员的必需条件。例如，完全可以像部署任何其他基于容器的应用程序一样，在集群中手动部署一个操作员。然而，由于之前提到的优势和安全措施（包括它的安装操作员的能力以及对其他已安装操作员的感知），强烈建议使用
    OLM 来管理集群中的操作员。
- en: When developing an Operator, the image is compiled into a **bundle**, and that
    bundle is installed via OLM. The bundle consists of several YAML files that describe
    the Operator, its CRD, and its dependencies. OLM knows how to process this bundle
    in its standardized format to properly manage the Operator in a cluster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发操作员时，镜像会被编译成一个**包**，这个包通过 OLM 进行安装。这个包由几个 YAML 文件组成，这些文件描述了操作员、其 CRD 和依赖项。OLM
    知道如何处理这种标准化格式的包，以便在集群中正确地管理操作员。
- en: 'Compiling an Operator''s code and deploying it can be done with commands such
    as the ones shown next. The first command shown in the following code snippet
    builds the bundle of YAML manifests that describe the Operator. Then, it passes
    that information to OLM to run the Operator in your cluster:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编译操作员的代码并进行部署可以通过以下命令来完成。下文代码片段中的第一个命令构建描述操作员的 YAML 清单包。然后，它将这些信息传递给 OLM，以便在你的集群中运行操作员：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Later chapters will demonstrate exactly how to use these commands and what they
    do, but the general idea is that these commands first compile the Operator's Go
    code into an image and a deployable format that's understandable by OLM. But OLM
    isn't the only part of the Operator Framework that consumes an Operator's bundle—much
    of the same information is used by OperatorHub to provide information on an Operator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将详细演示如何使用这些命令以及它们的作用，但总体思路是，这些命令首先将操作员的 Go 代码编译成镜像，并转换为 OLM 能够理解的可部署格式。但
    OLM 并不是操作员框架中唯一使用操作员包的部分——很多相同的信息也被 OperatorHub 用来提供关于操作员的信息。
- en: Once an Operator has been compiled into its image, OperatorHub exists as a platform
    to share and distribute those images to other users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作员被编译成镜像，OperatorHub 就作为一个平台，用于将这些镜像分享和分发给其他用户。
- en: Distributing Operators on OperatorHub.io
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 OperatorHub.io 上分发操作员
- en: The final core component of the Operator Framework is `OperatorHub.io`. As a
    major open source project, the Operator Framework ecosystem is built on the open
    sharing and distribution of projects. Therefore, OperatorHub powers the growth
    of Operators as a Kubernetes concept.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员框架的最终核心组件是`OperatorHub.io`。作为一个重要的开源项目，操作员框架生态系统建立在项目的开放共享和分发上。因此，OperatorHub
    推动了作为 Kubernetes 概念的操作员的发展。
- en: 'OperatorHub is an open catalog of Operators published and managed by the Kubernetes
    community. It serves as a central index of freely available Operators, each contributed
    by developers and organizations. You can see an overview of the `OperatorHub.io`
    home page in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OperatorHub 是一个由 Kubernetes 社区发布和管理的操作员开源目录。它作为一个自由可用的操作员的中央索引，每个操作员由开发者和组织贡献。你可以在下面的截图中查看
    `OperatorHub.io` 首页的概览：
- en: '![Figure 1.2 – Screenshot of the OperatorHub.io home page, showing some of
    the most popular Operators'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – OperatorHub.io 首页截图，展示了一些最受欢迎的操作员'
- en: '](img/B18147_Figure_1.2.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18147_Figure_1.2.jpg)'
- en: Figure 1.2 – Screenshot of the OperatorHub.io home page, showing some of the
    most popular Operators
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – OperatorHub.io 首页截图，展示了一些最受欢迎的操作员
- en: The process for submitting an Operator to OperatorHub for indexing has been
    standardized to ensure the consistency and compatibility of Operators with OLM.
    New Operators are reviewed by automated tooling for compliance with this standard
    definition of an Operator. The process is mainly handled through the open source
    GitHub repository that provides the backend of OperatorHub. However, OperatorHub
    does not provide any assistance with the ongoing maintenance of an Operator, which
    is why it is important for Operator developers to share links to their own open
    source repositories and contact information where users can report bugs and contribute
    themselves.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提交操作员到 OperatorHub 进行索引的过程已经标准化，以确保操作员与 OLM 的一致性和兼容性。新的操作员会通过自动化工具审查，确保符合操作员的标准定义。这个过程主要通过提供
    OperatorHub 后端的开源 GitHub 仓库进行处理。然而，OperatorHub 并不提供关于操作员持续维护的任何帮助，这也是为什么操作员开发者需要共享他们自己的开源仓库链接以及用户可以报告错误和贡献代码的联系方式。
- en: Preparing an Operator for submission to OperatorHub involves generating its
    bundle and associated manifests. The submission process primarily relies on the
    Operator's **Cluster Service Version** (**CSV**). The CSV is a YAML file that
    provides most of the metadata to OLM and OperatorHub about your Operator. It includes
    general information such as the Operator's name, version, and keywords. However,
    it also defines installation requirements (such as **role-based access control**
    (**RBAC**) permissions), CRDs, APIs, and additional cluster resource objects owned
    by the Operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 准备操作员提交到 OperatorHub 涉及生成其包和相关清单。提交过程主要依赖于操作员的 **集群服务版本** (**CSV**) 文件。CSV 是一个
    YAML 文件，提供关于操作员的大部分元数据给 OLM 和 OperatorHub。它包括一般信息，如操作员的名称、版本和关键词。然而，它也定义了安装要求（例如
    **基于角色的访问控制** (**RBAC**) 权限）、CRD、API 和操作员拥有的附加集群资源对象。
- en: 'The specific sections of an Operator''s CSV include the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员 CSV 的特定部分包括以下内容：
- en: The Operator's name and version number, as well as a description of the Operator
    and its display icon in Base64-encoded image format
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员的名称和版本号，以及操作员的描述和以 Base64 编码的图像格式显示的图标
- en: Annotations for the Operator
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员的注解
- en: Contact information for the maintainers of the Operator and the open source
    repository where its code is located
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员维护者的联系信息以及其代码所在的开源仓库
- en: How the Operator should be installed in the cluster
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员应该如何安装到集群中
- en: Example configurations for the Operator's CRD
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员 CRD 的示例配置
- en: Required CRDs and other resources and dependencies that the Operator needs to
    run
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员运行所需的 CRD 和其他资源及依赖项
- en: Because of all the information that it covers, the Operator CSV is usually very
    long and takes time to prepare properly. However, a well-defined CSV helps an
    Operator reach a much wider audience. Details of Operator CSVs will be covered
    in a later chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涵盖了大量信息，操作员 CSV 通常非常长，需要一定时间来正确准备。然而，一个定义清晰的 CSV 有助于操作员接触到更广泛的受众。有关操作员 CSV
    的详细信息将在后续章节中介绍。
- en: Defining Operator functions with the Capability Model
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用能力模型定义操作员功能
- en: The Operator Framework defines a Capability Model ([https://operatorframework.io/operator-capabilities/](https://operatorframework.io/operator-capabilities/))
    that categorizes Operators based on their functionality and design. This model
    helps to break down Operators based on their maturity, and also describes the
    extent of an Operator's interoperability with OLM and the capabilities users can
    expect when using the Operator.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运维框架定义了一个能力模型 ([https://operatorframework.io/operator-capabilities/](https://operatorframework.io/operator-capabilities/))，该模型根据运维人员的功能和设计对其进行分类。此模型有助于根据运维人员的成熟度将其拆分，同时描述了运维人员与
    OLM 的互操作性程度以及用户在使用该运维人员时可以预期的功能。
- en: The Capability Model is divided into five hierarchical levels. Operators can
    be published at any one of these levels and, as they grow, may evolve and graduate
    from one level to the next as features and functionality are added. In addition,
    the levels are cumulative, with each level generally encompassing all features
    of the levels below it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 能力模型分为五个层次，运维人员可以在这些层次中的任何一个级别发布，并随着其成长，随着功能的增加，可能会从一个级别逐渐发展到下一个级别。此外，各个级别是累进的，每个级别通常包括下面所有级别的功能。
- en: The current level of an Operator is part of the CSV, and this level is displayed
    on its OperatorHub listing. The level is based on somewhat subjective yet guided
    criteria and is purely an informational metric.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运维人员的当前级别是 CSV 的一部分，该级别会在其 OperatorHub 列表中显示。该级别基于一定程度的主观判断标准，并且纯粹是一个信息性指标。
- en: 'Each level has specific functionalities that define it. These functionalities
    are broken down into *Basic Install*, *Seamless Upgrades*, *Full Lifecycle*, *Deep
    Insights*, and *Auto Pilot*. The specific levels of the Capability Model are outlined
    here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别都有定义其功能的特定功能。这些功能被拆分为 *基础安装*、*无缝升级*、*完整生命周期*、*深度洞察* 和 *自动驾驶*。能力模型的具体级别在这里列出：
- en: '**Level I—Basic Install**: This level represents the most basic of Operator
    capabilities. At *Level I*, an Operator is only capable of installing its Operand
    in the cluster and conveying the status of the workload to cluster administrators.
    This means that it can set up the basic resources required for an application
    and report when those resources are ready to be used by the cluster.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Level I—基础安装**：此级别代表运维人员能力中最基础的部分。在 *Level I* 中，运维人员仅能在集群中安装其 Operand，并向集群管理员报告工作负载的状态。这意味着它可以设置应用程序所需的基本资源，并报告这些资源何时可以供集群使用。'
- en: At *Level I*, an Operator also allows for simple configuration of the Operand.
    This configuration is specified through the Operator's Custom Resource. The Operator
    is responsible for reconciling the configuration specifications with the running
    Operand workload. However, it may not be able to react if the Operand reaches
    a failed state, whether due to malformed configuration or outside influence.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Level I* 中，运维人员还允许对 Operand 进行简单配置。此配置通过运维人员的自定义资源指定。运维人员负责将配置规范与运行中的 Operand
    工作负载进行协调。然而，如果 Operand 进入失败状态，无论是由于配置错误还是外部影响，它可能无法作出响应。
- en: Going back to our example web application from the start of the chapter, a *Level
    I* Operator for this application would handle the basic setup of the workloads
    and nothing else. This is good for a simple application that needs to be quickly
    set up on many different clusters, or one that should be easily shared with users
    for them to install themselves.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本章开头的示例 Web 应用程序，对于该应用程序，*Level I* 级别的运维人员只会处理工作负载的基本设置，其他无所涉及。这适用于需要在多个集群上快速设置的简单应用程序，或者是需要用户自行安装并共享的应用程序。
- en: '**Level II—Seamless Upgrades**: Operators at *Level II* offer the features
    of basic installation, with added functionality around upgrades. This includes
    upgrades for the Operand but also upgrades for the Operator itself.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Level II—无缝升级**：*Level II* 级别的运维人员提供基本安装功能，并增加了关于升级的附加功能。这包括 Operand 的升级以及运维人员本身的升级。'
- en: Upgrades are a critical part of any application. As bug fixes are implemented
    and more features are added, being able to smoothly transition between versions
    helps ensure application uptime. An Operator that handles its own upgrades can
    either upgrade its Operand when it upgrades itself or manually upgrade its Operand
    by modifying the Operator's Custom Resource.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 升级是任何应用程序的重要部分。随着错误修复的实现和更多功能的添加，能够平滑地在版本之间过渡有助于确保应用程序的正常运行。处理自身升级的运维人员可以在升级自身时升级其
    Operand，或者通过修改运维人员的自定义资源手动升级其 Operand。
- en: For seamless upgrades, an Operator must also be able to upgrade older versions
    of its Operand (which may exist because they were managed by an older version
    of the Operator). This kind of backward compatibility is essential for both upgrading
    to newer versions and handling rollbacks (for example, if a new version introduces
    a high-visibility bug that can't wait for an eventual fix to be published in a
    patch version).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现无缝升级，操作员还必须能够升级其操作数的旧版本（这些旧版本可能是因为它们由操作员的早期版本管理）。这种向后兼容性对于升级到新版本和处理回滚至关重要（例如，如果新版本引入了一个显而易见的错误，无法等待修补程序发布）。
- en: Our example web application Operator could offer the same set of features. This
    means that if a new version of the application were released, the Operator could
    handle upgrading the deployed instances of the application to the newer version.
    Or, if changes were made to the Operator itself, then it could manage its own
    upgrades (and later upgrade the application, regardless of version skew between
    Operator and Operand).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例Web应用操作员也可以提供相同的一组功能。这意味着，如果发布了应用程序的新版本，操作员可以处理升级已部署的应用程序实例到新版本。或者，如果对操作员本身进行了更改，则可以管理自己的升级（并且稍后升级应用程序，无论操作员与操作数之间的版本差异如何）。
- en: '**Level III—Full Lifecycle**: *Level III* Operators offer at least one out
    of a list of Operand lifecycle management features. Being able to offer management
    during the Operand''s lifecycle implies that the Operator is more than just passively
    operating on a workload in a *set and forget* fashion. At Level III, Operators
    are actively contributing to the ongoing function of the Operand.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**III级—完整生命周期**：*III级*操作员提供至少一项操作数生命周期管理功能。能够在操作数生命周期内提供管理意味着操作员不仅仅是以*设定并遗忘*的方式被动地操作工作负载。在III级，操作员积极地参与操作数的持续功能。'
- en: 'The features relevant to the lifecycle management of an Operand include the
    following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作数生命周期管理相关的功能包括以下内容：
- en: The ability to create and/or restore backups of the Operand.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建和/或恢复操作数的备份。
- en: Support for more complex configuration options and multistep workflows.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持更复杂的配置选项和多步骤工作流。
- en: Failover and failback mechanisms for **disaster recovery** (**DR**). When the
    Operator encounters an error (either in itself or the Operand), it needs to be
    able to either re-route to a backup process (fail over) or roll the system back
    to its last known functioning state (fail back).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灾难恢复**（**DR**）的故障转移和故障回退机制。当操作员遇到错误（无论是在自身还是在操作数中）时，它需要能够将流程重新路由到备份过程（故障转移）或将系统回滚到最后已知的正常状态（故障回退）。'
- en: The ability to manage clustered Operands, and—specifically—support for adding
    and removing members to and from Operands. The Operator should be capable of considering
    quorum for Operands that run multiple replicas.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理集群化操作数的能力，特别是支持向操作数添加或移除成员。操作员应能够考虑多个副本的操作数的法定人数。
- en: Similarly, support for scaling an Operand with worker instances that operate
    with read-only functionality.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，支持使用只读功能的工作实例扩展操作数。
- en: Any Operator that implements one or more of these features can be considered
    to be at least a Level III Operator. The simple web application Operator could
    take advantage of a few of these, such as DR and scaling. As the user base grows
    and resources demands increase, an administrator could instruct the Operator to
    scale the application with additional replica Pods to handle the increased load.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些功能之一或多个功能的操作员可以被认为至少是III级操作员。简单的Web应用操作员可以利用其中的一些功能，例如灾难恢复（DR）和扩展。随着用户基础的增长和资源需求的增加，管理员可以指示操作员通过增加副本Pod来扩展应用程序，以应对增加的负载。
- en: Should any of the Pods fail during this process, the Operator would be smart
    enough to know to fail over to a different Pod or cluster zone entirely. Alternatively,
    if a new version of the web app was released that introduced an unexpected bug,
    the Operator could be aware of the previous successful version and provide ways
    to downgrade its Operand workloads if an administrator noticed the error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此过程中某些Pod失败，操作员应足够智能，知道将故障转移到另一个Pod或完全不同的集群区域。或者，如果发布了一个新的Web应用版本，并且该版本引入了意外的错误，操作员可以识别先前的成功版本，并在管理员发现错误时提供将操作数工作负载降级的方式。
- en: '**Level IV—Deep Insights**: While the previous levels focus primarily on Operator
    features as they relate to functional interaction with the application workload,
    Level IV emphasizes monitoring and metrics. This means an Operator is capable
    of providing measurable insights to the status of both itself and its Operand.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Level IV—深度见解**：虽然之前的级别主要关注操作员与应用工作负载的功能性交互，但 Level IV 强调监控和度量。这意味着操作员能够提供可衡量的见解，展示自身及其
    Operand 的状态。'
- en: Insights may be seen as less important from a development perspective relative
    to features and bug fixes, but they are just as critical to an application's success.
    Quantifiable reports about an application's performance can drive ongoing development
    and highlight areas that need improvement. Having a measurable system to push
    these efforts allows a way to scientifically prove or disprove which changes have
    an effect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发角度来看，见解可能相对于功能和 bug 修复显得不那么重要，但它们对于应用程序的成功至关重要。关于应用程序性能的量化报告可以推动持续开发，并突出需要改进的地方。拥有一个可衡量的系统来推动这些工作，可以科学地证明或反驳哪些变化有实际效果。
- en: Operators most commonly provide their insights in the form of metrics. These
    metrics are usually compatible with metrics aggregation servers such as Prometheus.
    (Interestingly enough, Red Hat publishes an Operator for Prometheus that is a
    Level IV Operator. That Operator is available on OperatorHub at [https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus).)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员最常以度量的形式提供他们的见解。这些度量通常与度量聚合服务器兼容，如 Prometheus。（有趣的是，Red Hat 发布了一个 Prometheus
    操作员，它是一个 Level IV 操作员。这个操作员可以在 OperatorHub 上找到，网址是 [https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus)。）
- en: However, Operators can provide insights through other means as well. These include
    alerts and Kubernetes Events. Events are built-in cluster resource objects that
    are used by core Kubernetes objects and controllers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，操作员也可以通过其他方式提供见解。这些方式包括警报和 Kubernetes 事件。事件是内建的集群资源对象，由 Kubernetes 核心对象和控制器使用。
- en: Another key insight that Level IV Operators report is the performance of the
    Operator and Operand. Together, these insights help inform administrators about
    the health of their clusters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Level IV 操作员报告的另一个关键见解是操作员和 Operand 的性能。这些见解有助于管理员了解集群的健康状况。
- en: Our simple web application Operator could provide insights about the performance
    of the Operand. Requests to the app would provide information about the current
    and historic load on the cluster. Additionally, since the Operator can identify
    failed states at this point, it could trigger an alert when the application is
    unhealthy. Many alerts would indicate a reliability issue that would gain the
    attention of an administrator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单 web 应用操作员可以提供关于 Operand 性能的见解。对应用程序的请求会提供有关当前和历史负载的信息。此外，由于操作员此时可以识别失败状态，它可以在应用程序不健康时触发警报。许多警报可能表明存在可靠性问题，从而引起管理员的关注。
- en: '**Level V—Auto Pilot**: Level V is the most sophisticated level for Operators.
    It includes Operators that offer the highest capabilities, in addition to the
    features in all four previous levels. This level is called *Auto Pilot* because
    the features that define it focus on being able to run almost entirely autonomously.
    These capabilities include Auto Scaling, Auto-Healing, Auto-Tuning, and Abnormality
    Detection.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Level V—自动驾驶**：Level V 是针对操作员的最复杂级别。它包括提供最高能力的操作员，除了之前四个级别中的所有功能外，这个级别还具备其他特性。这个级别被称为*自动驾驶*，因为定义它的特性侧重于能够几乎完全自主运行。这些能力包括自动扩展、自动修复、自动调优和异常检测。'
- en: Auto Scaling is the ability for an Operator to detect the need to scale an application
    up or down based on demand. By measuring the current load and performance, an
    Operator can determine whether more or fewer resources are necessary to satisfy
    the current usage. Advanced Operators can even try to predict the need to scale
    based on current and past data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展是操作员根据需求检测需要对应用程序进行扩展或缩减的能力。通过测量当前负载和性能，操作员可以确定是否需要更多或更少的资源来满足当前的使用需求。高级操作员甚至可以根据当前和过去的数据预测扩展的需求。
- en: Auto-Healing Operators can react to applications that are reporting unhealthy
    conditions and work to correct them (or, at least, prevent them from getting any
    worse). When an Operand is reporting an error, the Operator should take reactive
    steps to rectify the failure. In addition, Operators can use current metrics to
    proactively prevent an Operand from transitioning to a failure state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 自动修复操作员可以对报告不健康状态的应用程序做出反应，并努力修正它们（或者至少防止其恶化）。当操作对象报告错误时，操作员应采取反应措施来修复故障。此外，操作员还可以利用当前指标主动防止操作对象进入故障状态。
- en: Auto-Tuning means that an Operator can dynamically modify an Operand for peak
    performance. This involves tuning the settings of an Operand automatically. It
    can even include complex operations such as shifting workloads to entirely different
    nodes that are better suited than their current nodes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 自动调优意味着操作员可以动态地修改操作对象，以达到最佳性能。这涉及到自动调节操作对象的设置，甚至可能包括将工作负载转移到完全不同、更适合的节点上等复杂操作。
- en: Finally, Abnormality Detection is the capability of an Operator to identify
    suboptimal or off-pattern behavior in an Operand. By measuring performance, an
    Operator has a picture of the application's current and historical levels of functioning.
    That data can be compared to a manually defined minimum expectation or used to
    dynamically inform the Operator of that expectation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，异常检测是操作员识别操作对象中亚优化或异常行为的能力。通过衡量性能，操作员可以了解应用程序当前和历史的功能水平。这些数据可以与手动定义的最低预期进行比较，或者用来动态地通知操作员该预期。
- en: All of these features are heavily dependent upon the use of metrics to automatically
    inform the Operator of the need to act upon itself or its Operand. Therefore,
    a Level V Operator is an inherent progression from Level IV, which is the level
    at which an Operator exposes advanced metrics.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都在很大程度上依赖于使用指标来自动通知操作员需要对其自身或操作对象采取行动。因此，级别 V 操作员是级别 IV 的自然进展，后者是操作员暴露高级指标的层级。
- en: At Level V, the simple web application Operator would manage most of the aspects
    of the application for us. It has insights into the current number of requests,
    so it can scale up copies of the app on demand. If this scaling starts to cause
    errors (for example, too many concurrent database calls), it can identify the
    number of failing Pods and prevent further scaling. It would also attempt to modify
    parameters of the web app (such as request timeouts) to help rectify the situation
    and allow the auto-scaling to proceed. When the load peak subsided, the Operator
    would then automatically scale down the application to its baseline service levels.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在级别 V，简单的 Web 应用程序操作员将管理应用程序的大多数方面。它可以了解当前的请求数量，因此能够按需扩展应用程序的副本。如果这种扩展开始导致错误（例如，过多的并发数据库调用），它可以识别失败的
    Pod 数量，并防止进一步的扩展。它还会尝试修改 Web 应用程序的参数（例如请求超时），以帮助纠正问题并允许自动扩展继续。当负载高峰期过去后，操作员会自动将应用程序缩减到基线服务水平。
- en: 'Levels I and II (*Basic Install* and *Seamless Upgrades*) can be used with
    the three facets of the Operator SDK: Helm, Ansible, and Go. However, Level III
    and above (*Full Lifecycle*, *Deep Insights*, and *Auto Pilot*) are only possible
    with Ansible and Go. This is because the functionality at these higher levels
    requires more intricate logic than what is available through Helm charts alone.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 级别 I 和 II（*基本安装*和*无缝升级*）可以与操作员 SDK 的三个方面一起使用：Helm、Ansible 和 Go。然而，级别 III 及以上（*全生命周期*、*深度洞察*和*自动驾驶*）仅能通过
    Ansible 和 Go 实现。这是因为这些更高层次的功能需要比单独使用 Helm 图表更复杂的逻辑。
- en: 'We have now explained the three main pillars of the Operator Framework: Operator
    SDK, OLM, and OperatorHub. We learned how each contributes different helpful features
    to the development and usage of Operators. We also learned about the Capability
    Model, which serves as a reference for the different levels of functionality that
    Operators can have. In the next section, we''ll apply this knowledge to a sample
    application.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了操作员框架的三个主要支柱：操作员 SDK、OLM 和 OperatorHub。我们了解了它们如何为操作员的开发和使用提供不同的有益功能。我们还学习了能力模型，它作为操作员可能拥有的不同功能层级的参考。在下一部分，我们将应用这些知识来处理一个示例应用程序。
- en: Using Operators to manage applications
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作员来管理应用程序
- en: Clearly, working with Operators involves more than simply reconciling a cluster
    state. The Operator Framework is an encompassing platform for Kubernetes developers
    and users to solve unique problems, which makes Kubernetes so flexible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，操作员的工作不仅仅是调和集群状态。操作员框架是一个全面的平台，供 Kubernetes 开发者和用户解决独特问题，这也是 Kubernetes 如此灵活的原因。
- en: Cluster administrators' first step in the Operator Framework is usually either
    with the Operator SDK, to develop their own Operator if there are no existing
    Operators that address their needs, or OperatorHub if there are.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理员在操作员框架中的第一步通常是使用操作员 SDK，如果没有现成的操作员能够满足需求，就自己开发一个操作员，或者使用 OperatorHub（如果有合适的操作员）。
- en: Summarizing the Operator Framework
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作员框架总结
- en: 'When developing an Operator from scratch, there are three choices for development
    methods: Go, Ansible, or Helm. However, using Ansible or Helm alone will ultimately
    limit the Operator''s capabilities to the most basic levels of functionality.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在从零开始开发操作员时，有三种开发方法可供选择：Go、Ansible 或 Helm。然而，单独使用 Ansible 或 Helm 最终会将操作员的功能限制到最基本的水平。
- en: If the developer wishes to share their Operator, they will need to package it
    into the standard manifest bundle for OperatorHub. Following a review, their Operator
    will be available publicly for other users to download and install in their own
    clusters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者希望分享他们的操作员，他们需要将其打包成标准的操作员清单包，以便提交到 OperatorHub。经过审核后，他们的操作员将公开提供，供其他用户下载并安装到自己的集群中。
- en: 'OLM then makes it easy for users to launch Operators in a cluster. These Operators
    can be sourced from OperatorHub or written from scratch. Either way, OLM makes
    Operator installation, upgrades, and management much easier. It also provides
    several stability benefits when working with many Operators. You can see the relationship
    between the three services in the following diagram:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OLM 使用户在集群中启动操作员变得更加简单。这些操作员可以来自 OperatorHub，也可以从零开始编写。不管哪种方式，OLM 都让操作员的安装、升级和管理变得更加轻松。它还提供了多操作员工作时的多个稳定性优势。你可以通过下面的图示看到三者之间的关系：
- en: '![Figure 1.3 – The relationship between the Operator SDK, OperatorHub, and
    OLM](img/B18147_Figure_1.3.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 操作员 SDK、OperatorHub 和 OLM 之间的关系](img/B18147_Figure_1.3.jpg)'
- en: Figure 1.3 – The relationship between the Operator SDK, OperatorHub, and OLM
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 操作员 SDK、OperatorHub 和 OLM 之间的关系
- en: Each of these pillars provides distinct functions that aid in the development
    of Operators. Together, they comprise the foundation of the Operator Framework.
    Utilization of these pillars is the key distinguishing factor between an Operator
    and a normal Kubernetes controller. To summarize, while every Operator is essentially
    a controller, not every controller is an Operator.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些支柱中的每一个都提供了不同的功能，帮助操作员的开发。它们共同构成了操作员框架的基础。利用这些支柱是操作员与普通 Kubernetes 控制器之间的关键区别。总结来说，虽然每个操作员本质上都是一个控制器，但并非每个控制器都是操作员。
- en: Applying Operator capabilities
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用操作员功能
- en: Revisiting the first example in this chapter, the idea of a simple application
    with three Pods and a Persistent Volume was examined without Operator management.
    This application relied on optimistic uptime and future-proof design to run continuously.
    In real-world deployments, these ideas are unfortunately unreasonable. Designs
    evolve and change, and unforeseeable failures bring applications down. But how
    could an Operator help this app persist in an unpredictable world?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章中的第一个示例，分析了一个简单应用，包含三个 Pod 和一个持久卷，没有操作员管理。这个应用依赖于乐观的正常运行时间和面向未来的设计，以便持续运行。在实际部署中，这些理念不幸是不可行的。设计会不断演化，变化，无法预见的故障也会导致应用宕机。但操作员如何帮助这个应用在不可预测的环境中持续运行呢？
- en: 'By defining a single declarative configuration, this Operator could control
    various settings of the application deployment in one spot. This is the reason
    Operators are built on CRDs. These custom objects allow developers and users to
    easily interact with their Operators just as if they were native Kubernetes objects.
    So, the first step in writing an Operator to manage our simple web application
    would be to define a basic code structure with a CRD that has all the settings
    we think we''ll need. Once we have done this, the new diagram of our application
    will look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义单一声明性配置，这个运算符可以在一个位置控制应用程序部署的各种设置。这就是运算符建立在 CRD 上的原因。这些自定义对象使开发人员和用户可以像操作原生
    Kubernetes 对象一样轻松地与他们的运算符进行交互。因此，编写一个运算符来管理我们简单的 Web 应用程序的第一步将是定义一个带有我们认为需要的所有设置的
    CRD 的基本代码结构。一旦我们完成了这一点，我们应用程序的新图表将如下所示：
- en: '![Figure 1.4 – In the new app layout, the cluster administrator only interacts
    with the Operator; the Operator then manages the workload](img/B18147_Figure_1.4.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 在新的应用布局中，集群管理员只与运算符进行交互；然后运算符管理工作负载](img/B18147_Figure_1.4.jpg)'
- en: Figure 1.4 – In the new app layout, the cluster administrator only interacts
    with the Operator; the Operator then manages the workload
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 在新的应用布局中，集群管理员只与运算符进行交互；然后运算符管理工作负载。
- en: 'This shows how the details of the Operand deployment have been abstracted away
    from requiring manual administrator control, and the great part about CRDs is
    that more settings can be added in later versions of the Operator as our app grows.
    A few examples of settings to start with could be these:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了 Operand 部署的细节已经从需要手动管理员控制中抽象出来，CRD 的优点在于随着我们应用程序的增长，可以在后续版本的运算符中添加更多设置。一些初始设置的示例包括：
- en: Database access information
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库访问信息
- en: Application behavior settings
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序行为设置
- en: Log level
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别
- en: While writing our Operator code, we'll also want to write logic for things such
    as metrics, error handling, and reporting. The Operator can also start to bidirectionally
    communicate with the Operand. This means that not only can it install and update
    the Operand, but it can receive communication back from the Operand about its
    status and report that as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 编写我们的运算符代码时，我们还希望为诸如指标、错误处理和报告等事务编写逻辑。运算符还可以开始双向与操作数通信。这意味着它不仅可以安装和更新操作数，还可以接收操作数关于其状态的反馈，并进行相应的报告。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we introduced the fundamental concepts of the Operator Framework.
    These include the Operator SDK, OLM, and OperatorHub. In addition to the development
    and distribution pillars of the Operator Framework, the Capability Model provides
    an additional tool for measuring the functionality of an Operator. Throughout
    this book, we will be exploring these components in deeper detail to get a hands-on
    understanding of how they actually work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了运算符框架的基本概念。这些包括运算符 SDK、OLM 和 OperatorHub。除了运算符框架的开发和分发支柱外，能力模型还提供了衡量运算符功能的额外工具。在本书的整个过程中，我们将深入探讨这些组件，以深入理解它们的实际工作方式。
- en: We began this chapter by examining some of the problems that arise when manually
    managing applications and clusters without Operators. This was done through the
    lens of a simple generic web application based on a couple of Pods and a Persistent
    Volume. The main difficulties in managing something such as this include the time
    and resources required to debug applications. This is especially important in
    cloud applications, where **high availability** (**HA**) and consistent uptime
    are top priorities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从分析手动管理应用程序和集群时出现的一些问题开始。这是通过一个简单的基于几个 Pod 和持久卷的通用 Web 应用程序的视角来完成的。管理此类应用程序的主要困难包括调试应用程序所需的时间和资源。这在云应用程序中尤为重要，高可用性（HA）和持续的正常运行时间是首要任务。
- en: We then looked at how each pillar of the Operator Framework addresses the biggest
    difficulties of application management. These pillars begin with the Operator
    SDK, which streamlines Operator development. This allows developers to begin iterating
    on automated reconciliation logic to get their Operators written quickly. It also
    provides commands to interact with OLM, which is the next pillar of the framework.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看运算符框架的每个支柱如何解决应用管理的最大困难。这些支柱从运算符 SDK 开始，它简化了运算符的开发。这使得开发人员能够快速开始迭代自动对账逻辑，以快速编写他们的运算符。它还提供了与
    OLM 交互的命令，这是框架的下一个支柱。
- en: OLM exists to help administrators install and curate Operators within a cluster.
    It provides dependency management and notifies administrators of conflicting APIs
    to promote cluster stability. It also serves as a local catalog of installed Operators,
    which is useful for users on the cluster.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: OLM 的存在是为了帮助管理员在集群中安装和管理操作员。它提供了依赖关系管理，并通知管理员 API 冲突，以促进集群的稳定性。它还充当已安装操作员的本地目录，对于集群中的用户非常有用。
- en: Next, we examined OperatorHub and its role in the broader open source Kubernetes
    community. As an open index of freely available Operators, OperatorHub serves
    to promote the adoption and maintenance of Operators. It consumes the same manifests
    as OLM to provide a standardized set of metadata about each Operator to users.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考察了 OperatorHub 及其在更广泛的开源 Kubernetes 社区中的作用。作为一个自由可用操作员的公开索引，OperatorHub
    旨在促进操作员的采纳和维护。它使用与 OLM 相同的清单，向用户提供每个操作员的标准化元数据集。
- en: Finally, the Capability Model summarizes the maturity of an Operator based on
    the functionality it provides. This is helpful to users, but it also serves as
    a convenient roadmap for developers to plan features for their Operators.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，能力模型根据操作员提供的功能总结了操作员的成熟度。这对用户很有帮助，同时也为开发人员规划操作员功能提供了便捷的路线图。
- en: To summarize each of these components, we revisited the original application
    example presented in the first section. We showed that, with an Operator in place
    to manage the application, cluster administrators do not need to be keenly aware
    of the architectural details of the app to keep it running. Instead, this information
    and controls are abstracted away behind the Operator's interface.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这些组件，我们回顾了第一部分中呈现的原始应用示例。我们展示了，通过使用操作员来管理应用程序，集群管理员无需过于关注应用程序的架构细节即可保持其运行。相反，这些信息和控制已通过操作员的界面进行了抽象。
- en: With all of this in mind, we move on to the next chapters to explore each of
    these topics in depth. We will also be following detailed examples to build our
    own sample Operator. In the next chapter, we'll begin looking at the important
    concepts of designing an Operator based on its interactions with a Kubernetes
    cluster.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一切，我们将继续下一章，深入探讨每个主题。我们还将通过详细示例构建我们自己的示例操作员。在下一章中，我们将开始研究基于与 Kubernetes
    集群交互设计操作员的关键概念。
