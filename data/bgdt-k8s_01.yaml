- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器入门
- en: The world is rapidly generating massive amounts of data from a variety of sources
    – mobile devices, social media, e-commerce transactions, sensors, and more. This
    data explosion is often referred to as “big data.” While big data presents immense
    opportunities for businesses and organizations to gain valuable insights, it also
    brings tremendous complexity in how to store, process, analyze, and extract value
    from huge volumes of diverse data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备、社交媒体、电商交易、传感器等各种来源迅速生成大量数据，世界正面临着数据爆炸。这种数据爆炸通常被称为“**大数据**”。尽管大数据为企业和组织提供了获取有价值洞察的巨大机会，但它也带来了如何存储、处理、分析和从大量多样化的数据中提取价值的巨大复杂性。
- en: This is where Kubernetes comes in. Kubernetes is an open source container orchestration
    system that helps automate the deployment, scaling, and management of containerized
    applications. Kubernetes brings important advantages for building big data systems.
    It provides a standard way to deploy containerized big data applications on any
    infrastructure. This makes it easy to migrate applications across on-premises
    servers or cloud providers. It also makes it simple to scale big data applications
    up or down based on demand. Additional containers can be spun up or shut down
    automatically based on usage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，Kubernetes 就派上了用场。Kubernetes 是一个开源容器编排系统，帮助自动化容器化应用的部署、扩展和管理。Kubernetes 为构建大数据系统带来了重要的优势。它提供了一种标准方式来在任何基础设施上部署容器化的大数据应用。这使得应用可以轻松地在本地服务器或云服务商之间迁移。同时，它也使得根据需求对大数据应用进行水平扩展变得更加简单。可以根据使用情况自动启动或关闭额外的容器。
- en: Kubernetes helps ensure the high availability of big data applications through
    features such as self-healing and auto-restarting of failed containers. It also
    provides a unified way to deploy, monitor, and manage different big data components.
    This reduces operational complexity compared to managing each system separately.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过自愈和自动重启失败容器等特性，帮助确保大数据应用的高可用性。它还提供了一种统一的方法来部署、监控和管理不同的大数据组件。这与分别管理每个系统相比，显著减少了操作复杂性。
- en: This book aims to provide you with practical skills for leveraging Kubernetes
    to build robust and scalable big data pipelines. You will learn how to containerize
    and deploy popular big data tools such as Spark, Kafka, Airflow, and more on Kubernetes.
    The book covers architectural best practices and hands-on examples for building
    batch and real-time data pipelines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在为您提供实际技能，帮助您利用 Kubernetes 构建强大且可扩展的大数据管道。您将学习如何在 Kubernetes 上容器化并部署流行的大数据工具，如
    Spark、Kafka、Airflow 等。本书涵盖了构建批处理和实时数据管道的架构最佳实践和实际示例。
- en: By the end, you will gain an end-to-end view of running big data workloads on
    Kubernetes and be equipped to build efficient data platforms that power analytics
    and artificial intelligence applications. The knowledge you will gain will be
    of immense value whether you are a data engineer, data scientist, DevOps engineer,
    or technology leader driving digital transformation in your organization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，您将全面了解如何在 Kubernetes 上运行大数据工作负载，并能够构建高效的数据平台，支持分析和人工智能应用。无论您是数据工程师、数据科学家、DevOps
    工程师，还是在推动组织数字化转型的技术领导者，您所获得的知识都将具有巨大价值。
- en: The foundation of Kubernetes is containers. Containers are one of the most used
    technologies in data engineering today. They allow engineers to package software
    into standardized units for development, shipment, and deployment. By the end
    of this chapter, you will understand the basics of containers and be able to build
    and run your own containers using Docker.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的基础是容器。容器是当今数据工程中最常用的技术之一。它们允许工程师将软件打包成标准化的单元，用于开发、运输和部署。在本章结束时，您将理解容器的基本概念，并能够使用
    Docker 构建和运行自己的容器。
- en: In this chapter, we will cover what containers are, why they are useful, and
    how to create and run containers on your local machine using Docker. Containers
    solve many problems that developers face when moving applications between environments.
    They ensure that the application and its dependencies are packaged together and
    isolated from the underlying infrastructure. This allows the application to run
    quickly and reliably from one computing environment to another.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍容器是什么，为什么它们有用，以及如何使用 Docker 在本地机器上创建和运行容器。容器解决了开发者在应用程序迁移过程中面临的许多问题。它们确保应用程序及其依赖项被打包在一起，并与底层基础设施隔离开。这使得应用程序能够在不同的计算环境之间快速而可靠地运行。
- en: We will start by installing Docker, a platform for building and running containers,
    on your local system. We will run simple Docker images and learn the basic Docker
    commands. We will then build our first Docker image containing a simple Python
    application. We will learn how to define a Dockerfile to efficiently specify the
    environment and dependencies for our application. We will then run our image as
    a container and explore how to access the application and check its logs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在本地系统上安装 Docker 开始，Docker 是一个用于构建和运行容器的平台。我们将运行简单的 Docker 镜像，并学习基本的 Docker
    命令。接着，我们将构建第一个包含简单 Python 应用的 Docker 镜像。我们将学习如何定义 Dockerfile，以高效地指定应用的环境和依赖项。然后，我们将以容器的形式运行该镜像，探索如何访问应用并检查其日志。
- en: Containers are a key technology for modern software deployment. They are lightweight,
    portable, and scalable, allowing you to build and ship applications faster. The
    concepts and skills you will learn in this chapter will provide a strong foundation
    for working with containers and deploying data applications. By the end of this
    chapter, you will be ready to start building and deploying your own containerized
    data processing jobs, APIs, and data engineering tools.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是现代软件部署的关键技术。它们轻量、可移植且可扩展，使你能够更快地构建和发布应用程序。本章中你将学习的概念和技能将为你使用容器和部署数据应用提供坚实的基础。到本章结束时，你将准备好开始构建和部署自己的容器化数据处理任务、API
    和数据工程工具。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Container architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器架构
- en: Installing Docker
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Getting started with Docker images
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入门 Docker 镜像
- en: Building your own image
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自己的镜像
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you should have Docker installed. Also, a computer with a
    minimum of 4 GB of RAM (8 GB is recommended) is required, as Docker can really
    consume a computer’s memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，你需要已经安装 Docker。此外，电脑至少需要 4 GB 的内存（推荐 8 GB），因为 Docker 会消耗大量的计算机内存。
- en: The code for this chapter is available on GitHub. Please refer to [https://github.com/PacktPublishing/Bigdata-on-Kubernetes](https://github.com/PacktPublishing/Bigdata-on-Kubernetes)
    and access the `Chapter01` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到。请参考 [https://github.com/PacktPublishing/Bigdata-on-Kubernetes](https://github.com/PacktPublishing/Bigdata-on-Kubernetes)
    并访问 `Chapter01` 文件夹。
- en: Container architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器架构
- en: Containers are an operating system-level virtualization method that we can use
    to run multiple isolated processes on a single host machine. Containers allow
    applications to run in an isolated environment with their own dependencies, libraries,
    and configuration files without the overhead of a full **virtual machine** (**VM**),
    which makes them lighter and more efficient.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一种操作系统级别的虚拟化方法，我们可以利用它在单一主机上运行多个隔离的进程。容器允许应用在独立的环境中运行，拥有自己的依赖项、库和配置文件，而不需要像完整的**虚拟机**（**VM**）那样的开销，这使得容器更加轻量且高效。
- en: If we compare containers to traditional VMs, they differ in a few ways. VMs
    virtualize at the hardware level, creating a full virtual operating system. Containers,
    on the other hand, virtualize at the operating system level. Because of that,
    containers share the host system’s kernel, whereas VMs each have their own kernel.
    This allows containers to have much faster startup times, typically in milliseconds
    compared to minutes for VMs (it is worth noting that in a Linux environment, Docker
    can leverage the capabilities of a Linux kernel directly. While running in a Windows
    system, however, it runs in a lightweight Linux VM that is still lighter than
    a full VM).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将容器与传统的虚拟机进行比较，它们在几个方面有所不同。虚拟机在硬件层面进行虚拟化，创建一个完整的虚拟操作系统。而容器则是在操作系统层面进行虚拟化。因此，容器共享主机系统的内核，而虚拟机则每个都有自己的内核。这使得容器的启动时间非常快，通常以毫秒为单位，而虚拟机则需要几分钟（值得注意的是，在Linux环境中，Docker可以直接利用Linux内核的功能。然而，在Windows系统中，Docker则运行在一个轻量级的Linux虚拟机中，尽管如此，它仍然比完整的虚拟机更轻便）。
- en: Also, containers have better resource isolation as they only isolate the application
    layer, whereas VMs isolate an entire operating system. Containers are immutable
    infrastructure, making them more portable and consistent as updates create new
    container images (versions) rather than updating in place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，容器具有更好的资源隔离性，因为它们仅隔离应用层，而虚拟机则隔离整个操作系统。容器是不可变的基础设施，使得它们在更新时创建新的容器镜像（版本），而不是在原地更新，从而使它们更加便携和一致。
- en: Due to these differences, containers allow higher density, faster startup times,
    and lower resource usage compared to VMs. A single server can run dozens or hundreds
    of containerized applications isolated from each other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些差异，容器相比虚拟机允许更高的密度、更快的启动时间和更低的资源使用。单台服务器可以运行数十个甚至数百个彼此隔离的容器化应用程序。
- en: Docker is one of the most popular container platforms that provides tools to
    build, run, deploy, and manage containers. Docker architecture consists of the
    Docker client, Docker daemon, Docker registry, and Docker images.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是最受欢迎的容器平台之一，提供了构建、运行、部署和管理容器的工具。Docker 架构由 Docker 客户端、Docker 守护进程、Docker
    注册表和 Docker 镜像组成。
- en: The Docker client is a **command-line interface** (**CLI**) client used to interact
    with the Docker daemon to build, run, and manage containers. This interaction
    occurs through a REST API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端是一个**命令行界面**（**CLI**）客户端，用于与 Docker 守护进程交互，构建、运行和管理容器。这一交互通过 REST
    API 实现。
- en: The Docker daemon is a background service that runs on the host machine and
    manages building, running, and distributing containers. It is the base for all
    the containers to run on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 守护进程是一个在主机机器上运行的后台服务，负责构建、运行和分发容器。它是所有容器运行的基础。
- en: The Docker registry is a repository to host, distribute, and download Docker
    images. Docker Hub is the default public registry with many pre-built images,
    but cloud providers usually have their own private container registry as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 注册表是一个用于托管、分发和下载 Docker 镜像的仓库。Docker Hub 是默认的公共注册表，里面有许多预构建的镜像，但云服务提供商通常也有自己的私有容器注册表。
- en: Finally, Docker images are read-only templates used to create Docker containers.
    Images define the container environment, dependencies, operating system, environment
    variables, and everything that a container needs to run.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Docker 镜像是只读的模板，用于创建 Docker 容器。镜像定义了容器的环境、依赖关系、操作系统、环境变量以及容器运行所需的一切。
- en: '*Figure 1**.1* shows the difference between an application running in a VM
    and an application running in a container.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.1* 显示了在虚拟机中运行的应用程序与在容器中运行的应用程序之间的区别。'
- en: '![Figure 1.1 – VMs versus containers](img/B21927_01_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 虚拟机与容器](img/B21927_01_01.jpg)'
- en: Figure 1.1 – VMs versus containers
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 虚拟机与容器
- en: '*Figure 1**.2* shows how a container runs with separate layer levels. There
    is the shared kernel at the bottom. On top of that, we have as many operating
    systems as we need. On top of the Debian OS layer, we see a Java 8 image and an
    NGINX image. The Java 8 layer is shared by three containers, one of them with
    only the image information and two using another image, Wildfly. The figure demonstrates
    why the container architecture is so efficient in sharing resources and lightweight
    because it is built upon layers of libraries, dependencies, and applications that
    will run isolated from each other.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.2* 显示了容器如何通过分层运行。底部是共享的内核。在此之上，我们可以有任意数量的操作系统层。Debian 操作系统层之上，我们看到 Java
    8 镜像和 NGINX 镜像。Java 8 层被三个容器共享，其中一个仅包含镜像信息，另外两个使用不同的镜像，Wildfly。该图展示了为什么容器架构如此高效地共享资源和轻量，因为它是建立在各类库、依赖关系和应用程序的层之上的，这些层会彼此隔离运行。'
- en: '![Figure 1.2 – Container layers](img/B21927_01_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 容器层](img/B21927_01_02.jpg)'
- en: Figure 1.2 – Container layers
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 容器层
- en: Now, let’s get to it. In the next section, you will learn how to install Docker
    and run your first Docker CLI commands.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始吧。在接下来的部分中，你将学习如何安装 Docker 并运行你的第一个 Docker CLI 命令。
- en: Installing Docker
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: To get started with Docker, you can install it by using the package manager
    for your Linux distribution or install Docker Desktop for Mac/Windows machines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Docker，你可以通过你所使用的 Linux 发行版的包管理器进行安装，或者为 Mac/Windows 机器安装 Docker Desktop。
- en: Windows
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: 'To use Docker Desktop on Windows, you must turn on the WSL 2 feature. Refer
    to this link for detailed instructions: [https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上使用 Docker Desktop，你必须启用 WSL 2 功能。参考此链接获取详细说明：[https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)。
- en: 'After that, you can install Docker Desktop as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以按照以下步骤安装 Docker Desktop：
- en: Go to [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    and download the installer.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)下载安装程序。
- en: When the download is ready, double-click the installer and follow the prompts.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，双击安装程序并按照提示操作。
- en: You should ensure that the **Use WSL 2 instead of Hyper-V** option is selected
    on the **Configuration** page. This is the recommended usage. (If your system
    does not support WSL 2, this option will not be available. You can still run Docker
    with Hyper-V, though.)
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该确保在 **配置** 页面上选择了 **使用 WSL 2 替代 Hyper-V** 选项。这是推荐的使用方式。（如果你的系统不支持 WSL 2，此选项将不可用。不过，你仍然可以使用
    Hyper-V 运行 Docker。）
- en: After the installation is finished, close to complete and start Docker Desktop.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，关闭并启动 Docker Desktop。
- en: 'If you have any doubts, refer to the official documentation: [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何疑问，请参考官方文档：[https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)。
- en: macOS
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: macOS
- en: 'The installation of Docker Desktop on macOS is quite simple:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Docker Desktop 非常简单：
- en: Go to [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    and download the installer for macOS.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)下载
    macOS 的安装程序。
- en: Double-click the installer and follow the prompts to install Docker Desktop.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击安装程序并按照提示安装 Docker Desktop。
- en: Once the installation completes, Docker Desktop will start automatically.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，Docker Desktop 将自动启动。
- en: Docker Desktop runs natively on macOS using the HyperKit VM and does not need
    additional configuration. When Docker Desktop starts for the first time, it will
    prompt you to authorize it for drive access. Authorize Docker Desktop to allow
    it to access files on your filesystem.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop 在 macOS 上原生运行，使用 HyperKit 虚拟机，无需额外配置。当 Docker Desktop 第一次启动时，它会提示你授权访问驱动器。授权
    Docker Desktop 允许其访问文件系统上的文件。
- en: Linux
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: 'Installing Docker on Linux-based systems is very straightforward. You can use
    your Linux distribution package manager to do that with just a few commands. For
    Ubuntu, for instance, the first thing is to remove any older versions of Docker
    that you previously had on the machine:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Linux 的系统上安装 Docker 非常简单。你只需要使用你的 Linux 发行版的包管理器，执行几条命令即可。例如，在 Ubuntu 上，首先需要删除你以前在机器上安装的任何旧版本的
    Docker：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can install Docker from the default `apt` repository using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式从默认的`apt`仓库安装Docker：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will install a slightly older version of Docker. If you want the latest
    version, check the official Docker website ([https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/))
    and follow the instructions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装一个稍微旧一点的Docker版本。如果你想要最新版本，请访问官方Docker网站（[https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/)）并按照说明操作。
- en: 'If you want to use Docker without having to `sudo` commands, run the following
    commands:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不使用`sudo`的情况下使用Docker，可以运行以下命令：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let’s get hands-on practice with Docker.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们动手实践Docker。
- en: Getting started with Docker images
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门Docker镜像
- en: The very first Docker image we can run is the `hello-world` image. It is often
    used to test whether Docker is correctly installed and running.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行的第一个Docker镜像是`hello-world`镜像。它通常用于测试Docker是否正确安装并运行。
- en: hello-world
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hello-world
- en: 'After the installation, open the terminal (Command Prompt in Windows) and run
    the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开终端（Windows中的命令提示符）并运行以下命令：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will pull the `hello-world` image from the Docker Hub public repository
    and run the application in it. If you can run it successfully, you will see this
    output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将从Docker Hub公共仓库拉取`hello-world`镜像并运行其中的应用。如果你成功运行它，你将看到以下输出：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations! You just ran your first Docker image! Now, let’s try something
    a little more ambitious.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚运行了第一个Docker镜像！现在，让我们尝试一些更有挑战性的操作。
- en: NGINX
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGINX
- en: NGINX is a well-known open source software for web serving, reverse proxying,
    and caching. It is widely used in Kubernetes-based architectures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX是一个著名的开源软件，广泛用于Web服务、反向代理和缓存。它在基于Kubernetes的架构中得到了广泛应用。
- en: 'Different from the `hello-world` application (which behaves like a job execution),
    NGINX behaves like a service. It opens a port and keeps listening for user requests.
    We can start by searching for the available NGINX images in Docker Hub using the
    following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与`hello-world`应用（它表现得像一个作业执行程序）不同，NGINX表现得像一个服务。它会打开一个端口并持续监听用户请求。我们可以通过以下方式在Docker
    Hub中搜索可用的NGINX镜像：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will show several available images. Usually, the first in the list
    is the official image. Now, to set up a running NGINX container, we can use the
    following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示几个可用的镜像。通常，列表中的第一个是官方镜像。现在，为了设置一个运行中的NGINX容器，我们可以使用以下命令：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will download the current latest version of the image. The `latest` keyword
    after the colon stands for the “tag” of this image. To install a specific version
    (recommended), specify the tag like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载当前的最新版本镜像。冒号后面的`latest`关键字代表该镜像的“标签”。如果要安装特定版本（推荐），请像这样指定标签：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can visit [https://hub.docker.com/_/nginx](https://hub.docker.com/_/nginx)
    to check for all the available tags.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问[https://hub.docker.com/_/nginx](https://hub.docker.com/_/nginx)查看所有可用的标签。
- en: 'Now, to run the container, you should specify which version of the image you
    want to use. The following command will do the trick:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了运行容器，你应该指定想要使用的镜像版本。以下命令可以完成这个任务：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will start to see NGINX logs in the terminal. Then, open your preferred
    browser and type `http://localhost/`. You should see this message (*Figure 1**.3*):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始在终端中看到NGINX日志。然后，打开你喜欢的浏览器，输入`http://localhost/`。你应该能看到这个信息（*图1.3*）：
- en: '![Figure 1.3 – The nginx default output in the browser](img/B21927_01_3.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 浏览器中的nginx默认输出](img/B21927_01_3.jpg)'
- en: Figure 1.3 – The nginx default output in the browser
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 浏览器中的nginx默认输出
- en: The `docker run` command has a few important parameters. `--name` defines the
    name of the container that will run. If you don’t define a name, Docker will automatically
    choose a name for it (trust me, it can be very creative). `-p` connects a port
    on your machine (port `80`) to a port inside the container (also `80`). If you
    do not open this port, you won’t be able to reach the container’s running application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令有一些重要的参数。`--name`定义了将运行的容器名称。如果你没有定义名称，Docker会自动为它选择一个名字（相信我，它可以非常有创意）。`-p`将你机器上的一个端口（端口`80`）连接到容器内的一个端口（同样是`80`）。如果你不打开这个端口，你将无法访问容器中的应用程序。'
- en: 'After your test is successful, get back to the terminal running the container
    and press “CTRL + C” to stop the container. After it stops, it will still be there,
    although not running. To remove the container, use the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试成功后，返回到运行容器的终端并按下“CTRL + C”停止容器。停止后，容器仍然存在，尽管不再运行。要删除容器，请使用以下命令：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you are in doubt, you can see all the running and stopped containers with
    this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，你可以使用此命令查看所有正在运行和已停止的容器：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also can see all the locally available images with this command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这个命令查看所有本地可用的镜像：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In my case, the output shows three images: `hello-world` and two NGINX images,
    one of them with the `latest` tag and the other with the `1.25.2-alpine-slim`
    tag. All images and their respective versions will show.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，输出显示了三个镜像：`hello-world` 和两个 NGINX 镜像，其中一个是 `latest` 标签，另一个是 `1.25.2-alpine-slim`
    标签。所有镜像及其对应版本都会显示。
- en: Julia
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Julia
- en: 'In this last example, we will learn how to use technology that is not installed
    in our machine by interacting with running containers. We will run a container
    with a new and efficient programming language for data science called Julia. To
    do that, execute the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的示例中，我们将学习如何通过与正在运行的容器进行交互，使用我们机器上未安装的技术。我们将运行一个名为 Julia 的新型高效编程语言容器，它适用于数据科学。执行以下命令来实现：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the `docker run` command looks for a local image. If it’s not downloaded,
    Docker will automatically pull the image from Docker Hub. With the preceding command,
    we will start an interactive session in a Julia 1.9.3 container. The `-it` parameters
    allow us to use it interactively. The `--rm` parameter states that the container
    will automatically be removed after it is stopped, so we don’t have to manually
    remove it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`docker run` 命令会查找本地镜像。如果本地没有该镜像，Docker 会自动从 Docker Hub 拉取镜像。使用前面的命令，我们将在
    Julia 1.9.3 容器中启动一个交互式会话。`-it` 参数使我们可以交互使用该容器。`--rm` 参数表示容器停止后会自动删除，因此我们无需手动删除它。
- en: 'After the container is up and running, let’s play with a simple custom function
    to calculate two descriptive statistics: a mean and a standard deviation. You
    will see a Julia’s logo in the terminal, and you can use the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动并运行后，我们将尝试一个简单的自定义函数来计算两个描述性统计量：均值和标准差。你会在终端看到 Julia 的标志，并可以使用以下命令：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After defining the function, we will run it with a small array of random numbers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好函数后，我们将用一个小的随机数字数组来运行它：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the proper output on the screen. Congratulations! You have just
    used the Julia programming language without having to install or configure it
    on your computer with Docker! To exit the container, use the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在屏幕上看到正确的输出。恭喜你！你刚刚使用了 Julia 编程语言，而无需在你的计算机上安装或配置它，只需通过 Docker！要退出容器，请使用以下命令：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we used the `--rm` parameter, if we run the `docker ps -a` command, we will
    see that it has been automatically removed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 `--rm` 参数，如果运行 `docker ps -a` 命令，我们会看到它已被自动删除。
- en: Building your own image
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的镜像
- en: Now, we will customize our own container images for running a simple data processing
    job and an API service.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定制自己的容器镜像，以便运行一个简单的数据处理任务和 API 服务。
- en: Batch processing job
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批处理任务
- en: 'Here is a simple Python code for a batch processing job:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的 Python 代码示例，用于批处理任务：
- en: '**run.py**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**run.py**'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This Python code loads a CSV dataset from a URL into a pandas DataFrame, adding
    a new column by multiplying an existing column by 2 and then printing out some
    information about the DataFrame (column names, first five rows, and size of the
    DataFrame). Type this code using your favorite code editor and save the file with
    the name `run.py`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Python 代码从 URL 加载 CSV 数据集到 pandas DataFrame，新增一列，方法是将现有列的值乘以 2，然后打印出 DataFrame
    的一些信息（列名、前五行以及 DataFrame 的大小）。在你喜欢的代码编辑器中键入这段代码，并将文件保存为 `run.py`。
- en: 'Normally, we test our code locally (whenever possible) to be sure it is working.
    To do that, first, you need to install the `pandas` library:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在本地测试代码（尽可能地），以确保它能够正常工作。为此，首先需要安装 `pandas` 库：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, run the code with the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令运行代码：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If all goes well, you should see an output like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到如下输出：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we are ready to package our simple processing job into a container. Let’s
    start by defining a Dockerfile:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将我们的简单处理任务打包到一个容器中了。让我们先定义一个 Dockerfile：
- en: '**Dockerfile_job**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile_job**'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Those are the only four lines we need to define a working container. The first
    line specifies the base image to use, which is a slim version of `Python 3.11.6`.
    This is a Debian-based OS that already has `Python 3.11.6` installed, which can
    save us a lot of time. Using a slim image is very important to keep the container
    size small and optimize transfer time and storage costs (when it’s the case).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行就是我们定义一个工作容器所需要的内容。第一行指定了要使用的基础镜像，这是一个精简版的 `Python 3.11.6`。它是基于 Debian 的操作系统，已经安装了
    `Python 3.11.6`，这能为我们节省大量时间。使用精简镜像非常重要，因为它能保持容器大小小巧，优化传输时间和存储成本（如果适用）。
- en: 'The second line installs the `pandas` library. The third line copies the local
    `run.py` file into the container. Finally, the last line sets the default command
    to run when the container starts to execute the `/run.py` script. After you are
    done defining the code, save it as `Dockerfile_job` (no `.extension`). Now, it’s
    time to build our Docker image:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行安装了 `pandas` 库。第三行将本地的 `run.py` 文件复制到容器中。最后一行设置了容器启动时执行的默认命令，即运行 `/run.py`
    脚本。在定义完代码后，保存为 `Dockerfile_job`（没有 `.extension`）。现在，是时候构建我们的 Docker 镜像了：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `docker build` command builds an image according to the Dockerfile instructions.
    Usually, this command expects a file named `Dockerfile`. Since we are working
    with a filename different from expected, we must tell Docker which file to use
    with the `-f` flag. The `-t` flag defines a tag for the image. It is composed
    of a name and a version, separated by a colon (`:`). In this case, the name we
    set for the image is `data_processing_job` and a `1.0` version. The last parameter
    to this command is the path where code files are located. Here, we set the current
    folder with a dot (`.`). This dot is very easy to forget, so be careful!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 命令根据 Dockerfile 中的指令构建镜像。通常，这个命令会期望一个名为 `Dockerfile` 的文件。由于我们使用的文件名与预期不同，因此我们必须使用
    `-f` 标志告诉 Docker 使用哪个文件。`-t` 标志定义了镜像的标签。标签由名称和版本组成，中间用冒号（`:`）分隔。在这种情况下，我们为镜像设置的名称是
    `data_processing_job`，版本是 `1.0`。该命令的最后一个参数是代码文件所在的路径。这里我们设置了当前文件夹，使用一个点（`.`）。这个点很容易忘记，所以请小心！'
- en: 'After the build is finished, we can check the locally available images with
    this command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以通过以下命令检查本地可用的镜像：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see the first line of the output showing your recently built data
    processing image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在输出的第一行看到你刚刚构建的数据显示处理镜像：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, to run our data processing job from inside the container, use this command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在容器内部运行我们的数据处理任务，请使用以下命令：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `docker run` command runs the specified image. The `--name` flag defines
    the name of the container as `data_processing`. After you start running the container,
    you should see the same output as before:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令运行指定的镜像。`--name` 标志定义容器的名称为 `data_processing`。当你启动容器时，应该会看到与之前相同的输出：'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, don’t forget to remove the exited containers from your environment:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了清理你环境中的退出容器：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Congrats! You have run your first job using containers. Now, let’s move to
    another type of containerized application: a service.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经使用容器运行了第一个任务。接下来，让我们进入另一种容器化应用类型：服务。
- en: API service
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 服务
- en: In this section, we will use `app`, and create a Python script named `main.py`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将使用 `app`，并创建一个名为 `main.py` 的 Python 脚本。
- en: 'In the script, first, we import FastAPI and the random module:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，首先导入 FastAPI 和 random 模块：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we create an instance of the FastAPI app:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建 FastAPI 应用实例：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next code block defines a route using the `@``app.get` decorator:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块使用 `@``app.get` 装饰器定义一个路由：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `@app.get` decorator indicates that this is a `GET` endpoint. This function
    is defined to answer at the `"/api"` route. It just returns a pleasant message
    on request of the route.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`@app.get` 装饰器表示这是一个 `GET` 类型的端点。这个函数被定义为响应 `"/api"` 路由的请求。它只是在请求该路由时返回一个愉快的消息。'
- en: 'The next code chunk defines a route, `"/api/{name}"`, where `name` is a parameter
    that will be received in the request. It returns a greeting message with the given
    name:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块定义了一个路由 `"/api/{name}"`，其中 `name` 是在请求中接收的参数。它返回一个包含给定名称的问候信息：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last code block defines a `"/joke"` route. This function returns a (very
    funny!) random joke from the list of jokes previously defined. Feel free to replace
    them with your own cool jokes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码块定义了 `"/joke"` 路由。这个函数从之前定义的笑话列表中随机返回一个（非常有趣的！）笑话。可以随意用你自己酷的笑话替换它们：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is important to notice that every function returns a response in JSON format.
    This is a very common pattern with APIs. For the whole Python code, refer to the
    book’s GitHub repository ([https://github.com/PacktPublishing/Bigdata-on-Kubernetes](https://github.com/PacktPublishing/Bigdata-on-Kubernetes)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，每个函数都返回一个 JSON 格式的响应。这是 API 中非常常见的模式。有关完整的 Python 代码，请参考本书的 GitHub 仓库（[https://github.com/PacktPublishing/Bigdata-on-Kubernetes](https://github.com/PacktPublishing/Bigdata-on-Kubernetes)）。
- en: 'Before we build the Docker image, it is advised to test the code locally (whenever
    possible). To do this, you must install the `fastapi` and `uvicorn` packages.
    Run this command in the terminal:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建 Docker 镜像之前，建议先在本地测试代码（尽可能的话）。为此，你需要安装 `fastapi` 和 `uvicorn` 包。在终端中运行以下命令：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To run the API, use the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 API 时，使用以下命令：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If all goes well, you will see an output like this in the terminal:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将在终端中看到如下输出：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This command runs the API service locally on port `8087`. To test it, open a
    browser and access `http://localhost:8087/api`. You should see the programmed
    message on the screen. Test the `http://localhost:8087/api/<YOUR_NAME>` and `http://localhost:8087/joke`
    endpoints as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在 `8087` 端口本地运行 API 服务。要进行测试，请打开浏览器并访问 `http://localhost:8087/api`。你应该能看到屏幕上显示的编程消息。也可以测试
    `http://localhost:8087/api/<YOUR_NAME>` 和 `http://localhost:8087/joke` 端点。
- en: 'Now that we know everything is working fine, let’s package the API in a Docker
    image. To do that, we will build a simple Dockerfile. To optimize it, we will
    use the `alpine` linux distribution, an extremely lightweight base OS. In the
    root folder of your project, create a new file named `Dockerfile` (no `.extension`).
    This is the code we will use for this image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道一切运行正常，接下来将 API 打包成 Docker 镜像。为此，我们将构建一个简单的 Dockerfile。为了优化它，我们将使用 `alpine`
    Linux 发行版，这是一种极为轻量的基础操作系统。在项目的根文件夹中创建一个名为 `Dockerfile`（没有 `.extension`）的新文件。这是我们将用于该镜像的代码：
- en: '**Dockerfile**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile**'
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first line imports a Python container based on the `alpine` Linux distribution.
    The second line installs `fastapi` and `uvicorn`. The third line informs Docker
    that the container will listen on port `8087` at runtime. Without this command,
    we would not be able to access the API service. The fourth line copies all the
    code inside our local `/app` folder to a `/app` folder inside the container. Finally,
    the `CMD` command specifies the command to run when the container starts. Here,
    we are starting the `uvicorn` server to run our FastAPI application. After `uvicorn`,
    we state a location pattern of `folder.script_name:FastAPI_object_name` to tell
    FastAPI where to look for the API process object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入基于 `alpine` Linux 发行版的 Python 容器。第二行安装 `fastapi` 和 `uvicorn`。第三行告知 Docker，容器在运行时将监听
    `8087` 端口。如果没有这条命令，我们将无法访问 API 服务。第四行将本地 `/app` 文件夹中的所有代码复制到容器内的 `/app` 文件夹中。最后，`CMD`
    命令指定了容器启动时要运行的命令。在这里，我们启动 `uvicorn` 服务器来运行我们的 FastAPI 应用程序。在 `uvicorn` 后面，我们指定了一个位置模式
    `folder.script_name:FastAPI_object_name`，以告诉 FastAPI 在哪里查找 API 进程对象。
- en: 'When this Dockerfile is built into an image, we will have a containerized Python
    application configured to run a FastAPI web server on port `8087`. The Dockerfile
    allows us to package up the application and its dependencies into a standardized
    unit for deployment. To build the image, run the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个 Dockerfile 被构建成镜像时，我们将得到一个容器化的 Python 应用程序，配置为在 `8087` 端口运行 FastAPI Web
    服务器。Dockerfile 允许我们将应用程序及其依赖项打包成一个标准化的部署单元。要构建镜像，请运行以下命令：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: No need to specify the `-f` flag here since we are using a Dockerfile with the
    default name. And remember the dot at the end of the line!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里无需指定 `-f` 标志，因为我们使用的是默认名称的 Dockerfile。记得在命令末尾加上一个点！
- en: 'Now, we run the container with a slightly different set of parameters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用稍微不同的一组参数来运行容器：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `-p` parameter sets that we will open port `8087` in the server (in this
    case, your computer) to port `8087` in the container. If we don’t set this parameter,
    there is no way to communicate with the container whatsoever. The `-d` parameter
    runs the container in *detached* mode. The terminal will not be showing container
    logs but it will be available for use while the container is running in the background.
    The `--rm` parameter sets the container to be automatically removed after it is
    finished (very handy). Finally, `--name` sets the name for the container as `api`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 参数设置了我们将在服务器（在此情况下为你的计算机）中将 `8087` 端口映射到容器中的 `8087` 端口。如果不设置此参数，就无法与容器进行任何通信。`-d`
    参数以 *分离* 模式运行容器。终端将不会显示容器日志，但容器会在后台运行，终端仍然可以使用。`--rm` 参数设置容器在完成后自动删除（非常方便）。最后，`--name`
    为容器设置名称为 `api`。'
- en: 'We can check whether the container is correctly running with the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查容器是否正确运行：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you need to check the logs to a container, use the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要查看容器的日志，请使用以下命令：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see an output similar to this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似如下的输出：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, we can test our API endpoints in the browser with the same links shown
    before (`http://localhost:8087/api, http://localhost:8087/api/<YOUR_NAME>` and
    `http://localhost:8087/joke`).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过之前显示的相同链接在浏览器中测试我们的 API 端点（`http://localhost:8087/api`、`http://localhost:8087/api/<YOUR_NAME>`
    和 `http://localhost:8087/joke`）。
- en: Congrats! You are running your API service from inside a container. This is
    a completely portable and self-contained application that can be deployed anywhere.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经在容器内部运行了你的 API 服务。这是一个完全便携且自包含的应用程序，可以部署到任何地方。
- en: 'To stop the API service, use the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止 API 服务，请使用以下命令：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To check that the stopped container has been automatically removed, use the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查已停止的容器是否已被自动删除，请使用以下命令：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Nicely done!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 做得很好！
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the fundamentals of containers and how to build
    and run them using Docker. Containers provide a lightweight and portable way to
    package applications and their dependencies so they can run reliably across environments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了容器的基本原理以及如何使用 Docker 构建和运行它们。容器提供了一种轻量级、便携的方式来打包应用程序及其依赖项，以便它们能够在各种环境中可靠地运行。
- en: You learned about key concepts such as images, containers, Dockerfiles, and
    registries. We installed Docker and ran simple containers such as NGINX and Julia
    to get hands-on experience. You built your own containers for a batch processing
    job and API service, defining Dockerfiles to package dependencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了关键概念，例如镜像、容器、Dockerfile 和仓库。我们安装了 Docker，并运行了简单的容器，如 NGINX 和 Julia，进行实践操作。你还为批处理作业和
    API 服务构建了自己的容器，定义了 Dockerfile 来打包依赖项。
- en: These skills allow you to develop applications and containerize them for smooth
    deployment anywhere. Containers are super useful as they ensure your software
    runs exactly as intended every time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技能使你能够开发应用程序并将其容器化，以便能够顺利地在任何地方部署。容器非常有用，因为它们确保每次都能按预期运行你的软件。
- en: In the next chapter, we will look at orchestrating containers using Kubernetes
    to easily scale, monitor, and manage containerized applications. We will take
    a look at the most important Kubernetes concepts and components and learn how
    to implement them with YAML files (manifests).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Kubernetes 来编排容器，轻松地扩展、监控和管理容器化应用程序。我们将重点介绍 Kubernetes 中最重要的概念和组件，并学习如何通过
    YAML 文件（清单）实现它们。
