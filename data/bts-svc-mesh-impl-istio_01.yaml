- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing Service Meshes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格简介
- en: '**Service Mesh** are an advanced and complex topic. If you have experience
    using the cloud, Kubernetes, and developing and building an application using
    microservices architecture, then certain benefits of Service Mesh will be obvious
    to you. In this chapter, we will familiarize ourselves with and refresh some key
    concepts without going into too much detail. We will look at the problems you
    experience when you are deploying and operating applications built using microservices
    architecture and deployed on containers in the cloud, or even traditional data
    centers. Subsequent chapters will focus on Istio, so it is good to take some time
    to read through this chapter to prepare yourself for the learning ahead.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务网格**是一个高级且复杂的话题。如果你有使用云、Kubernetes，及基于微服务架构开发和构建应用程序的经验，那么你会很容易理解服务网格带来的一些好处。在本章中，我们将熟悉并回顾一些关键概念，而不会深入讨论细节。我们将探讨在使用微服务架构构建的应用程序在云端或传统数据中心中部署和运行时遇到的问题。后续章节将重点讲解Istio，因此花些时间阅读本章，对你后续的学习将大有裨益。'
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Cloud computing and its advantages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算及其优势
- en: Microservices architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Kubernetes and how it influences design thinking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes及其对设计思维的影响
- en: An introduction to Service Mesh
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格简介
- en: The concepts in the chapter will help you build an understanding of Service
    Mesh and why they are needed. It will also provide you guidance on identifying
    some of the signals and symptoms in your IT environment that indicate you need
    to implement Service Mesh. If you don’t have hands-on experience in dealing with
    large-scale deployment architecture using Kubernetes, cloud, and microservices
    architecture, then this chapter will familiarize you with these concepts and give
    you a good start toward understanding more complex subjects in subsequent chapters.
    Even if you are already familiar with these concepts, it will still be a good
    idea to read this chapter to refresh your memory and experiences.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的概念将帮助你建立对服务网格的理解，并说明它们为何必要。它还将指导你识别IT环境中一些迹象和症状，提示你需要实施服务网格。如果你没有在使用Kubernetes、云和微服务架构的大规模部署中积累实践经验，那么本章将帮助你熟悉这些概念，为你后续理解更复杂的内容打下良好的基础。即使你已经熟悉这些概念，阅读本章也能帮助你刷新记忆和经验。
- en: Revisiting cloud computing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视云计算
- en: In this section, we will look at what cloud computing is in simple terms, what
    benefits it provides, how it influences design thinking, as well software development
    processes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍什么是云计算，它带来了哪些好处，如何影响设计思维，以及软件开发流程。
- en: '**Cloud computing** is utility-style computing with a business model similar
    to what is provided by businesses selling utilities such as LPG and electricity
    to our homes. You don’t need to manage the production, distribution, or operation
    of electricity. Instead. you focus on consuming it effectively and efficiently
    by just plugging in your device to the socket on the wall, using the device, and
    paying for what you consume. Although this example is very simple, it is still
    very relevant as an analogy. Cloud computing providers provide access to compute,
    storage, databases, and a plethora of other services, including **Infrastructure
    as a Service** (**IaaS**), **Platform as a Service** (**PaaS**), and **Software
    as a Service** (**SaaS**) over the internet.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**云计算**是一种类似于我们家中使用的公共事业服务（如液化气和电力）的计算方式。你不需要管理电力的生产、分配或运作。相反，你只需通过插入电源插座来有效、经济地使用设备，使用设备，并为你消费的电力付费。虽然这个例子非常简单，但作为类比，它仍然很有意义。云计算提供商通过互联网提供计算、存储、数据库以及其他众多服务，包括**基础设施即服务**（**IaaS**）、**平台即服务**（**PaaS**）和**软件即服务**（**SaaS**）。'
- en: '![Figure 1.1 – Cloud computing options](img/B17989_01_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 云计算选项](img/B17989_01_01.jpg)'
- en: Figure 1.1 – Cloud computing options
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 云计算选项
- en: '*Figure 1**.1* illustrates the cloud computing options most commonly used:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.1* 展示了最常用的云计算选项：'
- en: '**IaaS** provides infrastructure such as networking to connect your application
    with other systems in your organization, as well as everything else you would
    like to connect to. IaaS gives you access to computational infrastructure to run
    your application, equivalent to **Virtual Machines** (**VMs**) or bare-metal servers
    in traditional data centers. It also provides storage for host data for your applications
    to run and operate. Some of the most popular IaaS providers are Amazon EC2, Azure
    virtual machines, Google Compute Engine, Alibaba E-HPC (which is very popular
    in China and the Greater China region), and VMware vCloud Air.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IaaS** 提供了如网络等基础设施，以便将你的应用程序与组织内的其他系统连接，并且连接到你想要的所有其他资源。IaaS 让你可以访问计算基础设施来运行你的应用程序，类似于传统数据中心中的
    **虚拟机**（**VMs**）或裸机服务器。它还提供了存储用于主机数据的资源，支持你的应用程序运行和操作。一些最受欢迎的 IaaS 提供商包括 Amazon
    EC2、Azure 虚拟机、Google Compute Engine、阿里巴巴 E-HPC（在中国及大中华区非常受欢迎）和 VMware vCloud Air。'
- en: '**PaaS** is another kind of offering that provides you with the flexibility
    to focus on building applications rather than worrying about how your application
    will be deployed, monitored, and so on. PaaS includes all that you get from IaaS
    but also middleware to deploy your applications, development tools to help you
    build applications, databases to store data, and so on. PaaS is especially beneficial
    for companies adopting microservices architecture. When adopting microservices
    architecture, you also need to build an underlying infrastructure to support microservices.
    The ecosystem required to support microservices architecture is expensive and
    complex to build. Making use of PaaS to deploy microservices makes microservices
    architecture adoption much faster and easier. There are many examples of popular
    PaaS services from cloud providers. However, we will be using Amazon **Elastic
    Kubernetes Service** (**EKS**) as a PaaS to deploy the sample application we will
    explore hands-on with Istio.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PaaS** 是另一种服务，它为你提供了灵活性，让你可以专注于构建应用程序，而不必担心应用程序如何部署、监控等。PaaS 包含了你从 IaaS 中得到的一切，同时还包括用于部署应用程序的中间件、帮助你构建应用程序的开发工具、存储数据的数据库等。PaaS
    对于采用微服务架构的公司尤其有益。在采用微服务架构时，你还需要构建一个支持微服务的底层基础设施。构建支持微服务架构所需的生态系统既昂贵又复杂。利用 PaaS
    来部署微服务可以让微服务架构的采用变得更快、更容易。云服务提供商有许多流行的 PaaS 服务。我们将在这里使用 Amazon **Elastic Kubernetes
    Service**（**EKS**）作为 PaaS 来部署我们将要通过 Istio 实践的示例应用程序。'
- en: '**SaaS** is another kind of offering that provides a complete software solution
    that you can use as a service. It is easy to get confused between PaaS and SaaS
    services, so to make things simple, you can think of SaaS as services that you
    can consume without needing to write or deploy any code. For example, it’s highly
    likely that you are using an email service as SaaS with the likes of Gmail. Moreover,
    many organizations use productivity software that is SaaS, and popular examples
    are services such as Microsoft Office 365\. Other examples include CRM systems
    such as Salesforce and **enterprise resource planning** (**ERP**) systems. Salesforce
    also provides a PaaS offering where Salesforce apps can be built and deployed.
    Salesforce Essentials for small businesses, Sales Cloud, Marketing Cloud, and
    Service Cloud are SaaS offerings, whereas Salesforce Platform, which is a low-code
    service for users to build Salesforce applications, is a PaaS offering. Other
    popular examples of SaaS are Google Maps, Google Analytics, Zoom, and Twilio.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaaS** 是另一种服务，它提供了一个完整的软件解决方案，作为一种服务供你使用。PaaS 和 SaaS 服务之间容易混淆，因此简单来说，你可以将
    SaaS 看作是你无需编写或部署任何代码即可消费的服务。例如，你很可能正在使用像 Gmail 这样的邮件服务作为 SaaS。此外，许多组织也使用作为 SaaS
    提供的生产力软件，流行的例子有 Microsoft Office 365 等服务。其他例子包括像 Salesforce 这样的客户关系管理（CRM）系统和
    **企业资源规划**（**ERP**）系统。Salesforce 还提供了一个 PaaS 服务，在这个平台上可以构建和部署 Salesforce 应用程序。Salesforce
    为小型企业提供的 Salesforce Essentials、Sales Cloud、Marketing Cloud 和 Service Cloud 是 SaaS
    服务，而 Salesforce Platform 是一个低代码服务，供用户构建 Salesforce 应用程序，它属于 PaaS 服务。其他流行的 SaaS
    示例包括 Google Maps、Google Analytics、Zoom 和 Twilio。'
- en: 'Cloud services providers also provide different kinds of cloud offerings, with
    varying business models, access methods, and target audiences. Out of many such
    offerings, the most common are a public cloud, a private cloud, a hybrid cloud,
    and a community cloud:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商还提供不同种类的云服务，拥有不同的商业模式、访问方式和目标受众。在这些服务中，最常见的有公共云、私有云、混合云和社区云：
- en: A **public cloud** is the one you most probably are familiar with. This offering
    is available over the internet and is accessible to anyone and everyone with the
    ability to subscribe, using a credit card or similar payment mechanism.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共云**是你最可能熟悉的云服务。这种服务可以通过互联网访问，任何人只要能够订阅，就可以使用，通常通过信用卡或类似的支付方式。'
- en: A **private cloud** is a cloud offering that can be accessed over the internet
    or a restricted private network to a restricted set of users. A private cloud
    can be an organization providing IaaS or PaaS to its IT users; there are also
    service providers who provide a private cloud to organizations. The private cloud
    delivers a high level of security and is widely used by organizations that have
    highly sensitive data.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有云**是一种可以通过互联网或限制性私有网络访问的云服务，通常面向一组受限的用户。私有云可以是组织为其IT用户提供IaaS或PaaS服务；也有服务提供商向组织提供私有云服务。私有云提供高度的安全性，广泛用于那些拥有高度敏感数据的组织。'
- en: A **hybrid cloud** refers to an environment where public and private clouds
    are collectively used. Also, a hybrid cloud is commonly used when more than one
    cloud offering is in use – for example, an organization using both AWS and Azure
    with applications deployed and data flowing across the two. A hybrid cloud is
    a good option when there are data and applications that are required to be hosted
    in a private cloud due to security reasons. Conversely, there may be other applications
    that don’t need to reside in the private cloud and can benefit from the scalability
    and elasticity features of a public cloud. Rather than restricting yourself to
    a public or private cloud, or one cloud provider or another, you should reap the
    benefit of the strengths of various cloud providers and create an IT landscape
    that is secure, resilient, elastic, and cost-effective.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合云**指的是在一个环境中同时使用公共云和私有云。混合云通常用于同时使用多个云服务的场景——例如，一个组织同时使用AWS和Azure，在这两个云平台之间进行应用程序部署和数据流转。混合云是一个很好的选择，当某些数据和应用程序因安全原因需要托管在私有云中时。相反，可能还有一些应用程序不需要驻留在私有云中，而可以从公共云的可扩展性和弹性功能中获益。与其局限于公共云或私有云，或者选择某一云服务提供商，你应该利用各种云服务提供商的优势，创建一个安全、韧性强、弹性十足且具有成本效益的IT环境。'
- en: A **community cloud** is another cloud offering available to a set of organizations
    and users. Some good examples are AWS GovCloud in the US, which is a community
    cloud for the US government. This kind of cloud restricts who can use it – for
    example, AWS GovCloud can only be used by US government departments and agencies.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区云**是另一种面向一组组织和用户的云服务。一个好的例子是美国的AWS GovCloud，它是为美国政府提供的社区云。这种云服务限制了使用者的范围——例如，AWS
    GovCloud只能由美国政府部门和机构使用。'
- en: Now that you understand the true crux of cloud computing, let’s look at some
    of its key advantages in the following section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了云计算的核心内容，接下来让我们在以下章节中看看它的一些关键优势。
- en: Advantages of cloud computing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云计算的优势
- en: Cloud computing enables organizations to easily access all kinds of technologies
    without going through high upfront investment in expensive hardware and software
    procurement. By utilizing cloud computing, organizations achieve agility, as they
    can innovate faster by having access to high-end compute power and infrastructure
    (such as a load balancer, compute instances, and so on) and also to software services
    (such as machine learning, analytics, messaging infrastructure, AI, databases,
    and so on) that can be integrated as building blocks in a plug-and-play style
    to build software applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算使得组织能够轻松访问各种技术，而无需经历高额的前期投资去采购昂贵的硬件和软件。通过利用云计算，组织实现了敏捷性，因为它们可以通过获得高端计算能力和基础设施（例如负载均衡器、计算实例等）以及软件服务（例如机器学习、分析、消息传输基础设施、AI、数据库等）来加速创新，并且这些服务可以像插件一样集成，帮助构建软件应用程序。
- en: 'For example, if you’re building a software application, then most probably
    it will need the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在构建一个软件应用程序，那么它很可能需要以下内容：
- en: Load balancers
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: Databases
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Servers to run and compute servers to host an application
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器用于运行和计算，服务器用于托管应用程序
- en: Storage to host the application binaries, logs, and so on
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储用于托管应用程序二进制文件、日志等
- en: A messaging system for asynchronous communication
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于异步通信的消息系统
- en: You will need to procure, set up, and configure this infrastructure in an on-premises
    data center. This activity, though important for launching and operationalizing
    your applications in production, does not produce any business differentiators
    between you and your competition. High availability and resiliency of your software
    application infrastructure is a requirement that is required to sustain and survive
    in the digital world. To compete and beat your competition, you need to focus
    on customer experience and constantly delivering benefits to your consumers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在本地数据中心采购、搭建并配置基础设施。尽管这项活动对于在生产环境中启动和运营应用程序至关重要，但它不会在你与竞争对手之间产生任何业务上的差异化。软件应用程序基础设施的高可用性和弹性是维持和生存于数字世界中的必要条件。要与竞争对手竞争并击败他们，你需要专注于客户体验，并不断为消费者提供价值。
- en: 'When deploying on-premises, you need to factor in all upfront costs of procuring
    infrastructure, which include the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地部署时，你需要考虑所有采购基础设施的前期成本，包括以下内容：
- en: Network devices and bandwidth
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备和带宽
- en: Load balancers
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: A firewall
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙
- en: Servers and storage
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和存储
- en: Rack space
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机架空间
- en: Any new software required to run the application
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序所需的任何新软件
- en: 'All the preceding costs will incur **Capital Expenditures** (**CapEx**) for
    the project. You will also need to factor in the setup cost, which includes the
    following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以上所有成本将会产生项目的**资本支出**（**CapEx**）。你还需要考虑搭建成本，包括以下内容：
- en: Network, compute servers, and cabling
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络、计算服务器和电缆
- en: Virtualization, operating systems, and base configuration
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化、操作系统和基础配置
- en: Setup of middleware such as application servers and web servers (if using containerization,
    then the setup of container platforms, databases, and messaging)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件的搭建，如应用服务器和Web服务器（如果使用容器化，则包括容器平台、数据库和消息中间件的搭建）
- en: Logging, auditing, alarming, and monitoring components
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录、审计、报警和监控组件
- en: All the preceding will incur CapEx for the project but may fall under the organization’s
    **Operating** **Expenses** (**OpEx**).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以上所有活动将会产生项目的资本支出（CapEx），但可能会计入组织的**运营****费用**（**OpEx**）。
- en: On top of the aforementioned additional costs, the most important factor to
    consider is the time and human resources required to procure, set up, and make
    the infrastructure ready for use. This significantly impacts your ability to launch
    features and services on the market (also called *agility* and *time* *to market*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述的附加成本外，最重要的考虑因素是采购、搭建并使基础设施准备就绪所需的时间和人力资源。这将显著影响你将功能和服务推向市场的能力（这也被称为*敏捷性*和*市场时间*）。
- en: When using the cloud, these costs can be procured with a pay-as-you-go model.
    Where you need compute and storage, it can be procured in the form of IaaS, and
    where you need middleware, it can be procured in the form of PaaS. You will realize
    that some of the functionality you need to build might be already available as
    SaaS. This expedites your software delivery and time to market. On the cost front,
    some of the costs will still incur CapEx for your project, but your organization
    can claim it as OpEx, which has certain benefits from a tax point of view. Whereas
    it previously took months of preparation to set up all that you needed to deploy
    your application, it can now be done in days or weeks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云计算时，这些成本可以通过按需付费模型进行采购。在需要计算和存储的地方，可以以IaaS的形式进行采购，而在需要中间件的地方，可以以PaaS的形式进行采购。你会发现，你需要构建的某些功能可能已经作为SaaS可用。这加快了软件交付和市场推向速度。在成本方面，某些成本仍将产生项目的资本支出（CapEx），但你的组织可以将其计入运营费用（OpEx），这在税务方面具有一定的优势。以前，部署应用程序所需的所有准备工作可能需要几个月的时间，而现在可以在几天或几周内完成。
- en: Cloud computing also changes the way you design, develop, and operate IT systems.
    In *Chapter 4*, we will look at cloud-native architecture and how it differs from
    traditional architecture.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算还改变了你设计、开发和运营IT系统的方式。在*第4章*中，我们将探讨云原生架构及其与传统架构的区别。
- en: Cloud computing makes it easier to build and ship software applications with
    low upfront investments. The following section describes microservices architecture
    and how it is used to build and deliver highly scalable and resilient applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算使得构建和发布软件应用变得更加容易，并且前期投资较低。以下部分将描述微服务架构以及它如何用于构建和交付高度可扩展和具备弹性的应用程序。
- en: Understanding microservices architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务架构
- en: Before we discuss microservices architecture, let’s first discuss **monolithic
    architecture**. It’s highly likely that you will have encountered or probably
    even participated in building one. To understand it better, let’s take a scenario
    and see how it has been traditionally solved using monolithic architecture.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论微服务架构之前，我们先讨论一下**单体架构**。你很可能已经接触过或甚至参与过单体架构的构建。为了更好地理解它，我们通过一个场景来看一下它是如何通过单体架构传统地解决问题的。
- en: 'Let’s imagine a book publisher who wants to start an online bookstore. The
    online bookstore needs to provide the following functionalities to its readers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一家图书出版商想要开设一个在线书店。这个在线书店需要为读者提供以下功能：
- en: Readers should be able to browse all the books available for purchase.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者应该能够浏览所有可供购买的图书。
- en: Readers should be able to select the books they want to order and save them
    to a shopping cart. They should also be able to manage their shopping cart.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者应该能够选择自己想要购买的书籍，并将其保存到购物车中。他们还应该能够管理购物车。
- en: Readers should be able to then authorize payment for the book order using a
    credit card.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者应该能够使用信用卡授权支付图书订单。
- en: Readers should have the books delivered to their shipping address once payment
    is complete.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者应该能够在支付完成后，将书籍送到其配送地址。
- en: Readers should be able to sign up, store details including their shipping address,
    and bookmark favorite books.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者应该能够注册，存储包括配送地址在内的详细信息，并收藏喜欢的图书。
- en: Readers should be able to sign in, check what books they have purchased, download
    any purchased electronic copies, and update shipping details and any other account
    information.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者应该能够登录，查看自己购买的图书，下载已购买的电子版，并更新配送信息及其他账户信息。
- en: There will be many more requirements for an online bookstore, but for the purpose
    of understanding monolithic architecture, let’s try to keep it simple by limiting
    the scope to these requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在线书店会有更多的需求，但为了理解单体架构，让我们将范围限制在这些需求上，尽量保持简洁。
- en: 'It is worth mentioning Conway’s law, where he stated that, often, the design
    of monolithic systems reflects the communication structure of an organization:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是康威定律，他指出，单体系统的设计往往反映了组织的沟通结构：
- en: Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization’s communication structure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任何设计系统的组织（广义上定义）都会产生一个设计，其结构是组织沟通结构的复制。
- en: – Melvin E. Conway
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: — 梅尔文·E·康威
- en: There are various ways to design this system; we can follow traditional design
    patterns such as **model-view-controller** (**MVC**), but to do a fair comparison
    with microservices architecture, let’s make use of **hexagonal architecture**.
    We will also be using hexagonal architecture in microservices architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 设计这个系统有很多种方式；我们可以遵循传统的设计模式，比如**模型-视图-控制器**（**MVC**），但为了与微服务架构做公平的比较，我们将使用**六边形架构**。我们在微服务架构中也将使用六边形架构。
- en: With a logical view of **hexagonal architecture**, business logic sits in the
    center. Then, there are adaptors to handle requests coming from outside as well
    as to send requests outside, which are called inbound and outbound adaptors respectively.
    The business logic has one or more ports, which are basically a defined set of
    operations that define how adaptors can interact with business logic as well as
    how business logic can invoke external systems. The ports through which external
    systems interact with business logic are called inbound ports, whereas the ports
    through which business logic interacts with external systems are called outbound
    ports.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从**六边形架构**的逻辑视图来看，业务逻辑位于中心。然后，有适配器来处理来自外部的请求以及向外部发送请求，这些适配器分别被称为内向适配器和外向适配器。业务逻辑有一个或多个端口，这些端口定义了一组操作，规定了适配器如何与业务逻辑交互，以及业务逻辑如何调用外部系统。外部系统与业务逻辑交互的端口被称为内向端口，而业务逻辑与外部系统交互的端口被称为外向端口。
- en: 'We can summarize the execution flow in a hexagonal architecture in the following
    two points:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下两点来总结六边形架构中的执行流程：
- en: User interface and REST API adaptors for web and mobile invoke business logic
    via inbound adaptors
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站和移动端的用户界面与REST API适配器通过内向适配器调用业务逻辑。
- en: Business logic invokes external-facing adaptors such as databases and external
    systems via outbound adaptors
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业逻辑通过外向适配器调用面向外部的适配器，如数据库和外部系统。
- en: One last but very important point to make about hexagonal architecture is that
    business logic is made up of modules that are a collection of domain objects.
    To know more about domain-driven design definitions and patterns, you can read
    the reference guide written by Eric Evans at [https://domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf](https://domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于六边形架构的最后一个但非常重要的点是，业务逻辑由模块组成，这些模块是领域对象的集合。要了解更多关于领域驱动设计的定义和模式，可以阅读 Eric Evans
    撰写的参考指南，链接如下：[https://domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf](https://domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf)。
- en: 'Returning to our online bookstore application, the following will be the core
    modules:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的在线书店应用，以下是核心模块：
- en: '**Order management**: Managing customer orders, shopping carts, and updates
    on order progress'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单管理**：管理客户订单、购物车及订单进度更新'
- en: '**Customer management**: Managing customer accounts, including sign-up, sign-in,
    and subscriptions'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户管理**：管理客户账户，包括注册、登录和订阅'
- en: '**Payment management**: Managing payments'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付管理**：管理支付'
- en: '**Product catalog**: Managing all the products available'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品目录**：管理所有可用的产品'
- en: '**Shipping**: Managing the delivery of orders'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配送管理**：管理订单配送'
- en: '**Inventory**: Managing up-to-date information on inventory levels'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库存管理**：管理最新的库存信息'
- en: With these in mind, let’s draw the hexagonal architecture for this system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些，让我们绘制这个系统的六边形架构。
- en: '![Figure 1.2 – The online book store application monolith](img/B17989_01_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 在线书店应用单体架构](img/B17989_01_02.jpg)'
- en: Figure 1.2 – The online book store application monolith
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 在线书店应用单体架构
- en: Though the architecture follows hexagonal architecture and some principles of
    domain-driven design, it is still packaged as one deployable or executable unit,
    depending on the underlying programming language you are using to write it. For
    example, if you are using Java, the deployable artifact will be a WAR file, which
    will then be deployed on an application server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管架构遵循六边形架构和领域驱动设计的某些原则，但它仍然被打包成一个可部署或可执行单元，这取决于你所使用的底层编程语言。例如，如果你使用的是 Java，部署的制品将是一个
    WAR 文件，然后部署到应用服务器上。
- en: The monolithic application looks awesome when it’s greenfield but nightmarish
    when it becomes brownfield, in which case it would need to be updated or extended
    to incorporate new features and changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用在绿地项目中看起来很棒，但当变成“棕地”项目时就变得非常糟糕，这时候需要更新或扩展，以融入新功能和变化。
- en: Monolithic architectures are difficult to understand, evolve, and enhance because
    the code base is big and, with time, gets humongous in size and complexity. This
    means it takes a long time to make code changes and to ship the code to production.
    Code changes are expensive and require thorough regression testing. The application
    is difficult and expensive to scale, and there is no option to allocate dedicated
    computing resources to individual components of the application. All resources
    are allocated holistically to the application and are consumed by all parts of
    it, irrespective of their importance in its execution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构难以理解、演化和增强，因为代码库庞大，随着时间推移，代码量和复杂度会变得非常巨大。这意味着代码更改需要很长时间，并且要将代码推送到生产环境也需要较长时间。代码更改成本高，并且需要彻底的回归测试。应用程序的扩展困难且成本高，而且没有办法为应用程序的各个组件分配专门的计算资源。所有资源都整体分配给整个应用程序，并被所有部分使用，而不管它们在执行中的重要性。
- en: The other issue is lock-in to one technology for the whole code base. What this
    basically means is that you need to constrain yourself to one or a few technologies
    to support the whole code base. Code lock-in is detrimental to efficient outcomes,
    including performance, reliability, as well as the amount of effort required to
    achieve an outcome. You should be using technologies that are the best fit to
    solve a problem. For example, you can use TypeScript for the UI, Node.js for the
    API, Golang for modules needing concurrency or maybe for writing the core modules,
    and so on. Using a monolithic architecture, you are stuck with technologies you
    used in the past, which might not be the right fit to solve the current problem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是代码库对某一技术的锁定。基本上，这意味着你需要将自己限制在一种或少数几种技术上，以支持整个代码库。代码锁定对高效结果是不利的，包括性能、可靠性以及实现结果所需的努力。你应该使用最适合解决问题的技术。例如，你可以使用
    TypeScript 来开发 UI，使用 Node.js 开发 API，使用 Golang 开发需要并发的模块，或者用它来编写核心模块，等等。使用单体架构时，你会被过去使用的技术所束缚，这些技术可能不适合当前的问题。
- en: 'So, how does *microservices architecture* solve this problem? *Microservices*
    is an overloaded term, and there are many definitions of it; in other words, there
    is no single definition of microservices. A few well-known personalities have
    contributed their own definitions of microservices architecture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*微服务架构*是如何解决这个问题的呢？*微服务* 是一个过载的术语，关于它有许多不同的定义；换句话说，微服务没有单一的定义。一些知名人物提出了他们自己对微服务架构的定义：
- en: The term Microservices architecture has sprung up over the last few years to
    describe a particular way of designing software applications as suites of independently
    deployable services. While there is no precise definition of this architectural
    style, there are certain common characteristics around organization around business
    capability, automated deployment, intelligence in the endpoints, and decentralized
    control of languages and data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构这个术语在过去几年间出现，用来描述一种将软件应用程序设计为一组可以独立部署的服务的方式。虽然这种架构风格没有精确定义，但有一些共同的特点，比如围绕业务能力进行组织、自动化部署、端点智能化、语言和数据的去中心化控制等。
- en: – Martin Fowler and James Lewis
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: – 马丁·福勒（Martin Fowler）和詹姆斯·刘易斯（James Lewis）
- en: The definition was published on [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)
    and is dated March 25, 2014, so you can ignore “sprung up over the last few years”
    in the description, as microservices architecture has becoming mainstream and
    pervasive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义已发布在 [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)
    上，发布时间是2014年3月25日，因此你可以忽略描述中的“在过去几年间出现”，因为微服务架构已经成为主流并广泛应用。
- en: 'Another definition of microservices is from Adam Cockcroft: “*Loosely coupled
    service-oriented architecture with* *bounded contexts.*”'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对微服务的定义来自亚当·科克罗夫特（Adam Cockcroft）：“*松耦合的面向服务架构，带有* *界限上下文*。”
- en: In microservices architecture, the term *micro* is a topic of intense debate,
    and often the question asked is, “*How micro should microservices be?*” or “*How
    should I decompose my application?*”. There is no easy answer to this; you can
    follow various decomposing strategies by following domain-driven design and decomposing
    applications into services based on business capability, functionality, the responsibility
    or concern of each service or module, scalability, bounded context, and blast
    radius. There are numerous articles and books written on the topic of microservices
    and decomposition strategies, so I am sure you can find enough to read about strategies
    for sizing your application in microservices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，*micro* 这个词是一个激烈讨论的话题，通常被问到的问题是：“*微服务应该有多小？*”或“*我该如何分解我的应用程序？*”。这个问题没有简单的答案；你可以通过遵循领域驱动设计，基于业务能力、功能、每个服务或模块的责任或关注点、可扩展性、界限上下文以及影响范围等多个维度来分解应用程序。有大量的文章和书籍讨论微服务及其分解策略，因此我相信你可以找到足够的资料来阅读，了解如何在微服务中确定应用程序的大小策略。
- en: Let’s get back to the online bookstore application and redesign it using a microservices
    architecture. The following diagram represents the online bookstore applications
    built using microservices architecture principles. The individual services are
    still following hexagonal architecture, and for brevity, we have not represented
    the inbound and outbound ports and adaptors. You can assume that ports, adaptors,
    and containers are within the hexagon itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到在线书店应用程序，并使用微服务架构重新设计它。下图展示了使用微服务架构原则构建的在线书店应用程序。各个服务仍然遵循六边形架构，为了简洁起见，我们没有展示入站和出站端口及适配器。你可以假设端口、适配器和容器都在六边形内部。
- en: '![Figure 1.3 – The online bookstore microservices architecture](img/B17989_01_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 在线书店微服务架构](img/B17989_01_03.jpg)'
- en: Figure 1.3 – The online bookstore microservices architecture
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 在线书店微服务架构
- en: Microservices architecture provides several benefits over monolithic architecture.
    Having independent modules segregated based on functionality and decoupled from
    each other unlocks the monolithic shackles that drag the software development
    process. Microservices can be built faster at a comparatively lower cost than
    a monolith and are well adept for continuous deployment processes and, thus, have
    faster time to production. With microservices architecture, developers can release
    code to production as frequently as they want. The smaller code base of microservices
    is easy to understand, and developers only need to understand microservices and
    not the whole application. Also, multiple developers can work on microservices
    within the application without any risk of code being overwritten or impacting
    each other’s work. Your application, now made up of microservices, can leverage
    polyglot programming techniques to deliver performance efficiency, with less effort
    for more outcomes, and best-of-breed technologies to solve a problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构相比单体架构提供了几个好处。将基于功能独立划分并解耦的模块，可以解锁单体架构所带来的束缚，推动软件开发过程的进步。与单体架构相比，微服务可以更快地构建，成本也较低，并且非常适合于持续部署流程，因此具有更快的生产上线时间。采用微服务架构后，开发人员可以根据需要频繁地将代码发布到生产环境中。微服务的小型代码库容易理解，开发人员只需理解微服务本身，而不需要理解整个应用程序。此外，多个开发人员可以在应用程序中的微服务上协作工作，而不必担心代码被覆盖或互相影响。你的应用程序现在由微服务构成，可以利用多语言编程技术提高性能效率，减少付出而获得更多成果，并使用最优技术来解决问题。
- en: Microservices as self-contained independent deployable units provide you with
    fault isolation and a reduced blast radius – for example, assume that one of the
    microservices starts experiencing exceptions, performance degradation, memory
    leakage, and so on. In this case, because the service is deployed as a self-contained
    unit with its own resource allocation, this problem will not affect other microservices.
    Other microservices will not get impacted by overconsumption of memory, CPU, storage,
    network, and I/O.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为自包含的独立可部署单元，微服务提供了故障隔离和较小的爆炸半径——例如，假设某个微服务开始出现异常、性能下降、内存泄漏等问题。在这种情况下，由于该服务作为一个自包含的单元并具有自己的资源分配，这个问题不会影响其他微服务。其他微服务不会受到内存、CPU、存储、网络和I/O过度消耗的影响。
- en: Microservices are also easier to deploy because you can use varying deployment
    options, depending on microservices requirements and what is available to you
    – for example, you can have a set of microservices deployed on a serverless platform
    and, at the same time, another set on a container platform along with another
    set on virtual machines. Unlike monolithic applications, you are not bounded by
    one deployment option.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的部署也更为简单，因为你可以根据微服务的需求以及可用的资源使用不同的部署选项——例如，你可以将一组微服务部署在无服务器平台上，同时将另一组部署在容器平台上，再将另一组部署在虚拟机上。与单体应用不同，你不受限于一种部署选项。
- en: While microservices provide numerous benefits, they also come with added complexity.
    This added complexity is because now you have too much to deploy and manage. Not
    following correct decomposition strategies can also create micro-monoliths that
    are nightmarish to manage and operate. Another important aspect is communication
    between microservices. As there will be lots of microservices that need to talk
    to each other, it is very important that communication between microservices is
    swift, performant, reliable, resilient, and secure. In the *Getting to know Service
    Mesh* section, we will dig deeper into what we mean by these terms.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务提供了许多好处，但它们也带来了额外的复杂性。这种复杂性是因为现在你需要部署和管理的东西太多了。不遵循正确的分解策略也可能导致微型单体架构的产生，这将使管理和操作变得极其困难。另一个重要的方面是微服务之间的通信。由于需要大量微服务相互交流，因此微服务之间的通信必须快速、高效、可靠、具备弹性且安全。在*了解服务网格*部分中，我们将深入探讨这些术语的具体含义。
- en: For now, with a good understanding of microservices architecture, it’s time
    to look at Kubernetes, which is also the de facto platform for deploying microservices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，掌握了微服务架构的基本概念后，是时候了解 Kubernetes 了，Kubernetes 也是部署微服务的事实标准平台。
- en: Understanding Kubernetes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes
- en: 'When designing and deploying microservices, it is easy to manage a small number
    of microservices. As the number of microservices grows, so does the complexity
    of managing them. The following list showcases some of the complexities caused
    by the adoption of microservices architecture:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和部署微服务时，管理少量微服务相对简单。但随着微服务数量的增加，管理的复杂性也会增加。以下列表展示了采用微服务架构可能带来的一些复杂性：
- en: Microservices will have specific deployment requirements in terms of the kind
    of base operating systems, middleware, database, and compute/memory/storage. Also,
    the number of microservices will be large, which, in turn, means that you will
    need to provide resources to every microservice. Moreover, to keep the cost down,
    you will need to be efficient with the allocation of resources and their utilization.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务在部署时会有特定的要求，包括基础操作系统、中间件、数据库以及计算/内存/存储资源的选择。此外，微服务的数量会非常庞大，这意味着你需要为每个微服务提供资源。而且，为了降低成本，你需要在资源分配和利用方面保持高效。
- en: Every microservice will have a different deployment frequency. For example,
    any updates to payment microservices might be on a monthly basis, whereas updates
    to frontend UI microservices might be on a weekly or daily basis.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务的部署频率都会不同。例如，支付微服务的更新可能是每月一次，而前端 UI 微服务的更新则可能是每周或每天一次。
- en: Microservices need to communicate with each other, for which they need to know
    about each other’s existence, and they should have application networking in place
    to communicate efficiently.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务需要相互通信，因此它们需要了解彼此的存在，并且应该具备应用程序网络功能以高效地进行通信。
- en: Developers who are building microservices need to have consistent environments
    for all stages of the development life cycle so that there are no unknowns, or
    near-unknowns, about the behavior of microservices when deployed in a production
    environment.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建微服务的开发人员需要为开发生命周期的各个阶段提供一致的环境，这样在生产环境中部署微服务时，就不会出现未知或接近未知的行为。
- en: There should be a continuous deployment process in place to build and deploy
    microservices. If you don’t have an automated continuous deployment process, then
    you will need an army of people to support microservices deployments.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该建立一个持续部署流程来构建和部署微服务。如果没有自动化的持续部署流程，那么你将需要一支庞大的团队来支持微服务的部署。
- en: With so many microservices deployed, it is inevitable that there will be failures,
    but you cannot burden the microservices developer to solve those problems. Cross-cutting
    concerns such as resiliency, deployment orchestration, and application networking
    should be easy to implement and should not distract the focus of microservice
    developers. These cross-cutting concerns should be facilitated by the underlying
    platform and should not be incorporated into the microservices code.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着部署的微服务数量增多，故障是不可避免的，但你不能把这些问题的解决责任都压在微服务开发人员身上。跨领域问题，如弹性、部署协调和应用程序网络功能，应该易于实现，并且不应分散微服务开发人员的注意力。这些跨领域问题应该由底层平台来处理，而不是嵌入到微服务代码中。
- en: '**Kubernetes**, also abbreviated as **K8S**, is an open source system that
    originated from Google. Kubernetes provides automated deployment, scaling, and
    management of containerized applications. It provides scalability without you
    needing to hire an army of DevOps engineers. It fits and suits all kinds of complexities
    – that is, it works on a small scale as well as an enterprise scale. Google, as
    well as many other organizations, runs a huge number of containers on the Kubernetes
    platform.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes**，也简称为 **K8S**，是一个源自 Google 的开源系统。Kubernetes 提供了自动化的部署、扩展和容器化应用的管理。它在不需要雇佣大量
    DevOps 工程师的情况下，提供了可扩展性。它适应各种复杂情况——也就是说，无论是小规模还是企业级规模都能运行。Google 以及许多其他组织都在 Kubernetes
    平台上运行着大量容器。'
- en: Important note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A **container** is a self-contained deployment unit that contains all code and
    associated dependencies, including operating system, system, and application libraries
    packaged together. Containers are instantiated from images, which are lightweight
    executable packages. A **Pod** is a deployable unit in Kubernetes and is comprised
    of one or more containers, with each one in the Pod sharing the resources, such
    as storage and network. A Pod’s contents are always co-located and co-scheduled
    and run in a shared context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器** 是一个自包含的部署单元，包含所有代码和相关的依赖项，包括操作系统、系统和应用程序库，打包在一起。容器是从镜像实例化出来的，镜像是轻量级的可执行包。**Pod**
    是 Kubernetes 中的可部署单元，由一个或多个容器组成，每个容器共享资源，如存储和网络。Pod 的内容总是共同定位和共同调度，并在共享的上下文中运行。'
- en: 'The following are some of the benefits of the Kubernetes platform:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Kubernetes 平台的一些优点：
- en: Kubernetes provides automated and reliable deployments by taking care of rollouts
    and rollbacks. During deployments, Kubernetes progressively rolls out changes
    while monitoring microservices’ health to ensure that there is no disruption to
    the processing of a request. If there is a risk to the overall health of microservices,
    then Kubernetes will roll back the changes to bring the microservices back to
    a healthy state.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 通过处理发布和回滚，实现自动化和可靠的部署。在部署过程中，Kubernetes 会逐步推出变更，并监控微服务的健康状况，以确保请求的处理不会中断。如果微服务的整体健康状况存在风险，Kubernetes
    会回滚变更，恢复微服务的健康状态。
- en: If you are using the cloud, then different cloud providers have different storage
    types. When running in data centers, you will be using various network storage
    types. When using Kubernetes, you don’t need to worry about underlying storage,
    as it takes care of it. It abstracts the complexity of underlying storage types
    and provides an API-driven mechanism for developers to allocate storage to the
    containers.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用云服务，那么不同的云服务提供商有不同的存储类型。在数据中心运行时，你将使用各种网络存储类型。使用 Kubernetes 时，你无需担心底层存储，因为它会处理这些问题。Kubernetes
    抽象了底层存储类型的复杂性，并为开发人员提供了一个基于 API 的机制，用于将存储分配给容器。
- en: Kubernetes takes care of DNS and IP allocation for the Pods; it also provides
    a mechanism for microservices to discover each other using simple DNS conventions.
    When more than one copy of services is running, then Kubernetes also takes care
    of load balancing between them.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 负责 Pod 的 DNS 和 IP 分配；它还为微服务提供了一种机制，使其能够通过简单的 DNS 约定相互发现。当多个服务副本运行时，Kubernetes
    还会负责它们之间的负载均衡。
- en: Kubernetes automatically takes care of the scalability requirements of Pods.
    Depending on resource utilization, Pods are automatically scaled up, which means
    that the number of running Pods is increased, or scaled down, which means that
    the number of running Pods is reduced. Developers don’t have to worry about how
    to implement scalability. Instead, they just need average utilization of CPU,
    memory, and various other custom metrics along with scalability limits.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 自动处理 Pod 的扩展需求。根据资源利用情况，Pod 会自动扩展，这意味着运行的 Pod 数量会增加，或者会缩减，这意味着运行的
    Pod 数量会减少。开发人员无需担心如何实现扩展。他们只需要关注 CPU、内存和其他各种自定义指标的平均利用率以及扩展限制。
- en: In a distributed system, failures are bound to happen. Similarly, in microservices
    deployments, Pods and containers will become unhealthy and unresponsive. Such
    scenarios are handled by Kubernetes by restarting the failed containers, rescheduling
    containers to other worker nodes if underlying nodes are having issues, and replacing
    containers that have become unhealthy.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式系统中，故障是不可避免的。同样，在微服务部署中，Pods 和容器会变得不健康或无响应。Kubernetes 通过重启失败的容器、将容器重新调度到其他工作节点（如果底层节点出现问题），以及替换变得不健康的容器来处理这些情况。
- en: As discussed earlier, microservices architecture being resource-hungry is one
    of its challenges, and a resource should be allocated efficiently and effectively.
    Kubernetes takes care of that responsibility by maximizing the allocation of resources
    without impairing availability or sacrificing the performance of containers.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，微服务架构的资源消耗是其挑战之一，资源应该高效且有效地分配。Kubernetes 通过最大化资源分配，确保不影响可用性或牺牲容器的性能，承担了这一责任。
- en: '![Figure 1.4 – The online bookstore microservice deployed on Kubernetes](img/B17989_01_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 部署在 Kubernetes 上的在线书店微服务](img/B17989_01_04.jpg)'
- en: Figure 1.4 – The online bookstore microservice deployed on Kubernetes
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 部署在 Kubernetes 上的在线书店微服务
- en: The preceding diagram is a visualization of the online bookstore application
    built using microservices architecture and deployed on Kubernetes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是通过微服务架构构建并部署在 Kubernetes 上的在线书店应用程序的可视化图示。
- en: Getting to know Service Mesh
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解服务网格
- en: In the previous section, we read about monolithic architecture, its advantages,
    and disadvantages. We also read about how microservices solve the problem of scalability
    and provide flexibility to rapidly deploy and push software changes to production.
    The cloud makes it easier for an organization to focus on innovation without worrying
    about expensive and lengthy hardware procurement and expensive CapEx cost. The
    cloud also facilitates microservices architecture not only by facilitating on-demand
    infrastructure but also by providing various ready-to-use platforms and building
    blocks, such as PaaS and SaaS. When organizations are building applications, they
    don’t need to reinvent the wheel every time; instead, they can leverage ready-to-use
    databases, various platforms including Kubernetes, and **Middleware as a** **Service**
    (**MWaaS**).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们阅读了关于单体架构的优缺点。我们还了解了微服务如何解决可扩展性问题，并提供灵活性，使软件更改能够快速部署到生产环境中。云平台使组织能够专注于创新，而无需担心昂贵且漫长的硬件采购过程和高昂的资本支出（CapEx）成本。云平台不仅通过提供按需基础设施促进微服务架构的实施，还通过提供各种现成可用的平台和构建模块（如
    PaaS 和 SaaS）来加速这一过程。在组织构建应用程序时，他们不需要每次都从头开始，而是可以利用现成的数据库、各种平台（包括 Kubernetes）以及**中间件即服务**（**MWaaS**）。
- en: In addition to the cloud, microservice developers also leverage containers,
    which makes microservices development much easier by providing a consistent environment
    and compartmentalization to help achieve modular and self-contained architecture
    of microservices. On top of containers, the developer should also use a container
    orchestration platform such as Kubernetes, which simplifies the management of
    containers and takes care of concerns such as networking, resource allocation,
    scalability, reliability, and resilience. Kubernetes also helps to optimize the
    infrastructure cost by providing better utilization of underlying hardware. When
    you combine the cloud, Kubernetes, and microservices architecture, you have all
    the ingredients you need to deliver potent software applications that not only
    do the job you want them to do but also do it cost-effectively.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了云平台，微服务开发者还利用容器，这使得微服务开发变得更加容易，因为容器提供了统一的环境和隔离机制，有助于实现微服务的模块化和自包含架构。在容器之上，开发者还应使用容器编排平台，如
    Kubernetes，它简化了容器的管理，并处理网络、资源分配、可扩展性、可靠性和弹性等问题。Kubernetes 还通过提供更好的底层硬件利用率来帮助优化基础设施成本。当你将云、Kubernetes
    和微服务架构结合在一起时，你就拥有了交付强大软件应用所需的所有要素，这些应用不仅能完成你希望它们完成的任务，还能以更具成本效益的方式做到这一点。
- en: So, the question on your mind must be, “*Why do I need a Service Mesh?*” or
    “*Why do I need Service Mesh if I am using the cloud, Kubernetes, and microservices?*”
    It is a great question to ask and think about, and the answer becomes evident
    once you have reached a stage where you are confidently deploying microservices
    on Kubernetes, and then you reach a certain tipping point where networking between
    microservices just becomes too complex to address by using Kubernetes’ native
    features.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你心里一定有个问题：“*我为什么需要Service Mesh？*”或者“*如果我使用云、Kubernetes和微服务，为什么还需要Service
    Mesh？*”这是一个很好的问题，值得思考，一旦你到了一个阶段，能够自信地在Kubernetes上部署微服务，你会遇到一个拐点，那时微服务之间的网络复杂度已经超出了Kubernetes原生特性所能解决的范围。
- en: Fallacies of distributed computing
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算的谬误
- en: Fallacies of a distributed system are a set of eight assertions made by L Peter
    Deutsch and others at Sun Microsystems. These assertions are false assumptions
    often made by software developers when designing distributed applications. The
    assumptions are that a network is reliable, latency is zero, bandwidth is infinite,
    the network is secure, the topology doesn’t change, there is one administrator,
    the transport cost is zero, and the network is homogenous.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的谬误是由L Peter Deutsch及其他人于Sun Microsystems提出的八个假设。这些假设是软件开发者在设计分布式应用时常犯的错误。假设包括：网络是可靠的、延迟为零、带宽是无限的、网络是安全的、拓扑结构不变、只有一个管理员、传输成本为零、网络是同质的。
- en: At the beginning of the *Understanding Kubernetes* section, we looked at the
    challenges developers face when implementing microservices architecture. Kubernetes
    provides various features for the deployment of containerized microservices as
    well as container/Pod life cycle management through declarative configuration,
    but it falls short of solving communication challenges between microservices.
    When talking about the challenges of microservices, we used terms such as *application
    networking* to describe communication challenges. So, let’s try to first understand
    what application networking is and why it is so important for the successful operations
    of microservices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*理解Kubernetes*部分的开始，我们探讨了开发者在实施微服务架构时面临的挑战。Kubernetes提供了各种功能，用于部署容器化微服务以及通过声明式配置进行容器/Pod生命周期管理，但它在解决微服务之间的通信挑战方面存在不足。当我们谈到微服务的挑战时，使用了诸如*应用网络*等术语来描述通信挑战。那么，首先让我们理解一下什么是应用网络，以及它为什么对微服务的成功运作如此重要。
- en: '*Application networking* is also a loosely used term; there are various interpretations
    of it depending on the context it is being used in. In the context of microservices,
    we refer to application networking as the enabler of distributed communication
    between microservices. The microservice can be deployed in one Kubernetes cluster
    or multiple clusters over any kind of underlying infrastructure. A microservice
    can also be deployed in a non-Kubernetes environment in the cloud, on-premises,
    or both. For now, let’s keep our focus on Kubernetes and application networking
    within Kubernetes.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用网络*也是一个宽泛的术语，具体的解释会根据上下文的不同而有所不同。在微服务的背景下，我们将应用网络定义为支持微服务之间分布式通信的工具。微服务可以部署在一个Kubernetes集群中，也可以跨多个集群，在任何类型的底层基础设施上运行。微服务还可以部署在云端、本地或两者兼备的非Kubernetes环境中。目前，我们将重点放在Kubernetes及其内部的应用网络上。'
- en: Irrespective of where microservices are deployed, you need a robust application
    network in place for microservices to talk to each other. The underlying platform
    should not just facilitate communication but also resilient communication. By
    resilient communication, we mean the kind of communication where it has a large
    probability of being successful even when the ecosystem around it is in adverse
    conditions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 无论微服务部署在哪里，都需要一个强大的应用网络来让微服务之间进行通信。底层平台不仅要促进通信，还要确保通信的韧性。所谓的韧性通信，指的是在其周围生态系统处于不利条件下，依然能成功通信的高概率。
- en: Apart from the application network, you also need visibility of the communication
    happening between microservices; this is also called observability. Observability
    is important in microservices communication in knowing how the microservices are
    interacting with each other. It is also important that microservices communicate
    securely with each other. The communication should be encrypted and defended against
    man-in-the-middle attacks. Every microservice should have an identity and be able
    to prove that they are authorized to communicate with other microservices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用程序网络，你还需要了解微服务之间通信的可见性；这也叫做可观察性。可观察性在微服务通信中非常重要，因为它可以帮助我们了解微服务如何互相交互。微服务之间的通信还需要安全保障。通信应该是加密的，并且防止中间人攻击。每个微服务应该有自己的身份，并且能够证明它有权与其他微服务进行通信。
- en: So, why Service Meshes? Why can’t these requirements be addressed in Kubernetes?
    The answer lies in Kubernetes architecture and what it was designed to do. As
    mentioned before, Kubernetes is application life cycle management software. It
    provides application networking, observability, and security, but at a very basic
    level that is not sufficient to meet the requirements of modern and dynamic microservices
    architecture. This doesn’t mean that Kubernetes is not modern software. Indeed,
    it is a very sophisticated and cutting-edge technology, but only for serving container
    orchestration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要使用服务网格？为什么这些需求不能在Kubernetes中解决？答案在于Kubernetes的架构以及它被设计的目的。正如前面提到的，Kubernetes是应用程序生命周期管理软件。它提供应用程序网络、可观察性和安全性，但这些功能仅仅处于一个非常基础的层面，不足以满足现代动态微服务架构的要求。这并不意味着Kubernetes不是现代化的软件。事实上，它是一项非常复杂且前沿的技术，但仅限于容器编排的服务。
- en: Traffic management in Kubernetes is handled by the Kubernetes network proxy,
    also called kube-proxy. kube-proxy runs on each node in the Kubernetes cluster.
    kube-proxy communicates with the Kubernetes API server and gets information about
    Kubernetes services. Kubernetes services are another level of abstraction to expose
    a set of Pods as a network service. kube-proxy implements a form of virtual IP
    for services that sets iptables rules, defining how any traffic for that service
    will be routed to the endpoints, which are essentially the underlying Pods hosting
    the application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的流量管理由Kubernetes网络代理处理，也叫kube-proxy。kube-proxy在Kubernetes集群的每个节点上运行。kube-proxy与Kubernetes
    API服务器进行通信，并获取关于Kubernetes服务的信息。Kubernetes服务是另一层抽象，用于将一组Pod暴露为网络服务。kube-proxy为服务实现了一种虚拟IP形式，并设置iptables规则，定义了该服务的所有流量如何路由到端点，这些端点本质上是托管应用程序的底层Pods。
- en: To understand it better, let’s look at the following example. To run this example,
    you will need **minikube** and **kubectl** on your computing device. If you don’t
    have this software installed, then I suggest you hold off from installing it,
    as we will be going through the installation steps in *Chapter 2*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们来看一下下面的例子。要运行这个例子，你需要在计算设备上安装**minikube**和**kubectl**。如果你还没有安装这些软件，建议先不要安装，因为我们将在*第二章*中详细介绍安装步骤。
- en: 'We will create a Kubernetes deployment and service by following the example
    in [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)上的示例创建一个Kubernetes部署和服务：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We just created a deployment object named `hello-minikube`. Let’s execute the
    `kubectl` `describe` command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个名为`hello-minikube`的部署对象。让我们执行`kubectl`的`describe`命令：
- en: '[PRE1]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From the preceding code block, you can see that a Pod has been created, containing
    a container instantiated from the `k8s.gcr.io/echoserver:1.4` image. Let’s now
    check the Pods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码块中，你可以看到一个Pod已经创建，包含了一个从`k8s.gcr.io/echoserver:1.4`镜像实例化的容器。现在让我们检查一下Pods：
- en: '[PRE2]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding output confirms that a Pod has been created. Now, let’s create
    a service and expose it so that it is accessible on a cluster-internal IP on a
    static port, also called `NodePort`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出确认了Pod已经创建。现在，让我们创建一个服务并暴露它，使其可以通过静态端口上的集群内部IP访问，也叫`NodePort`：
- en: '[PRE3]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s describe the service:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下这个服务：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the preceding output, you can see that a Kubernetes service named `hello-minikube`
    has been created and is accessible on port `31286`, also called `NodePort`. We
    also see that there is an `Endpoints` object with the `172.17.0.5:8080` value.
    Soon, we will see the connection between `NodePort` and `Endpoints`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的输出中，你可以看到一个名为`hello-minikube`的Kubernetes服务已创建，并且可以通过端口`31286`访问，也称为`NodePort`。我们还看到有一个`Endpoints`对象，值为`172.17.0.5:8080`。接下来，我们将看到`NodePort`和`Endpoints`之间的连接。
- en: 'Let’s dig deeper and look at what is happening to iptables. If you would like
    to see what the preceding service returns, then you can simply type `minikube
    service`. We are using macOS, where minikube is running itself as a VM. We will
    need to use `ssh` on minikube to see what’s happening with iptables. On Unix host
    machines, the following steps are not required:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下iptables发生了什么。如果你想查看前面的服务返回了什么，你可以直接输入`minikube service`。我们正在使用macOS，minikube本身作为虚拟机运行。我们需要通过`ssh`连接到minikube，查看iptables的情况。在Unix主机上，这些步骤是不需要的：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s check the iptables:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下iptables：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that there are two iptables rules associated with the `hello-minikube`
    service. Let’s look further into these iptables rules:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到与`hello-minikube`服务关联的两个iptables规则。让我们进一步查看这些iptables规则：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first rule, `KUBE-MARK-MASQ`, is simply adding an attribute called `packet
    mark`, with a `0x400` value for all traffic destined for port `31286`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则`KUBE-MARK-MASQ`只是为所有目标端口`31286`的流量添加了一个名为`packet mark`的属性，值为`0x400`。
- en: 'The second rule, `KUBE-SVC-MFJHED5Y2WHWJ6HX`, is routing the traffic to another
    rule, `KUBE-SEP-EVPNTXRIBDBX2HJK`. Let’s look further into it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则`KUBE-SVC-MFJHED5Y2WHWJ6HX`正在将流量路由到另一个规则`KUBE-SEP-EVPNTXRIBDBX2HJK`。让我们进一步了解它：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that this rule has a `172.17.0.5:8080`, which is the address of the endpoints
    when we created the service.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这条规则有一个`172.17.0.5:8080`，这是我们创建服务时端点的地址。
- en: 'Let’s scale the number of Pod replicas:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展Pod副本的数量：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Describe the service to find any changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 描述服务以查找任何变化：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the value of the endpoint has changed; let’s also describe the `hello-minikube`
    endpoint:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，端点的值已发生变化；让我们也描述一下`hello-minikube`端点：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the endpoint is now also targeting `172.17.0.7` along with `172.17.0.5\.
    172.17.0.7`, the new Pod that has been created as a result of increasing the number
    of replicas to `2`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，端点现在也同时指向`172.17.0.7`和`172.17.0.5`。`172.17.0.7`是通过将副本数量增加到`2`后创建的新Pod。
- en: '![Figure 1.5 – Service, endpoints, and Pods](img/B17989_01_05.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 服务、端点和Pods](img/B17989_01_05.jpg)'
- en: Figure 1.5 – Service, endpoints, and Pods
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 服务、端点和Pods
- en: 'Let’s check the iptables rules now:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下iptables规则：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will find that an additional rule, `KUBE-SEP-NXPGMUBGGTRFLABG`, has been
    added, and because of the statistic mode random probability, `0.5`, each packet
    handled by `KUBE-SVC-MFJHED5Y2WHWJ6HX` is then distributed 50–50 between `KUBE-SEP-EVPNTXRIBDBX2HJK`
    and `KUBE-SEP-NXPGMUBGGTRFLABG`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现一个额外的规则`KUBE-SEP-NXPGMUBGGTRFLABG`已被添加，并且由于统计模式的随机概率`0.5`，每个由`KUBE-SVC-MFJHED5Y2WHWJ6HX`处理的数据包在`KUBE-SEP-EVPNTXRIBDBX2HJK`和`KUBE-SEP-NXPGMUBGGTRFLABG`之间进行50/50的分配。
- en: 'Let’s also quickly examine the new chain added after we changed the number
    of replicas to `2`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查一下在将副本数量更改为`2`后添加的新链：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that another `DNAT` entry has been added for `172.17.0.7`. So, essentially,
    the new chain and the previous one are now routing traffic to corresponding Pods.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为`172.17.0.7`添加了另一个`DNAT`条目。所以，本质上，新的链和之前的链现在都在将流量路由到相应的Pods。
- en: So, if we summarize everything, kube-proxy runs on every Kubernetes node and
    keeps a watch on service and endpoint resources. Based on service and endpoint
    configurations, kube-proxy then creates iptables rules to take care of routing
    data packets between the consumer/client and the Pod.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们总结一下，kube-proxy在每个Kubernetes节点上运行，并监视服务和端点资源。根据服务和端点的配置，kube-proxy会创建iptables规则，负责在消费者/客户端和Pod之间路由数据包。
- en: The following diagram depicts the creation of iptables rules via kube-proxy
    and how consumers connect with Pods.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了通过kube-proxy创建iptables规则以及消费者如何连接到Pods。
- en: '![Figure 1.6 – The client connecting to a Pod based on the iptables rule chain](img/B17989_01_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 客户端基于iptables规则链连接到Pod](img/B17989_01_06.jpg)'
- en: Figure 1.6 – The client connecting to a Pod based on the iptables rule chain
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 客户端基于iptables规则链连接到Pod
- en: 'kube-proxy can also run in another mode called **IP Virtual Server** (**IPVS**).
    For ease of reference, here’s how this term is defined on the official Kubernetes
    website:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy 还可以运行在另一种模式下，称为 **IP 虚拟服务器**（**IPVS**）。为了方便参考，以下是官方 Kubernetes 网站上对此术语的定义：
- en: In IPVS mode, kube-proxy watches Kubernetes Services and Endpoints calls net
    link interface to create IPVS rules accordingly and synchronizes IPVS rules with
    Kubernetes Services and Endpoints periodically. This control loop ensures that
    IPVS status matches the desired state. When accessing a service, IPVS directs
    traffic to one of the backend Pods.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPVS 模式下，kube-proxy 监视 Kubernetes 服务和端点调用网络接口，按需创建 IPVS 规则，并定期与 Kubernetes
    服务和端点同步 IPVS 规则。这个控制循环确保 IPVS 状态与期望状态匹配。当访问某个服务时，IPVS 会将流量引导到某个后端 Pod。
- en: Tip
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To find out the mode in which kube-proxy is running, you can use `$ curl localhost:10249/proxyMode`.
    On Linux, you can curl directly, but, on macOS, you need to curl from the minikube
    VM itself.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找 kube-proxy 正在运行的模式，您可以使用 `$ curl localhost:10249/proxyMode`。在 Linux 上，您可以直接使用
    curl，但在 macOS 上，您需要从 minikube 虚拟机本身进行 curl 操作。
- en: So, what is wrong with kube-proxy using iptables or IPVS?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，kube-proxy 使用 iptables 或 IPVS 有什么问题呢？
- en: kube-proxy doesn’t provide any fine-grained configuration; all settings are
    applied to all traffic on that node. kube-proxy can only do simple TCP, UDP, and
    SCTP stream forwarding or round-robin TCP, UDP, and SCTP forwarding across a set
    of backends. As the number of Kubernetes services grows, so does the number of
    rulesets in iptables. As the iptables rules are processed sequentially, it causes
    performance degradation with growth in microservice numbers. Also, iptables only
    supports the use of simple probability to support traffic distribution, which
    is very rudimentary. Kubernetes delivers a few other tricks but not enough to
    cater to resilient communication between microservices. For microservice communication
    to be resilient, you need more than iptables-based traffic management.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy 不提供任何精细化配置；所有设置都应用于该节点上的所有流量。kube-proxy 只能进行简单的 TCP、UDP 和 SCTP 流转发，或在一组后端之间进行轮询
    TCP、UDP 和 SCTP 转发。随着 Kubernetes 服务数量的增加，iptables 中的规则集数量也会增加。由于 iptables 规则是顺序处理的，因此随着微服务数量的增长，会导致性能下降。此外，iptables
    只支持使用简单的概率来支持流量分配，这非常基础。Kubernetes 提供了一些其他技巧，但不足以支持微服务之间的弹性通信。为了实现微服务通信的弹性，您需要比基于
    iptables 的流量管理更多的东西。
- en: Let’s now talk about a couple of capabilities required to have resilient, fault-tolerant
    communication.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下实现弹性、容错通信所需的一些能力。
- en: Retry mechanism, circuit breaking, timeouts, and deadlines
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试机制、断路器、超时和截止时间
- en: If one Pod is not functioning, then the traffic should automatically be sent
    to another Pod. Also, a retry needs to be done under constraints so as to not
    make the communication worse. For example, if a call fails, then maybe the system
    needs to wait before retrying. If a retry is not successful, then maybe it’s better
    to increase the wait time. Even then. If it is not successful, maybe it’s worth
    abandoning retry attempts and breaking the circuit for subsequent connection.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 Pod 无法正常工作，则流量应自动发送到另一个 Pod。此外，重试需要在约束条件下进行，以避免使通信变得更糟。例如，如果调用失败，则系统可能需要等待一段时间后再进行重试。如果重试仍未成功，或许可以增加等待时间。即使这样，如果仍然失败，可能值得放弃重试并为后续连接断开电路。
- en: Circuit breaking is a mechanism that usually involves an electric circuit breaker.
    When there is a fault in a system where it is not safe to operate, the electric
    circuit breaker automatically trips. Similarly, consider microservices communications
    where one service is calling another service and the called service is not responding,
    is responding so slowly that it is detrimental to the calling service, or the
    occurrence of this behavior has reached a predefined threshold. In such a case,
    it is better to trip (stop) the circuit (communication) so that when the calling
    service (downstream) calls the underlying service (upstream), the communication
    fails straight away. The reason it makes sense to stop the downstream system from
    calling the upstream system is to stop resources such as network bandwidth, thread,
    IO, CPU, and memory from being wasted on an activity that has a significantly
    high probability of failing. Circuit breaking doesn’t resolve the communication
    problem; instead, it stops it from jumping boundaries and impacting other systems.
    Timeouts are also important during microservices communication so that downstream
    services wait for a response from the upstream system for a duration in which
    the response would be valid or worth waiting for. Deadlines build further on timeouts;
    you can see them as timeouts for the whole request, not just one connection. By
    specifying a deadline, a downstream system tells the upstream system about the
    overall maximum time permissible for processing the request, including subsequent
    calls to other upstream microservices involved in processing the request.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器是通常涉及电路断路器的一种机制。当系统出现故障而不安全运行时，电路断路器会自动跳闸。类似地，考虑微服务通信，其中一个服务调用另一个服务，被调用的服务未响应，响应过慢以至于对调用服务有害，或者这种行为的发生已达到预定义的阈值。在这种情况下，最好是跳闸（停止）电路（通信），这样当下游服务（调用者）调用底层服务（上游）时，通信会立即失败。停止下游系统调用上游系统的原因是防止网络带宽、线程、IO、CPU和内存等资源在极有可能失败的活动上浪费。断路器并不解决通信问题，而是阻止其跳出边界并影响其他系统。超时在微服务通信中也很重要，以便下游服务等待上游系统的响应，响应的有效时间段内等待。截止时间进一步建立在超时基础上；您可以将其视为整个请求的超时，而不仅仅是一个连接的超时。通过指定截止时间，下游系统告知上游系统关于处理请求的整体最大允许时间，包括对处理请求涉及的其他上游微服务的后续调用。
- en: Important note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: In a microservices architecture, downstream systems are the ones that rely on
    the upstream system. If service A calls service B, then service A will be called
    downstream and service B will be called upstream. When drawing a north–south architecture
    diagram to show a data flow between A and B, you will usually draw A at the top
    with an arrow pointing down toward B, which makes it confusing to call A downstream
    and B upstream. To make it easy to remember, you can draw the analogy that *a
    downstream system depends on an upstream system*. This way, microservice A depends
    on microservice B; hence, A is downstream and B is upstream.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，下游系统是依赖于上游系统的系统。如果服务A调用服务B，那么服务A将被称为下游，而服务B将被称为上游。在绘制北-南架构图以展示A和B之间的数据流时，通常会将A画在顶部，并向下指向B，这样称A为下游、B为上游会令人困惑。为了便于记忆，可以类比*下游系统依赖于上游系统*。这样，微服务A依赖于微服务B；因此，A是下游，B是上游。
- en: Blue/green and canary deployments
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝/绿和金丝雀部署
- en: Blue/green deployments are scenarios where you would like to deploy a new (green)
    version of a service side by side with the previous/existing (blue) version of
    a service. You make stability checks to ensure that the green environment can
    handle live traffic, and if it can, then you transfer the traffic from a blue
    to a green environment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝/绿部署是您希望将新版本（绿色）服务与先前/现有（蓝色）服务并行部署的情形。您进行稳定性检查以确保绿色环境能够处理实时流量，如果可以，则将流量从蓝色环境转移到绿色环境。
- en: Blue and green can be different versions of a service in a cluster or services
    in an independent cluster. If something goes wrong with the green environment,
    you can switch the traffic back to the blue environment. Transfer of traffic from
    blue to green can also happen gradually (canary deployment) in various ways –
    for example, at a certain rate, such as 90:10 in the first 10 minutes, 70:30 in
    the next 10 minutes, 50:50 in the next 20 minutes, and 0:100 after that. Another
    example can be to apply the previous example to certain traffic, such as transferring
    the traffic at a previous rate with all traffic with a certain HTTP header value
    – that is, a certain class of traffic. While in blue/green deployment you deploy
    like-for-like deployments side by side, in canary deployment you can deploy a
    subset of what you deploy in green deployment. These features are difficult to
    achieve in Kubernetes due to it not supporting the fine-grained distribution of
    traffic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色和绿色可以是集群中服务的不同版本，或者是独立集群中的服务。如果绿色环境出现问题，你可以将流量切换回蓝色环境。蓝色到绿色的流量迁移也可以逐步进行（金丝雀部署），有多种方式——例如，在前10分钟按90:10的比例，接下来的10分钟按70:30，接下来的20分钟按50:50，之后按0:100的比例迁移。另一个例子是将上述例子应用于某些特定流量，例如将之前的迁移比例应用于带有特定HTTP头值的所有流量——也就是某一类流量。在蓝绿部署中，你是并排部署相同的服务，而在金丝雀部署中，你可以只部署绿色部署中的一部分。这些特性在Kubernetes中难以实现，因为它不支持细粒度的流量分配。
- en: The following diagram depicts blue/green and canary deployments.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了蓝绿部署和金丝雀部署。
- en: '![Figure 1.7 – Blue/green deployment](img/B17989_01_07.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 蓝绿部署](img/B17989_01_07.jpg)'
- en: Figure 1.7 – Blue/green deployment
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 蓝绿部署
- en: To handle concerns such as blue/green and canary deployments, we need something
    that can handle the traffic at layer 7 rather than layer 4\. There are frameworks
    such as Netflix **Open Source Software** (**OSS**) and a few others to solve distributed
    system communication challenges, but in doing so, they shift the responsibility
    of solving application networking challenges to microservice developers. Solving
    these concerns in application code is not only expensive and time-consuming but
    also not conducive to the overall outcome, which is to deliver business outcomes.
    Frameworks and libraries such as Netflix OSS are written in certain programming
    languages, which then constrain developers to use only compatible languages for
    building microservices. These constrain developers to use technologies and programming
    languages supported by a specific framework, going against the polyglot concept.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理像蓝绿部署和金丝雀部署这样的需求，我们需要一个能够处理第7层流量而不是第4层流量的工具。像Netflix **开源软件**（**OSS**）等框架以及其他一些框架可以解决分布式系统通信中的挑战，但在此过程中，它们将解决应用网络问题的责任转移给了微服务开发者。在应用代码中解决这些问题不仅成本高、耗时，而且不利于最终目标的实现——交付业务成果。像Netflix
    OSS这样的框架和库是用某些特定编程语言编写的，这会限制开发者只能使用与之兼容的语言来构建微服务。这些框架限制了开发者使用特定框架支持的技术和编程语言，违背了多语言编程的概念。
- en: What is needed is a kind of proxy that can work alongside an application without
    requiring the application to have any knowledge of the proxy itself. The proxy
    should not just proxy the communication but also have intricate knowledge of the
    services doing the communication, along with the context of the communication.
    The application/service can then focus on business logic and let the proxy handle
    all concerns related to communication with other services. `ss` is one such proxy
    working at layer 7, designed to run alongside microservices. When it does so,
    it forms a transparent communication mesh with other Envoy proxies running alongside
    respective microservices. The microservice communicates only with nvoy as localhost,
    and Envoy takes care of the communication with the rest of the mesh. In this communication
    model, the microservices don’t need to know about the network. Envoy is extensible
    because it has a pluggable filter chain mechanism for network layers 3, 4, and
    7, allowing new filters to be added as needed to perform various functions, such
    as TLS client certificate authentication and rate limiting.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的是一种可以与应用程序一起工作的代理，而无需应用程序了解代理本身。代理不仅仅是传递通信，还应具备对进行通信的服务及其上下文的深刻了解。这样，应用程序/服务可以专注于业务逻辑，而让代理处理所有与其他服务通信相关的事务。`ss`
    就是这样的一个在第七层工作的代理，旨在与微服务一起运行。当它这样做时，它与其他在各自微服务旁边运行的 Envoy 代理形成了一个透明的通信网格。微服务仅与
    Envoy 作为本地主机进行通信，Envoy 负责与其余网格的通信。在这种通信模型中，微服务无需了解网络。Envoy 可扩展，因为它具有一个可插拔的过滤器链机制，支持第
    3、4 和 7 层的网络，可以根据需要添加新的过滤器，执行各种功能，如 TLS 客户端证书认证和流量限制。
- en: So, how are Service Meshes related with Envoy? A service Mesh is an infrastructure
    responsible for application networking. The following diagram depicts the relationship
    between the Service Mesh control plane, the Kubernetes API server, the Service
    Mesh sidecar, and other containers in the Pod.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，服务网格是如何与 Envoy 相关的呢？服务网格是一种负责应用程序网络的基础设施。下图描述了服务网格控制平面、Kubernetes API 服务器、服务网格
    Sidecar 和 Pod 中其他容器之间的关系。
- en: '![Figure 1.6 – Service Mesh sidecars, data, and the control plane](img/B17989_01_08.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 服务网格 Sidecar、数据和平面控制](img/B17989_01_08.jpg)'
- en: Figure 1.6 – Service Mesh sidecars, data, and the control plane
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 服务网格 Sidecar、数据和平面控制
- en: A Service Mesh provides a data plane, which is basically a collection of application-aware
    proxies such as Envoy that are then controlled by a set of components called the
    control plane. In a Kubernetes-based environment, the service proxies are inserted
    as a sidecar to Pods without needing any modification to existing containers within
    the Pod. A Service Mesh can be added to Kubernetes and traditional environments,
    such as virtual machines, as well. Once added to the runtime ecosystem, the Service
    Mesh takes care of the application networking concerns we discussed earlier, such
    as load balancing, timeouts, retries, canary and blue-green deployment, security,
    and observability.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格提供了一个数据平面，基本上是由应用感知的代理（如 Envoy）组成的集合，这些代理由一组名为控制平面（control plane）的组件进行管理。在基于
    Kubernetes 的环境中，服务代理被作为 Sidecar 插入到 Pods 中，而无需对 Pod 内现有的容器进行任何修改。服务网格也可以添加到 Kubernetes
    和传统环境（如虚拟机）中。一旦被添加到运行时生态系统中，服务网格就会处理我们之前讨论的与应用程序网络相关的问题，如负载均衡、超时、重试、金丝雀发布和蓝绿部署、安全性以及可观察性。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: In this chapter, we started with monolithic architecture and discussed the drag
    it causes in being able to expand with new capabilities as well as time to market.
    Monolithic architectures are brittle and expensive to change. We read about how
    microservices architecture breaks that inertia and provides the momentum required
    to meet the ever-changing and never-ending appetite of digital consumers. We also
    saw how microservices architecture is modular, with every module being self-contained,
    and can be built and deployed independently of each other. Applications built
    using microservices architecture make use of best-of-breed technologies that are
    suitable for solving individual problems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从单体架构开始，讨论了它在扩展新功能以及上市时间上的拖累。单体架构是脆弱的，且改变起来成本高昂。我们阅读了微服务架构如何打破这种惯性，并提供了所需的动力，以满足数字消费者日益变化且永无止境的需求。我们还看到微服务架构是模块化的，每个模块都是自包含的，并且可以独立构建和部署。使用微服务架构构建的应用程序利用了最适合解决单一问题的最佳技术。
- en: We then discussed the cloud and Kubernetes. The cloud provides utility-style
    computing with a pay-as-you-go model. Common cloud services include IaaS, PaaS,
    and SaaS. The cloud provides access to all infrastructure you may need without
    you needing to worry about the procurement of expensive hardware, data center
    costs, and so on. The cloud also provides you with software building blocks with
    which you can reduce your software development cycle. In microservices architecture,
    containers are the way to package application code. They provide consistency of
    environments and isolation between services, solving the *noisy* *neighbor* problem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了云计算和Kubernetes。云计算提供了一种按需付费的公用事业式计算模式。常见的云服务包括IaaS、PaaS和SaaS。云计算为你提供了所需的所有基础设施，无需担心昂贵的硬件采购、数据中心成本等问题。云计算还提供了软件构建模块，帮助你缩短软件开发周期。在微服务架构中，容器是封装应用程序代码的方式。它们提供了一致的环境和服务之间的隔离，解决了*邻居噪音*问题。
- en: Kubernetes, on the other hand, makes the usage of containers easier by providing
    container life cycle management and solving many of the challenges of running
    containers in production. As the number of microservices grows, you start facing
    challenges regarding traffic management between microservices. Kubernetes does
    provide traffic management based on kube-proxy and iptables-based rules, but it
    falls short of providing application networking.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Kubernetes通过提供容器生命周期管理并解决生产环境中运行容器的许多挑战，使得容器的使用变得更加简便。随着微服务数量的增加，你会开始面临微服务之间的流量管理挑战。Kubernetes确实提供了基于kube-proxy和iptables规则的流量管理，但它未能提供应用程序网络功能。
- en: We finally discussed Service Mesh, an infrastructure layer on top of Kubernetes
    that is responsible for application networking. The way it works is by providing
    a data plane, which is basically a collection of application-aware service proxies,
    such as Envoy, that are then controlled by a set of components called the control
    plane.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们讨论了服务网格，它是Kubernetes之上的基础设施层，负责应用程序网络。它的工作方式是通过提供数据平面，数据平面本质上是一个由应用感知的服务代理（如Envoy）组成的集合，这些代理由一组被称为控制平面的组件来管理。
- en: In the next chapter, we will read about Istio, one of the most popular Service
    Mesh implementations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将阅读Istio，这是最流行的服务网格实现之一。
