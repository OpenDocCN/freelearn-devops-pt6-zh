- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Extending Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes
- en: In this chapter, we will dig deep into the guts of Kubernetes. We will start
    with the Kubernetes API and learn how to work with Kubernetes programmatically
    via direct access to the API, the controller-runtime Go library, and automating
    kubectl. Then, we’ll look into extending the Kubernetes API with custom resources.
    The last part is all about the various plugins Kubernetes supports. Many aspects
    of Kubernetes operation are modular and designed for extension. We will examine
    the API aggregation layer and several types of plugins, such as custom schedulers,
    authorization, admission control, custom metrics, and volumes. Finally, we’ll
    look into extending kubectl and adding your own commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探索 Kubernetes 的内部。我们将从 Kubernetes API 开始，学习如何通过直接访问 API、使用 controller-runtime
    Go 库以及自动化 kubectl 来以编程方式操作 Kubernetes。然后，我们将研究如何使用自定义资源扩展 Kubernetes API。最后一部分将介绍
    Kubernetes 支持的各种插件。Kubernetes 操作的许多方面都是模块化的，并且设计为可扩展的。我们将研究 API 聚合层以及几种类型的插件，如自定义调度器、授权、准入控制、自定义度量和存储卷。最后，我们将探讨如何扩展
    kubectl 并添加自己的命令。
- en: 'The covered topics are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖的主题如下：
- en: Working with the Kubernetes API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes API
- en: Extending the Kubernetes API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes API
- en: Writing Kubernetes and kubectl plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Kubernetes 和 kubectl 插件
- en: Writing webhooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Webhook
- en: Working with the Kubernetes API
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes API
- en: The Kubernetes API is comprehensive and encompasses the entire functionality
    of Kubernetes. As you may expect, it is huge. But it is designed very well using
    best practices, and it is consistent. If you understand the basic principles,
    you can discover everything you need to know. We covered the Kubernetes API itself
    in *Chapter 1*, *Understanding Kubernetes Architecture*. If you need a refresher,
    go and take a look. In this section, we’re going to dive deeper and learn how
    to access and work with the Kubernetes API. But, first let’s look at OpenAPI,
    which is the formal foundation that gives structure to the entire Kubernetes API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 是全面的，涵盖了 Kubernetes 的所有功能。正如你可能预料的，它非常庞大。但它使用最佳实践设计，非常出色，并且保持一致性。如果你理解了基本原理，你可以发现所有你需要知道的内容。我们在*第一章*《理解
    Kubernetes 架构》中已经介绍了 Kubernetes API。如果你需要回顾一下，可以去看看。在本节中，我们将深入探讨，学习如何访问和使用 Kubernetes
    API。但首先，让我们了解一下 OpenAPI，它是为整个 Kubernetes API 提供结构化的正式基础。
- en: Understanding OpenAPI
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 OpenAPI
- en: OpenAPI (formerly Swagger) is an open standard that defines a language- and
    framework-agnostic way to describe RESTful APIs. It provides a standardized, machine-readable
    format for describing APIs, including their endpoints, parameters, request and
    response bodies, authentication, and other metadata.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI（前身为 Swagger）是一种开放标准，定义了一种与语言和框架无关的方式来描述 RESTful API。它提供了一种标准化、机器可读的格式来描述
    API，包括其端点、参数、请求和响应体、身份验证及其他元数据。
- en: In the context of Kubernetes, OpenAPI is used to define and document the API
    surface of a Kubernetes cluster. OpenAPI is used in Kubernetes to provide a standardized
    way to document and define the API objects that can be used to configure and manage
    the cluster. The Kubernetes API is based on a declarative model, where users define
    the desired state of their resources using YAML or JSON manifests. These manifests
    follow the OpenAPI schema, which defines the structure and properties of each
    resource. Kubernetes uses the OpenAPI schema to validate manifests, provide auto-completion
    and documentation in API clients, and generate API reference documentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 的上下文中，OpenAPI 用于定义和文档化 Kubernetes 集群的 API 接口。OpenAPI 被用于 Kubernetes，提供了一种标准化的方式来文档化和定义可以用来配置和管理集群的
    API 对象。Kubernetes API 基于声明式模型，用户通过 YAML 或 JSON 清单定义所需资源的状态。这些清单遵循 OpenAPI 架构，定义了每个资源的结构和属性。Kubernetes
    使用 OpenAPI 架构来验证清单，在 API 客户端中提供自动补全和文档，并生成 API 参考文档。
- en: One of the key benefits of using OpenAPI in Kubernetes is that it enables code
    generation for client libraries. This allows developers to interact with the Kubernetes
    API using their programming language of choice and generated client libraries,
    which provide a native and type-safe way to interact with the API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中使用 OpenAPI 的一个主要好处是，它支持为客户端库生成代码。这使得开发者可以使用他们选择的编程语言和生成的客户端库与
    Kubernetes API 进行交互，提供了一种本地化且类型安全的方式与 API 交互。
- en: Additionally, OpenAPI allows tools like kubectl to provide autocompletion and
    validation for Kubernetes resources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OpenAPI 还允许像 kubectl 这样的工具为 Kubernetes 资源提供自动补全和验证功能。
- en: OpenAPI also enables automated documentation generation for the Kubernetes API.
    With the OpenAPI schema, Kubernetes can automatically generate API reference documentation,
    which serves as a comprehensive and up-to-date resource for understanding the
    Kubernetes API and its capabilities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 还支持自动化生成 Kubernetes API 文档。通过 OpenAPI 架构，Kubernetes 可以自动生成 API 参考文档，作为一个全面且最新的资源，帮助理解
    Kubernetes API 及其功能。
- en: Kubernetes has had stable support for OpenAPI v3 since Kubernetes 1.27.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Kubernetes 1.27 起，Kubernetes 就稳定支持 OpenAPI v3。
- en: Check out [https://www.openapis.org](https://www.openapis.org) for more details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请访问 [https://www.openapis.org](https://www.openapis.org)。
- en: In order to work with the Kubernetes API locally, we need to set up a proxy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地使用 Kubernetes API，我们需要设置一个代理。
- en: Setting up a proxy
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置代理
- en: 'To simplify access, you can use kubectl to set up a proxy:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化访问，您可以使用 kubectl 设置一个代理：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, you can access the API server on `http://localhost:8080` and it will reach
    the same Kubernetes API server that kubectl is configured for.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在 `http://localhost:8080` 上访问 API 服务器，它将连接到与 kubectl 配置相同的 Kubernetes
    API 服务器。
- en: Exploring the Kubernetes API directly
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接探索 Kubernetes API
- en: The Kubernetes API is highly discoverable. You can just browse to the URL of
    the API server at `http://localhost:8080` and get a nice JSON document that describes
    all the available operations under the `paths` key.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 是高度可发现的。你只需要浏览到 `http://localhost:8080` 的 API 服务器 URL，就能获取一个描述所有可用操作的
    JSON 文档，其中包含在 `paths` 键下的所有操作。
- en: 'Here is a partial list due to space constraints:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间限制，这里是部分列表：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can drill down any one of the paths. For example, to discover the endpoint
    for the `default` namespace, I first called the `/api` endpoint, then discovered
    `/api/v1`, which told me there was `/api/v1/namespaces`, which pointed me to `/api/v1/namespaces/default`.
    Here is the response from the `/api/v1/namespaces/default` endpoint:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以深入查看任意一个路径。例如，要发现 `default` 命名空间的端点，我首先访问了 `/api` 端点，然后发现了 `/api/v1`，它告诉我有
    `/api/v1/namespaces`，接着指向了 `/api/v1/namespaces/default`。以下是来自 `/api/v1/namespaces/default`
    端点的响应：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can explore the Kubernetes API from the command line using tools like cURL
    or even kubectl itself, but sometimes using a GUI application is more convenient.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过命令行工具，如 cURL 或者 kubectl 本身，来探索 Kubernetes API，但有时使用图形界面应用程序会更加方便。
- en: Using Postman to explore the Kubernetes API
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Postman 探索 Kubernetes API
- en: Postman ([https://www.getpostman.com](https://www.getpostman.com)) is a very
    polished application for working with RESTful APIs. If you lean more to the GUI
    side, you may find it extremely useful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Postman ([https://www.getpostman.com](https://www.getpostman.com)) 是一个非常精致的应用程序，用于操作
    RESTful API。如果你更倾向于使用图形界面，可能会发现它非常有用。
- en: 'The following screenshot shows the available endpoints under the batch v1 API
    group:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了批量 v1 API 组下的可用端点：
- en: '![](img/B18998_15_01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_15_01.png)'
- en: 'Figure 15.1: The available endpoints under the batch v1 API group'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：批量 v1 API 组下的可用端点
- en: Postman has a lot of options, and it organizes the information in a very pleasing
    way. Give it a try.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 提供了很多选项，而且它以一种非常舒适的方式组织信息。试试看吧。
- en: Filtering the output with HTTPie and jq
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 HTTPie 和 jq 过滤输出
- en: 'The output from the API can be too verbose sometimes. Often, you’re interested
    just in one value out of a huge chunk of a JSON response. For example, if you
    want to get the names of all running services, you can hit the `/api/v1/services`
    endpoint. The response, however, includes a lot of additional information that
    is irrelevant. Here is a very partial subset of the output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: API 的输出有时可能过于冗长。通常，你只对从 JSON 响应中的一部分值感兴趣。例如，如果你想获取所有正在运行的服务的名称，可以访问 `/api/v1/services`
    端点。然而，响应中包含了很多无关的信息。以下是输出的一个非常小的子集：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The complete output is 193 lines long! Let’s see how to use HTTPie and jq to
    gain full control over the output and show only the names of the services. I prefer
    HTTPie([https://httpie.org/](https://httpie.org/)) over cURL for interacting with
    REST APIs on the command line. The jq ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    command-line JSON processor is great for slicing and dicing JSON.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的输出共有193行！让我们看看如何使用 HTTPie 和 jq 来完全控制输出，并仅显示服务的名称。我更喜欢 HTTPie([https://httpie.org/](https://httpie.org/))
    来与命令行中的 REST API 进行交互，相较于 cURL。jq ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    是一个非常棒的命令行 JSON 处理工具，适合切割和处理 JSON 数据。
- en: 'Examining the full output, you can see that the service name is in the `metadata`
    section of each item in the `items` array. The jq expression that will select
    just the name is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完整的输出，你会看到服务名称位于 `items` 数组中每个项的 `metadata` 部分。用于选择名称的 jq 表达式如下：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the full command and output on a fresh kind cluster:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在一个新建的 kind 集群上的完整命令和输出：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Accessing the Kubernetes API via the Python client
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 Python 客户端访问 Kubernetes API
- en: Exploring the API interactively using HTTPie and jq is great, but the real power
    of APIs comes when you consume and integrate them with other software. The Kubernetes
    Incubator project provides a full-fledged and very well-documented Python client
    library. It is available at [https://github.com/kubernetes-incubator/client-python](https://github.com/kubernetes-incubator/client-python).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTPie 和 jq 交互式地探索 API 很棒，但 API 的真正力量在于它们可以与其他软件进行消费和集成。Kubernetes Incubator
    项目提供了一个完整且文档齐全的 Python 客户端库。可以在 [https://github.com/kubernetes-incubator/client-python](https://github.com/kubernetes-incubator/client-python)
    获取。
- en: 'First, make sure you have Python installed ([https://wiki.python.org/moin/BeginnersGuide/Download](https://wiki.python.org/moin/BeginnersGuide/Download)).
    Then install the Kubernetes package:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你已安装 Python（[https://wiki.python.org/moin/BeginnersGuide/Download](https://wiki.python.org/moin/BeginnersGuide/Download)）。然后安装
    Kubernetes 包：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To start talking to a Kubernetes cluster, you need to connect to it. Start
    an interactive Python session:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始与 Kubernetes 集群进行交互，你需要连接到它。启动一个交互式 Python 会话：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Python client can read your kubectl config:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python 客户端可以读取你的 kubectl 配置：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or it can connect directly to an already running proxy:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以直接连接到已经运行的代理：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the `client` module provides methods to get access to different group
    versions, such as `CoreV1Api`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`client` 模块提供了访问不同组版本的方法，例如 `CoreV1Api`。
- en: Dissecting the CoreV1Api group
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构 CoreV1Api 组
- en: Let’s dive in and understand the `CoreV1Api` group. The Python object has 407
    public attributes!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解并理解 `CoreV1Api` 组。这个 Python 对象有 407 个公共属性！
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We ignore the attributes that start with double underscores because those are
    special class/instance methods unrelated to Kubernetes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略以双下划线开头的属性，因为它们是与 Kubernetes 无关的特殊类/实例方法。
- en: 'Let’s pick ten random methods and see what they look like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择十个随机方法，看看它们的样子：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Very interesting. The attributes begin with a verb such as `replace`, `list`,
    or `create`. Many of them have a notion of a namespace and many have a `with_http_info`
    suffix. To understand this better, let’s count how many verbs exist and how many
    attributes use each verb (where the verb is the first token before the underscore):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有趣。属性名以动词开头，例如 `replace`、`list` 或 `create`。其中许多属性涉及命名空间，并且许多属性有一个 `with_http_info`
    后缀。为了更好地理解这一点，让我们统计一下有多少个动词存在，以及每个动词使用的属性数量（动词是下划线前的第一个标记）：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can drill further and look at the interactive help for a specific attribute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以深入查看特定属性的交互式帮助：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We see that the API is vast, which makes sense because it represents the entire
    Kubernetes API. We also learned how to discover groups of related methods and
    how to get detailed information on specific methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 API 非常庞大，这也很合理，因为它代表了整个 Kubernetes API。我们还学习了如何发现相关方法的组，并且如何获取特定方法的详细信息。
- en: You can poke around yourself and learn more about the API. Let’s look at some
    common operations, such as listing, creating, and watching objects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己探索并了解更多关于 API 的内容。让我们看看一些常见的操作，如列出、创建和观察对象。
- en: Listing objects
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出对象
- en: 'You can list different kinds of objects. The method names start with `list_`.
    Here is an example listing all namespaces:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以列出不同种类的对象。方法名以 `list_` 开头。这里是一个列出所有命名空间的示例：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating objects
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'To create an object, you need to pass a `body` parameter to the `create` method.
    The `body` must be a Python dictionary that is equivalent to a YAML configuration
    manifest you would use with kubectl. The easiest way to do it is to actually use
    a YAML manifest and then use the Python YAML module (not part of the standard
    library and must be installed separately) to read the YAML file and load it into
    a dictionary. For example, to create an `nginx-deployment` with 3 replicas, we
    can use this YAML manifest (`nginx-deployment.yaml`):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个对象，你需要将 `body` 参数传递给 `create` 方法。`body` 必须是一个 Python 字典，相当于你使用 kubectl
    时的 YAML 配置清单。最简单的方法是直接使用 YAML 清单，然后使用 Python YAML 模块（这不是标准库的一部分，必须单独安装）读取 YAML
    文件并将其加载到字典中。例如，要创建一个具有 3 个副本的 `nginx-deployment`，我们可以使用这个 YAML 清单（`nginx-deployment.yaml`）：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To install the `yaml` Python module, type this command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `yaml` Python 模块，输入以下命令：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then the following Python program (`create_nginx_deployment.py`) will create
    the deployment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下 Python 程序（`create_nginx_deployment.py`）将创建部署：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s run it and check the deployment was actually created using kubectl:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它并使用 kubectl 检查部署是否已创建：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Watching objects
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监视对象
- en: 'Watching objects is an advanced capability. It is implemented using a separate
    `watch` module. Here is an example of watching 10 namespace events and printing
    them to the screen (`watch_demo.py`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 监视对象是一项高级功能。它是通过一个单独的 `watch` 模块实现的。以下是监视 10 个命名空间事件并将其打印到屏幕上的示例（`watch_demo.py`）：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that only 5 events were printed (one for each namespace) and the program
    continues to watch for more events.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有 5 个事件被打印出来（每个命名空间一个），程序继续监视更多事件。
- en: 'Let’s create and delete some namespaces in a separate terminal window, so the
    program can end:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个单独的终端窗口中创建并删除一些命名空间，以便程序能够结束：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can of course react to events and perform a useful action when an event
    happens (e.g., automatically deploy a workload in each new namespace).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以在事件发生时做出反应并执行有用的操作（例如，在每个新命名空间中自动部署工作负载）。
- en: Creating a pod via the Kubernetes API
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 Kubernetes API 创建一个 pod
- en: 'The API can be used for creating, updating, and deleting resources too. Unlike
    working with kubectl, the API requires specifying the manifests in JSON and not
    YAML syntax (although every JSON document is also valid YAML). Here is a JSON
    pod definition (`nginx-pod.json`):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: API 也可以用于创建、更新和删除资源。与使用 kubectl 不同，API 需要以 JSON 格式而不是 YAML 语法指定清单（尽管每个 JSON
    文档也是有效的 YAML）。以下是一个 JSON 格式的 pod 定义（`nginx-pod.json`）：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following command will create the pod via the API:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将通过 API 创建 pod：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To verify it worked, let’s extract the name and status of the current pods.
    The endpoint is `/api/v1/namespaces/default/pods`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证是否成功，让我们提取当前 pod 的名称和状态。端点是 `/api/v1/namespaces/default/pods`。
- en: The jq expression is `items[].metadata.name,.items[].status.phase`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: jq 表达式是 `items[].metadata.name,.items[].status.phase`。
- en: 'Here is the full command and output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的命令和输出：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Controlling Kubernetes using Go and controller-runtime
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Go 和 controller-runtime 控制 Kubernetes
- en: Python is cool and easy to work with, but for production-level tools, controllers,
    and operators, I prefer to use Go, and in particular the controller-runtime project.
    The controller-runtime is the standard Go client to use to access the Kubernetes
    API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 很酷且易于使用，但对于生产级工具、控制器和操作器，我更倾向于使用 Go，特别是 controller-runtime 项目。controller-runtime
    是用于访问 Kubernetes API 的标准 Go 客户端。
- en: Using controller-runtime via go-k8s
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 go-k8s 使用 controller-runtime
- en: The controller-runtime project is a set of Go libraries that can fully query
    and manipulate Kubernetes in a very efficient manner (e.g., advanced caching to
    avoid overwhelming the API server).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: controller-runtime 项目是一组 Go 库，可以非常高效地查询和操作 Kubernetes（例如，使用高级缓存来避免压垮 API 服务器）。
- en: Working directly with controller-runtime is not easy. There are many interlocking
    pieces and different ways to accomplish things.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用 controller-runtime 并不容易。它有许多相互关联的部分，并且有不同的方法来完成任务。
- en: See [https://pkg.go.dev/sigs.k8s.io/controller-runtime](https://pkg.go.dev/sigs.k8s.io/controller-runtime).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 查看：[https://pkg.go.dev/sigs.k8s.io/controller-runtime](https://pkg.go.dev/sigs.k8s.io/controller-runtime)。
- en: I created a little open-source project called `go-k8s` that encapsulates some
    of the complexity and helps with using a subset of the controller-runtime functionality
    with less hassle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为 `go-k8s` 的小型开源项目，它封装了一些复杂性，并帮助以更少的麻烦使用 controller-runtime 功能的子集。
- en: 'Check it out here: [https://github.com/the-gigi/go-k8s/tree/main/pkg/client](https://github.com/the-gigi/go-k8s/tree/main/pkg/client).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 查看详情：[https://github.com/the-gigi/go-k8s/tree/main/pkg/client](https://github.com/the-gigi/go-k8s/tree/main/pkg/client)。
- en: Note that the go-k8s project has other libraries, but we will focus on the client
    library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，go-k8s 项目还有其他库，但我们将重点介绍客户端库。
- en: 'The go-k8s client package supports two types of clients: `Clientset` and `DynamicClient`.
    The `Clientset` client supports working with well-known kinds, but explicitly
    specifying the API version, kind, and operation as method names. For example,
    listing all pods using `Clientset` looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: go-k8s 客户端包支持两种类型的客户端：`Clientset` 和 `DynamicClient`。`Clientset` 客户端支持与已知类型的交互，但需要明确指定
    API 版本、类型和操作作为方法名称。例如，使用 `Clientset` 列出所有 pods 如下所示：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It returns a pod list and an error. The error is `nil` if everything is OK.
    The pod list is of struct type `PodList`, which is defined here: [https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个 pod 列表和一个错误。如果一切正常，错误为 `nil`。pod 列表是结构体类型 `PodList`，定义见此处：[https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2514)。
- en: 'Conveniently, you can find all the Kubernetes API types in the same file. The
    API is very nested, for example, a `PodList`, as you may expect, is a list of
    `Pod` objects. Each `Pod` object has `TypeMeta`, `ObjectMeta`, `PodSpec`, and
    `PodStatus`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，你可以在同一个文件中找到所有 Kubernetes API 类型。API 结构非常嵌套，例如，`PodList` 如你所料，是 `Pod` 对象的列表。每个
    `Pod` 对象都有 `TypeMeta`、`ObjectMeta`、`PodSpec` 和 `PodStatus`：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In practice, this means that when you make a call through the `Clientset`,
    you get back a strongly typed nested object that is very easy to work with. For
    example, if we want to check if a pod has a label called `app` and its value,
    we can do it in one line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着当你通过 `Clientset` 发起调用时，你会得到一个强类型的嵌套对象，非常容易操作。例如，如果我们想检查一个 Pod 是否有一个名为
    `app` 的标签及其值，我们可以用一行代码完成：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the label doesn’t exist, `ok` will be false. If it does exist, then its value
    will be available in the `app` variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签不存在，`ok` 将为 `false`。如果存在，则其值将存储在 `app` 变量中。
- en: Now, let’s look at `DynamicClient`. Here, you get the ultimate flexibility and
    the ability to work with well-known types as well as custom types. In particular,
    if you want to create arbitrary resources, the dynamic client can operate in a
    generic way on any Kubernetes type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下 `DynamicClient`。在这里，你获得了终极的灵活性，能够与知名类型以及自定义类型一起工作。特别是，如果你想创建任意资源，动态客户端可以以通用方式操作任何
    Kubernetes 类型。
- en: 'However, with the dynamic client, you always get back a generic object of type
    `Unstructured`, defined here: [https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41](https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用动态客户端时，你总是会返回一个通用对象，类型为 `Unstructured`，定义见此处：[https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41](https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/unstructured/unstructured.go#L41)。
- en: 'It is really a very thin wrapper around the generic Golang type `map[string]interface{}`.
    It has a single field called `Object` of type `map[string]interface{}`. This means
    that the object you get back is a map of field names to arbitrary other objects
    (represented as `interface{}`). To drill down the hierarchy, we have to perform
    typecasting, which means taking an `interface{}` value and casting it explicitly
    to its actual type. Here is a simple example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上只是一个围绕通用 Go 类型 `map[string]interface{}` 的薄包装。它有一个名为 `Object` 的字段，类型是 `map[string]interface{}`。这意味着你返回的对象是一个字段名称到任意其他对象（表示为
    `interface{}`）的映射。要深入层次结构，我们必须进行类型转换，这意味着将一个 `interface{}` 值显式转换为其实际类型。下面是一个简单的示例：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, `x` is a variable of type `int` with a value of 5 that can be used as an
    integer. The original `i` variable can’t be used as an integer because its type
    is the generic `interface{}` even if it contains an integer value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`x` 是一个类型为 `int` 的变量，值为 5，可以作为整数使用。原始的 `i` 变量不能作为整数使用，因为它的类型是通用的 `interface{}`，即使它包含一个整数值。
- en: 'In the case of the objects returned from the dynamic client, we have to keep
    typecasting an `interface{}` to a `map[string]interface{}` until we get to the
    field we are interested in. To get to the `app` label of our pod, we need to follow
    this path:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从动态客户端返回的对象，我们必须不断地将`interface{}`类型转换为`map[string]interface{}`，直到我们找到感兴趣的字段。要获取我们
    Pod 的 `app` 标签，我们需要遵循以下路径：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is extremely tiresome and error-prone. Luckily, there is a better way.
    The Kubernetes `apimachinery/runtime` package provides a conversion function that
    can take an unstructured object and convert it into a known type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常繁琐且容易出错。幸运的是，有一种更好的方法。Kubernetes 的 `apimachinery/runtime` 包提供了一个转换函数，可以将一个非结构化的对象转换为已知类型：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The controller-runtime is very powerful, but it can be tedious to deal with
    all the types. One way to “cheat” is to use kubectl, which actually uses the controller-runtime
    under the covers. This is especially easy using Python and its dynamic typing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: controller-runtime 非常强大，但处理所有类型时可能会感到乏味。一个“作弊”的方法是使用 kubectl，它实际上是在幕后使用 controller-runtime。这在使用
    Python 和其动态类型时尤其容易。
- en: Invoking kubectl programmatically from Python and Go
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Python 和 Go 中程序化地调用 kubectl
- en: 'If you don’t want to deal with the REST API directly or client libraries, you
    have another option. Kubectl is used mostly as an interactive command-line tool,
    but nothing is stopping you from automating it and invoking it through scripts
    and programs. There are some benefits to using kubectl as your Kubernetes API
    client:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想直接处理REST API或客户端库，你还有另一种选择。Kubectl主要作为一个交互式命令行工具使用，但没有什么能阻止你通过脚本和程序来自动化它并调用它。使用kubectl作为Kubernetes
    API客户端有一些好处：
- en: Easy to find examples for any usage
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易找到任何用法的示例
- en: Easy to experiment on the command line to find the right combination of commands
    and arguments
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上很容易进行实验，以找到命令和参数的正确组合
- en: kubectl supports output in JSON or YAML for quick parsing
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl支持JSON或YAML格式的输出，便于快速解析
- en: Authentication is built in via kubectl configuration
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过kubectl配置内建了身份验证
- en: Using Python subprocess to run kubectl
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python的subprocess来运行kubectl
- en: Let’s use Python first, so you can compare using the official Python client
    to rolling your own. Python has a module called `subprocess` that can run external
    processes such as kubectl and capture the output.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们使用Python，这样你可以比较使用官方Python客户端和自己编写代码的不同。Python有一个名为`subprocess`的模块，可以运行外部进程，比如kubectl，并捕获输出。
- en: 'Here is a Python 3 example running kubectl on its own and displaying the beginning
    of the usage output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Python 3示例，运行kubectl并显示使用输出的开头：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Kubectl controls the Kubernetes cluster manager.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl控制Kubernetes集群管理器。
- en: Find more information at [https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问[https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/)。
- en: 'The `check_output()` function captures the output as a bytes array, which needs
    to be decoded into `utf-8` to be displayed properly. We can generalize it a little
    bit and create a convenience function called `k()` in the `k.py` file. It accepts
    any number of arguments it feeds to kubectl, and then decodes the output and returns
    it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_output()`函数将输出捕获为字节数组，需要解码为`utf-8`才能正确显示。我们可以稍微通用化一下，创建一个名为`k()`的便利函数，放在`k.py`文件中。它接受任意数量的参数，传递给kubectl，然后解码输出并返回：'
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s use it to list all the running pods in the default namespace:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用它来列出默认命名空间中所有正在运行的Pod：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is nice for display, but kubectl already does that. The real power comes
    when you use the structured output options with the `-o` flag. Then the result
    can be converted automatically into a Python object. Here is a modified version
    of the `k()` function that accepts a Boolean `use_json` keyword argument (defaults
    to `False`), and if `True`, adds `-o json` and then parses the JSON output to
    a Python object (dictionary):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于显示很不错，但kubectl本身就已经实现了这一点。真正的强大之处在于，当你使用带有`-o`标志的结构化输出选项时。然后结果可以自动转换为Python对象。以下是修改版的`k()`函数，它接受一个布尔值`use_json`关键字参数（默认为`False`），如果为`True`，则添加`-o
    json`，然后解析JSON输出为Python对象（字典）：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That returns a full-fledged API object, which can be navigated and drilled
    down just like when accessing the REST API directly or using the official Python
    client:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个完备的API对象，可以像访问REST API或使用官方Python客户端一样进行导航和深入探查：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s see how to delete the deployment and wait until all the pods are gone.
    The kubectl `delete` command doesn’t accept the `-o json` option (although it
    has `-o name`), so let’s leave out `use_json`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何删除部署并等待所有Pod消失。kubectl的`delete`命令不支持`-o json`选项（尽管它有`-o name`），因此我们将省略`use_json`：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Python is great, but what if you prefer Go for automating kubectl? No worries,
    I have just the package for you. The `kugo` package provides a simple Go API to
    automate kubectl. You can find the code here: [https://github.com/the-gigi/kugo](https://github.com/the-gigi/kugo).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python很棒，但如果你更喜欢用Go来自动化kubectl呢？别担心，我有适合你的包。`kugo`包提供了一个简单的Go API来自动化kubectl。你可以在这里找到代码：[https://github.com/the-gigi/kugo](https://github.com/the-gigi/kugo)。
- en: 'It provides 3 functions: `Run()`, `Get()`, and `Exec()`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了三个功能：`Run()`，`Get()`和`Exec()`。
- en: 'The `Run()` function is your Swiss Army knife. It can run any kubectl command
    as is. Here is an example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run()`函数是你的瑞士军刀。它可以直接运行任何kubectl命令。以下是一个示例：'
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is super convenient because you can interactively compose the exact command
    and parameters you need using kubectl and then, once you’ve figured out everything,
    you can literally take the same command and pass it to `kuge.Run()` in your Go
    program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，因为你可以交互式地组合你需要的准确命令和参数，然后，一旦你弄清楚所有内容，你可以直接将相同的命令传递给Go程序中的`kuge.Run()`。
- en: 'The `Get()` function is a smart wrapper around `kubectl get`. It accepts a
    `GetRequest` parameter and provides several amenities: it supports field selectors,
    fetching by label, and different output types. Here is an example of fetching
    all namespaces by name using a custom kube config file and custom kube context:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get()` 函数是围绕 `kubectl get` 的一个智能包装器。它接受一个 `GetRequest` 参数，并提供多种便利功能：支持字段选择器、按标签获取和不同的输出类型。以下是使用自定义
    kube 配置文件和自定义 kube 上下文获取所有命名空间名称的示例：'
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, the `Exec()` function is a wrapper around `kubectl exec` and lets
    you execute commands on a running pod/container. It accepts an `ExecRequest` that
    looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Exec()` 函数是围绕 `kubectl exec` 的一个包装器，允许您在运行的 pod/container 上执行命令。它接受一个看起来像这样的
    `ExecRequest`：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s look at the code of the Exec() function. It is pretty straightforward.
    It does basic validation that required fields like `Command` and `Target` were
    provided and then it builds a kubectl argument list starting with the `exec` command
    and finally calls the `Run()` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `Exec()` 函数的代码。它非常简单直接。它进行基本验证，确保提供了像 `Command` 和 `Target` 这样的必需字段，然后构建一个从
    `exec` 命令开始的 kubectl 参数列表，最后调用 `Run()` 函数：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, that we have accessed Kubernetes programmatically via its REST API, client
    libraries, and by controlling kubectl, it’s time to learn how to extend Kubernetes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过其 REST API、客户端库的编程方式访问 Kubernetes，并通过控制 kubectl，是学习如何扩展 Kubernetes 的时候了。
- en: Extending the Kubernetes API
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes API
- en: 'Kubernetes is an extremely flexible platform. It was designed from the get-go
    for extensibility and as it evolved, more parts of Kubernetes were opened up,
    exposed through robust interfaces, and could be replaced by alternative implementations.
    I would venture to say that the exponential adoption of Kubernetes across the
    board by start-ups, large companies, infrastructure providers, and cloud providers
    is a direct result of Kubernetes providing a lot of capabilities out of the box,
    but allowing easy integration with other actors. In this section, we will cover
    many of the available extension points, such as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个极其灵活的平台。从一开始就设计为可扩展的，并随着演变，越来越多的 Kubernetes 组件被开放，并通过稳健的接口暴露出来，可以被替换为替代实现。我敢说，Kubernetes
    在初创公司、大公司、基础设施提供商和云提供商中的指数级采用，直接源于 Kubernetes 提供了大量的开箱即用功能，同时又允许与其他组件轻松集成。在本节中，我们将涵盖许多可用的扩展点，例如：
- en: User-defined types (custom resources)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义类型（自定义资源）
- en: API access extensions
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 访问扩展
- en: Infrastructure extensions
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施扩展
- en: Operators
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作者
- en: Scheduler extensions
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序扩展
- en: Let’s understand the various ways you can extend Kubernetes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解您可以如何以各种方式扩展 Kubernetes。
- en: Understanding Kubernetes extension points and patterns
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 的扩展点和模式
- en: 'Kubernetes is made of multiple components: the API server, etcd state store,
    controller manager, kube-proxy, kubelet, and container runtime. You can deeply
    extend and customize each and every one of these components, as well as adding
    your own custom components that watch and react to events, handle new requests,
    and modify everything about incoming requests.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 由多个组件组成：API 服务器、etcd 状态存储、控制器管理器、kube-proxy、kubelet 和容器运行时。您可以深入扩展和定制每一个这些组件，还可以添加自己的定制组件，以监视和响应事件，处理新请求，并修改关于传入请求的一切。
- en: 'The following diagram shows some of the available extension points and how
    they are connected to various Kubernetes components:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一些可用的扩展点及其与各种 Kubernetes 组件的连接方式：
- en: '![](img/B18998_15_02.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_15_02.png)'
- en: 'Figure 15.2: Available extension points'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：可用的扩展点
- en: Let’s see how to extend Kubernetes with plugins.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用插件扩展 Kubernetes。
- en: Extending Kubernetes with plugins
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用插件扩展 Kubernetes
- en: 'Kubernetes defines several interfaces that allow it to interact with a wide
    variety of plugins from infrastructure providers. We discussed some of these interfaces
    and plugins in detail in previous chapters. We will just list them here for completeness:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 定义了几个接口，允许其与各种基础设施提供商的插件进行交互。我们在前几章节详细讨论了其中一些接口和插件。在这里，我们只列出它们以供完整性考虑：
- en: '**Container networking interface** (**CNI**) – the CNI supports a large number
    of networking solutions for connecting nodes and containers'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器网络接口**（**CNI**）– CNI 支持大量的连接节点和容器的网络解决方案'
- en: '**Container storage interface** (**CSI**) – the CSI supports a large number
    of storage options for Kubernetes'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器存储接口**（**CSI**）– CSI 支持大量的 Kubernetes 存储选项'
- en: Device plugins – allows nodes to discover new node resources beyond CPU and
    memory (e.g., a GPU)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备插件——允许节点发现除CPU和内存之外的新节点资源（例如，GPU）
- en: Extending Kubernetes with the cloud controller manager
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用云控制器管理器扩展Kubernetes
- en: Kubernetes needs to be deployed eventually on some nodes and use some storage
    and networking resources. Initially, Kubernetes supported only Google Cloud Platform
    and AWS. Other cloud providers had to customize multiple Kubernetes core components
    (Kubelet, the Kubernetes controller manager, and the Kubernetes API server) in
    order to integrate with Kubernetes. The Kubernetes developers identified it as
    a problem for adoption and created the **cloud controller manager** (**CCM**).
    The CCM cleanly defines the interaction between Kubernetes and the infrastructure
    layer it is deployed on. Now, cloud providers just provide an implementation of
    the CCM tailored to their infrastructure, and they can utilize upstream Kubernetes
    without costly and error-prone modification to the Kubernetes code. All the Kubernetes
    components interact with the CCM via the predefined interfaces and Kubernetes
    is blissfully unaware of which cloud (or no cloud) it is running on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最终需要部署在一些节点上，并使用一些存储和网络资源。最初，Kubernetes仅支持Google Cloud Platform和AWS。其他云提供商必须定制多个Kubernetes核心组件（如Kubelet、Kubernetes控制器管理器和Kubernetes
    API服务器），才能与Kubernetes集成。Kubernetes开发者将其视为采用过程中的问题，并创建了**云控制器管理器**（**CCM**）。CCM清晰地定义了Kubernetes与其部署基础设施层之间的交互。现在，云提供商只需要提供一个适应其基础设施的CCM实现，并可以利用上游Kubernetes，而无需对Kubernetes代码进行代价高昂且容易出错的修改。所有Kubernetes组件通过预定义接口与CCM交互，Kubernetes则完全不关心它运行在哪个云（或没有云）上。
- en: 'The following diagram demonstrates the interaction between Kubernetes and a
    cloud provider via the CCM:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示演示了Kubernetes与云提供商通过CCM的交互：
- en: '![](img/B18998_15_03.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_15_03.png)'
- en: 'Figure 15.3: Interaction between Kubernetes and a cloud provider via the CCM'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：Kubernetes与云提供商通过CCM的交互
- en: 'If you want to learn more about the CCM, check out this concise article I wrote
    a few years ago: [https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198](https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于CCM的信息，可以查看我几年前写的这篇简明文章：[https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198](https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198)。
- en: Extending Kubernetes with webhooks
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用webhook扩展Kubernetes
- en: Plugins run in the cluster, but in some cases, a better extensibility pattern
    is to delegate some functions to an out-of-cluster service. This is very common
    in the area of access control where companies and organizations may already have
    a centralized solution for identity and access control. In those cases, the webhook
    extensibility pattern is useful. The idea is that you can configure Kubernetes
    with an endpoint (webhook). Kubernetes will call the endpoint where you can implement
    your own custom functionality and Kubernetes will take action based on the response.
    We saw this pattern when we discussed authentication, authorization, and dynamic
    admission control in *Chapter 4*, *Securing Kubernetes*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 插件在集群中运行，但在某些情况下，更好的扩展性模式是将一些功能委托给集群外部的服务。这在访问控制领域非常常见，因为公司和组织可能已经有一个集中化的身份和访问控制解决方案。在这些情况下，webhook扩展模式非常有用。其核心思想是，你可以通过配置Kubernetes与一个端点（webhook）进行交互。Kubernetes将调用该端点，你可以在其中实现自己的自定义功能，然后Kubernetes会根据响应采取相应的行动。我们在*第4章*《保护Kubernetes》中讨论身份验证、授权和动态准入控制时，看到过这种模式。
- en: Kubernetes defines the expected payloads for each webhook. The webhook implementation
    must adhere to them in order to successfully interact with Kubernetes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes定义了每个webhook的预期有效载荷。Webhook的实现必须遵循这些定义，才能成功与Kubernetes进行交互。
- en: Extending Kubernetes with controllers and operators
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用控制器和操作符扩展Kubernetes
- en: The controller pattern is where you write a program that can run inside the
    cluster or outside the cluster, watch for events, and respond to them. The conceptual
    model for a controller is to reconcile the current state of the cluster (the parts
    the controller is interested in) with the desired state. A common practice for
    controllers is to read the `Spec` of an object, take some actions, and update
    its `Status`. A lot of the core logic of Kubernetes is implemented by a large
    set of controllers managed by the controller manager, but there is nothing stopping
    us from deploying our own controllers to the cluster or running controllers that
    access the API server remotely.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器模式是编写一个可以在集群内或集群外运行的程序，监视事件并响应它们。控制器的概念模型是将集群的当前状态（控制器感兴趣的部分）与期望状态进行协调。控制器的常见做法是读取对象的
    `Spec`，采取一些行动，并更新其 `Status`。Kubernetes 的许多核心逻辑是由由控制器管理器管理的大量控制器实现的，但没有任何限制阻止我们将自己的控制器部署到集群中，或者运行访问
    API 服务器的远程控制器。
- en: The operator pattern is another flavor of the controller pattern. Think of an
    operator as a controller that also has its own set of custom resources, which
    represents an application it manages. The goal of operators is to manage the lifecycle
    of an application that is deployed in the cluster or some out-of-cluster infrastructure.
    Check out [https://operatorhub.io](https://operatorhub.io) for examples of existing
    operators.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员模式是控制器模式的另一种形式。可以将操作员视为一种控制器，它还有自己的一组自定义资源，表示它管理的应用程序。操作员的目标是管理部署在集群内或某些集群外基础设施中的应用程序的生命周期。可以查看
    [https://operatorhub.io](https://operatorhub.io) 了解现有操作员的示例。
- en: If you plan to build your own controllers, I recommend starting with Kubebuilder
    ([https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)).
    It is an open project maintained by the Kubernetes API Machinery SIG and has support
    for defining multiple custom APIs using CRDs, and scaffolds out the controller
    code to watch these resources. You will implement your controller in Go.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划构建自己的控制器，我推荐从 Kubebuilder 开始 ([https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder))。这是一个由
    Kubernetes API Machinery SIG 维护的开源项目，支持使用 CRD 定义多个自定义 API，并自动生成控制器代码来监视这些资源。你将在
    Go 中实现控制器。
- en: 'However, there are multiple other frameworks for writing controllers and operators
    with different approaches and using other programming languages:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有多个其他框架可以编写控制器和操作员，采用不同的方法，并使用其他编程语言：
- en: The Operator Framework
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员框架
- en: Kopf
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kopf
- en: kube-rs
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-rs
- en: KubeOps
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KubeOps
- en: KUDO
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KUDO
- en: Metacontroller
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元控制器
- en: Check them out before you make your decision.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在做决定之前，先了解一下它们。
- en: Extending Kubernetes scheduling
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes 调度
- en: Kubernetes’ primary job, in one sentence, is to schedule pods on nodes. Scheduling
    is at the heart of what Kubernetes does, and it does it very well. The Kubernetes
    scheduler can be configured in very advanced ways (daemon sets, taints, tolerations,
    etc.). But still, the Kubernetes developers recognize that there may be extraordinary
    circumstances where you may want to control the core scheduling algorithm. It
    is possible to replace the core Kubernetes scheduler with your own scheduler or
    run another scheduler side by side with the built-in scheduler to control the
    scheduling of a subset of the pods. We will see how to do that later in the chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的主要工作，简而言之，就是在节点上调度 Pods。调度是 Kubernetes 的核心功能，它做得非常好。Kubernetes 调度器可以通过非常高级的方式进行配置（守护进程集、污点、容忍度等）。但即便如此，Kubernetes
    开发人员也认识到，在某些特殊情况下，你可能希望控制核心调度算法。你可以用自己的调度器替换核心 Kubernetes 调度器，或者与内置调度器并行运行另一个调度器，来控制一部分
    Pod 的调度。我们将在本章稍后部分看到如何实现这一点。
- en: Extending Kubernetes with custom container runtimes
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义容器运行时扩展 Kubernetes
- en: 'Kubernetes originally supported only Docker as a container runtime. The Docker
    support was embedded into the core Kubernetes codebase. Later, dedicated support
    for rkt was added. The Kubernetes developers saw the light and introduced the
    **container runtime interface** (**CRI**), a gRPC interface that enables any container
    runtime that implements it to communicate with the kubelet. Eventually, the hard-coded
    support for Docker and rkt was phased out and now the kubelet talks to the container
    runtime only through the CRI:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最初只支持Docker作为容器运行时。Docker的支持被嵌入到Kubernetes核心代码中。后来，专门支持rkt也被加入。Kubernetes的开发者意识到这一点，并引入了**容器运行时接口**（**CRI**），这是一个gRPC接口，任何实现它的容器运行时都可以与kubelet通信。最终，Docker和rkt的硬编码支持被淘汰，现在kubelet仅通过CRI与容器运行时进行通信：
- en: '![](img/B18998_15_04.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_15_04.png)'
- en: 'Figure 15.4: Kubelet talking to the container runtime through the CRI'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：Kubelet通过CRI与容器运行时通信
- en: Since the introduction of the CRI, the number of container runtimes that work
    with Kubernetes has exploded.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 自CRI（容器运行时接口）引入以来，支持Kubernetes的容器运行时数量激增。
- en: We’ve covered multiple ways to extend different aspects of Kubernetes. Let’s
    turn our attention to the major concept of custom resources, which allow you to
    extend the Kubernetes API itself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了多种扩展Kubernetes不同方面的方法。接下来，让我们聚焦于自定义资源的主要概念，它允许你扩展Kubernetes API本身。
- en: Introducing custom resources
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入自定义资源
- en: 'One of the primary ways to extend Kubernetes is to define new types of resources
    called custom resources. What can you do with custom resources? Plenty. You can
    use them to manage, through the Kubernetes API, resources that live outside the
    Kubernetes cluster but that your pods communicate with. By adding those external
    resources as custom resources, you get a full picture of your system, and you
    benefit from many Kubernetes API features such as:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Kubernetes的主要方式之一是定义新类型的资源，称为自定义资源。你可以用自定义资源做什么？很多。你可以通过Kubernetes API管理那些存在于Kubernetes集群外，但你的Pod与之通信的资源。通过将这些外部资源作为自定义资源，你能更全面地了解你的系统，并能享受到Kubernetes
    API的众多功能，如：
- en: Custom CRUD REST endpoints
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义CRUD REST端点
- en: Versioning
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Watches
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听
- en: Automatic integration with generic Kubernetes tooling
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与通用Kubernetes工具的自动集成
- en: Other use cases for custom resources are metadata for custom controllers and
    automation programs.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源的其他应用场景包括自定义控制器和自动化程序的元数据。
- en: Let’s dive in and see what custom resources are all about.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解自定义资源的具体内容。
- en: 'In order to play nice with the Kubernetes API server, custom resources must
    conform to some basic requirements. Similar to built-in API objects, they must
    have the following fields:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Kubernetes API服务器兼容，自定义资源必须符合一些基本要求。类似于内建的API对象，它们必须包含以下字段：
- en: '`apiVersion`: `apiextensions.k8s.io/v1`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`: `apiextensions.k8s.io/v1`'
- en: '`metadata`: Standard Kubernetes object metadata'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`: 标准Kubernetes对象元数据'
- en: '`kind`: `CustomResourceDefinition`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`: `CustomResourceDefinition`'
- en: '`spec`: Describes how the resource appears in the API and tools'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`: 描述资源在API和工具中的表现方式'
- en: '`status`: Indicates the current status of the CRD'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 表示CRD的当前状态'
- en: The `spec` has an internal structure that includes fields like `group`, `names`,
    `scope`, `validation`, and `version`. The `status` includes the fields `acceptedNames`
    and `Conditions`. In the next section, I’ll show you an example that clarifies
    the meaning of these fields.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`包含一个内部结构，其中包括`group`、`names`、`scope`、`validation`和`version`等字段。`status`包括`acceptedNames`和`Conditions`字段。在接下来的章节中，我将展示一个示例，帮助你理解这些字段的含义。'
- en: Developing custom resource definitions
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发自定义资源定义
- en: 'You develop your custom resources using custom resource definitions, AKA CRDs.
    The intention is for CRDs to integrate smoothly with Kubernetes, its API, and
    tooling. That means you need to provide a lot of information. Here is an example
    for a custom resource called Candy:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过自定义资源定义（也叫CRD）来开发自定义资源。目的是让CRD能够顺利地与Kubernetes、其API和工具集成。这意味着你需要提供大量信息。以下是一个名为Candy的自定义资源的示例：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Candy CRD has several interesting parts. The metadata has a fully qualified
    name, which should be unique since CRDs are cluster-scoped. The spec has a `versions`
    section, which can contain multiple versions with a schema for each version that
    specifies the field of the custom resource. The schema follows the OpenAPI v3
    specification ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject)).
    The `scope` field could be either `Namespaced` or `Cluster`. If the scope is `Namespaced`,
    then the custom resources you create from the CRD will exist only in the namespace
    they were created in, whereas cluster-scoped custom resources are available in
    any namespace. Finally, the `names` section refers to the names of the custom
    resource (not the name of the CRD from the `metadata` section). The `names` section
    has `plural`, `singular`, `kind`, and `shortNames` options.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Candy CRD 有几个有趣的部分。metadata 中包含一个完全限定的名称，应该是唯一的，因为 CRD 是集群范围的。spec 中有一个 `versions`
    部分，它可以包含多个版本，每个版本都有一个指定自定义资源字段的 schema。该 schema 遵循 OpenAPI v3 规范（[https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#schemaObject)）。`scope`
    字段可以是 `Namespaced` 或 `Cluster`。如果 scope 是 `Namespaced`，那么从 CRD 创建的自定义资源将仅存在于其创建的命名空间中，而集群范围的自定义资源可以在任何命名空间中使用。最后，`names`
    部分指的是自定义资源的名称（而不是来自 `metadata` 部分的 CRD 名称）。`names` 部分有 `plural`、`singular`、`kind`
    和 `shortNames` 选项。
- en: 'Let’s create the CRD:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来创建 CRD：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note, that the metadata name is returned. It is common to use a plural name.
    Now, let’s verify we can access it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，返回的是 metadata 名称。通常使用复数名称。现在，让我们验证是否可以访问它：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There is also an API endpoint for managing this new resource:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 API 端点用于管理这个新资源：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Integrating custom resources
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成自定义资源
- en: 'Once the `CustomResourceDefinition` object has been created, you can create
    custom resources of that resource kind – `Candy` in this case (candy becomes CamelCase
    Candy). Custom resources must respect the schema of the CRD. In the following
    example, the `flavor` field is set on the `Candy` object with the name `chocolate`.
    The `apiVersion` field is derived from the CRD `spec` group and `versions` fields:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `CustomResourceDefinition` 对象创建完成，你可以创建该资源类型的自定义资源——在本例中是 `Candy`（candy 变为
    CamelCase 的 Candy）。自定义资源必须遵守 CRD 的 schema。在以下示例中，`flavor` 字段被设置在名为 `chocolate`
    的 `Candy` 对象上。`apiVersion` 字段是从 CRD 的 `spec` 中的 `group` 和 `versions` 字段推导出来的：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s create it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建它：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that the spec must contain the `flavor` field from the schema.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，spec 中必须包含 schema 中的 `flavor` 字段。
- en: 'At this point, kubectl can operate on Candy objects just like it works on built-in
    objects. Resource names are case-insensitive when using kubectl:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，kubectl 可以像操作内建对象一样操作 Candy 对象。使用 kubectl 时，资源名称是不区分大小写的：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also view the raw JSON data using the standard `-o json` flag. Let’s
    use the short name `cn` this time:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用标准的 `-o json` 标志查看原始 JSON 数据。这次我们使用短名称 `cn`：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Dealing with unknown fields
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理未知字段
- en: The schema in the spec was introduced with the `apiextensions.k8s.io/v1` version
    of CRDs that became stable in Kubernetes 1.17\. With `apiextensions.k8s.io/v1beta`,
    a schema wasn’t required so arbitrary fields were the way to go. If you just try
    to change the version of your CRD from v1beta to v1, you’re in for a rude awakening.
    Kubernetes will let you update the CRD, but when you try to create a custom resource
    later with unknown fields, it will fail.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中的 schema 是在 `apiextensions.k8s.io/v1` 版本的 CRD 中引入的，该版本在 Kubernetes 1.17 中变得稳定。使用
    `apiextensions.k8s.io/v1beta` 时，不需要 schema，因此可以使用任意字段。如果你只是试图将 CRD 的版本从 v1beta
    更改为 v1，你将面临一次痛苦的觉醒。Kubernetes 会允许你更新 CRD，但当你试图使用未知字段创建自定义资源时，它会失败。
- en: You must define a schema for all your CRDs. If you must deal with custom resources
    that may have additional unknown fields, you can turn validation off, but the
    additional fields will be stripped off.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须为所有的 CRD 定义一个 schema。如果你必须处理可能包含额外未知字段的自定义资源，可以关闭验证，但额外的字段会被剥离。
- en: 'Here is a `Candy` resource that has an extra field, `texture`, not specified
    in the schema:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `Candy` 资源，它有一个额外的字段 `texture`，该字段在 schema 中未指定：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we try to create it with validation, it will fail:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用验证来创建，它将失败：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'But, if we turn validation off, then all is well, except that only the `flavor`
    field will be present and the `texture` field will not:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们关闭验证，一切都会正常，除了只有 `flavor` 字段会出现，而 `texture` 字段不会：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Sometimes, it can be useful to keep unknown fields. CRDs can support unknown
    fields by adding a special field to the schema.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，保留未知字段是有用的。CRDs 可以通过向架构中添加一个特殊字段来支持未知字段。
- en: 'Let’s delete the current Candy CRD and replace it with a CRD that supports
    unknown fields:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除当前的 Candy CRD，并用一个支持未知字段的 CRD 替代它：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The new CRD has the `x-kubernetes-preserve-unknown-fields` field set to `true`
    in the `spec` property:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 CRD 在 `spec` 属性中将 `x-kubernetes-preserve-unknown-fields` 字段设置为 `true`：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s create our gummy bear again WITH validation and check that the unknown
    `texture` field is present:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新创建一个带有验证的糖果，并检查未知的 `texture` 字段是否存在：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Finalizing custom resources
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成自定义资源的最终化
- en: Custom resources support finalizers just like standard API objects. A finalizer
    is a mechanism where objects are not deleted immediately but have to wait for
    special controllers that run in the background and watch for deletion requests.
    The controller may perform any necessary cleanup options and then remove its finalizer
    from the target object. There may be multiple finalizers on an object. Kubernetes
    will wait until all finalizers have been removed and only then delete the object.
    The finalizers in the metadata are just arbitrary strings that their corresponding
    controller can identify. Kubernetes doesn’t know what they mean.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源支持最终化器，就像标准 API 对象一样。最终化器是一种机制，对象不会立即被删除，而是必须等待在后台运行并监视删除请求的特殊控制器。控制器可以执行任何必要的清理操作，然后从目标对象中移除其最终化器。一个对象可能有多个最终化器。Kubernetes
    会等待所有最终化器被移除后才会删除对象。元数据中的最终化器只是一些任意字符串，对应的控制器可以识别它们。Kubernetes 并不知道它们的含义。
- en: 'It just waits patiently for all the finalizers to be removed before deleting
    the object. Here is an example with a `Candy` object that has two finalizers:
    `eat-me` and `drink-me`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是在删除对象之前耐心等待所有最终化器被移除。以下是一个示例，展示了一个包含两个最终化器（`eat-me` 和 `drink-me`）的 `Candy`
    对象：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Adding custom printer columns
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义打印列
- en: 'By default, when you list custom resources with kubectl, you get only the name
    and the age of the resource:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你使用 kubectl 列出自定义资源时，只会显示资源的名称和年龄：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'But the CRD schema allows you to add your own columns. Let’s add the flavor
    and the age as printable columns to our `Candy` objects:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 CRD 架构允许你添加自己的列。让我们将“flavor”和“age”作为可打印列添加到我们的 `Candy` 对象中：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then we can apply it, add our candies again, and list them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以应用它，重新添加我们的糖果，并列出它们：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Understanding API server aggregation
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 API 服务器聚合
- en: CRDs are great when all you need is some CRUD operations on your own types.
    You can just piggyback on the Kubernetes API server, which will store your objects
    and provide API support and integration with tooling like kubectl. If you need
    more power, you can run controllers that watch for your custom resources and perform
    some operations when they are created, updated, or deleted. The Kubebuilder ([https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder))
    project is a great framework for building Kubernetes APIs on top of CRDs with
    your own controllers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只需要对自己的类型进行一些 CRUD 操作时，CRDs 非常有用。你可以直接依赖 Kubernetes API 服务器，它会存储你的对象，并提供 API
    支持及与工具（如 kubectl）的集成。如果你需要更多功能，可以运行控制器，监视你的自定义资源，并在它们被创建、更新或删除时执行某些操作。Kubebuilder
    ([https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder))
    项目是一个很好的框架，能帮助你在 CRDs 上构建 Kubernetes API，并创建自己的控制器。
- en: 'But CRDs have limitations. If you need more advanced features and customization,
    you can use API server aggregation and write your own API server, which the Kubernetes
    API server will delegate to. Your API server will use the same API machinery as
    the Kubernetes API server itself. Some advanced capabilities are available only
    through the aggregation layer:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 CRDs 有一定的限制。如果你需要更高级的功能和自定义，可以使用 API 服务器聚合，并编写你自己的 API 服务器，Kubernetes API
    服务器将委托给它。你的 API 服务器将使用与 Kubernetes API 服务器本身相同的 API 机制。一些高级功能仅通过聚合层提供：
- en: Make your API server adopt different storage APIs rather than etcd
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的 API 服务器采用不同的存储 API，而不是 etcd
- en: Extend long-running subresources/endpoints like WebSocket for your own resources
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展类似 WebSocket 的长期运行子资源/端点，以支持你自己的资源
- en: Integrate your API server with any other external systems
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的 API 服务器与任何外部系统集成
- en: Control the storage of your objects (custom resources are always stored in etcd)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对象的存储（自定义资源始终存储在 etcd 中）
- en: Custom operations beyond CRUD (e.g., exec or scale)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出 CRUD 的自定义操作（例如，exec 或 scale）
- en: Use protocol buffer payloads
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议缓冲区有效负载
- en: 'Writing an extension API server is a non-trivial effort. If you decide you
    need all that power, there are a couple of good starting points. You can look
    at the sample API server for inspiration ([https://github.com/kubernetes/sample-apiserver](https://github.com/kubernetes/sample-apiserver)).
    You may want to check out the `apiserver-builder-alpha` project ([https://github.com/kubernetes-sigs/apiserver-builder-alpha](https://github.com/kubernetes-sigs/apiserver-builder-alpha)).
    It takes care of a lot of the necessary boilerplate code. The API builder provides
    the following capabilities:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 编写扩展 API 服务器是一项不容小觑的工作。如果你决定需要所有这些功能，有几个不错的起点。你可以参考示例 API 服务器获取灵感（[https://github.com/kubernetes/sample-apiserver](https://github.com/kubernetes/sample-apiserver)）。你可能还想查看
    `apiserver-builder-alpha` 项目（[https://github.com/kubernetes-sigs/apiserver-builder-alpha](https://github.com/kubernetes-sigs/apiserver-builder-alpha)）。它处理了很多必要的样板代码。API
    构建器提供以下功能：
- en: Bootstrap complete type definitions, controllers, and tests as well as documentation
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导完整的类型定义、控制器、测试以及文档
- en: An extension control plane you can run on a local cluster or on an actual remote
    cluster
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以在本地集群或实际远程集群上运行的扩展控制平面
- en: Your generated controllers will be able to watch and update API objects
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你生成的控制器将能够监视并更新 API 对象
- en: Add resources (including sub-resources)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加资源（包括子资源）
- en: Default values you can override if needed
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，你可以覆盖的默认值
- en: 'There is also a walkthrough here: [https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/](https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也有一个教程：[https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/](https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/)。
- en: Building Kubernetes-like control planes
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建类似 Kubernetes 的控制平面
- en: 'What if you want to use the Kubernetes model to manage other things and not
    just pods? It turns out that this is a very desirable capability. There is a project
    with a lot of momentum that provides it: [https://github.com/kcp-dev/kcp](https://github.com/kcp-dev/kcp).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Kubernetes 模型来管理其他资源，而不仅仅是 pod，怎么办？事实证明，这是一个非常受欢迎的功能。有一个 momentum 十足的项目提供了这个功能：[https://github.com/kcp-dev/kcp](https://github.com/kcp-dev/kcp)。
- en: kcp also ventures into multi-cluster management.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: kcp 还涉足了多集群管理。
- en: What does kcp bring to the table?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: kcp 能带来什么好处？
- en: It is a control plane for multiple conceptual clusters called workspaces
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个用于多个概念性集群（称为工作区）的控制平面
- en: It enables external API service providers to integrate with the central control
    plane using multi-tenant operators
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使外部 API 服务提供商能够通过多租户操作符与中央控制平面进行集成
- en: Users can consume APIs easily in their workspaces
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以轻松地在工作区中使用 API
- en: Scheduling workloads flexibly to physical clusters
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活地将工作负载调度到物理集群
- en: Move workloads transparently between compatible physical clusters
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在兼容的物理集群之间透明地迁移工作负载
- en: Users can deploy their workloads while taking advantage of capabilities such
    as geographic replication and cross-cloud replication.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在部署工作负载时，利用地理复制和跨云复制等功能。
- en: We have covered different ways to extend Kubernetes by adding controllers and
    aggregated API servers. Let’s take a look at another mode of extending Kubernetes,
    by writing plugins.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了通过添加控制器和聚合 API 服务器来扩展 Kubernetes 的不同方法。现在让我们来看看扩展 Kubernetes 的另一种方式：编写插件。
- en: Writing Kubernetes plugins
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Kubernetes 插件
- en: In this section, we will dive into the guts of Kubernetes and learn how to take
    advantage of its famous flexibility and extensibility. We will learn about different
    aspects that can be customized via plugins and how to implement such plugins and
    integrate them with Kubernetes.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将深入了解 Kubernetes 的内部结构，学习如何利用其著名的灵活性和可扩展性。我们将了解可以通过插件自定义的不同方面，以及如何实现这些插件并将它们与
    Kubernetes 集成。
- en: Writing a custom scheduler
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义调度器
- en: Kubernetes is all about orchestrating containerized workloads. The most fundamental
    responsibility is to schedule pods to run on cluster nodes. Before we can write
    our own scheduler, we need to understand how scheduling works in Kubernetes
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 主要负责调度容器化工作负载。最基本的职责是将 pod 调度到集群节点上。在我们编写自己的调度器之前，我们需要理解 Kubernetes
    中调度是如何工作的
- en: Understanding the design of the Kubernetes scheduler
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 调度器的设计
- en: The Kubernetes scheduler has a very simple role – when a new pod needs to be
    created, assign it to a target node. That’s it. The Kubelet on the target node
    will take it from there and instruct the container runtime on the node to run
    the pod’s containers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes调度器的角色非常简单——当需要创建一个新Pod时，将其分配到目标节点。就是这样。目标节点上的Kubelet会接管并指示节点上的容器运行时运行Pod的容器。
- en: 'The Kubernetes scheduler implements the Controller pattern:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes调度器实现了控制器模式：
- en: Watch for pending pods
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控待处理的Pod
- en: Select the proper node for the pod
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Pod选择合适的节点
- en: Update the node’s spec by setting the `nodeName` field
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置`nodeName`字段更新节点的规格
- en: 'The only complicated part is selecting the target node. This process involves
    multiple steps split into two cycles:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一复杂的部分是选择目标节点。这个过程涉及多个步骤，分为两个周期：
- en: The scheduling cycle
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度周期
- en: The binding cycle
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定周期
- en: While scheduling cycles are executed sequentially, binding cycles can be executed
    in parallel. If the target pod is considered unschedulable or an internal error
    occurs, the cycle will be terminated, and the pod will be placed back in the queue
    to be retried at a later time.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调度周期是顺序执行的，但绑定周期可以并行执行。如果目标Pod被认为不可调度或发生内部错误，周期将被终止，Pod将被放回队列中，稍后重试。
- en: 'The scheduler is implemented using an extensible scheduler framework. The framework
    defines multiple extension points that you can plug into to affect the scheduling
    process. The following diagram shows the overall process and the extension points:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器通过可扩展的调度框架实现。该框架定义了多个扩展点，你可以插入这些扩展点来影响调度过程。下图显示了整个过程和扩展点：
- en: '![](img/B18998_15_05.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_15_05.png)'
- en: 'Figure 15.5: The workflow of the Kubernetes scheduler'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：Kubernetes调度器的工作流程
- en: The scheduler takes a tremendous amount of information and configuration into
    account. Filtering removes nodes that don’t satisfy one of the hard constraints
    from the candidate list. Ranking nodes assigns a score to each of the remaining
    nodes and chooses the best node.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器会考虑大量的信息和配置。筛选过程会将不符合硬性约束的节点从候选列表中剔除。排名节点会为剩余的节点分配分数，并选择最佳节点。
- en: 'Here are the factors the scheduler evaluates when filtering nodes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调度器在筛选节点时评估的因素：
- en: Verify that the ports requested by the pod are available on the node, ensuring
    the required network connectivity.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Pod请求的端口是否在节点上可用，确保所需的网络连接。
- en: Ensure that the pod is scheduled on a node whose hostname matches the specified
    node preference.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保Pod调度到主机名与指定节点偏好匹配的节点上。
- en: Validate the availability of requested resources (CPU and memory) on the node
    to meet the pod’s requirements.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证节点上请求的资源（CPU和内存）是否可用，以满足Pod的需求。
- en: Match the node’s labels with the pod’s node selector or node affinity to ensure
    proper scheduling.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将节点的标签与Pod的节点选择器或节点亲和性匹配，以确保正确的调度。
- en: Confirm that the node supports the requested volume types, considering any failure
    zone restrictions for storage.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认节点支持请求的卷类型，考虑存储的故障域限制。
- en: Evaluate the node’s capacity to accommodate the pod’s volume requests, accounting
    for existing mounted volumes.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估节点是否有能力容纳Pod的卷请求，并考虑现有的挂载卷。
- en: Ensure the node’s health by checking for indicators such as memory pressure
    or PID pressure.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过检查内存压力或PID压力等指标来确保节点的健康。
- en: Evaluate the pod’s tolerations to determine compatibility with the node’s taints,
    enabling or restricting scheduling accordingly.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估Pod的容忍度，以确定与节点的污点兼容性，从而相应地启用或限制调度。
- en: 'Once the nodes have been filtered, the scheduler will score the modes based
    on the following policies (which you can configure):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点被筛选，调度器将根据以下策略对节点进行评分（你可以配置这些策略）：
- en: Distribute pods across hosts while considering pods belonging to the same Service,
    StatefulSet, or ReplicaSet.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分配Pod时考虑将Pod分布在主机之间，同时考虑属于同一服务、StatefulSet或ReplicaSet的Pod。
- en: Give priority to inter-pod affinity, which means favoring pods that have an
    affinity or preference for running on the same node.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先考虑Pod间的亲和性，即偏好那些倾向于在同一节点上运行的Pod。
- en: Apply the “Least requested” priority, which favors nodes with fewer requested
    resources. This policy aims to distribute pods across all nodes in the cluster.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用“最少请求”优先级，偏向那些请求资源较少的节点。这一策略旨在将Pod均匀分布到集群中的所有节点。
- en: Apply the “Most requested” priority, which favors nodes with the highest requested
    resources. This policy tends to pack pods into a smaller set of nodes.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用“最请求”优先级，优先选择请求资源最多的节点。这项策略通常会将 Pods 集中到较少的节点上。
- en: Use the “Requested to capacity ratio” priority, which calculates a priority
    based on the ratio of requested resources to the node’s capacity. It uses a default
    resource scoring function shape.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“请求与容量比”优先级，该优先级根据请求资源与节点容量的比例计算优先级。它使用默认的资源评分函数形状。
- en: Prioritize nodes with balanced resource allocation, favoring nodes with balanced
    resource usage.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择资源分配均衡的节点，偏向于资源使用均衡的节点。
- en: Utilize the “Node prefer avoid pods” priority, which prioritizes nodes based
    on the node annotation `scheduler.alpha.kubernetes.io/preferAvoidPods`. This annotation
    is used to indicate that two different pods should not run on the same node.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用“节点偏好避免 Pods”优先级，该优先级根据节点注解 `scheduler.alpha.kubernetes.io/preferAvoidPods`
    优先选择节点。此注解用于指示两个不同的 Pods 不应在同一个节点上运行。
- en: Apply node affinity priority, giving preference to nodes based on the node affinity
    scheduling preferences specified in `PreferredDuringSchedulingIgnoredDuringExecution`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用节点亲和性优先级，根据 `PreferredDuringSchedulingIgnoredDuringExecution` 中指定的节点亲和性调度偏好，优先选择节点。
- en: Consider taint toleration priority, preparing a priority list for all nodes
    based on the number of intolerable taints on each node. This policy adjusts a
    node’s rank, taking taints into account.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑污点容忍优先级，根据每个节点上不可容忍污点的数量为所有节点准备优先级列表。这项策略会调整节点的排名，考虑污点因素。
- en: Give priority to nodes that already have the container images required by the
    pod using the “Image locality” priority.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“镜像本地性”优先级，优先选择那些已经包含 Pod 所需容器镜像的节点。
- en: Prioritize spreading pods backing a service across different nodes with the
    “Service spreading” priority.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先选择将支持服务的 Pods 分布在不同节点上的“服务分布”优先级。
- en: Apply pod anti-affinity, which means avoiding running pods on nodes that already
    have similar pods based on anti-affinity rules.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 Pod 反亲和性，这意味着根据反亲和性规则避免在已运行相似 Pod 的节点上调度 Pod。
- en: Use the “Equal priority map,” where all nodes have the same weight and there
    are no favorites or biases.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“相等优先级映射”，其中所有节点的权重相同，不存在偏爱或偏见。
- en: Check out [https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/](https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/)
    for more details.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/](https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/)
    了解更多详情。
- en: As you can see, the default scheduler is very sophisticated and can be configured
    in a very fine-grained way to accommodate most of your needs. But, under some
    circumstances, it might not be the best choice.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，默认调度器非常复杂，可以通过精细的配置来满足大多数需求。但是，在某些情况下，它可能不是最佳选择。
- en: In particular, in large clusters with many nodes (hundreds or thousands), every
    time a pod is scheduled, all the nodes need to go through this rigorous and heavyweight
    procedure of filtering and scoring. Now, consider a situation where you need to
    schedule a large number of pods at once (e.g., training machine learning models).
    This can put a lot of pressure on your cluster and lead to performance issues.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在大规模集群中，节点数量众多（数百或数千个）时，每次调度一个 Pod，所有节点都需要经历这个严格且重量级的过滤和评分过程。现在，假设你需要一次性调度大量的
    Pods（例如，训练机器学习模型）。这可能会给你的集群带来很大的压力，并导致性能问题。
- en: Kubernetes can make the filtering and scoring process more lightweight by allowing
    you to filter and score only some of the pods, but still, you may want better
    control.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过允许你仅对部分 Pods 进行过滤和评分，可以使过滤和评分过程变得更加轻量，但你仍然可能希望获得更好的控制。
- en: 'Fortunately, Kubernetes allows you to influence the scheduling process in several
    ways. Those ways include:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kubernetes 允许你通过多种方式影响调度过程。这些方式包括：
- en: Direct scheduling of pods to nodes
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Pods 直接调度到节点
- en: Replacing the scheduler with your own scheduler
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你自己的调度器替代默认调度器
- en: Extending the scheduler with additional filters
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展调度器并添加额外的过滤器
- en: Adding another scheduler that runs side by side with the default scheduler
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个与默认调度器并行运行的调度器
- en: Let’s review various methods you can use to influence pod scheduling.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你可以用来影响 Pod 调度的各种方法。
- en: Scheduling pods manually
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动调度 Pods
- en: Guess what? We can just tell Kubernetes where to place our pod when we create
    the pod. All it takes is to specify a node name in the pod’s spec and the scheduler
    will ignore it. If you think about the loosely coupled nature of the controller
    pattern, it all makes sense. The scheduler is watching for pending pods that DON’T
    have a node name assigned yet. If you are passing the node name yourself, then
    the Kubelet on the target node, which watches for pending pods that DO have a
    node name, will just go ahead and make sure to create a new pod.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？我们可以在创建 pod 时直接告诉 Kubernetes 将 pod 放置在哪个节点。只需在 pod 的 spec 中指定节点名称，调度器将忽略它。如果你考虑到控制器模式的松耦合特性，这一切都能理解。调度器会监听那些尚未分配节点名称的待处理
    pod。如果你自己传递了节点名称，那么目标节点上的 Kubelet 将会确保创建一个新的 pod。
- en: 'Let’s look at the nodes of our k3d cluster:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的 k3d 集群的节点：
- en: '[PRE59]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'apiVersion: v1'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: v1'
- en: 'kind: Pod'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: Pod'
- en: 'metadata:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: some-pod-manual-scheduling'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'name: some-pod-manual-scheduling'
- en: 'spec:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'containers:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'containers:'
- en: '- name: some-container'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- name: some-container'
- en: 'image: registry.k8s.io/pause:3.8'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'image: registry.k8s.io/pause:3.8'
- en: 'nodeName: k3d-k3s-default-agent-1'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'nodeName: k3d-k3s-default-agent-1'
- en: 'schedulerName: no-such-scheduler'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'schedulerName: no-such-scheduler'
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: $ k create -f some-pod-manual-scheduling.yaml
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: $ k create -f some-pod-manual-scheduling.yaml
- en: pod/some-pod-manual-scheduling created
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: pod/some-pod-manual-scheduling 创建成功
- en: $ k get po some-pod-manual-scheduling -o wide
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: $ k get po some-pod-manual-scheduling -o wide
- en: NAME                         READY   STATUS    RESTARTS   AGE   IP            NODE                      NOMINATED
    NODE   READINESS GATES
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                         准备就绪   状态    重启次数   存活时长   IP地址         节点                      提名节点   就绪门控
- en: some-pod-manual-scheduling   1/1     Running   0          26s   10.42.2.213   k3d-k3s-default-agent-1   <none>           <none>
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: some-pod-manual-scheduling   1/1     正在运行   0          26秒   10.42.2.213   k3d-k3s-default-agent-1   <none>           <none>
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: from kubernetes import client, config, watch
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: from kubernetes import client, config, watch
- en: 'def schedule_pod(cli, name):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'def schedule_pod(cli, name):'
- en: target = client.V1ObjectReference()
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: target = client.V1ObjectReference()
- en: target.kind = 'Node'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: target.kind = 'Node'
- en: target.apiVersion = 'v1'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: target.apiVersion = 'v1'
- en: target.name = 'k3d-k3s-default-agent-0'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: target.name = 'k3d-k3s-default-agent-0'
- en: meta = client.V1ObjectMeta()
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: meta = client.V1ObjectMeta()
- en: meta.name = name
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: meta.name = name
- en: body = client.V1Binding(metadata=meta, target=target)
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: body = client.V1Binding(metadata=meta, target=target)
- en: return cli.create_namespaced_binding('default', body)
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return cli.create_namespaced_binding('default', body)
- en: 'def main():'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: config.load_kube_config()
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: config.load_kube_config()
- en: cli = client.CoreV1Api()
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cli = client.CoreV1Api()
- en: w = watch.Watch()
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: w = watch.Watch()
- en: 'for event in w.stream(cli.list_namespaced_pod, ''default''):'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'for event in w.stream(cli.list_namespaced_pod, ''default''):'
- en: o = event['object']
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: o = event['object']
- en: 'if o.status.phase != ''Pending'' or o.spec.scheduler_name != ''custom-scheduler'':'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if o.status.phase != ''Pending'' or o.spec.scheduler_name != ''custom-scheduler'':'
- en: continue
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: continue
- en: schedule_pod(cli, o.metadata.name)
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: schedule_pod(cli, o.metadata.name)
- en: 'if __name__ == ''__main__'':'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: main()
- en: '[PRE63]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'if o.status.phase != ''Pending'' or o.spec.scheduler_name != ''custom-scheduler'':'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'if o.status.phase != ''Pending'' or o.spec.scheduler_name != ''custom-scheduler'':'
- en: continue
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: continue
- en: '[PRE64]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'apiVersion: v1'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: v1'
- en: 'kind: Pod'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: Pod'
- en: 'metadata:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: some-pod-with-custom-scheduler'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: some-pod-with-custom-scheduler'
- en: 'spec:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'containers:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 'containers:'
- en: '- name: some-container'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- name: some-container'
- en: 'image: registry.k8s.io/pause:3.8'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'image: registry.k8s.io/pause:3.8'
- en: 'schedulerName: custom-scheduler'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'schedulerName: custom-scheduler'
- en: '[PRE65]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: $ k create -f some-pod-with-custom-scheduler.yaml
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: $ k create -f some-pod-with-custom-scheduler.yaml
- en: pod/some-pod-with-custom-scheduler created
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: pod/some-pod-with-custom-scheduler 创建成功
- en: $ k get po
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: $ k get po
- en: NAME                             READY   STATUS    RESTARTS   AGE
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                             准备就绪   状态    重启次数   存活时长
- en: some-pod-manual-scheduling       1/1     Running   0          9m33s
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: some-pod-manual-scheduling       1/1     正在运行   0          9分钟33秒
- en: some-pod-with-custom-scheduler   0/1     Pending   0          14s
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: some-pod-with-custom-scheduler   0/1     待处理   0          14秒
- en: '[PRE66]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: python custom_scheduler.py
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: python custom_scheduler.py
- en: Waiting for pending pods...
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 等待待处理的 pod...
- en: 'Scheduling pod: some-pod-with-custom-scheduler'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '正在调度 pod: some-pod-with-custom-scheduler'
- en: '[PRE67]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: $ k get po -o wide
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: $ k get po -o wide
- en: NAME                             READY   STATUS    RESTARTS   AGE    IP            NODE                      NOMINATED
    NODE   READINESS GATES
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                             准备就绪   状态    重启次数   存活时长   IP地址         节点                      提名节点   就绪门控
- en: some-pod-manual-scheduling       1/1     Running   0          4h5m   10.42.2.213   k3d-k3s-default-agent-1   <none>           <none>
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: some-pod-manual-scheduling       1/1     正在运行   0          4小时5分钟   10.42.2.213   k3d-k3s-default-agent-1   <none>           <none>
- en: some-pod-with-custom-scheduler   1/1     Running   0          87s    10.42.0.125   k3d-k3s-default-agent-0   <none>           <none>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: some-pod-with-custom-scheduler   1/1     正在运行   0          87秒   10.42.0.125   k3d-k3s-default-agent-0   <none>           <none>
- en: '[PRE68]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: $ k krew
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: $ k krew
- en: krew is the kubectl plugin manager.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: krew 是 kubectl 插件管理器。
- en: 'You can invoke krew through kubectl: "kubectl krew [command]..."'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 kubectl 调用 krew：“kubectl krew [命令]...”
- en: 'Usage:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'Usage:'
- en: kubectl krew [command]
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl krew [命令]
- en: 'Available Commands:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 可用命令：
- en: completion  generate the autocompletion script for the specified shell
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: completion  为指定的 shell 生成自动补全脚本
- en: help        Help about any command
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: help        获取关于任何命令的帮助
- en: index       Manage custom plugin indexes
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: index       管理自定义插件索引
- en: info        Show information about an available plugin
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: info        显示可用插件的信息
- en: install     Install kubectl plugins
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: install     安装 kubectl 插件
- en: list        List installed kubectl plugins
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: list        列出已安装的 kubectl 插件
- en: search      Discover kubectl plugins
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: search      查找 kubectl 插件
- en: uninstall   Uninstall plugins
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: uninstall   卸载插件
- en: update      Update the local copy of the plugin index
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: update      更新插件索引的本地副本
- en: upgrade     Upgrade installed plugins to newer versions
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: upgrade     升级已安装的插件到更新版本
- en: version     Show krew version and diagnostics
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: version     显示 krew 版本和诊断信息
- en: 'Flags:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 'Flags:'
- en: -h, --help      help for krew
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: -h, --help      获取 krew 帮助
- en: -v, --v Level   number for the log level verbosity
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: -v, --v Level   日志级别的数字
- en: Use "kubectl krew [command] --help" for more information about a command.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 "kubectl krew [命令] --help" 获取更多关于某个命令的信息。
- en: '[PRE69]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: $ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: $ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io
- en: aks-centralus-cluster-001-nodepool001         116d
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-001-nodepool001         116d
- en: aks-centralus-cluster-001-nodepool002         116d
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-001-nodepool002         116d
- en: aks-centralus-cluster-002-nodepool001         139d
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-002-nodepool001         139d
- en: aks-centralus-cluster-002-nodepool002         139d
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-002-nodepool002         139d
- en: aks-centralus-cluster-002-nodepool003         139d
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-002-nodepool003         139d
- en: '...'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE70]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: $ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io
    -o custom-columns=NAME:.metadata.name,SKU:.spec.sku,VERSION:.status.version,NODES:.status.replicas
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: $ k get -n cluster-registry azuremanagedmachinepools.infrastructure.cluster.x-k8s.io
    -o custom-columns=NAME:.metadata.name,SKU:.spec.sku,VERSION:.status.version,NODES:.status.replicas
- en: NAME                                    SKU                 VERSION   NODES
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: NAME                                    SKU                 VERSION   NODES
- en: aks-centralus-cluster-001-nodepool001   Standard_D4s_v4     1.23.8    10
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-001-nodepool001   Standard_D4s_v4     1.23.8    10
- en: aks-centralus-cluster-001-nodepool002   Standard_D8s_v4     1.23.8    20
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-001-nodepool002   Standard_D8s_v4     1.23.8    20
- en: aks-centralus-cluster-002-nodepool001   Standard_D16s_v4    1.23.8    30
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-002-nodepool001   Standard_D16s_v4    1.23.8    30
- en: aks-centralus-cluster-002-nodepool002   Standard_D8ads_v5   1.23.8    40
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-002-nodepool002   Standard_D8ads_v5   1.23.8    40
- en: aks-centralus-cluster-002-nodepool003   Standard_D8ads_v5   1.23.8    50
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: aks-centralus-cluster-002-nodepool003   Standard_D8ads_v5   1.23.8    50
- en: '[PRE71]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: $ k npa get
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: $ k npa get
- en: 'Error: exec format error'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：执行格式错误
- en: '[PRE72]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: $ k get npa
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: $ k get npa
- en: 'error: the server doesn''t have a resource type "npa"'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 'error: 服务器没有资源类型 "npa"'
- en: '[PRE73]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '- --authentication-token-webhook-config-file=<authentication config file>'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '- --authentication-token-webhook-config-file=<身份验证配置文件>'
- en: '- --authentication-token-webhook-cache-ttl (how long to cache auth decisions,
    default to 2 minutes)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '- --authentication-token-webhook-cache-ttl（缓存身份验证决策的时间，默认2分钟）'
- en: '[PRE74]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Kubernetes API version
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes API 版本
- en: 'apiVersion: v1'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: v1'
- en: kind of the API object
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 对象的类型
- en: 'kind: Config'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: Config'
- en: clusters refers to the remote service.
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: clusters 指的是远程服务。
- en: 'clusters:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 'clusters:'
- en: '- name: name-of-remote-authn-service'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '- name: name-of-remote-authn-service'
- en: 'cluster:'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'cluster:'
- en: 'certificate-authority: /path/to/ca.pem         # CA for verifying the remote
    service.'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'certificate-authority: /path/to/ca.pem         # 用于验证远程服务的 CA'
- en: 'server: https://authn.example.com/authenticate # URL of remote service to query.
    Must use ''https''.'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'server: https://authn.example.com/authenticate # 远程服务查询的 URL。必须使用 ''https''。'
- en: users refers to the API server's webhook configuration.
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: users 指的是 API 服务器的 webhook 配置。
- en: 'users:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 'users:'
- en: '- name: name-of-api-server'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '- name: name-of-api-server'
- en: 'user:'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'user:'
- en: 'client-certificate: /path/to/cert.pem # cert for the webhook plugin to use'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'client-certificate: /path/to/cert.pem # 用于 webhook 插件的证书'
- en: 'client-key: /path/to/key.pem          # key matching the cert'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'client-key: /path/to/key.pem          # 与证书匹配的密钥'
- en: kubeconfig files require a context. Provide one for the API server.
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubeconfig 文件需要一个上下文。为 API 服务器提供一个。
- en: 'current-context: webhook'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 'current-context: webhook'
- en: 'contexts:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 'contexts:'
- en: '- context:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '- context:'
- en: 'cluster: name-of-remote-authn-service'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'cluster: name-of-remote-authn-service'
- en: 'user: name-of-api-sever'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'user: name-of-api-sever'
- en: 'name: webhook'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: webhook'
- en: '[PRE75]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '{'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "authentication.k8s.io/v1",'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "authentication.k8s.io/v1",'
- en: '"kind": "TokenReview",'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "TokenReview",'
- en: '"spec": {'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '"spec": {'
- en: '"token": "<bearer token from original request headers>"'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"token": "<来自原始请求头的 bearer token>"'
- en: '}'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE76]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '{'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "authentication.k8s.io/v1",'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "authentication.k8s.io/v1",'
- en: '"kind": "TokenReview",'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "TokenReview",'
- en: '"status": {'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '"status": {'
- en: '"authenticated": true,'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"authenticated": true,'
- en: '"user": {'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"user": {'
- en: '"username": "gigi@gg.com",'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"username": "gigi@gg.com",'
- en: '"uid": "42",'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"uid": "42",'
- en: '"groups": ['
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"groups": ['
- en: '"developers",'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"developers",'
- en: '],'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '],'
- en: '"extra": {'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"extra": {'
- en: '"extrafield1": ['
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"extrafield1": ['
- en: '"extravalue1",'
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"extravalue1",'
- en: '"extravalue2"'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"extravalue2"'
- en: ']'
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE77]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '{'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "authentication.k8s.io/v1",'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "authentication.k8s.io/v1",'
- en: '"kind": "TokenReview",'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "TokenReview",'
- en: '"status": {'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '"status": {'
- en: '"authenticated": false'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"authenticated": false'
- en: '}'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE78]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: --authorization-webhook-config-file=<configuration filename>
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: --authorization-webhook-config-file=<configuration filename>
- en: '[PRE79]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '{'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "authorization.k8s.io/v1",'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "authorization.k8s.io/v1",'
- en: '"kind": "SubjectAccessReview",'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "SubjectAccessReview",'
- en: '"spec": {'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '"spec": {'
- en: '"resourceAttributes": {'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"resourceAttributes": {'
- en: '"namespace": "awesome-namespace",'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"namespace": "awesome-namespace",'
- en: '"verb": "get",'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"verb": "get",'
- en: '"group": "awesome.example.org",'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"group": "awesome.example.org",'
- en: '"resource": "pods"'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"resource": "pods"'
- en: '},'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '"user": "gigi@gg.com",'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"user": "gigi@gg.com",'
- en: '"group": ['
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"group": ['
- en: '"group1",'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"group1",'
- en: '"group2"'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"group2"'
- en: ']'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE80]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '{'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "authorization.k8s.io/v1",'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "authorization.k8s.io/v1",'
- en: '"kind": "SubjectAccessReview",'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "SubjectAccessReview",'
- en: '"status": {'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '"status": {'
- en: '"allowed": true'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"allowed": true'
- en: '}'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE81]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '{'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "authorization.k8s.io/v1beta1",'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "authorization.k8s.io/v1beta1",'
- en: '"kind": "SubjectAccessReview",'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "SubjectAccessReview",'
- en: '"status": {'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '"status": {'
- en: '"allowed": false,'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"allowed": false,'
- en: '"reason": "user does not have read access to the namespace"'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"reason": "user does not have read access to the namespace"'
- en: '}'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE82]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '{'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "authorization.k8s.io/v1",'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "authorization.k8s.io/v1",'
- en: '"kind": "SubjectAccessReview",'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "SubjectAccessReview",'
- en: '"spec": {'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '"spec": {'
- en: '"nonResourceAttributes": {'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"nonResourceAttributes": {'
- en: '"path": "/logs",'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"path": "/logs",'
- en: '"verb": "get"'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"verb": "get"'
- en: '},'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '"user": "gigi@gg.com",'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"user": "gigi@gg.com",'
- en: '"group": ['
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"group": ['
- en: '"group1",'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"group1",'
- en: '"group2"'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"group2"'
- en: ']'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE83]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: $ k auth can-i create deployments
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: $ k auth can-i create deployments
- en: 'yes'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 'yes'
- en: '[PRE84]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: $ k auth can-i create deployments --as default
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: $ k auth can-i create deployments --as default
- en: 'no'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 'no'
- en: '[PRE85]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
- en: '[PRE86]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'apiVersion: admissionregistration.k8s.io/v1'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: admissionregistration.k8s.io/v1'
- en: 'kind: ValidatingWebhookConfiguration'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: ValidatingWebhookConfiguration'
- en: '...'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'webhooks:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 'webhooks:'
- en: '- name: admission-webhook.example.com'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '- name: admission-webhook.example.com'
- en: 'rules:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 'rules:'
- en: '- operations: ["CREATE", "UPDATE"]'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '- operations: ["CREATE", "UPDATE"]'
- en: 'apiGroups: ["apps"]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'apiGroups: ["apps"]'
- en: 'apiVersions: ["v1", "v1beta1"]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'apiVersions: ["v1", "v1beta1"]'
- en: 'resources: ["deployments", "replicasets"]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'resources: ["deployments", "replicasets"]'
- en: 'scope: "Namespaced"'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'scope: "Namespaced"'
- en: '...'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE87]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '{'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "admission.k8s.io/v1",'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "admission.k8s.io/v1",'
- en: '"kind": "AdmissionReview",'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "AdmissionReview",'
- en: '"request": {'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '"request": {'
- en: '"uid": "705ab4f5-6393-11e8-b7cc-42010a800002",'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"uid": "705ab4f5-6393-11e8-b7cc-42010a800002",'
- en: '"kind": {"group":"autoscaling","version":"v1","kind":"Scale"},'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"kind": {"group":"autoscaling","version":"v1","kind":"Scale"},'
- en: '"resource": {"group":"apps","version":"v1","resource":"deployments"},'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"resource": {"group":"apps","version":"v1","resource":"deployments"},'
- en: '"subResource": "scale",'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"subResource": "scale",'
- en: '"requestKind": {"group":"autoscaling","version":"v1","kind":"Scale"},'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"requestKind": {"group":"autoscaling","version":"v1","kind":"Scale"},'
- en: '"requestResource": {"group":"apps","version":"v1","resource":"deployments"},'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"requestResource": {"group":"apps","version":"v1","resource":"deployments"},'
- en: '"requestSubResource": "scale",'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"requestSubResource": "scale",'
- en: '"name": "cool-deployment",'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"name": "cool-deployment",'
- en: '"namespace": "cool-namespace",'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"namespace": "cool-namespace",'
- en: '"operation": "UPDATE",'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"operation": "UPDATE",'
- en: '"userInfo": {'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"userInfo": {'
- en: '"username": "admin",'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"username": "admin",'
- en: '"uid": "014fbff9a07c",'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"uid": "014fbff9a07c",'
- en: '"groups": ["system:authenticated","my-admin-group"],'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"groups": ["system:authenticated","my-admin-group"],'
- en: '"extra": {'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"extra": {'
- en: '"some-key":["some-value1", "some-value2"]'
  id: totrans-620
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"some-key":["some-value1", "some-value2"]'
- en: '}'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '"object": {"apiVersion":"autoscaling/v1","kind":"Scale",...},'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"object": {"apiVersion":"autoscaling/v1","kind":"Scale",...},'
- en: '"oldObject": {"apiVersion":"autoscaling/v1","kind":"Scale",...},'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"oldObject": {"apiVersion":"autoscaling/v1","kind":"Scale",...},'
- en: '"options": {"apiVersion":"meta.k8s.io/v1","kind":"UpdateOptions",...},'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"options": {"apiVersion":"meta.k8s.io/v1","kind":"UpdateOptions",...},'
- en: '"dryRun": false'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"dryRun": false'
- en: '}'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE88]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '{'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "admission.k8s.io/v1",'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "admission.k8s.io/v1",'
- en: '"kind": "AdmissionReview",'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "AdmissionReview",'
- en: '"response": {'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '"response": {'
- en: '"uid": "<value from request.uid>",'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"uid": "<value from request.uid>",'
- en: '"allowed": true'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"allowed": true'
- en: '}'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE89]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '{'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"apiVersion": "admission.k8s.io/v1",'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "admission.k8s.io/v1",'
- en: '"kind": "AdmissionReview",'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "AdmissionReview",'
- en: '"response": {'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '"response": {'
- en: '"uid": "<value from request.uid>",'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"uid": "<value from request.uid>",'
- en: '"allowed": false,'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"allowed": false,'
- en: '"status": {'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"status": {'
- en: '"code": 403,'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"code": 403,'
- en: '"message": "You cannot do this because I say so!!!!"'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"message": "You cannot do this because I say so!!!!"'
- en: '}'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE90]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: type CustomMetricsProvider interface {
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: type CustomMetricsProvider interface {
- en: // GetRootScopedMetricByName fetches a particular metric for a particular root-scoped
    object.
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // GetRootScopedMetricByName 获取特定根范围对象的特定指标。
- en: GetRootScopedMetricByName(groupResource schema.GroupResource, name string, metricName
    string) (*custom_metrics.MetricValue, error)
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GetRootScopedMetricByName(groupResource schema.GroupResource, name string, metricName
    string) (*custom_metrics.MetricValue, error)
- en: // GetRootScopedMetricByName fetches a particular metric for a set of root-scoped
    objects
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // GetRootScopedMetricByName 获取一组根范围对象的特定指标
- en: // matching the given label selector.
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 匹配给定的标签选择器。
- en: GetRootScopedMetricBySelector(groupResource schema.GroupResource, selector labels.Selector,
    metricName string) (*custom_metrics.MetricValueList, error)
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GetRootScopedMetricBySelector(groupResource schema.GroupResource, selector labels.Selector,
    metricName string) (*custom_metrics.MetricValueList, error)
- en: // GetNamespacedMetricByName fetches a particular metric for a particular namespaced
    object.
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // GetNamespacedMetricByName 获取特定命名空间对象的特定指标。
- en: GetNamespacedMetricByName(groupResource schema.GroupResource, namespace string,
    name string, metricName string) (*custom_metrics.MetricValue, error)
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GetNamespacedMetricByName(groupResource schema.GroupResource, namespace string,
    name string, metricName string) (*custom_metrics.MetricValue, error)
- en: // GetNamespacedMetricByName fetches a particular metric for a set of namespaced
    objects
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // GetNamespacedMetricByName 获取一组命名空间对象的特定指标
- en: // matching the given label selector.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 匹配给定的标签选择器。
- en: GetNamespacedMetricBySelector(groupResource schema.GroupResource, namespace
    string, selector labels.Selector, metricName string) (*custom_metrics.MetricValueList,
    error)
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GetNamespacedMetricBySelector(groupResource schema.GroupResource, namespace
    string, selector labels.Selector, metricName string) (*custom_metrics.MetricValueList,
    error)
- en: // ListAllMetrics provides a list of all available metrics at
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ListAllMetrics 提供所有可用指标的列表
- en: // the current time. Note that this is not allowed to return
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 当前时间。请注意，不允许返回此信息
- en: // an error, so it is recommended that implementors cache and
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 一个错误，因此建议实现者缓存并
- en: // periodically update this list, instead of querying every time.
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 定期更新此列表，而不是每次查询。
- en: ListAllMetrics() []CustomMetricInfo
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ListAllMetrics() []CustomMetricInfo
- en: '}'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE91]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: service Controller {
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: service Controller {
- en: rpc CreateVolume (CreateVolumeRequest)
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: rpc CreateVolume (CreateVolumeRequest)
- en: returns (CreateVolumeResponse) {}
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (CreateVolumeResponse) {}
- en: rpc DeleteVolume (DeleteVolumeRequest)
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: rpc DeleteVolume (DeleteVolumeRequest)
- en: returns (DeleteVolumeResponse) {}
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (DeleteVolumeResponse) {}
- en: rpc ControllerPublishVolume (ControllerPublishVolumeRequest)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: rpc ControllerPublishVolume (ControllerPublishVolumeRequest)
- en: returns (ControllerPublishVolumeResponse) {}
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (ControllerPublishVolumeResponse) {}
- en: rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)
- en: returns (ControllerUnpublishVolumeResponse) {}
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (ControllerUnpublishVolumeResponse) {}
- en: rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)
- en: returns (ValidateVolumeCapabilitiesResponse) {}
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (ValidateVolumeCapabilitiesResponse) {}
- en: rpc ListVolumes (ListVolumesRequest)
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: rpc ListVolumes (ListVolumesRequest)
- en: returns (ListVolumesResponse) {}
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (ListVolumesResponse) {}
- en: rpc GetCapacity (GetCapacityRequest)
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: rpc GetCapacity (GetCapacityRequest)
- en: returns (GetCapacityResponse) {}
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (GetCapacityResponse) {}
- en: rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)
- en: returns (ControllerGetCapabilitiesResponse) {}
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: returns (ControllerGetCapabilitiesResponse) {}
- en: '}'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This is not a trivial undertaking and typically only storage solution providers
    should implement CSI plugins.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一项简单的工作，通常只有存储解决方案提供商才应该实现CSI插件。
- en: The additional extension points of custom metrics and custom storage solutions
    demonstrate the commitment of Kubernetes to being truly extensible and allowing
    its users to customize almost every aspect of its operation.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义指标和自定义存储解决方案的额外扩展点展示了Kubernetes致力于真正可扩展，并允许用户自定义其几乎所有操作方面的承诺。
- en: Summary
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: 'In this chapter, we covered three major topics: working with the Kubernetes
    API, extending the Kubernetes API, and writing Kubernetes plugins. The Kubernetes
    API supports the OpenAPI spec and is a great example of REST API design that follows
    all current best practices. It is very consistent, well organized, and well documented.
    Yet it is a big API and not easy to understand. You can access the API directly
    via REST over HTTP, using client libraries including the official Python client,
    and even by invoking kubectl programmatically.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了三个主要话题：与 Kubernetes API 的交互、扩展 Kubernetes API 和编写 Kubernetes 插件。Kubernetes
    API 支持 OpenAPI 规范，是一个很好的 REST API 设计示例，遵循了所有当前的最佳实践。它非常一致，组织良好，文档完善。然而，它是一个庞大的
    API，并不容易理解。你可以通过 HTTP 的 REST 接口直接访问 API，使用包括官方 Python 客户端在内的客户端库，甚至通过编程调用 kubectl。
- en: Extending the Kubernetes API may involve defining your own custom resources,
    writing controllers/operators, and optionally extending the API server itself
    via API aggregation.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes API 可能涉及定义自定义资源、编写控制器/操作符，并可选择通过 API 聚合来扩展 API 服务器本身。
- en: Plugins and webhooks are a foundation of Kubernetes design. Kubernetes was always
    meant to be extended by users to accommodate any needs. We looked at various plugins,
    such as custom schedulers, kubectl plugins, and access control webhooks. It is
    very cool that Kubernetes provides such a seamless experience for writing, registering,
    and integrating all those plugins.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 插件和 webhooks 是 Kubernetes 设计的基础。Kubernetes 一直旨在通过用户扩展以满足各种需求。我们查看了各种插件，如自定义调度器、kubectl
    插件和访问控制 webhooks。Kubernetes 提供了一个无缝的体验，支持编写、注册和集成所有这些插件，真是太棒了。
- en: We also looked at custom metrics and even how to extend Kubernetes with custom
    storage options.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了自定义指标，甚至讨论了如何通过自定义存储选项来扩展 Kubernetes。
- en: At this point, you should be well aware of all the major mechanisms to extend,
    customize, and control Kubernetes via API access, custom resources, controllers,
    operators, and custom plugins. You are in a great position to take advantage of
    these capabilities to augment the existing functionality of Kubernetes and adapt
    it to your needs and your systems.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该已经清楚了通过 API 访问、自定义资源、控制器、操作符和自定义插件扩展、定制和控制 Kubernetes 的所有主要机制。你已经处于一个非常有利的位置，可以利用这些能力来增强
    Kubernetes 的现有功能，并根据你的需求和系统进行调整。
- en: In the next chapter, we will look at governing Kubernetes via policy engines.
    This will continue the theme of extending Kubernetes as policy engines are dynamic
    admission controllers on steroids. We will cover what governance is all about,
    review existing policy engines, and dive deep into Kyverno, which is the best
    policy engine for Kubernetes in my opinion.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过策略引擎管理 Kubernetes。这将继续扩展 Kubernetes 的主题，因为策略引擎是增强版的动态准入控制器。我们将介绍治理的概念，回顾现有的策略引擎，并深入分析
    Kyverno，它是我认为最适合 Kubernetes 的策略引擎。
