- en: Cluster Authentication, Authorization, and Container Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群认证、授权和容器安全
- en: This chapter will discuss the basics of container security from the container
    runtime level to the host itself. We will discuss how to apply these concepts
    to workloads running in a Kubernetes cluster and some of the security concerns
    and practices that relate specifically to running your Kubernetes cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论容器安全的基础知识，从容器运行时级别到主机本身。我们将讨论如何将这些概念应用到Kubernetes集群中运行的工作负载，并探讨一些与运行Kubernetes集群相关的安全问题和实践。
- en: 'This chapter will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: Basic container security
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本容器安全
- en: Container image security and continuous vulnerability scanning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像安全与持续漏洞扫描
- en: Kubernetes cluster security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes集群安全
- en: Kubernetes secrets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes secrets
- en: Basics of container security
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器安全基础
- en: Container security is a deep subject area and in itself can fill its own book.
    Having said this, we will cover some of the high-level concerns and give you a
    starting point so that you can start thinking about this area.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器安全是一个深奥的领域，本身就可以写成一本书。话虽如此，我们将覆盖一些高层次的关注点，并为你提供一个起点，让你开始思考这个领域。
- en: In the *A brief overview of containers* section of Chapter 1*, Introduction
    to Kubernetes*, we looked at some of the core isolation features in the Linux
    kernel that enable container technology. Understanding the details of how containers
    work is the key to grasping the various security concerns in managing them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*Kubernetes简介*中的*容器简要概述*部分，我们查看了Linux内核中一些核心的隔离功能，这些功能使容器技术成为可能。理解容器如何工作是掌握管理容器时各种安全问题的关键。
- en: A good paper to dive deeper is *NCC's Whitepaper*, *Understanding and Hardening
    Linux Containers*. In *section 7*, the paper explores the various attack vectors
    of concern for container deployments, which I will summarize.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨的好资料是*NCC的白皮书*，*理解与强化Linux容器*。在*第7节*，该论文探讨了容器部署中各种攻击向量的关注点，我将在此进行总结。
- en: Keeping containers contained
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持容器隔离
- en: One of the most obvious features that is discussed in the paper we mentioned
    in the preceding section is that of escaping the isolation/virtualization of the
    container construct. Modern container implementations guard against using namespaces
    to isolate processes as well as allowing the control of Linux capabilities that
    are available to a container. Additionally, there is an increased move toward
    secure default configurations of the out-of-the-box container environment. For
    example, by default, Docker only enables a small set of capabilities. Networking
    is another avenue of escape and it can be challenging since there are a variety
    of network options that plug into most modern container setups.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节提到的论文中，讨论的最明显的一个特性是逃脱容器隔离/虚拟化的构造。现代容器实现通过使用命名空间来隔离进程，并允许控制容器可用的Linux功能，从而防止此类逃脱。此外，越来越多地采用对容器环境的安全默认配置。例如，Docker默认只启用一小部分功能。网络也是逃脱的一个途径，由于大多数现代容器设置中有多种网络选项，这可能会非常具有挑战性。
- en: The next area discussed in the paper is that of attacks between two containers.
    The *User* namespace model gives us added protection here by mapping the root
    user within the container to a lower-level user on the host machine. Networking
    is, of course, still an issue, and something that requires proper diligence and
    attention when selecting and implementing your container networking solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 论文中讨论的下一个领域是两个容器之间的攻击。*用户*命名空间模型在这里为我们提供了额外的保护，通过将容器内的root用户映射到主机机器上的低权限用户。网络仍然是一个问题，这需要在选择和实施容器网络解决方案时进行适当的谨慎和关注。
- en: Attacks within the container itself are another vector and, as with previous
    concerns, namespaces and networking are key to protection here. Another aspect
    that is vital in this scenario is the application security itself. The code still
    needs to follow secure coding practices and the software should be kept up to
    date and patched regularly. Finally, the efficiency of container images has an
    added benefit of shrinking the attack surface. The images should be built with
    only the packages and software that's necessary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内部的攻击是另一种攻击向量，和之前的关注点一样，命名空间和网络在这里是保护的关键。另一个至关重要的方面是应用程序安全。代码仍然需要遵循安全编码实践，并且软件应该保持最新并定期打补丁。最后，容器镜像的高效性有一个附加好处——减少攻击面。镜像应当仅包含必要的包和软件。
- en: Resource exhaustion and orchestration security
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源耗尽和调度安全
- en: Similar to the **denial-of-service** (**DoS**) attacks, we've seen in various
    other areas of computing that resource exhaustion is very much a pertinent concern
    in the container world. While cgroups provide some limitations on resource usage
    for things such as CPU, memory, and disk usage, there are still valid attack avenues
    for resource exhaustion. Tools such as Docker offer some starting defaults to
    the cgroups limitations, and Kubernetes also offers additional limits that can
    be placed on groups of containers running in the cluster. It's important to understand
    these defaults and to adjust for your deployments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于**拒绝服务**（**DoS**）攻击，我们在计算领域的其他方面也见过资源耗尽的现象，这在容器世界中同样是一个重要问题。虽然cgroups在CPU、内存和磁盘使用等资源上提供了一些限制，但资源耗尽仍然是一个有效的攻击途径。像Docker这样的工具提供了对cgroups限制的默认设置，而Kubernetes也提供了可以施加在集群中容器组上的额外限制。理解这些默认设置并根据你的部署进行调整非常重要。
- en: While the Linux kernel and the features that enable containers give us some
    form of isolation, they are fairly new to the Linux operating system. As such,
    they still contain their own bugs and vulnerabilities. The built-in mechanisms
    for capabilities and namespaces can and do have issues, and it is important to
    track these as part of your secure container operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Linux内核和支持容器的特性为我们提供了一定程度的隔离，但它们对于Linux操作系统来说还是相对较新的功能。因此，它们仍然存在一些自身的漏洞和缺陷。内置的能力和命名空间机制可能存在问题，并且这些问题在进行安全容器操作时需要被追踪。
- en: The final area covered in the NCC paper is the attack of the container management
    layer itself. The Docker engine, image repositories, and orchestration tools are
    all significant vectors of attack and should be considered when developing your
    strategy. We'll look in more depth at how we can address the repositories and
    Kubernetes as an orchestration layer in the following sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: NCC文档中最后提到的一个领域是容器管理层本身的攻击。Docker引擎、镜像仓库和调度工具都是重要的攻击载体，在制定策略时应考虑到这些因素。我们将在接下来的章节中更深入地讨论如何解决仓库和Kubernetes作为调度层的问题。
- en: If you're interested in knowing more about the specific security features of
    Docker's implementation, take a look here: [https://docs.docker.com/engine/security/security/](https://docs.docker.com/engine/security/security/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解更多关于Docker实现的具体安全特性，可以查看这里：[https://docs.docker.com/engine/security/security/](https://docs.docker.com/engine/security/security/)。
- en: Image repositories
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像仓库
- en: Vulnerability management is a critical component of any modern day IT operation.
    Zero-day vulnerabilities are on the rise and even those vulnerabilities with patches
    can be cumbersome to remediate. First, application owners must be made aware of
    their vulnerabilities and potential patches. Then, these patches must be integrated
    into systems and code, and often this requires additional deployments or maintenance
    windows. Even when there is visibility to vulnerabilities, there is often a lag
    in remediation, often taking large organizations several months to patch.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞管理是任何现代IT操作的关键组成部分。零日漏洞在不断增加，即使是有补丁的漏洞，修复起来也可能相当繁琐。首先，应用程序的所有者必须了解他们的漏洞和潜在的修复措施。然后，这些补丁必须集成到系统和代码中，通常这需要额外的部署或维护窗口。即使有漏洞的可视化，修复通常也会滞后，通常需要大型组织几个月的时间才能进行修补。
- en: While containers greatly improve the process of updating applications and minimizing
    downtime, there still remains a challenge that's inherent in vulnerability management.
    Especially since an attacker only needs to expose one such vulnerability, making
    anything less than 100% of the systems patched is a risk of compromise.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器极大地改善了应用程序更新和减少停机时间的过程，但在漏洞管理方面仍然存在一个固有的挑战。特别是因为攻击者只需暴露一个这样的漏洞，因此任何不到100%的系统修补都可能存在被攻破的风险。
- en: What's needed is a faster feedback loop in addressing vulnerabilities. Continuous
    scanning and tying into the software deployment life cycle is key to speeding
    up the information and remediation of vulnerabilities. Luckily, this is exactly
    the approach that's being built into the latest container management and security
    tooling.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的是一个更快速的反馈循环来解决漏洞问题。持续扫描并与软件部署生命周期紧密结合，是加速漏洞信息处理和修复的关键。幸运的是，这正是最新的容器管理和安全工具中正在构建的方法。
- en: Continuous vulnerability scanning
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续的漏洞扫描
- en: One such open source project that has emerged in this space is **clair**. clair
    is an open source project for the static analysis of vulnerabilities in appc ([https://github.com/appc/spec](https://github.com/appc/spec))
    and Docker ([https://github.com/moby/moby/blob/master/image/spec/v1.md](https://github.com/moby/moby/blob/master/image/spec/v1.md))
    containers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在这一领域出现的开源项目是 **clair**。clair 是一个用于静态分析 appc ([https://github.com/appc/spec](https://github.com/appc/spec))
    和 Docker ([https://github.com/moby/moby/blob/master/image/spec/v1.md](https://github.com/moby/moby/blob/master/image/spec/v1.md))
    容器漏洞的开源项目。
- en: You can visit clair at the following link: [https://github.com/coreos/clair](https://github.com/coreos/clair).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接访问 clair：[https://github.com/coreos/clair](https://github.com/coreos/clair)。
- en: clair scans your code against **Common Vulnerabilities and Exploits** (**CVEs**).
    It can be integrated into your CI/CD pipeline and run as a response to new builds.
    If vulnerabilities are found, they can be taken as feedback into the pipeline,
    even stop deployment, and fail the build. This forces developers to be aware of
    and remediate vulnerabilities during their normal release process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: clair 会扫描你的代码以检查 **常见漏洞和暴露** (**CVE**) 。它可以集成到你的 CI/CD 管道中，并在新的构建响应时运行。如果发现漏洞，可以作为反馈进入管道，甚至停止部署并使构建失败。这迫使开发人员在正常发布过程中意识到并修复漏洞。
- en: clair can be integrated with a number of container image repositories and CI/CD
    pipelines.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: clair 可以与多个容器镜像仓库和 CI/CD 管道集成。
- en: clair can even be deployed on Kubernetes: [https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm](https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: clair 甚至可以在 Kubernetes 上部署：[https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm](https://github.com/coreos/clair/blob/master/Documentation/running-clair.md#kubernetes-helm)。
- en: clair is also used as the scanning mechanism in CoreOS's Quay image repository.
    Quay offers a number of enterprise features, including continuous vulnerability
    scanning ([https://quay.io/](https://quay.io/)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: clair 也被用作 CoreOS 的 Quay 镜像仓库中的扫描机制。Quay 提供了许多企业功能，包括持续漏洞扫描 ([https://quay.io/](https://quay.io/))。
- en: Both Docker Hub and Docker Cloud support security scanning. Again, containers
    that are pushed to the repository are automatically scanned against CVEs, and
    notifications of vulnerabilities are sent as a result of any findings. Additionally,
    binary analysis of the code is performed to match the signature of the components
    with that of known versions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 和 Docker Cloud 都支持安全扫描。同样，推送到仓库的容器会自动扫描 CVE，并在发现漏洞时发送通知。此外，还会对代码进行二进制分析，匹配组件的签名与已知版本的签名。
- en: There are a variety of other scanning tools that can be used as well for scanning
    your image repositories, including OpenSCAP, Twistlock, Aqua Sec, and many more.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他扫描工具也可以用来扫描你的镜像仓库，包括 OpenSCAP、Twistlock、Aqua Sec 等等。
- en: Image signing and verification
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像签名与验证
- en: Whether you are using a private image repository in-house or a public repository
    such as Docker Hub, it's important to know that you are only running the code
    that your developers have written. The potential for malicious code or man-in-the-middle
    attacks on downloads is an important factor in protecting your container images.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在内部使用私有镜像仓库，还是使用像 Docker Hub 这样的公共仓库，了解你只运行开发人员编写的代码非常重要。恶意代码或中间人攻击下载的潜在风险，是保护容器镜像时必须考虑的重要因素。
- en: As such, both rkt and Docker support the ability to sign images and verify that
    the contents have not changed. Publishers can use keys to sign the images when
    they are pushed to the repositories, and users can verify the signature on the
    client side when downloading for use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，rkt 和 Docker 都支持签名镜像的能力，并验证内容未发生变化。发布者可以在将镜像推送到仓库时使用密钥进行签名，用户则可以在客户端下载时验证客户端的签名。
- en: 'This is from the rkt documentation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 rkt 文档的内容：
- en: <q>"Before executing a remotely fetched ACI, rkt will verify it based on attached
    signatures generated by the ACI</q> creator."
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <q>"在执行远程获取的 ACI 之前，rkt 将根据 ACI 创建者生成的附加签名对其进行验证。</q>
- en: 'For more information, visit the following links:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下链接：
- en: '[https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md](https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md](https://github.com/rkt/rkt/blob/master/Documentation/subcommands/trust.md)'
- en: '[https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md](https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md)[ ](https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md](https://github.com/rkt/rkt/blob/master/Documentation/signing-and-verification-guide.md)[ ](https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html)'
- en: 'This is from the Docker documentation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容摘自 Docker 文档：
- en: <q>"Content trust gives you the ability to verify both the integrity and the
    publisher of all the data received from a registry over any channel. "</q>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <q>“内容信任使你能够验证通过任何通道从注册中心接收到的所有数据的完整性和发布者。”</q>
- en: 'For more information, visit[https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/).
    [](https://docs.docker.com/engine/security/trust/content_trust/) This is from
    the Docker Notary GitHub page:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问[https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)。
    [](https://docs.docker.com/engine/security/trust/content_trust/) 以下内容摘自 Docker
    Notary GitHub 页面：
- en: <q>"The Notary project comprises a server and a client for running and interacting
    with trusted collections."</q>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <q>“Notary 项目包括一个服务器和一个客户端，用于运行和与受信的集合进行交互。”</q>
- en: For more information, visit [https://github.com/docker/notary](https://github.com/docker/notary).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问 [https://github.com/docker/notary](https://github.com/docker/notary)。
- en: Kubernetes cluster security
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 集群安全
- en: Kubernetes has continued to add a number of security features in their latest
    releases and has a well-rounded set of control points that can be used in your
    cluster – everything from secure node communication to pod security and even the
    storage of sensitive configuration data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在其最新版本中继续增加了许多安全功能，并拥有一套完善的控制点，可以在你的集群中使用——从安全节点通信到 pod 安全，甚至敏感配置数据的存储。
- en: Secure API calls
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全 API 调用
- en: 'During every API call, Kubernetes applies a number of security controls. This
    security life cycle is depicted here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 API 调用时，Kubernetes 都会应用一系列安全控制。这个安全生命周期如下图所示：
- en: '![](img/f03a474d-08ef-43ef-83a2-76af157b1860.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f03a474d-08ef-43ef-83a2-76af157b1860.png)'
- en: API call life cycle
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: API 调用生命周期
- en: After secure TLS communication is established, the API server runs through authorization
    and authentication. Finally, an admission controller loop is applied to the request
    before it reaches the API server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立安全的 TLS 通信后，API 服务器会经过授权和身份验证。最后，申请会在到达 API 服务器之前，经过一个入站控制器循环处理。
- en: Secure node communication
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全节点通信
- en: Kubernetes supports the use of secure communication channels between the API
    server and any client, including the nodes themselves. Whether it's a GUI or command-line
    utility such as `kubectl`, we can use certificates to communicate with the API
    server. Hence, the API server is the central interaction point for any changes
    to the cluster and is a critical component to secure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 支持在 API 服务器和任何客户端之间使用安全通信通道，包括节点本身。无论是图形界面还是像 `kubectl` 这样的命令行工具，我们都可以使用证书与
    API 服务器进行通信。因此，API 服务器是集群中任何变更的核心交互点，必须加以保护。
- en: In deployments such as GCE, the `kubelet` on each node is deployed for secure
    communication by default. This setup uses TLS bootstrapping and the new certificates'
    API to establish a secure connection with the API server using TLS client certificates
    and a **Certificate Authority** (**CA**) cluster.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCE 等部署环境中，每个节点上的 `kubelet` 默认会进行安全通信部署。此设置使用 TLS 引导和新的证书 API 来通过 TLS 客户端证书与
    API 服务器建立安全连接，并使用 **证书颁发机构** (**CA**) 集群。
- en: Authorization and authentication plugins
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权和身份验证插件
- en: The plugin mechanisms for authentication and authorization in Kubernetes are
    still being developed. They have come a long way, but still have plugins in beta
    stages and enhancements in the works. There are also third-party providers that
    integrate with the features here, so bear that in mind when building your hardening
    strategy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中用于身份验证和授权的插件机制仍在开发中。它们已经取得了很大进展，但仍有一些插件处于测试阶段，且增强功能仍在开发中。这里还有一些与这些功能集成的第三方提供商，因此在构建强化策略时请考虑到这一点。
- en: Authentication is currently supported in the form of tokens, passwords, and
    certificates, with plans to add the plugin capability at a later stage. OpenID
    Connect tokens are supported and several third-party implementations, such as
    Dex from CoreOS and user account and authentication from Cloud Foundry, are available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，认证支持令牌、密码和证书形式，并计划在后续阶段添加插件功能。支持 OpenID Connect 令牌，并且提供了几个第三方实现，如 CoreOS
    的 Dex 和 Cloud Foundry 的用户帐户和认证。
- en: Authorization already supports three modes. The **role-based access control** (**RBAC**)
    mode recently went to general availability in the 1.8 release and brings the standard
    role-based authentication model to Kubernetes. **Attribute-based access control**
    (**ABAC**) has long been supported and lets a user define privileges via attributes
    in a file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 授权目前已经支持三种模式。**基于角色的访问控制** (**RBAC**) 模式在 1.8 版本中已正式发布，并将基于角色的标准认证模型引入 Kubernetes。**基于属性的访问控制**
    (**ABAC**) 长期以来一直得到支持，并允许用户通过文件中的属性定义权限。
- en: Additionally, a Webhook mechanism is supported, which allows for integration
    with third-party authorization via REST web service calls. Finally, we have the
    new node authorization method, which grants permissions to kubelets based on the
    pods they are scheduled to run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还支持 Webhook 机制，它允许通过 REST Web 服务调用与第三方授权进行集成。最后，我们还提供了新的节点授权方法，根据节点运行的 Pods
    授予 kubelet 权限。
- en: 'You can learn more about each area at the following links:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接了解更多关于各个领域的内容：
- en: '[http://kubernetes.io/docs/admin/authorization/](http://kubernetes.io/docs/admin/authorization/)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://kubernetes.io/docs/admin/authorization/](http://kubernetes.io/docs/admin/authorization/)'
- en: '[http://kubernetes.io/docs/admin/authentication/](http://kubernetes.io/docs/admin/authentication/)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://kubernetes.io/docs/admin/authentication/](http://kubernetes.io/docs/admin/authentication/)'
- en: '[https://kubernetes.io/docs/reference/access-authn-authz/node/](https://kubernetes.io/docs/reference/access-authn-authz/node/)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/reference/access-authn-authz/node/](https://kubernetes.io/docs/reference/access-authn-authz/node/)'
- en: Admission controllers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制器
- en: Kubernetes also provides a mechanism for integrating, with additional verification
    as a final step. This could be in the form of image scanning, signature checks,
    or anything that is able to respond in the specified fashion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还提供了一种机制来集成，并以额外的验证作为最后一步。这可以采取镜像扫描、签名检查或任何能够以指定方式响应的形式。
- en: When an API call is made, the hook is called and that server can run its verification. Admission
    controllers can also be used to transform requests and add or alter the original
    request. Once the operations are run, a response is then sent back with a status
    that instructs Kubernetes to allow or deny the call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当 API 调用被发出时，钩子会被调用，服务器可以进行验证。准入控制器还可以用于转换请求，并添加或更改原始请求。一旦操作执行完毕，便会发送一个响应，指示
    Kubernetes 允许或拒绝该调用。
- en: This can be especially helpful for verifying or testing images, as we mentioned
    in the last section. The `ImagePolicyWebhook` plugin provides an admission controller
    that allows for integration with additional image inspection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所提到的，这对于验证或测试镜像尤其有帮助。`ImagePolicyWebhook` 插件提供了一种准入控制器，允许与额外的镜像检查进行集成。
- en: For more information, visit the Using Admission Controller page in the following
    documentation: [https://kubernetes.io/docs/admin/admission-controllers/](https://kubernetes.io/docs/admin/admission-controllers/).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下文档中的“使用准入控制器”页面：[https://kubernetes.io/docs/admin/admission-controllers/](https://kubernetes.io/docs/admin/admission-controllers/)。
- en: RBAC
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RBAC
- en: As mentioned earlier in this chapter, Kubernetes has now made RBAC a central
    component to authorization within the cluster. Kubernetes offers two levels for
    this kind of control. First, there is a *ClusterRole*, which provides cluster-wide
    authorization to resources. This is handy for enforcing access control across
    multiple teams, products, or to cluster-wide resources such as the underlying
    cluster nodes. Second, we have a *Role*, which simply provides access to resources
    within a specific namespace.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，Kubernetes 现在已将 RBAC 作为集群内授权的核心组件。Kubernetes 为这种控制提供了两种级别。首先是 *ClusterRole*，它提供对集群范围内资源的授权。这对于跨多个团队、产品或集群范围的资源（如底层集群节点）执行访问控制非常有用。其次是
    *Role*，它仅提供对特定命名空间内资源的访问。
- en: Once you have a role, you need a way to provide users with membership to that
    role. These are referred to as *Bindings*, and again we have *ClusterRoleBinding*
    and *RoleBinding*. As with the roles themselves, the former is meant for cluster-wide
    access and the latter is meant to apply within a specific namespace.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个角色，你需要一种方式来为用户提供该角色的成员身份。这些被称为*绑定*，我们有*ClusterRoleBinding*和*RoleBinding*。与角色本身一样，前者用于集群范围的访问，而后者则用于特定命名空间内的应用。
- en: We will not dive into the details of RBAC in this book, but it is something
    you'll want to explore as you get ready for production grade deployments. The
    *PodSecurityPolicy* discussed in the next section typically utilizes Roles and
    RoleBindings to control which policies each user has access to.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会深入讲解RBAC的细节，但这是你在准备生产环境部署时需要探索的内容。下一节中讨论的*PodSecurityPolicy*通常利用Roles和RoleBindings来控制每个用户可以访问哪些策略。
- en: For more information, please refer to the documentation here: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅此文档：[https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)。
- en: Pod security policies and context
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod安全策略和上下文
- en: One of the latest additions to the Kubernetes' security arsenal is that of pod
    security policies and contexts. These allow users to control users and groups
    for container processes and attached volumes, limit the use of host networks or
    namespaces, and even set the root filesystem to read-only. Additionally, we can
    limit the capabilities available and also set SELinux options for the labels that
    are applied to the containers in each pod.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes安全工具包中的最新功能之一是Pod安全策略和上下文。这些功能允许用户控制容器进程和附加卷的用户和组，限制使用主机网络或命名空间，甚至将根文件系统设置为只读。此外，我们还可以限制可用的功能，并为每个Pod中容器应用的标签设置SELinux选项。
- en: In addition to SELinux, Kubernetes also added beta support for using AppArmor
    with your pods by using annotations. For more information, refer to the following
    documentation page: [https://kubernetes.io/docs/admin/apparmor/](https://kubernetes.io/docs/admin/apparmor/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SELinux，Kubernetes还通过注释增加了对在Pod中使用AppArmor的beta支持。有关更多信息，请参考以下文档页面：[https://kubernetes.io/docs/admin/apparmor/](https://kubernetes.io/docs/admin/apparmor/)。
- en: 'PodSecurityPolicies are enforced using the admission controller we spoke of
    earlier in this book. By default, Kubernetes doesn''t enable PodSecurityPolicy,
    so if you have a GKE cluster running, you can try the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: PodSecurityPolicies是通过我们在本书中早些时候提到的准入控制器来强制执行的。默认情况下，Kubernetes并没有启用PodSecurityPolicy，因此，如果你有一个正在运行的GKE集群，你可以尝试以下操作：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should see `'No resources found.'`, assuming you haven't enabled them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`'No resources found.'`，假设你还没有启用它们。
- en: 'Let''s try an example by using the Docker image from our previous chapters.
    If we use the following `run` command on a cluster with no PodSecurityPolicy applied,
    it will happily run:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用前几章中的Docker镜像来尝试一个示例。如果我们在没有应用PodSecurityPolicy的集群上使用以下`run`命令，它将顺利运行：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Follow this with `kubectl get pods` and in a minute or so we should see a pod
    starting with `myroottest` in the listings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`kubectl get pods`命令，过一分钟左右，我们应该能在列表中看到以`myroottest`开头的Pod。
- en: 'Go ahead and clean this up with the following code before proceeding:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请使用以下代码清理一下：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Enabling PodSecurityPolicies
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用PodSecurityPolicies
- en: 'Now, let''s try this with a cluster that can utilize PodSecurityPolicies. If
    you are using GKE, it is quite easy to create a cluster with PodSecurityPolicy
    enabled. Note you will need the Beta APIs enabled for this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个可以利用PodSecurityPolicies的集群上尝试。如果你使用的是GKE，创建一个启用了PodSecurityPolicy的集群非常简单。请注意，你需要启用Beta
    API：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you have an existing GKE cluster, you can enable it with a command similar
    to the preceding one. Simply replace the `create` keyword with `update`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个现有的GKE集群，你可以使用类似于前面命令的方式启用它。只需将`create`关键字替换为`update`。
- en: For clusters created with `kube-up`, like we saw in [Chapter 1](446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml),
    *Introduction to Kubernetes*, you'll need to enable the admission controller on
    the API server. Take a look here for more information: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `kube-up` 创建的集群，像我们在[第 1 章](446f901d-70fa-4ebe-be8a-0de14248f99c.xhtml)《Kubernetes
    入门》中看到的那样，*Kubernetes*，您需要在 API 服务器上启用准入控制器。查看此处以获取更多信息：[https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies)。
- en: 'Once you have PodSecurityPolicy enabled, you can see the applied policies by
    using the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用 PodSecurityPolicy，您可以使用以下代码查看已应用的策略：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/79bea3b7-c4ae-4451-b9d4-978f07e1cf44.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79bea3b7-c4ae-4451-b9d4-978f07e1cf44.jpg)'
- en: GKE default pod security policies
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: GKE 默认的 Pod 安全策略
- en: 'You''ll notice a few predefined policies that GKE has already defined. You
    can explore the details and the YAML used to create these policies with the following
    code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到 GKE 已经定义了一些预定义的策略。您可以使用以下代码探索这些策略的详细信息及其用于创建这些策略的 YAML 文件：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's important to note that PodSecurityPolicies work with the RBAC features
    of Kubernetes. There are a few default roles, role bindings, and namespaces that
    are defined by GKE. As such, we will see different behaviors based on how we interact
    with Kubernetes. For example, by using `kubectl` in a GCloud Shell, you may be
    sending commands as a cluster admin and therefore have access to all policies,
    including `gce.privileged`. However, using the `kubectl run` command, as we did
    previously, will invoke the pods through the kube-controller-manager, which will
    be restricted to the policies bound to its role. Thus, if you simply create a
    pod with `kubectl`, it will create it without an issue, but by using the `run`
    command, we will be restricted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，PodSecurityPolicies 与 Kubernetes 的 RBAC 功能协同工作。GKE 定义了一些默认角色、角色绑定和命名空间。因此，我们在与
    Kubernetes 交互时会看到不同的行为。例如，在 GCloud Shell 中使用`kubectl`时，您可能以集群管理员身份发送命令，因此可以访问所有策略，包括
    `gce.privileged`。然而，使用之前的`kubectl run`命令会通过 kube-controller-manager 调用 Pods，这将受到绑定到其角色的策略的限制。因此，如果您仅使用
    `kubectl` 创建一个 Pod，它将顺利创建，但通过使用 `run` 命令时，我们将受到限制。
- en: 'Sticking to our previous method of using `kubectl run`, let''s try the same
    deployment as the preceding one:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用我们之前的 `kubectl run` 方法，让我们尝试与前述相同的部署：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, if we follow this with `kubectl get pods`, we won''t see any pods prefaced
    with `myroottest`. We can dig a bit deeper by describing our deployment:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们接着使用`kubectl get pods`，将不会看到任何以`myroottest`为前缀的 Pods。我们可以通过描述我们的部署进一步调查：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By using the name of the replica set listed in the output from the preceding
    command, we can then get the details on the failure. Run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前述命令输出中列出的副本集名称，我们可以获取失败的详细信息。运行以下命令：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Under the events at the bottom, you will see the following pod security policy
    validation error:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部的事件下，您将看到以下 Pod 安全策略验证错误：
- en: '![](img/916c02b0-331a-4e10-a10c-097fb49138ed.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/916c02b0-331a-4e10-a10c-097fb49138ed.jpg)'
- en: Replica set pod security policy validation error
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Replica set Pod 安全策略验证错误
- en: Again, because the `run` command uses the controller manager and that role has
    no bindings that allow the use of the existing **PodSecurityPolicies**, we are
    unable to run any pods.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，因为`run`命令使用了控制器管理器，而该角色没有绑定允许使用现有**PodSecurityPolicies**，所以我们无法运行任何 Pods。
- en: Understanding that running containers securely is not merely the task of administrators
    adding constraints is important. The work must be done in collaboration with developers,
    who will properly create the images.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理解安全地运行容器不仅仅是管理员添加约束的任务非常重要。必须与开发人员合作，确保他们正确地创建镜像。
- en: 'You can find all of the possible parameters for PodSecurityPolicies in the
    source code, but I''ve created the following table for convenience. You can find
    more handy lookups like this on my new site, [http://www.kubesheets.com](http://www.kubesheets.com):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在源代码中找到所有 PodSecurityPolicies 的可能参数，但为了方便起见，我已创建以下表格。您可以在我的新站点 [http://www.kubesheets.com](http://www.kubesheets.com)
    上找到更多这样的实用查询：
- en: '| **Parameter** | **Type** | **Description** | **Required** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **类型** | **描述** | **是否必需** |'
- en: '| `Privileged` | `bool` | Allows or disallows running a pod as privileged.
    | No |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Privileged` | `bool` | 允许或禁止以特权模式运行 Pod。 | 否 |'
- en: '| `DefaultAddCapabilities` | `[]v1.Capaility` | This defines a default set
    of capabilities that are added to the container. If the pod specifies a capability
    drop that will override, then add it here. Values are strings of POSIX capabilities
    minus the leading `CAP_`. For example, `CAP_SETUID` would be `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
    | No |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `DefaultAddCapabilities` | `[]v1.Capaility` | 定义一个默认的能力集，这些能力会添加到容器中。如果 pod
    指定了丢弃的能力集，这里添加的能力将被覆盖。值是 POSIX 能力的字符串，去掉前缀 `CAP_`。例如，`CAP_SETUID` 应为 `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html))。
    | 否 |'
- en: '| `RequiredDropCapabilities` | `[]v1.Capaility` | This defines a set of capabilities
    that must be dropped from a container. The pod cannot specify any of these capabilities.Values
    are strings of POSIX capabilities minus the leading `CAP_`. For example, `CAP_SETUID`
    would be `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
    | No |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `RequiredDropCapabilities` | `[]v1.Capaility` | 定义一个必须从容器中丢弃的能力集。Pod 不能指定这些能力中的任何一个。值是
    POSIX 能力的字符串，去掉前缀 `CAP_`。例如，`CAP_SETUID` 应为 `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html))。
    | 否 |'
- en: '| `AllowedCapabilities` | `[]v1.Capaility` | This defines a set of capabilities
    that are allowed and can be added to a container. The pod can specify any of these
    capabilities.Values are strings of POSIX capabilities minus the leading `CAP_`.
    For example, `CAP_SETUID` would be `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
    | No |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `AllowedCapabilities` | `[]v1.Capaility` | 定义一个允许的能力集，可以添加到容器中。Pod 可以指定这些能力中的任何一个。值是
    POSIX 能力的字符串，去掉前缀 `CAP_`。例如，`CAP_SETUID` 应为 `SETUID` ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html))。
    | 否 |'
- en: '| `Volumes` | `[]string` | This list defines which volumes can be used. Leave
    this empty for all types ([https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127](https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127)).
    | No |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Volumes` | `[]string` | 此列表定义可以使用哪些卷。若要支持所有类型，请保持为空 ([https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127](https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127))。
    | 否 |'
- en: '| `HostNetwork` | `bool` | This allows or disallows the pod to use the host
    network. | No |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `HostNetwork` | `bool` | 允许或不允许 pod 使用主机网络。 | 否 |'
- en: '| `HostPorts` | `[]HostPortRange` | This lets us restrict allowable host ports
    that can be exposed. | No |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `HostPorts` | `[]HostPortRange` | 允许我们限制可以暴露的主机端口。 | 否 |'
- en: '| `HostPID` | `bool` | This allows or disallows the pod to use the host PID.
    | No |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `HostPID` | `bool` | 允许或不允许 pod 使用主机 PID。 | 否 |'
- en: '| `HostIPC` | `bool` | This allows or disallows the pod to use the host IPC.
    | No |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `HostIPC` | `bool` | 允许或不允许 pod 使用主机 IPC。 | 否 |'
- en: '| `SELinux` | `SELinuxStrategyOptions` | Set it to one of the strategy options,
    as defined here: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux).
    | Yes |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `SELinux` | `SELinuxStrategyOptions` | 将其设置为以下策略选项之一，如此处定义：[https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux)。
    | 是 |'
- en: '| `RunAsUser` | `RunAsUserStrategyOptions` | Set it to one of the strategy
    options, as defined here: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups).
    | Yes |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `RunAsUser` | `RunAsUserStrategyOptions` | 将其设置为以下策略选项之一，如此处定义：[https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups)。
    | 是 |'
- en: '| `SupplementalGroups` | `SupplementalGroupsStrategyOptions` | Set it to one
    of the strategy options, as defined here: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups)
    | Yes |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `SupplementalGroups` | `SupplementalGroupsStrategyOptions` | 将其设置为以下策略选项之一，如此处定义：[https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups)
    | 是 |'
- en: '| `FSGroup` | `FSGroupStrategyOptions` | Set it to one of the strategy options,
    as defined here: [https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | Yes |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `FSGroup` | `FSGroupStrategyOptions` | 将其设置为此处定义的策略选项之一：[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | 是 |'
- en: '| `ReadOnlyRootFilesystem` | `bool` | Setting this to `true` will either deny
    the pod or force it to run with a read-only root filesystem. | No |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `ReadOnlyRootFilesystem` | `bool` | 将此设置为 `true` 将拒绝该 Pod 或强制其以只读根文件系统运行。
    | 否 |'
- en: '| `allowedHostPaths` | `[]AllowedHostPath` | This provides a whitelist of host
    paths that can be used at volumes. | No |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `allowedHostPaths` | `[]AllowedHostPath` | 提供可以在卷中使用的主机路径的白名单。 | 否 |'
- en: '| `allowedFlexVolumes` | `[]AllowedFlexVolume` | This provides a whitelist
    of flex volumes that can be mounted. | No |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `allowedFlexVolumes` | `[]AllowedFlexVolume` | 提供可以挂载的 Flex Volumes 白名单。
    | 否 |'
- en: '| `allowPrivilegeEscalation` | `bool` | This governs where `setuid` can be
    used to change the user a process is running under. Its default is `true`.   |
    No |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `allowPrivilegeEscalation` | `bool` | 控制是否可以使用 `setuid` 来改变进程运行的用户。默认值为 `true`。
    | 否 |'
- en: '| `defaultAllowPrivilegeEscalation` | `bool` | Sets the default for `allowPrivilegeEscalation`.
    | No |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `defaultAllowPrivilegeEscalation` | `bool` | 设置 `allowPrivilegeEscalation`
    的默认值。 | 否 |'
- en: Additional considerations
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他考虑事项
- en: In addition to the features we just reviewed, Kubernetes has a number of other
    constructs that should be considered in your overall cluster hardening process.
    Earlier in this book, we looked at namespaces that provide a logical separation
    for multi-tenancy. While the namespaces themselves do not isolate the actual network
    traffic, some of the network plugins, such as Calico and Canal, provide additional
    capability for network policies. We also looked at quotas and limits that can
    be set for each namespace, which should be used to prevent a single tenant or
    project from consuming too many resources within the cluster.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚刚回顾的功能外，Kubernetes 还有许多其他构造体应纳入整个集群硬化过程。在本书早些时候，我们介绍了命名空间，它为多租户提供了逻辑隔离。虽然命名空间本身并不隔离实际的网络流量，但一些网络插件（如
    Calico 和 Canal）为网络策略提供了额外的功能。我们还介绍了可以为每个命名空间设置的配额和限制，这些配额和限制应该用于防止单个租户或项目在集群中消耗过多资源。
- en: Securing sensitive application data (secrets)
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护敏感应用数据（Secrets）
- en: Sometimes, our application needs to hold sensitive information. This can be
    credentials or tokens to log in to a database or service. Storing this sensitive
    information in the image itself is something to be avoided. Here, Kubernetes provides
    us with a solution in the construct of secrets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的应用程序需要保存敏感信息。这些信息可能是登录数据库或服务的凭证或令牌。将这些敏感信息存储在镜像本身中是需要避免的。在这里，Kubernetes
    提供了一个通过 Secrets 进行管理的解决方案。
- en: Secrets give us a way to store sensitive information without including plaintext
    versions in our resource definition files. Secrets can be mounted to the pods
    that need them and then accessed within the pod as files with the secret values
    as content. Alternatively, you can also expose the secrets via environment variables.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets 为我们提供了一种存储敏感信息的方法，避免将明文版本包含在资源定义文件中。Secrets 可以挂载到需要它们的 Pod 上，然后在 Pod
    内部作为文件访问，文件内容为敏感值。或者，你也可以通过环境变量暴露这些 secrets。
- en: Given that Kubernetes still relies on plaintext etcd storage, you may want to
    explore integration with more mature secrets vaults, such as Vault from Hashicorp.
    There is even a GitHub project for integration: [https://github.com/Boostport/kubernetes-vault](https://github.com/Boostport/kubernetes-vault).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kubernetes 仍然依赖于明文存储在 etcd 中，你可能希望探索与更成熟的秘密存储库（如 Hashicorp 的 Vault）的集成。甚至有一个
    GitHub 项目用于集成：[https://github.com/Boostport/kubernetes-vault](https://github.com/Boostport/kubernetes-vault)。
- en: We can easily create a secret either with YAML or on the command line. Secrets
    do need to be base-64 encoded, but if we use the `kubectl` command line, this
    encoding is done for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地通过 YAML 或命令行创建一个 secret。Secrets 需要进行 base64 编码，但如果我们使用 `kubectl` 命令行工具，这一编码过程会为我们自动完成。
- en: 'Let''s start with the following secret:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下 Secret 开始：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then check for the secret with this command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查 secret：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have successfully created the secret, let''s make a pod that can
    use the secret. Secrets are consumed in pods by way of attached volumes. In the
    following `secret-pod.yaml` file, you''ll notice that we use `volumeMount` to
    mount the secret to a folder in our container:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了机密，接下来让我们创建一个可以使用该机密的Pod。机密在Pod中通过附加的卷进行消费。在以下的`secret-pod.yaml`文件中，您会注意到我们使用`volumeMount`将机密挂载到容器中的一个文件夹：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create this pod with `kubectl create -f secret-pod.yaml`. Once created, we
    can get a bash shell in the pod with `kubectl exec` and then change directories
    to the `/etc/secret-phrases` folder that we set up in the pod definition. Listing
    this directory reveals a single file with the name of the secret that we created
    earlier:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl create -f secret-pod.yaml`创建此Pod。创建后，我们可以通过`kubectl exec`进入Pod并更改目录到我们在Pod定义中设置的`/etc/secret-phrases`文件夹。列出该目录会显示一个文件，文件名是我们之前创建的机密的名称：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we then display its contents, we should see the phrase we encoded previously,
    `Shh! Dont'' tell`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们显示其内容，应该看到我们之前编码的短语，`Shh! Dont' tell`：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Typically, this would be used for a username and password to a database or service, or
    any sensitive credentials and configuration data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这会用于数据库或服务的用户名和密码，或任何敏感的凭据和配置信息。
- en: Bear in mind that secrets are still in their early stages, but they are a vital
    component for production operations. There are several improvements being planned
    for future releases. At the moment, secrets are still stored in plaintext in the
    etcd server. However, the secrets construct does allow us to control which pods
    can access it, and it stores the information on the tmpfs, but does not store
    it at rest for each pod. You can limit users with access to etcd and perform additional
    wipe procedures when you decommission servers, but you'll likely want more protection
    in place for a production-ready system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，机密信息仍处于初期阶段，但它们是生产操作中至关重要的组成部分。未来版本计划进行多项改进。目前，机密信息仍然以明文形式存储在etcd服务器中。然而，机密结构确实允许我们控制哪些Pods可以访问它，并且它将信息存储在tmpfs中，但不会为每个Pod存储静态数据。您可以限制访问etcd的用户，并在停用服务器时执行额外的清除操作，但对于准备投入生产的系统，您可能需要更多的保护措施。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at basic container security and some essential
    areas of consideration. We also touched on basic image security and continuous
    vulnerability scanning. Later in this chapter, we looked at the overall security
    features of Kubernetes, including secrets for storing sensitive configuration
    data, secure API calls, and even setting up security policies and contexts for
    pods running on our cluster.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了基本的容器安全性和一些关键的考虑领域。我们还简单讨论了基本的镜像安全性和持续的漏洞扫描。随后，我们探讨了Kubernetes的整体安全特性，包括存储敏感配置信息的机密、API调用的安全性，甚至为在集群中运行的Pods设置安全策略和上下文。
- en: You should now have a solid starting point for securing your cluster and moving
    toward production. To that end, the next chapter will cover an overall strategy
    for moving toward production and will also look at some third-party vendors that
    offer tools to fill in the gaps and assist you on the way.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该有一个坚实的起点来保护您的集群并朝着生产环境迈进。为此，下一章将介绍朝生产环境迈进的整体策略，并将讨论一些第三方供应商提供的工具，以填补空白并在过程中提供帮助。
- en: Questions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which component can be used as a central point for managing and prevent vulnerabilities
    from being released?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个组件可以作为管理的中心点，并防止漏洞被释放？
- en: What are three methods for authorization within a Kubernetes cluster?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中，有哪三种授权方法？
- en: Which parameter of a PodSecurityPolicy disallows the running of privileged containers?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PodSecurityPolicy中的哪个参数禁止运行特权容器？
- en: How do you list all secrets that you have access to in a cluster?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何列出您在集群中有权访问的所有机密信息？
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: '[https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-10pdf/](https://www.nccgroup.trust/us/our-research/understanding-and-hardening-linux-containers/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-10pdf/](https://www.nccgroup.trust/us/our-research/understanding-and-hardening-linux-containers/)'
- en: '[https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14](https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14](https://github.com/moby/moby/blob/89dac8427e7366cbd6a47e713fe8f445198ca3d4/oci/defaults.go#L14)'
- en: '[https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145](https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145](https://github.com/kubernetes/kubernetes/blob/2d7b92ee743de20d17406003e463a829a0db5a51/pkg/apis/policy/types.go#L145)'
