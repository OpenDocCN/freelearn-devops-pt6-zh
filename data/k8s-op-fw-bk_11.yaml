- en: '*Chapter 8*: Preparing for Ongoing Maintenance of Your Operator'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：为你的 Operator 做持续维护的准备'
- en: In this book, we have shown the steps for creating a new **Kubernetes** Operator.
    We've covered the full range of processes from conception to design, to coding,
    deployment, and finally, release. But, very few software projects end their life
    cycle after the initial release, Operators included. In fact, for many Operators,
    the majority of work will eventually be done after release on a long enough timescale.
    So, it's valuable to prepare for the future maintenance of your Operator by understanding
    the expectations of your users and the Operator community at large.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们展示了创建新的 **Kubernetes** Operator 的步骤。我们涵盖了从构思、设计、编码、部署到最终发布的全过程。但是，极少有软件项目在初始发布后结束生命周期，Operator
    也不例外。事实上，对于许多 Operator，大部分工作最终会在发布后很长时间内完成。因此，通过了解用户和 Operator 社区的期望，为将来维护你的 Operator
    做准备是很有价值的。
- en: 'As a Kubernetes-based project, it can be very helpful to rely on the established
    conventions from Kubernetes and its subprojects for your own ongoing development.
    While you are free to form your own guidelines for future releases, it is likely
    that your Operator will depend on at least some library or aspect of the core
    Kubernetes platform simply by virtue of being built for Kubernetes. For that reason,
    knowing the policies in place for Kubernetes can help align your own development
    practices in preparation for changes in the upstream platform, which you will
    almost certainly inherit and be forced to react to. That''s why this chapter will
    focus on those conventions throughout the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个基于 Kubernetes 的项目，依赖 Kubernetes 及其子项目中已建立的约定对你自己持续的开发工作非常有帮助。虽然你可以自由制定未来发布的指导方针，但由于是为
    Kubernetes 构建的，你的 Operator 很可能至少会依赖于某些库或 Kubernetes 核心平台的某些方面。因此，了解 Kubernetes
    的现行政策可以帮助你在准备应对上游平台的变化时对齐自己的开发实践，因为这些变化几乎是必然的，你将不得不做出反应。这就是为什么本章将在接下来的部分中重点介绍这些约定。
- en: Releasing new versions of your Operator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布你 Operator 的新版本
- en: Planning for deprecation and backward compatibility
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为弃用和向后兼容性做规划
- en: Complying with Kubernetes standards for changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵守 Kubernetes 对变更的标准
- en: Aligning with the Kubernetes release timeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Kubernetes 发布时间表对齐
- en: Working with the Kubernetes community
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Kubernetes 社区合作
- en: The procedures established by the Kubernetes community provide an excellent
    template for your own development practices and a familiar set of policies for
    your users. There is, of course, no requirement for any Operator to strictly follow
    these guidelines, but it is the goal of this chapter to explain them in a way
    that provides the relevant precedent for your project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 社区制定的程序为你自己的开发实践提供了一个优秀的模板，并为用户提供了一套熟悉的政策。当然，没有任何要求要求 Operator 严格遵循这些指南，但本章的目标是以一种方式解释它们，提供与你的项目相关的先例。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, the only technical work will be done in the *Releasing new
    versions of your Operator* section, in which we will build on the existing nginx
    Operator code from earlier chapters to add new code and run that code in a Kubernetes
    cluster. As such, the requirements for this chapter include the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，唯一的技术工作将集中在 *发布你 Operator 的新版本* 部分，我们将在这一部分基于前面章节中的 nginx Operator 代码进行扩展，新增代码并在
    Kubernetes 集群中运行这些代码。因此，本章的要求包括以下内容：
- en: The `operator-sdk` binary
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator-sdk` 二进制文件'
- en: '`Go` 1.16+'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Go` 1.16+'
- en: Docker
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Access to a running Kubernetes cluster
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问正在运行的 Kubernetes 集群
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3aiaokl](https://bit.ly/3aiaokl)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 Code in Action 视频可以在以下链接观看：[https://bit.ly/3aiaokl](https://bit.ly/3aiaokl)
- en: Releasing new versions of your Operator
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布你 Operator 的新版本
- en: Now that your Operator is published, the fun has just begun. It's now time to
    start thinking about your next release! As with any software project, your Operator
    will evolve over time by introducing new features and adapting to changes in upstream
    Kubernetes. There are tomes of literature written on releasing software with recommendations
    on when and how to publish updates to a software product. Much of that information
    is out of the scope of this book. Instead, we will explain the technical steps
    required to create and publish a new version of your Operator with the **Operator
    SDK**, **Operator Lifecycle Manager** (**OLM**), and **OperatorHub** in mind.
    From there, methods and timing for your release are entirely up to your organization
    (though you may want to learn more about how other Kubernetes projects are released
    later in this chapter in the *Aligning with the Kubernetes release timeline* section).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的 Operator 已经发布，真正有趣的部分才刚刚开始。是时候开始考虑下一次发布了！和任何软件项目一样，你的 Operator 会随着时间推移而不断发展，推出新特性并适应上游
    Kubernetes 的变化。关于发布软件的文献极其丰富，提供了何时以及如何发布软件更新的建议。大部分信息超出了本书的范围。相反，我们将解释使用 **Operator
    SDK**、**Operator 生命周期管理器**（**OLM**）和 **OperatorHub** 发布新版本 Operator 所需的技术步骤。从那时起，你的发布方式和时机完全由你的组织决定（不过你可能希望稍后在本章的
    *与 Kubernetes 发布时间表对齐* 部分中了解其他 Kubernetes 项目的发布方式）。
- en: Adding an API version to your Operator
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的 Operator 添加 API 版本
- en: While there are many factors that may influence your decision to release a new
    version of your Operator (such as bug fixes or simply following a regular release
    schedule), one type of change that is common among Operators is updating the Operator's
    config API. Recall that this is the API translated into the Operator's **CustomResourceDefinition**
    (**CRD**). So, in some cases, it may be necessary to update the API that is shipped
    with your Operator to indicate changes to users (see the *Complying with Kubernetes
    standards for changes* section).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多因素可能影响你决定发布新版本 Operator（例如修复 Bug 或仅仅是跟随定期发布计划），但 Operator 中常见的一种更改是更新 Operator
    的配置 API。回想一下，这是转换成 Operator 的 **CustomResourceDefinition**（**CRD**）的 API。因此，在某些情况下，可能需要更新与
    Operator 一起发布的 API，以便向用户指示更改（请参见 *遵循 Kubernetes 标准进行变更* 部分）。
- en: 'To do this, we need to create a new API version and include that version in
    the Operator''s CRD (for a more in-depth look at what this means from a technical
    standpoint, see the Kubernetes documentation on CRD versioning for information
    on the details of how this works: [https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/)).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要创建一个新的 API 版本，并将该版本包含在 Operator 的 CRD 中（有关从技术角度深入了解此操作的更多信息，请参见 Kubernetes
    关于 CRD 版本控制的文档，了解此操作的详细信息：[https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/)）。
- en: 'In [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing an Operator
    with the Operator SDK*, we initialized the first version of our Operator''s API
    with the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第4章*](B18147_04_ePub.xhtml#_idTextAnchor066) 中，*使用 Operator SDK 开发 Operator*，我们通过以下命令初始化了我们
    Operator API 的第一个版本：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This created the `NginxOperator` API type as the `v1alpha1` version. We then
    filled out the API in `api/v1alpha1/nginxoperator_types.go` and generated the
    corresponding CRD, which provides the interface for using the Operator once it
    was deployed in a cluster.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了 `NginxOperator` API 类型，并将其版本设置为 `v1alpha1`。然后，我们在 `api/v1alpha1/nginxoperator_types.go`
    中填写了 API 并生成了相应的 CRD，这为 Operator 部署到集群后提供了使用接口。
- en: 'If some incompatible changes needed to be made to this API that required a
    new version, that version could be generated similarly. Say, for example, that
    we wanted to allow the nginx Deployment managed by our Operator to expose multiple
    ports, such as one for HTTP and another for HTTPS requests. We could do this by
    changing the `port` field in the existing nginx Operator''s CRD to a `ports` field
    that defines a list of `v1.ContainerPorts` (this is a native Kubernetes API type
    that allows for naming multiple ports for a container). This new type exposes
    additional information, such as `Name` and `HostPort`, but it also includes the
    same `int32` value for defining a singular `ContainerPort` that the original `port`
    field used. Let''s take the following line from `controllers/nginxoperator_controller.go`
    as an example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要对该 API 进行某些不兼容的更改，并且需要生成新版本，可以以类似的方式生成该版本。例如，假设我们希望允许由 Operator 管理的 nginx
    部署暴露多个端口，比如一个用于 HTTP，另一个用于 HTTPS 请求。我们可以通过将现有 nginx Operator 的 CRD 中的`port`字段更改为`ports`字段，来定义一个`v1.ContainerPorts`列表（这是
    Kubernetes 原生的 API 类型，允许为容器命名多个端口）。这个新类型暴露了额外的信息，如`Name`和`HostPort`，但它也包含了与原始`port`字段相同的`int32`值，用于定义单个`ContainerPort`。我们可以从`controllers/nginxoperator_controller.go`中取以下一行作为示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This could be simplified to just the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为以下内容：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To show what this means for the Operator types, we will take the existing `NginxOperatorSpec`
    type in `v1alpha1`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这对 Operator 类型意味着什么，我们将以现有的`NginxOperatorSpec`类型为例，展示`v1alpha1`版本：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And now, we will change it to a new `NginxOperatorSpec` type in `v1alpha2`
    that looks like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将其更改为`v1alpha2`中新定义的`NginxOperatorSpec`类型，像下面这样：
- en: '[PRE19]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In order to preserve functionality for our users, it's important to introduce
    the new version in a way that ensures the Operator supports both versions for
    as long as required by the deprecation policy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持用户的功能性，重要的是以一种确保 Operator 在退役策略要求的时间内支持两个版本的方式来引入新版本。
- en: Generating the new API directory
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成新的 API 目录
- en: 'The first step is to generate the new API files. The new API version is generated
    as a scaffold with the `operator-sdk` command, just like when we generated `v1alpha1`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是生成新的 API 文件。新的 API 版本通过`operator-sdk`命令生成，像我们生成`v1alpha1`时一样：
- en: '[PRE29]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that this time, the `--controller` flag was omitted (and we chose `n` for
    `Create Controller [y/n]`) because the controller for this Operator already exists
    (`controllers/nginxoperator_controller.go`), so we don't need to generate another
    one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次省略了`--controller`标志（我们选择了`n`代表`Create Controller [y/n]`），因为该 Operator
    的控制器已经存在（`controllers/nginxoperator_controller.go`），因此我们不需要生成另一个控制器。
- en: Instead, the existing controller will need to be manually updated to remove
    references to `v1alpha1` and replace them with `v1alpha2`. This step can also
    be automated with tools such as `sed`, but be sure to carefully review any changes
    whenever automating code updates like this.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，现有的控制器需要手动更新，移除对`v1alpha1`的引用并将其替换为`v1alpha2`。这个步骤也可以通过诸如`sed`之类的工具来自动化，但在自动化代码更新时，请务必仔细检查任何更改。
- en: 'When the version is generated, it will create a new `api/v1alpha2` folder,
    which also contains an `nginxoperator_types.go` file. Copy the existing type definitions
    from `api/v1alpha1/nginxoperator_types.go` into this file and change the `port`
    field into `ports`, as shown in the preceding code. The new file should look as
    follows (note the highlighted change to `Ports`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当版本生成时，它会创建一个新的`api/v1alpha2`文件夹，其中还包含一个`nginxoperator_types.go`文件。将现有的类型定义从`api/v1alpha1/nginxoperator_types.go`复制到此文件，并将`port`字段更改为`ports`，如前面的代码所示。新文件应如下所示（注意对`Ports`的高亮更改）：
- en: 'api/v1alpha2/nginxoperator_types.go:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: api/v1alpha2/nginxoperator_types.go：
- en: '[PRE30]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Updating the Operator's CRD
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 Operator 的 CRD
- en: 'Next, the Operator''s CRD needs to be updated to include definitions for both
    `v1alpha1` and `v1alpha2`. First, one version needs to be defined as the `etcd`.
    When the Operator only had one version, it wasn''t necessary to specify this (that
    was the only version available to be stored). Now, however, the API server needs
    to know how to store the object. This is done by adding another `kubebuilder`
    marker (`//+kubebuilder:storageversion`) to the `NginxOperator` struct:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要更新 Operator 的 CRD，以包括`v1alpha1`和`v1alpha2`的定义。首先，需要将一个版本定义为`etcd`。当 Operator
    只有一个版本时，不需要指定这个（那时唯一可用的版本就是该版本）。然而，现在，API 服务器需要知道如何存储该对象。通过在`NginxOperator`结构体中添加另一个`kubebuilder`标记（`//+kubebuilder:storageversion`）来实现这一点：
- en: '[PRE78]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This instructs the CRD generator to label `v1alpha2` as the storage version.
    Now, running `make manifests` will generate new changes to the CRD:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示CRD生成器将`v1alpha2`标记为存储版本。现在，运行`make manifests`将生成新的CRD更改：
- en: '[PRE88]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, the Operator''s CRD should include a new `v1alpha2` specification definition
    under `versions`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Operator的CRD应该在`versions`下包括一个新的`v1alpha2`规范定义：
- en: 'config/crd/bases/operator.example.com_nginxoperators.yaml:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'config/crd/bases/operator.example.com_nginxoperators.yaml:'
- en: '[PRE89]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Implementing API conversions
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现API转换
- en: 'Finally, the API server needs to know how to convert between these two incompatible
    versions. Specifically, the `int32` value for the `v1alpha1` port needs to be
    converted into a `ContainerPort` value in a list of `ports` for `v1alpha2`. For
    the sake of this example, we will define the behavior as the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，API服务器需要知道如何在这两个不兼容的版本之间进行转换。具体来说，`v1alpha1`端口的`int32`值需要转换为`v1alpha2`中`ports`列表中的`ContainerPort`值。为了这个示例，我们将定义以下行为：
- en: '`v1alpha1` to `v1alpha2`: `int32(port)` becomes `ports[0].ContainerPort`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1alpha1`到`v1alpha2`：`int32(port)`变为`ports[0].ContainerPort`。'
- en: '`v1alpha2` to `v1alpha1`: `ports[0].ContainerPort` becomes `int32(port)`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1alpha2`到`v1alpha1`：`ports[0].ContainerPort`变为`int32(port)`。'
- en: In other words, if we are handed a list of ports and need to convert to a single
    port (`v1alpha2` to `v1alpha1`), we will take the first value in the list and
    use that. In reverse (`v1alpha1` to `v1alpha2`), we will take the single `port`
    value and make it the first (and only) value in a new list of ports.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们收到一个端口列表并需要转换为单个端口（`v1alpha2`到`v1alpha1`），我们将取列表中的第一个值并使用它。反之（`v1alpha1`到`v1alpha2`），我们将取单个`port`值并将其作为新端口列表中的第一个（也是唯一）值。
- en: 'To define these conversion rules, we will implement the `Convertible` and `Hub`
    interfaces from `sigs.k8s.io/controller-runtime/pkg/conversion`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义这些转换规则，我们将实现来自`sigs.k8s.io/controller-runtime/pkg/conversion`的`Convertible`和`Hub`接口：
- en: 'sigs.k8s.io/controller-runtime/pkg/conversion/conversion.go:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'sigs.k8s.io/controller-runtime/pkg/conversion/conversion.go:'
- en: '[PRE121]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: These will then be exposed to the API server via a `operator-sdk` are wrappers
    for kubebuilder commands, so the steps for implementing the conversion webhook
    in an Operator are the same as for any other controller, as shown in the kubebuilder
    documentation). This process defines one version as the `Hub` type through which
    the `Convertible` spoke types are converted.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将通过`operator-sdk`暴露给API服务器，`operator-sdk`是kubebuilder命令的包装器，因此在Operator中实现转换webhook的步骤与任何其他控制器相同，如kubebuilder文档中所示）。该过程通过`Hub`类型定义一个版本，`Convertible`的
    spoke 类型通过该版本进行转换。
- en: 'To get started, first create a new file, `api/v1alpha2/nginxoperator_conversion.go`,
    to define `v1alpha2` as the Hub version:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新文件`api/v1alpha2/nginxoperator_conversion.go`，将`v1alpha2`定义为Hub版本：
- en: 'api/v1alpha2/nginxoperator_conversion.go:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'api/v1alpha2/nginxoperator_conversion.go:'
- en: '[PRE137]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Next, create another file, `api/v1alpha1/nginxoperator_conversion.go` (note
    this is in the `v1alpha1` directory). This file will implement the `ConvertTo()`
    and `ConvertFrom()` functions to translate `v1alpha1` to and from `v1alpha2`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个文件`api/v1alpha1/nginxoperator_conversion.go`（注意这是在`v1alpha1`目录中）。此文件将实现`ConvertTo()`和`ConvertFrom()`函数，用于将`v1alpha1`与`v1alpha2`之间进行转换：
- en: 'api/v1alpha1/nginxoperator_conversion.go:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'api/v1alpha1/nginxoperator_conversion.go:'
- en: '[PRE140]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Then, fill in these functions to do the actual conversions. For the fields
    such as `Replicas` and `ForceRedeploy`, the conversion is 1:1 (it''s also important
    to copy the `Metadata` and `Status.Conditions` too). But, for `Port`/`Ports`,
    we need to add the logic defined previously. That makes `ConvertTo()` look like
    the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，填写这些函数以执行实际的转换。对于`Replicas`和`ForceRedeploy`等字段，转换是1:1的（同样重要的是要复制`Metadata`和`Status.Conditions`）。但是，对于`Port`/`Ports`，我们需要添加之前定义的逻辑。这样，`ConvertTo()`看起来像以下这样：
- en: '[PRE155]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'And `ConvertFrom()` is similar, but in reverse:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 而`ConvertFrom()`类似，但方向相反：
- en: '[PRE173]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Now, we can generate the webhook logic and endpoints by using `operator-sdk
    create webhook`, with the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`operator-sdk create webhook`生成webhook逻辑和端点，使用以下命令：
- en: '[PRE189]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: You can ignore the message saying `You need to implement the conversion.Hub
    and conversion.Convertible interfaces for your CRD types` because we already did
    that (the generator simply assumes that it will be run before these are implemented).
    At this point, everything has been implemented, and the only next step is to ensure
    that the webhook is properly deployed with the Operator when it is installed in
    a cluster.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以忽略消息中提到的`You need to implement the conversion.Hub and conversion.Convertible
    interfaces for your CRD types`，因为我们已经实现了这些（生成器简单假设它会在这些接口实现之前运行）。到目前为止，所有工作已经完成，下一步只是确保
    webhook 在 Operator 安装到集群时被正确部署。
- en: Updating project manifests to deploy the webhook
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新项目的 manifests 以部署 webhook
- en: Just like how the manifests to enable metrics resources needed to be uncommented
    in order to be deployed with the Operator ([*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*), so too do resources related
    to the webhook.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 就像启用度量资源的 manifests 需要取消注释以便与 Operator 一起部署一样（[*第五章*](B18147_05_ePub.xhtml#_idTextAnchor078)，*开发
    Operator – 高级功能*），与 webhook 相关的资源也需要如此处理。
- en: 'To do this, first, modify `config/crd/kustomization.yaml` to uncomment the
    `patches/webhook_in_nginxoperators.yaml` and `patches/cainject_in_nginxoperators.yaml`
    lines to include these two patch files in the deployment:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先修改`config/crd/kustomization.yaml`，取消注释`patches/webhook_in_nginxoperators.yaml`和`patches/cainject_in_nginxoperators.yaml`行，以便将这两个补丁文件包含到部署中：
- en: 'config/crd/kustomization.yaml:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'config/crd/kustomization.yaml:'
- en: '[PRE190]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Now, modify one of those files, `patches/webhook_in_nginxoperators.yaml`, to
    add the two CRD versions as `conversionReviewVersions` in the Operator''s CRD:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改其中一个文件`patches/webhook_in_nginxoperators.yaml`，将两个 CRD 版本作为`conversionReviewVersions`添加到
    Operator 的 CRD 中：
- en: 'config/crd/patches/webhook_in_nginxoperators.yaml:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'config/crd/patches/webhook_in_nginxoperators.yaml:'
- en: '[PRE204]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Next, make the following changes to `config/default/kustomization.yaml` to
    uncomment the following lines:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对`config/default/kustomization.yaml`进行以下更改，以取消注释以下行：
- en: '`- ../webhook`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- ../webhook`'
- en: '`- ../certmanager`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- ../certmanager`'
- en: '`- manager_webhook_patch.yaml`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- manager_webhook_patch.yaml`'
- en: All of the variables in the `vars` section with the `[CERTMANAGER]` label.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在`vars`部分中带有`[CERTMANAGER]`标签的变量。
- en: 'The final file will look as follows (uncommented lines highlighted and some
    sections omitted for brevity):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最终文件将如下所示（取消注释的行高亮显示，部分内容为简洁起见被省略）：
- en: 'config/default/kustomization.yaml:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'config/default/kustomization.yaml:'
- en: '[PRE222]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'And finally, comment out the `manifests.yaml` line in `config/webhook/kustomization.yaml`
    (this file does not exist for our use case, and trying to deploy without uncommenting
    this line will result in an error). The following snippet shows which line should
    be commented out with `#`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`config/webhook/kustomization.yaml`中注释掉`manifests.yaml`行（该文件在我们的使用案例中不存在，尝试在没有取消注释这一行的情况下进行部署将导致错误）。下面的代码片段显示了应该注释掉的行：
- en: 'config/webhook/kustomization.yaml:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 'config/webhook/kustomization.yaml:'
- en: '[PRE271]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: With these changes, the Operator can be re-built and deployed using the `operator-sdk`
    and `make` commands from earlier chapters.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，Operator 可以使用前面章节中的`operator-sdk`和`make`命令重新构建并部署。
- en: Deploying and testing the new API version
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署和测试新 API 版本
- en: To confirm that the API server now understands and can convert between versions
    of the Operator CRD, install it in a cluster. Note that now your Operator will
    depend on **cert-manager** being present in the cluster, so be sure to install
    that first (instructions are available at [https://cert-manager.io/docs/installation/](https://cert-manager.io/docs/installation/)).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认 API 服务器现在能够理解并在不同版本的 Operator CRD 之间进行转换，将其安装到集群中。请注意，现在你的 Operator 依赖于**cert-manager**存在于集群中，所以一定要先安装它（安装指南可在[https://cert-manager.io/docs/installation/](https://cert-manager.io/docs/installation/)找到）。
- en: 'Remember, you need to update `controllers/nginxoperator_controller.go` to replace
    `v1alpha1` references with `v1alpha2` and change the `Ports` check (in `Reconcile()`)
    to match the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你需要更新`controllers/nginxoperator_controller.go`，将`v1alpha1`的引用替换为`v1alpha2`，并将`Ports`检查（在`Reconcile()`中）更改为以下内容：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'controllers/nginxoperator_controller.go:'
- en: '[PRE274]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Forgetting to do this will cause an error when creating or retrieving the Operator
    CRD (which won't show up at compile time). This is because the `v1alpha1` API
    types are still defined and valid (so the Operator code compiles correctly), but
    the new client and reconciliation code will expect the object to be retrieved
    in the `v1alpha2` format.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记这样做将导致在创建或检索 Operator CRD 时发生错误（编译时不会显示该错误）。这是因为 `v1alpha1` API 类型仍然被定义且有效（所以
    Operator 代码能够正常编译），但新的客户端和协调代码会期望以 `v1alpha2` 格式检索该对象。
- en: 'To deploy the nginx Operator, build and push the new container image before
    running `make deploy`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署 nginx Operator，请在运行 `make deploy` 之前构建并推送新的容器镜像：
- en: '[PRE279]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'Next, create a simple `NginxOperator` object. To demonstrate the API conversion,
    create it as the `v1alpha1` version and use the old `port` field:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个简单的 `NginxOperator` 对象。为了演示 API 转换，将其创建为 `v1alpha1` 版本，并使用旧的 `port`
    字段：
- en: 'sample-cr.yaml:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: sample-cr.yaml：
- en: '[PRE280]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Next, create the custom resource object with kubectl:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 kubectl 创建自定义资源对象：
- en: '[PRE288]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'Now, using `kubectl get` to view the object will show it as `v1alpha2` because
    it was automatically converted and stored as this version:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `kubectl get` 查看该对象时，将显示为 `v1alpha2`，因为它已经被自动转换并存储为此版本：
- en: '[PRE289]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'You can choose to specifically view the object as `v1alpha1` with the following
    command, which will instruct the API server to call the Operator''s webhook and
    convert it back using the functions we wrote:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择通过以下命令以 `v1alpha1` 的形式查看该对象，这将指示 API 服务器调用 Operator 的 webhook，并使用我们编写的函数将其转换回来：
- en: '[PRE290]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: What this means for your users is that they can continue using the existing
    API, which allows valuable transition time while you introduce a new version.
    Note that if they are already using the Operator, and you introduce a new storage
    version, they may need to use **kube-storage-version-migrator** ([https://github.com/kubernetes-sigs/kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator))
    to migrate the existing storage version to the new one. You can provide migration
    files for them (or even automate it into the Operator, as migrations are simply
    Kubernetes resources) to make this easier.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户来说，这意味着他们可以继续使用现有的 API，从而在您引入新版本的同时提供宝贵的过渡时间。请注意，如果他们已经在使用 Operator，且您引入了新的存储版本，他们可能需要使用
    **kube-storage-version-migrator**（[https://github.com/kubernetes-sigs/kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator)）将现有的存储版本迁移到新版本。您可以为他们提供迁移文件（甚至将其自动化到
    Operator 中，因为迁移本质上是 Kubernetes 资源）以简化这个过程。
- en: With a new API version introduced and conversion handled, your Operator is now
    ready to be packaged into a new bundle so that deployment can be managed by the
    OLM. This means updating your Operator's CSV to a new version.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了新的 API 版本并完成了转换后，您的 Operator 现在可以打包成一个新的 bundle，以便通过 OLM 来管理部署。这意味着需要将 Operator
    的 CSV 更新为新版本。
- en: Updating the Operator CSV version
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 Operator 的 CSV 版本
- en: Updating the version of the Operator in its CSV provides information to the
    OLM, OperatorHub, and users about which version of the Operator they are running.
    It also instructs the OLM on which versions replace other versions for in-cluster
    upgrades. This allows developers to define specific upgrade `alpha` and `beta`),
    which are similar to the versioning channels in other software projects that allow
    users to subscribe to a different release cadence. The Operator SDK documentation
    goes into technical detail about this process on GitHub, but it is not necessary
    to understand these details for completing this section ([https://github.com/operator-framework/operator-lifecycle-manager/blob/b43ecc4/doc/design/how-to-update-operators.md](https://github.com/operator-framework/operator-lifecycle-manager/blob/b43ecc4/doc/design/how-to-update-operators.md)).
    In this section, however, we will cover the simple task of updating the CSV version
    in a single channel.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Operator 在其 CSV 中的版本为 OLM、OperatorHub 和用户提供有关他们正在运行的 Operator 版本的信息。它还指示
    OLM 哪些版本会替代其他版本用于集群内升级。这使得开发者能够定义特定的升级 `alpha` 和 `beta` 版本，这类似于其他软件项目中的版本渠道，允许用户订阅不同的发布节奏。Operator
    SDK 文档在 GitHub 上详细讲解了这个过程，但为了完成这一部分内容，并不需要理解这些细节（[https://github.com/operator-framework/operator-lifecycle-manager/blob/b43ecc4/doc/design/how-to-update-operators.md](https://github.com/operator-framework/operator-lifecycle-manager/blob/b43ecc4/doc/design/how-to-update-operators.md)）。不过，在这一部分中，我们将介绍更新
    CSV 版本这一简单任务，且只涉及单一渠道的更新。
- en: The first step toward bumping the Operator's CSV version is updating the version
    that will be replaced with the current version. In other words, `v0.0.2` will
    replace `v0.0.1`, so the `v0.0.2` CSV must indicate that it is replacing `v0.0.1`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 提升 Operator 的 CSV 版本的第一步是更新将被当前版本替换的版本。换句话说，`v0.0.2` 将替换 `v0.0.1`，因此 `v0.0.2`
    的 CSV 必须指示它正在替换 `v0.0.1`。
- en: 'This is done by modifying the base CSV in `config/manifests/bases` to add a
    `replaces` field under its spec, as shown in the following example:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改 `config/manifests/bases` 中的基础 CSV，向其 spec 中添加 `replaces` 字段来完成此操作，示例如下：
- en: 'config/manifests/bases/nginx-operator.clusterserviceversion.yaml:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: config/manifests/bases/nginx-operator.clusterserviceversion.yaml：
- en: '[PRE291]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Next, update the `VERSION` variable in the project''s Makefile (you can also
    export this variable to the new version in your shell similar to the other environment
    variables we have used from this file, but updating it manually clearly indicates
    the version and ensures that the right version will be propagated when built on
    any machine):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新项目中的 Makefile 文件中的 `VERSION` 变量（你也可以像我们之前使用的其他环境变量那样，在 shell 中将这个变量导出为新版本，但手动更新它可以清楚地指示版本，并确保在任何机器上构建时都会传播正确的版本）：
- en: 'Makefile:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile：
- en: '[PRE302]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'Now, the new CSV can be built as part of the regular make bundle command from
    [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108), *Installing and Running
    Operators with the Operator Lifecycle Manager*:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以像在[*第7章*](B18147_07_ePub.xhtml#_idTextAnchor108)，*使用 Operator 生命周期管理器安装和运行
    Operators*中所述的常规 make bundle 命令一样，构建新的 CSV：
- en: '[PRE308]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: This updates the version of the Operator listed in `bundle/manifests/nginx-operator.clusterserviceversion.yaml`
    (which is the main CSV packaged into the Operator's bundle). If you followed the
    steps from the previous section to add a new API version, it also adds information
    about that new version (and the conversion webhook) to the CSV and the sample
    CRD packaged along with the bundle. In addition, it will generate a new Service
    manifest in the bundle that exposes the conversion endpoint for the two API versions.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新 `bundle/manifests/nginx-operator.clusterserviceversion.yaml` 中列出的 Operator
    版本（这是打包到 Operator 包中的主要 CSV）。如果你按照前面一节的步骤添加了新的 API 版本，它还会将有关该新版本（以及转换 Webhook）的信息添加到
    CSV 和随包一起打包的示例 CRD 中。此外，它还将在包中生成一个新的 Service 清单，用于公开两个 API 版本的转换端点。
- en: 'The bundle image can then be built, pushed, and run with the OLM just like
    before:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以像以前一样使用 OLM 构建、推送和运行该包镜像：
- en: '[PRE309]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: With a new bundle image built and working, the only step remaining in releasing
    your new version is to publish it on OperatorHub for users to find.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建并正常运行新的包镜像后，发布新版本的最后一步是将其发布到 OperatorHub，以便用户查找。
- en: Releasing a new version on OperatorHub
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 OperatorHub 上发布新版本
- en: With a new version of your Operator, the bundle that is published to OperatorHub
    also needs to be updated (if you have chosen to release your Operator on OperatorHub).
    Thankfully, this process is not too complex. In fact, it is essentially the same
    as releasing your initial version (as in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*), wherein
    you created a folder with your Operator's bundle and submitted that folder as
    a pull request to the community Operators repository on GitHub ([https://github.com/k8s-operatorhub/community-operators](https://github.com/k8s-operatorhub/community-operators)).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布新版本的 Operator 后，如果你选择将 Operator 发布到 OperatorHub，那么发布到 OperatorHub 的包也需要更新。幸运的是，这个过程并不复杂。事实上，它基本上与发布初始版本的过程相同（如在[*第7章*](B18147_07_ePub.xhtml#_idTextAnchor108)，*使用
    Operator 生命周期管理器安装和运行 Operators*中所述），你需要创建一个包含 Operator 包的文件夹，并将该文件夹作为拉取请求提交到
    GitHub 上的社区 Operator 仓库（[https://github.com/k8s-operatorhub/community-operators](https://github.com/k8s-operatorhub/community-operators)）。
- en: To release a new version of your Operator, simply create a new folder under
    your Operator's directory in the community Operators project named after the version
    number. For example, if the first version was `nginx-operator/0.0.1`, this version
    would be `nginx-operator/0.0.2`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布新版本的 Operator，只需在社区 Operator 项目中你的 Operator 目录下创建一个新的文件夹，文件夹名称使用版本号。例如，如果第一个版本是`nginx-operator/0.0.1`，那么这个版本应该是`nginx-operator/0.0.2`。
- en: Then, just like with your first version, simply copy the contents of your Operator's
    `bundle` directory (after generating the new bundle version) into the new version
    folder. Commit and push the changes to your fork of the GitHub repository and
    open a new pull request against the main repository with the changes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像你的第一个版本一样，只需将 Operator `bundle` 目录的内容（在生成新版本的包之后）复制到新版本文件夹中。提交并推送更改到你自己
    GitHub 仓库的分支，并向主仓库提交一个新的拉取请求。
- en: When your pull request passes the automated checks, it should merge, and the
    new version of your Operator should be visible on OperatorHub soon after.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的拉取请求通过自动化检查后，它应该被合并，新的 Operator 版本应很快出现在 OperatorHub 上。
- en: '![Figure 8.1 – Screenshot of version and channel listing on OperatorHub for
    the Grafana Operator](img/B18147_08_001.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – Grafana Operator 在 OperatorHub 上的版本和频道列表截图](img/B18147_08_001.jpg)'
- en: Figure 8.1 – Screenshot of version and channel listing on OperatorHub for the
    Grafana Operator
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Grafana Operator 在 OperatorHub 上的版本和频道列表截图
- en: Now, you have finished releasing a new version of your Operator. By introducing
    a new API, ensuring that the new API is convertible between existing versions,
    updating your Operator's bundle, and publishing that updated bundle on OperatorHub,
    you should now announce to your users that the new version of your Operator is
    available. In the next sections, we'll discuss ways to ensure that future releases
    continue to go smoothly by planning ahead to minimize breaking API changes that
    require new versions and following the Kubernetes standards for making new changes.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经完成了发布新版本的操作。通过引入新的 API，确保新 API 在现有版本之间是可转换的，更新你的 Operator 包，并将更新后的包发布到
    OperatorHub，你现在应该向用户宣布新的 Operator 版本已上线。在接下来的章节中，我们将讨论如何通过提前规划以最小化需要新版本的 API 破坏性更改，并遵循
    Kubernetes 标准来确保未来的版本发布顺利进行。
- en: Planning for deprecation and backward compatibility
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为废弃和向后兼容做规划
- en: In the previous section, we discussed the work needed to release a new version
    of an Operator. While the processes for bundling and publishing a new version
    are relatively simple in terms of the effort required, implementing a new API
    version is not an insignificant task. As such, doing so should be done only as
    necessary in order to minimize the use of engineering resources and disruption
    to users.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了发布新版本 Operator 所需的工作。虽然捆绑和发布新版本的过程在所需的工作量上相对简单，但实现新 API 版本并不是一项微不足道的任务。因此，这样做应该仅在必要时进行，以最小化工程资源的使用和对用户的干扰。
- en: Of course, it will occasionally be unavoidable that incompatible changes must
    be introduced, for example, in the case of deprecation. Some of this deprecation
    might even come from upstream, where it is beyond your direct control (see the
    *Complying with Kubernetes standards for changes* section). However, the frequency
    of such changes can often be controlled through careful planning. In this section,
    we'll discuss some ways to plan for deprecation and support backward compatibility
    without causing undue strain on your engineers or users.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，偶尔会不可避免地需要引入不兼容的更改，例如在废弃的情况下。有些废弃甚至可能来自上游，这是你无法直接控制的（请参阅*遵守 Kubernetes 标准的变更*部分）。然而，通过仔细规划，这种更改的频率通常可以得到控制。在本节中，我们将讨论如何规划废弃并支持向后兼容，而不会对你的工程师或用户造成过大的压力。
- en: Revisiting Operator design
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重温 Operator 设计
- en: In [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032), *Understanding How
    Operators Interact with Kubernetes*, the *Planning for changes in your Operator*
    section discussed, in general terms, various design approaches that establish
    good practices for outlining an Operator's design for future evolution. These
    suggested guidelines (which could, in reality, be applied to many software projects)
    were to start small, iterate effectively, and deprecate gracefully.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B18147_02_ePub.xhtml#_idTextAnchor032)，《理解 Operator 如何与 Kubernetes
    交互》一章中的*为你的 Operator 规划变更*部分，概述了各种设计方法，确立了为未来演进而规划 Operator 设计的良好实践。这些建议的指南（实际上可以应用于许多软件项目）是从小做起，有效迭代，并优雅地废弃。
- en: Now, having gone through the steps of building an Operator from scratch in the
    form of our nginx Operator, it will be helpful to revisit these guidelines and
    examine how they were specifically applied to our own design.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在从头构建 Operator（如我们的 nginx Operator）之后，回顾这些指南并检查它们如何具体应用于我们的设计将会很有帮助。
- en: Starting small
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从小开始
- en: 'The nginx Operator design started out very simple. The Operator was intended
    to serve a very basic function: manage the deployment of an nginx Pod. For configuration
    options, it exposed three fields to control the container port on the Pod, the
    number of replicas to deploy, and an extra field to trigger a forced redeployment.
    As a **minimum viable product** (**MVP**), this served well to get our Operator
    off the ground. While this design was intentionally kept minimal for the purpose
    of a reasonably sized demonstration, it still shows the mindset that keeps Operator
    CRDs from starting out with too many knobs exposed. Shipping excessive configuration
    options can be confusing to users, which then poses potential risks to the stability
    of your product if users cannot fully understand what every option does. This
    also adds a support burden on your own teams.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: nginx Operator 的设计最初非常简单。这个 Operator 旨在提供一个非常基本的功能：管理 nginx Pod 的部署。对于配置选项，它暴露了三个字段来控制
    Pod 上容器端口、部署的副本数以及一个额外的字段来触发强制重部署。作为一个**最小可行产品**（**MVP**），这非常有助于让我们的 Operator
    起步。尽管该设计故意保持简约，以便展示一个合理规模的示例，但它依然体现了一个思维方式，即防止 Operator CRD 在一开始就暴露太多的配置选项。发布过多的配置选项可能会让用户感到困惑，从而导致用户无法完全理解每个选项的作用，这会给产品的稳定性带来潜在风险。同时，这也增加了团队的支持负担。
- en: Remember that the first release of an Operator will actually likely make up
    a minority of its life cycle. There will be plenty of time to add more features
    in future releases, but this becomes difficult as the CRD grows in its API definition
    and new features dilute the viability of existing ones. Of course, that's not
    to say you should never add new features to your Operator or its CRD. But, when
    that time comes, it's important to do so carefully, which is the focus of iterating
    effectively.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Operator 的第一次发布实际上很可能只占其生命周期的一小部分。在未来的发布中将有足够的时间添加更多的功能，但随着 CRD 在 API 定义中的不断扩展以及新功能的加入，现有功能的可行性可能会被稀释。当然，这并不是说你永远不应该向
    Operator 或其 CRD 中添加新功能。但当这个时机到来时，重要的是要谨慎行事，这也是有效迭代的核心。
- en: Iterating effectively
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效地迭代
- en: In this chapter, we introduced an API change to the Operator wherein the type
    of one field was converted to an entirely different nested struct. This effectively
    removed the old field, which would be a breaking change for any user who was already
    relying on that field (in fact, we did technically remove the old field, but more
    on that in a minute). The benefit of changes such as this needs to be weighed
    against the negatives, which include disruption for your users (if applicable)
    and ongoing support for your own team.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了对 Operator API 的变更，其中一个字段的类型被转换成了完全不同的嵌套结构体。这实际上移除了旧的字段，对于任何已经依赖该字段的用户来说，这将是一个破坏性的变更（事实上，我们确实技术上移除了旧字段，但稍后会详细解释）。像这样的变更的好处需要与其负面影响权衡，这些负面影响包括对用户的干扰（如果适用的话）以及对自己团队的持续支持。
- en: In our case, we chose to move from a single `int32` field (named `port`) to
    a list of `v1.ContainerPort` objects (named `ports`). This added some complexity
    to the CRD (because `v1.ContainerPort` contains other nested fields). However,
    it also shifted our CRD to rely on a native, stable API type from upstream Kubernetes.
    This, along with the added functionality of being able to configure multiple ports
    and added fields, offers usability and stability benefits for users and developers
    of the Operator (not that `int32` is likely to be unstable, but the general idea
    remains).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们选择将原来的 `int32` 字段（名为 `port`）替换为一个 `v1.ContainerPort` 对象列表（名为 `ports`）。这增加了
    CRD 的复杂性（因为 `v1.ContainerPort` 包含其他嵌套字段）。然而，这也使我们的 CRD 转向依赖 Kubernetes 上游的一个原生、稳定的
    API 类型。这一点，加上能够配置多个端口和新增字段的功能，为 Operator 的用户和开发者提供了可用性和稳定性的好处（并不是说 `int32` 很可能不稳定，但这个总体思路依然适用）。
- en: Still, this change required the removal of the existing `port` field. This is
    what users must ultimately react to, but that transition can be made smoother
    through graceful deprecation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次变更确实需要移除现有的 `port` 字段。这是用户最终必须响应的变化，但通过优雅的废弃，可以使过渡变得更加平滑。
- en: Deprecating gracefully
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅地废弃
- en: When adding the new `ports` field to our Operator's CRD, a conscious decision
    was made to remove the existing single `port` field, and that's perfectly acceptable;
    in fact, keeping it would have been unnecessarily redundant. But, the fact remains
    that users who were relying on the old field would have to transition to the new
    one or face data loss when their old configurations were migrated to the new ones.
    While that may seem small for something such as a single integer value, the scope
    of degradation can clearly scale with more complex Operators.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在向我们的 Operator 的 CRD 添加新的 `ports` 字段时，经过深思熟虑决定移除现有的单一 `port` 字段，这完全可以接受；实际上，保留它会显得多余。然而，事实是，依赖旧字段的用户必须过渡到新字段，否则在旧配置迁移到新配置时会面临数据丢失的风险。虽然这种变化对于单个整数值来说可能看起来微不足道，但其影响范围在更复杂的
    Operator 中会显得更加明显。
- en: This is why we added a conversion webhook to the Operator, to translate the
    old field into the new one automatically. But that webhook would not have been
    as simple to implement if the new `ports` field wasn't effectively a super-set
    of the old field. Choosing to go with a fairly compatible existing type made this
    transition much easier for developers to implement and users to understand. Design
    decisions such as this greatly help to reduce friction in a growing code base.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为何为 Operator 添加了一个转换 webhook，以自动将旧字段转换为新字段。如果新的 `ports` 字段不是旧字段的超集，实施这个
    webhook 就不会这么简单。选择一个兼容性较强的现有类型使得这个过渡对开发人员的实施和用户的理解变得更加容易。像这样的设计决策大大有助于减少在不断增长的代码库中产生的摩擦。
- en: However, our conversion was not completely perfect. While the transition from
    `v1alpha1` to `v1alpha2` carries over just fine, the reverse can only hold one
    port value (the first from the list). This may be suitable for practical use cases,
    as most users would be more likely to upgrade to the new version than downgrade
    to the deprecated one, but from a support standpoint, lossy conversion like this
    can create headaches down the road. There are ways to address this that are relevant
    to the next section, which discusses how Kubernetes prescribes ways to smoothly
    implement changes.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的转换并不完全完美。虽然从 `v1alpha1` 到 `v1alpha2` 的过渡顺利进行，但反向转换只能保留一个端口值（即列表中的第一个）。这可能适用于实际的使用场景，因为大多数用户更有可能升级到新版本，而不是降级到废弃的版本，但从支持角度来看，这种丢失数据的转换可能会在未来带来麻烦。对此有一些方法可以解决，这与下一节讨论的
    Kubernetes 如何平滑地实现更改相关。
- en: Complying with Kubernetes standards for changes
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循 Kubernetes 对更改的标准
- en: Kubernetes defines a standard set of policies for deprecation (and other breaking
    changes) that all core projects must abide by. This policy is available at [https://kubernetes.io/docs/reference/using-api/deprecation-policy/](https://kubernetes.io/docs/reference/using-api/deprecation-policy/).
    It's not necessary to read and understand the whole policy for the purposes of
    Operator development, as we will highlight some of the relevant bits here. It
    primarily defines the standards for deprecating parts of the Kubernetes API, with
    many of the same (or similar) guidelines being applied to other types of deprecation
    as well (such as user-facing features that are not directly part of the API).
    It does this by enumerating a list of explicit rules for deprecating changes,
    some of which we will cover in this section.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 为所有核心项目定义了一套标准的废弃（以及其他破坏性更改）政策，所有核心项目必须遵守。这些政策可以在[https://kubernetes.io/docs/reference/using-api/deprecation-policy/](https://kubernetes.io/docs/reference/using-api/deprecation-policy/)找到。对于
    Operator 开发而言，并不需要阅读并理解整个政策，我们将在此处重点介绍一些相关部分。它主要定义了废弃 Kubernetes API 部分的标准，其中许多相同（或相似）的准则也适用于其他类型的废弃（例如，面向用户的功能，这些功能不是
    API 的直接一部分）。它通过列出明确的规则来废弃更改，其中一些我们将在本节中讨论。
- en: As a third-party component, your Operator is under no obligation to follow the
    Kubernetes deprecation policy. But, in a practical sense, there are benefits to
    working within the constraints of the ecosystem your Operator is built to be a
    part of. These include a template provided to set expectations for your users
    and a set of guidelines for planning your own ongoing development. And, even if
    you choose not to follow these policies for your own Operator, it is still crucial
    to understand how they are enforced upstream to be prepared for deprecations and
    changes beyond your control that you will eventually inherit.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第三方组件，您的 Operator 并没有义务遵循 Kubernetes 的废弃政策。但在实际操作中，在您 Operator 所构建的生态系统的约束条件下工作是有益的。这些包括提供一个模板来为用户设定期望，以及一套指导方针来规划您自己的持续开发。而且，即使您选择不遵循这些政策，理解它们如何在上游被执行仍然至关重要，以便为您最终需要继承的废弃和变化做好准备。
- en: The full deprecation policy linked at the start of this section goes into specific
    detail for standards that govern every applicable Kubernetes component. So, some
    details of the deprecation are not directly relevant to Operator development.
    However, certain elements, such as those pertaining to the support and removal
    of API fields, do apply to Operators (should you choose to follow them).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开始时提供的完整废弃政策详细说明了管理每个相关 Kubernetes 组件的标准。因此，废弃的一些细节与 Operator 开发并不直接相关。然而，某些元素，比如与
    API 字段支持和移除相关的内容，确实适用于 Operators（如果您选择遵循它们）。
- en: Removing APIs
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除 API
- en: The Kubernetes deprecation policy is very clear on forbidding the removal of
    API elements from the current API version. In fact, this is the first rule in
    the entire policy.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的废弃政策明确禁止从当前 API 版本中移除 API 元素。事实上，这也是整个政策中的第一条规则。
- en: 'Rule #1'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 #1'
- en: API elements may only be removed by incrementing the version of the API group.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: API 元素只能通过增加 API 组版本的方式来移除。
- en: This means that it is forbidden to remove any field or object from an existing
    API. The removal can only be done by introducing a new API version with that element
    removed.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着禁止从现有 API 中移除任何字段或对象。移除操作只能通过引入一个新版本的 API，并删除该元素来完成。
- en: This is relevant to our nginx Operator, where we removed the `port` field that
    was present in `v1alpha1` as we incremented the API version to `v1alpha2`. Following
    this rule ensures that current users of an API version will not have their workflows
    suddenly broken by updating to a new release. The distinction between API versions
    makes a clear indication of some level of incompatibility.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的 nginx Operator 相关，在我们将 API 版本从 `v1alpha1` 升级到 `v1alpha2` 时，移除了 `v1alpha1`
    中存在的 `port` 字段。遵循这一规则可确保当前使用某个 API 版本的用户，在更新到新版本时，其工作流不会突然中断。API 版本之间的区分明确指出了某种程度的不兼容性。
- en: Inversely, this rule allows for the addition of API elements without incrementing
    the version of the existing API. This is because a new element in the current
    API version will not break any existing use cases because it is as if consumers
    of the object are simply leaving this field blank (as opposed to the removal of
    an existing field, which could result in data loss as non-blank entries are dropped).
    This is directly relevant to our use case because it provides an ability for seamless
    conversion.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来说，这条规则允许在不增加现有 API 版本的情况下添加 API 元素。这是因为当前 API 版本中的新元素不会破坏任何现有用例，因为就像消费者只是把这个字段留空一样（与移除现有字段不同，移除字段可能导致数据丢失，因为非空条目会被删除）。这与我们的用例直接相关，因为它提供了无缝转换的能力。
- en: API conversion
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 转换
- en: The second rule of the Kubernetes deprecation policy is as follows.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 废弃政策的第二条规则如下。
- en: 'Rule #2'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 #2'
- en: API objects must be able to round-trip between API versions in a given release
    without information loss, with the exception of whole REST resources that do not
    exist in some versions.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: API 对象必须能够在给定的版本之间进行往返转换而不会丢失信息，除非某些 REST 资源在某些版本中不存在。
- en: This means that when any two API versions exist within the same release of Kubernetes
    (or, in this case, your Operator), objects of either API version must be able
    to convert between the two versions while preserving all data fields.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 Kubernetes 的同一版本中（或者在本例中，指的是您的 Operator），任何两个 API 版本必须能够在保持所有数据字段的同时，相互转换。
- en: In our nginx Operator, we did not follow this rule (because a `v1alpha2` CRD
    object with multiple ports defined cannot translate them all to a single `port`
    value). This is OK because, as a third-party project, we are not beholden to the
    upstream Kubernetes policies. But, from a practical standpoint, it would be useful
    for us and our users to support such lossless conversions. This could be done
    by adding the `ports` field to both `v1alpha2` and `v1alpha1`. Then, our conversion
    could have stored the additional ports in the new field when converting to `v1alpha1`.
    Existing code that only knows about the `v1alpha1` single `port` field may not
    be able to use these additional ports, but the important part is that the data
    is preserved during conversion. Alternatively, we could have simply stored the
    additional `ports` values as an annotation in the CRD object's metadata and read
    from this during conversion.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的nginx Operator中，我们没有遵循这一规则（因为定义多个端口的`v1alpha2` CRD对象不能将它们全部转换为单一的`port`值）。这没问题，因为作为第三方项目，我们不受上游Kubernetes政策的约束。然而，从实际角度来看，支持这种无损转换对我们和我们的用户会非常有用。可以通过向`v1alpha2`和`v1alpha1`都添加`ports`字段来实现。然后，在转换到`v1alpha1`时，我们的转换逻辑可以将额外的端口保存在新字段中。现有代码如果只知道`v1alpha1`中的单个`port`字段，可能无法使用这些额外的端口，但重要的是在转换过程中数据得以保存。或者，我们可以简单地将额外的`ports`值作为注释存储在CRD对象的元数据中，在转换时从中读取。
- en: API lifetime
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API生命周期
- en: How long you choose to support an API version is entirely up to your organization's
    agreement with your users. The Kubernetes standards for support timelines vary
    based on the stability level of that API. The three levels of stability are alpha,
    beta, and general availability (GA).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择支持API版本的时间完全取决于你的组织与用户之间的协议。Kubernetes对支持时间表的标准根据API的稳定性级别有所不同。稳定性有三个级别：alpha、beta和正式发布（GA）。
- en: In our nginx Operator, the API is currently in alpha. Technically, this means
    that there is no support guarantee for any duration. However, when working toward
    graduating an API to a more stable level, it is good practice to operate as if
    that API is already at the next level of stability. For beta APIs, this timeline
    is the longer of 9 months or three releases (see the *Aligning with the Kubernetes
    release timeline* section). APIs that are graduated to GA cannot be removed, but
    they can be marked as deprecated. The intent is that an API that is GA can be
    assumed stable for the lifetime of that major version of Kubernetes.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的nginx Operator中，API当前处于alpha阶段。从技术角度来看，这意味着没有对任何时间段的支持保证。然而，在将API升级到更稳定版本的过程中，最佳实践是以该API已经处于下一个稳定级别的假设来操作。对于beta版本的API，这一时间线通常是9个月或三次发布中的较长者（参见*与Kubernetes发布时间线对齐*部分）。被升级为GA的API不能被删除，但可以标记为废弃。其目标是，GA版本的API可以被认为在Kubernetes的该主版本生命周期内是稳定的。
- en: Removal, conversion, and lifetime are the three main points of the Kubernetes
    deprecation policy relevant to our Operator development. There are more details
    in the link provided at the top of this section. You can also follow the planned
    timeline for upcoming upstream API deprecation, which is published at [https://kubernetes.io/docs/reference/using-api/deprecation-guide/](https://kubernetes.io/docs/reference/using-api/deprecation-guide/),
    for each release.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 删除、转换和生命周期是与我们Operator开发相关的Kubernetes废弃政策的三个关键点。更多细节可以参考本节顶部提供的链接。你也可以根据发布的[https://kubernetes.io/docs/reference/using-api/deprecation-guide/](https://kubernetes.io/docs/reference/using-api/deprecation-guide/)上的计划时间表，跟踪即将到来的上游API废弃，适用于每个版本。
- en: While this section mentioned the Kubernetes release as a unit of time, we did
    not define exactly how much time that is. In the next section, we will explain
    exactly how the Kubernetes release breaks down and how it relates to your Operator
    development.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节提到Kubernetes发布作为时间单位，但我们没有明确说明具体的时间长度。在下一节中，我们将详细解释Kubernetes发布的分解方式，以及它如何与您的Operator开发相关。
- en: Aligning with the Kubernetes release timeline
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Kubernetes发布时间线对齐
- en: Each new release of Kubernetes is driven by the hard work and dedication of
    many people from different companies and time zones. This process for publishing
    a new version of Kubernetes is, therefore, the product of an orchestration effort
    among component areas and **special interest groups** (**SIGs**) to ensure timely,
    stable releases. While there are occasional roadblocks and delays, the release
    timeline is, for the most part, a well-defined collaborative effort that strives
    to provide predictable updates that the Kubernetes ecosystem of users and downstream
    products can depend on.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新版本的 Kubernetes 都是由来自不同公司和时区的许多人的辛勤工作和奉献推动的。因此，发布新版本的过程是组件领域和**特别兴趣小组**（**SIGs**）之间协调努力的产物，以确保及时、稳定的发布。虽然偶尔会遇到障碍和延迟，但发布时间表在很大程度上是一个定义良好的协作努力，力求提供可预测的更新，以便
    Kubernetes 生态系统的用户和下游产品依赖。
- en: When developing an Operator, you or your organization will likely have similar
    organized release efforts. You also want to provide a dependable and timely schedule
    for shipping updates to your users. And, while your own release schedule may differ
    from the Kubernetes timeline, there are still benefits to a keen understanding
    of how the upstream release works. For example, it offers you the ability to plan
    around specific dates at which a beta API will be promoted to GA, or an entirely
    new feature will become available that you can leverage in your own product to
    pass on to your users. On the other hand, it also outlines the remaining time
    that deprecated APIs have before they are removed entirely. As a product vendor,
    you can rely on this timeline to guide your release planning.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Operator 时，您或您的组织可能会有类似的组织化发布努力。您还希望为用户提供可靠和及时的更新时间表。尽管您自己的发布时间表可能与 Kubernetes
    的时间表不同，但了解上游发布工作的方式仍然具有重要意义。例如，它使您能够计划围绕特定日期进行，例如 beta API 升级为 GA 或者完全新功能的发布，这些都是您可以在自己的产品中利用并传递给用户的。另一方面，它还概述了废弃的
    API 在被完全移除之前的剩余时间。作为产品供应商，您可以依靠此时间表指导您的发布计划。
- en: For these reasons, aligning your Operator's release timeline for updates with
    that of Kubernetes is a valuable effort and it's why we will explain that timeline
    more in this section.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，将您的 Operator 发布时间表与 Kubernetes 的更新保持一致是一项有价值的工作，这也是我们在本节中将更详细地解释该时间表的原因。
- en: Overview of a Kubernetes release
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 发布概述
- en: The Kubernetes release cycle is approximately 15 weeks long. As of Kubernetes
    1.22, this has defined a goal of three releases per calendar year. Of course,
    three 15-week releases do not account for an entire 52-week-long year. This is
    because the release cycle allows for several breaks in work, including holidays,
    end-of-year travel, and events or conferences such as **KubeCon**. This timeline
    was decided on by the SIG Release team with input from the community, and you
    can read more details about the decision in a blog post at [https://kubernetes.io/blog/2021/07/20/new-kubernetes-release-cadence/](https://kubernetes.io/blog/2021/07/20/new-kubernetes-release-cadence/).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 发布周期约为 15 周。截至 Kubernetes 1.22 版本，这已经定义了每年三个版本的目标。当然，三个 15 周的发布并不能覆盖整个
    52 周的一年。这是因为发布周期允许多次工作中断，包括假期、年底旅行以及 KubeCon 等事件或会议。此时间表由 SIG Release 团队在社区的参与下决定，您可以在[https://kubernetes.io/blog/2021/07/20/new-kubernetes-release-cadence/](https://kubernetes.io/blog/2021/07/20/new-kubernetes-release-cadence/)的博客文章中详细了解这一决定的更多细节。
- en: 'During the course of a single release, there are several key dates that signal
    important progress updates in that release. These include an **Enhancements Freeze**,
    **Code Freeze**, deadlines for documentation updates and blog posts, and **release
    candidate** (**RC**) version releases. The exact timeline for each release is
    posted in the SIG Release GitHub repository at [https://github.com/kubernetes/sig-release](https://github.com/kubernetes/sig-release).
    As an example, the Kubernetes 1.24 release cycle looked like the following, with
    some of these key dates highlighted:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个发布周期中，有几个关键日期标志着该发布中的重要进展更新。这些包括**功能冻结**、**代码冻结**、文档更新和博客文章的截止日期，以及**发布候选版**（**RC**）版本的发布。每个发布的确切时间表都发布在
    SIG Release GitHub 仓库的[https://github.com/kubernetes/sig-release](https://github.com/kubernetes/sig-release)中。例如，Kubernetes
    1.24 发布周期如下所示，并突出显示了一些关键日期。
- en: '![Figure 8.2 – Kubernetes 1.24 release cycle calendar](img/B18147_08_002.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Kubernetes 1.24 发布周期日历](img/B18147_08_002.jpg)'
- en: Figure 8.2 – Kubernetes 1.24 release cycle calendar
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Kubernetes 1.24 发布周期日历
- en: Each of these dates plays an important role in the progression of an individual
    release. In the following sections, we'll explain what each of them means in more
    detail and how they can relate to your own release cycle for your Operator. Much
    of this information is also documented in the SIG Release repository at [https://github.com/kubernetes/sig-release/blob/master/releases/release_phases.md](https://github.com/kubernetes/sig-release/blob/master/releases/release_phases.md).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日期在单个版本的推进中都起着重要作用。在接下来的章节中，我们将详细解释每个日期的含义，以及它们如何与你的 Operator 发布周期相关联。很多这些信息也记录在
    SIG Release 仓库中，地址为 [https://github.com/kubernetes/sig-release/blob/master/releases/release_phases.md](https://github.com/kubernetes/sig-release/blob/master/releases/release_phases.md)。
- en: Start of release
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布开始
- en: Fairly self-explanatory, this is the official date that the release cycle for
    the next version of Kubernetes begins. This provides a reference date from which
    all other steps in the cycle can be derived. Note that this is not the same date
    as the previous release's publication because of the buffer between release cycles,
    along with post-release processes such as **Retrospective**. So, there may already
    be work-in-progress for the current release before this date (see the *GA release/Code
    Thaw* subsection). However, just as any race needs a starting line, every release
    needs a date to denote its official beginning.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日期是相当直观的，表示下一个版本的 Kubernetes 发布周期的正式开始日期。这为周期中的所有其他步骤提供了参考日期。请注意，这与上一个版本的发布时间不同，因为版本之间存在缓冲期，以及发布后流程，如
    **回顾**。因此，在这个日期之前，当前版本可能已经在进行中的工作（请参见 *GA 发布/代码解冻* 小节）。然而，就像任何比赛需要一个起跑线一样，每个发布也需要一个日期来标志其正式开始。
- en: Enhancements Freeze
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强功能冻结
- en: New features in Kubernetes take many forms. While all changes to the platform
    are valuable regardless of size, certain undertakings involve increased effort
    and a broadened scope of work. Examples include significant user-facing changes
    or architectural designs involving collaboration between multiple components and
    SIGs. Such features require additional management to ensure their successful rollout.
    At this point, the feature may be considered as an **enhancement** or **Kubernetes
    Enhancement Proposal** (**KEP**).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的新功能有多种形式。尽管所有平台的变更都是有价值的，不论大小，但某些工作需要更多的努力，并且工作范围更广。例子包括显著面向用户的变更或涉及多个组件和
    SIG 协作的架构设计。这些特性需要额外的管理，以确保它们的成功推出。在这一阶段，特性可能会被视为 **增强功能** 或 **Kubernetes 增强提案**
    (**KEP**)。
- en: We have already mentioned several individual KEPs in this book. For example,
    in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an Operator
    – Advanced Functionality,* we referred to `Condition` type for components to report
    their status (including our nginx Operator). All KEPs such as this are tracked
    in the *Kubernetes Enhancements* GitHub repository at [https://github.com/kubernetes/enhancements](https://github.com/kubernetes/enhancements).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中已经提到过几个单独的 KEP。例如，在 [*第 5 章*](B18147_05_ePub.xhtml#_idTextAnchor078)，《开发
    Operator – 高级功能》中，我们提到了 `Condition` 类型，用于组件报告其状态（包括我们的 nginx Operator）。所有此类 KEP
    都会在 *Kubernetes Enhancements* GitHub 仓库中跟踪，地址为 [https://github.com/kubernetes/enhancements](https://github.com/kubernetes/enhancements)。
- en: The full details of the KEP process and repository are beyond the scope of this
    book, but the essential knowledge is that KEPs signify wide-scale design changes
    that can impact users or consumers of APIs. As the developer of an Operator, which
    is itself a component that may consume one or more upstream APIs (such as the
    `Condition` field), it is then important to be aware of the status of upcoming
    changes of this scale, as they may directly affect you. Providing this information
    is the goal of the KEP process.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: KEP 过程和仓库的完整细节超出了本书的范围，但基本知识是，KEP 代表大规模的设计变更，这些变更可能会影响 API 的用户或消费者。作为一个 Operator
    的开发者，Operator 本身是一个可能会使用一个或多个上游 API（例如 `Condition` 字段）的组件，因此了解即将发生的这类大规模变更的状态非常重要，因为它们可能会直接影响你。提供这些信息就是
    KEP 过程的目标。
- en: During a release cycle, the Enhancements Freeze stage signifies the point at
    which all proposed KEPs for that release must be either accepted and committed
    toward implementing their changes or delayed for a future release. This is the
    critical *go*/*no-go* date for moving forward with a KEP for that release. And,
    while many in-progress KEPs are able to proceed at this point, there may be a
    reasonable justification why certain changes may not be able to commit to the
    release by this date. In these cases, the developers of an enhancement may request
    an **exception** during the *Call for Exceptions* period, described next.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个发布周期中，增强功能冻结阶段标志着所有为该发布提出的KEP必须在此时被接受并承诺实施其变更，或者推迟到未来的发布版本。这是决定该发布是否推进的关键*Go*/*No-Go*日期。尽管许多进行中的KEP此时可以继续，但也可能有合理的理由解释某些变更无法在此日期之前承诺到发布版本中。在这些情况下，增强功能的开发者可以在接下来的*异常请求征集*期间请求**异常**。
- en: For Operator developers, the Enhancements Freeze deadline is an important date
    to keep in mind during your own development cycle because, while KEPs are often
    used to introduce new features to Kubernetes, part of their definition is to outline
    the removal of other features (such as any that are being replaced). Being aware
    of any features you depend on being officially slated for removal helps to gauge
    the urgency with which you will need to react to that removal. On the other hand,
    knowing that a KEP missed the deadline for Enhancements Freeze can provide assurance
    that any related features planned for removal will continue to be supported for
    at least another release unless that plan receives an exception.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Operator开发者来说，增强功能冻结截止日期是你在自己的开发周期中需要牢记的一个重要日期，因为虽然KEP通常用于向Kubernetes引入新特性，但它们的定义之一也是概述其他功能的移除（比如被替代的功能）。了解您依赖的任何功能是否被正式列为移除有助于评估您需要多紧急地对移除做出反应。另一方面，如果一个KEP错过了增强功能冻结的截止日期，那么可以放心，任何计划移除的相关功能将在至少另一个发布周期内继续得到支持，除非该计划获得异常批准。
- en: Call for Exceptions
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常请求征集
- en: If, during the course of a release, a certain feature is not yet ready to commit
    to Enhancement Freeze (or *Code Freeze*), the contributors and participating SIGs
    who are working on that enhancement may request an exception to the freeze deadlines.
    If approved, this allows those contributors a reasonable extension to accommodate
    the additional time needed to prepare the enhancement for release.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在发布过程中，某个功能还没有准备好提交到增强功能冻结（或*代码冻结*）中，参与该增强功能开发的贡献者和SIG可以请求延长冻结的截止日期。如果获得批准，这将允许这些贡献者在准备好发布的过程中获得合理的延期。
- en: Enhancements seeking an exception need to meet certain criteria to ensure that
    they do not risk impacting the stability of the platform or delaying the release.
    Therefore, release managers evaluate each exception request based on its scope,
    the estimated extension time requested, and the time at which the request was
    submitted within the release cycle.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 寻求异常的增强功能需要满足一定的标准，以确保它们不会影响平台的稳定性或延迟发布。因此，发布经理根据异常请求的范围、请求的估算延期时间以及请求在发布周期中提交的时间来评估每个异常请求。
- en: Exception requests and approvals are generally communicated via the participating
    SIG's mailing lists, Slack channels, and the specific KEP issue discussion page
    on GitHub. This is why it's important to monitor these communication channels
    for features your Operator implements or depends on. Just because a new feature
    missed Enhancements Freeze, that doesn't mean it won't be implemented until an
    exception has been officially denied. The same goes for planned removals, in the
    event that an exception is granted. Knowing whether the upstream SIG related to
    your Operator's function is going to request any exceptions after Enhancements
    Freeze (or Code Freeze) is a good signal for what to commit to in your Operator's
    development cycle.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 异常请求和批准通常通过参与的SIG的邮件列表、Slack频道以及GitHub上的具体KEP问题讨论页面进行沟通。因此，监控这些沟通渠道对于了解你的Operator所实现或依赖的功能至关重要。即使一个新特性错过了增强功能冻结（Enhancements
    Freeze）日期，也不意味着在官方拒绝异常请求之前，它就不会被实现。对于计划移除的特性也是如此，如果获得了异常批准的话。了解与您的Operator功能相关的上游SIG在增强功能冻结（或代码冻结）后是否会请求任何异常，是判断您在Operator开发周期中需要承诺的内容的一个重要信号。
- en: Code Freeze
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码冻结
- en: Code Freeze is the point during the release cycle at which all code changes
    must be complete and merged into the Kubernetes code base (besides any features
    that have been granted an exception). This signifies that no more changes will
    be accepted into the release unless they are critical to the stability of the
    platform.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 代码冻结是发布周期中的一个时刻，在此时，所有的代码更改必须完成并合并到Kubernetes代码库中（除了那些被授予例外的功能）。这意味着，除非是对平台稳定性至关重要的更改，否则不再接受任何更改。
- en: As the developer of a downstream Operator, this is relevant to your own project
    timeline because it is the point at which you can begin updating your libraries
    to the latest Kubernetes version with a reasonable expectation of stability. This
    can be done by updating your dependencies to the latest RC version of the upstream
    Kubernetes libraries.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下游Operator的开发者，这与你自己的项目时间表相关，因为这是你可以开始将库更新到最新Kubernetes版本的时机，并且可以合理预期其稳定性。可以通过将依赖项更新到上游Kubernetes库的最新RC版本来完成此操作。
- en: The first RC for a new release is usually published soon after the Code Freeze
    date. This timing allows developers to update dependencies with additional *soak
    time* to catch any additional updates or reactions that need to be made in order
    to function with the new version of Kubernetes before it is finally released.
    It is very beneficial to take advantage of this timing to minimize the delay between
    publishing your updated Operator after the Kubernetes version release. Due to
    the size and fluctuating nature of Kubernetes, it's recommended to upgrade any
    upstream dependencies regularly. Failure to do so is likely to result in snowballing
    technical debt and eventual lack of compatibility with newer versions of the platform.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的第一个RC通常会在代码冻结日期后不久发布。这个时机使得开发者能够更新依赖项，并有额外的*缓冲时间*来捕捉任何需要更新或修改的内容，以确保与新版本的Kubernetes兼容，并在最终发布之前进行调整。利用这个时机是非常有益的，有助于最小化在Kubernetes版本发布后发布更新的Operator的延迟。由于Kubernetes的规模和波动性，建议定期升级任何上游依赖项。否则，可能会导致技术债务累积，并最终与平台的新版本不兼容。
- en: Test Freeze
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试冻结
- en: While Code Freeze defines a strict deadline for enhancements to have their implementations
    completely merged, Test Freeze allows an additional buffer to expand test coverage.
    This provides an opportunity to improve test cases once a feature has merged before
    release. After this date, the only changes allowed to any tests are to fix or
    remove tests that are consistently failing. This date may not have a consistent
    impact on your own release cycle, but it is a good signal to be aware of when
    monitoring the progress of a key enhancement.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码冻结定义了一个严格的期限，要求所有增强功能的实现必须完全合并，但测试冻结提供了额外的缓冲时间以扩展测试覆盖范围。这为在发布之前，一旦功能合并后，改进测试用例提供了机会。在此日期之后，允许对任何测试的唯一更改是修复或移除那些持续失败的测试。这个日期可能对你自己的发布周期没有一致的影响，但它是监控关键增强功能进展时需要关注的一个重要信号。
- en: GA release/Code Thaw
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GA发布/代码解冻
- en: 'At last, the moment everyone has been waiting for. If there are a few problems
    discovered during the release that cause a delay, this is the date that Kubernetes
    releases its newest version. For developers, this means that the code in Kubernetes
    (at [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes))
    is updated with a new Git tag, which allows the opportunity to easily reference
    the release point at a definitive point in code (for example, when updating your
    Operator''s dependencies in its `go.mod` file). In addition, the client libraries
    that support Kubernetes and its subprojects are also updated, including the following:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，大家期待的时刻到了。如果在发布过程中发现一些问题导致延迟，这是Kubernetes发布最新版本的日期。对于开发者而言，这意味着Kubernetes中的代码（在[https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)上）将会更新一个新的Git标签，这使得你可以轻松地在代码中的某个确定点引用发布版本（例如，在更新Operator的依赖项时，更新其`go.mod`文件）。此外，支持Kubernetes及其子项目的客户端库也会更新，包括以下内容：
- en: '[https://github.com/kubernetes/api](https://github.com/kubernetes/api) – Core
    API types used by the Kubernetes platform (imported as `k8s.io/api`)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/api](https://github.com/kubernetes/api) – Kubernetes平台使用的核心API类型（作为`k8s.io/api`导入）'
- en: '[https://github.com/kubernetes/apimachinery](https://github.com/kubernetes/apimachinery)
    – The library used to implement the encoding and decoding of API types in code
    (`k8s.io/apimachinery`)'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/apimachinery](https://github.com/kubernetes/apimachinery)
    – 用于实现代码中API类型编码和解码的库（`k8s.io/apimachinery`）'
- en: '[https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go)
    – The Go client used by Operators and other programs to interact with Kubernetes
    resources programmatically (`k8s.io/client-go`)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go)
    – Operators 和其他程序用于通过编程方式与 Kubernetes 资源交互的 Go 客户端 (`k8s.io/client-go`)'
- en: These are just a few of the additional dependencies that, on GA release day,
    will be updated with a new Git tag. These dependencies are actually part of the
    core Kubernetes repository (`k8s.io/kubernetes`), but they are synced to symbolic
    canonical locations by an automated bot for better dependency management. This
    can sometimes cause a slight delay between core Kubernetes releasing its tag and
    the libraries updating with their own (which are usually more important to developers).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些额外的依赖项，在 GA 发布当天，它们会通过新的 Git 标签进行更新。这些依赖项实际上是核心 Kubernetes 仓库 (`k8s.io/kubernetes`)
    的一部分，但它们通过自动化机器人同步到符号化的标准位置，以便更好地进行依赖管理。这有时会导致核心 Kubernetes 发布标签和库更新之间出现短暂的延迟（通常开发者更关注的是库的更新）。
- en: Kubernetes as a Dependency
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 作为依赖项
- en: The core Kubernetes repository at `k8s.io/kubernetes` (or [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes))
    contains all of the code needed by the core platform components. So, it may be
    tempting to import code from here directly. However, due to its complexity, it
    is not recommended to import code from `k8s.io/kubernetes` directly into your
    project as it can cause dependency issues that are difficult to resolve with Go
    modules and bring excess transitive dependencies into your project. Instead, it
    is best to rely on the component libraries (such as those listed previously),
    which are meant to be imported into outside projects.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 核心 Kubernetes 仓库 `k8s.io/kubernetes`（或 [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)）包含了核心平台组件所需的所有代码。因此，直接从这里导入代码可能会很有诱惑力。然而，由于其复杂性，不建议直接将
    `k8s.io/kubernetes` 中的代码导入到你的项目中，因为这可能会导致依赖问题，这些问题使用 Go 模块很难解决，并且会将多余的传递依赖项引入你的项目中。相反，最好依赖于组件库（例如之前列出的那些库），这些库旨在被导入到外部项目中。
- en: After the new release is officially published, the Kubernetes project enters
    `master` (or `main`) branch at any point after this really means you are interacting
    with the `N+1` version code (where `N` is the current version of Kubernetes).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本正式发布后，Kubernetes 项目进入 `master`（或 `main`）分支，此时意味着你正在与 `N+1` 版本的代码进行交互（其中 `N`
    是当前的 Kubernetes 版本）。
- en: Retrospective
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: When the dust has settled, the SIG Release team takes time to review the release
    during **Retrospective**. The intent of Retrospective is to meet and discuss any
    roadblocks or concerns that occurred during that release and propose solutions
    to address them in the future. In addition, any exceptional successes are identified
    and praised. It is meant as a blameless process through which the end goal is
    simply to reduce friction for future releases. While the specific details of the
    Retrospective may not be directly relevant to the development of your Operator
    (the focus is generally more on the release infrastructure and processes that
    drive the release rather than specific feature changes), it can be a very informative
    way to be aware of future changes to the release cycle.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当尘埃落定后，SIG Release 团队会花时间回顾此次发布过程，进行 **回顾**。回顾的目的是开会讨论在发布过程中出现的任何障碍或问题，并提出解决方案以避免未来再次发生。此外，任何突出的成功也会被识别并予以表扬。这个过程是无责备的，最终目标是减少未来发布中的摩擦。虽然回顾的具体细节可能与开发你的
    Operator 关系不大（回顾的重点通常更多放在发布基础设施和驱动发布的过程上，而非具体的功能更改），但它可以是了解未来发布周期变化的一种非常有价值的方式。
- en: All of the above dates form the most important signals in the Kubernetes release
    cycle. Being aware of them can help inform your team about the status of the current
    features you depend on, and that information can be passed on in the form of the
    commitments you make to your users. Staying up to date with the latest Kubernetes
    releases is critical to avoid tiresome technical debt from piling up, as the Kubernetes
    project is constantly evolving within the support constraints it offers.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有日期构成了 Kubernetes 发布周期中最重要的信号。了解这些信息有助于通知你的团队关于当前你所依赖的功能的状态，并且这些信息可以通过你对用户的承诺传递出去。保持对最新
    Kubernetes 发布的关注至关重要，这样可以避免技术债务不断积累，因为 Kubernetes 项目在它所提供的支持限制内持续发展。
- en: In addition, knowing where you are in the current release cycle also provides
    the opportunity to contribute to Kubernetes at meaningful times. In the next section,
    we will discuss ways you can do this and how it can benefit you.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解自己在当前发布周期中的位置，也为你在合适的时机贡献 Kubernetes 提供了机会。在下一部分中，我们将讨论你可以如何做到这一点，以及它如何为你带来好处。
- en: Working with the Kubernetes community
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Kubernetes 社区合作
- en: This chapter focused heavily on the standards, policies, and timelines of Kubernetes
    as they relate to Operator development. While it might seem that these are fixed,
    prescriptive decrees, the reality is that they are fluid frameworks for development
    created through an open and fair process. This process is organized by contributors
    from different companies all over the world, and it is always open to new voices.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了与 Operator 开发相关的 Kubernetes 标准、政策和时间表。虽然这些标准看似固定、具有约束力，但实际上它们是通过一个开放、公平的过程创建的灵活框架。这个过程由来自世界各地的不同公司贡献者组织，始终欢迎新的声音。
- en: As a developer for the Kubernetes platform, you have inherent stock in the community
    that organizes Kubernetes upstream. Therefore, improvements or concerns that affect
    you are likely to affect others as well. This is why it's not only OK but encouraged
    that you play an active role in upstream development alongside your own Operator.
    If nothing else, doing so serves to benefit your own development, as the open
    process allows you to help steer upstream work as you feel it should be done.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Kubernetes 平台的开发者，你在组织 Kubernetes 上游的社区中有着固有的份额。因此，影响到你的改进或关注点，很可能也会影响到其他人。这就是为什么不仅是可以，而且鼓励你在开发自己的
    Operator 时，积极参与上游开发的原因。如果没有别的，参与其中也有助于你的自身发展，因为开放的流程让你可以帮助指导上游工作，确保它按你认为合适的方式进行。
- en: Getting involved is as simple as sending a message or joining a video call.
    The various GitHub repositories and Slack channels shown in other chapters for
    support are a great place to offer support yourself. The Kubernetes Slack server
    is [slack.k8s.io](http://slack.k8s.io), and it is free to join and contribute.
    You may also want to follow the various SIG meetings for topics of interest, all
    of which are listed on the *Kubernetes Community* repository at [https://github.com/kubernetes/community](https://github.com/kubernetes/community).
    This repository includes links and schedules for all SIG and community meetings.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 参与社区活动非常简单，只需发送一条消息或加入视频通话即可。在其他章节中提到的各种 GitHub 仓库和 Slack 频道是一个提供支持的好地方，你也可以在这些地方提供帮助。Kubernetes
    的 Slack 服务器是[slack.k8s.io](http://slack.k8s.io)，加入并贡献是免费的。你可能还想关注各种 SIG 会议，了解你感兴趣的主题，所有会议都可以在[https://github.com/kubernetes/community](https://github.com/kubernetes/community)上的
    *Kubernetes Community* 仓库中找到。这些仓库包括了所有 SIG 和社区会议的链接和时间表。
- en: Summary
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: Once, in an interview, champion football quarterback Tom Brady was asked which
    of his championship rings was his favorite, to which he replied, "The next one."
    Coming from a person who many already considered to be one of the most successful
    in his field, that response showed powerful commitment to a continuous pursuit
    of achievement (if not a little tongue-in-cheek hubris). As software developers,
    that same passion is what drives the never-ending cycle of improvement with every
    new release.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，在一次采访中，传奇橄榄球四分卫汤姆·布雷迪被问到哪一枚冠军戒指是他最喜欢的，他回答道：“下一个。”来自一个被许多人认为是自己领域中最成功的人，这个回答展示了他对持续追求成就的强大承诺（即便带着一点点自负）。作为软件开发者，这种同样的激情驱动着每次新版本发布时无休止的改进循环。
- en: 'This chapter was about the part of the Operator development cycle that is even
    more important than the first release: the next one. Releasing new software versions
    is not something that is exclusive to Operators, but the idiomatic processes and
    upstream Kubernetes standards do create a unique set of requirements for Operator
    projects. By exploring the technical steps necessary to create and publish a new
    version, alongside the more abstract policies and timelines that dictate guidelines
    for doing so, we have ensured that you are aware of a few suggestions for how
    to keep your Operator running for many releases to come.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Operator 开发周期中比第一次发布更重要的部分：下一个版本。发布新版本的软件并非只有 Operator 才需要做的事情，但惯用的流程和
    Kubernetes 上游标准确实为 Operator 项目创建了独特的要求。通过探索创建和发布新版本所需的技术步骤，以及那些指导发布的更抽象的政策和时间表，我们确保你了解了一些建议，帮助你保持
    Operator 的持续更新。
- en: This concludes the technical tutorial section of this book. While there are
    many topics and details that, unfortunately, did not fit within the scope of these
    chapters, we have explained all of the foundational concepts to build an Operator
    following the Operator Framework. In the next chapter, we'll summarize these concepts
    in an FAQ-style format to quickly refresh what was covered.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的技术教程部分到此结束。虽然有许多话题和细节遗憾地未能包含在这些章节中，但我们已经解释了构建一个操作符所需的所有基础概念，遵循操作符框架。 在下一章中，我们将以常见问题解答的形式总结这些概念，快速回顾我们所涵盖的内容。
