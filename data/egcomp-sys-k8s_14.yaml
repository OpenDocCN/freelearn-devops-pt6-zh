- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Computer Vision with Python and K3s Clusters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 和 K3s 集群的计算机视觉
- en: '**Artificial intelligence** (**AI**) is commonly used to substitute activities
    that humans do every day. It can give systems the intelligence to operate autonomously
    without human intervention in most cases. **Computer vision** (**CV**) is a subcategory
    of AI that focuses on detecting objects in videos and images. CV is often used
    to detect traffic in a city. This chapter focuses on building a basic smart traffic
    system that consists of detecting objects such as cars, trucks, and pedestrians
    when a vehicle is moving. For this, the system uses the OpenCV, TensorFlow, and
    scikit-learn Python libraries and a camera to perform computer vision at the edge
    on a Raspberry Pi. This system also shows locally to drivers a map within the
    detected objects, and it also implements a public map for global detected object
    visualization. This public map can be used as a real-time traffic state map that
    municipalities can use.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）通常用于替代人类每天进行的活动。在大多数情况下，它可以赋予系统智能，使其能够在没有人工干预的情况下自主运行。**计算机视觉**（**CV**）是人工智能的一个子类别，专注于检测视频和图像中的物体。计算机视觉通常用于检测城市中的交通流量。本章重点介绍构建一个基本的智能交通系统，该系统能够在车辆行驶时检测到诸如汽车、卡车和行人等物体。为此，系统使用了
    OpenCV、TensorFlow 和 scikit-learn Python 库以及一个相机，在 Raspberry Pi 上执行边缘计算的计算机视觉。该系统还在本地为司机显示包含检测物体的地图，并实现了一个公共地图，用于全局检测物体的可视化。这个公共地图可以作为实时交通状态图，供市政部门使用。'
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Computer vision and smart traffic systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机视觉和智能交通系统
- en: Using Redis to store temporary object **Global Positioning System** (**GPS**)
    positions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 存储临时物体 **全球定位系统**（**GPS**）位置
- en: Deploying a computer vision service to detect car obstacles using OpenCV, TensorFlow
    Lite, and scikit-learn
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署计算机视觉服务以使用 OpenCV、TensorFlow Lite 和 scikit-learn 检测汽车障碍物
- en: Deploying the edge application to visualize warnings based on computer vision
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署边缘应用以基于计算机视觉可视化警告
- en: Deploying a global visualizer for the smart traffic system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署智能交通系统的全局可视化器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To deploy our computer vision system in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中部署计算机视觉系统，你将需要以下内容：
- en: A Kubernetes cluster hosted in your public cloud provider (**Amazon Web Services**
    (**AWS**), Azure, **Google Cloud Platform** (**GCP**)).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的公共云提供商（**Amazon Web Services**（**AWS**）、Azure、**Google Cloud Platform**（**GCP**））中托管的
    Kubernetes 集群。
- en: A Raspberry Pi 4B with an 8-GB micro **Secure Digital** (**SD**) card with a
    small-monitor **liquid-crystal display** (**LCD**) screen to use in a car.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台带有 8GB 微型 **Secure Digital**（**SD**）卡和小型 **液晶显示器**（**LCD**）屏幕的 Raspberry Pi
    4B，用于汽车中。
- en: A Logitech C922 PRO webcam, recommended because of its quality and support on
    Linux.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款 Logitech C922 PRO 网络摄像头，推荐使用，因为其质量优良并支持 Linux 系统。
- en: Multiple VK-162 G-Mouse USB GPS Dongle Navigation modules, for your edge Raspberry
    devices.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个 VK-162 G-Mouse USB GPS 导航模块，用于你的边缘 Raspberry 设备。
- en: Basic knowledge of AI.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能的基本知识。
- en: '`kubectl` configured to be used in your local machine for your Kubernetes cloud
    cluster to avoid using the `--kubeconfig` parameter.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 `kubectl` 以便在本地机器上使用你的 Kubernetes 云集群，避免使用 `--kubeconfig` 参数。
- en: Clone the [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch14](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch14)
    repository if you want to run the `kubectl apply` instead of copying the code
    from the book. Take a look at the `python` directory inside the `code` directory
    and the `yaml` directory for YAML configurations that are inside the `ch14` directory.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆[https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch14](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch14)
    仓库，如果你想运行 `kubectl apply` 而不是从书中复制代码。查看 `code` 目录中的 `python` 目录，以及 `ch14` 目录中的
    `yaml` 目录，里面包含了 YAML 配置文件。
- en: With this, you can deploy Prometheus and Grafana to start experiment monitoring
    in edge environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你可以部署 Prometheus 和 Grafana 来开始在边缘环境中进行实验性监控。
- en: Computer vision and smart traffic systems
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机视觉和智能交通系统
- en: 'AI is an area of computer science that consists of simulating human intelligence
    using mathematics, statistics, linguistics, computer science, and other sciences.
    AI can also be defined as the study of rational agents, as depicted in the following
    diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能（AI）是计算机科学的一个领域，旨在通过数学、统计学、语言学、计算机科学及其他科学模拟人类智能。人工智能也可以定义为理性代理的研究，如下图所示：
- en: '![Figure 14.1 – Agents'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.1 – 代理]'
- en: '](img/B16945_14_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_14_01.jpg)'
- en: Figure 14.1 – Agents
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 代理
- en: Taking *Figure 14.1* as a reference, an agent receives perceptions coming from
    the environment. These perceptions are captured by sensors, and this information
    is processed to perform an action using effectors. Actions are decided by internal
    rules installed inside the agent. These actions involve the use of effectors such
    as arms, legs, or wheels, for example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以*图 14.1*为参考，代理接收来自环境的感知。这些感知由传感器捕捉，信息经过处理后，通过效应器执行动作。这些动作由安装在代理内部的内部规则决定。动作可能包括使用效应器，如手臂、腿或车轮等。
- en: These internal rules can be implemented using different **machine learning**
    (**ML**) paradigms such as **supervised learning** (**SL**), **unsupervised learning**
    (**UL**), and **reinforcement learning** (**RL**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内部规则可以通过不同的**机器学习**（**ML**）范式来实现，例如**监督学习**（**SL**）、**无监督学习**（**UL**）和**强化学习**（**RL**）。
- en: 'ML is a type of AI that uses historical data as input to do predictions. Computer
    vision is a subset of ML applied to image and video analysis using predictions.
    In our chapter, we are going to do predictions about what our agent is capturing
    using a camera and take decisions according to that information, but we are going
    to apply computer vision to create a smart traffic system. Let’s have a look at
    the following diagram, which shows how our system will be implemented to create
    a smart traffic system using computer vision at the edge:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习（ML）是一种利用历史数据作为输入进行预测的人工智能技术。计算机视觉是应用于图像和视频分析的机器学习子集，使用预测来实现分析。在我们这一章中，我们将根据代理通过摄像头捕获的信息进行预测，并据此做出决策，同时将计算机视觉应用于创建智能交通系统。让我们来看一下以下的图示，展示了我们的系统如何在边缘使用计算机视觉来创建智能交通系统：
- en: '![Figure 14.2 – Smart traffic system using computer vision'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.2 – 使用计算机视觉的智能交通系统'
- en: '](img/B16945_14_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_14_02.jpg)'
- en: Figure 14.2 – Smart traffic system using computer vision
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 使用计算机视觉的智能交通系统
- en: 'Smart traffic systems are often used by municipalities to improve safety, and
    traffic flow on streets in a cost-effective way. Our system can be used in two
    modes. The static mode uses a camera in a static location point in the city, and
    the dynamic mode uses a car to scan traffic where the car is moving. We are going
    to use the dynamic mode. Now, let’s explain our system using the layers of the
    edge computing systems, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 智能交通系统通常被市政府用来提高安全性，并以具有成本效益的方式改善街道上的交通流量。我们的系统可以在两种模式下使用。静态模式使用位于城市静止位置的摄像头，而动态模式则使用移动中的汽车扫描交通情况。我们将使用动态模式。现在，让我们通过边缘计算系统的各层来解释我们的系统，如下所示：
- en: '**Cloud layer**: Here, we are going to use an **application programming interface**
    (**API**) called **Traffic Manager** that stores all detected objects at the edge
    in a Redis instance. The data stored will contain the type of object—car, truck,
    and person—which represents a level 1 warning on our system and the GPS coordinates.
    This means that a vehicle driver will be warned of previously detected objects
    by other drivers. Our API will store the GPS position of these objects, which
    potentially could be obstacles for a vehicle. This layer will also include a frontend
    application called **Traffic Map Public** that shows the objects detected on a
    map. This application could be used by the municipality to monitor all traffic
    across the city.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云层**：在这一层，我们将使用一个名为**Traffic Manager**的**应用程序编程接口**（**API**），它将所有在边缘检测到的对象存储在Redis实例中。存储的数据将包含对象的类型——如汽车、卡车和行人——这代表我们系统中的一级警告，以及GPS坐标。这意味着驾驶员将通过其他驾驶员提前被警告到已检测到的对象。我们的API将存储这些对象的GPS位置，这些对象可能成为车辆的障碍。该层还将包括一个名为**Traffic
    Map Public**的前端应用程序，显示地图上的检测对象。市政府可以使用这个应用程序来监控全市的交通状况。'
- en: '**Near edge**: This layer has the **fourth-generation** (**4G**)/**fifth-generation**
    (**5G**) **Long-Term Evolution** (**LTE**) mobile network used to send information
    to the internet. This layer will transport information collected at the edge to
    send it to the cloud layer.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**近边缘**：这一层使用**第四代**（**4G**）/**第五代**（**5G**）**长期演进**（**LTE**）移动网络来将信息发送到互联网。这一层将把在边缘收集的信息传送到云层。'
- en: '**Far edge**: Our far edge has a Raspberry Pi that will process the information
    captured by a camera. This device has installed K3s as a single node cluster to
    manage all services that the system uses. K3s can brings automation to the system.
    K3s can easily update and maintain the system and can extend the system to use
    more nodes. These additional nodes can be used to add multiple cameras for object
    detection at multiple angles. The computer vision application that runs in the
    cluster consists of two displays and two APIs. One display runs outside K3s but
    in the same device as a Python script, and it’s the service that captures the
    video. This service consists of a Python program that captures video and detects
    objects using OpenCV and a precompiled model for TensorFlow Lite for object detection.
    Here is where computer vision occurs. The system uses a small LCD touchscreen
    connected to the device. The other display is a frontend application that runs
    on a browser; it shows detected objects across a map, not only showing these locally
    but also showing all detected objects by all vehicles in a radius of 500 meters.
    Detected objects will be classified by the Inference API, which classifies objects
    according to their level of warning for a driver. These warnings are represented
    at three levels: levels 1 and 2 represent a warning, and level 3 could be ignored
    as an obstacle for a driver. The Inference API contains a precompiled decision
    tree to do classification. The **GPS Queue** API manages all GPS coordinates and
    periodically sends information about detected objects that represent a warning
    to the cloud to be shown to other drivers. The whole application uses the Display,
    Traffic Map, Inference, and GPS Queue components to process and visualize detected
    objects. The GPS Queue service is based on the GPS service created in [*Chapter
    5*](B16945_05_Final_PG.xhtml#_idTextAnchor097), *K3s Homelab for Edge Computing
    Experiments*, with some modifications. Something important to consider is that
    you can accelerate your object detection by using an external device that accelerates
    **neural network** (**NN**) processing. Some devices that you can consider are
    the Coral USB Accelerator from Google, the Rock Pi neural compute stick **Universal
    Serial Bus** (**USB**), and the NVIDIA Jetson Nano. These devices accelerate the
    NN processing of OpenCV by delegating processing to a dedicated processing unit
    sometimes called a **graphics processing unit** (**GPU**) or a **Tensor Processing
    Unit** (**TPU**). The OpenCV library uses TensorFlow Lite models, so the use of
    these devices can increase the number of **frames per second** (**FPS**) analyzed
    that have some GPU that can be used by TensorFlow Lite, which is designed to run
    on edge devices to accelerate your video analysis. For more information, check
    the *Further reading* section.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远端边缘**：我们的远端边缘设备配有一台树莓派，它将处理由摄像头捕捉到的信息。该设备已安装了K3s，作为一个单节点集群来管理系统所使用的所有服务。K3s可以为系统带来自动化。K3s可以轻松地更新和维护系统，并且可以扩展系统以使用更多节点。这些额外的节点可以用于添加多个摄像头，以从多个角度进行物体检测。运行在集群中的计算机视觉应用程序由两个显示屏和两个API组成。一个显示屏运行在K3s之外，但与Python脚本在同一设备上，它是负责捕捉视频的服务。该服务由一个Python程序组成，使用OpenCV和预编译的TensorFlow
    Lite模型进行物体检测。计算机视觉的过程就在这里发生。系统使用连接到设备的小型LCD触摸屏。另一个显示屏是一个前端应用程序，运行在浏览器中；它展示了地图上的检测物体，不仅显示这些本地检测到的物体，还显示在500米半径内所有车辆检测到的物体。检测到的物体将通过推理API进行分类，按照其对驾驶员的警告级别进行分类。这些警告分为三个级别：级别1和2表示警告，级别3则可能被驾驶员忽视作为障碍物。推理API包含一个预编译的决策树进行分类。**GPS队列**API管理所有GPS坐标，并定期将代表警告的检测物体信息发送到云端，供其他驾驶员查看。整个应用程序使用显示屏、交通地图、推理和GPS队列组件来处理和可视化检测到的物体。GPS队列服务基于[*第五章*](B16945_05_Final_PG.xhtml#_idTextAnchor097)中创建的GPS服务，*K3s
    Homelab用于边缘计算实验*，并进行了一些修改。需要注意的是，您可以通过使用外部设备来加速物体检测，这些设备加速**神经网络**（**NN**）处理。您可以考虑的一些设备包括Google的Coral
    USB加速器、Rock Pi神经计算棒**Universal Serial Bus**（**USB**）和NVIDIA Jetson Nano。这些设备通过将处理任务委派给专用的处理单元（有时称为**图形处理单元**（**GPU**）或**张量处理单元**（**TPU**））来加速OpenCV的神经网络处理。OpenCV库使用TensorFlow
    Lite模型，因此使用这些设备可以提高TensorFlow Lite可用的GPU数量，从而增加每秒**帧数**（**FPS**），这有助于加速视频分析，TensorFlow
    Lite设计用于在边缘设备上运行以加速您的视频分析。有关更多信息，请查看*进一步阅读*部分。'
- en: '**Tiny edge**: Here, we can find an LCD screen to display all detected objects
    in real time and warnings for the driver. You can also find the VK-162 G-Mouse
    GPS module here.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tiny edge**：在这里，我们可以找到一个 LCD 屏幕，用于实时显示所有检测到的物体和警告信息。你还可以在这里找到 VK-162 G-Mouse
    GPS 模块。'
- en: To summarize this workflow, our vehicle first captures images with its camera;
    then, the video frames or images are captured using OpenCV and classified using
    TensorFlow Lite, then are classified according to their level of warning representation
    for the drivers by the Inference API. This information is shown locally in the
    LCD and browser. The GPS coordinate data sent to the cloud is shown in a public
    web frontend application in the cloud. So now, let’s get started in building a
    basic smart traffic system to alert drivers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下这个工作流程，我们的车辆首先使用相机捕捉图像；然后，使用 OpenCV 捕捉视频帧或图像，并通过 TensorFlow Lite 进行分类，再通过推理
    API 按照警告级别为驾驶员分类。这些信息会在 LCD 屏幕和浏览器中本地显示。发送到云端的 GPS 坐标数据会在云中的公共 Web 前端应用程序中显示。现在，让我们开始构建一个基本的智能交通系统，用于警示驾驶员。
- en: Using Redis to store temporary object GPS positions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 存储临时对象的 GPS 位置
- en: 'We are going to use Redis to store our GPS coordinates for all detected objects
    using computer vision. This is a basic configuration to deploy Redis for this
    purpose. This Redis instance must be deployed in the cloud. As we explained in
    [*Chapter 13*](B16945_13_Final_PG.xhtml#_idTextAnchor246), *Geolocalization Applications
    Using GPS, NoSQL, and K3s Clusters*, we are going to use a geospatial index to
    represent our data. The difference will be that we are going to implement temporary
    storage of data using a `traffic`, which stores all traffic objects detected by
    other drivers. In this way, we implemented a kind of garbage functionality to
    remove old detected objects during traffic hours. The reason is that the detected
    objects are relevant just for a certain amount of time, then have to be deleted.
    So, let’s install our Redis deployment by following the next steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Redis 存储通过计算机视觉检测到的所有物体的 GPS 坐标。这是一个基本的配置，用于部署 Redis 来实现这一目的。这个 Redis
    实例必须部署在云端。正如我们在 [*第 13 章*](B16945_13_Final_PG.xhtml#_idTextAnchor246) 中解释的那样，*使用
    GPS、NoSQL 和 K3s 集群的地理定位应用程序*，我们将使用地理空间索引来表示我们的数据。不同之处在于，我们将实现使用 `traffic` 的临时数据存储，它存储由其他驾驶员检测到的所有交通物体。通过这种方式，我们实现了一种垃圾回收功能，用于在交通高峰时段删除旧的检测物体。原因是，检测到的物体只在特定时间内相关，之后必须删除。那么，让我们按照以下步骤安装我们的
    Redis 部署：
- en: 'Create a **PersistentVolumeClaim** for Redis to persist our data, like so:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Redis 创建一个 **PersistentVolumeClaim**，以持久化我们的数据，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, create a **ConfigMap** to configure Redis to use an authentication password,
    as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个 **ConfigMap** 来配置 Redis 使用认证密码，如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a deployment for Redis using the previous `redis-configmap` `db-pv-claim-1`
    **PersistentVolumeClaim** with some resource limits, using the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的 `redis-configmap` `db-pv-claim-1` **PersistentVolumeClaim** 创建 Redis 部署，并设置一些资源限制，使用以下命令：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, create a service for Redis opening port `6379`, like so:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为 Redis 创建一个服务，开放端口 `6379`，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now have Redis installed. Let’s move on to deploying our computer vision
    service at the far edge, in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Redis，接下来让我们在下一节中部署我们的计算机视觉服务到边缘设备。
- en: Deploying a computer vision service to detect car obstacles using OpenCV, TensorFlow
    Lite, and scikit-learn
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署计算机视觉服务来检测车辆障碍物，使用 OpenCV、TensorFlow Lite 和 scikit-learn
- en: In this section, we are going to explore how to configure the object detection
    system that runs at the edge with all its components. This section also shows
    how to configure the public web application running in the cloud that stores and
    shows information about all detected objects at the edge. Let’s start by first
    configuring our Raspberry Pi device in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何配置运行在边缘的物体检测系统及其所有组件。本节还展示了如何配置运行在云端的公共 Web 应用程序，该应用程序存储并显示关于所有在边缘检测到的物体的信息。让我们首先从配置
    Raspberry Pi 设备开始，下一节中将详细讲解。
- en: Preparing your Raspberry Pi to run the computer vision application
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备你的 Raspberry Pi 来运行计算机视觉应用
- en: 'Before installing our software, we have to prepare our device to run it. For
    this, let’s start to configure our Raspberry Pi 4B following the next steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装软件之前，我们必须准备好设备来运行它。为此，让我们按照以下步骤开始配置我们的 Raspberry Pi 4B：
- en: Install Raspbian Pi OS (32 bit) using Debian Bullseye, released at least from
    2022-04-04\. The code to run the TensorFlow Lite model in this chapter has to
    run on an ARMv7 device to support the Coral USB Accelerator device and the LCD
    screen. ARM64 is not supported yet.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Debian Bullseye 安装 Raspbian Pi OS（32 位），并至少从 2022-04-04 发布。本文中运行 TensorFlow
    Lite 模型的代码必须在 ARMv7 设备上运行，以支持 Coral USB 加速器设备和 LCD 屏幕。ARM64 目前不受支持。
- en: Depending on your webcam, you have to install drivers. In this case, we are
    using the Logitech C922 PRO webcam, which is automatically detected by Raspbian.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的网络摄像头，你可能需要安装驱动程序。在本例中，我们使用的是 Logitech C922 PRO 网络摄像头，Raspbian 会自动识别它。
- en: Connect and configure your GPS module. In this case, our VK-162 G-Mouse module
    is autodetected by Raspbian too.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接并配置你的 GPS 模块。在本例中，我们的 VK-162 G-Mouse 模块也会被 Raspbian 自动识别。
- en: Configure the network to use a wireless connection, to install all the necessary
    packages to run the application. Later, you can reconfigure your wireless connection
    to connect to your access point in your smartphone, but you have to delete the
    previous connection in the `/etc/wpa_supplicant/wpa_supplicant.conf` file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置网络以使用无线连接，并安装运行应用所需的所有必要软件包。之后，你可以重新配置无线连接，以连接到智能手机中的接入点，但你需要删除 `/etc/wpa_supplicant/wpa_supplicant.conf`
    文件中的先前连接。
- en: Install the drivers of your LCD screen. In this case, we are using the Miuzei
    **High-Definition Multimedia Interface** (**HDMI**). This will flip the screen
    horizontally and activate the touch feature (this will be the last step once all
    the things are configured). You can check the repository at [https://github.com/goodtft/LCD-show.git](https://github.com/goodtft/LCD-show.git),
    and you can use any LCD screen.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装你的 LCD 屏幕的驱动程序。在本例中，我们使用的是 Miuzei **高清多媒体接口**（**HDMI**）。这将水平翻转屏幕并激活触摸功能（当所有配置完成后，这是最后一步）。你可以查看该代码库：[https://github.com/goodtft/LCD-show.git](https://github.com/goodtft/LCD-show.git)，并且可以使用任何
    LCD 屏幕。
- en: 'Before installing K3s, remember to activate the CGROUPS in the `/boot/cmdline.txt`
    file, then add the next flags at the end of the line:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装 K3s 之前，记得在 `/boot/cmdline.txt` 文件中启用 CGROUPS，然后在行末添加以下标志：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Important Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For more information about CGROUPS visit this link: [https://man7.org/linux/man-pages/man7/cgroups.7.html](https://man7.org/linux/man-pages/man7/cgroups.7.html)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如需有关 CGROUPS 的更多信息，请访问此链接：[https://man7.org/linux/man-pages/man7/cgroups.7.html](https://man7.org/linux/man-pages/man7/cgroups.7.html)
- en: 'Get your current `ifconfig`, then take a look at the `wlan0` interface, as
    follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前的 `ifconfig`，然后查看 `wlan0` 接口，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install K3s by running the following command:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 K3s：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you can test if everything is working by running the following command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以通过运行以下命令来测试一切是否正常：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will return your unique node running.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回你当前唯一运行的节点。
- en: Now, our edge device is ready to be used to run our service that performs computer
    vision at the edge. For this, let’s move on to the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的边缘设备已准备好运行服务，执行边缘计算中的计算机视觉任务。接下来，让我们进入下一节。
- en: Deploying the inference service to detect objects
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署推理服务以检测物体
- en: 'The `inference` service is used in this scenario to do predictions and to classify
    if an object represents an obstacle for a driver. We use the next table for that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中使用 `inference` 服务进行预测，并分类判断物体是否对驾驶员构成障碍。我们使用下表来完成此操作：
- en: '![](img/B16945_14_Table_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16945_14_Table_01.jpg)'
- en: For example, a car identified by the id `1` in the `n` field represents a level
    1 of warning, so all the objects with `warning_level` equal to 1 or 2 will be
    recorded as potential objects that can obstruct traffic or represent danger for
    the driver. If an object is classified with the value 1000, the object doesn’t
    represent any danger, so it is not recorded.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`n` 字段中 id 为 `1` 的汽车表示警告级别 1，因此所有 `warning_level` 为 1 或 2 的物体将被记录为可能会阻碍交通或对驾驶员造成危险的潜在物体。如果物体的分类值为
    1000，则该物体不代表任何危险，因此不会被记录。
- en: 'The source code of this service consists of two files: `index.py` and `create_model.py`.
    The `index.py` file contains a basic API to return predictions by calling the
    model to predict using the `/predict` path. It has basic code to load the precompiled
    ML model. The `create_model.py` file contains code to train and generate a model
    that will be used for this API using `index.py`. The code looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务的源代码由两个文件组成：`index.py`和`create_model.py`。`index.py`文件包含一个基本的API，通过调用模型来使用`/predict`路径进行预测。它包含加载预编译的机器学习（ML）模型的基本代码。`create_model.py`文件包含用于训练并生成将被此API使用的模型的代码，该模型使用`index.py`。代码如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we read our `safety_rules.csv` `drop`. In AI, you have to represent texts
    as values. Our object column has a numeric representation in the n column, so
    the column object can be ignored. The data loaded from the CSV file is represented
    as a Pandas DataFrame that is used in scikit-learn as the source of data to generate
    a decision tree. A decision tree is an ML algorithm that can use classified data
    to do predictions using the data structure of trees for predictions. So, it is
    one of the simplest methods to do predictions using ML. After the DataFrame is
    loaded, scikit-learn does its training processes to generate a `safety_rules.model`
    model that could be used later in the API for predictions. Every time you build
    the container, the model is updated by calling the `create_model.py` file inside
    the `Dockerfile` of this API. Now, the serving code for the API will look like
    this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们读取了我们的`safety_rules.csv` `drop`。在AI中，必须将文本表示为数值。我们的对象列在n列中有一个数字表示，因此该列对象可以忽略。
    从CSV文件加载的数据表示为一个Pandas DataFrame，它在scikit-learn中作为生成决策树的数据源。决策树是一种ML算法，可以使用分类数据，通过树形数据结构进行预测。因此，它是使用机器学习进行预测的最简单方法之一。在DataFrame加载之后，scikit-learn会执行其训练过程，生成一个`safety_rules.model`模型，该模型可以在API中用于后续的预测。每次构建容器时，模型都会通过在此API的`Dockerfile`中调用`create_model.py`文件来更新。现在，API的服务代码将如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By calling the `/predict` `safety_rules.csv` file. You can add more values to
    classify your images by adding new values in the file and regenerating the container
    with the new model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`/predict`的`safety_rules.csv`文件，你可以通过在文件中添加新的值并使用新模型重新生成容器，来为你的图像分类添加更多的值。
- en: Important Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To check the code and update the model, check the next link: [https://github.com/sergioarmgpl/containers/tree/main/inference/src](https://github.com/sergioarmgpl/containers/tree/main/inference/src).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查代码并更新模型，请查看下一个链接：[https://github.com/sergioarmgpl/containers/tree/main/inference/src](https://github.com/sergioarmgpl/containers/tree/main/inference/src)。
- en: 'Now, let’s deploy our `inference` service in our **Advanced RISC Machine**
    (**ARM**) device by following the next steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤，在我们的**高级精简指令集计算机**（**ARM**）设备上部署我们的`inference`服务：
- en: 'Create a deployment for the `inference` API, as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`inference` API创建一个部署，步骤如下：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s port forward the service running, like so:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像这样进行端口转发以运行服务：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let’s call the `inference` API to get some predictions. Let’s use an object
    detected and classified as `other` with the number 6; it will return a warning
    level of 3 based on the prediction table. The code is illustrated in the following
    snippet:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用`inference` API来获取一些预测。我们使用一个被检测并分类为`other`且编号为6的对象，它将根据预测表返回一个警告级别为3的结果。代码如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will return the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our inference service is now running, ready to be called inside our device to
    classify the detected images. Let’s continue deploying the `gps-queue` service
    in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的推理服务现在正在运行，准备在设备内被调用以分类检测到的图像。接下来，让我们继续在下一部分部署`gps-queue`服务。
- en: Deploying the gps-queue service to store GPS coordinates
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署gps-queue服务以存储GPS坐标
- en: 'The `gps-queue` service is composed of several containers dedicated to a specific
    task. First, initialize an `init` container called `init-gps-queue` that adds
    an initial value of `-1` inside the `/tmp/gps` file. This file stores the last
    GPS coordinate generated. Then, the `gps-queue` container is in charge of reading
    the GPS coordinates from our GPS module, so it needs permission to access the
    `/dev` folder from the host. Once the GPS coordinate is read, it is stored in
    `/tmp/gps`. After this, the `sync-traffic-events` container calls the `gps-api`
    container every 30 seconds by default using the `http://localhost:3000/traffic`
    endpoint, which sends the detected objects with their warning classification and
    GPS coordinate to the `http://<TRAFFIC_MANAGER_IP>:5000` public endpoint, which
    stores this information for some time to be shown in the `traffic-map-public`
    service that has public access to show the objects detected by other vehicles.
    Before deploying our service, let’s explore a little bit the code of the `gps-queue`
    container, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`gps-queue` 服务由多个容器组成，每个容器专注于特定任务。首先，初始化一个名为`init-gps-queue`的`init`容器，它会在`/tmp/gps`文件中添加一个初始值`-1`。该文件存储生成的最后一个GPS坐标。然后，`gps-queue`容器负责从我们的GPS模块读取GPS坐标，因此它需要获得对主机`/dev`文件夹的访问权限。一旦读取到GPS坐标，它将被存储在`/tmp/gps`中。之后，`sync-traffic-events`容器每30秒默认调用一次`gps-api`容器，通过`http://localhost:3000/traffic`端点，将检测到的对象及其警告分类和GPS坐标发送到`http://<TRAFFIC_MANAGER_IP>:5000`公共端点，该端点会暂时存储这些信息，以便在`traffic-map-public`服务中显示，这个服务对外开放，展示其他车辆检测到的对象。在部署我们的服务之前，让我们先探索一下`gps-queue`容器的代码，如下所示：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code configures the GPS module and stores the coordinate in the `/tmp/gps`
    file, which is shared by the `gps-queue` and `gps-api` containers. It uses a `cid`
    variable to associate each GPS coordinate with a unique client **identifier**
    (**ID**) that could be used for customizations to create your own system. The
    information will be stored in the next format:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码配置了GPS模块，并将坐标存储在`/tmp/gps`文件中，该文件由`gps-queue`和`gps-api`容器共享。它使用`cid`变量将每个GPS坐标与一个唯一的客户端**标识符**（**ID**）关联起来，该标识符可以用于自定义，以便创建你自己的系统。信息将以以下格式存储：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s explore the code inside the `gps-api` container, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一下`gps-api`容器中的代码，如下所示：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As an explanation, the `/gps` path of this API returns the value of the last
    GPS coordinate stored in `/tmp/gps`, and the `/traffic/event` path receives the
    object detected from the edge device running the `detect.py` program. This happens
    every second. Then, the information is stored temporarily in the `traffic_events`
    array. Inside the Pod, the `sync-traffic-events` container calls the `/traffic`
    endpoint of the API running inside the `gps-api` container, which filters the
    `traffic_events` array to have just unique objects detected because the edge program
    gets a maximum of eight detected objects per video-frame analysis. Once the array
    is filtered, it is sent to the `http://<TRAFFIC_MANAGER:5000>/traffic/1`. This
    information is requested later by the `http://<TRAFFIC_MANAGER:5000>/traffic`
    URL, which shows the globally stored objects detected from all the devices in
    a map using the Leaflet library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为说明，API的`/gps`路径返回存储在`/tmp/gps`中的最后一个GPS坐标值，`/traffic/event`路径接收从运行`detect.py`程序的边缘设备检测到的对象。这个过程每秒发生一次。然后，信息被暂时存储在`traffic_events`数组中。在Pod内，`sync-traffic-events`容器每30秒调用一次运行在`gps-api`容器中的API的`/traffic`端点，过滤`traffic_events`数组，只保留唯一检测到的对象，因为边缘程序每帧视频分析最多只能检测到八个对象。一旦数组被过滤，它将被发送到`http://<TRAFFIC_MANAGER:5000>/traffic/1`。随后，这些信息会被`http://<TRAFFIC_MANAGER:5000>/traffic`网址请求，该网址使用Leaflet库在地图上展示来自所有设备的全球检测对象。
- en: 'To deploy this service, execute the following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署此服务，请执行以下步骤：
- en: 'Create a deployment for the GPS queue, like so:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个GPS队列的部署，如下所示：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Important Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To check the code and create your own containers, you can check the next links:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查代码并创建自己的容器，可以查看以下链接：
- en: '[https://github.com/sergioarmgpl/containers/tree/main/gps-api/src](https://github.com/sergioarmgpl/containers/tree/main/gps-api/src)
    and [https://github.com/sergioarmgpl/containers/tree/main/gps-queue/src](https://github.com/sergioarmgpl/containers/tree/main/gps-queue/src)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/sergioarmgpl/containers/tree/main/gps-api/src](https://github.com/sergioarmgpl/containers/tree/main/gps-api/src)
    和 [https://github.com/sergioarmgpl/containers/tree/main/gps-queue/src](https://github.com/sergioarmgpl/containers/tree/main/gps-queue/src)'
- en: 'Let’s pay attention to the variables that this deployment uses in its containers.
    These are explained in more detail here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注一下这个部署在其容器中使用的变量。这里将详细解释这些变量：
- en: '`gps-queue`:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gps-queue`：'
- en: '`DEVICE`: Configures the device where your GPS module is detected. For the
    VK-162 G-Mouse module, the default value used is `/dev/ttyACM0`.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEVICE`：配置检测到 GPS 模块的设备。对于 VK-162 G-Mouse 模块，默认值是 `/dev/ttyACM0`。'
- en: '`gps-api`:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gps-api`：'
- en: '`ENDPOINT`: Configures the public endpoint where all detected objects with
    GPS coordinates and warnings are stored. This is the public service that stores
    the coordinates. By default, this is `http://<TRAFFIC_MANAGER_IP>:5000`.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENDPOINT`：配置所有带有 GPS 坐标和警告的检测对象存储的公共端点。这是存储坐标的公共服务。默认情况下，这个地址是`http://<TRAFFIC_MANAGER_IP>:5000`。'
- en: '`sync-traffic-events`:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync-traffic-events`：'
- en: '`URL`: Contains the local URL called periodically to send information about
    all detected objects. This will call the API configured in the `gps-api` container.
    By default, this is `http://localhost:3000/traffic`.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL`：包含周期性调用的本地 URL，用于发送所有检测到的对象信息。这将调用在 `gps-api` 容器中配置的 API。默认值是 `http://localhost:3000/traffic`。'
- en: '`DELAY`: Configures the amount of time to wait to send the last objects detected
    with their information. By default, this is 30, which represents the time in seconds.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELAY`：配置发送最后检测到的对象及其信息的延迟时间。默认值是 30，表示以秒为单位的时间。'
- en: These values could be used to customize the behavior of the service that processes
    the objects detected and its GPS coordinates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可以用于定制处理检测到的对象及其 GPS 坐标的服务行为。
- en: 'If you want to test the endpoints of this service, you can run inside your
    edge device `port-forward` to access the API using the `curl` command, like so:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想测试此服务的端点，可以在你的边缘设备内运行 `port-forward` 来通过 `curl` 命令访问 API，方法如下：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, you can execute the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以执行以下命令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It will return something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回类似以下内容：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have now deployed the `gps-queue` service and it’s ready to be used. It’s
    time to deploy our local web application that will show detected objects at the
    edge using our edge device equipped with a camera. For this, we have to solve
    the `traffic-manager` public API from the local `traffic-map` application. CORS
    is a mechanism that allows or restricts resources on a web page to be requested
    from a domain outside the current one. In this scenario, it’s called a public
    API from a local web application. So, let’s move on to the next section to create
    a simple proxy to resolve this issue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经部署了 `gps-queue` 服务，并且它已经准备好使用。接下来是部署我们的本地 Web 应用程序，它将在边缘设备上显示通过摄像头检测到的对象。为此，我们需要解决本地
    `traffic-map` 应用程序中的 `traffic-manager` 公共 API 问题。CORS 是一种机制，它允许或限制从当前域外的域请求网页上的资源。在此场景中，它被称为本地
    Web 应用程序的公共 API。因此，让我们进入下一部分，创建一个简单的代理来解决这个问题。
- en: Deploying traffic-manager to store GPS coordinates
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 traffic-manager 来存储 GPS 坐标
- en: 'The `traffic-manager` service receives detected objects with their GPS coordinates
    and warning-level classification. This API runs in the cloud, and it’s called
    periodically by the edge device while it’s moving and detecting objects. This
    service consists of two containers: one that gives an API to recollect objects
    detected, and another that is in charge of auto-expiring detected objects and
    global traffic information. This is because traffic is constantly changing during
    the day. You can configure these values to fit your own scenario. Let’s explore
    first the code of the API in the `traffic-manager` container, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`traffic-manager` 服务接收带有 GPS 坐标和警告级别分类的检测对象。这个 API 在云端运行，并且在边缘设备移动和检测对象时被周期性调用。此服务由两个容器组成：一个提供
    API 用于收集检测到的对象，另一个负责自动过期检测到的对象和全局交通信息。因为交通状况在一天之内不断变化，你可以配置这些值以适应你的场景。让我们首先探索
    `traffic-manager` 容器中 API 的代码，如下所示：'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This container has two endpoints with the `/traffic/1` path. This service stores
    detected objects at the edge by creating a hash key with the form `object:<object-id>:data`
    that stores the type and the warning level, and in the `traffic` geospatial set
    stores the GPS coordinate. An expiration time to the `traffic` key is set or renewed,
    and for the new `object:<object-id>:data` hash key, the expiration time is set
    too. After calling the `/traffic/unit/<unit>/r/<radius>/lat/<lat>/lng/<lng>` path,
    the call returns near detected objects in the radius defined in the request. This
    is a public service that all the edge devices will access periodically to send
    updates of objects detected while they are moving. Now, let’s explore the code
    of the `autoexpire` container, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器有两个端点，路径为`/traffic/1`。此服务通过创建一个哈希键`object:<object-id>:data`来存储检测到的边缘对象，其中存储了对象类型和警告级别，在`traffic`地理空间集合中存储了GPS坐标。为`traffic`键设置或更新过期时间，对于新的`object:<object-id>:data`哈希键，也设置过期时间。调用`/traffic/unit/<unit>/r/<radius>/lat/<lat>/lng/<lng>`路径时，返回请求中定义的半径范围内检测到的附近对象。这是一个公共服务，所有边缘设备会定期访问该服务，以发送在移动过程中检测到的对象更新。现在，让我们继续探索`autoexpire`容器的代码，具体如下：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This container basically checks if each member of the traffic geospatial set
    has metadata available in the `object:<object-id>:data` hash key. If none exists,
    this means that the object passed the maximum amount of time to be relevant in
    the traffic, which means that it has expired too, and then this code removes the
    member from the sorted set. This process is called periodically after waiting
    for a certain number of seconds that are configured by the `DELAY` variable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器基本上会检查交通地理空间集合中的每个成员是否在`object:<object-id>:data`哈希键中有可用的元数据。如果没有，这意味着该对象已超出在交通中保持相关性的最大时间，这意味着它已经过期，接着这段代码会从排序集中过滤掉该成员。此过程会在等待由`DELAY`变量配置的秒数后定期进行。
- en: 'To deploy the `traffic-manager` service, proceed as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署`traffic-manager`服务，请按以下步骤操作：
- en: 'Create a deployment for the GPS server, like so:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建GPS服务器的部署，如下所示：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This deployment uses the following variables:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此部署使用以下变量：
- en: '`REDIS_HOST`: This is the name of the Redis service. This variable can be customized
    to fit your needs.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REDIS_HOST`：这是Redis服务的名称。此变量可以根据需要进行自定义。'
- en: '`REDIS_AUTH`: This is the password to connect to the Redis service.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REDIS_AUTH`：这是连接Redis服务的密码。'
- en: '`TTL_TRAFFIC`: This is the URL of the `tracking-server` service. In this case,
    the URL matches the internal `tracking-server` service on port `3000`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TTL_TRAFFIC`：这是`tracking-server`服务的URL。在此情况下，URL与内部的`tracking-server`服务的端口`3000`匹配。'
- en: '`TTL_OBJECT`: This is the URL of the `tracking-server` service. in this case,
    the URL matches the internal `tracking-server` service on port `3000`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TTL_OBJECT`：这是`tracking-server`服务的URL。在此情况下，URL与内部的`tracking-server`服务的端口`3000`匹配。'
- en: '`DELAY`: This is the time to wait to check if a member inside the traffic geospatial
    sorted set expired.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELAY`：这是等待检查流量地理空间排序集中的成员是否已过期的时间。'
- en: By configuring these variables, you can customize the behavior of this deployment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置这些变量，您可以自定义此部署的行为。
- en: Important Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'To check the code and create your own containers, you can check the next links:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码并创建自己的容器，您可以查看以下链接：
- en: '[https://github.com/sergioarmgpl/containers/tree/main/traffic-manager/src](https://github.com/sergioarmgpl/containers/tree/main/traffic-manager/src)
    and [https://github.com/sergioarmgpl/containers/tree/main/autoexpire/src](https://github.com/sergioarmgpl/containers/tree/main/autoexpire/src)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/sergioarmgpl/containers/tree/main/traffic-manager/src](https://github.com/sergioarmgpl/containers/tree/main/traffic-manager/src)
    和 [https://github.com/sergioarmgpl/containers/tree/main/autoexpire/src](https://github.com/sergioarmgpl/containers/tree/main/autoexpire/src)'
- en: 'Now, let’s create a service for this deployment as a **LoadBalancer**. This
    IP address will be used in our edge device to propagate this information in the
    cloud to be accessible to all drivers that use this smart traffic system. The
    code is illustrated in the following snippet:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为此部署创建一个作为**LoadBalancer**的服务。此IP地址将在我们的边缘设备中使用，以便在云中传播此信息，使所有使用该智能交通系统的司机都可以访问。代码示例如下：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Get the load balancer IP address for your `traffic-manager` deployment with
    the following command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取`traffic-manager`部署的负载均衡器IP地址：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see the value of the `TRAFFIC_MANAGER_IP` environment variable by running
    the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，可以查看`TRAFFIC_MANAGER_IP`环境变量的值：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that it takes some time after the IP address of the load balancer is provisioned.
    You can check the state of the services by running the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在负载均衡器的IP地址配置完成后需要一些时间。你可以通过运行以下命令来检查服务的状态：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Wait until the `EXTERNAL_IP` environment variable is provisioned.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 等待直到`EXTERNAL_IP`环境变量配置完成。
- en: Also, take note that the `$TRAFFIC_MANAGER_IP` value will be used to configure
    the `proxy` service in the edge device.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，`$TRAFFIC_MANAGER_IP`的值将用于在边缘设备中配置`proxy`服务。
- en: '(*Optional*) If you want to test this API to insert an object manually, run
    the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 如果你想测试这个API以手动插入一个对象，请运行以下命令：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will return the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '(*Optional*) To get all detected objects in a radius of 0.1 kilometers, run
    the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (*可选*) 要获取0.1公里半径内的所有检测对象，请运行以下命令：
- en: '[PRE30]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will return the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, our `traffic-manager` API is running in the cloud. Let’s move on to use
    this API in our edge device using a proxy to prevent CORS restrictions when calling
    the API, in the next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`traffic-manager` API已经在云端运行。接下来，我们将使用代理在边缘设备中使用这个API，以避免在调用API时遇到CORS限制，具体操作将在下一节中说明。
- en: Deploying a simple proxy to bypass CORS
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署一个简单的代理以绕过CORS
- en: 'The `proxy` service is used to bypass the CORS restriction that occurs when
    a local website running on a private network tries to call a public API using
    a public API address. Using a proxy to forward requests to this public site could
    be one possible and simple solution to solve this. Another one is to modify the
    request headers on the API call and add the necessary headers to bypass the CORS
    restriction. In this case, we are going to use a proxy build with Flask to forward
    all local `GET` requests to the `traffic-manager` API, which is a public API deployed
    in the cloud and is accessible over the internet. Let’s explore the code a little
    bit before deploying the `proxy` service, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy`服务用于绕过CORS限制，这种限制通常出现在本地网站尝试使用公共API地址调用公共API时。使用代理将请求转发到这个公共站点可能是解决这个问题的一个简单方法。另一种方法是修改API调用中的请求头，添加必要的头信息来绕过CORS限制。在这种情况下，我们将使用基于Flask构建的代理，将所有本地的`GET`请求转发到`traffic-manager`
    API，这个API是部署在云中的公共API，可以通过互联网访问。在部署`proxy`服务之前，我们先来简要查看一下代码，如下所示：'
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code basically receives all `GET` requests on any path and forwards the
    requests with all the important headers to the URL defined in the environment
    variable. This API is accessible using port `5000`. Now, let’s move on to deploy
    this simple proxy to forward all calls from our local `proxy` service, execute
    the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上会接收所有`GET`请求并将请求以及所有重要的头信息转发到环境变量中定义的URL。这个API可以通过`5000`端口访问。现在，接下来我们将部署这个简单的代理，将来自本地`proxy`服务的所有调用转发出去，执行以下步骤：
- en: 'Create a deployment for the GPS server, like so:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个GPS服务器的部署，如下所示：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This deployment uses the following variables:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部署使用了以下变量：
- en: '`URL`: This variable has the URL where the proxy is going to redirect all `GET`
    requests received by the proxy in port `5000`. This URL will be the `traffic-manager`
    public IP address using the format `http://<TRAFFIC_MANAGER_IP>:5000`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL`：这个变量包含代理将在端口`5000`上接收到的所有`GET`请求重定向到的URL。这个URL将是`traffic-manager`的公共IP地址，格式为`http://<TRAFFIC_MANAGER_IP>:5000`。'
- en: Important Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'To check the code and create your own container, you can check the next link:
    [https://github.com/sergioarmgpl/containers/tree/main/proxy/src](https://github.com/sergioarmgpl/containers/tree/main/proxy/src).
    This small proxy is a custom implementation that you can implement using languages
    other than Python to have all the control in your implementation. You can also
    use solutions such as using NGINX with a `proxy_pass` configuration, and so on.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码并创建你自己的容器，可以查看以下链接：[https://github.com/sergioarmgpl/containers/tree/main/proxy/src](https://github.com/sergioarmgpl/containers/tree/main/proxy/src)。这个小型代理是一个自定义实现，你可以使用Python以外的语言来实现它，以便在实现中拥有完全的控制权。你也可以使用其他解决方案，比如使用带有`proxy_pass`配置的NGINX等。
- en: 'You can test the proxy by running something like this:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过运行如下命令来测试代理：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the remote path could be `/traffic`, which is a URL where the **Traffic
    Manager** service returns all objects globally detected by drivers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，远程路径可以是`/traffic`，这是一个URL，**Traffic Manager**服务会返回所有由驾驶员在全球范围内检测到的对象。
- en: Now our proxy is running, let’s deploy our **Traffic Map** web application to
    show the detected objects that represent warnings for drivers in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代理服务已经启动，让我们在接下来的部分中部署**交通地图**网页应用程序，以展示代表驾驶员警告的检测物体。
- en: Deploying the edge application to visualize warnings based on computer vision
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署边缘应用程序以可视化基于计算机视觉的警告
- en: 'Our visual application consists of two parts: the first one is a web application
    that shows all data from all drivers using the smart traffic system, and the other
    one is a desktop application that shows the detected objects in real time. So,
    let’s start installing our web application to visualize objects detected by different
    drivers in the next section.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可视化应用程序由两个部分组成：第一部分是一个网页应用程序，显示所有驾驶员使用智能交通系统的数据，第二部分是一个桌面应用程序，实时显示检测到的物体。因此，接下来我们将开始安装我们的网页应用程序，以可视化不同驾驶员检测到的物体。
- en: Installing the Traffic Map application to visualize objects detected by drivers
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装交通地图应用程序以可视化驾驶员检测到的物体
- en: 'We have now set up the necessary APIs to visualize what our device detected.
    We have to continue deploying our web application to visualize this object on
    a map. This is where our **Traffic Map** application comes in handy. But let’s
    explore the code first before deploying it, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了必要的 API 来可视化我们的设备检测到的内容。接下来，我们需要继续部署网页应用程序，将这些物体在地图上进行可视化。这时，我们的**交通地图**应用程序就派上用场了。不过在部署之前，让我们先看看代码，代码如下：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is similar to the previous web application map used in [*Chapter 13*](B16945_13_Final_PG.xhtml#_idTextAnchor246),
    *Geolocalization Applications using GPS, NoSQL, and K3s Clusters*, but this one
    calls the GPS Queue service to get the current GPS coordinate that is running
    in the edge device and get data from the public endpoint of the `proxy` service
    to prevent CORS access restrictions. It also has the option to center the map
    at the beginning every time the page is loaded.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于在[*第 13 章*](B16945_13_Final_PG.xhtml#_idTextAnchor246)中使用的前一个网页应用地图，*基于
    GPS、NoSQL 和 K3s 集群的地理定位应用*，但这个地图调用了 GPS 队列服务来获取正在边缘设备上运行的当前 GPS 坐标，并从 `proxy`
    服务的公共端点获取数据，以防止 CORS 访问限制。它还具有在每次页面加载时将地图居中的选项。
- en: 'The web part uses the `map.html` file with the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 网页部分使用 `map.html` 文件，代码如下：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code basically centers the map with initial latitude and longitude coordinates,
    shows the current position of the device in a blue globe, and shows the detected
    objects with icons, showing the object name, the GPS coordinates, the type of
    object, and the warning level. It should look something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上会将地图居中，显示初始的经纬度坐标，显示设备的当前位置（以蓝色地球图标表示），并显示检测到的物体的图标，展示物体名称、GPS 坐标、物体类型和警告级别。它应该类似于以下效果：
- en: '![Figure 14.3 – Driver current position'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.3 – 驾驶员当前位置'
- en: '](img/B16945_14_03.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_14_03.jpg)'
- en: Figure 14.3 – Driver current position
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 驾驶员当前位置
- en: 'This shows the driver’s current position in real time, while the vehicle is
    moving. The other possible visualization shows how detected objects appear across
    the map. This information is requested using the `proxy` service to visualize
    all detected objects by other drivers. This could represent a kind of **augmented
    reality** (**AR**), something similar to what Waze does with its application.
    The visualization looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这会实时显示驾驶员当前位置，而车辆正在移动。另一个可能的可视化效果是展示检测到的物体在地图上的位置。这些信息是通过 `proxy` 服务请求的，用于可视化其他驾驶员检测到的所有物体。这可以代表一种**增强现实**（**AR**），类似于
    Waze 应用中的实现。其可视化效果如下所示：
- en: '![Figure 14.4 – Detected object’s current position and warning message'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.4 – 检测到的物体当前位置和警告信息'
- en: '](img/B16945_14_04.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_14_04.jpg)'
- en: Figure 14.4 – Detected object’s current position and warning message
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 检测到的物体当前位置和警告信息
- en: 'If you click inside the detected object, it will show the current GPS coordinate,
    the type of object, and a warning message. There are several objects included
    in this default implementation. The implementation includes car, truck, and person
    detection as possible obstacles and potential warnings for a driver. You can see
    the following icons on the map:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击检测到的物体，它将显示当前的 GPS 坐标、物体类型和警告信息。这个默认实现中包含了几个物体。实现包括汽车、卡车和行人检测，作为可能的障碍物和潜在的驾驶员警告。你可以在地图上看到以下图标：
- en: '![Figure 14.5 – Car, truck, and person icons shown in Traffic Map](img/B16945_14_05.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 交通地图中显示的汽车、卡车和行人图标](img/B16945_14_05.jpg)'
- en: Figure 14.5 – Car, truck, and person icons shown in Traffic Map
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 交通地图中显示的汽车、卡车和人物图标
- en: 'By default, our web application updates the objects every 5 seconds within
    a radius of 0.5 kilometers. Those values can be customized to satisfy your own
    solution. Now, let’s deploy our Traffic Map web application by executing the next
    commands:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的 Web 应用程序每 5 秒更新一次在 0.5 公里半径内的物体。这些值可以根据您的需求进行定制。现在，让我们通过执行以下命令来部署我们的交通地图
    Web 应用程序：
- en: 'Create a `traffic-map` deployment by running the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建 `traffic-map` 部署：
- en: '[PRE37]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This deployment has the following environment variables:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此部署包含以下环境变量：
- en: '`LATITUDE`: Initial GPS latitude coordinate to center your map.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LATITUDE`：初始 GPS 纬度坐标，用于居中您的地图。'
- en: '`LONGITUDE`: Initial GPS longitude coordinate to center your map.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONGITUDE`：初始 GPS 经度坐标，用于居中您的地图。'
- en: '`GPS_QUEUE`: IP address endpoint of the `gps-queue` service. In this case,
    because this runs locally, it is set by default as `localhost`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPS_QUEUE`：`gps-queue` 服务的 IP 地址端点。在本地运行时，默认设置为 `localhost`。'
- en: '`TRAFFIC_MANAGER`: IP address endpoint of your `proxy` service, we can call
    it using `localhost`, which prevents the CORS restriction.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRAFFIC_MANAGER`：`proxy` 服务的 IP 地址端点，我们可以使用 `localhost` 来调用它，从而避免 CORS 限制。'
- en: Important Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To check the code and create your own container of `traffic_map`, you can check
    the next link:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码并创建您自己的 `traffic_map` 容器，您可以查看以下链接：
- en: '[https://github.com/sergioarmgpl/containers/tree/main/traffic-map/src](https://github.com/sergioarmgpl/containers/tree/main/traffic-map/src)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/sergioarmgpl/containers/tree/main/traffic-map/src](https://github.com/sergioarmgpl/containers/tree/main/traffic-map/src)'
- en: We have now deployed the **Traffic Map** web application on our edge device.
    Let’s move on to run our object detection system at the edge to perform our computer
    vision, in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在边缘设备上部署了 **交通地图** Web 应用程序。接下来，我们将运行边缘设备上的物体检测系统，执行我们的计算机视觉任务，如下节所述。
- en: Detecting objects with computer vision using OpenCV, TensorFlow Lite, and scikit-learn
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OpenCV、TensorFlow Lite 和 scikit-learn 进行计算机视觉的物体检测
- en: 'The service that performs computer vision is contained in the `detect.py` file.
    This will run on our edge device. Let’s explore the code inside this file before
    preparing our device to run this program, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行计算机视觉服务的代码包含在 `detect.py` 文件中。该文件将在我们的边缘设备上运行。在准备设备运行此程序之前，我们来探索一下这个文件中的代码，具体如下：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code starts the video capture and then sends this image in a format that
    TensorFlow Lite can analyze. TensorFlow Lite detects coordinates where objects
    are detected and classifies the objects with a label that is their name. This
    program will use the `efficientdet_lite0_edgetpu_metadata.tflite` model. In this
    case, we are focusing on the car, person, dog, semaphore, and truck objects. These
    objects represent obstacles for drivers and represent a level of warning. If the
    detected object is different than these objects, it’s classified as `other` and
    it’s omitted as a warning. If you want to add more objects to the list, you just
    have to modify the `obj_values` array with new values, as in the following example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码启动视频捕捉，然后将图像以 TensorFlow Lite 可以分析的格式发送。TensorFlow Lite 会检测物体的位置并使用物体名称对其进行分类。该程序将使用
    `efficientdet_lite0_edgetpu_metadata.tflite` 模型。在本例中，我们关注的物体有汽车、人物、狗、信号灯和卡车。这些物体代表了驾驶员的障碍，并表示一定的警告级别。如果检测到的物体与这些物体不同，则会被分类为
    `other` 并作为警告忽略。如果您想添加更多物体到列表中，只需修改 `obj_values` 数组并添加新值，如以下示例所示：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In each loop of this program, the detected objects are counted by groups and
    stored in the `items` array. Then, if one of these groups detects more than one
    object and the group is one of the identified objects in the `obj_values` array,
    the detected objects in the group are counted as potential object obstacles that
    represent warnings for drivers. To calculate the warning level, the script calls
    the `inference` API, and then, if a warning is detected, it calls the `traffic-map`
    service using the `proxy` service previously installed using the `http://localhost:5000/traffic/event`
    URL. Every time the proxy is called, the requests will be sent to the public endpoint
    of the `traffic-manager` service deployed in the cloud. Then, after the object
    analysis, the `items` array is cleared and the output summarizing the detected
    objects is shown in a blue box using OpenCV. It will look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此程序的每次循环中，检测到的对象按组进行计数并存储在`items`数组中。然后，如果其中某个组检测到多个对象，并且该组是`obj_values`数组中已识别的对象之一，则该组中的检测到的对象将被计为潜在的障碍物，代表着对驾驶员的警告。为了计算警告级别，脚本会调用`inference`
    API，然后，如果检测到警告，它会通过之前安装的`proxy`服务使用`http://localhost:5000/traffic/event` URL调用`traffic-map`服务。每次调用代理时，请求将被发送到部署在云中的`traffic-manager`服务的公共端点。然后，在对象分析之后，`items`数组会被清空，并且通过OpenCV以蓝色框显示总结检测到的对象。它看起来像这样：
- en: '![Figure 14.6 – Object detection screen'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.6 – 物体检测屏幕'
- en: '](img/B16945_14_06.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_14_06.jpg)'
- en: Figure 14.6 – Object detection screen
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 物体检测屏幕
- en: 'This output also shows the detected objects marked with a red rectangle with
    the name of the detected object. In the upper-left corner, you will see the number
    of FPS analyzed. Our warning box will show two types of messages: either the group
    of objects found (for example, **person, car found**) or that there are no detected
    objects—this will show the message **No warnings**. The service closes if you
    press the *Esc* key. To install the object detection service in your edge device,
    execute the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出还显示了检测到的对象，用红色矩形标记，并显示检测到的对象名称。在左上角，您将看到分析的FPS数。我们的警告框将显示两种类型的消息：要么是找到的对象组（例如，**发现了人和车**），要么是没有检测到任何对象——这将显示**没有警告**消息。如果按下*Esc*键，服务将关闭。要在您的边缘设备上安装物体检测服务，请执行以下步骤：
- en: Connect your edge device to a network that you can access.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的边缘设备连接到您可以访问的网络。
- en: 'Log in to your edge device, like so:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的边缘设备，如下所示：
- en: '[PRE40]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can get the IP address of your device by running the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令获取设备的IP地址：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can run it by connecting your device to an HDMI screen and connecting a
    keyboard and mouse to your device.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将设备连接到HDMI屏幕，并连接键盘和鼠标来运行它。
- en: 'Clone the repository by running the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码克隆仓库：
- en: '[PRE42]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Install missing dependencies to run OpenCV and the camera, like so:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装缺失的依赖项以运行OpenCV和摄像头，如下所示：
- en: '[PRE43]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Configure the device to run the object detection program, as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置设备以运行物体检测程序，如下所示：
- en: '[PRE44]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the script to install desktop shortcuts, like so:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本安装桌面快捷方式，如下所示：
- en: '[PRE45]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Important Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Take a look at the files with a `.desktop` extension that call the `run.sh`
    script and the files with a `.desktop` extension that start the detection application
    and the local web Traffic Map application. These files are located in the `ch14/code/python/object_detection`
    directory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 查看调用`run.sh`脚本的`.desktop`扩展名的文件，以及启动检测应用程序和本地Web流量地图应用程序的`.desktop`扩展名的文件。这些文件位于`ch14/code/python/object_detection`目录下。
- en: Test the installation by clicking on the new **Detector** desktop shortcut.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击新的**Detector**桌面快捷方式测试安装。
- en: Test the local Traffic Map application by clicking on the `http://localhost:5000`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击`http://localhost:5000`测试本地流量地图应用程序。
- en: Reconfigure your wireless network to use the access point connection of your
    smartphone and reset your `/etc/wpa_supplicant/wpa_supplicant.conf` configuration
    file by removing the `network {}` entries to use your smartphone internet connection.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的无线网络重新配置为使用智能手机的接入点连接，并通过删除`network {}`条目重置您的`/etc/wpa_supplicant/wpa_supplicant.conf`配置文件，以使用智能手机的互联网连接。
- en: Important Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For more information, you can check the next link:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，您可以查看下一个链接：
- en: '[https://wiki.archlinux.org/title/wpa_supplicant](https://wiki.archlinux.org/title/wpa_supplicant)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.archlinux.org/title/wpa_supplicant](https://wiki.archlinux.org/title/wpa_supplicant)'
- en: 'Now, you can configure your touchscreen. In this case, we are using the Miuzei
    LCD 4.0-inch HDMI display, which flips the screen. For this, execute the following
    commands:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以配置触摸屏了。在此，我们使用的是Miuzei LCD 4.0英寸HDMI显示器，它可以翻转屏幕。为此，执行以下命令：
- en: '[PRE46]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, restart your device by running the following command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令重启你的设备：
- en: '[PRE47]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, access the **Detect** shortcut to start the service to detect objects.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问**检测**快捷方式以启动检测物体的服务。
- en: Important Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can accelerate the video-frame analysis by uncommenting the `--enableEdgeTPU`
    flag in the `ch14/code/python/object_detection/run.sh` file. Our detection code
    is based on the official Tensor Flow example that uses the Coral USB Accelerator
    device. This device is a TPU, which is a dedicated unit to process information
    using NNs. The configuration of the Coral device is out of the scope of this book.
    For more information, check the Coral USB Accelerator link in the *Further reading*
    section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`ch14/code/python/object_detection/run.sh`文件中取消注释`--enableEdgeTPU`标志来加速视频帧分析。我们的检测代码基于官方TensorFlow示例，该示例使用了Coral
    USB加速器设备。该设备是一个TPU，是专门用于处理神经网络信息的单元。Coral设备的配置超出了本书的范围。如需更多信息，请查阅*进一步阅读*部分中的Coral
    USB加速器链接。
- en: Start the Traffic Map application by clicking on the **Traffic** shortcut. If
    there are objects detected, they will appear 30 seconds later in the web application.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**交通**快捷方式启动交通地图应用。如果检测到物体，它们将在30秒后显示在Web应用中。
- en: The last step is to deploy a public **Traffic Map** application to visualize
    all traffic in a radius area. For this, let’s deploy the last service—**Traffic
    Map Public**—in the next section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是部署一个公共**交通地图**应用来可视化一个半径区域内的所有交通。为此，我们将在下一部分部署最后一个服务——**交通地图公共版**。
- en: Deploying a global visualizer for the smart traffic system
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个智能交通系统的全球可视化器
- en: 'The **Traffic Map Public** service is the static version of **Traffic Map**
    that only shows detected objects within a radius of 5 kilometers. This service
    is deployed in the cloud, so you should expect the same visualization as with
    the **Traffic Map** service, but the only missing part is that it doesn’t show
    your real-time GPS position because it is static. The GPS position to take into
    consideration could be a GPS coordinate that is the center of the city that you
    want to monitor. In general, this web visualization could fit a static report
    for a municipality. The code is the same as for the **Traffic Map** web application,
    but the continuous update of the GPS position is omitted. To deploy this service,
    run the following commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**交通地图公共版**服务是**交通地图**的静态版本，仅显示半径5公里内的检测物体。该服务部署在云端，因此你可以期望它与**交通地图**服务提供相同的可视化效果，唯一的不同是它不会显示你的实时GPS位置，因为它是静态的。需要考虑的GPS位置可以是你希望监控的城市中心的GPS坐标。一般来说，这种Web可视化适合作为市政的静态报告。代码与**交通地图**Web应用相同，但省略了GPS位置的连续更新。要部署此服务，请运行以下命令：'
- en: 'Create a `traffic-map` deployment by running the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建一个`traffic-map`部署：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This deployment has the following environment variables:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部署有以下环境变量：
- en: '`LATITUDE`: Initial GPS latitude coordinate to center your map.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LATITUDE`：初始GPS纬度坐标，用于将地图居中。'
- en: '`LONGITUDE`: Initial GPS longitude coordinate to center your map.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONGITUDE`：初始GPS经度坐标，用于将地图居中。'
- en: '`GPS_QUEUE`: IP address endpoint of the `gps-queue` service. In this case,
    because this runs locally, it is set by default as `localhost`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPS_QUEUE`：`gps-queue`服务的IP地址端点。在此情况下，因为是本地运行，所以默认设置为`localhost`。'
- en: '`TRAFFIC_MANAGER`: IP address endpoint of your `localhost`, which prevents
    the CORS restriction.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRAFFIC_MANAGER`：你的`localhost`的IP地址端点，用于防止CORS限制。'
- en: Important Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To check the code and create your own container of `traffic-map-public`, you
    can check the next link:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查代码并创建你自己的`traffic-map-public`容器，可以查看以下链接：
- en: '[https://github.com/sergioarmgpl/containers/tree/main/traffic-map-public/src](https://github.com/sergioarmgpl/containers/tree/main/traffic-map-public/src)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/sergioarmgpl/containers/tree/main/traffic-map-public/src](https://github.com/sergioarmgpl/containers/tree/main/traffic-map-public/src)'
- en: 'Now, let’s create a service for this deployment as a LoadBalancer. This IP
    address will be the endpoint to access the Traffic Map public web application.
    The code is illustrated in the following snippet:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为这个部署创建一个作为负载均衡器的服务。这个IP地址将是访问Traffic Map公共Web应用的端点。代码示例如下：
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Important Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To troubleshoot your deployments, you can use the `$ kubectl logs pod/<POD>
    -f <CONTAINER_NAME>` command. This will show you some useful outputs to troubleshoot
    services.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 若要排查部署问题，可以使用`$ kubectl logs pod/<POD> -f <CONTAINER_NAME>`命令。这将展示一些有用的输出，帮助排查服务问题。
- en: 'Get the load balancer IP for your `traffic-map-public` deployment with the
    following command:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取`traffic-map-public`部署的负载均衡器IP：
- en: '[PRE50]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can see the value of the `TRAFFIC_MAP_PUBLIC` environment variable by running
    the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令查看`TRAFFIC_MAP_PUBLIC`环境变量的值：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that it takes some time after the IP address of the load balancer is provisioned.
    You can check the state of the services by running the following command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，负载均衡器的IP地址配置后需要一些时间。您可以通过运行以下命令检查服务的状态：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Wait until the `EXTERNAL_IP` environment variable is provisioned.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 等待`EXTERNAL_IP`环境变量配置完毕。
- en: Access the Traffic Map public application at `http://<TRAFFIC_MAP_PUBLIC>:3000`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`http://<TRAFFIC_MAP_PUBLIC>:3000`访问Traffic Map公共应用。
- en: Now everything is running, try to fill the system with data and drive your car
    with your edge device to capture objects. You will then see the objects in the
    system in a few seconds. Take a look at the *Further reading* section, where there
    are a lot of materials that you can explore to create your system. But now, it’s
    time to summarize what we learned. Let’s move on to the *Summary* section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都在运行，试着向系统填充数据，并通过您的边缘设备驾驶汽车以捕捉物体。然后，您将在几秒钟内看到系统中的物体。请查看*进一步阅读*部分，那里有大量可以探索的资料，帮助您构建自己的系统。但现在，是时候总结我们学到的内容了。让我们进入*总结*部分。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how you can use AI to analyze video captured by
    cameras, to detect objects that potentially represent obstacles for drivers. This
    was implemented to run at the edge on a Raspberry Pi, using the power of Kubernetes
    with K3s. With this approach, we created a decoupled system that could be easier
    to upgrade using containers. We also learned how this kind of system can be used
    in real-world scenarios to monitor traffic behavior to improve driver safety.
    Across this implementation, we also learned how this kind of system is distributed
    across the edge and the cloud to process and show information locally to drivers
    to improve their driving experience. In the last chapter, we are going to give
    an easy method to organize and design fast your own edge computing system using
    a diagram called the edge computing design system canvas.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用AI分析由摄像头拍摄的视频，检测潜在的障碍物。这一功能在边缘计算环境下，通过K3s和Raspberry Pi实现。通过这种方法，我们创建了一个解耦的系统，能够通过容器轻松升级。我们还学到了如何将这种系统应用于现实场景中，监控交通行为以提高驾驶安全性。通过这一实现，我们还了解了如何将这种系统分布在边缘和云端，处理并展示本地信息，提升驾驶体验。在最后一章中，我们将介绍一种简单的方法，通过一个名为边缘计算设计系统画布的图表，帮助您快速组织和设计自己的边缘计算系统。
- en: Questions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are a few questions to validate your new knowledge:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个问题，帮助验证您新学到的知识：
- en: How are AI, ML, and computer vision related to each other to design smart traffic
    systems?
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能、机器学习和计算机视觉如何相互关联，以设计智能交通系统？
- en: How do TensorFlow Lite and scikit-learn work to detect objects and perform predictions?
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow Lite和scikit-learn是如何协作检测物体并进行预测的？
- en: How does computer vision work running at the edge?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机视觉在边缘设备上是如何工作的？
- en: How can you distribute data across the edge and the cloud?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在边缘和云端之间分布数据？
- en: How can you use Python to build a computer vision system?
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python构建计算机视觉系统？
- en: How can you use K3s to design distributed systems that detect objects in real
    time?
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用K3s设计实时检测物体的分布式系统？
- en: Further reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following references for more information on the topics
    covered in this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下资料，获取本章涉及主题的更多信息：
- en: '*What is artificial intelligence (AI)?*: [https://www.techtarget.com/searchenterpriseai/definition/AI-Artificial-Intelligence](https://www.techtarget.com/searchenterpriseai/definition/AI-Artificial-Intelligence)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是人工智能（AI）？*：[https://www.techtarget.com/searchenterpriseai/definition/AI-Artificial-Intelligence](https://www.techtarget.com/searchenterpriseai/definition/AI-Artificial-Intelligence)'
- en: '*Agents in Artificial Intelligence*: [https://www.geeksforgeeks.org/agents-artificial-intelligence](https://www.geeksforgeeks.org/agents-artificial-intelligence)
    and [https://www.educba.com/agents-in-artificial-intelligence](https://www.educba.com/agents-in-artificial-intelligence)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人工智能中的智能体*: [https://www.geeksforgeeks.org/agents-artificial-intelligence](https://www.geeksforgeeks.org/agents-artificial-intelligence)
    和 [https://www.educba.com/agents-in-artificial-intelligence](https://www.educba.com/agents-in-artificial-intelligence)'
- en: '*Smart Traffic Management: Optimizing Your City’s Infrastructure Spend*: [https://www.digi.com/blog/post/smart-traffic-management-optimizing-spend](https://www.digi.com/blog/post/smart-traffic-management-optimizing-spend)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*智能交通管理：优化城市基础设施支出*: [https://www.digi.com/blog/post/smart-traffic-management-optimizing-spend](https://www.digi.com/blog/post/smart-traffic-management-optimizing-spend)'
- en: '*Markers with Custom Icons*: [https://leafletjs.com/examples/custom-icons](https://leafletjs.com/examples/custom-icons)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*带自定义图标的标记*: [https://leafletjs.com/examples/custom-icons](https://leafletjs.com/examples/custom-icons)'
- en: '*MLOps Using Argo and K3s*: [https://github.com/sergioarmgpl/mlops-argo-k3s](https://github.com/sergioarmgpl/mlops-argo-k3s)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MLOps 使用 Argo 和 K3s*: [https://github.com/sergioarmgpl/mlops-argo-k3s](https://github.com/sergioarmgpl/mlops-argo-k3s)'
- en: '*YOLO and Tiny-YOLO object detection on the Raspberry Pi and Movidius NCS*:
    [https://pyimagesearch.com/2020/01/27/yolo-and-tiny-yolo-object-detection-on-the-raspberry-pi-and-movidius-ncs](https://pyimagesearch.com/2020/01/27/yolo-and-tiny-yolo-object-detection-on-the-raspberry-pi-and-movidius-ncs)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*YOLO 和 Tiny-YOLO 在 Raspberry Pi 和 Movidius NCS 上的物体检测*: [https://pyimagesearch.com/2020/01/27/yolo-and-tiny-yolo-object-detection-on-the-raspberry-pi-and-movidius-ncs](https://pyimagesearch.com/2020/01/27/yolo-and-tiny-yolo-object-detection-on-the-raspberry-pi-and-movidius-ncs)'
- en: '*TensorFlow Lite example apps*: [https://www.tensorflow.org/lite/examples](https://www.tensorflow.org/lite/examples)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TensorFlow Lite 示例应用*: [https://www.tensorflow.org/lite/examples](https://www.tensorflow.org/lite/examples)'
- en: '*TensorFlow Hub*: [https://tfhub.dev](https://tfhub.dev)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TensorFlow Hub*: [https://tfhub.dev](https://tfhub.dev)'
- en: 'Get models for TensorFlow Lite: [https://www.tensorflow.org/lite/models](https://www.tensorflow.org/lite/models)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '获取 TensorFlow Lite 的模型: [https://www.tensorflow.org/lite/models](https://www.tensorflow.org/lite/models)'
- en: '*Edge Analytics in Transportation and Logistics Space: A Case Study*: [https://www.skillsire.com/read-blog/174_edge-analytics-in-transportation-and-logistics-space-a-case-study.html](https://www.skillsire.com/read-blog/174_edge-analytics-in-transportation-and-logistics-space-a-case-study.html)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运输和物流领域的边缘分析：案例研究*: [https://www.skillsire.com/read-blog/174_edge-analytics-in-transportation-and-logistics-space-a-case-study.html](https://www.skillsire.com/read-blog/174_edge-analytics-in-transportation-and-logistics-space-a-case-study.html)'
- en: '*Tutorial to set up TensorFlow Object Detection API on the Raspberry Pi*: [https://github.com/EdjeElectronics/TensorFlow-Object-Detection-on-the-Raspberry-Pi](https://github.com/EdjeElectronics/TensorFlow-Object-Detection-on-the-Raspberry-Pi)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Raspberry Pi 上设置 TensorFlow 物体检测 API 的教程*: [https://github.com/EdjeElectronics/TensorFlow-Object-Detection-on-the-Raspberry-Pi](https://github.com/EdjeElectronics/TensorFlow-Object-Detection-on-the-Raspberry-Pi)'
- en: '*TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi*: [https://github.com/EdjeElectronics/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi](https://github.com/EdjeElectronics/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TensorFlow-Lite-物体检测在 Android 和 Raspberry Pi 上的应用*: [https://github.com/EdjeElectronics/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi](https://github.com/EdjeElectronics/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi)'
- en: '*TensorFlow Lite Python object detection example with Raspberry Pi*: [https://github.com/tensorflow/examples/tree/master/lite/examples/object_detection/raspberry_pi](https://github.com/tensorflow/examples/tree/master/lite/examples/object_detection/raspberry_pi)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TensorFlow Lite Python 物体检测示例与 Raspberry Pi*: [https://github.com/tensorflow/examples/tree/master/lite/examples/object_detection/raspberry_pi](https://github.com/tensorflow/examples/tree/master/lite/examples/object_detection/raspberry_pi)'
- en: '*Python Project – Real-time Human Detection & Counting*: [https://data-flair.training/blogs/python-project-real-time-human-detection-counting](https://data-flair.training/blogs/python-project-real-time-human-detection-counting)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 项目 – 实时人体检测与计数*: [https://data-flair.training/blogs/python-project-real-time-human-detection-counting](https://data-flair.training/blogs/python-project-real-time-human-detection-counting)'
- en: 'Coral USB Accelerator: [https://coral.ai/products/accelerator](https://coral.ai/products/accelerator)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Coral USB 加速器: [https://coral.ai/products/accelerator](https://coral.ai/products/accelerator)'
- en: 'Edge TPU simple camera examples: [https://github.com/google-coral/examples-camera](https://github.com/google-coral/examples-camera)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Edge TPU 简单相机示例: [https://github.com/google-coral/examples-camera](https://github.com/google-coral/examples-camera)'
- en: '*Use NGINX as a Reverse Proxy*: [https://www.linode.com/docs/guides/use-nginx-reverse-proxy](https://www.linode.com/docs/guides/use-nginx-reverse-proxy)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 NGINX 作为反向代理*: [https://www.linode.com/docs/guides/use-nginx-reverse-proxy](https://www.linode.com/docs/guides/use-nginx-reverse-proxy)'
- en: '*Movidius on Mac OS*: [https://github.com/acharroux/Movidius-On-MacOS](https://github.com/acharroux/Movidius-On-MacOS)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Movidius 在 Mac OS 上*: [https://github.com/acharroux/Movidius-On-MacOS](https://github.com/acharroux/Movidius-On-MacOS)'
- en: '*NCS-Pi-Stream*: [https://github.com/HanYangZhao/NCS-Pi-Stream](https://github.com/HanYangZhao/NCS-Pi-Stream)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NCS-Pi-Stream*: [https://github.com/HanYangZhao/NCS-Pi-Stream](https://github.com/HanYangZhao/NCS-Pi-Stream)'
- en: '*Intel® Neural Compute Stick 2 (Intel® NCS2)*: [https://www.intel.com/content/www/us/en/developer/tools/neural-compute-stick/overview.html](https://www.intel.com/content/www/us/en/developer/tools/neural-compute-stick/overview.html)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Intel® 神经计算棒 2（Intel® NCS2）*: [https://www.intel.com/content/www/us/en/developer/tools/neural-compute-stick/overview.html](https://www.intel.com/content/www/us/en/developer/tools/neural-compute-stick/overview.html)'
- en: '*Deep Surveillance with Deep Learning – Intelligent Video Surveillance Project*:
    [https://data-flair.training/blogs/deep-surveillance-with-deep-learning-intelligent-video-surveillance-project](https://data-flair.training/blogs/deep-surveillance-with-deep-learning-intelligent-video-surveillance-project)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深度学习下的深度监控 – 智能视频监控项目*: [https://data-flair.training/blogs/deep-surveillance-with-deep-learning-intelligent-video-surveillance-project](https://data-flair.training/blogs/deep-surveillance-with-deep-learning-intelligent-video-surveillance-project)'
- en: '*Road Lane line detection – Computer Vision Project in Python*: [https://data-flair.training/blogs/road-lane-line-detection](https://data-flair.training/blogs/road-lane-line-detection)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*道路车道线检测 – Python 中的计算机视觉项目*: [https://data-flair.training/blogs/road-lane-line-detection](https://data-flair.training/blogs/road-lane-line-detection)'
- en: '*Raspberry Pi and Movidius NCS Face Recognition*: [https://pyimagesearch.com/2020/01/06/raspberry-pi-and-movidius-ncs-face-recognition](https://pyimagesearch.com/2020/01/06/raspberry-pi-and-movidius-ncs-face-recognition)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Raspberry Pi 和 Movidius NCS 人脸识别*: [https://pyimagesearch.com/2020/01/06/raspberry-pi-and-movidius-ncs-face-recognition](https://pyimagesearch.com/2020/01/06/raspberry-pi-and-movidius-ncs-face-recognition)'
- en: '*OpenVINO, OpenCV, and Movidius NCS on the Raspberry Pi*: [https://pyimagesearch.com/2019/04/08/openvino-opencv-and-movidius-ncs-on-the-raspberry-pi](https://pyimagesearch.com/2019/04/08/openvino-opencv-and-movidius-ncs-on-the-raspberry-pi)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Raspberry Pi 上使用 OpenVINO、OpenCV 和 Movidius NCS*: [https://pyimagesearch.com/2019/04/08/openvino-opencv-and-movidius-ncs-on-the-raspberry-pi](https://pyimagesearch.com/2019/04/08/openvino-opencv-and-movidius-ncs-on-the-raspberry-pi)'
- en: '*Speed up predictions on low-power devices using Neural Compute Stick and OpenVINO*:
    [https://towardsdatascience.com/speed-up-predictions-on-low-power-devices-using-neural-compute-stick-and-openvino-98f3ae9dcf41](https://towardsdatascience.com/speed-up-predictions-on-low-power-devices-using-neural-compute-stick-and-openvino-98f3ae9dcf41)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用神经计算棒和 OpenVINO 加速低功耗设备上的预测*: [https://towardsdatascience.com/speed-up-predictions-on-low-power-devices-using-neural-compute-stick-and-openvino-98f3ae9dcf41](https://towardsdatascience.com/speed-up-predictions-on-low-power-devices-using-neural-compute-stick-and-openvino-98f3ae9dcf41)'
- en: '*Deep Learning with Movidius NCS (pt.4) Installing NCSDK on a Rock64*: [https://www.youtube.com/watch?v=AXzIYk7-lr8](https://www.youtube.com/watch?v=AXzIYk7-lr8)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Movidius NCS 进行深度学习（第 4 部分）：在 Rock64 上安装 NCSDK*: [https://www.youtube.com/watch?v=AXzIYk7-lr8](https://www.youtube.com/watch?v=AXzIYk7-lr8)'
- en: '*Glyph-based video visualization on Google Map for surveillance in smart cities*:
    [https://jivp-eurasipjournals.springeropen.com/articles/10.1186/s13640-017-0175-4](https://jivp-eurasipjournals.springeropen.com/articles/10.1186/s13640-017-0175-4)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于字形的视频可视化在智能城市中进行监控的 Google Map 上*: [https://jivp-eurasipjournals.springeropen.com/articles/10.1186/s13640-017-0175-4](https://jivp-eurasipjournals.springeropen.com/articles/10.1186/s13640-017-0175-4)'
- en: '*Looking-In and Looking-Out of a Vehicle: Computer-Vision-Based Enhanced Vehicle
    Safety*: [https://escholarship.org/content/qt2g6313r2/qt2g6313r2_noSplash_81ae2290f201a6b25e8eecc8a1142845.pdf?t=lnpgaj](https://escholarship.org/content/qt2g6313r2/qt2g6313r2_noSplash_81ae2290f201a6b25e8eecc8a1142845.pdf?t=lnpgaj)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*车辆内外观：基于计算机视觉的增强车辆安全性*: [https://escholarship.org/content/qt2g6313r2/qt2g6313r2_noSplash_81ae2290f201a6b25e8eecc8a1142845.pdf?t=lnpgaj](https://escholarship.org/content/qt2g6313r2/qt2g6313r2_noSplash_81ae2290f201a6b25e8eecc8a1142845.pdf?t=lnpgaj)'
- en: '*Install Touch Screen and Touch Calibration Program for Raspberry Pi*: [https://www.gechic.com/en/raspberry-pi-install-touch-monitor-and-touch-calibrator-driver](https://www.gechic.com/en/raspberry-pi-install-touch-monitor-and-touch-calibrator-driver)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为 Raspberry Pi 安装触摸屏和触摸校准程序*: [https://www.gechic.com/en/raspberry-pi-install-touch-monitor-and-touch-calibrator-driver](https://www.gechic.com/en/raspberry-pi-install-touch-monitor-and-touch-calibrator-driver)'
- en: '*Rotating a Raspberry Pi 4 Touch Monitor*: [https://www.interelectronix.com/rotating-raspberry-pi-4-touch-monitor.html](https://www.interelectronix.com/rotating-raspberry-pi-4-touch-monitor.html)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旋转树莓派 4 触摸屏显示器*: [https://www.interelectronix.com/rotating-raspberry-pi-4-touch-monitor.html](https://www.interelectronix.com/rotating-raspberry-pi-4-touch-monitor.html)'
- en: '*Calibrating Touchscreen*: [https://wiki.archlinux.org/title/Calibrating_Touchscreen](https://wiki.archlinux.org/title/Calibrating_Touchscreen)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*校准触摸屏*: [https://wiki.archlinux.org/title/Calibrating_Touchscreen](https://wiki.archlinux.org/title/Calibrating_Touchscreen)'
