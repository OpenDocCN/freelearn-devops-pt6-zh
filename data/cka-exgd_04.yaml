- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Application Scheduling and Lifecycle Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序调度和生命周期管理
- en: This chapter describes how to use Kubernetes deployments to deploy pods, scale
    pods, perform rolling updates and rollbacks, carry out resource management, and
    use ConfigMaps to configure pods using `kubectl` commands and YAML definitions.
    This chapter covers 15% of the CKA exam content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何使用 Kubernetes 部署来部署 Pods、扩展 Pods、执行滚动更新和回滚、进行资源管理，并使用 ConfigMaps 配置 Pods，使用
    `kubectl` 命令和 YAML 定义。本章涵盖了 CKA 考试内容的 15%。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主要内容：
- en: The basics of Kubernetes workloads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 工作负载基础
- en: Deploying and managing applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和管理应用程序
- en: Scaling applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Performing rolling updates and rollbacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行滚动更新和回滚
- en: Resource management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理
- en: Workload scheduling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作负载调度
- en: Configuring applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get started, we need to make sure your local machine meets the following
    technical requirements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们需要确保你的本地机器满足以下技术要求：
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容的 Linux 主机——我们推荐基于 Debian 的 Linux 发行版，如 Ubuntu 18.04 或更高版本
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的主机至少具有 2 GB 内存、2 个 CPU 核心以及约 20 GB 的空闲磁盘空间
- en: The basics of Kubernetes workloads
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 工作负载基础
- en: 'Kubernetes orchestrates your workloads to achieve the desired status – a containerized
    workload with applications running on Kubernetes, including stateless, stateful,
    and data-processing applications. In terms of cloud-native applications, there’s
    an interesting white paper that introduced the notion of cloud-native applications
    and design patterns thoroughly, which you can check out here if you’re interested:
    [https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper](https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 协调你的工作负载以实现期望的状态——一个运行在 Kubernetes 上的容器化工作负载，包括无状态、有状态和数据处理应用程序。关于云原生应用程序，有一篇有趣的白皮书深入介绍了云原生应用程序的概念和设计模式，如果你感兴趣，可以在这里查看：[https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper](https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper)。
- en: The fundamental building blocks of any containerized workload up and running
    in the Kubernetes cluster are called Kubernetes API primitives or Kubernetes objects.
    They are the API resource types defined in Kubernetes, including pods, ReplicaSets,
    DaemonSets, StatefulSets, Job and CronJob objects, and Deployments, among others
    mentioned in [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在 Kubernetes 集群中运行的容器化工作负载的基本构建模块称为 Kubernetes API 原语或 Kubernetes 对象。它们是 Kubernetes
    中定义的 API 资源类型，包括 Pods、ReplicaSets、DaemonSets、StatefulSets、Job 和 CronJob 对象，以及在[*第一章*](B18201_01.xhtml#_idTextAnchor015)中提到的
    Deployments，*Kubernetes 概述*。
- en: The CKA exam covers some of the main Kubernetes objects such as Pods, Deployments,
    ReplicaSets, and DaemonSets while working with Kubernetes clusters and we’ll dive
    into further detail in the following section of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CKA 考试涵盖了一些主要的 Kubernetes 对象，如 Pods、Deployments、ReplicaSets 和 DaemonSets，在使用
    Kubernetes 集群时，我们将在本章的下一部分深入探讨这些内容。
- en: Please make sure your local machine meets the required technical requirements
    before diving into the practice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实践之前，请确保你的本地机器符合所需的技术要求。
- en: Imperative management versus declarative management
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式管理与声明式管理
- en: There are a few ways to communicate with API servers in Kubernetes – mainly,
    they can be categorized as either imperative management or declarative management.
    You will need to use both `kubectl` and YAML definitions to manage Kubernetes
    objects. The `kubectl` utilities can support all the management techniques for
    managing Kubernetes objects, as Kubernetes is intended to be a desired state manager.
    After executing a `kubectl` command, as a result, it moves the current workload
    running in Kubernetes from its actual state to the desired state, which is defined
    in the command-line parameters or YAML-defined specifications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，有几种方式可以与 API 服务器进行通信——主要可以归类为命令式管理或声明式管理。你将需要同时使用 `kubectl` 和
    YAML 定义来管理 Kubernetes 对象。`kubectl` 工具支持所有管理 Kubernetes 对象的管理技术，因为 Kubernetes 旨在作为期望状态的管理器。执行
    `kubectl` 命令后，结果将当前运行在 Kubernetes 中的工作负载从实际状态转移到期望状态，该期望状态是在命令行参数或 YAML 定义的规范中定义的。
- en: Time management is the key to success in the CKA exam. Getting familiar with
    `kubectl` commands will help you save a lot of time when it comes to a new deployment.
    A good understanding of YAML definition will help you update the configurations
    quickly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 时间管理是 CKA 考试成功的关键。熟悉 `kubectl` 命令将帮助你在新部署时节省大量时间。对 YAML 定义的良好理解将帮助你快速更新配置。
- en: Understanding pods
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Pod
- en: 'The smallest deployable unit in Kubernetes is a pod. The pod contains the actual
    application workload – it could be one or multiple containers. A pod in Kubernetes
    has a defined lifecycle. We’ll cover the following topic about pods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中最小的可部署单元是 Pod。Pod 包含实际的应用工作负载 – 它可以是一个或多个容器。Kubernetes 中的 Pod 有一个定义的生命周期。我们将覆盖以下关于
    Pod 的主题：
- en: Understanding pods
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Pod
- en: Understanding health probing for pods
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Pod 的健康探测
- en: Understanding a multi-container pod
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多容器 Pod
- en: Understanding an init container
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解初始化容器
- en: Understanding a static pod
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态 Pod
- en: 'Let’s take a look at the pod first. You can create a pod using an imperative
    command as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下 Pod。你可以使用如下命令创建一个 Pod：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is an example of running a pod named `ngin-pod` with the image as `nginx`
    and the image tag as `alpine`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行名为 `ngin-pod` 的 Pod 示例，镜像为 `nginx`，镜像标签为 `alpine`：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see the output is returned as `created`, as follows, to indicate that
    your pod has been created successfully:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到输出返回为`created`，如下所示，表示你的 Pod 已经成功创建：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the process, you will see pod has the `ContainerCreating` status, indicating
    that the container is being created, and you can use `kubectl` to describe a pod
    command to see what’s going on. The following command is what we can use to check
    the pod’s current status:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，你将看到 Pod 具有 `ContainerCreating` 状态，表示容器正在创建，你可以使用 `kubectl` 的描述命令查看发生了什么。我们可以使用以下命令检查
    Pod 的当前状态：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the bottom of the `describe` command, you will see the events – this is
    helpful information for you to use to check whether anything is going wrong during
    your deployment. We will explore troubleshooting pods further in [*Chapter 8*](B18201_08.xhtml#_idTextAnchor293),
    *Monitoring and Logging Kubernetes Clusters and Applications*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `describe` 命令的底部，你将看到事件 – 这对于你检查部署过程中是否出现问题非常有帮助。我们将在[*第8章*](B18201_08.xhtml#_idTextAnchor293)中进一步探讨
    Pod 故障排除，*监控和日志 Kubernetes 集群与应用程序*：
- en: '![Figure 4.1 – The pod events ](img/Figure_4.01_B18201.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Pod 事件](img/Figure_4.01_B18201.jpg)'
- en: Figure 4.1 – The pod events
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Pod 事件
- en: 'The same pod can be YAML-defined, as follows, which will give you the same
    result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的 Pod 也可以通过 YAML 定义，如下所示，结果相同：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use the following command to deploy a YAML definition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来部署一个 YAML 定义：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, we can run a BusyBox image with a single command, such as the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过一个命令运行 BusyBox 镜像，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also deploy a `nginx` image and then export the YAML definition by
    using the `-o yaml` flag :'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以部署一个 `nginx` 镜像，然后使用 `-o yaml` 标志导出 YAML 定义：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After running this command, a sample `yaml` file will be exported to your local
    PC – you can edit this `yaml` file to make changes locally if needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，一个示例的 `yaml` 文件将被导出到本地计算机 – 如果需要，你可以编辑这个 `yaml` 文件进行本地修改。
- en: Understanding liveness, readiness, and startup probes
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解存活性、就绪性和启动探针
- en: 'To explore the health status of the pods further, let’s talk about health probes.
    Probes allow you to know how Kubernetes determines the states of your containers.
    Let’s have look at each of them one by one:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探讨 Pod 的健康状态，我们来谈谈健康探针。探针让你了解 Kubernetes 如何判断容器的状态。我们来逐一看看每种探针：
- en: '**Liveness probes** indicate whether the container is running properly, as
    they govern when the cluster will decide to restart the container automatically.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存活性探针**表示容器是否正常运行，因为它们决定了集群何时自动重启容器。'
- en: '**Readiness probes** indicate whether the container is ready to accept requests.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**就绪性探针**表示容器是否准备好接受请求。'
- en: '`kubelet` before they get on their feet. Once configured, they disable liveness
    and readiness checkers until they’re complete.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubelet` 在它们启动之前会进行初始化。一旦配置完成，它们会禁用存活性检查和就绪性检查，直到容器启动完成。'
- en: 'We’ll have a look at these in more detail in [*Chapter 8*](B18201_08.xhtml#_idTextAnchor293)*,*
    *Monitoring and Logging Kubernetes Clusters and Applications*. You can find further
    details about health probes at the following link: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 8 章*](B18201_08.xhtml#_idTextAnchor293) 中更详细地了解这些内容，*《Kubernetes 集群和应用程序的监控与日志记录》*。你可以通过以下链接找到更多关于健康检查探针的细节：[https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)。
- en: Understanding a multi-container pod
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解多容器 Pod
- en: 'Multi-container pods are simply pods with more than one container working together
    as a single unit. When it comes to multiple containers residing in a pod, a container
    interacts with another in the following two ways:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多容器 Pod 就是具有多个容器一起作为一个单元工作的 Pod。当多个容器驻留在一个 Pod 中时，一个容器与另一个容器的交互有以下两种方式：
- en: '**Shared networking**: When two containers are running on the same host when
    they are in the same pod, they can access each other by simply using *localhost*.
    All the listening ports are accessible to other containers in the pod, even if
    they’re not exposed outside the pod.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享网络**：当两个容器在同一主机上运行并且它们在同一个 Pod 中时，它们可以通过简单地使用 *localhost* 互相访问。即使容器没有对外暴露端口，Pod
    内的所有监听端口也可以被其他容器访问。'
- en: '*Figure 4.2* shows how multiple containers in the same pod share a local network
    with each other:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.2* 显示了同一 Pod 中多个容器如何共享本地网络：'
- en: '![Figure 4.2 – A multi-container pod’s shared network  ](img/Figure_4.02_B18201.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 多容器 Pod 的共享网络](img/Figure_4.02_B18201.jpg)'
- en: Figure 4.2 – A multi-container pod’s shared network
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 多容器 Pod 的共享网络
- en: '**Shared storage volumes**: We can mount the same volume to two different containers
    so that they can both interact with the same data – it is possible to have one
    container write data to the volume and the other container read that data from
    the same volume. Some volumes even allow concurrent reading and writing. We’ll
    dive deeper into how storage works for multi-container pods in [*Chapter 5*](B18201_05.xhtml#_idTextAnchor149),
    *Demystifying Kubernetes Storage*.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享存储卷**：我们可以将相同的存储卷挂载到两个不同的容器，以便它们可以共同访问相同的数据 —— 一个容器可以将数据写入存储卷，另一个容器则可以从同一存储卷读取数据。有些存储卷甚至允许并发读写。我们将在
    [*第 5 章*](B18201_05.xhtml#_idTextAnchor149) 中深入探讨多容器 Pod 的存储工作原理，*《揭开 Kubernetes
    存储的神秘面纱》*。'
- en: '*Figure 4.3* shows how multiple containers in the same pod share local storage
    with each other:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.3* 显示了同一 Pod 中多个容器如何共享本地存储：'
- en: '![Figure 4.3 – A multi-container pod’s shared storage volume ](img/Figure_4.03_B18201.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 多容器 Pod 的共享存储卷](img/Figure_4.03_B18201.jpg)'
- en: Figure 4.3 – A multi-container pod’s shared storage volume
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 多容器 Pod 的共享存储卷
- en: 'The following is an example of how to create multiple containers in a pod:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在 Pod 中创建多个容器的示例：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In general, it is good to have a one-to-one relationship between a container
    and a pod, which follows the principles of building microservices by keeping each
    module independent. The real world is sometimes more complicated than it may seem,
    let’s take a look at multi-container pods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，容器与 Pod 之间最好是保持一对一的关系，这符合通过保持每个模块独立来构建微服务的原则。现实世界有时比看起来更复杂，让我们来看看多容器 Pod
    的情况。
- en: Understanding an init container
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解初始化容器
- en: 'An init container is configured in a pod to execute before the container host
    starts. It is specified inside an `initContainers` section, as in the following
    example. You can configure multiple init containers too, which will allow each
    init container to complete one at a time in sequential order:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器是在 Pod 中配置的，用于在容器主机启动之前执行。它在 `initContainers` 部分中指定，如以下示例所示。你还可以配置多个初始化容器，这样每个初始化容器将按顺序逐个完成：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the case that any of the init containers fail to complete, Kubernetes will
    restart the pod repeatedly until the init container succeeds. To learn more about
    init containers, visit the following link: [https://kubernetes.io/docs/concepts/workloads/pods/init-containers/](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何初始化容器未能完成，Kubernetes 会不断重启 Pod，直到初始化容器成功。要了解更多关于初始化容器的信息，请访问以下链接：[https://kubernetes.io/docs/concepts/workloads/pods/init-containers/](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/)。
- en: Understanding a static Pod
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解静态 Pod
- en: As the captain of a worker node, the `kubelet` agent can manage a node independently,
    and it can create pods. The pods that are managed directly by the `kubelet` daemon
    and bound to a specific node are called static pods. As opposed to pods that are
    managed by the Kubernetes master, static pods are watched by the `kubelet` agent,
    and it restarts in the case of failure.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为工作节点的“队长”，`kubelet` 代理可以独立管理一个节点，并且可以创建 pods。由 `kubelet` 守护进程直接管理并绑定到特定节点的
    pod 称为静态 pod。与由 Kubernetes 主节点管理的 pod 相对，静态 pod 由 `kubelet` 代理监视，并且在失败时会重启。
- en: 'The way to configure `kubelet` so that it reads the pod definition files is
    to add a YAML specification under the following directory where the static pod
    information is stored:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `kubelet` 使其读取 pod 定义文件的方法是将 YAML 规范添加到以下目录，该目录存储静态 pod 信息：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`kubelet` checks this directory periodically. This path can be configured in
    `kubelet.service`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubelet` 会定期检查该目录。此路径可以在 `kubelet.service` 中进行配置。'
- en: Understanding Job and CronJob objects
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Job 和 CronJob 对象
- en: '`Completed` status.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Completed` 状态。'
- en: Jobs can be used to reliably execute a workload until it completes. The Job
    will create one or more pods. When the Job is finished, the containers will exit
    and the pods will enter the `Completed` status. An example use of Jobs is when
    we want to run a particular workload and make sure that it runs once and succeeds.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Jobs 可用于可靠地执行工作负载，直到其完成。Job 将创建一个或多个 pod。当 Job 完成时，容器将退出，pod 将进入 `Completed`
    状态。Jobs 的一个典型使用场景是当我们想要运行特定的工作负载，并确保它只运行一次并成功执行时。
- en: 'You can create a Job with a YAML description:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 YAML 描述来创建一个 Job：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `backoffLimit` parameter means that, if it fails `4` times, this is the
    limit. All the Job does the same as it is while creating a pod under the hood.
    Although a normal pod is constantly running, when a Job is complete, it goes into
    the `Completed` status. This means that the container is no longer running, so
    the pod still exists, but the container is complete.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`backoffLimit` 参数表示如果失败 `4` 次，这就是限制。所有的 Job 在底层创建 pod 时都是一样的。虽然正常的 pod 会持续运行，但当
    Job 完成时，它会进入 `Completed` 状态。这意味着容器不再运行，所以 pod 仍然存在，但容器已经完成。'
- en: 'You can use the following command to deploy a YAML definition:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令部署 YAML 定义：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can run the following command to check the Job’s status:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以运行以下命令检查 Job 的状态：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the Job is still running, you can see the `Running` status. When the Job
    is finished, you can see that it is complete from the following:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Job 仍在运行时，你可以看到 `Running` 状态。当 Job 完成时，你可以看到它是完成状态，以下是一个例子：
- en: '![Figure 4.4 – The Job is complete ](img/Figure_4.04_B18201.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – Job 已完成](img/Figure_4.04_B18201.jpg)'
- en: Figure 4.4 – The Job is complete
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Job 已完成
- en: '**CronJobs**, based on the capability of a Job, add value by allowing users
    to execute Jobs on a schedule. Users can use cron expressions to define a particular
    schedule as per their requirements. The following is an example of a CronJob YAML
    definition:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**CronJobs** 基于 Job 的能力，通过允许用户按计划执行 Jobs 来增加价值。用户可以使用 cron 表达式根据需求定义特定的计划。以下是
    CronJob YAML 定义的示例：'
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can use the following command to deploy a YAML definition:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令部署 YAML 定义：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use the following command to check the cron job’s status:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令检查 cron 作业的状态：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You’ll get an output as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得如下输出：
- en: '![Figure 4.5 – The cron job shown as complete ](img/Figure_4.05_B18201.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – cron 作业显示为已完成](img/Figure_4.05_B18201.jpg)'
- en: Figure 4.5 – The cron job shown as complete
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – cron 作业显示为已完成
- en: 'This cron job creates a few pods name `hello`, so we will use the following
    command to check the log of the Job:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 cron 作业创建了几个名为 `hello` 的 pod，因此我们将使用以下命令检查 Job 的日志：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You’ll get an output as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得如下输出：
- en: '![Figure 4.6 – The completed cron job pods  ](img/Figure_4.06_B18201.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 完成的 cron 作业 pod](img/Figure_4.06_B18201.jpg)'
- en: Figure 4.6 – The completed cron job pods
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 完成的 cron 作业 pod
- en: 'We can check the logs of these pods with the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查这些 pod 的日志：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can see that the cron job has been executed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 cron 作业已经执行完成：
- en: '![Figure 4.7 – The logs showing how the cron job was completed ](img/Figure_4.07_B18201.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 显示 cron 作业如何完成的日志](img/Figure_4.07_B18201.jpg)'
- en: Figure 4.7 – The logs showing how the cron job was completed
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 显示 cron 作业如何完成的日志
- en: 'If you want to delete cron jobs, you can use the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除 cron 作业，可以使用以下命令：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, you will see the following output indicating that your cron job has been
    deleted:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到以下输出，表示您的定时任务已被删除：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'CronJobs were promoted to general availability in Kubernetes v1.21\. You can
    find a great article about running automated tasks using a CronJob here: [https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs](https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CronJobs 已在 Kubernetes v1.21 中提升为正式功能。您可以在这里找到一篇关于使用 CronJob 执行自动化任务的精彩文章：[https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs](https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs)。
- en: Deploying and managing applications
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和管理应用程序
- en: The following sections of this chapter will take you through practical exercises
    with concrete examples that you would encounter in your real CKA exam, including
    how to deploy and scale applications, perform rolling updates and rollbacks for
    those applications, manage and govern the resource consumption for these applications,
    and configure them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的以下部分将通过具体的实践练习，带您了解您在实际 CKA 考试中会遇到的场景，包括如何部署和扩展应用程序、执行滚动更新和回滚、管理和治理这些应用程序的资源消耗，以及如何配置它们。
- en: Deploying applications
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Deploying applications can be achieved in various ways, such as deploying a
    pod with `kubectl` or a YAML definition, as we did in the *The basics of Kubernetes
    workloads* section of this chapter. Now, we’ll take a look at a more effective
    way of using Deployments. In this section, let’s get into how to deploy and scale
    applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序可以通过多种方式实现，例如通过 `kubectl` 或 YAML 定义来部署一个 pod，就像我们在本章的 *Kubernetes 工作负载基础*
    部分中所做的那样。现在，我们将深入了解使用 Deployments 的更有效方法。本节将介绍如何部署和扩展应用程序。
- en: Deployments
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Deployments
- en: 'A Deployment is a convenient way to define the desired state deployment – it
    provides us with a better way of upgrading the underlying instances seamlessly
    using rolling updates, undoing changes, and pausing and resuming changes as required.
    For example, things such as deploying a ReplicaSet with a certain number of replicas
    are easy to roll out and roll back, and more effective. The following figure depicts
    how a Deployment looks conceptually:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 是定义期望状态部署的便捷方式——它为我们提供了一种更好的方式来通过滚动更新无缝升级基础实例、撤销更改以及根据需要暂停和恢复更改。例如，像部署具有特定副本数的
    ReplicaSet 这样的操作可以轻松实现滚动发布和回滚，更加高效。下图展示了 Deployment 的概念图：
- en: '![Figure 4.8 – A Deployment ](img/Figure_4.08_B18201.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 一个 Deployment](img/Figure_4.08_B18201.jpg)'
- en: Figure 4.8 – A Deployment
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 一个 Deployment
- en: 'Deployments provide a way to define a desired state for the replica pod. You
    can use a YAML definition as follows to define a Deployment:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Deployments 提供了一种定义副本 pod 所需状态的方法。您可以使用如下的 YAML 定义来定义一个 Deployment：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following attributes are important to help you understand the preceding
    YAML definition:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性对于帮助您理解前面的 YAML 定义非常重要：
- en: '`spec.replicas` gives us the number of replica pods'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.replicas` 给出了副本 pod 的数量'
- en: '`spec.template` is the template pod descriptor that defines the pods that will
    be created'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.template` 是模板 pod 描述符，用于定义将要创建的 pod'
- en: '`spec.selector` is the deployment that will manage all pods whose labels match
    this selector'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.selector` 是将管理所有标签与此选择器匹配的 pod 的部署'
- en: 'We can create a Deployment using the following `kubectl` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 `kubectl` 命令来创建一个 Deployment：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After running the preceding command, you will then get the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，您将得到以下输出：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use `kubectl get deploy` to query all the Deployments in the current
    namespace as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `kubectl get deploy` 查询当前命名空间中的所有 Deployments，如下所示：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see the following Deployment status in the output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在输出中看到以下 Deployment 状态：
- en: '![Figure 4.9 – kubectl getting the Deployments ](img/Figure_4.09_B18201.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 使用 kubectl 获取 Deployments](img/Figure_4.09_B18201.jpg)'
- en: Figure 4.9 – kubectl getting the Deployments
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 使用 kubectl 获取 Deployments
- en: 'If you know the name of a Deployment, you can use the following command to
    get that Deployment:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道 Deployment 的名称，可以使用以下命令来获取该 Deployment：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will see the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 4.10 – kubectl getting a Deployment by name ](img/Figure_4.10_B18201.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 使用 kubectl 按名称获取 Deployment](img/Figure_4.10_B18201.jpg)'
- en: Figure 4.10 – kubectl getting a Deployment by name
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 使用 kubectl 按名称获取 Deployment
- en: 'The following command allows you to get the details of the Deployment:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令允许您获取 Deployment 的详细信息：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This command will help you understand the configurations in the Deployment,
    where you will see the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将帮助你了解 Deployment 中的配置，你将看到以下输出：
- en: '![Figure 4.11 – kubectl describing a Deployment ](img/Figure_4.11_B18201.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – kubectl 描述 Deployment](img/Figure_4.11_B18201.jpg)'
- en: Figure 4.11 – kubectl describing a Deployment
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – kubectl 描述 Deployment
- en: 'The following command allows you to live-edit the Deployments:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令允许你进行 Deployment 的实时编辑：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding command is a magical one that will allow you to *live-edit* a
    Deployment. The following is the sample output and you can edit it live – it works
    similarly to when you create a pod using the `vim` editor. You can live-edit the
    Deployment here, and then save and quit using `wq!`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令是一个非常有用的命令，它允许你*实时编辑* Deployment。以下是示例输出，你可以进行实时编辑——它的工作方式类似于你使用 `vim` 编辑器创建
    pod 时的操作。你可以在这里实时编辑 Deployment，然后使用 `wq!` 保存并退出：
- en: '![Figure 4.12 – kubectl describing a Deployment for live-editing ](img/Figure_4.12_B18201.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – kubectl 描述 Deployment 进行实时编辑](img/Figure_4.12_B18201.jpg)'
- en: Figure 4.12 – kubectl describing a Deployment for live-editing
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – kubectl 描述 Deployment 进行实时编辑
- en: 'Then, you can also delete Deployments if you don’t need them anymore with the
    `kubectl delete` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你不再需要 Deployment，可以使用 `kubectl delete` 命令删除它：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following output shows that the Deployment has been deleted successfully:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示 Deployment 已成功删除：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the deletion of the Deployment, the objects defined in that Deployment
    are also deleted, as they share the same lifecycle. In our third example, the
    deployed `nginx` pods are deleted, as we delete the `kubeserve` Deployment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Deployment 的删除，在该 Deployment 中定义的对象也被删除，因为它们共享相同的生命周期。在我们的第三个示例中，部署的`nginx`
    pod 被删除，因为我们删除了 `kubeserve` Deployment。
- en: Learning about Deployments allows you to manage your application in a more effective
    way, update it as an entity easier, and roll it back to its previous versions.
    In the next section, we’ll have a look at rolling updates and rollbacks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 Deployment 使你能够更有效地管理应用程序，更轻松地将其作为一个整体进行更新，并将其回滚至之前的版本。在下一节中，我们将了解滚动更新和回滚。
- en: Performing rolling updates and rollbacks
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行滚动更新和回滚
- en: Rolling updates provide a way to update a Deployment to a newer version more
    effectively and efficiently. This way, you can update Kubernetes objects such
    as replicas and pods gradually with nearly zero downtime. In a nutshell, you may
    consider either using the `kubectl set image` command or going straight to updating
    a YAML manifest file. In this section, we will introduce `kubectl set image`,
    as it is very effective and handy to use in your actual CKA exam.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新提供了一种更加高效、有效的方式来更新 Deployment 至较新版本。通过这种方式，你可以逐步更新 Kubernetes 对象，如副本和 pod，几乎实现零停机时间。简而言之，你可以考虑使用`kubectl
    set image`命令，或者直接更新 YAML 清单文件。在本节中，我们将介绍`kubectl set image`，因为它在实际的 CKA 考试中非常有效且便捷。
- en: Rolling updates with kubectl
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubectl 进行滚动更新
- en: 'From here, we’ll go through the steps of rolling updates with `kubectl`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍使用 `kubectl` 执行滚动更新的步骤：
- en: 'You can spin up a new Deployment, `kubeserve`, using the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令启动一个新的 Deployment，`kubeserve`：
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can use `kubectl` to update the container image as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl`按照以下方式更新容器镜像：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Important note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '`--record flag` records information about the updates so that it can be rolled
    back later. You can either use `--record flag` or `--record=true flag`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`--record flag` 用于记录更新的信息，以便以后可以回滚。你可以使用`--record flag`或者`--record=true flag`。'
- en: 'With the preceding command, you will see the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述命令后，你将看到以下输出：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can use the `kubectl describe` command to double-check whether your container
    image has updated successfully by typing the following command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `kubectl describe` 命令通过输入以下命令来再次检查容器镜像是否已成功更新：
- en: '[PRE33]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Your output should be similar to the following, in *Figure 4.14*, where you
    can see that the image is set to `nginx:1.18.0`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该类似于 *图 4.14*，其中你可以看到镜像已设置为`nginx:1.18.0`：
- en: '![Figure 4.13 – kubectl describing kubeserve after updating the image ](img/Figure_4.13_B18201.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – kubectl 描述更新镜像后的 kubeserve](img/Figure_4.13_B18201.jpg)'
- en: Figure 4.13 – kubectl describing kubeserve after updating the image
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – kubectl 描述更新镜像后的 kubeserve
- en: The `kubectl describe deploy` command comes in very handy when we are trying
    to check key information such as the container image, ports, and deployment-related
    events. This is also the case in the actual CKA exam – make sure you master the
    shortcut of this command, `k describe deploy`, which will help you work more effectively
    in the exam.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl describe deploy` 命令在我们尝试查看关键信息时非常有用，比如容器镜像、端口和与部署相关的事件。在实际的 CKA 考试中也是如此——确保你掌握此命令的快捷方式
    `k describe deploy`，这将帮助你在考试中更加高效地工作。'
- en: Rollback
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚
- en: 'Rollback allows us to revert to a previous state and a Deployment makes this
    super easy to achieve:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚使我们能够恢复到之前的状态，而部署让这一切变得非常简单：
- en: 'You can use the following `kubectl rollout` command to quickly recover if you
    need to perform a rollback:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要执行回滚，你可以使用以下 `kubectl rollout` 命令来快速恢复：
- en: '[PRE34]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your output should look as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应如下所示：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, if you use the `kubectl describe deploy kubeserve` command, you will see
    the following output indicating that the image has been rolled back:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你使用 `kubectl describe deploy kubeserve` 命令，你将看到以下输出，表明镜像已被回滚：
- en: '![Figure 4.14 – kubectl describing kubeserve after a rollback ](img/Figure_4.14_B18201.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – kubectl 描述回滚后的 kubeserve](img/Figure_4.14_B18201.jpg)'
- en: Figure 4.14 – kubectl describing kubeserve after a rollback
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – kubectl 描述回滚后的 kubeserve
- en: 'Now, you may be very curious as to whether we can keep a track of the history
    of our Deployments. You can use the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可能非常好奇是否可以跟踪我们部署的历史记录。你可以使用以下命令：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output would look as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 4.15 – kubectl describing kubeserve ](img/Figure_4.15_B18201.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – kubectl 描述 kubeserve](img/Figure_4.15_B18201.jpg)'
- en: Figure 4.15 – kubectl describing kubeserve
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – kubectl 描述 kubeserve
- en: 'In the case that you want to go back to a specific revision, you can use the
    `--to-revision` flag. You can see in *Figure 4.16* that we have revision `2` available
    thanks to using the `--record` flag when setting the image version. The following
    command is an example of undoing a Deployment and reverting to revision `2`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想回滚到特定版本，你可以使用 `--to-revision` 参数。你可以在 *图 4.16* 中看到，由于我们在设置镜像版本时使用了 `--record`
    参数，我们可以使用版本 `2`。以下命令是回滚部署并恢复到版本 `2` 的示例：
- en: '[PRE37]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Your output should look as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应如下所示：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, if you use the `kubectl describe deploy kubeserve` command, you will see
    the following output indicating that the image has been rolled back to revision
    `2`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你使用 `kubectl describe deploy kubeserve` 命令，你将看到以下输出，表明镜像已回滚到版本 `2`：
- en: '![Figure 4.16 – kubectl describing kubeserve ](img/Figure_4.16_B18201.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – kubectl 描述 kubeserve](img/Figure_4.16_B18201.jpg)'
- en: Figure 4.16 – kubectl describing kubeserve
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – kubectl 描述 kubeserve
- en: Deployments not only make the rolling update and rollback process much easier
    but also help us scale up and down with ease – we’ll take a look at how to scale
    applications, as well as all the viable options when doing so, in the next section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 部署不仅使滚动更新和回滚过程变得更加简单，而且帮助我们轻松地进行扩缩容——在下一节中，我们将了解如何扩展应用程序，以及扩展时所有可行的选项。
- en: Scaling applications
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: When our application becomes popular, in order to handle increasingly on-demand
    requests, we need to spin up multiple instances of applications to satisfy the
    workload requirements.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序变得流行时，为了处理越来越多的按需请求，我们需要启动多个应用程序实例来满足工作负载要求。
- en: 'When you have a Deployment, scaling is achieved by changing the number of replicas.
    Here, you can scale a Deployment using the `kubectl scale` command to make this
    happen:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个部署时，扩展是通过更改副本数来实现的。在这里，你可以使用 `kubectl scale` 命令来扩展部署：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Your output should look as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应如下所示：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you use the `kubectl get pods` command now, you will see that some more
    copies of the pods are spinning up, as shown in the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在使用 `kubectl get pods` 命令，你将看到更多副本的 Pods 被启动，输出如下所示：
- en: '![Figure 4.17 – kubectl getting the pods and showing more copies of them ](img/Figure_4.17_B18201.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – kubectl 获取 Pods 并显示更多副本](img/Figure_4.17_B18201.jpg)'
- en: Figure 4.17 – kubectl getting the pods and showing more copies of them
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – kubectl 获取 Pods 并显示更多副本
- en: Aside from manually scaling the Deployments with the `kubectl scale` command,
    we also have another way of scaling a Deployment and its ReplicaSets, which is
    **HorizontalPodAutoscaler** (**HPA**). Let’s take a look at the ReplicaSets first.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `kubectl scale` 命令手动扩展部署，我们还有另一种扩展部署及其 ReplicaSets 的方式，那就是 **HorizontalPodAutoscaler**（**HPA**）。让我们先来看一下
    ReplicaSets。
- en: ReplicaSets
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReplicaSets
- en: ReplicaSets help pods achieve higher availability since users can define a certain
    number of replicas using a ReplicaSet. The main capability of a ReplicaSet is
    to make sure the cluster keeps the exact number of replicas running in the Kubernetes
    cluster. If any of them were to fail, new ones would be deployed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSets 帮助 pods 实现更高的可用性，因为用户可以使用 ReplicaSet 定义一定数量的副本。ReplicaSet 的主要功能是确保集群中保持精确数量的副本在
    Kubernetes 集群中运行。如果任何副本失败，它们会被新副本取代。
- en: 'The following is an example of the YAML definition of a ReplicaSet:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 ReplicaSet 的 YAML 定义示例：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `matchLabels` selector simply matches the labels specified under it to
    the labels on the pods. To check your ReplicaSet, use the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchLabels` 选择器简单地将其下指定的标签与 pods 上的标签进行匹配。要检查你的 ReplicaSet，可以使用以下命令：'
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you can also use the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用以下命令：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, you will see the output indicating the number of `DESIRED` *replica*
    counts and how many of them are in a `READY` state:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到输出显示 `DESIRED` *副本* 数量以及有多少副本处于 `READY` 状态：
- en: '![Figure 4.18 – The kubectl get rs command showing the state of the ReplicaSet
    ](img/Figure_4.18_B18201.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – kubectl 获取 rs 命令显示 ReplicaSet 的状态](img/Figure_4.18_B18201.jpg)'
- en: Figure 4.18 – The kubectl get rs command showing the state of the ReplicaSet
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – kubectl 获取 rs 命令显示 ReplicaSet 的状态
- en: 'Once the ReplicaSet is deployed, update the number of ReplicaSets by using
    the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 ReplicaSet 部署完成，可以使用以下命令更新 ReplicaSet 的数量：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Your output should look as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应如下所示：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Alternatively, you can specify it in a YAML definition with the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以在 YAML 定义中使用以下命令指定：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Your output should look as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应如下所示：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, if you want to check whether the number of ReplicaSets has increased,
    you can use the `kubectl get rs` command again and you will be able to see the
    following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想检查 ReplicaSets 的数量是否增加，可以再次使用 `kubectl get rs` 命令，你将能够看到以下输出：
- en: '![Figure 4.19 – kubectl getting the ReplicaSets  ](img/Figure_4.19_B18201.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – kubectl 获取 ReplicaSets](img/Figure_4.19_B18201.jpg)'
- en: Figure 4.19 – kubectl getting the ReplicaSets
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 使用 kubectl 获取 ReplicaSets
- en: 'In the case that you want to delete a ReplicaSet, you can use the `kubectl
    delete` command – in this case, we can use it to delete a ReplicaSet named `frontend`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除一个 ReplicaSet，可以使用 `kubectl delete` 命令——在这种情况下，我们可以使用它删除名为 `frontend`
    的 ReplicaSet：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Your output should look as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应如下所示：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using ReplicaSets directly is not the only way to scale the applications. Let’s
    take a look at the alternative next, HPA.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用 ReplicaSets 不是唯一的扩展应用程序的方式。接下来让我们来看一下另一种方式，HPA。
- en: HPA
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HPA
- en: 'To update a workload resource such as a Deployment or a StatefulSet, we can
    also use HPA – this is a Kubernetes API primitive that scales the workloads automatically
    based on your demands. *Figure 4.18* explains how HPA works in the context of
    application scaling:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新工作负载资源（例如 Deployment 或 StatefulSet），我们也可以使用 HPA——这是一个 Kubernetes API 原语，根据你的需求自动扩展工作负载。*图
    4.18* 解释了在应用扩展的上下文中 HPA 是如何工作的：
- en: '![Figure 4.20 – HPA ](img/Figure_4.20_B18201.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – HPA](img/Figure_4.20_B18201.jpg)'
- en: Figure 4.20 – HPA
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – HPA
- en: From the previous diagram, we can see that HPA is configured to fetch metrics
    provided by a metrics server based on the CPU and memory usage. These metrics
    are fetched from `kubelet` by the metrics server, which then exposes them to the
    API server using a metrics API. HPA scales the Deployment by increasing or decreasing
    the count of replicas, which is managed underneath by a ReplicaSet.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图示中，我们可以看到 HPA 配置为基于 CPU 和内存使用情况从度量服务器中获取指标。这些指标由度量服务器从`kubelet`获取，然后通过度量
    API 将它们暴露给 API 服务器。HPA 通过增加或减少副本数来扩展部署，副本数由底层的 ReplicaSet 管理。
- en: As on-demand resource requests increase, HPA scales out the Deployment and the
    number of replicas increases. Conversely, when the resource requests decrease,
    the number of replicas decreases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 随着按需资源请求的增加，HPA 扩展部署并增加副本数。相反，当资源请求减少时，副本数也会减少。
- en: 'To create an HPA, you can use the `kubectl autoscale deployment` command with
    the following flags for the requirements:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 HPA，你可以使用 `kubectl autoscale deployment` 命令并带上以下标志来满足要求：
- en: '`cpu-percent` indicates the average CPU utilization usage across all pods'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu-percent` 表示所有 pod 的平均 CPU 利用率'
- en: '`min` provides the minimum number of replicas'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min` 提供最小副本数'
- en: '`max` provides the maximum number of replicas'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max` 提供最大副本数'
- en: 'You can use the following command to create an HPA with a CPU utilization usage
    of 50% and ensure a minimum of `3` copies and a maximum of up to `10` copies:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令创建一个 HPA，CPU 利用率为 50%，并确保最少有 `3` 个副本，最多可达 `10` 个副本：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Your output should look as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该如下所示：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To check how many HPAs we currently have in the default namespace, use the
    following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前在默认命名空间中有多少个 HPA，请使用以下命令：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output would look as follows
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 4.21 – Getting the HPAs in the default namespace ](img/Figure_4.21_B18201.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 获取默认命名空间中的 HPAs](img/Figure_4.21_B18201.jpg)'
- en: Figure 4.21 – Getting the HPAs in the default namespace
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 获取默认命名空间中的 HPAs
- en: 'You can also use the following YAML definition to deploy an HPA, which will
    help you achieve the same goal:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下 YAML 定义来部署 HPA，这样也能达到相同的目标：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the case that you want to delete an HPA, use a `kubectl delete` command.
    Here, we can delete an HPA named `kubeserve` as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除一个 HPA，请使用 `kubectl delete` 命令。这里，我们可以按如下方式删除名为 `kubeserve` 的 HPA：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Your output will look as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该如下所示：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Another concept that we will cover is DaemonSets, which come in handier in real
    life, particularly in scenarios where at least one replica of the pod needs to
    be evenly distributed across the worker nodes. Let’s get right into it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来会介绍另一个概念：DaemonSets，它在实际中更为常用，特别是在至少需要将 pod 的一个副本均匀分布在各个工作节点的场景中。让我们直接开始吧。
- en: DaemonSets
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DaemonSets
- en: We have learned about how ReplicaSets and Deployments help us ensure that multiple
    copies of our applications are up and running across various worker nodes. DaemonSets
    create a couple of copies of a pod, meanwhile making sure that at least one copy
    of the pod is evenly on each node in the Kubernetes cluster, as shown in *Figure
    4.23*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 ReplicaSets 和 Deployments 如何帮助我们确保应用程序的多个副本在各个工作节点上正常运行。DaemonSets 会创建
    pod 的几个副本，并确保至少有一个副本均匀分布在 Kubernetes 集群中的每个节点上，如 *图 4.23* 所示。
- en: If a new node is added to the cluster, a replica of that pod is automatically
    assigned to that node. Similarly, when a node is removed, the pod is automatically
    removed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集群中新增了一个节点，该节点会自动分配一个 pod 副本。类似地，当一个节点被移除时，该 pod 会自动被移除。
- en: '![Figure 4.22 – DaemonSets ](img/Figure_4.22_B18201.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22 – DaemonSets](img/Figure_4.22_B18201.jpg)'
- en: Figure 4.22 – DaemonSets
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – DaemonSets
- en: 'You can define a DaemonSet using the following YAML definition:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下 YAML 定义来定义一个 DaemonSet：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Your output would look as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Notice that we have created this DaemonSet in a namespace called `kube-system`
    this time – this is a namespace usually reserved for Kubernetes objects created
    by the Kubernetes system. We’ll get to talking about the namespace in a heartbeat.
    For now, you can check that the DaemonSet has been created using the following
    command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们在名为 `kube-system` 的命名空间中创建了这个 DaemonSet——这个命名空间通常保留给 Kubernetes 系统创建的对象。我们稍后会讨论命名空间。现在，你可以使用以下命令来检查
    DaemonSet 是否已经创建：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Alternatively, we can simplify the command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以简化命令：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Your output will look as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '![Figure 4.23 – Checking out the DaemonSets in the kube-system namespace ](img/Figure_4.23_B18201.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.23 – 查看 kube-system 命名空间中的 DaemonSets](img/Figure_4.23_B18201.jpg)'
- en: Figure 4.23 – Checking out the DaemonSets in the kube-system namespace
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 查看 kube-system 命名空间中的 DaemonSets
- en: 'Don’t forget to check the details of the DaemonSets by using the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了通过以下命令查看 DaemonSets 的详细信息：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Your output would look as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '![Figure 4.24 – kubectl describing the DaemonSets ](img/Figure_4.24_B18201.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.24 – kubectl 描述 DaemonSets](img/Figure_4.24_B18201.jpg)'
- en: Figure 4.24 – kubectl describing the DaemonSets
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – kubectl 描述 DaemonSets
- en: 'In case you want to delete a DaemonSet, use the `kubectl delete` command. Here,
    we can delete a DaemonSet named `fluentd` in the `kube-system` namespace as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除一个 DaemonSet，请使用 `kubectl delete` 命令。这里，我们可以按如下方式删除在 `kube-system` 命名空间中的名为
    `fluentd` 的 DaemonSet：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Your output should look as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该如下所示：
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The main use case of DaemonSets is to use them as a monitoring agent or a logs
    collector on every node, or in other cases, to run a cluster storage daemon across
    all the worker nodes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSets 的主要用途是将其用作每个节点上的监控代理或日志收集器，或者在其他情况下，用于在所有工作节点上运行集群存储守护进程。
- en: With DaemonSets, you don’t have to worry about removing or adding new nodes
    that will impact the monitoring agents on these nodes. A real-life use case, such
    as `fluentd`, requires an agent to be deployed on each node in the cluster.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DaemonSets 时，你不必担心添加或删除会影响这些节点上的监控代理的节点。实际应用案例，比如 `fluentd`，需要在集群中的每个节点上部署代理。
- en: Workload scheduling
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载调度
- en: Understanding the workload scheduling and how it works with the Kubernetes scheduler
    will be useful in your daily life as a Kubernetes Administrator. Kubernetes allows
    you to define node affinity rules, taints, and tolerations with the good use of
    labels, selectors, and annotations leading your way. Let’s first start with the
    notion of namespaces.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 理解工作负载调度及其与 Kubernetes 调度器的配合将对你作为 Kubernetes 管理员的日常工作有所帮助。Kubernetes 允许你通过良好的标签、选择器和注释来定义节点亲和性规则、污点和容忍度，帮助你前进。首先，我们从命名空间的概念开始。
- en: Understanding namespaces
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解命名空间
- en: Thinking about the separation of the workloads, namespaces come in handy. A
    namespace is a logical separation of all the namespaced objects deployed in a
    single Kubernetes cluster. Deployments, Services, and Secrets are all namespaced.
    Otherwise, some Kubernetes objects are cluster-wide, such as Nodes, StorageClass,
    and PersistentVolume. The name of a resource has to be unique within a namespace.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到工作负载的隔离，命名空间非常方便。命名空间是一个逻辑分隔符，用于将所有部署在单个 Kubernetes 集群中的命名空间对象隔离开来。Deployments、Services
    和 Secrets 都是命名空间对象。否则，一些 Kubernetes 对象是集群范围的，例如 Nodes、StorageClass 和 PersistentVolume。资源的名称在命名空间内必须是唯一的。
- en: 'You can get all namespaces using the following command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令获取所有命名空间：
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, you can use this command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令：
- en: '[PRE64]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You will see that the output gets all the namespace currently in our Kubernetes
    cluster:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到输出会列出当前我们 Kubernetes 集群中的所有命名空间：
- en: '![Figure 4.25 – kubectl getting the namespaces ](img/Figure_4.25_B18201.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.25 – kubectl 获取命名空间](img/Figure_4.25_B18201.jpg)'
- en: Figure 4.25 – kubectl getting the namespaces
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – kubectl 获取命名空间
- en: 'When you define a pod or any namespaced Kubernetes object, you can specify
    the namespace in the YAML definition as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个 pod 或任何命名空间的 Kubernetes 对象时，可以在 YAML 定义中指定命名空间，如下所示：
- en: '[PRE65]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you create that pod and specify the namespace that the pod belongs to, you
    can add the `-n` flag when querying this pod using the `kubectl get pods` command.
    The following is an example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了该 pod 并指定了 pod 所属的命名空间，那么在使用 `kubectl get pods` 命令查询该 pod 时，可以添加 `-n`
    标志。以下是一个示例：
- en: '[PRE66]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Similarly, if the pod has been created in that namespace, you can use the following
    command to check it out:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果 pod 已在该命名空间中创建，你可以使用以下命令查看：
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the case that the pods are not in the default namespace, you don’t have
    to specify the namespace option anymore. In the following example, you want to
    set a namespace named `dev`, and then use the `kubectl get` command without the
    `-n` flag:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 pod 不在默认命名空间中，你不再需要指定命名空间选项。以下示例中，你想设置一个名为 `dev` 的命名空间，然后使用没有 `-n` 标志的 `kubectl
    get` 命令：
- en: '[PRE68]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can then simply run the following command without the namespace option
    to list the pods:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以简单地运行以下命令，不带命名空间选项，来列出 pods：
- en: '[PRE69]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Understanding namespaces will further help you when you need to define the namespace-scoped
    permissions where Kubernetes objects are grouped. We’ll elaborate on this further
    in [*Chapter 6*](B18201_06.xhtml#_idTextAnchor192), *Securing Kubernetes*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 理解命名空间将进一步帮助你在需要定义命名空间作用域的权限时，在 Kubernetes 对象分组时提供帮助。我们将在 [*第 6 章*](B18201_06.xhtml#_idTextAnchor192)《*Kubernetes
    安全*》中进一步阐述。
- en: Labels, node selectors, and annotations
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签、节点选择器和注释
- en: 'Labels, selectors, and annotations are useful notions when it comes to workload
    scheduling. Labels are key-value pairs attached to Kubernetes objects that can
    be listed in the `metadata.labels` section of an object descriptor. Selectors
    are used for identifying and selecting a group of objects using their labels.
    See the following examples of some quality-based selectors:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 标签、选择器和注释是工作负载调度时非常有用的概念。标签是附加到 Kubernetes 对象上的键值对，可以在对象描述符的 `metadata.labels`
    部分列出。选择器用于通过标签识别和选择一组对象。请参见以下基于质量的选择器示例：
- en: '[PRE70]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When it comes to inequality, you can use the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到不等式时，你可以使用以下命令：
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following example involves chaining multiple selectors together using a
    comma-delimited list:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过使用逗号分隔的列表将多个选择器串联在一起：
- en: '[PRE72]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To assign a pod to nodes, we can use node selectors. You can specify a map
    of key-value pairs in the `PodSpec` field:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个 Pod 分配到节点上，我们可以使用节点选择器。你可以在 `PodSpec` 字段中指定一组键值对：
- en: 'You can start by labeling the worker nodes using the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令开始为工作节点打标签：
- en: '[PRE73]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output should be as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE74]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can use the following command to show the label of worker nodes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令显示工作节点的标签：
- en: '[PRE75]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, we should get the following output:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该得到以下输出：
- en: '![Figure 4.26 – Getting the node labels ](img/Figure_4.26_B18201.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.26 – 获取节点标签](img/Figure_4.26_B18201.jpg)'
- en: Figure 4.26 – Getting the node labels
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – 获取节点标签
- en: 'Then, you can add the node selector in the YAML definition as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在 YAML 定义中添加节点选择器，如下所示：
- en: '[PRE76]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can attach annotations to objects using the `metadata.annotations` section,
    as with the following configuration file that has the annotation `imageregistry:
    "http://hub.docker.com/"`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用 `metadata.annotations` 部分将注解附加到对象上，以下是带有注解 `imageregistry: "http://hub.docker.com/"`
    的配置文件：'
- en: '[PRE77]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Annotations are similar to labels and they can be used to store custom metadata
    about objects.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注解类似于标签，它们可以用来存储关于对象的自定义元数据。
- en: Node affinity and anti-affinity
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点亲和性和反亲和性
- en: 'Node affinity and anti-affinity are simply ways to help pods be assigned to
    the right node. Compare this to `nodeSelector`, which is designed for assigning
    a pod directly to the worker nodes. The following is an example of node affinity
    and anti-affinity in the YAML specification:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 节点亲和性和反亲和性是帮助 Pod 分配到正确节点的方式。与此相比，`nodeSelector` 是用于将 Pod 直接分配到工作节点的。以下是 YAML
    配置中节点亲和性和反亲和性的示例：
- en: '[PRE78]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: With particular labels, node affinity and anti-affinity allow us to create matching
    rules with logic and operations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过特定的标签，节点亲和性和反亲和性使我们能够创建具有逻辑和操作的匹配规则。
- en: Taints and tolerations
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 污点和容忍
- en: Aside from node affinity and anti-affinity, we can also assign taints on the
    node and tolerations on the pods by tainting the nodes and ensuring that no pods
    will be scheduled to that node.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节点亲和性和反亲和性之外，我们还可以通过给节点打上污点并确保没有 Pod 被调度到该节点来在节点上分配污点和在 Pod 上分配容忍。
- en: 'You can use the following command to taint a node:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令给节点打污点：
- en: '[PRE79]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The preceding definition can be translated into a pod YAML definition file
    to achieve the same outcome as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的定义可以转化为 Pod 的 YAML 定义文件，以实现相同的结果，如下所示：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you want to un-taint a node, you can use the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想解除节点的污点，可以使用以下命令：
- en: '[PRE81]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We have learned how to taint certain nodes when you want to evict workloads
    from a node in this section. Now, let’s look at resource management.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们已经学会了如何在需要将工作负载从节点中驱逐时给某些节点打污点。现在，让我们来看一下资源管理。
- en: Resource management
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理
- en: Kubernetes allows us to specify the resource requirements of a container in
    the pod specification, which basically refers to how many resources a container
    needs.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 允许我们在 Pod 规格中指定容器的资源需求，这基本上是指容器需要多少资源。
- en: '`kube-scheduler` uses the resource request information that you specify for
    a container in a pod to decide on which worker node to schedule the pod. It’s
    up to `kubelet` to enforce these resource limits when you specify them for the
    containers in the pod so that the running container goes beyond a set limit, as
    well as reserves at least the requested amount of a system resource for a container
    to use.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-scheduler` 使用你为 Pod 中的容器指定的资源请求信息来决定将 Pod 调度到哪个工作节点。`kubelet` 负责在你为容器指定资源限制时执行这些限制，以确保运行中的容器不会超出设定的限制，并为容器保留至少请求的系统资源量。'
- en: 'It usually gives us the following values:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常会给我们以下值：
- en: '`resources.limits.cpu` is the resource limit set on CPU usage.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.limits.cpu` 是设置的 CPU 使用资源限制。'
- en: '`resources.limits.memory` is the resource limit set on memory usage.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.limits.memory` 是设置的内存使用资源限制。'
- en: '`resources.requests.cpu` is the minimum CPU usage requested to allow your application
    to be up and running.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.requests.cpu` 是为使应用程序正常运行而请求的最小 CPU 使用量。'
- en: '`resources.requests.memory` is the minimum memory usage requested to allow
    your application to be up and running. In the case that a container exceeds its
    memory request, the worker node that it runs on becomes short on overall memory
    at the same time, and the pod that the container belongs to is likely to be evicted
    too.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.requests.memory` 是请求的最小内存使用量，用于确保你的应用程序能够正常运行。如果容器超出了其内存请求，运行该容器的工作节点会同时内存不足，容器所属的
    Pod 很可能也会被驱逐。'
- en: '`resources.limits.ephemeral-storage` is the limit on ephemeral storage resources.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.limits.ephemeral-storage` 是对临时存储资源的限制。'
- en: '`resources.limits.hugepages-<size>` is the limit on the allocation and consumption
    of pre-allocated huge pages by any applications in a pod.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.limits.hugepages-<size>` 是对 Pod 中任何应用程序预分配的大页内存分配和消耗的限制。'
- en: 'A resource request refers to the amount of resources that are necessary to
    run a container, and what they do is govern on which worker node the containers
    will actually be scheduled. So, when Kubernetes is getting ready to run a particular
    pod, it’s going to choose a worker node based on the resource requests of that
    pod’s containers. Kubernetes will use these values to ensure that it chooses a
    node that actually has enough resources available to run that pod. A pod will
    only run on a node that has enough available resources to run the pod’s containers.
    The following is a YAML example of defining `resource request` and `limits`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 资源请求是指运行容器所需的资源量，它们决定了容器将在哪个工作节点上调度。因此，当 Kubernetes 准备运行一个特定的 Pod 时，它会根据 Pod
    容器的资源请求来选择一个工作节点。Kubernetes 将使用这些值来确保选择一个有足够资源来运行该 Pod 的节点。Pod 只会在拥有足够可用资源的节点上运行。以下是定义
    `resource request` 和 `limits` 的 YAML 示例：
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can use the `kubectl describe node` command to check the allocation resources
    of that node to see whether your requests or limits definitions correspond to
    what is needed in the current circumstances:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `kubectl describe node` 命令检查该节点的资源分配，以查看你的请求或限制定义是否符合当前环境下的需求：
- en: '![Figure 4.27 – kubectl describing the node resources ](img/Figure_4.27_B18201.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.27 – kubectl 描述节点资源](img/Figure_4.27_B18201.jpg)'
- en: Figure 4.27 – kubectl describing the node resources
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27 – kubectl 描述节点资源
- en: You can use the `kubectl top` command in the case that you have a metrics server
    installed in your cluster to check the actual resource usage of the node or pod.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的集群中已安装了度量服务器，你可以使用 `kubectl top` 命令检查节点或 Pod 的实际资源使用情况。
- en: Configuring applications
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: Configuring an application is a simple and straightforward experience thanks
    to ConfigMaps and Secrets. Let’s take a look at each of them.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序是一个简单直接的过程，得益于 ConfigMaps 和 Secrets。我们来逐一看看它们。
- en: Understanding ConfigMaps
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 ConfigMaps
- en: A ConfigMap is simply a Kubernetes object that stores configuration data in
    key-value pairs. This configuration data can then be used to configure the software
    running in a container by configuring a pod to consume ConfigMaps using environment
    variables, command-line arguments, or mounting a volume with configuration files.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 仅仅是一个 Kubernetes 对象，用来存储以键值对形式的配置信息。然后，这些配置信息可以通过配置 Pod 来使用环境变量、命令行参数或挂载包含配置文件的卷，从而配置运行在容器中的软件。
- en: 'You can also use a YAML definition to define `configmap` as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 YAML 定义来定义 `configmap`，如下所示：
- en: '[PRE83]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Your output should look as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应如下所示：
- en: '[PRE84]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You can check `configmap` using the following command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令检查 `configmap`：
- en: '[PRE85]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Alternatively, you can use this command:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用这个命令：
- en: '[PRE86]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Your output will be as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '![Figure 4.28 – kubectl getting configmap ](img/Figure_4.28_B18201.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.28 – kubectl 获取 configmap](img/Figure_4.28_B18201.jpg)'
- en: Figure 4.28 – kubectl getting configmap
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 – kubectl 获取 configmap
- en: 'You can check the binary data of `configmap` using the following command:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令检查 `configmap` 的二进制数据：
- en: '[PRE87]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following screenshot is the output of the preceding command:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是前述命令的输出：
- en: '![Figure 4.29 – The configmap binary data ](img/Figure_4.29_B18201.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.29 – configmap 二进制数据](img/Figure_4.29_B18201.jpg)'
- en: Figure 4.29 – The configmap binary data
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – configmap 二进制数据
- en: 'Once you have `configmap` ready, here’s how to configure the pod to consume
    it:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `configmap` 准备好，下面是如何配置 Pod 来使用它：
- en: 'Create a pod that can use the `configmap` data by using environment variables:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用环境变量创建一个可以使用 `configmap` 数据的 Pod：
- en: '[PRE88]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can use the following command to check the `configmap` value:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来检查`configmap`的值：
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output will be similar to the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '![Figure 4.30 – The configmap mounted value ](img/Figure_4.30_B18201.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.30 – configmap挂载的值](img/Figure_4.30_B18201.jpg)'
- en: Figure 4.30 – The configmap mounted value
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – configmap挂载的值
- en: 'You can create a pod to use `configmap` data via a volume. The following is
    an example of a YAML definition:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过卷来创建pod使用`configmap`数据。以下是一个YAML定义的示例：
- en: '[PRE90]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You can use the `kubectl logs` command to check the pod for the mounted data
    value, or use the following command to check the `configmap`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl logs`命令检查pod中的挂载数据值，或者使用以下命令来检查`configmap`：
- en: '[PRE91]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output will look as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 4.31 – The configmap mounted value ](img/Figure_4.31_B18201.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.31 – configmap挂载的值](img/Figure_4.31_B18201.jpg)'
- en: Figure 4.31 – The configmap mounted value
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – configmap挂载的值
- en: 'In the case that you want to delete a `configmap`, use the `kubectl delete`
    command:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除一个`configmap`，请使用`kubectl delete`命令：
- en: '[PRE92]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Your output would look as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '[PRE93]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we have shown how we can work with ConfigMaps in Kubernetes. Once you
    feel comfortable with ConfigMaps, you’ll find a lot of similarities when it comes
    to working with Secrets. Next, we will have a look at how to work with Kubernetes
    Secrets so that they can be consumed by your application.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了如何在Kubernetes中使用ConfigMap。一旦你对ConfigMap感到熟悉，你会发现当你处理Secrets时，有很多相似之处。接下来，我们将看看如何处理Kubernetes
    Secrets，以便它们能被你的应用消费。
- en: Understanding Secrets
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Secrets
- en: 'A Kubernetes Secret is an object containing sensitive data such as a password,
    an API token, or a key, which is passed to a pod rather than stored in a `PodSpec`
    field or in the container itself:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Secret是一个包含敏感数据的对象，例如密码、API令牌或密钥，这些数据会传递给pod，而不是存储在`PodSpec`字段或容器中：
- en: '[PRE94]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You can also use a YAML definition to define `configmap` as the following with
    base64:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用YAML定义来将`configmap`定义为以下形式并使用base64：
- en: '[PRE95]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You can check the Secrets by using the following command:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令检查Secrets：
- en: '[PRE96]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Your output would look as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '![Figure 4.32 – kubectl getting Secrets ](img/Figure_4.32_B18201.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.32 – kubectl 获取 Secrets ](img/Figure_4.32_B18201.jpg)'
- en: Figure 4.32 – kubectl getting Secrets
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – kubectl 获取 Secrets
- en: 'Once you have created the Secret, you may want to attach the Secret to an application.
    That’s where you need to create a pod to consume the Secret by following these
    steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Secret后，你可能希望将其附加到一个应用程序中。这时，你需要创建一个pod来消费该Secret，步骤如下：
- en: 'You can create a pod to consume the Secret using environment variables:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以创建一个pod，通过环境变量消费Secret：
- en: '[PRE97]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can also consume a Secret as a volume, as shown here – you will define
    a `secret-volume` and then mount the `secret-volume` to the `/etc/secret-volume`
    path:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以将Secret作为卷来使用，如下所示——你需要定义一个`secret-volume`，然后将`secret-volume`挂载到`/etc/secret-volume`路径：
- en: '[PRE98]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If you want to delete a Secret, use the `kubectl delete` command as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除一个Secret，请使用以下`kubectl delete`命令：
- en: '[PRE99]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Your output will look as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '[PRE100]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note that if you delete a Secret, make sure to update the `PodSpec` field for
    your application to avoid exceptions. You can do this by creating a new Secret,
    then attaching it to your pod, or updating your application so it doesn’t need
    the Secret anymore.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你删除了一个Secret，确保更新你应用的`PodSpec`字段，以避免出现异常。你可以通过创建一个新的Secret，然后将其附加到你的pod上，或者更新你的应用使其不再需要该Secret。
- en: Manifest management with kustomize
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kustomize进行清单管理
- en: 'Starting from Kubernetes 1.14, customization files became available to facilitate
    smoother Kubernetes management. It supports the following use cases:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.14开始，提供了自定义文件，以便更顺畅地管理Kubernetes。它支持以下用例：
- en: Generation of YAML definitions from other resources, such as generating a Kubernetes
    Secret and its YAML definition
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他资源生成YAML定义，例如生成Kubernetes Secret及其YAML定义
- en: Common configuration across multiple YAML definitions, such as adding namespace
    for a group of resources
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个YAML定义中的常见配置，例如为一组资源添加命名空间
- en: Composing and customizing a collection of YAML definitions, such as setting
    resource requests and limits for multiple Kubernetes objects
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和自定义YAML定义集合，例如为多个Kubernetes对象设置资源请求和限制
- en: 'This can be achieved using a central file called `Kustomization.yaml`. You
    can use the following command to view the resources found in the directory that
    are contained in a customization file:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个名为`Kustomization.yaml`的中央文件来实现。你可以使用以下命令查看包含在定制文件中的目录中的资源：
- en: '[PRE101]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You can then apply those resources by running the following command:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过运行以下命令来应用这些资源：
- en: '[PRE102]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Let’s take Secret generation as an example and generate a Secret manifest file:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以Secret生成为例，生成一个Secret清单文件：
- en: '[PRE103]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, you will be able to see that you have two files created after executing
    the previous steps:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将能够看到在执行前述步骤后创建了两个文件：
- en: '[PRE104]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If you want to check out the content of the `customization.yaml` file, you
    can use `cat customization.yaml` and you will see the following output:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看`customization.yaml`文件的内容，可以使用`cat customization.yaml`命令，输出将如下所示：
- en: '[PRE105]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Then, you can use the `kubectl apply` command to deploy the pod with the Secret
    mounted:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`kubectl apply`命令来部署带有挂载Secret的Pod：
- en: '[PRE106]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Kustomize is a good way to customize your application configuration and now
    that it is built into `kubectl apply -k`, you can gain a greater understanding
    of the use cases of Kustomize by visiting the official documentation site: [https://kubectl.docs.kubernetes.io/guides/](https://kubectl.docs.kubernetes.io/guides/).'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize是一个非常好的方式来定制你的应用程序配置，现在它已集成到`kubectl apply -k`中，你可以通过访问官方文档网站，深入了解Kustomize的使用场景：[https://kubectl.docs.kubernetes.io/guides/](https://kubectl.docs.kubernetes.io/guides/)。
- en: Common package management and templating with Helm
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Helm进行常见的包管理和模板化操作
- en: 'Helm is a management tool for managing packages of pre-configured Kubernetes
    objects in the form of charts – we call these Helm charts. Helm charts allow users
    to install and manage Kubernetes applications more reproducibly and effectively.
    Furthermore, you can find popular Helm charts from the community or share your
    own applications with the Helm community at this link: [https://artifacthub.io/packages/search](https://artifacthub.io/packages/search).'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是一个管理预配置Kubernetes对象包的工具，形式为chart——我们称之为Helm charts。Helm charts允许用户更可复现、更高效地安装和管理Kubernetes应用程序。此外，你还可以通过以下链接，从社区中查找流行的Helm
    charts，或与Helm社区共享你自己的应用程序：[https://artifacthub.io/packages/search](https://artifacthub.io/packages/search)。
- en: 'The standard file structure of a chart is as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: chart的标准文件结构如下：
- en: '`Charts` – (the folder)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Charts` – （文件夹）'
- en: '`Chart.yaml #` – A .`yaml` file that contains the information about the chart'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chart.yaml #` – 一个`.yaml`文件，其中包含有关chart的信息'
- en: '`README.md`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`'
- en: '`requirements.lock`'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.lock`'
- en: '`requirements.yaml` – an optional file that lists the dependencies for a chart
    (the dependencies are actually packaged in the `Charts` folder)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.yaml` – 一个可选的文件，用于列出chart的依赖项（这些依赖项实际上是打包在`Charts`文件夹中的）'
- en: '`templates` – a directory of templates that combine with values to generate
    Kubernetes manifest files'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates` – 一个包含模板的目录，这些模板与值结合生成Kubernetes清单文件'
- en: '`values.yaml` – contains the default configuration values for the chart (this
    is where Helm grabs the values for the manifest template that contains the reference
    values)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values.yaml` – 包含chart的默认配置值（这是Helm从中获取清单模板中包含的参考值的地方）'
- en: 'To query the Helm charts that have been deployed, use the following command:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询已部署的Helm charts，可以使用以下命令：
- en: '[PRE107]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If you need to search for a chart, you can use the following command:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要搜索某个chart，可以使用以下命令：
- en: '[PRE108]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Delete a Helm chart that has been deployed using the following command:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令删除已部署的Helm chart：
- en: '[PRE109]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Whenever you install a chart, a new release is created. So, one chart can be
    installed multiple times into the same cluster. Each can be independently managed
    and upgraded. To upgrade a release to a specified version of a chart or update
    the chart values, run the following:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你安装一个chart时，都会创建一个新的发布版本。因此，同一个chart可以多次安装到同一个集群中。每个发布版本都可以独立管理和升级。要将发布版本升级到指定的chart版本或更新chart的值，请运行以下命令：
- en: '[PRE110]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To roll back to a specific version, you can use the following command:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要回滚到特定版本，你可以使用以下命令：
- en: '[PRE111]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Helm charts help you manage, install, and upgrade Kubernetes-native applications.
    You can learn more about Helm by visiting their official documentation website:
    [https://helm.sh/docs/](https://helm.sh/docs/).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Helm charts帮助你管理、安装和升级Kubernetes本地应用程序。你可以访问Helm的官方网站，了解更多关于Helm的信息：[https://helm.sh/docs/](https://helm.sh/docs/)。
- en: Summary
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered one of the most common tasks for both Kubernetes
    Administrators and Developers – application scheduling and managing the application
    lifecycle. Even though this chapter covers about 15% of the content of the CKA
    exam, working with Kubernetes objects is one of the most important daily tasks
    as a Kubernetes Administrator. Ensure that you practice enough and master the
    shortcuts of the `kubectl` commands before moving on.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们介绍了 Kubernetes 管理员和开发人员最常做的任务之一——应用调度和应用生命周期管理。虽然本章内容涵盖了 CKA 考试约 15% 的内容，但作为
    Kubernetes 管理员，处理 Kubernetes 对象是最重要的日常任务之一。在继续之前，确保你充分练习并掌握 `kubectl` 命令的快捷方式。
- en: In the next chapter, we’ll talk about Kubernetes storage. The content and the
    questions covered in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application
    Scheduling and Lifecycle Management* and [*Chapter 5*](B18201_05.xhtml#_idTextAnchor149),
    *Demystifying Kubernetes Storage* are considered very high-value and less time-consuming
    within the scheme of the actual CKA exam. Stay tuned and keep learning!
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Kubernetes 存储。本书的 [*第 4 章*](B18201_04.xhtml#_idTextAnchor080) *应用调度与生命周期管理*
    和 [*第 5 章*](B18201_05.xhtml#_idTextAnchor149) *破解 Kubernetes 存储* 被认为是在实际 CKA 考试中高价值且不费时的内容，敬请关注并继续学习！
- en: Mock CKA scenario-based practice test
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 CKA 情景练习测试
- en: You have two virtual machines, `master-0` and `worker-0`. Please complete the
    following mock scenarios.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两台虚拟机，`master-0` 和 `worker-0`。请完成以下模拟场景。
- en: Scenario 1
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情景 1
- en: SSH into the `worker-0` node and provision a new pod called `ngnix` with a single
    container, `nginx`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 进入 `worker-0` 节点，并创建一个名为 `ngnix` 的新 Pod，包含一个容器 `nginx`。
- en: Scenario 2
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情景 2
- en: SSH to `worker-0` and then scale `nginx` to 5 copies.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 进入 `worker-0`，然后将 `nginx` 扩展为 5 个副本。
- en: Scenario 3
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情景 3
- en: SSH to `worker-0`, set a ConfigMap with a username and password, and then attach
    a new pod to BusyBox.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 进入 `worker-0`，设置一个包含用户名和密码的 ConfigMap，然后将一个新的 Pod 附加到 BusyBox。
- en: Scenario 4
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情景 4
- en: SSH to `worker-0` and create a `nginx` pod with an init container called `busybox`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 进入 `worker-0`，并创建一个包含名为 `busybox` 的 init 容器的 `nginx` Pod。
- en: Scenario 5
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情景 5
- en: SSH to `worker-0`, create a `nginx` pod, and then a `busybox` container in the
    same pod.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 进入 `worker-0`，创建一个 `nginx` Pod，然后在同一 Pod 中创建一个 `busybox` 容器。
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 [*附录*](B18201_Appendix_A.xhtml#_idTextAnchor386) *- 模拟 CKA 情景练习测试解析*
    中找到所有情景的解析。
- en: FAQs
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: '*Where can I find out about Helm charts?*'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在哪里可以了解 Helm charts？*'
- en: 'Go to Helm’s official documentation to learn more about Helm: [https://helm.sh/docs/howto/charts_tips_and_tricks/](https://helm.sh/docs/howto/charts_tips_and_tricks/).'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Helm 的官方文档，了解更多有关 Helm 的信息：[https://helm.sh/docs/howto/charts_tips_and_tricks/](https://helm.sh/docs/howto/charts_tips_and_tricks/)。
- en: '*Where can I find out about Kustomize?*'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在哪里可以了解 Kustomize？*'
- en: 'Go to Helm’s official documentation to learn more about Kustomize: [https://kubectl.docs.kubernetes.io/references/kustomize/](https://kubectl.docs.kubernetes.io/references/kustomize/).'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Helm 的官方文档，了解更多有关 Kustomize 的信息：[https://kubectl.docs.kubernetes.io/references/kustomize/](https://kubectl.docs.kubernetes.io/references/kustomize/)。
- en: '*What is the recommended official Kubernetes article about init containers?*'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于 init 容器，推荐的官方 Kubernetes 文章是什么？*'
- en: 'I recommend bookmarking this article, *Init Containers*: [https://kubernetes.io/docs/concepts/workloads/pods/init-containers/](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/).'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议收藏这篇文章，*Init 容器*：[https://kubernetes.io/docs/concepts/workloads/pods/init-containers/](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/)。
- en: '*What is your recommended Kubernetes official article for ConfigMaps?*'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你推荐的 Kubernetes 官方文章关于 ConfigMaps 是哪一篇？*'
- en: 'I recommend bookmarking an article, *ConfigMaps*: [https://kubernetes.io/docs/concepts/configuration/configmap/](https://kubernetes.io/docs/concepts/configuration/configmap/).'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议收藏这篇文章，*ConfigMaps*：[https://kubernetes.io/docs/concepts/configuration/configmap/](https://kubernetes.io/docs/concepts/configuration/configmap/)。
- en: '*What is your recommended official Kubernetes article for resource management?*'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你推荐的 Kubernetes 官方文章关于资源管理是哪一篇？*'
- en: 'I recommend bookmarking this article, *Resource Management for Pods and Containers*:
    [https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/).'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议收藏这篇文章，*Pod 和容器的资源管理*：[https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)。
