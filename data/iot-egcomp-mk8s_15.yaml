- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Implementing Strict Confinement for Isolated Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为隔离容器实现严格限制
- en: In the previous chapter, we looked at how to build secure containers using Kata
    Containers and how to improve workload isolation with hardware virtualization
    technology. We also discussed the best practices for securing your production-grade
    cluster with containers. The MicroK8s add-on option has also made it easier to
    activate Kata Containers, which can significantly increase the security and isolation
    of your container operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何使用 Kata Containers 构建安全的容器，并如何通过硬件虚拟化技术提高工作负载的隔离性。我们还讨论了如何通过容器保护您的生产级集群的最佳实践。MicroK8s
    插件选项还简化了 Kata Containers 的激活，使容器操作的安全性和隔离性显著增强。
- en: 'In this chapter, we will take a look at another approach to isolation using
    snap confinement options to run containers in complete isolation, meaning no access
    to files, networks, processes, or any other system resource without requesting
    specific access via an interface. Confinement models describe how much access
    a particular snap has to a user’s machine. There are currently three choices available,
    as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探讨使用 Snap 限制选项进行隔离的另一种方法，运行容器时实现完全隔离，这意味着没有文件、网络、进程或任何其他系统资源的访问，除非通过接口请求特定的访问权限。限制模型描述了特定
    Snap 对用户机器的访问程度。目前有三种可供选择的模型，如下所示：
- en: The *strict* confinement level operates in complete isolation, with access limited
    to a level that is always regarded as safe. As a result, without requesting particular
    access via an interface, strictly limited snaps cannot access your files, network,
    processes, or any other system resource.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*严格*限制级别在完全隔离的环境中运行，访问权限仅限于始终被视为安全的程度。因此，未经通过接口请求特定访问权限的严格限制 Snap 无法访问您的文件、网络、进程或任何其他系统资源。'
- en: The *classic* confinement level is similar to conventional Linux packages and
    can access a system’s resources.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*经典*的限制级别类似于传统的 Linux 包，可以访问系统的资源。'
- en: The *devmode* confinement level runs in a limited environment with full access
    to system resources and generates debug output to locate unidentified interfaces.
    This is specifically designed for snap creators and developers.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发模式*限制级别在一个有限的环境中运行，具有对系统资源的完全访问权限，并生成调试输出，以便定位未识别的接口。这专为 Snap 创建者和开发人员设计。'
- en: As we discussed in [*Chapter 2*](B18115_02.xhtml#_idTextAnchor030), *Introducing
    MicroK8s*, MicroK8s is a snap, and we employed the classic confinement model throughout
    this book. The interface of each snap is carefully chosen by the author to enable
    specialized access to a resource in accordance with the snap’s requirements. For
    example, network access, desktop access, and audio access are all provided by
    common interfaces.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 2 章*](B18115_02.xhtml#_idTextAnchor030) 中讨论的那样，*介绍 MicroK8s*，MicroK8s
    是一个 Snap，在本书中我们使用了经典的限制模型。每个 Snap 的接口都由作者精心挑选，以便根据 Snap 的需求启用对某个资源的专门访问。例如，网络访问、桌面访问和音频访问都是通过常见的接口提供的。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Overview of Snap, Snapcraft, and Ubuntu Core
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snap、Snapcraft 和 Ubuntu Core 概述
- en: Setting up Ubuntu Core on a Raspberry Pi board
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树莓派板上设置 Ubuntu Core
- en: Setting up MicroK8s on Ubuntu Core
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu Core 上设置 MicroK8s
- en: Deploying a sample containerized application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个示例容器化应用程序
- en: Overview of Snap, Snapcraft, and Ubuntu Core
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Snap、Snapcraft 和 Ubuntu Core 概述
- en: Before going into detail about how strict confinement snaps offer isolation
    to applications, we will delve into a little bit of history on how embedded Linux
    development was handled before the advent of snaps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讨论严格限制的 Snap 如何为应用程序提供隔离之前，我们将简要回顾一下在 Snap 出现之前，嵌入式 Linux 开发是如何进行的。
- en: Traditionally, getting software to embedded Linux systems has proven difficult.
    There were different Linux packaging formats (RPM, DEB, and so on) and there is
    no standardization of formats. Furthermore, software packages frequently necessitate
    sophisticated code to manage installation and updates that are incompatible with
    one another, have unmet dependencies, or write to the entire system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，将软件安装到嵌入式 Linux 系统上一直是一个困难的问题。不同的 Linux 包格式（RPM、DEB 等）没有统一的标准化格式。此外，软件包通常需要复杂的代码来管理安装和更新，而这些代码相互不兼容、存在未满足的依赖关系，或者会写入整个系统。
- en: Snaps were envisioned to answer the concerns of embedded Linux developers seeking
    a secure environment and precise configuration to run their applications. They
    allow software publishers and developers to manage the binary that is supplied
    and the exact version that their users have access to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Snaps 的初衷是解决嵌入式 Linux 开发人员对运行应用程序时所需的安全环境和精确配置的需求。它们允许软件发布者和开发者管理其提供的二进制文件以及用户可以访问的精确版本。
- en: Snaps are easy to create, build, and deploy as compared to standard Linux software
    distribution. Snaps get automatically updated **over the air** (**OTA**) and via
    deltas, keeping the functionality of an embedded Linux device always fresh and
    reducing the risk of breaking. Snaps are compatible with all major Linux distributions
    and may be used on any type of device from desktop to cloud and IoT devices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于标准的 Linux 软件分发方式，Snaps 更容易创建、构建和部署。Snaps 会自动 **通过空中升级** (**OTA**) 和增量更新，保持嵌入式
    Linux 设备的功能始终保持最新，减少了出现故障的风险。Snaps 兼容所有主要的 Linux 发行版，并且可以在从桌面到云端以及物联网设备的任何类型设备上使用。
- en: Snapcraft ([https://snapcraft.io/](https://snapcraft.io/)) is a framework for
    creating and distributing snaps by bringing together different components of the
    application into a single, cohesive bundle. Developers submit their snaps to a
    central repository known as Snap Store—a universal app store that allows users
    to publish, browse, install, distribute, and deploy apps in the cloud, on desktops,
    and on IoT devices from any Linux distribution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Snapcraft ([https://snapcraft.io/](https://snapcraft.io/)) 是一个框架，用于通过将应用程序的不同组件整合成一个单一、协调的包来创建和分发
    snaps。开发人员将他们的 snaps 提交到一个中央存储库——Snap Store，一个通用的应用商店，允许用户发布、浏览、安装、分发并在云端、桌面和物联网设备上部署应用程序，无论是任何
    Linux 发行版。
- en: The Ubuntu Core embedded OS ([https://ubuntu.com/core](https://ubuntu.com/core))
    is built on snaps and is free and open source. In Ubuntu Core, everything is a
    snap. Even the kernel is a snap. In Ubuntu Core, only snaps that use the strict
    confinement model can be installed. It is a cutting-edge new operating system
    (OS) designed from the ground up with zero-trust security in mind. It efficiently
    decouples the base system and OS from the installed apps by containerizing the
    Linux kernel and runtime environments. Containerization allows you to separate
    and provide lockdown functionality, with applications running in a security sandbox
    by default (kernel features such as AppArmor, seccomp, security policies, and
    device permissions are leveraged).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu Core 嵌入式操作系统 ([https://ubuntu.com/core](https://ubuntu.com/core)) 是建立在
    snaps 之上的，并且是免费开源的。在 Ubuntu Core 中，一切都是 snap。甚至连内核也是一个 snap。在 Ubuntu Core 中，只有使用严格限制模型的
    snaps 才能被安装。它是一个全新设计的操作系统（OS），从零开始构建，具有零信任安全性。它通过容器化 Linux 内核和运行时环境有效地解耦了基础系统和已安装的应用程序。容器化使得您可以分离并提供封锁功能，应用程序默认在安全沙箱中运行（利用内核功能，如
    AppArmor、seccomp、安全策略和设备权限）。
- en: MicroK8s and Ubuntu Core share characteristics including self-healing, high
    availability, automatic OTA updates, reliability, and security. Running MicroK8s
    on Ubuntu Core provides Kubernetes with the benefits of a solid computing foundation.
    Furthermore, combining Ubuntu Core and MicroK8s offers a streamlined, embedded
    Kubernetes experience for IoT and Edge applications, with a small footprint and
    performance efficiency optimizations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MicroK8s 和 Ubuntu Core 具有一些共同特征，包括自愈、高可用性、自动 OTA 更新、可靠性和安全性。在 Ubuntu Core 上运行
    MicroK8s 为 Kubernetes 提供了坚实的计算基础。此外，将 Ubuntu Core 和 MicroK8s 结合起来为物联网和边缘应用程序提供了一个简化的嵌入式
    Kubernetes 体验，具有小巧的占用空间和性能优化。
- en: In the next section, we will go over the procedures for setting up a Kubernetes
    Raspberry Pi cluster with snap strict confinement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍设置一个使用 snap 严格限制的 Kubernetes 树莓派集群的过程。
- en: Setting up Ubuntu Core on a Raspberry Pi board
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在树莓派板上设置 Ubuntu Core
- en: Now that we are clear on the snap confinement concepts, we will delve into the
    steps of creating a Kubernetes Raspberry Pi cluster that uses snap strict confinement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 snap 限制概念，接下来我们将深入探讨创建一个使用 snap 严格限制的 Kubernetes 树莓派集群的步骤。
- en: What we are trying to achieve
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们试图实现的目标
- en: 'We’ll list down the steps that we’re seeking to work through in this section
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将列出我们要进行的步骤如下：
- en: Setting up an Ubuntu Core image to SD card
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Ubuntu Core 镜像设置到 SD 卡
- en: Creating an Ubuntu SSO account
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Ubuntu SSO 账户
- en: Generating an SSH key pair
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成 SSH 密钥对
- en: Booting Ubuntu Core on Raspberry Pi
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动树莓派上的 Ubuntu Core
- en: 'The Raspberry Pi cluster that we will build in this step is depicted in *Figure
    15.1* as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这一步构建的 Raspberry Pi 集群如*图 15.1*所示：
- en: '![Figure 15.1 – The Raspberry Pi cluster that uses snap strict confinement
    ](img/Figure_15.01_B18115.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 使用 Snap 严格限制的 Raspberry Pi 集群](img/Figure_15.01_B18115.jpg)'
- en: Figure 15.1 – The Raspberry Pi cluster that uses snap strict confinement
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 使用 Snap 严格限制的 Raspberry Pi 集群
- en: Now that we know what we want to do, let’s look at the requirements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道想做什么，接下来来看一下需求。
- en: Requirements
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求
- en: 'The following are the prerequisites for building the Ubuntu Core Raspberry
    Pi Kubernetes cluster:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建 Ubuntu Core Raspberry Pi Kubernetes 集群的前提条件：
- en: A microSD card (4 GB minimum; 8 GB recommended)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张 microSD 卡（最小 4 GB，推荐 8 GB）
- en: A computer with a microSD card drive
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台配有 microSD 卡驱动器的计算机
- en: Raspberry Pi 2, 3, or 4 (1 or more)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 2、3 或 4（1 台或更多）
- en: A micro-USB power cable (USB-C for the Pi 4)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根 micro-USB 电源线（Pi 4 使用 USB-C）
- en: A Wi-Fi network or an Ethernet cable with an internet connection
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种 Wi-Fi 网络或带有互联网连接的以太网电缆
- en: (Optional) A monitor with an HDMI interface
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）带 HDMI 接口的显示器
- en: (Optional) An HDMI cable for Pi 2 and 3 and a micro-HDMI cable for Pi 4
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）用于 Pi 2 和 3 的 HDMI 电缆，Pi 4 使用 micro-HDMI 电缆
- en: (Optional) A USB keyboard
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）一只 USB 键盘
- en: Now that we’ve established the requirements, we’ll move on to the step-by-step
    instructions on how to create a Kubernetes Raspberry Pi cluster that uses snap
    strict confinement.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了需求，接下来我们将进入一步步的指导，讲解如何创建使用 Snap 严格限制的 Kubernetes Raspberry Pi 集群。
- en: Step 1 – Setting up an Ubuntu Core image to an SD card
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 1 – 将 Ubuntu Core 镜像设置到 SD 卡
- en: The first step is to install an Ubuntu Core image to the microSD card. To do
    that, we will be using the **Raspberry Pi Imager tool** to install an OS image
    to a microSD card that can then be used with Raspberry Pi.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将 Ubuntu Core 镜像安装到 microSD 卡上。为此，我们将使用**Raspberry Pi Imager 工具**将操作系统镜像写入
    microSD 卡，然后可以用它在 Raspberry Pi 上运行。
- en: Download and install **Raspberry Pi Imager** from the Raspberry Pi website on
    a computer equipped with an SD card reader.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Raspberry Pi 网站下载并安装**Raspberry Pi Imager**到一台配有 SD 卡读卡器的计算机上。
- en: 'As depicted in *Figure 15.2*, run Raspberry Pi Imager with the microSD card
    and open the **CHOOSE OS** menu as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 15.2*所示，运行 Raspberry Pi Imager 并插入 microSD 卡，然后打开**选择操作系统**菜单，如下所示：
- en: '![Figure 15.2 – Raspberry Pi Imager ](img/Figure_15.02_B18115.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – Raspberry Pi Imager](img/Figure_15.02_B18115.jpg)'
- en: Figure 15.2 – Raspberry Pi Imager
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – Raspberry Pi Imager
- en: 'From the OS menu, choose **Other general purpose OS** from the options listed,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作系统菜单中，选择**其他通用操作系统**，如以下所示：
- en: '![Figure 15.3 – Raspberry Pi Imager OS options ](img/Figure_15.03_B18115.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – Raspberry Pi Imager 操作系统选项](img/Figure_15.03_B18115.jpg)'
- en: Figure 15.3 – Raspberry Pi Imager OS options
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – Raspberry Pi Imager 操作系统选项
- en: 'Choose the **Ubuntu Core** **64-bit version** that works with Raspberry Pi
    2,3, 3, and 4 from the options listed (refer to *Figure 15.4*) as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从选项中选择与 Raspberry Pi 2、3 和 4 兼容的**Ubuntu Core 64 位版本**（参见*图 15.4*），如以下所示：
- en: '![Figure 15.4 – Choose Ubuntu Core 64-bit version ](img/Figure_15.04_B18115.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.4 – 选择 Ubuntu Core 64 位版本](img/Figure_15.04_B18115.jpg)'
- en: Figure 15.4 – Choose Ubuntu Core 64-bit version
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – 选择 Ubuntu Core 64 位版本
- en: 'As depicted in *Figure 15.5*, open the **Storage** menu after selecting **Ubuntu
    Core 64-bit image**. Choose the micro SD card that you’ve inserted as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 15.5*所示，选择**Ubuntu Core 64 位镜像**后，打开**存储**菜单。选择您插入的 microSD 卡，如下所示：
- en: '![Figure 15.5 – Raspberry Pi Imager write operation ](img/Figure_15.05_B18115.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.5 – Raspberry Pi Imager 写入操作](img/Figure_15.05_B18115.jpg)'
- en: Figure 15.5 – Raspberry Pi Imager write operation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – Raspberry Pi Imager 写入操作
- en: Finally, click on **Write** to start the operation and Raspberry Pi Imager will
    wipe your micro SD card data; you will be prompted to confirm this procedure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击**写入**以开始操作，Raspberry Pi Imager 会清除您的 microSD 卡数据；系统会提示您确认此过程。
- en: Post confirmation, Raspberry Pi Imager will start flashing OS images to the
    micro SD card. It will take a while to finish.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确认后，Raspberry Pi Imager 将开始将操作系统镜像写入 microSD 卡。完成此操作需要一些时间。
- en: Once finished, continue with the creation of an Ubuntu Single Sign-On (SSO)
    account.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，继续创建一个 Ubuntu 单点登录（SSO）账户。
- en: Step 2 – Creating an Ubuntu SSO account
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 2 – 创建一个 Ubuntu SSO 账户
- en: An Ubuntu **SSO** account needs to be created so that Secure shell (SSH) public
    keys can be stored and linked to an email address. This allows Ubuntu Core devices
    to only permit SSH connections from the devices that have public keys that match
    those in your SSO account.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个 Ubuntu **SSO** 帐户，以便存储并将安全外壳（SSH）公钥链接到电子邮件地址。这允许 Ubuntu Core 设备仅允许来自那些具有与
    SSO 帐户中匹配的公钥的设备进行 SSH 连接。
- en: Go to [https://login.ubuntu.com/](https://login.ubuntu.com/) and fill in the
    relevant information, and after the SSO account has been created, generate the
    SSH key pair as explained in the following section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://login.ubuntu.com/](https://login.ubuntu.com/)，填写相关信息，并在创建 SSO 帐户后，按照以下部分的说明生成
    SSH 密钥对。
- en: Step 3 – Generating an SSH key pair
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 3 – 生成 SSH 密钥对
- en: '**SSH**, as we know, is a popular way to connect to remote Linux servers. The
    authentication process involves the pairing of a private local key with a public
    remote key, which is used to secure communication from your device to Linux servers
    that are hosting the application.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSH**，正如我们所知道的，是一种连接到远程 Linux 服务器的流行方式。身份验证过程涉及将本地私钥与远程公钥配对，用于保护从你的设备到托管应用程序的
    Linux 服务器之间的通信。'
- en: Using the free and open source OpenSSH software included in Windows 10, SSH
    keys can be generated. SSH keys can also be generated through the PuTTYgen utility,
    which has support for various platforms. We’re going to use the built-in Windows
    OpenSSH client for the following steps.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Windows 10 中包含的免费开源 OpenSSH 软件，可以生成 SSH 密钥。SSH 密钥还可以通过 PuTTYgen 工具生成，该工具支持各种平台。接下来的步骤我们将使用内置的
    Windows OpenSSH 客户端。
- en: 'From the PowerShell window, enter the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PowerShell 窗口，输入以下命令：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first step asks where you would like to save the key, and you can accept
    the default answer by pressing `Return`, as shown in the command execution output
    in *Figure 15.6*. The passphrase is requested in the second step. When a passphrase
    is entered, it is required to use the passphrase each time the key is accessed.
    The passphrase is optional; pressing `Return` twice will create a key pair without
    requiring a passphrase, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步询问你希望将密钥保存在哪里，按`Return`键可以接受默认选项，如*图 15.6*所示的命令执行输出所示。第二步要求输入密码短语。当输入密码短语时，每次访问密钥时都需要使用该密码短语。密码短语是可选的；如果按`Return`键两次，则会创建一个没有密码短语的密钥对，具体如下：
- en: '![Figure 15.6 – SSH key generation ](img/Figure_15.06_B18115.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.6 – SSH 密钥生成](img/Figure_15.06_B18115.jpg)'
- en: Figure 15.6 – SSH key generation
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 – SSH 密钥生成
- en: 'The private key and the public key can be found in the same folder once the
    process is complete, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完成过程后，私钥和公钥将位于同一文件夹中，具体如下：
- en: '![Figure 15.7 – Private and public keys generated ](img/Figure_15.07_B18115.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.7 – 生成的私钥和公钥](img/Figure_15.07_B18115.jpg)'
- en: Figure 15.7 – Private and public keys generated
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7 – 生成的私钥和公钥
- en: We can now use the generated public and private keys for Ubuntu Core installation.
    The following step is to add the public key to an Ubuntu SSO account so that it
    could be used to permit connections from the devices that have public keys.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用生成的公钥和私钥来安装 Ubuntu Core。接下来的步骤是将公钥添加到 Ubuntu SSO 帐户中，以便它可以用来允许拥有公钥的设备连接。
- en: 'From the Ubuntu SSO account login, under the `ubuntu-core-rpi.pub` (public
    key) file to import the public key as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Ubuntu SSO 帐户登录后，在 `ubuntu-core-rpi.pub`（公钥）文件下导入公钥，如下所示：
- en: '![Figure 15.8 – Import SSH keys ](img/Figure_15.08_B18115.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.8 – 导入 SSH 密钥](img/Figure_15.08_B18115.jpg)'
- en: Figure 15.8 – Import SSH keys
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.8 – 导入 SSH 密钥
- en: 'The following screenshot shows that the public key has been imported successfully:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了公钥已成功导入：
- en: '![Figure 15.9 – SSH keys imported ](img/Figure_15.09_B18115.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.9 – SSH 密钥已导入](img/Figure_15.09_B18115.jpg)'
- en: Figure 15.9 – SSH keys imported
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9 – SSH 密钥已导入
- en: Now that we have imported SSH keys to the Ubuntu SSO account, the following
    step is to power Raspberry Pi and boot Ubuntu Core.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 SSH 密钥导入到 Ubuntu SSO 帐户，接下来的步骤是为 Raspberry Pi 供电并启动 Ubuntu Core。
- en: Step 4 – Booting Ubuntu Core on Raspberry Pi
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 4 – 在 Raspberry Pi 上启动 Ubuntu Core
- en: Extract the SD card from your laptop and insert it into Raspberry Pi. Before
    powering the Pi, connect an HDMI screen and a USB keyboard. Power on the Pi and
    you will be able to see the boot process on the screen. It typically takes less
    than 5 minutes to complete the booting process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从笔记本电脑中取出 SD 卡并插入 Raspberry Pi。在为 Pi 供电之前，连接 HDMI 屏幕和 USB 键盘。启动 Pi 后，你将能够在屏幕上看到启动过程。通常启动过程会在
    5 分钟内完成。
- en: When the boot process is complete, you will see instructions for configuring
    the network and creating an administrator account on Ubuntu Core. In this configuration,
    you will be able to configure Wi-Fi settings, and the following step will require
    you to provide the email address associated with your SSO account. Once configured,
    the device will automatically update and, if necessary, restart.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程完成后，您将看到配置网络和创建管理员帐户的说明。在此配置下，您将能够配置 Wi-Fi 设置，下一步将要求您提供与 SSO 帐户相关的电子邮件地址。配置完成后，设备将自动更新，并在必要时重启。
- en: After you provide your email and the Pi connects to your account, you will be
    able to use any SSH client, for example, PuTTY, to connect to your Pi.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供您的电子邮件并且 Pi 连接到您的帐户后，您将能够使用任何 SSH 客户端，例如 PuTTY，连接到您的 Pi。
- en: '*Success! You are now connected to Ubuntu Core running on your Raspberry Pi.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*成功！您现在已连接到运行 Ubuntu Core 的 Raspberry Pi。*'
- en: We’ve finished configuring the settings and we are ready to go on to the following
    step of installing and configuring the MicroK8s snap with strict confinement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已完成配置设置，现在可以进入下一步，安装并配置带有严格限制的 MicroK8s snap。
- en: Setting up MicroK8s on Ubuntu Core
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ubuntu Core 上设置 MicroK8s
- en: 'SSH into your control plane node and install the latest version of the MicroK8s
    snap with strict confinement as in the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SSH 登录到控制平面节点，并安装最新版本的 MicroK8s snap，并启用严格限制，如以下命令所示：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output after the execution of the preceding command, which
    confirms that the MicroK8s snap with strict confinement was successfully configured:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行前述命令后的输出，确认带有严格限制的 MicroK8s snap 已成功配置：
- en: '![Figure 15.10 – Successful MicroK8s snap installation  ](img/Figure_15.10_B18115.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.10 – MicroK8s snap 安装成功](img/Figure_15.10_B18115.jpg)'
- en: Figure 15.10 – Successful MicroK8s snap installation
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10 – MicroK8s snap 安装成功
- en: 'Now that we have installed the MicroK8s snap, let’s run the `microk8s status`
    command to verify its running state as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 MicroK8s snap，让我们运行 `microk8s status` 命令来验证其运行状态，如下所示：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the output after the execution of the preceding command, which
    confirms that the MicroK8s snap with strict confinement is running successfully:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行前述命令后的输出，确认带有严格限制的 MicroK8s snap 已成功运行：
- en: '![Figure 15.11 – MicroK8s snap is running ](img/Figure_15.11_B18115.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.11 – MicroK8s snap 正在运行](img/Figure_15.11_B18115.jpg)'
- en: Figure 15.11 – MicroK8s snap is running
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11 – MicroK8s snap 正在运行
- en: Strict confinement *locks down* the apps in the snap using Linux kernel security
    capabilities. Access will be extremely constrained for a highly contained application
    without any stated interfaces. MicroK8s running successfully indicates that all
    necessary interfaces are specified and application access requirements are met.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 严格限制（*strict confinement*）利用 Linux 内核的安全能力将应用程序锁定在 snap 中。对于没有明确接口的高度受限应用程序，访问将受到极大限制。MicroK8s
    成功运行表明所有必要的接口已被指定，且满足应用程序访问要求。
- en: 'To view the MicroK8s snap interfaces, use the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 MicroK8s snap 接口，请使用以下命令：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output after the execution of the preceding command, which
    lists interfaces of the MicroK8s snap:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行前述命令后的输出，列出了 MicroK8s snap 的接口：
- en: '![Figure 15.12 – MicroK8s snap interfaces ](img/Figure_15.12_B18115.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.12 – MicroK8s snap 接口](img/Figure_15.12_B18115.jpg)'
- en: Figure 15.12 – MicroK8s snap interfaces
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.12 – MicroK8s snap 接口
- en: In the end, all snaps would need to aim for a strict confinement level, using
    only the APIs required for the application to run properly, and nothing else.
    Additionally, Ubuntu Core necessitates that snaps are on a strict confinement
    model.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，所有 snap 都需要达到严格限制级别，仅使用应用程序正常运行所需的 API，其他的则不使用。此外，Ubuntu Core 要求所有 snap 都采用严格限制模型。
- en: Read more about interfaces and confinement in the Snapcraft documentation at
    [https://docs.snapcraft.io](https://docs.snapcraft.io).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Snapcraft 文档中了解更多关于接口和限制的信息，访问 [https://docs.snapcraft.io](https://docs.snapcraft.io)。
- en: 'Now that we have installed MicroK8s, let’s verify whether the node status is
    `Ready` using the `kubectl get nodes` command as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 MicroK8s，让我们使用 `kubectl get nodes` 命令来验证节点状态是否为 `Ready`，如下所示：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the installation is successful, then you should see the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，您应该会看到以下输出：
- en: '![Figure 15.13 – Verifying whether the node is in a Ready state ](img/Figure_15.13_B18115.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.13 – 验证节点是否处于 Ready 状态](img/Figure_15.13_B18115.jpg)'
- en: Figure 15.13 – Verifying whether the node is in a Ready state
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 – 验证节点是否处于Ready状态
- en: Since MicroK8s is packaged as a snap, it will automatically upgrade to newer
    point releases. Also, the strictly confined MicroK8s version of the snap is currently
    on a dedicated snap channel that is synchronized with the latest version of upstream
    of Kubernetes, that is, an open source version of Kubernetes managed and maintained
    by the Cloud Native Computing Foundation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MicroK8s被打包为snap包，它将自动升级到更新的版本。此外，MicroK8s的严格封闭版本目前位于一个专用的snap通道中，与Kubernetes的上游最新版本同步，Kubernetes是由云原生计算基金会管理和维护的开源版本。
- en: 'Based on MicroK8s releases, channels are formed of a track (or series) and
    an anticipated level of stability (*stable*, *candidate*, *beta*, and *edge*).
    For more information about releases and channels, run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 基于MicroK8s的发布，通道由一个轨道（或系列）和一个预期的稳定性级别（*stable*、*candidate*、*beta* 和 *edge*）组成。有关发布和通道的更多信息，请运行以下命令：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the output after the execution of the preceding command, which
    shows the list of channels (*stable*, *candidate*, *beta*, and *edge*) and their
    release dates:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行上述命令后的输出，显示了各个通道（*stable*、*candidate*、*beta* 和 *edge*）及其发布日期：
- en: '![Figure 15.14 – MicroK8s list of channels (stable, candidate, beta, and edge)
    and the release dates ](img/Figure_15.14_B18115.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图15.14 – MicroK8s通道列表（stable、candidate、beta和edge）及其发布日期](img/Figure_15.14_B18115.jpg)'
- en: Figure 15.14 – MicroK8s list of channels (stable, candidate, beta, and edge)
    and the release dates
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14 – MicroK8s通道列表（stable、candidate、beta和edge）及其发布日期
- en: Repeat the MicroK8s installation process on the other nodes as well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他节点上重复MicroK8s的安装过程。
- en: 'The output of the command for the MicroK8s installation on the worker node
    is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作节点上安装MicroK8s的命令输出如下：
- en: '![Figure 15.15 – Successful MicroK8s snap installation on the worker1 node  ](img/Figure_15.15_B18115.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图15.15 – 在worker1节点上成功安装MicroK8s snap](img/Figure_15.15_B18115.jpg)'
- en: Figure 15.15 – Successful MicroK8s snap installation on the worker1 node
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15 – 在worker1节点上成功安装MicroK8s snap
- en: 'The following `microk8s status` command execution output confirms that MicroK8s
    is running successfully on the worker node as well:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行`microk8s status`命令后的输出，确认MicroK8s也已在工作节点上成功运行：
- en: '![Figure 15.16 – Verifying whether MicroK8s is running ](img/Figure_15.16_B18115.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图15.16 – 验证MicroK8s是否正在运行](img/Figure_15.16_B18115.jpg)'
- en: Figure 15.16 – Verifying whether MicroK8s is running
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16 – 验证MicroK8s是否正在运行
- en: 'Now that MicroK8s is running, the following step is to check whether the `kubectl
    get nodes` command displays the node in a `Ready` state as indicated in the command
    execution output as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在MicroK8s已经运行，接下来的步骤是检查`kubectl get nodes`命令是否显示节点处于`Ready`状态，具体如下所示：
- en: '![Figure 15.17 – Verifying whether the node is in a Ready state ](img/Figure_15.17_B18115.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图15.17 – 验证节点是否处于Ready状态](img/Figure_15.17_B18115.jpg)'
- en: Figure 15.17 – Verifying whether the node is in a Ready state
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17 – 验证节点是否处于Ready状态
- en: 'We have completed the installation of MicroK8s on all boards. The following
    step is to add the worker node to the control plane node. Open the PuTTY shell
    to the control plane node and run the following command to generate the connection
    string:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在所有节点上完成了MicroK8s的安装。接下来的步骤是将工作节点添加到控制平面节点中。打开PuTTY终端连接到控制平面节点，并运行以下命令生成连接字符串：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output after the execution of the preceding command. It
    validates that the command was successfully executed and provides instructions
    for generating the connection string:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行上述命令后的输出。它验证了命令已成功执行，并提供了生成连接字符串的说明：
- en: '![Figure 15.18 – Generating the connection string for adding nodes ](img/Figure_15.18_B18115.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图15.18 – 生成用于添加节点的连接字符串](img/Figure_15.18_B18115.jpg)'
- en: Figure 15.18 – Generating the connection string for adding nodes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18 – 生成用于添加节点的连接字符串
- en: As indicated by the preceding command execution output, the connection string
    is generated in the form of `<control plane_ip>:<port>/<token>`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述命令执行输出所示，连接字符串以`<control plane_ip>:<port>/<token>`的形式生成。
- en: Adding the worker node
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加工作节点
- en: 'We now have the connection string to join with the control plane node. Open
    the PuTTY shell to the worker node and run the `join` command to add it to the
    cluster, as can be seen in the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有连接字符串来与控制平面节点连接。打开 PuTTY 终端连接到 worker 节点，并运行 `join` 命令将其添加到集群中，以下是该命令的执行情况：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The command was successfully executed, and the node has joined the cluster,
    as shown in the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 命令成功执行，节点已成功加入集群，输出如下所示：
- en: '![Figure 15.19 – Add worker#1 node to the cluster ](img/Figure_15.19_B18115.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图15.19 – 将 worker#1 节点添加到集群](img/Figure_15.19_B18115.jpg)'
- en: Figure 15.19 – Add worker#1 node to the cluster
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.19 – 将 worker#1 节点添加到集群
- en: As indicated by the command execution output shown in *Figure 15.19*, you should
    be able to see the new node in a few seconds on the control plane node.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图15.19*所示的命令执行输出所示，您应该能在几秒钟内在控制平面节点上看到新节点。
- en: 'Use the following command to verify whether the new node is added to the cluster:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证新节点是否已添加到集群中：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following command execution output shows that the control plane and `worker1`
    nodes are part of the cluster:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出显示控制平面和`worker1`节点是集群的一部分：
- en: '![Figure 15.20 – The cluster is ready and the control plane and worker1 nodes
    are part of the cluster ](img/Figure_15.20_B18115.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图15.20 – 集群已就绪，控制平面和 worker1 节点已加入集群](img/Figure_15.20_B18115.jpg)'
- en: Figure 15.20 – The cluster is ready and the control plane and worker1 nodes
    are part of the cluster
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.20 – 集群已就绪，控制平面和 worker1 节点已加入集群
- en: At this point, you have a fully functional multi-node Kubernetes cluster with
    strict confinement enabled. To summarize, we have installed the MicroK8s snap
    on the Raspberry Pi boards running Ubuntu Core and joined multiple deployments
    to form the cluster. We’ve seen how to add nodes to the cluster as well. In the
    following section, we are going to deploy a sample application on the MicroK8s
    cluster that we just created.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已拥有一个完全功能的多节点 Kubernetes 集群，并启用了严格的隔离。总结一下，我们已在运行 Ubuntu Core 的树莓派板上安装了
    MicroK8s snap，并将多个部署连接起来形成集群。我们也看到了如何向集群中添加节点。接下来，我们将要在刚刚创建的 MicroK8s 集群上部署一个示例应用程序。
- en: Deploying a sample containerized application
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个示例容器化应用程序
- en: 'In this section, we will be deploying one of the nginx deployments from the
    Kubernetes examples repository on our MicroK8s cluster setup, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在我们的 MicroK8s 集群环境中部署 Kubernetes 示例库中的 nginx 部署，具体如下：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the output after the execution of the preceding command. It
    indicates that there is no error in the deployment, and in the following steps,
    we can verify whether the deployment is successful using the `get pods` command
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令执行后的输出，显示部署没有错误，接下来的步骤中，我们可以使用 `get pods` 命令来验证部署是否成功：
- en: '![Figure 15.21 – Sample application deployment ](img/Figure_15.21_B18115.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图15.21 – 示例应用程序部署](img/Figure_15.21_B18115.jpg)'
- en: Figure 15.21 – Sample application deployment
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.21 – 示例应用程序部署
- en: 'Check the status of the pods to verify whether the application has been deployed
    and is running as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 pods 状态，以验证应用程序是否已成功部署并运行，如下所示：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output after the execution of the preceding command, which
    indicates that pods are created and that their status is `Running`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令执行后的输出，显示了 pods 已被创建，并且其状态为`Running`：
- en: '![Figure 15.22 – Checking whether pods have a Running status ](img/Figure_15.22_B18115.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图15.22 – 检查 pods 是否处于 Running 状态](img/Figure_15.22_B18115.jpg)'
- en: Figure 15.22 – Checking whether pods have a Running status
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.22 – 检查 pods 是否处于 Running 状态
- en: '*Great! We have just deployed and examined our sample application deployment
    on the Raspberry multi-node cluster running Ubuntu Core.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了！我们刚刚在运行 Ubuntu Core 的树莓派多节点集群上部署并检查了我们的示例应用程序部署。*'
- en: To summarize, embedded Linux development utilizing snaps, Snapcraft, and Ubuntu
    Core is a lot quicker, safer, and more reliable than the current options available
    in the market. As it can package, distribute, and update any app through the global
    Snap Store, Snapcraft makes it simpler to find new software for your embedded
    devices. Additionally, the application updates either completely succeed or are
    not deployed at all. During both application and system updates, your embedded
    device running Ubuntu Core stays fully functional.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，利用快照、Snapcraft和Ubuntu Core进行嵌入式Linux开发比市场上现有的选项更快捷、更安全、更可靠。由于它能够通过全球Snap
    Store打包、分发和更新任何应用程序，Snapcraft使得为嵌入式设备寻找新软件变得更加简单。此外，应用程序更新要么完全成功，要么根本不会部署。在进行应用程序和系统更新时，运行Ubuntu
    Core的嵌入式设备始终保持完全功能。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to install the MicroK8s snap with the strict
    confinement option, monitored the installation’s progress, and managed the Kubernetes
    cluster running on Ubuntu Core. We also deployed a sample application and examined
    whether the application is able to run on a strict confinement-enabled Kubernetes
    cluster.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何使用严格限制选项安装MicroK8s快照，监控安装进度，并管理在Ubuntu Core上运行的Kubernetes集群。我们还部署了一个示例应用程序，并检查了该应用程序是否能够在启用了严格限制的Kubernetes集群上运行。
- en: We also introduced a new embedded OS, Ubuntu Core, which complies with enterprise
    standards by enabling automated updates, app stores, and software management.
    We also learned that it is built from the ground up to be the most secure platform
    for connected devices. Furthermore, Ubuntu Core provides a modular design based
    on snaps, bullet-proof application updates, a seamless developer experience via
    Snapcraft, and built-in security to handle the challenges of embedded Linux development.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一个新的嵌入式操作系统，Ubuntu Core，它通过启用自动更新、应用商店和软件管理来符合企业标准。我们还了解到，它从零开始构建，旨在成为最安全的连接设备平台。此外，Ubuntu
    Core提供了基于快照的模块化设计、防弹的应用更新、通过Snapcraft无缝的开发者体验以及内置的安全性，以应对嵌入式Linux开发中的挑战。
- en: In this and earlier chapters, we have covered most of the implementation aspects
    that are required for your IoT/Edge computing applications using MicroK8s in detail;
    this includes running your applications on a multi-node Raspberry Pi cluster,
    configuring load balancing mechanisms, installing/configuring different CNI plugins
    for network connectivity, configuring logging, monitoring, and alerting options
    for your cluster, and building/deploying machine learning models and serverless
    applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章及之前的章节中，我们详细讨论了使用MicroK8s进行物联网/边缘计算应用程序所需的多数实施方面；包括在多节点Raspberry Pi集群上运行应用程序、配置负载均衡机制、为网络连接安装/配置不同的CNI插件、为集群配置日志、监控和警报选项，以及构建/部署机器学习模型和无服务器应用程序。
- en: Additionally, we have looked at setting up storage replication for your stateful
    applications, implementing a service mesh for your cross-cutting concerns, setting
    up a high-availability cluster to withstand component failure and continue to
    serve workloads without interruption, configuring containers with workload isolation,
    and running secured containers with isolation from a host system. In the following
    chapter, we’ll look at how MicroK8s is uniquely positioned for accelerating IoT
    and Edge deployments and also key trends that are shaping up our new future.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了为有状态应用程序设置存储复制、为跨领域问题实现服务网格、设置高可用性集群以承受组件故障并持续为工作负载提供服务、配置具有工作负载隔离的容器以及运行与主机系统隔离的安全容器。在接下来的章节中，我们将探讨MicroK8s如何在加速物联网（IoT）和边缘计算部署方面独树一帜，并分析塑造我们新未来的关键趋势。
