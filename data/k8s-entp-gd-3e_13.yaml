- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: KubeArmor Securing Your Runtime
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KubeArmor保护你的运行时
- en: As the popularity of Kubernetes grows, so does the need for robust security
    measures to protect workloads. We learned how to secure a cluster using RBAC,
    which allows us to control the access that users have to resources. Using RBAC,
    we can control what users can execute on a cluster, controlling if someone can
    create or delete a pod, view logs, view Secrets, etc. We also looked at securing
    clusters using Gatekeeper policies that can protect nodes by denying the creation
    of an object that contains a value against security policies like attempting to
    allow privilege escalation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Kubernetes的普及，保护工作负载的强大安全措施的需求也在增加。我们学习了如何使用RBAC来保护集群安全，RBAC允许我们控制用户对资源的访问权限。通过RBAC，我们可以控制用户在集群上能执行什么操作，控制某人是否能够创建或删除Pod、查看日志、查看Secrets等。我们还研究了使用Gatekeeper策略来保护集群，这可以通过拒绝创建违反安全策略的对象（例如尝试允许特权升级）来保护节点。
- en: While these go a long way to securing clusters, there are certain actions that
    are often overlooked by many organizations. One of the most important examples
    is securing the container runtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些措施大大增强了集群的安全性，但许多组织经常忽视某些操作。最重要的例子之一就是保护容器运行时。
- en: Kubernetes has limited abilities to audit or secure actions that are executed
    within a container. While Kubernetes can handle certain security requirements
    like blocking elevated privilege attempts within a container, it doesn’t provide
    a way for operators to limit most actions that are executed in the container.
    It cannot allow or deny any actions that a user may be able to execute once they
    exec into a running container, like looking at files, deleting files, adding files,
    and more. Even worse, most actions executed inside a container are not audited
    by the Kubernetes API server, which is why they often go overlooked.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在审计或保护容器内执行的操作方面的能力有限。尽管Kubernetes可以处理某些安全要求，例如阻止容器内的特权提升尝试，但它并没有为操作员提供限制容器中执行的大部分操作的方式。它不能允许或拒绝用户在执行进入运行中的容器时能够执行的任何操作，比如查看文件、删除文件、添加文件等。更糟糕的是，大多数在容器内执行的操作不会被Kubernetes
    API服务器审计，这也是这些操作常常被忽视的原因。
- en: In *Chapter 8*, *Managing Secrets*, we learned about using Vault to store and
    retrieve secrets. Many people think that if they use a system like Vault, they
    have secured their secrets from anyone being able to view the data in the secret.
    It is true that the secret isn’t stored in a basic K8s secret resource, where
    anyone with the required permissions to the namespace would be able to view and
    decode the secret. Since a Vault secret will be stored in your pod as an environment
    variable or a file, there is no way to stop someone who has access to exec into
    the container from viewing the container’s environment variables or the files
    where the Vault secret is stored.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第八章*，*管理机密*中，我们学习了如何使用Vault来存储和检索机密。许多人认为，如果使用像Vault这样的系统，他们就能确保机密数据不被任何人查看。的确，机密数据不会存储在基本的K8s秘密资源中，在那里，只要有适当的命名空间权限，任何人都可以查看并解码机密。然而，由于Vault机密将存储在你的Pod中作为环境变量或文件，无法阻止拥有exec权限的人查看容器的环境变量或存储Vault机密的文件。
- en: We also need a way to stop certain processes from running in containers. Your
    organization may have a policy that a container should never run an SSH daemon.
    Without an add-on tool, you have limited options to secure binaries to that level
    in a running container.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方式来阻止某些进程在容器中运行。你的组织可能有一个策略，即容器永远不应运行SSH守护进程。如果没有附加工具，你在运行中的容器中保护二进制文件到这种级别的选项非常有限。
- en: Sure, you can create pipelines and security checks when an image is created
    and deny images that don’t follow documented security standards, but once the
    image passes and is deployed, how do you stop someone from executing an exec into
    the container and adding binaries like the SSH daemon, or even worse, malware
    or crypto mining tools?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在镜像创建时创建管道和安全检查，并拒绝不符合文档安全标准的镜像，但一旦镜像通过并部署了，如何阻止某人执行exec进入容器并添加像SSH守护进程这样的二进制文件，甚至更糟的恶意软件或加密矿工工具？
- en: Luckily, a company called AccuKnox has donated a project to the CNCF called
    **KubeArmor** that provides you with the ability to secure your container runtime.
    KubeArmor isn’t limited to only the runtime; it has a number of other useful features
    that are related to securing your workloads, including restricting process execution,
    file access, and more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一家公司名为 AccuKnox 向 CNCF 捐赠了一个名为**KubeArmor**的项目，它为您提供了保护容器运行时的能力。KubeArmor
    不仅限于运行时，它还具有一些与保护工作负载相关的其他有用功能，包括限制进程执行、文件访问等。
- en: 'In this chapter, we will explain how to deploy KubeArmor and how to use its
    many features to enhance the security of your clusters. Here are a few topics
    that we will cover in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何部署 KubeArmor，以及如何使用其众多功能来增强集群的安全性。以下是我们将在本章中介绍的几个主题：
- en: What is runtime security?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是运行时安全？
- en: Introducing KubeArmor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 KubeArmor
- en: Deploying KubeArmor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 KubeArmor
- en: Enabling KubeArmor logging
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 KubeArmor 日志记录
- en: KubeArmor and LSM policies
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KubeArmor 和 LSM 策略
- en: Creating a KubeArmorSecurityPolicy
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 KubeArmorSecurityPolicy
- en: Using karmor to interact with KubeArmor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 karmor 与 KubeArmor 互动
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: An Ubuntu 22.04+ server running Docker with a minimum of 8 GB of RAM
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Docker 的 Ubuntu 22.04+ 服务器，内存至少为 8 GB
- en: A KinD cluster, preferably a new cluster, with Vault integrated
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 KinD 集群，最好是一个新的集群，并且集成了 Vault
- en: 'Scripts from the `chapter13` folder from the repo, which you can access by
    going to this book’s GitHub repository: [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过访问本书的 GitHub 仓库：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)
    来获取 `chapter13` 文件夹中的脚本。
- en: What is runtime security?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是运行时安全？
- en: Runtime security is a vital part of security for systems, applications, and
    data when they are most exposed to attacks during active execution, while they
    are up and running on your network. Runtimes, often left unmonitored and sometimes
    lacking in any form of logging or auditing, pose a critical security challenge.
    Of course, runtime security is not exclusive to containers; it is a requirement
    for applications, containers, physical servers, virtual machines, and more. Every
    component within your infrastructure requires continuous monitoring of all potential
    security risks to quickly detect threats and vulnerabilities posed by potential
    attackers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时安全是系统、应用程序和数据在活跃执行期间最容易受到攻击时的关键安全部分，尤其是在它们运行在您的网络上时。运行时通常未被监控，有时缺乏任何形式的日志记录或审计，这带来了重大的安全挑战。当然，运行时安全不仅限于容器，它对于应用程序、容器、物理服务器、虚拟机等都是必要的。基础设施中的每个组件都需要持续监控所有潜在的安全风险，以便快速检测到潜在攻击者带来的威胁和漏洞。
- en: 'In the face of increasingly sophisticated and dynamic security threats, the
    reliance solely on static security measures is no longer adequate. This is where
    runtime security comes in, providing dynamic, real-time protection precisely when
    it is most crucial: with live systems. Through constant monitoring of the runtime
    environment, these systems can spot anomalies, suspicious activities, and unauthorized
    processes and allow or block actions based on a set of policies.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 面对日益复杂和动态的安全威胁，单纯依赖静态的安全措施已经不再足够。这就是运行时安全的作用所在，它提供动态的、实时的保护，正是在最关键的时候：在系统运行时。通过不断监控运行时环境，这些系统能够发现异常、可疑活动和未经授权的进程，并根据一组策略允许或阻止操作。
- en: To secure workloads you need to follow key practices, such as permitting only
    authorized processes in a container, implementing measures to prevent and alert
    on any unauthorized resource access, or inspecting network traffic to detect any
    hostile activities. For example, you can limit what processes can access files
    or directories in a container, denying access to a database file to any process
    that isn’t part of MySQL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护工作负载，您需要遵循一些关键实践，例如只允许授权的进程在容器中运行、实施措施防止并警告任何未经授权的资源访问，或检查网络流量以检测任何恶意活动。例如，您可以限制哪些进程可以访问容器中的文件或目录，拒绝任何非
    MySQL 进程访问数据库文件。
- en: 'Runtime security has multiple pieces to consider: using KubeArmor is just one
    of the tools to help protect your workloads and clusters. *Figure 13.1* shows
    a picture of the components that make up a runtime environment from the CNCF security
    V2 whitepaper. You can find the whole paper on the CNCF website at [https://www.cncf.io/wp-content/uploads/2022/06/CNCF_cloud-native-security-whitepaper-May2022-v2.pdf](https://www.cncf.io/wp-content/uploads/2022/06/CNCF_cloud-native-security-whitepaper-May2022-v2.pdf).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时安全需要考虑多个方面：使用KubeArmor只是帮助保护您的工作负载和集群的工具之一。*图13.1*展示了来自CNCF安全V2白皮书的运行时环境组件的图片。您可以在CNCF网站上找到完整的白皮书，网址是[https://www.cncf.io/wp-content/uploads/2022/06/CNCF_cloud-native-security-whitepaper-May2022-v2.pdf](https://www.cncf.io/wp-content/uploads/2022/06/CNCF_cloud-native-security-whitepaper-May2022-v2.pdf)。
- en: We have covered many of the various tools to secure your runtimes in previous
    chapters, including network policies, identity and access management, secrets,
    and policy security using **Gatekeeper**. Combining these options with the added
    security that KubeArmor supplies, you can secure your clusters from malicious
    activity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中已经介绍了许多用于保护运行时的工具，包括网络策略、身份和访问管理、秘密管理以及使用**Gatekeeper**的策略安全。将这些选项与KubeArmor提供的附加安全性结合起来，您可以保护集群免受恶意活动的侵害。
- en: '![](img/B21165_13_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_01.png)'
- en: 'Figure 13.1: CNCF runtime security landscape'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：CNCF运行时安全景观
- en: In summary, KubeArmor is a runtime security tool that provides dynamic, real-time
    protection for your systems against an ever-expanding spectrum of threats and
    vulnerabilities. Its purpose is to protect the security and stability of your
    infrastructure, upholding the integrity of your operations in the face of countless
    cybersecurity threats.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，KubeArmor是一个运行时安全工具，为您的系统提供动态、实时的保护，防止日益扩展的威胁和漏洞。它的目的是保护您基础设施的安全性和稳定性，在面对无数网络安全威胁时维护您操作的完整性。
- en: Introducing KubeArmor
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍KubeArmor
- en: Before we jump into KubeArmor, we need to define a few base concepts you need
    to be aware of. If you are new to Linux, you may not be familiar with these, and
    even if you are a Linux veteran, the concepts may still be new to you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解KubeArmor之前，我们需要定义一些基础概念，您需要了解这些内容。如果您是Linux新手，可能对这些概念不太熟悉，即使您是Linux老手，这些概念也可能对您来说是新的。
- en: Introduction to Linux Security
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux安全简介
- en: 'In this chapter, you will primarily see two references that need to be understood
    to understand how KubeArmor protects clusters. The first term is **eBPF**, which
    stands for the **extended Berkley Packet Filter**, and the second one is **LSM**,
    which stands for **Linux Security Module**. In *Figure 13.2*, you can see how
    access from a pod goes through KubeArmor before it hits the host’s kernel. This
    is what allows KubeArmor to secure your runtimes: sitting between the pod runtime
    and the kernel, to take action before a request is executed.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将主要看到两个需要理解的术语，以了解KubeArmor如何保护集群。第一个术语是**eBPF**，它代表**扩展贝尔克利数据包过滤器**，第二个术语是**LSM**，代表**Linux安全模块**。在*图13.2*中，您可以看到一个pod的访问如何在到达主机内核之前经过KubeArmor。这就是KubeArmor能够保护您运行时的方式：它位于pod运行时和内核之间，在请求执行之前采取行动。
- en: '![](img/B21165_13_02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_02.png)'
- en: 'Figure 13.2: KubeArmor’s high-level design'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：KubeArmor的高级设计
- en: Now, we need to explain, at a high level, what eBPF and LSMs are and how they
    help to secure a cluster.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从一个高层次的角度解释什么是eBPF和LSM，以及它们如何帮助保护集群。
- en: 'Have you ever wondered how Linux handles the constant stream of data in and
    out of the system? How it monitors performance, and how it protects itself from
    security risks? Well, that’s where eBPF comes in: it handles all these responsibilities
    and more!'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾想过Linux是如何处理进出系统的持续数据流的？它如何监控性能，以及如何保护自己免受安全风险？那么，eBPF就发挥了作用：它处理所有这些任务，甚至更多！
- en: Think of eBPF as a digital traffic cop. Your computer resembles a busy intersection
    where data is in constant motion. eBPF acts as a traffic controller, capable of
    controlling the data flow, inspecting it for issues, and tracking ongoing activities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想象eBPF像一个数字交通警察。您的计算机就像一个繁忙的交叉口，数据在不断流动。eBPF充当交通指挥员，能够控制数据流，检查数据是否存在问题，并跟踪正在进行的活动。
- en: 'One advantage of eBPF is its use of “virtual machines,” rather than requiring
    direct edits to the kernel to add features like monitoring network traffic. eBPF
    primarily uses programs that are written in a restricted subset of C and are executed
    within the kernel. While C is the most commonly used language for creating eBPF
    programs, you can also create them using other languages, including:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF的一个优势是它使用“虚拟机”，而不是直接编辑内核来添加监控网络流量等功能。eBPF主要使用以C语言的受限子集编写的程序，这些程序在内核内执行。虽然C语言是创建eBPF程序时最常用的语言，但你也可以使用其他语言来创建它们，包括：
- en: Go
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Lua
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lua
- en: Python
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Rust
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust
- en: Using a language other than C involves transpiling to C or adding the required
    libraries that abstract the C programming. The final decision on selecting a language
    is ultimately up to your use cases, standards, and expertise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用除C语言以外的语言涉及到转译成C语言或添加所需的库来抽象C语言编程。选择语言的最终决定取决于你的使用案例、标准和专业技能。
- en: In summary, eBPF provides a number of powerful functions, without the need to
    modify the kernel directly. It is highly secured and isolated, providing a security
    boundary through its use of virtual machines, similar to a standard virtual machine
    that runs a full operating system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，eBPF提供了许多强大的功能，而无需直接修改内核。它具有高度的安全性和隔离性，通过使用虚拟机提供了一个安全边界，类似于运行完整操作系统的标准虚拟机。
- en: The other term we mentioned was **LSM**, which stands for **Linux Security Module**.
    Two of the most common LSMs today are SELinux, which is primarily used by Red
    Hat systems, and **AppArmor**, which is used by a number of systems, including
    Ubuntu, SUSE, and Debian.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的另一个术语是**LSM**，即**Linux安全模块**。当前最常见的两个LSM是SELinux，主要用于Red Hat系统，以及**AppArmor**，它被多个系统使用，包括Ubuntu、SUSE和Debian。
- en: Like the previous eBPF section, we are going to provide a high-level overview
    of LSMs with a focus on AppArmor since we are using Ubuntu as our server operating
    system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的eBPF部分类似，我们将提供一个关于LSM的高层概述，重点介绍AppArmor，因为我们使用Ubuntu作为我们的服务器操作系统。
- en: LSMs are used to connect the kernel with security policies and modules, providing
    enforcement of **mandatory access controls** (**MACs**) and additional security
    policies within a Linux system. They provide a framework for security, providing
    hooks into the kernel, and allowing external modules the ability to intercept
    and secure systems calls, file operations, and other various kernel activities.
    LSMs are meant to be very flexible and extensible, allowing you to select and
    create modules that meet your specific requirements, rather than a set of policies
    that a vendor thinks you should implement.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: LSM用于将内核与安全策略和模块连接起来，提供对Linux系统中**强制访问控制**（**MACs**）和额外安全策略的执行。它们提供了一个安全框架，通过内核中的钩子提供对外部模块的支持，使得外部模块能够拦截和保护系统调用、文件操作和其他各种内核活动。LSM设计为非常灵活和可扩展，允许你选择和创建符合特定需求的模块，而不是供应商认为你应该实施的一套政策。
- en: Given that both eBPF and LSMs offer security functionalities, you might be wondering
    how, or if, they are different.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于eBPF和LSM都提供安全功能，你可能会想知道它们是否有区别，或者它们是如何不同的。
- en: Despite their apparent similarities at a high level, they diverge significantly.
    eBPF employs kernel-embedded virtual machines for execution, allowing the creation
    of programs capable of executing low-level tasks such as packet filtering, tracing,
    and performance monitoring. eBPF is commonly employed for network-related tasks,
    performance optimization, or the development of custom kernel-level functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在高层次上看似相似，但它们有显著的不同。eBPF利用内核嵌入的虚拟机进行执行，使得能够创建能够执行低级任务的程序，如数据包过滤、追踪和性能监控。eBPF通常用于与网络相关的任务、性能优化或开发自定义内核级功能。
- en: LSMs are components executed by the kernel, operating externally to the kernel
    itself. The core purpose of LSMs is to enhance system security through the enforcement
    of policies, including MACs, and other measures designed to safeguard system resources.
    These modules have the ability to increase cluster security by restricting access
    to various elements, ranging from files and processes to the flow of network traffic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: LSM是由内核执行的组件，外部运行于内核本身之外。LSM的核心目的是通过执行策略（包括MACs）以及其他旨在保护系统资源的措施来增强系统安全性。这些模块能够通过限制对各种元素的访问（从文件和进程到网络流量的流动）来提高集群安全性。
- en: You can create policies without a tool like KubeArmor if you know enough about
    the specific LSM, like AppArmor. Imagine if you use multiple Linux vendors, you
    would need to know each LSM that each vendor is compatible with. This makes creating
    policies a challenge, and that’s where AppArmorKubeArmor can help.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够了解特定的 LSM（如 AppArmor），你可以在没有像 KubeArmor 这样的工具的情况下创建策略。试想一下，如果你使用多个 Linux
    发行版，你需要了解每个发行版所兼容的 LSM。这使得创建策略变得具有挑战性，而这正是 AppArmorKubeArmor 可以提供帮助的地方。
- en: KubeArmor streamlines the task of creating LSM policies, saving you from having
    to know the syntax between different LSMs. When you create a policy with KubeArmor,
    it automatically generates the corresponding LSM policy on the host system. This
    guarantees that, irrespective of the underlying LSM in operation, you can create
    a uniform set of policies that provide a consistent security standard across multiple
    Linux distributions and LSMs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 简化了创建 LSM 策略的任务，免去了你需要了解不同 LSM 之间语法的麻烦。当你使用 KubeArmor 创建策略时，它会自动在主机系统上生成相应的
    LSM 策略。这保证了无论底层 LSM 是什么，你都可以创建一组统一的策略，确保跨多个 Linux 发行版和 LSM 提供一致的安全标准。
- en: As you can imagine, KubeArmor uses both eBPF and LSMs to help you secure your
    environments. Now that we know about what both eBPF and LSMs provide, we can move
    on to introducing KubeArmor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，KubeArmor 同时使用 eBPF 和 LSM 来帮助你保护环境。现在我们已经了解了 eBPF 和 LSM 提供的功能，接下来我们可以介绍
    KubeArmor。
- en: Welcome to KubeArmor
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎使用 KubeArmor
- en: Securing any environment can be a difficult task. When it comes to protecting
    your clusters, it’s not something you can simply address after the fact; it should
    be a part of the initial design and discussions. Many organizations tend to postpone
    the security aspect of their environments because of the perceived skills, effort,
    and time required to implement security solutions. However, it’s essential to
    establish a security foundation before your cluster goes into production. This
    can present a challenge to organizations, and that’s where KubeArmor steps in
    to assist.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 保护任何环境都可能是一项艰巨的任务。保护集群时，这不是你可以事后简单处理的问题；它应该是最初设计和讨论的一部分。许多组织倾向于推迟环境的安全性问题，因为他们认为实施安全解决方案需要技能、精力和时间。然而，在集群投入生产之前建立安全基础是至关重要的。这对许多组织来说是一个挑战，这正是
    KubeArmor 可以提供帮助的地方。
- en: By deploying KubeArmor, you can increase the security and regulatory compliance
    of containerized applications. KubeArmor serves as a runtime security solution
    designed to secure containerized workloads by enforcing security protocols and
    promptly identifying and allowing or denying any activity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署 KubeArmor，你可以提高容器化应用程序的安全性和合规性。KubeArmor 作为一个运行时安全解决方案，旨在通过强制执行安全协议并及时识别和允许或拒绝任何活动来保护容器化工作负载。
- en: 'The features of KubeArmor are always evolving: by the time you read this book,
    KubeArmor will likely have additional features that we do not cover in this chapter.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 的功能在不断发展：等你读完这本书时，KubeArmor 可能会增加我们在本章中没有涉及的额外功能。
- en: So, what are some of the features that KubeArmor provides to enhance our security?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，KubeArmor 提供了哪些增强我们安全性的功能呢？
- en: Container security
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器安全
- en: 'Containers are the cornerstone of modern applications, making their security
    a primary objective. This isn’t to say that we think non-containerized applications
    don’t need security: of course they do, but non-containerized apps have a lot
    of security options provided by operating systems and third-party vendors. Containers,
    as we know them today, are relatively new and many of the toolsets are still catching
    up.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是现代应用程序的基石，使得容器安全成为首要目标。这并不是说我们认为非容器化应用程序不需要安全性：当然需要，但非容器化应用程序有很多操作系统和第三方供应商提供的安全选项。我们今天所知道的容器是相对较新的，许多工具集仍在追赶。
- en: KubeArmor provides security by continuously monitoring container behavior in
    real time, mitigating risks like container escapes, binary execution, and privilege
    escalations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 通过实时监控容器行为来提供安全性，缓解诸如容器逃逸、二进制执行和权限升级等风险。
- en: Inline mitigation versus post-attack mitigation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联缓解与事后攻击缓解
- en: There are a number of products on the market today that are very good at detecting
    anomalies, but they do not have the ability to block or allow the request before
    it actually executes. This is a post-attack mitigation process, which means the
    action will be allowed or denied and the anomaly will be logged.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多非常擅长检测异常的产品，但它们没有在实际执行之前阻止或允许请求的能力。这是一个攻击后缓解过程，意味着该动作会被允许或拒绝，异常也会被记录下来。
- en: This would be like having a door without a lock and when someone walks into
    the building, all you would get is an alert from a security camera. The person
    would still be allowed into the building since there is no lock on the door.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是有一扇没有锁的门，当有人进入建筑物时，您得到的只是来自监控摄像头的警报。由于门没有锁，这个人仍然可以进入建筑物。
- en: Many of the offerings that only detect events can be integrated with other systems
    to prevent the action(s). For example, a system detects that someone may have
    injected a crypto miner into a running container. The event would be detected
    by the anomaly engine and based on that event, you could trigger a custom written
    routine to create a network policy that would deny all egress and ingress traffic.
    This would block the application from network activity, stopping the pod from
    mining and it would save the current state of the pod since we didn’t destroy
    it; we just stopped all network traffic to and from the pod.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多仅检测事件的产品可以与其他系统集成，以防止动作的执行。例如，一个系统检测到可能有人将加密货币挖矿程序注入正在运行的容器中。该事件将被异常引擎检测到，基于该事件，您可以触发一个自定义编写的程序来创建一个网络策略，拒绝所有进出流量。这将阻止应用程序进行网络活动，停止
    Pod 挖矿，并且我们没有销毁 Pod，只是停止了所有进出 Pod 的网络流量。
- en: '![Post Attack Mitigation](img/B21165_13_03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![攻击后缓解](img/B21165_13_03.png)'
- en: 'Figure 13.3: Post-attack mitigation'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：攻击后缓解
- en: 'In *Figure 13.3*, you can see the flow of a post-mitigation attack. The flow
    of the mitigation is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 13.3*中，您可以看到攻击后缓解的流程。缓解的流程如下：
- en: Post-exploit mitigation works by actioning suspicious activity in response to
    an alert indicating malicious intent.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击后缓解通过对可疑活动采取行动，响应表示恶意意图的警报。
- en: The attacker is allowed to execute a binary or other actions. Since they have
    access, they may be able to disable security controls, logging, etc. to avoid
    detection.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者被允许执行二进制文件或其他操作。由于他们有访问权限，他们可能能够禁用安全控制、日志记录等，以避免被检测到。
- en: Assuming the action has been detected, we send it to an event handler that can
    execute an action based on the event. However, it’s important to point out that
    by the time a malicious process is actioned, sensitive contents may have already
    been deleted, encrypted, or transmitted.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设该动作已经被检测到，我们将其发送到事件处理程序，后者可以根据事件执行相应的动作。然而，重要的是要指出，在恶意进程被执行时，敏感内容可能已经被删除、加密或传输。
- en: Based on the event, the handler will execute an action like deleting the pod
    or perform other actions like creating a network policy to block communication
    without deleting the pod.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据事件，处理程序将执行一个动作，如删除 Pod，或者执行其他动作，如创建网络策略以阻止通信，而不删除 Pod。
- en: 'One key differentiator of KubeArmor is its ability to not only detect the runtime
    event but to take action on the event, to block or allow it based on various parameters.
    Similar to post-attack mitigation, you would still see the attempted action(s)
    logged, which may be required as evidence to document the malicious activity.
    However, unlike the previous example of a door with no lock, this door would have
    a camera and a lock. When someone tries to open the door, the camera will log
    the attempt: but this time, since the door is locked, the opening action will
    be denied.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 的一个关键区别是它不仅能检测运行时事件，还能对事件采取行动，根据各种参数来阻止或允许该事件。与攻击后缓解类似，您仍然会看到尝试的动作被记录下来，这些记录可能是记录恶意活动所需的证据。然而，不像之前那个没有锁的门的例子，这扇门将配有摄像头和锁。当有人尝试打开门时，摄像机会记录下这一尝试：但这一次，由于门被锁住，开门的动作将被拒绝。
- en: '![KubeArmor Differentiation](img/B21165_13_04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![KubeArmor 差异化](img/B21165_13_04.png)'
- en: 'Figure 13.4: Inline mitigation'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：内联缓解
- en: 'In *Figure 13.4*, you can see how streamlined the process is: we don’t need
    an external event handler, or any custom components to act on the event. Since
    KubeArmor handles the events in line, in real time, we can stop an action instantly
    before an attacker can perform any malicious activity, all in a single product.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 13.4* 中，你可以看到该过程是如何简化的：我们无需外部事件处理程序或任何自定义组件来处理事件。由于 KubeArmor 在实时内联处理事件，我们可以在攻击者执行任何恶意操作之前立即停止该行为，所有这些都在一个单一产品中完成。
- en: As you can see, inline mitigation is a better method of mitigating runtime events.
    Threats move quickly in today’s landscape, and we need to be just as quick at
    mitigation. If we are attempting to react to events only after they happen, the
    damage will already have been done and you will just have a log entry that tells
    you someone has done something malicious.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内联缓解是缓解运行时事件的更好方法。威胁在今天的环境中发展迅速，我们需要同样迅速地进行缓解。如果我们只是在事件发生后再进行反应，损害已经发生，你也只能在日志中看到有人做了恶意操作。
- en: Zero-day vulnerability
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零日漏洞
- en: 'Zero-day vulnerabilities take time to remediate, not only from a vendor side
    but from an organizational side as well. If you have the ability to remediate
    any vulnerability as you wait for an official patch, you should: every minute
    counts. KubeArmor monitors container activities for any suspicious activity. It
    can stop activities, without prior knowledge regarding the specific vulnerability
    or attack pattern.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 零日漏洞需要时间来修复，不仅是厂商方面的问题，组织方面也一样。如果你能够在等待官方补丁的同时修复任何漏洞，你应该这么做：每一秒钟都至关重要。KubeArmor
    会监控容器活动中的任何可疑行为，能够在没有事先了解具体漏洞或攻击模式的情况下停止这些活动。
- en: CI/CD pipeline integration
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CI/CD 管道集成
- en: KubeArmor easily integrates into **continuous integration and continuous deployment**
    (**CI/CD**) pipelines. Integrating KubeArmor into your pipelines automates security
    checks through the entire development and deployment lifecycle, delivering a safe
    and secure image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 可以轻松集成到**持续集成和持续部署**（**CI/CD**）管道中。将 KubeArmor 集成到你的管道中可以通过整个开发和部署生命周期自动化安全检查，从而提供一个安全可靠的镜像。
- en: Robust auditing and logging
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强大的审计和日志记录
- en: Logging is very important, and KubeArmor includes comprehensive logs and audit
    trails of container activities. These logs can be used to report compliance, provide
    troubleshooting assistance, and assist in forensic examinations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录非常重要，KubeArmor 包含容器活动的全面日志和审计跟踪。这些日志可用于报告合规性、提供故障排除帮助，并协助进行取证检查。
- en: Enhanced container visibility
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的容器可视化
- en: Visibility into container behavior simplifies identifying and responding to
    security incidents or abnormalities. KubeArmor finds what processes are running
    in the container and what they are accessing and connecting to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对容器行为的可视化简化了识别和应对安全事件或异常的过程。KubeArmor 可以找到容器中正在运行的进程及其访问和连接的内容。
- en: Least privilege tenet adherence
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小权限原则遵循
- en: KubeArmor is based on the least amount of privilege concept, which is a base
    security principle. This ensures that containers possess only the necessary permissions
    and access levels required for their designated functions, consequently curtailing
    the attack surface and constraining potential damage stemming from a compromised
    container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 基于最小权限原则，这是一个基本的安全原则。它确保容器仅拥有其指定功能所需的必要权限和访问级别，从而减少攻击面并限制因容器被攻破而可能带来的损害。
- en: Policy enforcement
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略执行
- en: Policies are at the heart of KubeArmor. They provide administrators with the
    ability to create detailed security policies for containers, fine-tuning the requirements
    for each different, unique workload. Want to block the ability of any container
    executing the SSH daemon? Make a simple policy using KubeArmor and no container
    will be able to execute the SSH daemon.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是 KubeArmor 的核心。它们使管理员能够为容器创建详细的安全策略，精细调整每个不同、独特工作负载的要求。想要阻止任何容器执行 SSH 守护进程？只需使用
    KubeArmor 创建一个简单的策略，任何容器都无法执行 SSH 守护进程。
- en: Staying in compliance
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持合规性
- en: To help you stay in compliance with standards like **CIS**, **NIST-800-53**,
    and **MITRE**, KubeArmor includes policies that will secure your clusters based
    on the defined best standards, all out of the box.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你保持符合 **CIS**、**NIST-800-53** 和 **MITRE** 等标准，KubeArmor 提供了一些策略，基于定义的最佳标准自动保护你的集群，开箱即用。
- en: Policy impact testing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略影响测试
- en: Any policy can be tested before enforcing any settings. This will help you to
    create a policy that will not cause any workloads to have downtime due to a setting
    that may impact a running application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在强制执行任何设置之前，可以先测试任何策略。这将帮助您创建一个不会因可能影响运行中的应用程序的设置而导致工作负载停机的策略。
- en: Multi-tenancy support
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多租户支持
- en: It is common for enterprises to run multi-tenant clusters. With multiple teams
    or applications sharing a Kubernetes cluster, you need to provide a secure environment
    to all of the users, stopping any attacks or effects that a workload in one namespace
    may have on another namespace. KubeArmor provides isolation and security among
    tenants by implementing unique policies at the container level. It’s an important
    tool for securing containerized applications, providing compliance with regulatory
    requirements, and providing a defence against a large spectrum of security threats.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 企业通常会运行多租户集群。在多个团队或应用程序共享同一个 Kubernetes 集群的情况下，您需要为所有用户提供一个安全的环境，防止一个命名空间中的工作负载对另一个命名空间造成攻击或影响。KubeArmor
    通过在容器级别实施独特的策略，为租户之间提供隔离和安全性。它是确保容器化应用程序安全的关键工具，能帮助满足合规要求，并防御各种安全威胁。
- en: Now, let’s talk about how we can deploy KubeArmor in a cluster and how to use
    it to secure our workloads.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下如何在集群中部署 KubeArmor，以及如何使用它来保护我们的工作负载。
- en: Cluster requirements for the exercises
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习的集群要求
- en: As you learned in *Chapter 2*, KinD is a Kubernetes cluster that runs the components
    in containers. This nesting does mean that some add-ons like KubeArmor need to
    have some extra steps to function correctly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 *第 2 章* 中学到的，KinD 是一个在容器中运行组件的 Kubernetes 集群。这种嵌套意味着某些附加组件如 KubeArmor 需要额外的步骤才能正常工作。
- en: For this chapter, we suggest a new cluster. If you have a previous cluster with
    Vault installed already, you should delete that cluster and start over with a
    new one. If you do need to delete an existing cluster, you can execute `kind delete
    cluster --name cluster01` to delete it and then use the scripts to deploy a new
    cluster that includes Vault integration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建议使用新的集群。如果您已经有一个安装了 Vault 的旧集群，您应该删除该集群并从新集群开始。如果确实需要删除现有集群，您可以执行 `kind delete
    cluster --name cluster01` 来删除它，然后使用脚本部署一个包含 Vault 集成的新集群。
- en: To make it easier to deploy, we have included all the required scripts in the
    `chapter13/cluster` directory. To deploy a new cluster, execute `create-cluster.sh`
    in the `cluster` directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化部署，我们在 `chapter13/cluster` 目录中包含了所有必需的脚本。要部署一个新集群，请在 `cluster` 目录中执行 `create-cluster.sh`。
- en: We also need Vault for one of the examples. If you want to run the example,
    you will need to add Vault to your cluster. We have provided an automated Vault
    deployment in the `chapter13/vault` directory called `deploy-vault.sh`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要 Vault 来运行其中一个示例。如果您希望运行该示例，您需要将 Vault 添加到您的集群中。我们在 `chapter13/vault` 目录中提供了一个自动化的
    Vault 部署脚本，名为 `deploy-vault.sh`。
- en: Once both have been executed, you will have a brand-new cluster integrated with
    Vault. It will take time for Vault to deploy fully, so please wait until all of
    the pods have been created to move on to deploying KubeArmor in the cluster.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两个操作都执行完成，您将拥有一个全新集成了 Vault 的集群。Vault 完全部署需要一些时间，请等待所有 Pod 创建完成后再继续在集群中部署
    KubeArmor。
- en: Deploying KubeArmor
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 KubeArmor
- en: 'Before we can use KubeArmor on our KinD cluster, we will need to patch Calico
    and the kubearmor-relay deployment to work with KinD. AppArmor requires some changes
    for certain workloads to deploy and run correctly in a KinD cluster. In a standard
    cluster, these patches would not be required: and once they are deployed, KubeArmor
    will work as it would on a standard Kubernetes cluster.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在 KinD 集群中使用 KubeArmor 之前，我们需要对 Calico 和 kubearmor-relay 部署进行补丁，以便它们能与
    KinD 一起工作。AppArmor 需要对某些工作负载进行一些修改，才能在 KinD 集群中正确部署和运行。在标准集群中，这些补丁是不需要的：一旦部署完成，KubeArmor
    就能像在标准 Kubernetes 集群中一样工作。
- en: KubeArmor can be easily deployed using a single binary, called karmor, or via
    Helm charts. For the book exercises, we will use the karmor utility to install
    KubeArmor. Both deployment methods offer the same protection and configuration
    options, and once deployed, you interact with KubeArmor the same way, regardless
    of the deployment method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 可以通过一个名为 karmor 的单一二进制文件或通过 Helm charts 轻松部署。对于本书中的练习，我们将使用 karmor
    工具来安装 KubeArmor。两种部署方法提供相同的保护和配置选项，一旦部署完成，您与 KubeArmor 的交互方式是相同的，无论采用哪种部署方式。
- en: We have included a script in the `chapter13` folder called `kubearmor-patch.sh`
    that will download karmor, patch Calico and the kubearmor-relay deployments, and
    deploy KubeArmor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chapter13`文件夹中包含了一个名为`kubearmor-patch.sh`的脚本，它将下载karmor，修补Calico和kubearmor-relay部署，并部署KubeArmor。
- en: KubeArmor installs on most Kubernetes clusters without any issues. Since we
    are using a cluster built on KinD, we need to make a few tweaks to allow AppArmor
    to work as expected. The scripts do this work for you. The majority of the fixes
    are to add an annotation to a few deployments, like the Calico Typha controller
    to unconfined mode. We will discuss the patched deployments and what unconfined
    provides in this section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor能够在大多数Kubernetes集群中顺利安装。由于我们使用的是基于KinD构建的集群，因此我们需要做一些调整，以确保AppArmor能够按预期工作。这些调整由脚本自动完成。大部分修复工作是为一些部署（如Calico
    Typha控制器）添加注解，以便它们进入未受限模式。我们将在本节中讨论这些修补部署以及未受限模式的功能。
- en: The script downloads karmor and moves it to the `/usr/local/bin` directory on
    the host. This is the utility that we will use to install KubeArmor and interact
    with it once it has been deployed in the cluster.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本下载karmor并将其移动到主机的`/usr/local/bin`目录。这个工具将用于安装KubeArmor并在它部署到集群后与其交互。
- en: 'Since KubeArmor leverages LSMs, all nodes require an installed LSM, like AppArmor,
    for KubeArmor to function. On most Ubuntu deployments, AppArmor is already deployed,
    but since our Kubernetes cluster is running containerized, AppArmor is not included
    in the image. To resolve this, we need to add AppArmor to our nodes: the script
    takes care of this by executing `docker exec` in each container that updates the
    apt repositories, installs AppArmor, and restarts containerd.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于KubeArmor依赖LSM（Linux安全模块），所有节点都需要安装LSM，如AppArmor，以使KubeArmor正常运行。在大多数Ubuntu部署中，AppArmor已经部署，但由于我们的Kubernetes集群是容器化运行的，镜像中并未包含AppArmor。为了解决这个问题，我们需要将AppArmor添加到我们的节点中：脚本通过在每个容器中执行`docker
    exec`来更新apt源、安装AppArmor并重启containerd，完成这一过程。
- en: The next step in the script will patch the `calico-typha` deployment with an
    `AppArmor` policy that is unconfined. Running policies as unconfined means they
    don’t have an AppArmor profile assigned to them, or they are assigned a profile
    that does not impose any significant restrictions. This allows the process to
    operate with the standard Linux discretionary access controls, without additional
    restrictions from AppArmor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一步将使用一个未受限的`AppArmor`策略来修补`calico-typha`部署。以未受限模式运行策略意味着这些策略没有分配AppArmor配置文件，或者分配了一个不会施加任何重大限制的配置文件。这允许进程在标准Linux自由访问控制下运行，而不会受到AppArmor的附加限制。
- en: As we mentioned previously, you wouldn’t need these patch deployments in a standard
    Kubernetes cluster, but since we are using KinD, we need to patch `calico-typha`
    to work correctly with KubeArmor running in our KinD cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，标准的Kubernetes集群中不需要这些修补部署，但由于我们使用的是KinD，我们需要修补`calico-typha`以便它能与在KinD集群中运行的KubeArmor正常配合使用。
- en: 'With all the requirements and changes deployed, the script continues to install
    KubeArmor using karmor install. This will take a few minutes to deploy all the
    components and, during the deployment, you will see each step that karmor is executing:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署所有要求和变更后，脚本将继续使用karmor install安装KubeArmor。这个过程需要几分钟来部署所有组件，并且在部署过程中，您将看到karmor正在执行的每一步操作：
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will see that the installer creates a number of Kubernetes resources, including
    CRDs, a ServiceAccount, RBAC, Services, and Deployments. Once all resources have
    been created, it will verify the deployment was successful by telling you that
    `Your Cluster is Armored Up!`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到安装程序创建了许多Kubernetes资源，包括CRD、ServiceAccount、RBAC、服务和部署。所有资源创建完成后，它将通过告诉您“`Your
    Cluster is Armored Up!`”来验证部署是否成功。
- en: 'After a successful deployment, you will have additional pods running in the
    `kubearmor` namespace, the controller, the relay, and a `kubearmor` pod, one for
    each of your nodes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 成功部署后，您将在`kubearmor`命名空间中运行额外的Pods，包括控制器、转发器以及每个节点一个`kubearmor` Pod：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also deploy KubeArmor using Helm charts. If you want to know more about
    deploying KubeArmor with Helm, read more about it in KubeArmor’s Git repository
    at [https://github.com/kubearmor/KubeArmor/blob/main/getting-started/deployment_guide.md](https://github.com/kubearmor/KubeArmor/blob/main/getting-started/deployment_guide.md).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用Helm charts部署KubeArmor。如果您想了解更多关于如何使用Helm部署KubeArmor的内容，可以在KubeArmor的Git仓库中阅读[https://github.com/kubearmor/KubeArmor/blob/main/getting-started/deployment_guide.md](https://github.com/kubearmor/KubeArmor/blob/main/getting-started/deployment_guide.md)。
- en: 'Each of the pods has a specific function that is explained below:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Pod 都有一个特定的功能，具体说明如下：
- en: '**kubearmor**: A daemonset that deploys the `kubearmor` pod on each node in
    the cluster. It is a non-privileged DaemonSet with capabilities that allow it
    to monitor pods and containers and the host.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubearmor**：一个 DaemonSet，在集群的每个节点上部署 `kubearmor` Pod。它是一个非特权的 DaemonSet，具有能够监控
    Pod、容器以及主机的能力。'
- en: '**kubearmor-relay**: KubeArmor’s relay server collects all messages, alerts,
    and system logs generated by KubeArmor in each node, and then it allows other
    logging systems to simply collect those through the service of the relay server.
    The relay server plays a critical role in ensuring efficient and centralized security
    monitoring and data collection within Kubernetes environments, making it easier
    for organizations to maintain robust security postures in their containerized
    infrastructures.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubearmor-relay**：KubeArmor 的中继服务器收集 KubeArmor 在每个节点生成的所有消息、警报和系统日志，然后它允许其他日志系统通过中继服务器的服务轻松收集这些数据。中继服务器在确保
    Kubernetes 环境中高效且集中化的安全监控与数据收集中发挥着关键作用，使得组织能够在其容器化基础设施中保持强大的安全态势。'
- en: '**kubearmor-controller**: Admission controller for KubeArmor policy management,
    including policy management, distribution, synchronization, and logging.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubearmor-controller**：KubeArmor 策略管理的准入控制器，包括策略管理、分发、同步和日志记录。'
- en: For the chapter, we’ve opted for the karmor binary installation due to its ease
    of use, making it a convenient choice for deploying KubeArmor quickly. Additionally,
    we need the same karmor binary for the exercises throughout the chapter. This
    approach not only simplifies the learning process but also underscores the versatility
    and practicality of the karmor tool in managing KubeArmor deployments and operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们选择了 karmor 二进制安装，因为它易于使用，成为快速部署 KubeArmor 的便捷选择。此外，接下来的练习中，我们也需要使用相同的 karmor
    二进制文件。这个方法不仅简化了学习过程，还突出了 karmor 工具在管理 KubeArmor 部署和操作中的多功能性和实用性。
- en: Now that we have KubeArmor deployed, we will discuss configuring logging before
    we start to create policies to secure our cluster.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经部署了 KubeArmor，接下来我们将在开始创建安全集群策略之前讨论如何配置日志记录。
- en: Enabling KubeArmor logging
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 KubeArmor 日志记录
- en: By default, KubeArmor is not enabled to log events or alerts to `STDOUT`. Later
    in the chapter, we will go over how to watch logging events in the console interactively,
    which is useful for troubleshooting issues with policies in real time, but it
    is not an efficient way to log a history of policy events.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，KubeArmor 不启用将事件或警报记录到 `STDOUT`。在本章的后续部分，我们将介绍如何在控制台中交互式地查看日志事件，这对于实时故障排除策略问题非常有用，但它并不是一种高效的历史事件日志记录方式。
- en: Most logging solutions made for Kubernetes will pick up logged events from `STDOUT`
    and `STDERROR`. By enabling KubeArmor’s logging options, you will have a history
    of events in your standard logging solution. Using these events, you can create
    alerts and produce a history of changes and events when a security audit occurs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数为 Kubernetes 设计的日志解决方案会从 `STDOUT` 和 `STDERROR` 中获取日志事件。通过启用 KubeArmor 的日志选项，你将能够在标准日志解决方案中拥有事件历史记录。使用这些事件，你可以创建警报并在进行安全审计时生成变更和事件的历史记录。
- en: 'KubeArmor offers three events that can be logged:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 提供三种可以记录的事件：
- en: '**Alert**: When a policy is violated, an event will be logged with information
    including the action, policy name, pod name, namespace, and more'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：当策略被违反时，将记录一条事件，包含的内容有操作、策略名称、Pod 名称、命名空间等信息。'
- en: '**Log**: Creates a log event when a pod executes a syscall, file access, process
    creation, network socket events, etc'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：当 Pod 执行系统调用、文件访问、进程创建、网络套接字事件等时，会生成一条日志事件。'
- en: '**Message**: Creates log entries generated by the KubeArmor daemon'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：由 KubeArmor 守护进程生成的日志条目。'
- en: 'The process to enable logging is different between deployments of KubeArmor.
    We used the karmor executable to deploy, so we need to edit the deployment, adding
    two environment variables: one for standard logging, `ENABLE_STDOUT_LOGS`, and
    one for alerts, `ENABLE_STDOUT_ALERTS`. Both of these require a value of true
    to be enabled. To enable logging, we need to edit or patch the deployment of the
    relay server. This has already been done by our included script that deployed
    KubeArmor. The script will use a standard YAML file to patch the deployment. The
    patching file is shown below:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 启用日志记录的过程在 KubeArmor 的不同部署中有所不同。我们使用了 karmor 可执行文件进行部署，因此我们需要编辑部署，添加两个环境变量：一个用于标准日志记录，`ENABLE_STDOUT_LOGS`，另一个用于警报，`ENABLE_STDOUT_ALERTS`。这两个变量都需要设置为
    true 才能启用。为了启用日志记录，我们需要编辑或修补 relay server 的部署。这已通过我们包含的部署 KubeArmor 的脚本完成。该脚本将使用标准的
    YAML 文件来修补部署。下面显示了修补文件：
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, using the patch file, the `script` executes a `kubectl patch` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用补丁文件，`script` 执行 `kubectl patch` 命令：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once patched, all of the enabled logs will be shown in the relay-server pod
    logs. An example of an event is shown below:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦修补完毕，所有启用的日志将显示在 relay-server pod 的日志中。下面显示了一个事件的示例：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From the example log entry, you can see that the information for the event
    contains everything that you need to know for the activity. It includes a review
    of the activity including:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例日志条目中，你可以看到事件的信息包含了你需要了解的所有活动内容。它包括对活动的回顾，包括：
- en: The source namespace
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源命名空间
- en: The Kubernetes host
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 主机
- en: Pod name
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 名称
- en: Process name
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程名称
- en: The violated policy name
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被违反的策略名称
- en: Operation
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: The resource that was acted on
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被操作的资源
- en: The results of the action, allowed or denied
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作的结果，是允许还是拒绝
- en: By itself, this may not include additional information that you need to know
    the full activity from end to end. For example, it doesn’t include the user of
    the initial activity. Like many events in Kubernetes, you need to correlate events
    from multiple log files to create the full story of the executed activity. In
    this example, you would need to correlate the activity from the event that audited
    the initial `kubectl exec` command with the pod and time of the runtime violation
    that KubeArmor logged.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这可能没有包含你需要了解的完整活动信息。比如，它没有包括初始活动的用户。像 Kubernetes 中的许多事件一样，你需要关联来自多个日志文件的事件，以创建活动的完整过程。在此示例中，你需要将审核初始
    `kubectl exec` 命令的事件与 KubeArmor 记录的运行时违反事件的 Pod 和时间进行关联。
- en: At this point, we have KubeArmor configured, and we can get into creating and
    testing policies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已配置 KubeArmor，并且可以开始创建和测试策略。
- en: KubeArmor and LSM policies
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KubeArmor 和 LSM 策略
- en: As we mentioned, KubeArmor is a tool that helps you create policies for Linux
    LSMs. Since it creates standard LSMs, any policy that you create and deploy will
    be stored on the node(s) where the OS stores LSM policies. Since we are using
    KinD, the nodes are running Ubuntu, which uses AppArmor as the LSM. AppArmor policies
    are stored in the `/etc/apparmor.d` directory on the host.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，KubeArmor 是一个帮助你为 Linux LSM 创建策略的工具。由于它创建标准的 LSM，任何你创建并部署的策略都会存储在节点上，存储位置与操作系统存储
    LSM 策略的地方一致。由于我们使用的是 KinD，节点运行的是 Ubuntu 操作系统，而 Ubuntu 使用 AppArmor 作为 LSM。AppArmor
    策略存储在主机的 `/etc/apparmor.d` 目录下。
- en: 'The output below shows an example directory from a node that has had a few
    KubeArmor policies created:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了一个节点的示例目录，该节点已创建了一些 KubeArmor 策略：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you looked at any of the policies, you would see a standard AppArmor formatted
    policy. We aren’t going to go into the details of creating an AppArmor policy,
    but the output below shows an example of a policy created by KubeArmor:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看过任何策略，你会看到一个标准的 AppArmor 格式的策略。我们不会详细介绍如何创建 AppArmor 策略，但下面的输出展示了 KubeArmor
    创建的一个策略示例：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s possible that your nodes may have policies that were not created using
    KubeArmor. In order to know what policies were created and managed by KubeArmor
    and what policies were not, you need to look at the first line of the policy.
    If the policy was created by KubeArmor, it will start with `## == Managed by KubeArmor
    == ##`, and policies that do not start with this line were not created by KubeArmor.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '你的节点可能有些策略并非通过 KubeArmor 创建。为了知道哪些策略是由 KubeArmor 创建和管理的，哪些不是，你需要查看策略的第一行。如果策略是由
    KubeArmor 创建的，它将以 `## == Managed by KubeArmor == ##` 开头，而没有以此行开头的策略不是由 KubeArmor
    创建的。'
- en: Now let’s move on to the next section, on creating a `KubeArmorSecurityPolicy`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入下一部分，创建 `KubeArmorSecurityPolicy`。
- en: Creating a KubeArmorSecurityPolicy
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 KubeArmorSecurityPolicy
- en: It’s time to create some policies! When KubeArmor is deployed, it creates three
    Custom Resource Definitions and one of those is `kubearmorpolicies.security.kubearmor.com`,
    which is used to create new policy resources.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一些策略了！当 KubeArmor 部署时，它会创建三个自定义资源定义，其中之一是 `kubearmorpolicies.security.kubearmor.com`，用于创建新的策略资源。
- en: Let’s jump right into an example policy. You do not need to deploy this to your
    cluster; it’s being used to show an example policy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入一个示例策略。您无需将其部署到集群中；它仅用于展示一个示例策略。
- en: 'If we want to block any attempted access to create a file in the `/bin` directory
    of our containers in the `demo` namespace, the format of this policy is shown
    below:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要阻止任何尝试在 `demo` 命名空间的容器中的 `/bin` 目录下创建文件的操作，下面是该策略的格式：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Breaking down this policy, we can see that it’s using the `security.kubearmor.com/v1`
    API and it’s a KubeArmorPolicy type. The metadata section has common options,
    naming the object `block-write-bin` in the `demo` namespace.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 分析这个策略，我们可以看到它使用了 `security.kubearmor.com/v1` API，并且是一个 KubeArmorPolicy 类型。元数据部分包含常见选项，将对象命名为
    `block-write-bin`，并位于 `demo` 命名空间中。
- en: 'The `spec` section is where we actually start to create a new policy. There
    are a number of options available to you for creating policies. You can learn
    about all of the options on the KubeArmor website: [https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification](https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分是我们实际开始创建新策略的地方。您可以使用许多选项来创建策略。有关所有选项的详细信息，您可以访问 KubeArmor 网站：[https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification](https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification)。'
- en: 'The action `spec` allows you to define what the policy enforces. The options
    are `Block`, `Allow`, and `Audit`: each of the options is described in the table
    below.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分允许您定义策略所执行的操作。选项包括 `Block`、`Allow` 和 `Audit`，每个选项的描述见下表。'
- en: '| **Available Action** | **Description** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **可用操作** | **描述** |'
- en: '| `Block` | Tells KubeArmor to block the actions that are included in the policy
    (default if no action is provided) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `Block` | 告诉 KubeArmor 阻止策略中包含的操作（如果未提供操作，默认为此） |'
- en: '| `Allow` | Tells KubeArmor to allow the actions that are included in the policy
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `Allow` | 告诉 KubeArmor 允许策略中包含的操作 |'
- en: '| `Audit` | Tells KubeArmor to only audit the actions of the policy. The actions
    on the policy will be allowed, but in our example, we would receive a logged event
    when someone creates a file under the `/bin` directory. This is handy for testing
    how a policy will affect a workload in the cluster. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `Audit` | 告诉 KubeArmor 只审计策略的操作。策略中的操作将被允许，但在我们的示例中，当有人在 `/bin` 目录下创建文件时，我们会收到一个已记录的事件。这对于测试策略如何影响集群中的工作负载非常有用。
    |'
- en: 'Table 13.1: Available actions for policies'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 13.1：可用的策略操作
- en: KubeArmor operates on the principle of enforcing the least permissive access.
    When you specify the allow action in a policy, it generates an allow list that
    permits access exclusively to the object(s) specified within the policy. For instance,
    if you were to establish an `allow` policy for a file named `demo/allowed-file`,
    any process within the container would have permission to access that particular
    file. All other files accessed within the container would trigger an audit event
    because they do not belong to the allowed list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 的操作原则是实施最小权限访问。当您在策略中指定允许操作时，它会生成一个允许列表，只允许访问策略中指定的对象。例如，如果您为名为 `demo/allowed-file`
    的文件建立一个 `allow` 策略，容器内的任何进程都将获得访问该文件的权限。容器内访问的所有其他文件都会触发审计事件，因为它们不属于允许列表。
- en: You might be questioning the example, where if you set up an allow policy and
    someone tries to read a different file, it won’t reject the request but will instead
    log the access for auditing purposes. The default security posture, within an
    allow policy, pertains to how it manages access attempts not listed in the allowed
    entries. By default, KubeArmor’s security posture is set to audit mode.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会对示例中的情况提出疑问：如果您设置了一个允许策略，而某人尝试读取另一个文件，它不会拒绝请求，而是会记录访问日志以供审计。允许策略中的默认安全态度与它如何管理未列在允许条目中的访问尝试有关。默认情况下，KubeArmor
    的安全态度设置为审计模式。
- en: It’s crucial to bear in mind that when you establish an allow policy, any access
    requests that would typically be denied will not face denial; instead, they will
    merely trigger an audit alert. As a result, if you configure an allow rule to
    restrict access to a specific file, all other files will remain accessible.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别注意的是，当你建立一个允许策略时，任何通常会被拒绝的访问请求将不会被拒绝；相反，它们只会触发审计警报。因此，如果你配置了一个允许规则来限制对特定文件的访问，所有其他文件仍然可以访问。
- en: 'The default posture behavior can be changed at the global level or on a per
    namespace level. To make the global default posture block, instead of audit, you
    need to edit the KubeArmor config, which is stored in a ConfigMap called `kubearmor-config`
    in the `kubearmor` namespace. In the config, you can set the default security
    posture for each option, file, network, and capabilities:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的姿态行为可以在全局级别或每个命名空间级别进行更改。要使全局默认姿态为阻止（block），而非审计（audit），你需要编辑 KubeArmor 配置，该配置存储在
    `kubearmor` 命名空间中的名为 `kubearmor-config` 的 ConfigMap 中。在该配置中，你可以为每个选项、文件、网络和能力设置默认的安全姿态：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Depending on your cluster configuration and the logic design of a cluster,
    you may want to change the default posture on specific namespaces. To set the
    policy on a namespace, you need to add an annotation of `kubearmor-file-posture=<value>`.
    If we wanted to add a policy to an existing demo namespace, we would just need
    to run `kubectl annotate`, as shown below:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的集群配置和集群的逻辑设计，你可能希望在特定命名空间中更改默认姿态。要在命名空间上设置策略，你需要添加一个注释 `kubearmor-file-posture=<value>`。如果我们想为现有的
    demo 命名空间添加策略，我们只需要运行 `kubectl annotate`，如下所示：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you were creating a new namespace using a manifest, you would just add the
    annotation to the manifest before applying the file to create the namespace.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是通过清单创建新的命名空间，只需在应用文件创建命名空间之前，将注释添加到清单中即可。
- en: After defining the policy action, we need to add what objects we want to block,
    allow, or audit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义完策略行为后，我们需要添加希望阻止、允许或审计的对象。
- en: 'There are four objects that we can create policies for. They are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为四个对象创建策略。它们是：
- en: Process
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程
- en: File
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Network
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Capabilities
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能力
- en: The KubeArmor website has documentation on the policies and options located
    at [https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification](https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification).
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: KubeArmor 网站提供了有关策略和选项的文档，位于 [https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification](https://docs.kubearmor.io/kubearmor/documentation/security_policy_specification)。
- en: In our example, our goal is to prevent any form of write access within the `/bin`
    directory. To achieve this, we will utilize the `file` object. Following the object
    declaration, you specify a `match` condition that will trigger the policy action.
    In this instance, we’ve configured the `matchDirectories` action specifically
    for the `/bin` directory, indicating to KubeArmor that the policy’s evaluation
    should only occur if the action is within that directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们的目标是阻止对 `/bin` 目录的任何写入访问。为此，我们将使用 `file` 对象。在声明对象后，你需要指定一个 `match`
    条件，该条件会触发策略行为。在此实例中，我们已将 `matchDirectories` 行为专门配置为 `/bin` 目录，这表示只有当操作发生在该目录下时，KubeArmor
    才会评估该策略。
- en: Continuing, there are optional settings for `readOnly` and `recursive`. In our
    scenario, we have enabled both. When `readOnly` is set to true, it permits the
    reading of any file located under `/bin`, but any other actions will be denied.
    Enabling the `recursive` option instructs KubeArmor to assess both the `/bin`
    directory and all of its subdirectories.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，还有可选的 `readOnly` 和 `recursive` 设置。在我们的场景中，我们已启用这两个选项。当 `readOnly` 设置为 true
    时，它允许读取位于 `/bin` 下的任何文件，但其他任何操作都会被拒绝。启用 `recursive` 选项会指示 KubeArmor 评估 `/bin`
    目录及其所有子目录。
- en: Finally, you can define the message option, which will add a custom message
    in the KubeArmor logs when the policy has been triggered. In our example, we added
    the message option to add “**Alert! An attempt to write to the /bin directory
    denied.**” when an attempt is made to do anything other than read a file under
    the directory.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以定义消息选项，这将在策略触发时在 KubeArmor 日志中添加自定义消息。在我们的示例中，我们添加了消息选项，当尝试进行除读取 `/bin`
    目录下的文件外的任何操作时，会显示“**警告！尝试写入 /bin 目录被拒绝。**”的消息。
- en: You may be wondering about the allow action and how we said it creates an allow
    list, allowing only access to the objects in the policy, and denying access to
    every other file in the container. The example of a single file isn’t a great
    example for the real world, but it does explain what you granted access to and
    what was denied by allow policies. An allow policy will lock down a container
    tightly when used correctly. When used incorrectly, your application would likely
    crash, being denied access to a file not in the allowed list. You can imagine
    that creating an allow list for an app could require a large number of objects,
    many of which would be a challenge to find on your own.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对允许操作感到好奇，我们之前说它会创建一个允许列表，只允许访问政策中的对象，拒绝访问容器中的其他文件。单个文件的示例在实际应用中并不是一个很好的例子，但它确实解释了你授予了什么访问权限，以及哪些权限被允许政策拒绝。当允许政策正确使用时，它会紧密地锁定容器。而如果使用不当，你的应用可能会崩溃，因为被拒绝访问不在允许列表中的文件。你可以想象，为一个应用创建一个允许列表可能需要大量对象，而很多对象你可能很难自己找到。
- en: Let’s use a real-world example policy to close out this section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个实际的示例政策来结束这一节。
- en: Foowidgets want to secure their secrets. They have created a policy that all
    secrets must be stored in an external secret manager like Vault. As we discussed
    in the secrets chapter, you can read your secret in from Vault without having
    a base64-encoded secret in the namespace. A lot of people assume this secures
    your secret, but they overlook that someone will be able to exec into the container
    and read most files, including files that store secrets.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Foowidgets 希望保护他们的机密信息。他们已经制定了一项政策，要求所有机密信息必须存储在外部机密管理器中，如 Vault。正如我们在机密章节中讨论的那样，你可以从
    Vault 中读取机密信息，而不需要在命名空间中存储 base64 编码的机密。很多人认为这可以保护机密信息，但他们忽略了一个问题，那就是任何人都可以进入容器并读取大多数文件，包括存储机密信息的文件。
- en: How do we enhance the security of our secrets, even using an external secrets
    manager like Vault? The answer is KubeArmor!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何增强机密信息的安全性，即使使用像 Vault 这样的外部机密管理器？答案就是 KubeArmor！
- en: We can address Foowidgets’ requirement by creating a policy that will allow
    only the required running process access to the file that contains the secret,
    while any other process will be denied.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过制定一项政策来解决 Foowidgets 的需求，允许只有必要的运行进程访问包含机密信息的文件，而其他进程则被拒绝访问。
- en: In the `chapter13/nginx-secrets` directory, there is a script called `create-nginx-vault.sh`,
    which will create an NGNIX webserver that will display a secret file and the contents
    when you open a webpage path, `/secrets/myenv`. The secret that is shown on the
    page is pulled down from Vault and mounted in the pod using a volume at `/etc/secrets/myenv`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chapter13/nginx-secrets` 目录中，有一个名为 `create-nginx-vault.sh` 的脚本，它将创建一个 NGNIX
    web 服务器，当你打开网页路径 `/secrets/myenv` 时，会显示一个机密文件及其内容。页面上显示的机密信息是从 Vault 拉取的，并通过 `/etc/secrets/myenv`
    这个卷挂载到 pod 中。
- en: 'When you execute the script, the last line will show you the **nip.io** URL
    for the webserver. Open the URL in any browser, or curl the `http://secret.<nip.io>/secrets/myenv`
    URL to prove that the secret shows in the output. You should see output similar
    to the below:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行脚本时，最后一行会显示 **nip.io** 的 URL 用于 web 服务器。你可以在任意浏览器中打开该 URL，或者使用 curl 请求 `http://secret.<nip.io>/secrets/myenv`
    来验证机密信息是否出现在输出中。你应该会看到类似于以下的输出：
- en: '![](img/B21165_13_05.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_05.png)'
- en: 'Figure 13.5: NGINX showing contents of secret file'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：NGINX 显示机密文件内容
- en: 'Verifying that the container is working as expected, we can `exec` into the
    container and attempt to read the secret file using `cat`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证容器是否按预期工作，我们可以使用 `exec` 进入容器并尝试使用 `cat` 阅读机密文件：
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The secret is mounted in the pod at `/etc/secrets` in the `myenv` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 机密信息已在 `/etc/secrets` 目录下的 `myenv` 文件中挂载到 pod 中：
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will output the contents of the file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出文件的内容：
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hold on! I thought that employing an external secret manager would ensure the
    security of Kubernetes secrets. Although it may not store the data in an easily
    discoverable `Secret` within the namespace, an individual with container execution
    access can still retrieve the secret.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我以为使用外部机密管理器就能确保 Kubernetes 的机密信息安全。尽管它可能不会将数据存储在命名空间中容易发现的 `Secret` 中，但拥有容器执行访问权限的人仍然可以获取机密信息。
- en: This issue is one of the shortcomings of systems like Vault; simply using Vault
    doesn’t necessarily guarantee the security of the secret.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是像 Vault 这样的系统的一个缺点；仅仅使用 Vault 并不一定能确保机密信息的安全。
- en: To illustrate this with a real-world scenario, let’s consider a requirement
    by our company, Foowidgets. They want to restrict secret access exclusively to
    the processes that require access to the secret. This can be accomplished by creating
    a new KubeArmor policy that permits only the application to access the file containing
    the secret. In our example container, we intend to grant the NGINX process permission
    to read the secret file while preventing other processes from doing so.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过实际场景说明这一点，我们来考虑一下我们公司Foowidgets的需求。他们希望将秘密访问限制为仅限那些需要访问秘密的进程。这可以通过创建一个新的KubeArmor策略来实现，只允许应用程序访问包含秘密的文件。在我们的示例容器中，我们打算授予NGINX进程读取秘密文件的权限，同时阻止其他进程访问该文件。
- en: 'To accomplish this, we have created an example policy file called `nginx-secrets-block.yaml`.
    This will deploy into the `my-ext-secret` namespace:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们创建了一个名为`nginx-secrets-block.yaml`的示例策略文件。该文件将部署到`my-ext-secret`命名空间：
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To show the policy in action, we have included a script called `redeploy-nginx-vault.sh`
    in the `chapter13/nginx-secrets` directory, which will delete the previous NGINX
    deployment and then create a new deployment with the KubeArmor policy to secure
    the Vault secret used by NGINX.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示策略的实际效果，我们在`chapter13/nginx-secrets`目录中包含了一个名为`redeploy-nginx-vault.sh`的脚本，该脚本将删除先前的NGINX部署，然后创建一个带有KubeArmor策略的新部署，以保护NGINX使用的Vault秘密。
- en: Execute the script and wait until the new deployment and policy have been created.
    It’s important that we confirm that the outcome is what we expect from the new
    policy. To verify the policy, we will attempt to access the secret by executing
    `kubectl exec -it nginx-secrets -n my-ext-secret -- bash` to enter the pod.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该脚本并等待新的部署和策略创建完成。我们需要确认最终结果符合我们对新策略的预期。为了验证策略，我们将通过执行`kubectl exec -it nginx-secrets
    -n my-ext-secret -- bash`进入pod，尝试访问秘密。
- en: 'Once in the pod, we can attempt to view the secret by using `cat`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 进入pod后，我们可以尝试使用`cat`查看秘密：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’ll notice that access to the file is no longer allowed. KubeArmor will
    intercept the request and, based on the policy, refuse access to the `/etc/secrets/myenv`
    file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，访问该文件已经被阻止。KubeArmor会拦截请求，并根据策略拒绝访问`/etc/secrets/myenv`文件：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take note that even though you have root privileges within the container, you
    can’t access the `myenv` file in the `/etc/secrets` directory. The policy blocks
    any access not explicitly allowed to the directory or its files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管您在容器内拥有root权限，但无法访问`/etc/secrets`目录中的`myenv`文件。该策略阻止了任何未明确允许的对该目录或文件的访问。
- en: So far, everything seems to be going well. However, now we must verify the website
    to ensure that the secret information still appears. If the site displays the
    same content as before implementing our policy, it demonstrates that the secret
    is allowed to be read by the NGINX binary. To verify this, navigate to the same
    URL you previously used to test the site, either by browsing or using the `curl`
    command. If you still have the same browser window open, simply refresh it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切似乎都进展顺利。然而，我们现在必须验证网站，确保秘密信息仍然存在。如果网站显示与实施我们策略之前相同的内容，说明NGINX二进制文件允许读取该秘密。为了验证这一点，导航到您之前用来测试该网站的相同URL，无论是通过浏览器还是使用`curl`命令。如果您仍然保持同一个浏览器窗口打开，只需刷新它即可。
- en: 'The screenshot below verifies that the website is functioning correctly and
    continues to display the value stored in the `myenv` file in the `/etc/secrets`
    directory. This confirms that the NGINX binary has the necessary access to the
    secret file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图验证了网站正常运行，并继续显示`/etc/secrets`目录下`myenv`文件中存储的值。这确认了NGINX二进制文件具有访问秘密文件所需的权限：
- en: '![](img/B21165_13_06.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_06.png)'
- en: 'Figure 13.6: NGINX can still read secret'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：NGINX仍然可以读取秘密
- en: KubeArmor simplifies the creation of LSM policies for both developers and operators.
    The potential applications are endless, granting you the capability to enhance
    the security of workloads down to the granularity of individual files or processes.
    Now that we’ve covered the process of policy creation, let’s proceed to explore
    the primary tool that you’ll employ to engage with KubeArmor.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor简化了开发人员和运维人员创建LSM策略的过程。其潜在应用几乎是无限的，使您能够增强工作负载的安全性，精确到单个文件或进程的粒度。现在我们已经介绍了策略创建的过程，接下来让我们深入探讨您将用来与KubeArmor交互的主要工具。
- en: Using karmor to interact with KubeArmor
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用karmor与KubeArmor交互
- en: We installed KubeArmor using the karmor utility. Along with installing and uninstalling
    KubeArmor in a cluster, it is used for a number of other actions. The table below
    is an overview of the main options that you should understand. Each one will be
    explained in detail in its own section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 karmor 实用程序安装了 KubeArmor。除了在集群中安装和卸载 KubeArmor 外，它还用于执行许多其他操作。下表是您应该了解的主要选项概述。每个选项将在其各自的章节中详细解释。
- en: '| **Options** | **Description** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `Install` | Installs KubeArmorKubeArmor in a clusterKubeArmor |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `安装` | 在集群中安装 KubeArmorKubeArmor |'
- en: '| `Logs` | Provides an interactive method to view logs, or to send the logs
    to a file |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `日志` | 提供交互查看日志的方法，或将日志发送到文件 |'
- en: '| `Probe` | Lists the support features for the cluster |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `探针` | 列出集群支持的功能特性 |'
- en: '| `profile` | Runs an interactive utility that displays the process, file,
    network, and syscalls that KubeArmor has observed |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `配置文件` | 运行一个交互式实用程序，显示 KubeArmor 观察到的进程、文件、网络和系统调用 |'
- en: '| `recommend` | Creates a directory that contains recommended policies that
    can be deployed in a cluster. This will download additional containers to create
    the recommendations. It could take some time depending on the number and size
    of the running containers. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `推荐` | 创建一个包含推荐策略的目录，可以在集群中部署。这将下载额外的容器来创建推荐内容。根据正在运行的容器数量和大小，可能需要一些时间。 |'
- en: '| `selfupdate` | Updates the `karmor` CLI |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `自更新` | 更新 `karmor` 命令行工具 |'
- en: '| `summary` | Shows observations from the discovery engine |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `摘要` | 显示来自发现引擎的观察结果 |'
- en: '| `sysdump` | Used to collect a system dump to help troubleshooting |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `系统转储` | 用于收集系统转储以帮助故障排除 |'
- en: '| `uninstall` | Uninstalls KubeArmor from the cluster |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `卸载` | 从集群中卸载 KubeArmor |'
- en: '| `version` | Shows the version of the karmor binaryKubeArmor |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `版本` | 显示 karmor 二进制文件的版本KubeArmor |'
- en: '| `Vm` | Used for commands that can be used against VMs that run with `Kubevirt`,
    which runs `kvmservices` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `Vm` | 用于对运行 `Kubevirt` 和 `kvmservices` 的虚拟机执行命令 |'
- en: 'Table 13.2: karmor command options'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.2：karmor 命令选项
- en: The list may make KubeArmor look like it doesn’t have a lot of options, but
    most of the options are incredibly powerful and some will take time to run in
    larger clusters. In the next sections, we will explain the karmor options and
    what they provide to secure your cluster.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可能会让 KubeArmor 看起来选择不多，但大多数选项非常强大，并且在较大的集群中运行某些选项可能需要时间。在接下来的章节中，我们将解释 karmor
    的选项及其提供的安全功能。
- en: karmor install and uninstall
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: karmor 安装和卸载
- en: As you would imagine, the `karmor install` command will deploy KubeArmor into
    the cluster from your current `kubeconfig` file, while the `karmor uninstall`
    command will remove KubeArmor from the cluster.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，`karmor install` 命令将使用当前的 `kubeconfig` 文件将 KubeArmor 部署到集群中，而 `karmor uninstall`
    命令将从集群中移除 KubeArmor。
- en: We do need to call out that `karmor uninstall`, by default, will remove KubeArmor
    from the cluster, but it will leave any LSM policies that were created on the
    hosts in an inactive state. To fully remove KubeArmor from the cluster, including
    all created policies, you need to add the `--force` flag to the `uninstall` command.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，默认情况下 `karmor uninstall` 会从集群中移除 KubeArmor，但会使在主机上创建的所有 LSM 策略处于非活动状态。要完全从集群中移除
    KubeArmor，包括所有创建的策略，您需要在 `uninstall` 命令中加入 `--force` 标志。
- en: karmor probe
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: karmor 探针
- en: The probe option will list the KubeArmor features in the current cluster.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 探针选项将列出当前集群中的 KubeArmor 功能。
- en: When you check for the supported probes, karmor will output information including
    each node and its active LSM and the default posture of each namespace and pod.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检查支持的探针时，karmor 将输出信息，包括每个节点及其活动的 LSM 和每个命名空间和 Pod 的默认姿态。
- en: karmor profile
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: karmor 配置文件
- en: KubeArmor’s profile provides you with an interactive console to view what processes,
    files, network connections, and syscalls are in use. The screen below shows an
    abbreviated output from a probe with the **File** tab selected.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 的配置文件为您提供了一个交互式控制台，用于查看正在使用的进程、文件、网络连接和系统调用。下面的屏幕显示了从选择了 **文件** 选项的探针中的简略输出。
- en: '![](img/B21165_13_07.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_07.png)'
- en: 'Figure 13.7: karmor profile output'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：karmor 配置文件输出
- en: By default, a probe will output information for all namespaces. If you have
    clusters with a lot of namespaces and pods, you can limit the output to a single
    namespace or certain pods.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，探针将输出所有命名空间的信息。如果您有具有大量命名空间和 Pod 的集群，可以将输出限制为单个命名空间或特定的 Pod。
- en: To limit the output to a single namespace, add the option `-n` or `--namespace
    <namespace to prove>`, and to limit the output to just a pod, use `-p` or `--pod
    <pod name to probe>`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要将输出限制为单个命名空间，可以添加选项 `-n` 或 `--namespace <namespace to prove>`，如果只想限制输出到某个 pod，可以使用
    `-p` 或 `--pod <pod name to probe>`。
- en: If you want to see this in action, let’s say that you wanted to watch a new
    namespace called `demo` for activity. You would execute the recommend command
    and add `-n demo`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到实际效果，假设你想监视一个名为 `demo` 的新命名空间的活动。你可以执行 recommend 命令并添加 `-n demo`。
- en: 'On the host, execute the probe command shown below:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，执行下面显示的探针命令：
- en: '[PRE16]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may not see any activity under some tabs. The profile command needs to have
    activity to show and if there is no activity for any of the watched events, they
    will not show any data. You will see a blank list until KubeArmor sees activity
    and creates new entries, as shown in *Figure 13.8*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在某些标签页下看不到任何活动。profile 命令需要有活动才能显示，如果没有任何被监视事件的活动，它们将不会显示任何数据。在 KubeArmor
    看到活动并创建新条目之前，你会看到一个空白列表，如 *图 13.8* 所示。
- en: '![](img/B21165_13_08.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_08.png)'
- en: 'Figure 13.8: KubeArmor’s profile console'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：KubeArmor 的 profile 控制台
- en: Open another connection to the host, so we can create a new NGINX deployment.
    There is a script in the `chapter13/nginx` directory called `ngnix-ingress.sh`
    that will create a new namespace called demo with an NGINX deployment and an ingress
    rule. Execute the script and, at the end, it will show you the ingress URL to
    use.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个连接到主机，以便创建一个新的 NGINX 部署。在 `chapter13/nginx` 目录下有一个名为 `ngnix-ingress.sh`
    的脚本，它将创建一个名为 demo 的命名空间，并部署一个 NGINX 和一个 ingress 规则。执行脚本后，最后它将显示你需要使用的 ingress
    URL。
- en: Now that we have created a deployment, your other terminal should show activity
    in the **Process** tab, as shown in *Figure 13.9*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个部署，你的另一个终端应该会在 **Process** 标签中显示活动，如 *图 13.9* 所示。
- en: '![](img/B21165_13_09.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_09.png)'
- en: 'Figure 13.9: KubeArmor’s profile console'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9：KubeArmor 的 profile 控制台
- en: This will populate events in the **Process** tab as the NGINX pod starts up
    and processes are started. In your other window, you will see the profile update,
    in real time, with the processes that started in the demo namespace.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 NGINX pod 启动并且进程开始运行，这将会在 **Process** 标签中填充事件。在你的另一个窗口中，你将实时看到 profile 更新，并显示在
    demo 命名空间中启动的进程。
- en: KubeArmor’s probe is a powerful tool that provides information that would otherwise
    be very challenging to collect.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor 的探针是一个强大的工具，它提供了通常很难收集的信息。
- en: karmor recommend
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: karmor recommend
- en: The `recommend` command is to provide security policy recommendations based
    on established industry compliance standards and attack frameworks like CIS, MITRE,
    NIST, STIGs, and various others. All of the workloads specified in the recommend
    command will be tested against any policy templates included with KubeArmor.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommend` 命令用于根据已建立的行业合规标准和攻击框架（如CIS、MITRE、NIST、STIG等）提供安全策略推荐。所有在 recommend
    命令中指定的工作负载将会针对 KubeArmor 包含的任何策略模板进行测试。'
- en: '![](img/B21165_13_10.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_10.png)'
- en: 'Figure 13.10: KubeArmor recommend policies'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10：KubeArmor recommend 策略
- en: 'Since each pod and container are evaluated, you have the option to filter the
    execution to target not only the cluster but by namespace, container image, or
    pod. An example output of `karmor recommend` running is shown in *Figure 13.11*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 pod 和容器都会被评估，你可以选择通过命名空间、容器镜像或 pod 来过滤执行，不仅仅是针对集群。以下是运行 `karmor recommend`
    命令的示例输出，如 *图 13.11* 所示：
- en: '![](img/B21165_13_11.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_11.png)'
- en: 'Figure 13.11: karmor recommend output'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11：karmor recommend 输出
- en: 'From the output, you can see that karmor will pull the image for each container
    to test against the policies. All policies that are created by karmor are, by
    default, saved in a directory called out in the current working directory. You
    can change where the policies will be created by adding the `-o` or the `--output`
    switch to the recommend command. Since the recommendations are broken down by
    each action, you may generate a large number of files. To show an example, we
    run a recommend command against our KinD cluster’s `kube-system` namespace, which
    generates the directory structure shown below:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你可以看到 karmor 将为每个容器拉取镜像，以便测试策略。所有由 karmor 创建的策略默认保存在当前工作目录下的一个目录中。你可以通过向
    recommend 命令添加 `-o` 或 `--output` 选项来更改策略的创建位置。由于推荐内容按每个操作分解，你可能会生成大量的文件。举个例子，我们对
    KinD 集群的 `kube-system` 命名空间运行 recommend 命令，它生成了如下所示的目录结构：
- en: '[PRE17]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Along with a directory for each deployment, you will see a `report.txt` file
    that contains all recommended policies for various standards, including NIST,
    MITRE, PCI_DSS, CIS, etc. We will discuss the report and its options in a later
    section. For now, we want to focus on the created policies.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了每个部署的目录，你还会看到一个`report.txt`文件，里面包含了各种标准下所有推荐的策略，包括NIST、MITRE、PCI-DSS、CIS等。我们将在后面的章节讨论报告及其选项。目前，我们希望关注创建的策略。
- en: 'Let’s take a closer look at the first directory in the list, which contains
    policies for the `core-dns` deployment in the `kube-system namespace`. As you
    can see from the output, 16 policies were created by the `recommend` command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下列表中的第一个目录，它包含了`kube-system`命名空间中`core-dns`部署的策略。正如你从输出中看到的，`recommend`命令创建了16个策略：
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you look at the filenames, you can tell what type of action and process
    each policy uses. For example, let’s look at the `registry-k8s-io-coredns-coredns-v1-10-1-write-etc-dir.yaml`
    `policy`. From the filename, we can see that this policy was created to add an
    action to writing in the `/etc` directory. Looking into the file, we will see
    that this policy contains a block action on directories in `/etc` and it also
    locks down `/etc` to a read-only state, for anything that matches the label `k8s-app=kube-dns`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看文件名，你可以判断每个策略使用的是什么类型的操作和过程。例如，让我们看一下`registry-k8s-io-coredns-coredns-v1-10-1-write-etc-dir.yaml`
    `策略`。从文件名中，我们可以看出这个策略是为了在`/etc`目录中添加写操作而创建的。深入查看文件，我们会看到这个策略包含了对`/etc`目录的阻止操作，并且它还将`/etc`锁定为只读状态，适用于任何与标签`k8s-app=kube-dns`匹配的内容。
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are a few added fields in this policy that we haven’t discussed previously,
    namely the severity and the tags. Unlike other tools that may add severity to
    a triggered event, KubeArmor allows you to set your own severity for policies.
    When you create a policy, you can assign it a severity rating from 1 to 10, allowing
    you to create your own rating based on your organizational requirements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个策略中有几个我们之前没有讨论过的字段，分别是严重性和标签。与其他可能将严重性添加到触发事件的工具不同，KubeArmor 允许你为策略设置自己的严重性。当你创建策略时，可以为其分配一个从1到10的严重性评分，允许你根据组织需求创建自己的评分标准。
- en: The tags section was generated by the recommend command. By default, when you
    run a recommendation, it will test all of the objects against all of the included
    hardening policies, including MITRE TTPs, STIGs, NIST, and CIS. The policies that
    are created are based on the standards supplied during the recommendation collection.
    If you don’t specify any policies to check, karmor will create policies for all
    standards, including policies that you may or may not need.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 标签部分是由推荐命令生成的。默认情况下，当你运行推荐时，它会根据所有包含的加固策略（包括MITRE TTP、STIG、NIST和CIS）对所有对象进行测试。创建的策略是基于在推荐收集过程中提供的标准。如果你没有指定任何要检查的策略，Karmor将为所有标准创建策略，包括你可能需要或不需要的策略。
- en: 'Depending on your organization and security requirements, you can limit the
    hardening policies to only the policies that you want to include. This is done
    by adding either the `-t` or `--tag` flags to the recommend command, followed
    by the standard or standards. For example, if we wanted to run a recommend against
    the `kube-system` namespace and only include the CIS and PCI-DSS standards, we
    would execute:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的组织和安全要求，你可以将加固策略限制为仅包含你希望包括的策略。这可以通过在推荐命令中添加`-t`或`--tag`标志来完成，后面跟上标准或标准集。例如，如果我们希望对`kube-system`命名空间执行推荐，并且只包括CIS和PCI-DSS标准，我们可以执行：
- en: '[PRE20]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like all other recommend commands, this will create an `out` directory in the
    working directory with policies and a `report.txt`. If you took a look at the
    report, you would see a list of recommended actions around PCI-DSS and CIS standards
    for each pod. The figure below is an abbreviated example of a `report.txt` from
    the recommend command we ran against `kube-system`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有其他推荐命令一样，这个命令会在工作目录中创建一个`out`目录，里面包含策略和一个`report.txt`文件。如果你查看报告，你会看到针对每个
    Pod 在 PCI-DSS 和 CIS 标准下的推荐操作列表。下面的图是我们对`kube-system`运行推荐命令时生成的`report.txt`的简化示例。
- en: '![](img/B21165_13_12.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_13_12.png)'
- en: 'Figure 13.12: Recommend example for NIST and CIS'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：NIST和CIS的推荐示例
- en: Since we added tags to our command, karmor only created policies that are required
    to meet the standards for NIST and CIS. This will create fewer policies than running
    without any tags since it will only generate policies based on the specified tags
    versus all standards if you do not supply a tag.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在命令中添加了标签，karmor 只会创建满足 NIST 和 CIS 标准所需的策略。这将比没有标签的运行生成更少的策略，因为它将仅基于指定的标签生成策略，而不是所有标准（如果您未提供标签）。
- en: 'The last example we will discuss is using recommend to create policies and
    a report for an image that is not running in the cluster. So far, we have run
    recommendations against objects in the cluster, but KubeArmor offers the ability
    to create policies based on any container image. To run a recommendation against
    an image, you need to add the `-i` or `--image` to your command. For example,
    we want to run karmor against the `bitnami/nginx` image:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一个示例是使用推荐命令为在集群中未运行的镜像创建策略和报告。到目前为止，我们已对集群中的对象运行了推荐命令，但 KubeArmor 提供了基于任何容器镜像创建策略的功能。要对一个镜像运行推荐命令，您需要在命令中添加
    `-i` 或 `--image` 参数。例如，我们想对 `bitnami/nginx` 镜像运行 karmor：
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will pull down the image and run it against all of the included KubeArmor
    policies. The policies will be created in the `out` directory, just like the previous
    examples:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这将拉取镜像并根据所有已包含的 KubeArmor 策略进行运行。策略将与之前的示例一样，创建在 `out` 目录中：
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we ran the same test and included the tag for only the CIS policies, we
    would generate fewer policies:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行相同的测试并仅包括 CIS 策略的标签，我们将生成更少的策略：
- en: '[PRE23]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As demonstrated, the recommend command empowers you to increase the security
    of your workloads in accordance with any standards required by your organization,
    government regulations, or other pertinent criteria.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如示范所示，recommend 命令使您能够根据组织、政府法规或其他相关标准提高工作负载的安全性。
- en: karmor logs
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: karmor logs
- en: 'The logs option provides a real-time log of KubeArmor’s activities, which is
    beneficial when you want to watch events without seeing hundreds of other logged
    activities. When you execute a karmor log, a logger will start up and watch for
    KubeArmor activity. Since it’s a real-time log, it will run interactively in your
    shell, waiting for activity:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 日志选项提供了 KubeArmor 活动的实时日志，这对于希望查看事件而不看到成百上千其他已记录活动的用户非常有用。当您执行 karmor log 时，日志记录器将启动并监视
    KubeArmor 活动。由于这是实时日志，它将在您的 shell 中以交互方式运行，等待活动发生：
- en: '[PRE24]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As events are observed by KubeArmor, they will be shown in the output. For
    example, we create a policy that will block any write attempts to the `/bin` directory
    in all containers in the demo namespace. We exec into the container and attempt
    to create a file called `test` in the directory. As we can see in the output below,
    the attempt was denied:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当 KubeArmor 观察到事件时，它们将显示在输出中。例如，我们创建了一个策略，阻止在演示命名空间中所有容器对 `/bin` 目录的任何写入尝试。我们进入容器并尝试在该目录下创建一个名为
    `test` 的文件。如下面的输出所示，尝试被拒绝：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since this was an action that KubeArmor had a policy for, it will also log
    the activity in the session running the karmor logs. The logs contain a lot of
    information. Below is an example of a logged event:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 KubeArmor 已经有策略的操作，它也会在运行 karmor 日志的会话中记录活动。日志包含了大量信息。以下是一个记录事件的示例：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By default, the log output is set to text, which may be difficult to sort through
    when there are a lot of logged events. If you would prefer the logs to be in JSON
    format, you can add the flag `--json` to the `logs` command. The format that is
    best to use for your requirements usually depends on the system you are using
    for storing your logged events. In most cases, JSON is the format preferred by
    most logging systems.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，日志输出设置为文本格式，这在日志事件较多时可能难以筛选。如果您希望日志以 JSON 格式显示，可以在 `logs` 命令中添加 `--json`
    标志。最适合您需求的格式通常取决于您用于存储日志事件的系统。在大多数情况下，JSON 是大多数日志系统首选的格式。
- en: 'To show the difference, we execute the same test from the previous log entry,
    an attempt to create a file under `/bin`. This will change the output from text
    to JSON, as shown below:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示差异，我们执行与前一条日志相同的测试，尝试在 `/bin` 下创建一个文件。这将把输出从文本格式转换为 JSON，如下所示：
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The decision to use text or JSON is usually dependent on the tools you plan
    to use to parse the data. JSON is a popular format for logging since it makes
    parsing the data much easier than using a text format.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本或 JSON 的决定通常取决于您计划用来解析数据的工具。JSON 是一种流行的日志格式，因为它比文本格式更容易解析数据。
- en: You may be looking at the logging abilities using the karmor log and wondering
    how useful it is to have the output going to the console only.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在查看使用 karmor 日志功能，想知道仅将输出定向到控制台有多大用处。
- en: As a default behavior, the logs are directed to `stdout`. While real-time log
    viewing is valuable for monitoring events as they happen, it’s not always feasible
    to continuously observe events. It is more common to send your logs to a file,
    which can then be viewed or sent to an external system for processing. KubeArmor
    offers the flexibility to modify your log output preferences by using the `--logPath`
    flag. This flag lets you specify the desired destination for the log file, enabling
    you to redirect log data to a designated file location.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，日志被定向到`stdout`。虽然实时日志查看对监控事件的发生非常有价值，但持续观察事件并不总是可行的。通常的做法是将日志发送到文件中，然后查看该文件或将其发送到外部系统进行处理。KubeArmor
    提供了通过使用`--logPath`标志来修改日志输出偏好的灵活性。这个标志允许你指定日志文件的目标位置，从而将日志数据重定向到指定的文件路径。
- en: 'When you specify the path of the log file, it must include the entire path
    and filename that you want to use. The `logPath` option can be used with other
    options, like setting the log format to JSON. The example command below will send
    the logs to the current user’s home directory using the filename `karmor.logs`
    in JSON format:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定日志文件的路径时，必须包含你希望使用的完整路径和文件名。`logPath`选项可以与其他选项一起使用，比如将日志格式设置为 JSON。下面的示例命令将把日志发送到当前用户的主目录，并使用文件名`karmor.logs`以
    JSON 格式保存：
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you specify a new directory in `logPath`, it must be created before sending
    any logs; KubeArmor will not create the directory for you. If you fail to create
    the directory before logging, you will receive an error on the log output screen
    and no events will be logged.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`logPath`中指定了一个新的目录，它必须在发送任何日志之前创建；KubeArmor 不会为你创建该目录。如果你在记录日志之前没有创建目录，你将收到日志输出屏幕上的错误，并且不会记录任何事件。
- en: 'When the first event is caught by KubeArmor, it will create the file and will
    continue to collect data until you stop logging:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当 KubeArmor 捕获到第一个事件时，它会创建文件并继续收集数据，直到你停止记录：
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Like other karmor options, logging will watch the entire cluster by default,
    which may generate a lot of events that may make it difficult to find the events
    you really need to see. Instead of logging the entire cluster, you can filter
    the logs by adding a flag to the `logs` option. The available flags include:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他 karmor 选项一样，日志默认会监视整个集群，这可能会生成大量事件，使你难以找到真正需要查看的事件。你可以通过向`logs`选项添加标志来过滤日志，而不是记录整个集群。可用的标志包括：
- en: '| **Flag** | **Description** |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **描述** |'
- en: '| `--labels` | Filter the logs by a label |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `--labels` | 按标签过滤日志 |'
- en: '| `--namespace` | Filter the logs by namespace |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `--namespace` | 按命名空间过滤日志 |'
- en: '| `--pod` | Filter the logs by pod |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `--pod` | 按 pod 过滤日志 |'
- en: 'Table 13.3: Limiting logs to certain objects'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.3：限制日志到特定对象
- en: Limiting the scope of the objects being logged offers the distinct advantage
    of tailoring the log data to focus exclusively on the specific object(s) you require
    detailed information for. By implementing this approach, you can significantly
    enhance the precision and relevance of the logged data, ensuring that it directly
    aligns with your specific monitoring, analysis, and troubleshooting needs. Limiting
    the objects being logged enables you to streamline your monitoring efforts, making
    it more efficient and effective in providing insights into the targeted object(s)
    while reducing the noise and clutter caused by unnecessary log entries.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 限制被记录对象的范围有一个明显的优势，那就是可以根据需要详细信息的特定对象定制日志数据。通过实施这种方法，你可以显著提高日志数据的精确性和相关性，确保它与你的特定监控、分析和故障排除需求直接对齐。限制被记录对象可以使你简化监控工作，使其更加高效，并有效提供对目标对象的洞察，同时减少因不必要的日志条目导致的噪音和冗余。
- en: karmor vm
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: karmor vm
- en: Did you know that with Kubernetes you can run virtual machines? These VMs are
    deployed and managed differently than what you may be used to when working with
    hypervisors from VMware and Microsoft. Instead of running an OS straight on the
    hypervisor, KubeVirt VMs actually run inside of a container. They look like a
    standard pod running any other Docker image, but instead of a microservice, it’s
    an entire operating system supporting both Windows and Linux.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道通过Kubernetes可以运行虚拟机吗？这些虚拟机的部署和管理方式与使用VMware和Microsoft的虚拟化技术时有所不同。与其直接在虚拟化程序上运行操作系统，KubeVirt的虚拟机实际上是在容器内运行的。它们看起来像是运行其他Docker镜像的标准Pod，但它们不是微服务，而是一个完整的操作系统，支持Windows和Linux。
- en: KubeVirt is a complex topic and we can’t cover it in this section alone. You
    can learn more about KubeVirt on their website, [https://kubevirt.io/](https://kubevirt.io/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: KubeVirt是一个复杂的话题，我们无法仅在本节中涵盖。你可以在他们的官网了解更多关于KubeVirt的信息，[https://kubevirt.io/](https://kubevirt.io/)。
- en: The KubeArmor team saw the need to expand runtime security to include support
    for VMs running with KubeVirt. This is a powerful feature for organizations that
    run VMs in Kubernetes, extending the same security that KubeArmor provides for
    containers to VMs.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: KubeArmor团队意识到需要将运行时安全性扩展到支持使用KubeVirt运行的虚拟机。这是一个强大的功能，适用于在Kubernetes中运行虚拟机的组织，将KubeArmor为容器提供的安全性扩展到虚拟机。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at strengthening the security of our runtime environment,
    enhancing your overall security posture. It’s a common misconception that an organization’s
    clusters are secured since many of them tend to overlook the content running within
    containers or the implications of a user connecting to a running pod using `kubectl
    exec`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何加强我们运行时环境的安全性，提升整体安全态势。很多人误以为组织的集群已经安全，但许多集群往往忽视了容器中运行的内容，或忽视了用户通过`kubectl
    exec`连接到运行中的Pod的潜在风险。
- en: This chapter also described in detail how one of the most effective approaches
    to container security involves tightly controlling the container’s processes,
    exclusively allowing the execution of only the necessary processes while denying
    access to all other files. By leveraging a tool like KubeArmor, you can grant
    access to specific files from a restricted set of binaries, blocking access to
    and securing all other processes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还详细描述了容器安全性最有效的方法之一，涉及严格控制容器的进程，专门允许仅执行必要的进程，同时拒绝访问其他所有文件。通过利用像KubeArmor这样的工具，你可以为受限的二进制文件集合提供文件访问权限，阻止对其他所有进程的访问并进行保护。
- en: Questions
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following are LSMs?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是LSM？
- en: Accuknox
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Accuknox
- en: AppArmor
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AppArmor
- en: SELinux
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux
- en: LSMLinux
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LSMLinux
- en: LSMs and eBPF provide the same features.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LSM和eBPF提供相同的功能。
- en: 'True'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Which karmor option provides real-time information in an easy-to-see console?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个karmor选项提供易于查看的实时信息？
- en: Monitor
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控
- en: Trace
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪
- en: Profile
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件
- en: Probe
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探测
- en: Which of the following is NOT a feature provided by KubeArmor to enhance security
    in Kubernetes clusters?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项不是KubeArmor为增强Kubernetes集群安全性而提供的功能？
- en: Restricting process execution
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制进程执行
- en: File access control
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件访问控制
- en: Network traffic encryption
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络流量加密
- en: Creating security policies
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建安全策略
- en: Answers
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b - AppArmor
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b - AppArmor
- en: b - False
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b - 错误
- en: c - Profile
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c - 配置文件
- en: c - Network traffic encryption
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c - 网络流量加密
- en: Join our book’s Discord space
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的Discord空间
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 加入本书的Discord工作区，参加每月的*问我任何问题*（Ask Me Anything）环节，与作者互动：
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
- en: '![](img/QR_Code965214276169525265.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code965214276169525265.png)'
