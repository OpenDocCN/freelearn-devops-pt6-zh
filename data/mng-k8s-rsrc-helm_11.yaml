- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Using Helm with the Operator Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 与操作符框架
- en: One of the advantages of using Helm is the ability to declaratively define an
    application’s desired state. With Helm, the desired state is managed with templates
    and Helm values, which, when provided using the `install` or `upgrade` commands,
    apply the values to synchronize the live state in a Kubernetes cluster. In previous
    chapters, this was performed by invoking those commands manually. Most recently,
    in [*Chapter 10*](B17979_10.xhtml#_idTextAnchor241), *Automating Helm with CD
    and GitOps*, we used Argo CD as a method of state synchronization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 的一个优势是能够声明式地定义应用程序的期望状态。通过 Helm，期望的状态通过模板和 Helm 值进行管理，当通过 `install`
    或 `upgrade` 命令提供时，这些值会应用于同步 Kubernetes 集群中的实时状态。在前面的章节中，这是通过手动调用这些命令来执行的。最近，在
    [*第 10 章*](B17979_10.xhtml#_idTextAnchor241)，*使用 CD 和 GitOps 自动化 Helm* 中，我们使用
    Argo CD 作为一种状态同步的方法。
- en: Another way changes can be synchronized to a Kubernetes cluster is to use a
    controller that checks periodically that the desired state matches the current
    configuration in the environment. If the state does not match, the application
    can automatically modify the environment to match the desired state. This controller
    is the foundation of applications and is referred to as a **Kubernetes operator**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将更改同步到 Kubernetes 集群的方法是使用一个控制器，该控制器定期检查期望的状态是否与环境中的当前配置匹配。如果状态不匹配，应用程序可以自动修改环境以匹配期望的状态。这个控制器是应用程序的基础，通常被称为**Kubernetes
    操作符**。
- en: In this chapter, we will create a Helm-based operator that helps ensure that
    the desired state always matches the live state of the cluster. If it does not,
    the operator will execute the appropriate Helm commands to reconcile the state
    of the environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个基于 Helm 的操作符，帮助确保期望的状态始终与集群的实时状态匹配。如果不匹配，操作符将执行相应的 Helm 命令以协调环境的状态。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Kubernetes operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 操作符
- en: Understanding the Guestbook operator control loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Guestbook 操作符控制循环
- en: Using Helm to manage operators, **Custom Resource Definitions** (**CRDs**),
    and **Custom Resources** (**CRs**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helm 管理操作符，**自定义资源定义**（**CRDs**）和**自定义资源**（**CRs**）
- en: Cleaning up
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to have the following technologies installed
    on your local machine:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你需要在本地机器上安装以下技术：
- en: minikube
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube
- en: Helm
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: kubectl
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: In addition to these tools, you should find the Packt repository containing
    resources associated with the examples on GitHub at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm).
    This repository will be referenced throughout this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具之外，你还应该在 GitHub 上找到包含与示例相关资源的 Packt 仓库，网址为 [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm)。本章将会多次引用这个仓库。
- en: Understanding Kubernetes operators
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 操作符
- en: One of the fundamental principles of Kubernetes is that the current state of
    resources within the cluster matches the desired state, a process known as the
    **control loop**. The control loop is an ongoing, non-terminating pattern of monitoring
    the state of the cluster through the use of controllers. Kubernetes includes numerous
    controllers that are native to the platform, with examples ranging from admission
    controllers that intercept requests made to the API server to replication controllers
    that ensure the configuration of pod replicas.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的基本原则之一是集群中资源的当前状态与期望状态相匹配，这个过程被称为**控制循环**。控制循环是一种持续不断的模式，通过使用控制器监控集群的状态。Kubernetes
    包含多个原生控制器，例子包括从拦截请求的准入控制器到确保 Pod 副本配置的复制控制器。
- en: As interest in Kubernetes began to grow, the combination of providing users
    with the ability to extend the capabilities of the platform, as well as a way
    to provide more intelligence around managing the life cycle of applications, led
    to the creation of a couple of important features to support Kubernetes development.
    First, the introduction of CRDs enabled users the ability to extend the default
    Kubernetes API in order to create and register new types of resources. Registering
    a new CRD creates a new resource path on the Kubernetes API server. For example,
    registering a new CRD for an object type called `kubectl get Guestbook` can now
    be used to view all Guestbook objects that are currently available. With this
    new capability realized, developers could now create controllers of their own
    to monitor these types of CRs and manage the lifecycle of applications through
    the use of CRDs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Kubernetes 兴趣的不断增长，提供用户扩展平台功能的能力，以及围绕管理应用生命周期的更多智能方式，促使了几个重要功能的创建，以支持 Kubernetes
    开发。首先，引入 CRD 使用户能够扩展默认的 Kubernetes API，从而创建并注册新的资源类型。注册新的 CRD 会在 Kubernetes API
    服务器上创建一个新的资源路径。例如，注册一个名为 `kubectl get Guestbook` 的对象类型 CRD，现在可以用来查看当前所有可用的 Guestbook
    对象。随着这一新能力的实现，开发者现在可以创建自己的控制器来监控这些 CR 类型，并通过使用 CRD 来管理应用的生命周期。
- en: Another major feature that helped to shape the developer experience in Kubernetes
    included advances in the types of applications deployed to Kubernetes. Instead
    of small and simple applications, more complex and stateful applications were
    being deployed more frequently. Typically, these types of advanced applications
    require a higher level of management and maintenance, such as *day 2* activities
    including backups, restorations, and upgrades. These tasks extend beyond the typical
    types of controllers that are found natively in Kubernetes, as deep knowledge
    related to the application being managed must be embedded within. This pattern
    of using a CR to manage applications and their components is known as the **Operator**
    pattern. First coined by the software company **CoreOS** in 2016, operators aim
    to capture the knowledge that a human operator would have for managing the lifecycle
    of an application. Operators are packaged as normal containerized applications,
    deployed within pods, that react on changes to the API against CRs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有助于塑造 Kubernetes 中开发者体验的重要功能是对部署到 Kubernetes 的应用类型的改进。与小型和简单的应用程序不同，越来越多复杂且有状态的应用程序被频繁部署。通常，这些类型的高级应用程序需要更高水平的管理和维护，例如包括备份、恢复和升级等
    *第二天* 活动。这些任务超出了 Kubernetes 原生控制器的典型类型，因为需要将与被管理应用程序相关的深入知识嵌入其中。使用 CR 来管理应用及其组件的模式被称为
    **操作符** 模式。该模式最早由软件公司 **CoreOS** 于 2016 年提出，操作符旨在捕获人类操作员管理应用程序生命周期时所具备的知识。操作符作为普通的容器化应用程序打包，部署在
    pod 中，针对 CR 的 API 变更做出反应。
- en: 'Operators are commonly written using a framework called **kubebuilder**, which
    contains features that simplify the creation of CRs and the interaction with a
    Kubernetes environment. Several additional frameworks have since been created
    to further extend the capabilities to support operator development. One such popular
    toolkit is the **Operator Framework**, which provides end users with the ability
    to create operators using one of the following three technologies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符通常使用名为 **kubebuilder** 的框架编写，该框架包含简化 CR 创建和与 Kubernetes 环境交互的功能。此后，已创建几个额外的框架，以进一步扩展支持操作符开发的能力。其中一个流行的工具包是
    **Operator Framework**，它为最终用户提供了使用以下三种技术之一创建操作符的能力：
- en: '**Go**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go**'
- en: '**Ansible**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible**'
- en: '**Helm**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm**'
- en: Go-based operators leverage the Go programming language to implement control
    loop logic. Ansible-based operators leverage the Ansible CLI tool and Ansible
    playbooks to manage the state of resources. Ansible is a popular open source configuration
    management tool.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Go 的操作符利用 Go 编程语言实现控制循环逻辑。基于 Ansible 的操作符利用 Ansible CLI 工具和 Ansible 剧本来管理资源的状态。Ansible
    是一个流行的开源配置管理工具。
- en: In this chapter, we will focus on Helm-based operators. Helm operators base
    their control loop logic on Helm charts and a subset of features provided by the
    Helm CLI. As a result, they represent an easy way for Helm users to implement
    their own operators.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讨论基于 Helm 的操作符。Helm 操作符将其控制循环逻辑基于 Helm 图表和 Helm CLI 提供的子集功能。因此，它们为
    Helm 用户提供了一种简单的方式来实现自己的操作符。
- en: With an understanding of operators, let’s continue by creating our own operator
    using Helm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了 operators 后，让我们继续通过使用 Helm 创建我们自己的 operator。
- en: Understanding the Guestbook operator control loop
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Guestbook operator 控制循环
- en: In this chapter, we will write a Helm-based operator that will be used to install
    the Guestbook Helm chart. This chart can be found in the Packt repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/helm-charts/charts/guestbook](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/helm-charts/charts/guestbook).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个基于 Helm 的 operator，用于安装 Guestbook Helm 图表。该图表可以在 Packt 仓库中找到，网址为
    [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/helm-charts/charts/guestbook](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/helm-charts/charts/guestbook)。
- en: 'The following diagram demonstrates how the Guestbook operator will function
    once it has been deployed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下图演示了 Guestbook operator 部署后将如何运作：
- en: '![](img/Figure_11.01_B17979.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.01_B17979.jpg)'
- en: Figure 11.1 – The Guestbook operator control loop
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Guestbook operator 控制循环
- en: The Guestbook operator constantly watches for the creation, deletion, or modification
    of Guestbook CRs. When a Guestbook CR is created, the operator will install the
    Guestbook Helm chart, and when the CR is modified, it upgrades the release accordingly
    so that the state of the cluster matches the desired intent as defined by the
    CR. Similarly, when the CR is deleted, the operator uninstalls the release.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook operator 会不断监控 Guestbook CR 的创建、删除或修改。当创建一个 Guestbook CR 时，operator
    会安装 Guestbook Helm 图表；当 CR 被修改时，它会相应地升级发布，以确保集群的状态与 CR 定义的目标一致。同样，当 CR 被删除时，operator
    会卸载该发布。
- en: With an understanding of how the operator’s control loop will function, let’s
    set up an environment where the operator can be built and deployed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了 operator 的控制循环如何运作后，让我们设置一个可以构建和部署 operator 的环境。
- en: Preparing a local development environment
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备本地开发环境
- en: 'In order to create a Helm operator, you will need the following CLI tools at
    a minimum:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Helm operator，您至少需要以下 CLI 工具：
- en: '`operator-sdk`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator-sdk`'
- en: A container management tool, such as `docker`, `podman`, or `buildah`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个容器管理工具，如 `docker`、`podman` 或 `buildah`
- en: The `operator-sdk` CLI is a toolkit used to help develop Kubernetes operators.
    It contains inherent logic to simplify the operator development process. Under
    the hood, `operator-sdk` requires a container management tool that it can use
    to build the operator image. The supported container management tools are `docker`,
    `podman`, and `buildah`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator-sdk` CLI 是一个用于帮助开发 Kubernetes operator 的工具包。它包含简化 operator 开发过程的内在逻辑。在底层，`operator-sdk`
    需要一个容器管理工具来构建 operator 镜像。支持的容器管理工具有 `docker`、`podman` 和 `buildah`。'
- en: Installing the `operator-sdk` CLI is easy, as you can simply download a release
    from GitHub at [https://github.com/operator-framework/operator-sdk/releases](https://github.com/operator-framework/operator-sdk/releases).
    However, the process used to install `docker`, `podman`, or `buildah` varies greatly
    depending on your operating system; not to mention, Windows users will not be
    able to use the `operator-sdk` toolkit natively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `operator-sdk` CLI 非常简单，您可以从 GitHub 下载一个版本，网址为 [https://github.com/operator-framework/operator-sdk/releases](https://github.com/operator-framework/operator-sdk/releases)。然而，安装
    `docker`、`podman` 或 `buildah` 的过程因操作系统不同而大不相同；更重要的是，Windows 用户将无法原生使用 `operator-sdk`
    工具包。
- en: Fortunately, the minikube `operator-sdk` toolkit onto minikube and use the minikube
    VM as an environment to create the operator.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以将 minikube `operator-sdk` 工具包安装到 minikube 中，并使用 minikube 虚拟机作为创建 operator
    的环境。
- en: 'First, start the minikube VM:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动 minikube 虚拟机：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the VM has started, proceed by following these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟机启动，请按照以下步骤操作：
- en: 'Access the VM by running the `minikube ssh` command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`minikube ssh`命令访问虚拟机：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once inside the VM, you need to download the `operator-sdk` CLI. This can be
    accomplished using the `curl` command. Note that the `operator-sdk` version used
    during writing was version `v1.20.0`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入虚拟机，您需要下载 `operator-sdk` CLI。可以使用 `curl` 命令来完成此操作。请注意，写本文时使用的 `operator-sdk`
    版本是 `v1.20.0`。
- en: 'To download this version of the `operator-sdk` CLI, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载此版本的`operator-sdk` CLI，请运行以下命令：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once downloaded, you will need to change the permission of the `operator-sdk`
    binary to be user-executable. Run the `chmod` command to make this modification:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，您需要更改 `operator-sdk` 二进制文件的权限，使其可由用户执行。运行 `chmod` 命令进行此修改：
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, move the `operator-sdk` binary to a location managed by the `PATH` variable,
    such as `/usr/local/bin`. Because this operation requires root privileges, you
    will need to run the `mv` command using `sudo`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`operator-sdk`二进制文件移动到`PATH`变量管理的目录中，例如`/usr/local/bin`。由于此操作需要root权限，你需要使用`sudo`运行`mv`命令：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, verify your `operator-sdk` installation by running the `operator-sdk
    version` command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过运行`operator-sdk version`命令验证你的`operator-sdk`安装：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As an additional step, you should also clone the Packt repository in your minikube
    VM since we will need it later to build our Helm operator. Run the following commands
    to install `git` and clone the repository in your VM (notice that we will also
    install `make`, which is necessary for building our operator image later):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为额外的步骤，你还应该在minikube虚拟机中克隆Packt仓库，因为稍后我们需要它来构建我们的Helm操作器。运行以下命令来安装`git`并在虚拟机中克隆仓库（注意，我们还将安装`make`，它对于稍后构建操作器镜像是必要的）：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have a local development environment created in the minikube VM,
    let’s begin writing the Guestbook operator. Note that an example of the operator
    code is located in the Packt repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter11/guestbook-operator](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter11/guestbook-operator).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在minikube虚拟机中创建了本地开发环境，让我们开始编写Guestbook操作器。请注意，操作器代码的示例位于Packt仓库中，链接为[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter11/guestbook-operator](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter11/guestbook-operator)。
- en: Scaffolding the operator file structure
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搭建操作器文件结构
- en: 'Similar to Helm charts themselves, Helm operators built by the `operator-sdk`
    binary have a specific file structure that must be adhered to. The file structure
    is explained in the following table:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与Helm图表本身类似，通过`operator-sdk`二进制文件构建的Helm操作器具有特定的文件结构，必须遵循该结构。文件结构在下表中有说明：
- en: '| **File/folder** | **Definition** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **文件/文件夹** | **定义** |'
- en: '| `Dockerfile` | Used to build the operator image |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Dockerfile` | 用于构建操作器镜像 |'
- en: '| `Makefile` | Provides a convenient set of targets for building the operator
    image and deploying it to Kubernetes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Makefile` | 提供了一组便捷的目标，用于构建操作器镜像并将其部署到Kubernetes |'
- en: '| `PROJECT` | Provides `operator-sdk` metadata |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `PROJECT` | 提供`operator-sdk`的元数据 |'
- en: '| `config/` | Contains Kubernetes resource manifests for CRDs, CRs, and the
    operator instance |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `config/` | 包含CRD、CR和操作器实例的Kubernetes资源清单文件 |'
- en: '| `helm-charts/` | Contains the Helm charts that the operator is in charge
    of installing |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `helm-charts/` | 包含操作器负责安装的Helm图表 |'
- en: '| `watches.yaml` | Defines the CRs that the operator is in charge of monitoring
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `watches.yaml` | 定义了操作器负责监视的CRs |'
- en: Table 11.1 – The operator-sdk file structure
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 – operator-sdk文件结构
- en: 'This file structure can be easily created using the `operator-sdk init` and
    `operator-sdk create api` commands. Let’s walk through this process to create
    a `Guestbook` kind of a custom API version, `demo.example.com/v1alpha1`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件结构可以通过使用`operator-sdk init`和`operator-sdk create api`命令轻松创建。让我们一起走一遍这个过程，创建一个`Guestbook`类型的自定义API版本`demo.example.com/v1alpha1`：
- en: 'First, create a new folder for the operator and `cd` inside the newly created
    directory:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为操作器创建一个新文件夹并`cd`进入新创建的目录：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, use the `operator-sdk init` command to initialize the project:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`operator-sdk init`命令初始化项目：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the usage of the `--plugins helm` parameter. This specifies that our
    project is a Helm operator and provides the necessary project scaffolding. The
    `–domain example.com` parameter specifies the Kubernetes API group that will be
    used for the CR. However, the command has not yet created the Guestbook CRD and
    control loop logic. This will be handled in the next step.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用了`--plugins helm`参数。它指定我们的项目是一个Helm操作器，并提供了必要的项目框架。`–domain example.com`参数指定了将用于CR的Kubernetes
    API组。然而，这个命令还没有创建Guestbook CRD和控制循环逻辑，接下来的步骤将处理这一部分。
- en: 'Run the `operator-sdk create api` command to create the Guestbook CRD and associated
    manifests:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`operator-sdk create api`命令来创建Guestbook CRD和相关的清单文件：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might see a warning about RBAC rules, but this can safely be ignored for
    this example. In practice, you should always ensure that the RBAC rules follow
    the principle of least privilege.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到关于RBAC规则的警告，但对于这个示例来说，可以安全忽略。实际上，你应该始终确保RBAC规则遵循最小权限原则。
- en: With the Guestbook operator successfully scaffolded, let’s build the operator
    and push it to a container registry, where we will later pull the image for deployment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过成功创建Guestbook操作员框架，让我们构建操作员并将其推送到容器注册表，稍后我们将在那里拉取镜像以进行部署。
- en: Building the operator image
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建操作员镜像
- en: One of the files generated by `operator-sdk` was `Makefile`, which contains
    targets for building your operator image and pushing it to a container registry.
    However, before we can build our image, we need to have access to a container
    registry.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator-sdk`生成的文件之一是`Makefile`，它包含了构建操作员镜像并将其推送到容器注册表的目标。然而，在我们构建镜像之前，需要先访问一个容器注册表。'
- en: In [*Chapter 8*](B17979_08.xhtml#_idTextAnchor210), *Publishing to a Helm Chart
    Repository*, we used the GitHub container registry located at `ghcr.io` to publish
    images. We will use the same registry for publishing our Guestbook operator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17979_08.xhtml#_idTextAnchor210)中，*发布到Helm Chart仓库*，我们使用了位于`ghcr.io`的GitHub容器注册表来发布镜像。我们将使用相同的注册表来发布我们的Guestbook操作员。
- en: In order to publish to `ghcr.io`, you need to have first created a **Personal
    Access Token** (**PAT**). If you have already created one in [*Chapter 8*](B17979_08.xhtml#_idTextAnchor210),
    *Publishing to a Helm Chart Repository*, you do not need to create a new one (unless
    it has expired or you have misplaced the token).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布到`ghcr.io`，你需要先创建一个**个人访问令牌**（**PAT**）。如果你已经在[*第8章*](B17979_08.xhtml#_idTextAnchor210)中创建过一个令牌，即*发布到Helm
    Chart仓库*，则不需要重新创建（除非令牌已经过期或你丢失了令牌）。
- en: 'However, if you do need to create a PAT, you can follow these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实需要创建PAT，你可以按照以下步骤操作：
- en: Log into GitHub. Once you are logged in, from the upper-right corner of the
    page, select your profile picture and click on **Settings** from the drop-down
    menu.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录GitHub。登录后，在页面的右上角选择你的个人资料图片，并从下拉菜单中点击**设置**。
- en: Click on **Developer Settings** and select **Personal Account Token**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开发者设置**并选择**个人账户令牌**。
- en: Click on the **Generate New Token** button to initiate the token creation process.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成新令牌**按钮，开始创建令牌。
- en: Enter a unique name for the token, such as `Learn Helm`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为令牌输入一个唯一的名称，例如`Learn Helm`。
- en: Select the date the token will expire. It is a recommended practice to specify
    an expiration date as it follows security best practices.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择令牌的过期日期。建议指定过期日期，因为这符合安全最佳实践。
- en: 'Select the scopes (permissions) granted to the token. The following scopes
    are required for managing content within the container registry:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择授予令牌的作用域（权限）。以下作用域是管理容器注册表内容所必需的：
- en: '`read:packages`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`read:packages`'
- en: '`write:packages`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`write:packages`'
- en: '`delete:packages`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delete:packages`'
- en: Click on the **Generate Token** button to create the token.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成令牌**按钮来创建令牌。
- en: Be sure to copy the token before navigating away from the page. If you navigate
    away from the page before noting the content of the token, it can be regenerated
    at any time. However, the previously specified value will no longer be valid.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开页面之前，请务必复制令牌。如果在记下令牌内容之前离开了页面，令牌可以随时重新生成。但是，之前指定的值将不再有效。
- en: 'Once you have created your PAT and copied the access token, you can log into
    the `ghcr.io` registry from within your minikube VM by using the `docker login`
    command. For the `Username` prompt, provide your GitHub username, and for `Password`,
    paste the PAT token:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了PAT并复制了访问令牌，你可以通过在minikube虚拟机中使用`docker login`命令登录`ghcr.io`注册表。在`Username`提示框中输入你的GitHub用户名，在`Password`提示框中粘贴PAT令牌：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you have logged into the registry, you can continue by building and deploying
    your operator image. To do this, we can use the `make` utility to run different
    Makefile targets:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你登录到注册表，就可以继续构建并部署操作员镜像。为此，我们可以使用`make`工具运行不同的Makefile目标：
- en: 'First, we need to define the image name. The Makefile defaults the image name
    to `controller:latest`. We can give a more descriptive name by setting the `IMG`
    environment variable:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义镜像名称。Makefile默认的镜像名称是`controller:latest`。我们可以通过设置`IMG`环境变量来为其指定一个更具描述性的名称：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Be sure to substitute your GitHub username when setting the `IMG` variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`IMG`变量时，请确保替换为你的GitHub用户名。
- en: 'Next, we can begin the image build using the `docker-build` Makefile target:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`docker-build` Makefile目标开始镜像构建：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the build is successful, you will see the `Successfully tagged` message
    followed by the container image name and tag. Additionally, you can use the `docker
    images` command to verify the image was created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功，你将看到 `Successfully tagged` 消息，后面跟着容器镜像的名称和标签。另外，你可以使用 `docker images`
    命令验证镜像是否创建成功：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can push our image using the `docker-push` target:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `docker-push` 目标推送我们的镜像：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, your image will be private after you successfully push to `ghcr.io`.
    To avoid requiring the need for specifying a Kubernetes pull secret to access
    the image, we can update the image settings to make the image publicly available.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，成功推送到 `ghcr.io` 后，您的镜像将是私有的。为了避免需要指定 Kubernetes 拉取密钥来访问镜像，我们可以更新镜像设置，使镜像公开可用。
- en: 'First, in GitHub, select your profile picture from the upper-right corner of
    the page, and choose `guestbook-operator` image (the guestbook image from [*Chapter
    8*](B17979_08.xhtml#_idTextAnchor210), *Publishing to a Helm Chart Repository*,
    is visible in the screenshot, too):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 GitHub 上，选择页面右上角的个人头像，选择 `guestbook-operator` 镜像（在截图中可以看到来自 [*第8章*](B17979_08.xhtml#_idTextAnchor210)
    的 Guestbook 镜像，*发布到 Helm 图表仓库*，也可以看到）：
- en: '![Figure 11.2 – The GitHub Packages page'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – GitHub Packages 页面'
- en: '](img/Figure_11.02_B17979.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.02_B17979.jpg)'
- en: Figure 11.2 – The GitHub Packages page
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – GitHub Packages 页面
- en: Next, select the `guestbook-operator` package. On the far right of the screen,
    select **Package Settings**, then update the **Change Visibility** setting to
    **Public**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择 `guestbook-operator` 包。在屏幕的最右侧，选择 **Package Settings**，然后更新 **Change
    Visibility** 设置为 **Public**。
- en: If you were able to update your image’s visibility to **Public**, then you have
    successfully pushed your image and can now access it without requiring credentials.
    Let’s continue by deploying your operator to Kubernetes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经成功将镜像的可见性更新为 **Public**，那么你就成功推送了镜像，现在可以在无需凭证的情况下访问它。接下来，让我们继续将操作器部署到 Kubernetes。
- en: Deploying the Guestbook operator
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Guestbook 操作器
- en: 'Similar to building the operator, the deployment of our Guestbook operator
    can be performed using a set of Makefile targets. The Makefile generated by `operator-sdk`
    contains four targets related to the installation or removal of the operator:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于构建操作器，我们可以使用一组 Makefile 目标来部署我们的 Guestbook 操作器。由 `operator-sdk` 生成的 Makefile
    包含四个与操作器安装或移除相关的目标：
- en: '`install`: This installs CRDs onto the Kubernetes cluster. This target adds
    the Guestbook API to the cluster.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install`: 该目标将 CRD 安装到 Kubernetes 集群中。此目标会将 Guestbook API 添加到集群中。'
- en: '`uninstall`: This uninstalls CRDs from the Kubernetes cluster. This target
    removes the Guestbook API from the cluster.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uninstall`: 该目标卸载 Kubernetes 集群中的 CRD。此目标会从集群中移除 Guestbook API。'
- en: '`deploy`: This installs CRDs and deploys the Guestbook operator to the Kubernetes
    cluster. We’ll use this target later for the deployment.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy`: 该目标安装 CRD 并将 Guestbook 操作器部署到 Kubernetes 集群中。稍后我们将使用此目标进行部署。'
- en: '`undeploy`: This undeploys (or removes) the CRDs and Guestbook operator instance
    from the Kubernetes cluster.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undeploy`: 该目标从 Kubernetes 集群中撤销（或移除）CRD 和 Guestbook 操作器实例。'
- en: Under the hood, each target uses `kubectl` and a configuration management tool
    called `config` folder. Kustomize is a tool that, at a high level, uses `kustomization.yaml`
    files that specify the Kubernetes manifests that will be applied. Also, it adds
    patches and common configurations to each manifest, such as the target namespace
    and resource names.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，每个目标都使用 `kubectl` 和一个名为 `config` 文件夹的配置管理工具。Kustomize 是一个高层次的工具，使用 `kustomization.yaml`
    文件来指定将要应用的 Kubernetes 清单文件。此外，它还会向每个清单添加补丁和公共配置，例如目标命名空间和资源名称。
- en: 'The contents of the `config` folder contents are shown in the following table:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`config` 文件夹的内容如下面的表格所示：'
- en: '| **Folder** | **Definition** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **文件夹** | **定义** |'
- en: '| `config/crd/` | Contains the CRDs for extending the Kubernetes API. For our
    Guestbook operator, there is only one CRD. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `config/crd/` | 包含用于扩展 Kubernetes API 的 CRD。对于我们的 Guestbook 操作器，只有一个 CRD。
    |'
- en: '| `config/default/` | Contains a parent `kustomization.yaml` file for applying
    CRD, RBAC, and operator (also referred to as *manager*) resources. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `config/default/` | 包含一个父级 `kustomization.yaml` 文件，用于应用 CRD、RBAC 和操作器（也称为
    *manager*）资源。 |'
- en: '| `config/manager/` | Contains a deployment resource for creating the operator
    (or `manage`r) instance. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `config/manager/` | 包含创建操作器（或 `manage`r）实例的部署资源。 |'
- en: '| `config/manifests/` | A superset of the `config/default/` folder. Here, `config/manifests`
    applies CRD, RBAC, and operator resources, but it also applies an example Guestbook
    CR and a *scorecard*, which is used for testing the operator. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `config/manifests/` | `config/default/` 文件夹的超集。在这里，`config/manifests` 应用
    CRD、RBAC 和操作器资源，还应用了一个示例 Guestbook CR 和一个 *scorecard*，用于测试操作器。 |'
- en: '| `config/prometheus/` | Contains a Prometheus `ServiceMonitor` resource for
    tracking metrics. This is disabled by default but can be enabled in the `kustomization.yaml`
    file located under `config/default/`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `config/prometheus/` | 包含用于跟踪指标的 Prometheus `ServiceMonitor` 资源。默认情况下禁用，但可以在位于
    `config/default/` 下的 `kustomization.yaml` 文件中启用。 |'
- en: '| `config/rbac/` | Contains `Role`, `RoleBinding`, and `ServiceAccount` resources.
    These grant the operator permission to manage Guestbook resources. They also create
    Guestbook editor and viewer roles for users throughout the Kubernetes cluster.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `config/rbac/` | 包含 `Role`、`RoleBinding` 和 `ServiceAccount` 资源。这些资源授予操作器管理
    Guestbook 资源的权限。它们还为 Kubernetes 集群中的用户创建 Guestbook 编辑和查看角色。 |'
- en: '| `config/samples/` | Contains an example Guestbook manifest. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `config/samples/` | 包含一个示例 Guestbook 清单。 |'
- en: '| `config/scorecard/` | Contains manifests for testing the operator. They are
    unused by default. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `config/scorecard/` | 包含用于测试操作器的清单。默认情况下未使用。 |'
- en: Figure 11.4 – The contents of the config folder
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 配置文件夹的内容
- en: 'When we run the `make` deploy command, Kustomize targets the `kustomization.yaml`
    file from `config/default/` to apply resources from the `config/crd/`, `config/manager/`,
    and `config/rbac/` directories. Then, when the operator is installed, we will
    apply the Guestbook CR, which is located at `config/samples/demo_v1alpha1_guestbook.yaml`.
    Let’s take a look at a snippet from the `demo_v1alpha1_guestbook.yaml` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `make deploy` 命令时，Kustomize 会定位 `config/default/` 中的 `kustomization.yaml`
    文件，并应用 `config/crd/`、`config/manager/` 和 `config/rbac/` 目录中的资源。然后，当操作器安装完成后，我们将应用位于
    `config/samples/demo_v1alpha1_guestbook.yaml` 的 Guestbook CR。让我们来看一下 `demo_v1alpha1_guestbook.yaml`
    文件中的一个片段：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Does the preceding YAML look familiar? Each of the entries under the `spec`
    stanza reference default values from the Guestbook chart’s `values.yaml` file.
    This is how values are provided when using a Helm operator. Rather than providing
    a `values.yaml` file, users write values in the Guestbook CR. Then, when the resource
    is applied, the operator consumes the values and deploys the application accordingly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的 YAML 看起来熟悉吗？`spec` 部分下的每个条目引用了 Guestbook chart 中 `values.yaml` 文件中的默认值。这是使用
    Helm 操作器时提供值的方式。用户并不提供一个 `values.yaml` 文件，而是在 Guestbook CR 中写入值。然后，当资源应用时，操作器会消费这些值并相应地部署应用程序。
- en: 'With a basic understanding of the operator’s `config/` folder and `Makefile`
    targets, let’s deploy the Guestbook operator by following these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对操作器 `config/` 文件夹和 `Makefile` 目标的基本理解，我们可以通过以下步骤部署 Guestbook 操作器：
- en: In order to deploy the Guestbook operator, we need to be authenticated to the
    Kubernetes cluster. Because the minikube VM does not have `kubectl` installed,
    nor `kubeconfig`, which we can use for authentication, it will be simpler to deploy
    the operator from your host machine.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了部署 Guestbook 操作器，我们需要认证到 Kubernetes 集群。由于 minikube 虚拟机中没有安装 `kubectl`，也没有
    `kubeconfig`，我们可以用来进行身份验证，因此从主机机器部署操作器会更简单。
- en: 'Exit the minikube VM by running the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令退出 minikube 虚拟机：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resources we created in the minikube VM are also located in the Packt repository
    under the `chapter11/guestbook-operator/` folder. You can clone this repository
    and navigate to the `guestbook-operator` folder by running the following commands:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 minikube 虚拟机中创建的资源也位于 Packt 仓库中的 `chapter11/guestbook-operator/` 文件夹。你可以克隆该仓库并通过运行以下命令进入
    `guestbook-operator` 文件夹：
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The files from the Packt repository are the same as the ones you created in
    the minikube VM with one exception. As you might recall from previous chapters,
    the Guestbook Helm chart contains hooks for backing up and restoring the Redis
    database. These hooks require the operator to have permission to manage the `Job`
    and `PersistentVolumeClaim` resources. Because the role generated by `operator-sdk`
    does not include these resources, we added them at the end of the role definition
    located at `chapter11/guestbook-operator/config/rbac/role.yaml`. Here are the
    permissions that we added:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Packt 仓库的文件与你在 minikube 虚拟机中创建的文件相同，唯一的例外是。如你可能从前面的章节中回忆的那样，Guestbook Helm
    图表包含用于备份和恢复 Redis 数据库的钩子。这些钩子要求操作符具有管理 `Job` 和 `PersistentVolumeClaim` 资源的权限。由于
    `operator-sdk` 生成的角色不包含这些资源，因此我们在位于 `chapter11/guestbook-operator/config/rbac/role.yaml`
    的角色定义末尾添加了它们。以下是我们添加的权限：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will use the `make` command to deploy the Guestbook CRD and operator
    to the Kubernetes cluster. Note that Windows users might need to install `make`
    first, which can be done by using the Chocolatey package manager:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `make` 命令将 Guestbook CRD 和操作符部署到 Kubernetes 集群中。请注意，Windows 用户可能需要先安装
    `make`，可以通过使用 Chocolatey 包管理器来完成：
- en: '[PRE19]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Proceed with the operator deployment by setting the `IMG` environment variable
    and running the following `make` command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 `IMG` 环境变量并运行以下 `make` 命令，继续操作符部署：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The operator was installed in a namespace called `guestbook-operator-system`.
    Verify that the pod was deployed successfully in this namespace:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作符已安装在名为 `guestbook-operator-system` 的命名空间中。请验证该 Pod 是否已成功部署到此命名空间：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that the operator has been deployed, let’s use it to install the Guestbook
    Helm chart.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在操作符已被部署，接下来让我们使用它来安装 Guestbook Helm 图表。
- en: Deploying the Guestbook application
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Guestbook 应用
- en: When using Helm normally as a standalone CLI tool, you would install a Helm
    chart by running the `helm install` command. With a Helm operator, you can install
    a Helm chart by creating a CR.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用 Helm 作为独立 CLI 工具时，你会通过运行 `helm install` 命令来安装 Helm 图表。使用 Helm 操作符时，你可以通过创建
    CR 来安装 Helm 图表。
- en: 'First, create a new namespace for our deployment:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为我们的部署创建一个新的命名空间：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, using the CR located in the Packt repository at `chapter11/guestbook-operator/config/samples/demo_v1alpha1_guestbook.yaml`,
    install the Guestbook Helm chart:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用位于 Packt 仓库的 `chapter11/guestbook-operator/config/samples/demo_v1alpha1_guestbook.yaml`
    文件中的 CR 安装 Guestbook Helm 图表：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the installation is complete, you’ll see each pod in the ready state:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将看到每个 Pod 都处于就绪状态：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you created the CR, the operator executed the `helm install` command against
    the Guestbook Helm chart. You can confirm the release was created by running `helm
    list`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 CR 时，操作符会执行 `helm install` 命令来安装 Guestbook Helm 图表。你可以通过运行 `helm list`
    来确认发布是否已经创建：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Upgrades are performed by reapplying the CR with a different set of values.
    A modified CR is located in the Packt repository at `chapter11/guestbook-operator/config/samples/upgrade-example.yaml`.
    In this file, the `replicaCount` value has been changed to `2`, as opposed to
    `1` in the original CR.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 升级通过重新应用 CR 并使用一组不同的值来执行。修改后的 CR 位于 Packt 仓库的 `chapter11/guestbook-operator/config/samples/upgrade-example.yaml`
    文件中。在此文件中，`replicaCount` 的值已从原始 CR 中的 `1` 修改为 `2`。
- en: 'Apply the updated CR by running the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令应用更新后的 CR：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This modification of the Guestbook CR causes the operator to trigger `helm
    upgrade` against the `guestbook-sample` release. As you might recall from [*Chapter
    7*](B17979_07.xhtml#_idTextAnchor196), *Helm Lifecycle Hooks*, the Guestbook chart
    contains an upgrade hook that initiates a Redis backup. If you watch the pods
    in the `chapter11` namespace after modifying the CR, you will see the backup job
    begin, and then you will shortly see two Guestbook pods appear. You will also
    notice that the revision number of the release increased to `2`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Guestbook CR 的修改使得操作符触发了针对 `guestbook-sample` 发布的 `helm upgrade`。正如你可能从 [*第
    7 章*](B17979_07.xhtml#_idTextAnchor196) 中回忆的那样，*Helm 生命周期钩子*，Guestbook 图表包含一个升级钩子，用于启动
    Redis 备份。如果你在修改 CR 后观察 `chapter11` 命名空间中的 Pod，你将看到备份任务开始，然后很快会看到两个 Guestbook Pod
    出现。你还会注意到发布的修订号增加到了 `2`：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Although the revision number increased to `2`, as of writing, one limitation
    of Helm operators is that you cannot initiate a rollback to a previous version
    as you can do when using the CLI. If you attempt to run `helm history` against
    the `guestbook-sample` release, you will notice that only the current revision
    is available in the release history:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管修订版本号已增加到`2`，但在撰写时，Helm 操作符的一个限制是你无法像使用 CLI 时那样启动回滚到先前的版本。如果你尝试对 `guestbook-sample`
    发布运行 `helm history`，你会发现发布历史中只包含当前的修订版本：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is an important difference between using Helm regularly with the CLI and
    using Helm as an operator. Because the release history is not retained, Helm operators
    do not allow you to perform explicit rollbacks. However, `helm rollback` will
    be run implicitly in situations where upgrades fail. This would also trigger any
    rollback hooks that might be defined in the chart.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 Helm 与 CLI 常规操作和使用 Helm 作为操作符之间的一个重要区别。由于不会保留发布历史，Helm 操作符不允许你执行显式的回滚。然而，在升级失败的情况下，`helm
    rollback` 会被隐式执行。这也会触发 chart 中可能定义的任何回滚钩子。
- en: 'Although Helm operators do not retain the release history, one area where they
    excel is in synchronizing the desired and live states of an application. This
    is because the operator constantly watches the state of the Kubernetes environment
    and ensures that the application is always configured to match the CR. In other
    words, if one of the Guestbook application’s resources has been modified, the
    operator will immediately revert the change to synchronize it with the configuration
    defined within the CR. You can see this in action by modifying one of the live
    resources. As an example, we will change the Guestbook deployment’s replica count
    from `2` to `3` and watch the operator revert this change back to `2` immediately
    to resync the state to match the CR. Run the following `kubectl patch` command
    to change the replica count on the deployment from `2` to `3`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Helm 操作符不会保留发布历史，但它们在同步应用程序的期望状态和实时状态方面表现出色。这是因为操作符不断监视 Kubernetes 环境的状态，并确保应用程序始终配置为与
    CR 匹配。换句话说，如果 Guestbook 应用程序的某个资源被修改，操作符会立即将其更改恢复，以便与 CR 中定义的配置同步。你可以通过修改一个实时资源来看它的实际效果。例如，我们将
    Guestbook 部署的副本数从 `2` 更改为 `3`，并观察操作符立即将其恢复为 `2`，以重新同步状态与 CR 匹配。运行以下 `kubectl patch`
    命令，将部署的副本数从 `2` 更改为 `3`：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Normally, this would create an additional Guestbook pod replica. However, because
    the Guestbook CR currently defines only `2` replicas, the operator quickly changes
    the replica count back to `2` and terminates the additional pod that was created.
    If you actually wanted to increase the replica count to `3`, you would need to
    update the `replicaCount` value on the CR. This process provides the advantage
    of ensuring the desired state matches the live state at all times.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这将创建一个额外的 Guestbook pod 副本。然而，由于 Guestbook CR 当前只定义了 `2` 个副本，操作符会迅速将副本数改回
    `2`，并终止已创建的额外 pod。如果你真的希望将副本数增加到 `3`，你需要更新 CR 中的 `replicaCount` 值。这个过程的优点是确保期望的状态始终与实时状态匹配。
- en: 'Uninstalling releases created by the Helm operator is as simple as removing
    the CR. Delete the `guestbook-sample` CR to uninstall the release:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载由 Helm 操作符创建的发布非常简单，只需删除 CR 即可。删除 `guestbook-sample` CR 以卸载发布：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also remove the Guestbook operator and its resources since we will
    not need them in the next section. You can do this by running another `make` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以删除 Guestbook 操作符及其资源，因为在下一节中我们不再需要它们。你可以通过运行另一个 `make` 命令来完成此操作：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In general, you should always make sure that you delete the CR first before
    deleting the operator. If you delete the operator before the CR, then the operator
    will not be able to automatically run `helm uninstall`, and you would have to
    run it manually from the command line.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在删除操作符之前，你应该始终确保先删除 CR。如果你在 CR 之前删除了操作符，操作符将无法自动运行 `helm uninstall`，你必须手动从命令行运行它。
- en: Over the course of this chapter, you created a Helm operator and learned how
    to install a Helm chart using an operator-based approach. In the next section,
    we will continue our discussion on operators by investigating how they can be
    managed using Helm.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章过程中，你创建了一个 Helm 操作符，并学习了如何使用基于操作符的方法安装 Helm chart。在接下来的部分，我们将继续讨论操作符，探讨如何通过
    Helm 管理操作符。
- en: Using Helm to manage operators, CRDs, and CRs
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 管理操作符、CRD 和 CR
- en: In this chapter, we installed the Guestbook operator and CRD by using the `Makefile`
    instance generated by `operator-sdk`. Then, we installed a Guestbook CR using
    `kubectl apply`. While this is an acceptable way of creating these resources,
    we could also install the operator, CRD, and CR by using Helm charts to provide
    a more repeatable solution for installing and managing an operator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用由`operator-sdk`生成的`Makefile`实例来安装了访客留言操作员和 CRD。然后，我们使用`kubectl apply`安装了一个访客留言
    CR。虽然这是创建这些资源的可接受方法，但我们也可以使用 Helm 图表来安装和管理操作员提供一个更可重复的解决方案，来安装操作员、CRD 和 CR。
- en: Helm allows you to create CRDs by adding them to a directory called `crds/`
    in your Helm chart. Helm creates CRDs before any of the other resources defined
    under the `templates/` folder, making it simpler to install applications such
    as operators that depend on CRDs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 允许您通过将它们添加到 Helm 图表中名为`crds/`的目录来创建 CRD。Helm 在定义了`templates/`文件夹下的任何其他资源之前创建
    CRD，从而简化了安装依赖于 CRD 的操作员应用程序等应用程序。
- en: 'The following file structure depicts a Helm chart that could be used to install
    the Guestbook operator:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于安装访客留言操作员的 Helm 图表的文件结构：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Upon installation, this Helm chart will first install the Guestbook CRD. If
    the CRD is already present in the cluster, it will skip the CRD creation and go
    straight into installing the templates. Note that while CRDs can be convenient
    to include in a Helm chart, there are a couple of limitations to be aware of.
    First, Helm does not allow CRDs to contain any Go templating, so CRDs do not benefit
    from parameterization as opposed to typical resources. Also, CRDs cannot be upgraded,
    rolled back, or deleted. Finally, including CRDs in your chart would require the
    user to have elevated cluster-level privileges within the Kubernetes cluster.
    Often, it is administrators who perform operator installations, so this is likely
    to be an acceptable approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 安装时，这个 Helm 图表将首先安装访客留言定制资源定义（CRD）。如果 CRD 已经存在于集群中，它将跳过 CRD 的创建并直接安装模板。请注意，虽然
    CRD 可以方便地包含在 Helm 图表中，但有几个限制需要注意。首先，Helm 不允许 CRD 包含任何 Go 模板化内容，因此 CRD 无法像典型资源那样从参数化中受益。此外，CRD
    不能被升级、回滚或删除。最后，包括 CRD 在您的图表中将要求用户在 Kubernetes 集群中拥有提升的集群级权限。通常，执行操作员安装的是管理员，因此这可能是一个可接受的方法。
- en: 'The Helm chart that we described earlier could be used to install the Guestbook
    operator, but this is only half of the equation, as end users must still be able
    to create CRs that deploy the Guestbook application. To address this limitation,
    you could create a separate Helm chart that is used for templating a Guestbook
    CR. An example layout for this type of Helm chart is shown in the following file
    structure:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前描述的 Helm 图表可以用于安装访客留言操作员，但这只是方程的一半，因为最终用户仍然必须能够创建部署访客留言应用程序的 CR。为解决这个限制，可以创建一个单独的
    Helm 图表，用于模板化访客留言 CR。这种类型的 Helm 图表的示例布局如下所示：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Unlike CRDs, CRs underneath the `templates/` folder benefit from Go templating
    and lifecycle management, as do all other resources. This methodology provides
    the most value when the CR contains complex fields or when other resources must
    be installed alongside the CR. You would also be able to manage the lifecycle
    of your CR with this method, and you would also be able to maintain a history
    of revisions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CRD 不同，位于`templates/`文件夹下的 CR 从 Go 模板化和生命周期管理中受益，与所有其他资源一样。当 CR 包含复杂字段或必须与
    CR 并行安装其他资源时，这种方法提供了最大的价值。您还可以使用此方法管理 CR 的生命周期，并维护修订版本的历史记录。
- en: However, users would need to be given permission to install Guestbook CRs, since
    this permission would not be included in Kubernetes by default. These permissions
    can be easily added by applying the `guestbook_editor_role.yaml` file under the
    operator’s `config/rbac/` folder. Then, you can create a `RoleBinding` resource
    to assign the editor role to the appropriate users or groups.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户需要被授予安装访客留言定制资源的权限，因为这个权限在 Kubernetes 默认情况下不包含在内。可以通过在操作员的`config/rbac/`文件夹下应用`guestbook_editor_role.yaml`文件来轻松添加这些权限。然后，您可以创建一个`RoleBinding`资源将编辑角色分配给适当的用户或组。
- en: Now that you have an understanding of how operators, CRDs, and CRs can be managed
    with Helm, let’s close out the chapter by cleaning up the Kubernetes environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用 Helm 管理操作员、CRD 和 CR，让我们通过清理 Kubernetes 环境来结束本章。
- en: Cleaning up
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'First, delete the `chapter11` namespace:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除`chapter11`命名空间：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, run the `minikube stop` command to stop your minikube VM.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行 `minikube stop` 命令来停止你的 minikube 虚拟机。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Operators are important for ensuring that the desired state always matches the
    live state. Such a feat allows users to more easily maintain a source of truth
    for resource configuration. Users can leverage a Helm operator to provide this
    type of resource reconciliation, and it is easy to get started because it uses
    Helm charts as its deployment mechanism. When a CR is created, the Helm operator
    installs the associated Helm chart to create a new release. Subsequent upgrades
    are performed when the CR is modified, and the release is uninstalled when the
    CR has been deleted.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: operator 对于确保期望状态始终与实时状态匹配非常重要。这样的成就使得用户更容易维护资源配置的真实来源。用户可以利用 Helm operator
    提供这种资源调解，而且它很容易上手，因为它使用 Helm charts 作为部署机制。当 CR 被创建时，Helm operator 会安装相关的 Helm
    chart 来创建一个新的发布版本。之后，当 CR 被修改时，会进行升级，而当 CR 被删除时，发布版本会被卸载。
- en: To manage the operator, cluster administrators can create a separate Helm chart
    for creating the operator’s resources and CRDs. Also, end users can create a separate
    Helm chart for creating CRs and other related resources.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理 operator，集群管理员可以创建一个单独的 Helm chart 来创建 operator 的资源和 CRD。此外，最终用户可以创建一个单独的
    Helm chart 来创建 CR 和其他相关资源。
- en: In the next chapter, we will discuss best practices and topics around security
    within the Helm ecosystem.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Helm 生态系统中的最佳实践和安全性相关话题。
- en: Further reading
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about operators and their origins, check out the Kubernetes documentation
    at [https://kubernetes.io/docs/concepts/extend-kubernetes/operator/](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于 operator 及其起源的信息，请查看 Kubernetes 文档：[https://kubernetes.io/docs/concepts/extend-kubernetes/operator/](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)。
- en: To discover other operators that have been developed throughout the community,
    check out *OperatorHub* at [https://operatorhub.io](https://operatorhub.io) or
    the *Operators* section of *ArtifactHub* at [https://artifacthub.io](https://artifacthub.io).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发现社区中已开发的其他操作符，请访问 *OperatorHub*：[https://operatorhub.io](https://operatorhub.io)
    或 *ArtifactHub* 的 *Operators* 部分：[https://artifacthub.io](https://artifacthub.io)。
- en: Questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an operator? How does an operator work at a high level?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 operator？在高层次上，operator 是如何工作的？
- en: What is the difference between installing a Helm chart with the Helm CLI versus
    a Helm operator?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Helm CLI 安装 Helm chart 与使用 Helm operator 安装 Helm chart 有什么区别？
- en: What toolkit can you use to create Helm operators?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么工具包来创建 Helm operator？
- en: How does the `install`, `upgrade`, `rollback`, and `uninstall` hooks function
    with a Helm operator?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`install`、`upgrade`、`rollback` 和 `uninstall` 钩子在 Helm operator 中如何工作？'
- en: What is the purpose of the `crds/` folder in a Helm chart?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm chart 中 `crds/` 文件夹的作用是什么？
