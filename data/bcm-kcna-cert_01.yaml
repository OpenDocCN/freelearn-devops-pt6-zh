- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: From Cloud to Cloud Native and Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从云计算到云原生与Kubernetes
- en: In this chapter, you’ll see how computing has evolved over the past 20 or so
    years, what the **cloud** is and how it appeared, and how IT landscapes have changed
    with the introduction of containers. You’ll learn about fundamentals such as **Infrastructure-as-a-Service**
    (**IaaS**), **Platform-as-a-Service** (**PaaS**), **Software-as-a-Service** (**SaaS**),
    and **Function-as-a-Service** (**FaaS**), as well as learning about the transition
    from monolithic to microservice architectures and getting a first glimpse at Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示过去20多年中计算如何演变，**云计算**是什么及其如何出现，以及IT环境随着容器的引入发生了怎样的变化。你将学习到**基础设施即服务**(**IaaS**)、**平台即服务**(**PaaS**)、**软件即服务**(**SaaS**)和**函数即服务**(**FaaS**)等基础知识，同时还会了解从单体架构到微服务架构的过渡，并初步了解Kubernetes。
- en: This chapter does not map directly to a specific KCNA exam objective, but these
    topics are crucial for anyone who’d like to tie their career to modern infrastructures.
    If you are already familiar with the basic terms, feel free to quickly verify
    your knowledge by going directly to the recap questions. If not, don’t be surprised
    that things are not covered in great detail, as this is an introductory chapter,
    and we’ll dive deeper into all of the topics in later chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并没有直接对应特定的KCNA考试目标，但这些主题对任何希望将自己职业与现代基础设施挂钩的人来说至关重要。如果你已经熟悉基本术语，可以通过直接查看回顾问题来快速验证你的知识。如果不熟悉，不要惊讶于本章没有深入探讨，因为这是一个入门章节，我们将在后续章节中深入探讨所有主题。
- en: 'We’re going to cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The cloud and **Before Cloud** (**B.C.**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算与**云之前**(**B.C.**)
- en: Evolution of the cloud and cloud-native
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算的演变与云原生
- en: Containers and container orchestration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器与容器编排
- en: Monolithic versus microservices applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用与微服务应用
- en: Kubernetes and its origins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes及其起源
- en: Let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The cloud and Before Cloud (B.C.)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算与云之前（B.C.）
- en: The cloud has triggered a major revolution and accelerated innovation, but before
    we learn about the cloud, let’s see how things were done before the era of the
    cloud.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算引发了一场重大革命并加速了创新，但在我们学习云之前，先来看看云时代之前的做法。
- en: 'In the times before the term *cloud computing* was used, one physical server
    would only be able to run a single **operating system** (**OS**) at a time. These
    systems would typically host a single application, meaning two things:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*云计算*这个术语之前，一台物理服务器通常只能同时运行一个**操作系统**(**OS**)。这些系统通常只承载一个应用程序，这意味着两件事：
- en: If an application was not used, the computing resources of the server where
    it ran were wasted
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个应用程序不被使用，那么它运行的服务器上的计算资源就会浪费
- en: If an application was used very actively and needed a larger server or more
    servers, it would take days or even weeks to get new hardware procured, delivered,
    cabled, and installed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个应用程序非常活跃并且需要更大的服务器或更多服务器，通常需要几天甚至几周的时间来采购、交付、布线并安装新硬件。
- en: Moving on, let’s have a look at an important aspect of computing – virtualization.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看计算中的一个重要方面——虚拟化。
- en: Virtualization
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化
- en: Virtualization technology and **virtual machines** (**VMs**) first appeared
    back in the 1960s, but it was not until the early 2000s that virtualization technologies
    such as XEN and **Kernel-based Virtual Machines** (**KVMs**) started to become
    mainstream.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化技术和**虚拟机**(**VM**)最早出现在1960年代，但直到2000年代初，像XEN和**基于内核的虚拟机**(**KVM**)这样的虚拟化技术才开始成为主流。
- en: Virtualization would allow us to run multiple VMs on a single physical server
    using hypervisors, where a hypervisor is a software that acts as an emulator of
    the hardware resources, such as the CPU and RAM. Effectively, it allows you to
    share the processor time and memory of the underlying physical server by slicing
    it between multiple VMs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化允许我们在一台物理服务器上通过使用虚拟机监控程序（hypervisor）运行多个虚拟机（VM）。虚拟机监控程序是一种作为硬件资源（如CPU和RAM）模拟器的软件。它实际上通过将底层物理服务器的处理器时间和内存划分给多个虚拟机，从而允许你共享这些资源。
- en: 'It means that each VM will be very similar to the physical server, but with
    a virtual CPU, memory, disks, and network cards instead of physical ones. Each
    VM will also have an OS on which you can install applications. The following figure
    demonstrates a virtualized deployment with two VMs running on the same physical
    server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个虚拟机将非常类似于物理服务器，但使用虚拟 CPU、内存、磁盘和网络卡，而非物理组件。每个虚拟机还将运行操作系统，并可以在其上安装应用程序。下图展示了在同一物理服务器上运行两个虚拟机的虚拟化部署：
- en: '![Figure 1.1 – Comparison of traditional and virtualized deployments](img/B18970_01_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 传统与虚拟化部署的对比](img/B18970_01_01.jpg)'
- en: Figure 1.1 – Comparison of traditional and virtualized deployments
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 传统与虚拟化部署的对比
- en: This concept of sharing hardware resources between the so-called *guest VMs*
    is what made it possible to utilize hardware more effectively and reduce any waste
    of computing resources. It means we might not need to purchase a whole new server
    in order to run another application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在所谓的*客户虚拟机*之间共享硬件资源的概念，使得硬件的利用变得更加高效，减少了计算资源的浪费。也就是说，我们可能不需要为了运行另一个应用程序而购买一台全新的服务器。
- en: 'The obvious benefits that came along with virtualization are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化带来的明显好处如下：
- en: Less physical hardware required
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更少的物理硬件
- en: Fewer data center personnel required
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更少的数据中心人员
- en: Lower acquisition and maintenance costs
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更低的采购和维护成本
- en: Lower power consumption
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更低的能耗
- en: Besides, provisioning a new VM would take minutes and not days or weeks of waiting
    for new hardware. However, to scale beyond the capacities of the hardware already
    installed in the corporate data center, we would still need to order, configure,
    and cable new physical servers and network equipment – and that has all changed
    with the introduction of cloud computing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置一个新的虚拟机（VM）只需几分钟，而不是等待几天或几周来购买新硬件。然而，要超越公司数据中心已有硬件的容量，我们仍然需要订购、配置并布线新的物理服务器和网络设备——但随着云计算的引入，这一切都发生了变化。
- en: The cloud
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云
- en: At a very basic level, the cloud is virtualization on demand. It allows us to
    spawn VMs accessible over the network as a service, when requested by the customers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从最基础的层面来看，云就是按需虚拟化。它允许我们在客户请求时，作为一种服务生成可通过网络访问的虚拟机（VM）。
- en: Cloud computing
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算
- en: This is the delivery of computational resources as a service, where the actual
    hardware is owned and managed by the cloud provider rather than a corporate IT
    department.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将计算资源作为服务提供的方式，其中实际的硬件由云服务提供商拥有和管理，而非企业的 IT 部门。
- en: 'The cloud has ignited a major revolution in computing. It became unnecessary
    to buy and manage your own hardware anymore to build and run applications and
    VMs. The cloud provider takes full care of hardware procurement, installation,
    and maintenance and ensures the efficient utilization of resources by serving
    hundreds and thousands of customers on shared hardware securely. Each customer
    will only pay for the resources they use. Today, it is common to distinguish the
    following three cloud types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算引发了计算领域的重大革命。如今，构建和运行应用程序以及虚拟机不再需要购买和管理自己的硬件。云服务提供商全面负责硬件采购、安装和维护，并通过在共享硬件上为数百上千个客户提供安全的服务来确保资源的高效利用。每个客户仅需为其所使用的资源付费。如今，常见的云类型包括以下三种：
- en: '**Public** – The most popular type. A public cloud is operated by a third-party
    company and available for use by any paying customer. Public clouds are typically
    used by thousands of organizations at the same time. Examples of public cloud
    providers include **Amazon Web Services** (**AWS**), **Microsoft Azure**, and
    **Google Cloud** **Platform** (**GCP**).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共云** – 最受欢迎的类型。公共云由第三方公司运营，任何付费客户都可以使用。公共云通常同时为成千上万的组织提供服务。公共云提供商的例子包括**亚马逊网络服务**（**AWS**）、**微软
    Azure** 和 **谷歌云平台**（**GCP**）。'
- en: '**Private** – Used by one typically large organization or an enterprise. The
    operations and maintenance might be done by the organization itself or a private
    cloud provider. Examples include Rackspace Private Cloud and VMware Private Cloud.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有云** – 仅供一个通常较大的组织或企业使用。其操作和维护可能由该组织本身或私有云提供商完成。例子包括 Rackspace 私有云和 VMware
    私有云。'
- en: '**Hybrid** – This is the combination of a public and private cloud, in a case
    where an organization has a private cloud but uses some of the services from a
    public cloud at the same time.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合云** – 这是公共云与私有云的结合，适用于某个组织拥有私有云，但同时也使用一些公共云服务的情况。'
- en: However, the cloud is not just VMs reachable over the network. There are tens
    and hundreds of services offered by cloud providers. Today, you can request and
    use network-attached storage, virtual network devices, firewalls, load balancers,
    VMs with GPUs or specialized hardware, managed databases, and more almost immediately.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，云不仅仅是通过网络访问的虚拟机。云服务提供商提供了数十种、数百种服务。今天，您几乎可以立即请求并使用网络附加存储、虚拟网络设备、防火墙、负载均衡器、带有GPU或专用硬件的虚拟机、托管数据库等服务。
- en: Now, let’s see in more detail how cloud services can be delivered and consumed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地了解云服务如何交付和消费。
- en: Evolution of the cloud and cloud-native
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算和云原生的发展
- en: 'Besides the huge variety of cloud services you can find today, there is also
    a difference in how the services are offered. It is common to distinguish between
    four cloud service delivery models that help meet different needs:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了今天可以找到的各种云服务外，云服务的提供方式也有所不同。通常可以区分四种云服务交付模型，以满足不同的需求：
- en: '**IaaS** – The most flexible model with the basic services provided: VMs, virtual
    routers, block devices, load balancers, and so on. This model also assumes the
    most customer responsibility. Users of IaaS have access to their VMs and must
    configure their OS, install updates, and set up, manage, and secure their applications.
    AWS **Elastic Compute Cloud** (**EC2**), AWS **Elastic Block Store** (**EBS**),
    and Google Compute Engine VMs are all examples of IaaS.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IaaS** – 最灵活的模型，提供基本服务：虚拟机、虚拟路由器、块设备、负载均衡器等等。这个模型也假设客户承担更多责任。IaaS的用户可以访问他们的虚拟机，必须配置操作系统，安装更新，并设置、管理和保护他们的应用程序。AWS
    **弹性计算云**（**EC2**）、AWS **弹性块存储**（**EBS**）和Google Compute Engine虚拟机都是IaaS的示例。'
- en: '**PaaS** – This helps to focus on the development and management of applications
    by taking away the need to install OS upgrades or do any lower-level maintenance.
    As a PaaS customer, you are still responsible for your data, identity and access,
    and your application life cycle. Examples include Heroku and Google App Engine.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PaaS** – 通过免去安装操作系统更新或进行任何低级别维护的需求，帮助客户专注于应用程序的开发和管理。作为PaaS客户，您仍然需要负责您的数据、身份与访问以及应用程序生命周期。示例包括Heroku和Google
    App Engine。'
- en: '**SaaS** – Takes the responsibilities even further away from the customers.
    Typically, these are fully managed applications that *just work*, such as Slack
    or Gmail.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaaS** – 将责任进一步移离客户。通常，这些是完全托管的应用程序，*即开即用*，例如Slack或Gmail。'
- en: '**FaaS** – A newer delivery model that appeared around 2010\. It is also known
    as **Serverless** today. A FaaS customer is responsible for defining the functions
    that are triggered by the events. Functions can be written in one of the popular
    programming languages and customers don’t have to worry about server or OS management,
    deployment, or scaling. Examples of FaaS include AWS Lambda, Google Cloud Functions,
    and Microsoft Azure Functions.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FaaS** – 一种在2010年左右出现的较新交付模型。如今也被称为**无服务器**。FaaS的客户负责定义由事件触发的功能。这些功能可以使用流行的编程语言编写，客户无需担心服务器或操作系统管理、部署或扩展等问题。FaaS的示例包括AWS
    Lambda、Google Cloud Functions和Microsoft Azure Functions。'
- en: These models might sound a bit complicated, so let’s draw a simple analogy with
    cars and transportation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型听起来可能有点复杂，让我们用汽车和交通工具做一个简单的类比。
- en: '*On-premises, traditional data centers* are like having your own car. You are
    buying it, and you are responsible for its insurance and maintenance, the replacement
    of broken parts, passing regular inspections, and so on.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*本地传统数据中心* 就像是拥有自己的车。你购买了它，并且负责它的保险和维护、坏件的更换、定期检查等等。'
- en: '*IaaS* is more like leasing a car for some period of time. You pay monthly
    lease payments, you drive it, you fill it with gas, and you wash it, but you don’t
    actually own the car and you can give it back when you don’t need it anymore.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*IaaS* 更像是租车一段时间。你支付月租费，开车，给车加油，洗车，但你实际上并不拥有这辆车，当你不再需要它时，你可以把它还回去。'
- en: '*PaaS* can be compared with car-sharing. You don’t own the car, you don’t need
    to wash it, do any maintenance, or even refill it most of the time, but you still
    drive it yourself.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*PaaS* 可以与共享汽车进行类比。你不拥有汽车，不需要洗车、维护，甚至大多数时候不需要加油，但你仍然自己开车。'
- en: Following the analogy, *SaaS* is like calling a taxi. You don’t need to own
    the car or even drive it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个类比，*SaaS* 就像打出租车。你不需要拥有车甚至不需要开车。
- en: Finally, *Serverless* or *FaaS* can be compared to a bus from a user perspective.
    You just hop on and ride to your destination – no maintenance, no driving, and
    no ownership.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从用户的角度来看，*无服务器*或*FaaS*可以与公共汽车进行比较。你只需上车并直达目的地——无需维护、无需驾驶、无需拥有。
- en: Hopefully, this makes things clearer. The big difference between traditional
    on-premises setups where a company is solely responsible for the organization,
    hardware maintenance, data security, and more is that a so-called shared responsibility
    model applies in the cloud.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能让事情更加明晰。传统的本地部署设置中，公司完全负责组织、硬件维护、数据安全等方面，而在云中适用的则是所谓的共享责任模型。
- en: Shared responsibility model
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 共享责任模型
- en: Defines the obligations of the cloud provider and the cloud customer. These
    responsibilities depend on the service provided – in the case of an IaaS service,
    the customer has more responsibility compared to PaaS or SaaS. For example, the
    cloud provider is always responsible for preventing unauthorized access to data
    center facilities and the stability of the power supply and underlying network
    connectivity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了云服务提供商与云客户的责任。这些责任取决于提供的服务——在 IaaS 服务的情况下，客户的责任比 PaaS 或 SaaS 服务更多。例如，云服务提供商始终负责防止未经授权访问数据中心设施，以及确保电力供应和底层网络连接的稳定性。
- en: 'The following figure visually demonstrates the difference between the responsibilities:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示形象地展示了不同责任之间的差异：
- en: '![Figure 1.2 – Comparison of cloud delivery models](img/B18970_01_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 云交付模型比较](img/B18970_01_02.jpg)'
- en: Figure 1.2 – Comparison of cloud delivery models
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 云交付模型比较
- en: As cloud technologies and providers evolved over the past 20 years, so did the
    architectures of the applications that run on the cloud; a new term has emerged
    – **cloud-native**. Most of the time, it refers to the architectural approach,
    but you will often encounter cloud-native applications or cloud-native software
    as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着过去 20 年云技术和云服务提供商的发展，运行在云上的应用架构也发生了变化；一个新术语应运而生——**云原生**。大多数时候，它指的是一种架构方法，但你也会经常遇到云原生应用或云原生软件。
- en: Cloud-native
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生
- en: Is an approach to building and running applications on modern, dynamic infrastructures
    such as clouds. It is emphasizing application workloads with high resiliency,
    scalability, high degree of automation, ease of management, and observability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 是一种在现代、动态基础设施（如云）上构建和运行应用的方式。它强调具有高弹性、可扩展性、高度自动化、易于管理和可观察性的应用工作负载。
- en: Despite the presence of the word *cloud*, it does not mean that a cloud-native
    application must run strictly in a public, private, or hybrid cloud. You can develop
    a cloud-native application and run it on-premises with Kubernetes as an example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有*云*这个词，但这并不意味着云原生应用必须严格运行在公共、私有或混合云中。你可以开发一个云原生应用，并在本地运行它，例如使用 Kubernetes。
- en: 'Cloud-native should not be confused with **Cloud Service Providers** (**CSPs**),
    or simply cloud providers, and cloud-native is also not the same as cloud-first,
    so remember the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生不应与**云服务提供商**（**CSPs**）或简称云提供商混淆，也不应与云优先混淆，请记住以下几点：
- en: '**Cloud-native ≠ CSP ≠ cloud-first**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**云原生 ≠ CSP ≠ 云优先**'
- en: For the sake of completeness, let’s define the other two.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们定义一下另外两个概念。
- en: A CSP is a third-party company offering cloud computing services such as IaaS,
    PaaS, SaaS, or FaaS. Cloud-first simply stands for a strategy where the cloud
    is the default choice for either optimizing existing IT infrastructure or for
    launching new applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商（CSP）是指提供云计算服务的第三方公司，例如 IaaS、PaaS、SaaS 或 FaaS。云优先（Cloud-first）仅仅意味着一种策略，在这种策略下，云是优化现有
    IT 基础设施或启动新应用的默认选择。
- en: Don’t worry if those definitions do not make total sense just yet – we will
    dedicate a whole section to cloud-native that explains all its aspects in detail.
    For now, let’s have a quick introduction to containers and their orchestration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些定义目前还没有完全理解，也不用担心——我们将专门有一节来详细解释云原生的所有方面。现在，让我们简要介绍一下容器及其编排。
- en: Containers and container orchestration
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器与容器编排
- en: At a very high level, containers are another form of lightweight virtualization,
    also known as **OS-level virtualization**. However, containers are different from
    VMs with their own advantages and disadvantages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，容器是另一种轻量级虚拟化形式，也称为**操作系统级虚拟化**。然而，容器与虚拟机（VM）不同，具有各自的优缺点。
- en: The major difference is that with VMs, we can slice and share one physical server
    between many VMs, each running their own OS. With containers, we can slice and
    share an OS kernel between multiple containers and each container will have its
    own virtual OS. Let’s see this in more detail.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别在于，使用虚拟机时，我们可以在一台物理服务器上切分并共享多个虚拟机，每个虚拟机运行自己的操作系统。而使用容器时，我们可以在多个容器之间共享操作系统内核，每个容器都有自己的虚拟操作系统。让我们更详细地看看这个过程。
- en: Containers
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 容器
- en: These are portable units of software that include application code with runtimes,
    dependencies, and system libraries. Containers share one OS kernel, but each container
    can have its own isolated OS environment with different packages, system libraries,
    tools, its own storage, networking, users, processes, and groups.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是便携式的软件单元，包含应用代码、运行时、依赖项和系统库。容器共享一个操作系统内核，但每个容器可以拥有自己的隔离操作系统环境，带有不同的包、系统库、工具、存储、网络、用户、进程和组。
- en: '*Portable* is important and needs to be elaborated. An application packaged
    into a container image is guaranteed to run on another host because the container
    includes its own isolated environment. Starting a container on another host does
    not interfere with its environment or the application containerized.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*便携性*很重要，需要详细说明。将应用程序打包成容器镜像后，可以保证它在另一台主机上运行，因为容器包含了自己的隔离环境。在另一台主机上启动容器不会干扰其环境或被容器化的应用程序。'
- en: A major advantage is also that containers are a lot more lightweight and efficient
    compared to VMs. They consume less resources (the CPU and RAM) than VMs and start
    almost instantly because they don’t need to bootstrap a complete OS with a kernel.
    For example, if a physical server is capable of running 10 VMs, then the same
    physical server might be able to run 30, 40, or possibly even more containers,
    each with its own application (the exact number depends on many factors, including
    the type of workload, so those values are for demonstration purposes only and
    do not represent any formula).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的一个主要优势是，它们比虚拟机更加轻量和高效。容器消耗的资源（CPU 和 RAM）比虚拟机少，启动几乎是即时的，因为它们不需要启动一个完整的操作系统和内核。例如，如果一台物理服务器能够运行
    10 个虚拟机，那么同一台物理服务器可能能够运行 30、40，甚至更多的容器，每个容器都有自己的应用程序（具体的数量取决于许多因素，包括工作负载类型，因此这些数字仅用于演示，并不代表任何公式）。
- en: Containers are also much smaller than VMs in disk size, because they don’t package
    a full OS with thousands of libraries. Only applications with dependencies and
    a minimal set of OS packages are included in container images. That makes container
    images small, portable, and easy to download or share.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的磁盘大小也比虚拟机（VM）小得多，因为它们不会打包完整的操作系统和成千上万的库。容器镜像中仅包含带有依赖项的应用程序和一组最小的操作系统包。这使得容器镜像既小巧、便携，又容易下载或分享。
- en: Container images
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像
- en: These are essentially templates of container OS environments that we can use
    to create multiple containers with the same application and environment. Every
    time we execute an image, a container is created.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本上是容器操作系统环境的模板，我们可以使用它们来创建多个具有相同应用程序和环境的容器。每次执行镜像时，都会创建一个容器。
- en: Speaking in numbers, a container image of a popular Linux distribution such
    as *Ubuntu Server 20.04* weighs about 70 MB, whereas a KVM QCOW2 virtual machine
    image of the same Ubuntu Server will weigh roughly 500 MB. Specialized Linux container
    images such as *Alpine* can be as small as 5 to 10 MB and provide the bare minimum
    functionality to install and run applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从数字角度来看，一个流行的 Linux 发行版的容器镜像，如*Ubuntu Server 20.04*，大约为 70 MB，而相同的 Ubuntu Server
    的 KVM QCOW2 虚拟机镜像大约为 500 MB。专门的 Linux 容器镜像，如*Alpine*，可能只有 5 到 10 MB，并提供安装和运行应用程序所需的最低功能。
- en: Containers are also agnostic to where they run – whether on physical servers,
    on-premises VMs, or the cloud, containers can run in any of these locations with
    the help of container runtimes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 容器与其运行的地方无关——无论是在物理服务器、内部虚拟机还是云端，容器都可以在这些位置中的任何一个上运行，只要有容器运行时的支持。
- en: Container runtimes
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时
- en: A container runtime is a special software needed to run containers on a host
    OS. It is responsible for creating, starting, stopping, and deleting containers
    based on the container images it downloads. Examples of container runtimes include
    containerd, CRI-O, and Docker Engine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时是运行容器所需的特殊软件，它负责根据下载的容器镜像创建、启动、停止和删除容器。容器运行时的例子包括 containerd、CRI-O 和 Docker
    Engine。
- en: '*Figure 1**.3* demonstrates the differences between virtualized and containerized
    deployments:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.3* 展示了虚拟化和容器化部署的差异：'
- en: '![Figure 1.3 – Comparison of virtualized and container deployments](img/B18970_01_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 虚拟化与容器化部署的对比](img/B18970_01_03.jpg)'
- en: Figure 1.3 – Comparison of virtualized and container deployments
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 虚拟化与容器化部署的对比
- en: Now, a question you might be asking yourself is if containers are so great,
    why would anyone use VMs and why do cloud providers still offer so many VM types?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问自己，如果容器如此优秀，为什么还会有人使用虚拟机（VM），而且云服务提供商为什么仍然提供这么多虚拟机类型？
- en: 'Here is the scenario where VMs have an advantage over containers: they provide
    better security due to stronger isolation because they don’t directly share the
    same host kernel. That means if an application running in a container has been
    breached by a hacker, the chances that they can get to all the other containers
    on the same host are much higher than compared to regular VMs.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是虚拟机相比容器有优势的场景：虚拟机由于隔离性更强，提供了更好的安全性，因为它们不会直接共享相同的宿主机内核。这意味着，如果运行在容器中的应用程序被黑客攻破，那么黑客能够攻破同一宿主机上其他容器的可能性要比常规虚拟机高得多。
- en: We will dive deeper into the technology behind OS-level virtualization and explore
    the low-level differences between VMs and containers in later chapters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中深入探讨操作系统级虚拟化背后的技术，并探索虚拟机和容器之间的底层差异。
- en: As containers gained momentum and received wider adoption over the years, it
    quickly became apparent that managing containers on a large scale can be quite
    a challenge. The industry needed tools to orchestrate and manage the life cycle
    of container-based applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器的流行和广泛应用，容器的管理逐渐成为一个挑战，特别是在大规模管理容器时。行业需要一些工具来编排和管理基于容器的应用程序的生命周期。
- en: This had to do with the increasing number of containers that companies and teams
    had to operate because as the infrastructure tools evolved, so did the application
    architectures too, transforming from large monolithic architectures into small,
    distributed, and loosely coupled microservices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这与公司和团队必须操作的容器数量不断增加有关，因为随着基础设施工具的不断发展，应用架构也在发生变化，从大型单体架构转变为小型、分布式、松耦合的微服务架构。
- en: Monolithic versus microservices applications
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构与微服务架构
- en: To understand the difference between monolithic and microservice-based applications,
    let us reflect on a real-world example. Imagine that a company runs an online
    hotel booking business. All reservations are made and paid for by the customers
    via a corporate web service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解单体应用和基于微服务的应用之间的差异，让我们回顾一个现实中的例子。假设一家企业运营着一个在线酒店预订业务，所有预订都是客户通过公司网站进行的，并且完成支付。
- en: 'The traditional monolithic architecture for this kind of web application would
    have bundled all the functionality into one single, complex software that might
    have included the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的 Web 应用程序的传统单体架构会将所有功能打包到一个复杂的软件中，这个软件可能包括以下内容：
- en: Customer dashboard
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户仪表盘
- en: Customer identity and access management
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户身份与访问管理
- en: Search engine for hotels based on criteria
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据条件搜索酒店
- en: Billing and integration with payment providers
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计费与支付供应商集成
- en: Reservation system for hotels
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 酒店预订系统
- en: Ticketing and support chat
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 票务与支持聊天
- en: A monolithic application will be tightly coupled (bundled) with all the business
    and user logic and must be developed and updated at once. That means if a change
    to a billing code has to be made, the entire application will have to be updated
    with the changes. After that, it should be carefully tested and released to the
    production environment. Each (even a small) change could potentially break the
    whole application and impact business by making it unavailable for a longer time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用将所有业务和用户逻辑紧密耦合（打包）在一起，并且必须一起开发和更新。这意味着，如果需要修改计费代码，整个应用程序都必须进行更新。更新后，还必须进行仔细测试，并发布到生产环境中。每一个（即便是小的）变更都可能导致整个应用崩溃，并使得业务在较长时间内不可用。
- en: 'With a microservices architecture, this very same application could be split
    into several smaller pieces communicating with each other over the network and
    fulfilling its own purpose. Billing, for example, can be performed by four smaller
    services:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构下，同样的应用程序可以被拆分成几个小模块，通过网络相互通信，并各自完成自己的功能。例如，计费可以通过四个较小的服务来实现：
- en: Currency converter
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇率转换器
- en: Credit card provider integration
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用卡供应商集成
- en: Bank wire transfer processing
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '银行电汇处理  '
- en: Refund processing
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '退款处理  '
- en: Essentially, microservices are a group of small applications where each is responsible
    for its own small task. These small applications communicate with each other over
    the network and work together as a part of a larger application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '本质上，微服务是一组小型应用，每个应用负责完成自己的小任务。这些小型应用通过网络互相通信，并共同协作，成为一个更大应用的一部分。  '
- en: 'The following figure demonstrates the differences between monolithic and microservice
    architectures:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '下图展示了单体架构与微服务架构之间的差异：  '
- en: '![Figure 1.4 – Comparison of monolithic and microservice architectures](img/B18970_01_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 单体架构与微服务架构的比较](img/B18970_01_04.jpg)  '
- en: Figure 1.4 – Comparison of monolithic and microservice architectures
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '图1.4 – 单体架构与微服务架构的比较  '
- en: 'This way, all other parts of the web application can also be split into multiple
    smaller independent applications (microservices) communicating over the network.
    The advantages of this approach include the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '通过这种方式，Web应用的其他部分也可以拆分成多个独立的小型应用（微服务），它们通过网络进行通信。此方法的优点包括以下几点：  '
- en: Each microservice can be developed by its own team
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每个微服务可以由其独立的团队开发  '
- en: Each microservice can be released and updated separately
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每个微服务可以单独发布和更新  '
- en: Each microservice can be deployed and scaled independently of others
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每个微服务可以独立于其他服务进行部署和扩展  '
- en: A single microservice outage will only impact a small part of the overall functionality
    of the app
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '单个微服务的故障只会影响应用的一个小部分功能  '
- en: Microservices are an important part of cloud-native architectures, and we will
    review in detail the benefits as well as the challenges associated with microservices
    in [*Chapter 9*](B18970_09.xhtml#_idTextAnchor095), *Understanding Cloud Native
    Architectures*. For the moment, let’s get back to containers and why they need
    to be orchestrated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是云原生架构的重要组成部分，我们将在[*第9章*](B18970_09.xhtml#_idTextAnchor095)《理解云原生架构》中详细回顾微服务的优势与挑战。暂时让我们回到容器，探讨为什么它们需要进行编排。
- en: When each microservice is packaged into a container, the total number of containers
    can easily reach tens or even hundreds for especially large and complex applications.
    In such a complex distributed environment, things can quickly get out of our control.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '当每个微服务被打包成容器时，容器的总数可能会很快达到几十个甚至几百个，特别是在大型和复杂应用中。在这样的复杂分布式环境下，情况可能迅速失控。  '
- en: 'A container orchestration system is what helps us to keep control over a large
    number of containers. It simplifies the management of containers by grouping application
    containers into deployments and automating operations such as the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '容器编排系统帮助我们管理大量容器。它通过将应用容器分组到部署中，并自动化以下操作，简化了容器的管理：  '
- en: Scaling microservices depending on the workload
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '根据工作负载扩展微服务  '
- en: Releasing new versions of microservices and their updates
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '发布微服务的新版本及其更新  '
- en: Scheduling containers based on host utilizations and requirements
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '根据主机的使用情况和需求调度容器  '
- en: Automatically restarting containers that fail or failing over the traffic
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '自动重启失败的容器或将流量切换到其他容器  '
- en: 'As of today, there are many container and workload orchestration systems available,
    including these:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '目前，有许多容器和工作负载编排系统可供选择，包括以下几种：  '
- en: Kubernetes
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubernetes  '
- en: OpenShift (also known as **Open Kubernetes** **Distribution** (**OKD**))
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenShift（也称为**Open Kubernetes** **发行版**（**OKD**））  '
- en: Hashicorp Nomad
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hashicorp Nomad  '
- en: Docker Swarm
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker Swarm  '
- en: Apache Mesos
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Apache Mesos  '
- en: As you already know from the book title, we will only focus on Kubernetes and
    there won’t be any sort of comparison made between these five. In fact, Kubernetes
    has overwhelmingly higher market shares and over the years, has become the de
    facto platform for orchestrating containers. With a high degree of confidence,
    you can concentrate on learning about Kubernetes and forget about the others,
    at least for the moment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你从书名中已经知道的，我们将仅专注于Kubernetes，并且不会在这五种方案之间做任何比较。事实上，Kubernetes的市场份额遥遥领先，多年来，它已成为编排容器的事实标准平台。你可以充满信心地专注于学习Kubernetes，至少目前可以忽略其他的容器编排方案。  '
- en: Kubernetes and its origins
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Kubernetes及其起源  '
- en: Let’s start with a brief history first. The name Kubernetes originates from
    Greek and means *pilot* or *helmsman* – a person steering a ship (that is why
    there is a steering wheel in the logo). The steering wheel has seven bars and
    the number seven has a special meaning for Kubernetes. The team originally working
    on Kubernetes called it *Project Seven* – named after seven of nine characters
    from the well-known TV series,*Star Trek*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从简要的历史开始。Kubernetes 的名称源自希腊语，意思是*领航员*或*舵手* —— 一个操纵船只的人（这也是为什么标志中有一个舵轮）。舵轮上有七根条，而数字七对
    Kubernetes 具有特殊意义。最初负责 Kubernetes 的团队称其为*七号项目* —— 这是根据著名电视系列《星际迷航》中的七个九分之七角色而命名的。
- en: '![Figure 1.5 – The Kubernetes logo](img/B18970_01_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – Kubernetes 标志](img/B18970_01_05.jpg)'
- en: Figure 1.5 – The Kubernetes logo
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Kubernetes 标志
- en: Kubernetes was initially developed by Google and released as an open source
    project in 2014\. Google has been a pioneer, having run its services in containers
    already for more than a decade by that time, and the release of Kubernetes triggered
    another small revolution in the industry. By that time, many businesses had realized
    the benefits of using containers and were in need of a solution that would simplify
    container orchestration at scale. Kubernetes turned out to be this solution, as
    we will see soon.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 最初由 Google 开发，并于 2014 年作为开源项目发布。当时，Google 早已运行其服务于容器中超过十年，并且 Kubernetes
    的发布引发了行业的另一场小革命。那时，许多企业已经意识到使用容器的好处，并需要简化大规模容器编排的解决方案。正如我们即将看到的，Kubernetes 成为了这个解决方案。
- en: Kubernetes (K8s)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes（K8s）
- en: Kubernetes is an open source platform for container orchestration. Kubernetes
    features an extensible and declarative API that allows you to automatically reach
    the desired state of resources. It allows flexible scheduling, autoscaling, rolling
    update, and self-healing of container-based payloads.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个用于容器编排的开源平台。Kubernetes 具有可扩展和声明式 API，允许您自动达到资源的期望状态。它支持灵活的调度、自动扩展、滚动更新和基于容器的负载自愈。
- en: (Online and in documentation, a shorter abbreviation, K8s, can often be encountered
    – where eight is the number of letters between “K” and “s”.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: （在线和文档中，经常可以遇到更短的缩写 K8s —— 其中八是“K”和“s”之间字母的数量。）
- en: Kubernetes has inherited many of its features and best ideas from Borg – an
    internal container cluster management system powering thousands of different applications
    at Google. Many Borg engineers participated in the development of Kubernetes and
    were able to address relevant pain points based on their experience of operating
    a huge fleet of containers over the years.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 继承了许多来自 Borg 的特性和最佳理念 —— Borg 是 Google 的一个内部容器集群管理系统，多年来支持运行数千个不同的应用程序。许多
    Borg 工程师参与了 Kubernetes 的开发，并能够根据多年运营大规模容器的经验来解决相关痛点。
- en: Soon after its initial release, Kubernetes rapidly gained the attention of the
    open source community and attracted many talented contributors from all over the
    world. Today, Kubernetes is among the top three biggest open source projects on
    GitHub ([https://github.com/kubernetes](https://github.com/kubernetes)) with more
    than 80,000 stars and 3,000 contributors. It was also the first project to graduate
    from the **Cloud Native Computing Foundation** (**CNCF**), a non-profit organization
    that split off from the Linux Foundation created with the goal of advancing container
    and cloud-native technologies.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在初版发布后不久，Kubernetes 迅速吸引了开源社区的注意，并吸引了来自全球各地的许多才华横溢的贡献者。今天，Kubernetes 是 GitHub
    上三大最大的开源项目之一（[https://github.com/kubernetes](https://github.com/kubernetes)），拥有超过
    80,000 个星和 3,000 名贡献者。它还是第一个从**云原生计算基金会**（**CNCF**）毕业的项目，CNCF 是一个从 Linux 基金会分拆出来的非营利组织，旨在推动容器和云原生技术的发展。
- en: One of the most important features of Kubernetes is the concept of the desired
    state. Kubernetes operates in a way where we define the state of the application
    containers we want to have, and Kubernetes will automatically ensure the state
    is reached. Kubernetes constantly observes the state of all deployed containers
    and makes sure this state matches what we’ve requested.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 最重要的特性之一是期望状态的概念。Kubernetes 的运行方式是我们定义所需的应用程序容器状态，Kubernetes 将自动确保达到这个状态。Kubernetes
    不断观察所有部署容器的状态，并确保此状态与我们请求的一致。
- en: 'Let’s consider the following example. Imagine that we run a simple microservice-based
    application on Kubernetes cluster with three hosts. We define a specification
    that requires Kubernetes to run these:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例。假设我们在具有三个主机的 Kubernetes 集群上运行一个简单的微服务应用程序。我们定义了一个规格，要求 Kubernetes
    运行以下内容：
- en: Two identical containers for the frontend
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个相同的前端容器
- en: Three identical containers for the backend
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个相同的后端容器
- en: Two containers with volumes serving the data persistence
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个用于数据持久化的容器
- en: Unexpectedly, one of the three hosts fails, and two containers running on the
    frontend and backend become unavailable. Kubernetes observes the changed number
    of hosts in the cluster and reduced number of containers responsible for the frontend
    and the backend. Kubernetes automatically starts one frontend and one backend
    container on the other two operational hosts to bring the system back to its desired
    state. This process is known as **self-healing**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，三个主机中的一个发生故障，导致在前端和后端上运行的两个容器不可用。Kubernetes 会观察到集群中主机的数量变化以及前端和后端容器的数量减少。Kubernetes
    会自动在另外两个运行中的主机上启动一个前端容器和一个后端容器，将系统恢复到预期状态。这个过程被称为**自我修复**。
- en: Kubernetes can do way more than scheduling and restarting failed containers
    – we can also define a Kubernetes specification that requires the number of microservice
    containers to automatically increase based on the current demand. For example,
    in the preceding example, we can specify that with an increased workload, we want
    to run five replicas of the frontend and five replicas of the backend. Alternatively,
    in case of low application demand, we can automatically decrease the number of
    each microservice containers to two. This process is known as **autoscaling**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 能做的不仅仅是调度和重启失败的容器——我们还可以定义一个 Kubernetes 规格，要求根据当前的需求自动增加微服务容器的数量。例如，在前面的例子中，我们可以指定，在工作负载增加时，我们希望运行五个前端副本和五个后端副本。或者，在应用需求低时，我们可以自动将每个微服务容器的数量减少到两个。这个过程被称为**自动扩缩**。
- en: This example demonstrates the basic capabilities of Kubernetes. In *Part 3*,
    we will explore more Kubernetes features and try some of them firsthand.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了 Kubernetes 的基本功能。在*第3部分*，我们将深入探索更多 Kubernetes 特性，并亲自尝试其中的一些功能。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While being a container orchestrator, Kubernetes does not have its own container
    runtime. Instead, it has integration with popular container runtimes such as *containerd*
    and can work with multiple runtimes within a Kubernetes cluster.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然作为一个容器编排工具，Kubernetes 本身并没有容器运行时。相反，它与流行的容器运行时（如*containerd*）集成，并且可以在 Kubernetes
    集群内与多个运行时一起工作。
- en: You often see references to Kubernetes clusters because a typical Kubernetes
    installation will be used to manage hundreds of containers spread across multiple
    hosts. Single-host Kubernetes installations are only suitable for learning or
    local development, but not for production usage.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到 Kubernetes 集群的相关内容，因为一个典型的 Kubernetes 安装会被用来管理分布在多个主机上的数百个容器。单主机的 Kubernetes
    安装仅适合用于学习或本地开发，而不适用于生产环境。
- en: To sum up, Kubernetes has laid down the path for massive container adoption
    and is a thriving open source ecosystem that is still growing with new projects
    graduating from the CNCF every year. In this book, we will cover the Kubernetes
    API, components, resources, features, and operational aspects in depth, and learn
    more about projects that can be used with Kubernetes to extend its functionality.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Kubernetes 为大规模容器的采用铺平了道路，并且它是一个蓬勃发展的开源生态系统，每年都有新的项目从CNCF毕业。在本书中，我们将深入探讨
    Kubernetes 的 API、组件、资源、功能和操作方面，并了解更多可以与 Kubernetes 一起使用以扩展其功能的项目。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about the concepts of the cloud and containers,
    and the evolution of computing over the last 20 to 30 years. In the era before
    the cloud, traditional deployments with one or a few applications per physical
    server caused a lot of inefficiency and wasted resources with underutilized hardware
    and high costs of ownership.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了云计算和容器的概念，以及过去20到30年计算领域的演变。在云计算时代之前，传统的部署方式将一个或少量应用程序部署在每台物理服务器上，这导致了很多低效和资源浪费，硬件利用率低且拥有成本高。
- en: When virtualization technologies came along, it became possible to run many
    applications per physical server using VMs. This addressed the pitfalls of traditional
    deployments and allowed us to deliver new applications more quickly and with significantly
    lower costs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当虚拟化技术出现时，使用虚拟机（VMs）可以在一个物理服务器上运行多个应用程序。这解决了传统部署的缺陷，并且能够更快速且成本显著降低地交付新应用程序。
- en: 'Virtualization paved the way for the cloud services that are delivered via
    four different models today: IaaS, PaaS, SaaS, and FaaS or Serverless. Customer
    responsibilities differ by cloud service and delivery model.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化为通过四种不同模型提供的云服务铺平了道路：IaaS、PaaS、SaaS和FaaS或无服务器。根据云服务和交付模型，客户的责任有所不同。
- en: This progress never stopped – now, cloud-native as an approach to building and
    running applications has emerged. Cloud-native applications are designed and built
    with an emphasis on scalability, resilience, ease of management, and a high degree
    of automation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种进步从未停止——现在，云原生作为一种构建和运行应用程序的方法已经出现。云原生应用程序设计和构建时强调可扩展性、弹性、易管理性和高度自动化。
- en: Over recent years, container technology has developed and gained momentum. Containers
    use virtualization at the OS level and each container represents a virtual OS
    environment. Containers are faster, more efficient, and more portable compared
    to VMs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，容器技术发展迅速并获得了动力。容器在操作系统级别使用虚拟化，每个容器代表一个虚拟操作系统环境。与VM相比，容器更快速、更高效、更具可移植性。
- en: Containers enabled us to develop and manage modern applications based on a microservices
    architecture. Microservices were a step ahead compared to traditional monoliths
    – *all-in-one,* *behemoth* applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使我们能够基于微服务架构开发和管理现代应用程序。与传统的单体应用程序相比，微服务更先进——*一体化*、*巨兽*应用程序。
- en: While containers are one of the most efficient ways to run cloud-native applications,
    it becomes hard to manage large numbers of containers. Therefore, containers are
    best managed using an orchestrator such as Kubernetes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器是运行云原生应用程序最有效的方式之一，但难以管理大量容器。因此，最好使用像Kubernetes这样的编排器来管理容器。
- en: Kubernetes is an open source container orchestration system that originated
    from Google and automates many operational aspects of containers. Kubernetes will
    schedule, start, stop, and restart containers and increase or decrease the number
    of containers based on the provided specification automatically. Kubernetes makes
    it possible to implement self-healing and autoscaling based on the current demand.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一种开源容器编排系统，起源于Google，自动化容器的许多运维方面。Kubernetes将根据提供的规格自动安排、启动、停止和重新启动容器，并根据当前需求增加或减少容器数量。Kubernetes使得实施自愈和根据当前需求自动扩展成为可能。
- en: Questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'At the end of each chapter, you’ll find recap questions that allow to test
    your understanding. Questions might have multiple correct answers. Correct answers
    can be found in the *Assessment* section of the *Appendix*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在每章末尾，您将找到总结性问题，以测试您的理解。问题可能有多个正确答案。正确答案可在*附录*的*评估*部分找到：
- en: Which of the following describes traditional deployments on physical servers
    (pick two)?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项描述了物理服务器上的传统部署方式（选两个）？
- en: Easy maintenance
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简易维护
- en: Underutilized hardware
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未充分利用的硬件
- en: Low energy consumption
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低能耗
- en: High upfront costs
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高前期成本
- en: Which advantages do VMs have compared to containers?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VM相比容器有哪些优势？
- en: They are more reliable
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们更可靠
- en: They are more portable
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们更具可移植性
- en: They are more secure
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们更安全
- en: They are more lightweight
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们更轻量级
- en: What describes the difference between VMs and containers (pick two)?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述VM和容器之间差异的是哪两个（选两个）？
- en: VM images are small and container images are large
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: VM镜像较小而容器镜像较大
- en: VM images are large and container images are small
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: VM镜像较大而容器镜像较小
- en: VMs share the OS kernel and containers don’t
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: VMs共享操作系统内核而容器不共享
- en: Containers share the OS kernel and VMs don’t
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器共享操作系统内核而VMs不共享
- en: At which level do containers operate?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器在哪个层级操作？
- en: The orchestrator level
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编排器层级
- en: The hypervisor level
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟化层级
- en: The programming language level
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程语言层级
- en: The OS level
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统级别
- en: What is typically included in a container image (pick two)?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器镜像通常包含以下哪两个内容（选两个）？
- en: An OS kernel
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统内核
- en: A minimal set of OS libraries and packages
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个最小化的OS库和软件包集合
- en: A graphical desktop environment
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图形化桌面环境
- en: A packaged microservice
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个打包的微服务
- en: Which advantages do containers have compared to VMs (pick multiple)?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与虚拟机相比，容器有哪些优势（选择多个）？
- en: They are more secure
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们更安全
- en: They are more lightweight
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们更轻量
- en: They are more portable
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们更具可移植性
- en: They are faster to start
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动速度更快
- en: Which software is needed to start and run containers?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动和运行容器需要哪些软件？
- en: A container runtime
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器运行时
- en: A hypervisor
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个虚拟机监控程序
- en: Kubernetes
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: VirtualBox
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: VirtualBox
- en: Which of the following can be used to orchestrate containers?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些可以用于编排容器？
- en: containerd
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: containerd
- en: CRI-O
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRI-O
- en: Kubernetes
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Serverless
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器
- en: Which of the following is a cloud service delivery model (pick multiple)?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是云服务交付模型（选择多个）？
- en: IaaS, PaaS
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: IaaS, PaaS
- en: SaaS, FaaS
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SaaS, FaaS
- en: DBaaS
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: DBaaS
- en: Serverless
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器
- en: Which of the following statements about cloud-native is true?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于云原生的说法哪一项是正确的？
- en: It is an architectural approach
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一种架构方法
- en: It is the same as a cloud provider
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它与云提供商相同
- en: It is similar to cloud-first
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它类似于云优先
- en: It is software that only runs in the cloud
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是仅在云中运行的软件
- en: Which of the following descriptors applies to cloud-native applications (pick
    two)?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些描述适用于云原生应用程序（选择两个）？
- en: High degree of automation
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高度自动化
- en: High scalability and resiliency
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高可扩展性和高韧性
- en: Can only run in a private cloud
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只能在私有云中运行
- en: Can only run in a public cloud
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只能在公有云中运行
- en: Which of the following statements is true about monolithic applications?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于单体应用程序的说法哪一项是正确的？
- en: They are easy to update
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们容易更新
- en: Their components communicate with each other over the network
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们的组件通过网络相互通信
- en: They include all the business logic and interfaces
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们包含所有的业务逻辑和接口
- en: They can be scaled easily
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们可以轻松扩展
- en: Which of the following statements is true for microservices (pick multiple)?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些关于微服务的说法是正确的（选择多个）？
- en: They can only be used for the backend
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们只能用于后端
- en: They work together as a part of a bigger application
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们作为更大应用的一部分协同工作
- en: They can be developed by multiple teams
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们可以由多个团队开发
- en: They can be deployed independently
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们可以独立部署
- en: Which of the following can be done with Kubernetes (pick multiple)?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些可以通过 Kubernetes 完成（选择多个）？
- en: Self-healing in case of failure
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故障时自我修复
- en: Autoscaling containers
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动扩展容器
- en: Spawning VMs
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动虚拟机
- en: Scheduling containers on different hosts
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同主机上调度容器
- en: Which project served as an inspiration for Kubernetes?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个项目为 Kubernetes 提供了灵感？
- en: OpenStack
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenStack
- en: Docker
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker
- en: Borg
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Borg
- en: OpenShift
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenShift
