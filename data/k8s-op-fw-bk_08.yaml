- en: '*Chapter 6*: Building and Deploying Your Operator'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：构建和部署您的 Operator'
- en: 'At this point, we have written a significant amount of code to develop an `make`
    command provided by a boilerplate Operator SDK project to build a container image
    and manually deploy that image in a running Kubernetes cluster. In addition, this
    chapter will follow up those steps with guided steps for iterative development
    in which new changes in the Operator are compiled and pushed to the cluster. Finally,
    we will offer troubleshooting resources and tips for issues that may arise during
    this process. Those sections will be broken into the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了大量代码，以便开发由基础模板 Operator SDK 项目提供的 `make` 命令，用于构建容器镜像并手动将该镜像部署到正在运行的
    Kubernetes 集群中。此外，本章将继续跟进这些步骤，提供迭代开发的指导步骤，其中 Operator 中的更改将被编译并推送到集群中。最后，我们将提供故障排除资源和在此过程中可能遇到的问题的解决建议。这些部分将分为以下内容：
- en: Building a container image
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Deploying in a test cluster
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试集群中进行部署
- en: Pushing and testing changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送和测试变更
- en: Troubleshooting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除
- en: Note that during the course of this chapter, running the Operator in a cluster
    will be done manually using local build commands. This is useful for local development
    and testing in non-production environments because it is quick and does not rely
    on additional components, minimizing the time and resources required to deploy
    proof-of-concept test cases. In a real environment, it is better to install and
    manage Operators with the **Operator Lifecycle Manager**. That process will be
    covered in more detail in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*. For now,
    we will proceed with local deployments in a test cluster.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章过程中，将使用本地构建命令手动运行 Operator。对于本地开发和非生产环境中的测试，这是非常有用的，因为它快速且不依赖于额外的组件，最大限度地减少了部署概念验证测试用例所需的时间和资源。在实际环境中，最好使用**Operator
    生命周期管理器**来安装和管理 Operator。这个过程将在[*第 7 章*](B18147_07_ePub.xhtml#_idTextAnchor108)中更详细地介绍，标题为
    *使用 Operator 生命周期管理器安装和运行 Operator*。现在，我们将继续在测试集群中进行本地部署。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will rely on the code from previous chapters to build a container
    image and deploy that image in a Kubernetes cluster. As such, the technical requirements
    for this chapter necessitate access to a cluster and container management tool
    such as Docker. However, it is not explicitly required to use the code from the
    previous chapters, as the commands and processes explained will work with any
    `operator-sdk` project. Therefore, the minimum recommended requirements for this
    chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将依赖前几章的代码来构建容器镜像，并将该镜像部署到 Kubernetes 集群中。因此，本章的技术要求需要访问一个集群和像 Docker 这样的容器管理工具。然而，使用前几章的代码并非强制要求，因为所解释的命令和过程适用于任何
    `operator-sdk` 项目。因此，本章的最低推荐要求如下：
- en: An internet connection (to pull Docker base images and push built container
    images to a public registry).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接（用于拉取 Docker 基础镜像并将构建好的容器镜像推送到公共注册表）。
- en: Access to a running Kubernetes cluster. This can be any cluster, although it
    is recommended to use a tool such as **Kubernetes in Docker** (**kind**) ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
    or **minikube** ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    so that it is not costly to destroy and recreate clusters if needed.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问一个运行中的 Kubernetes 集群。这可以是任何集群，尽管推荐使用像 **Kubernetes in Docker** (**kind**)
    ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)) 或 **minikube** ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    这样的工具，以便在需要时可以轻松销毁并重新创建集群。
- en: An up-to-date version of `kubectl` ([https://kubernetes.io/docs/tasks/tools/#kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl))
    on your machine (in order to interact with the Kubernetes cluster).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机上安装了最新版本的 `kubectl`（[https://kubernetes.io/docs/tasks/tools/#kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl)），用于与
    Kubernetes 集群进行交互。
- en: Docker installed locally, as well as an account on either `Makefile` that the
    Operator SDK generates in a project assumes that the `docker` binary will be available
    locally. Therefore, additional local setup (for example, aliasing `docker` commands
    to `buildah`), which is not covered in this chapter, will be necessary.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地安装了 Docker，并且在 `Makefile` 文件中生成的 Operator SDK 项目中假设 `docker` 二进制文件会在本地可用。因此，需要额外的本地设置（例如，将
    `docker` 命令别名为 `buildah`），本章不涉及这部分内容，但这是必须的。
- en: This chapter introduces several of the preceding projects, some of which involve
    additional setup. In addition, a few of them (such as kind) are described in this
    tutorial only for the purposes of creating a stock test environment to follow
    along with. In these cases, alternative tools can be used as noted if you are
    more comfortable with them. For each of the technologies introduced in this chapter,
    resources are provided in the *Troubleshooting* section at the end of this chapter
    for further assistance if needed. However, the use cases with a specific technology
    in this chapter have been chosen to be fairly basic to guide toward the minimal
    risk of technical problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了前面几个项目，其中一些需要额外的设置。此外，部分项目（例如 kind）在本教程中仅用于创建一个标准的测试环境以供跟随。在这些情况下，如果您对其他工具更为熟悉，可以按需选择。对于本章中介绍的每项技术，若有需要帮助的地方，本章末尾的
    *故障排除* 部分提供了更多资源。然而，本章中所选的技术使用案例相对简单，旨在指导您最大限度地减少技术问题的风险。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using a public registry without any access credentials will make your Operator
    image accessible to anyone on the internet. This may be fine for following a tutorial
    such as this, but for production images, you may wish to look more into securing
    your image registry (which is out of the scope of this book).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用没有任何访问凭证的公共注册表会使您的 Operator 镜像对互联网上的任何人开放。虽然对于像这样的教程来说可能没问题，但对于生产镜像，您可能希望进一步了解如何保护您的镜像注册表（这超出了本书的范围）。
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3NdVZ7s](https://bit.ly/3NdVZ7s)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的《Code in Action》视频可以在以下网址观看：[https://bit.ly/3NdVZ7s](https://bit.ly/3NdVZ7s)
- en: Building a container image
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Kubernetes is a container orchestration platform, meaning that it is designed
    to run applications that have been built into containers. Even the core system
    components for Kubernetes, such as the API server and scheduler, run as containers.
    So, it should come as no surprise that the Operators developed for Kubernetes
    must also be built and deployed as containers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个容器编排平台，意味着它被设计用来运行已经构建成容器的应用程序。即使是 Kubernetes 的核心系统组件，如 API 服务器和调度器，也以容器的形式运行。因此，Kubernetes
    开发的 Operators 也必须作为容器来构建和部署，这一点应该不足为奇。
- en: For this process, a basic understanding of the fundamentals of working with
    containers is helpful. Fortunately, however, the Operator SDK abstracts away much
    of the configuration and command-line incantations to simple `Makefile` targets.
    These are build macros that help to automate the process of compiling binaries
    and container images (as well as pushing those images to a registry and deploying
    them in a cluster).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个过程，了解容器操作的基础知识是有帮助的。然而，幸运的是，Operator SDK 抽象化了许多配置和命令行操作，通过简单的 `Makefile`
    目标进行处理。这些是构建宏，帮助自动化编译二进制文件和容器镜像的过程（以及将这些镜像推送到注册表并在集群中部署它们）。
- en: 'To see the full list of available targets provided by the Operator SDK, run
    the `make help` command within the project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Operator SDK 提供的所有可用目标列表，请在项目中运行 `make help` 命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some of these commands, such as `make manifests` and `make generate`, were used
    in earlier chapters to initialize the project and generate the Operator's API
    and `Build` heading. Specifically, `make build` and `make docker-build`, with
    the former responsible for compiling a local binary of the Operator and the latter
    building a container image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些命令，如 `make manifests` 和 `make generate`，在前面的章节中已经使用过，用于初始化项目并生成 Operator
    的 API 和 `Build` 头文件。具体来说，`make build` 和 `make docker-build`，前者负责编译 Operator 的本地二进制文件，后者则构建容器镜像。
- en: Building the Operator locally
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地构建 Operator
- en: 'First, let''s examine `make build`. From `Makefile`, the definition is simple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看 `make build`。从 `Makefile` 中，定义非常简单：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This target is primarily concerned with running `go build`, which is the standard
    command to compile any `make generate`, `make fmt`, and `make vet` targets, which
    ensure that the Operator's generated API code is up to date and that the Go code
    in the project's source code conforms to the stylistic standards of the language.
    This is an added convenience and is why `Makefile` targets such as this are useful
    in development.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目标主要涉及运行 `go build`，这是标准命令，用于编译任何 `make generate`、`make fmt` 和 `make vet`
    目标，这些目标确保 Operator 生成的 API 代码是最新的，并且项目源代码中的 Go 代码符合语言的风格标准。这是一个附加的便利，因此像这样的 `Makefile`
    目标在开发中非常有用。
- en: 'Running `make build` produces the standard output that one would expect when
    compiling a Go program:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `make build` 会生成编译 Go 程序时预期的标准输出：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the compilation is successful, there should be no more output than the
    preceding code. Upon completion, there will now be a new executable file under
    `bin/manager`, which is the compiled Operator code. This can be run manually (or
    with `make run`) against any accessible Kubernetes cluster, but it will not actually
    be deployed in the cluster until it is built into a container image. This is what
    `make docker-build` does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译成功时，输出不会超过前面的代码。完成后，`bin/manager` 下将会有一个新的可执行文件，这是编译后的 Operator 代码。可以手动运行该文件（或使用
    `make run`），并连接到任何可访问的 Kubernetes 集群，但在构建成容器镜像之前，它不会真正部署到集群中。这正是 `make docker-build`
    的作用。
- en: Building the Operator image with Docker
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker 构建 Operator 镜像
- en: 'The definition for `make docker-build` is slightly more interesting than the
    local `build` target:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`make docker-build` 的定义比本地的 `build` 目标稍微有趣一些：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is essentially just calling `docker build` (with an added dependency to
    make a test that runs any unit tests defined in the project along with ensuring
    all generated CRD manifests and API code are up to date).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是调用 `docker build`（并添加了一个依赖项，用于测试运行项目中定义的任何单元测试，同时确保所有生成的 CRD 清单和 API 代码都是最新的）。
- en: 'The `docker build` command will instruct the local Docker daemon to construct
    a container image from the Dockerfile in the root of the Operator''s project directory.
    This file was originally generated by the initial `operator-sdk init` command
    from when the project was first created. We have made a very slight modification
    (which will be explained here), so the file now looks like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 命令将指示本地 Docker 守护进程根据 Operator 项目目录根目录中的 Dockerfile 构建一个容器镜像。此文件最初由项目首次创建时的
    `operator-sdk init` 命令生成。我们做了一些微小的修改（将在此处解释），因此该文件现在看起来如下：'
- en: 'Dockerfile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that the exact details about how this Dockerfile works are a more advanced
    topic in regard to container builds. It''s not critical to understand each of
    these in depth (just one benefit of using the Operator SDK to generate the file!),
    but we will summarize them here. These steps roughly break down into the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于 Dockerfile 如何工作的详细细节是容器构建中更高级的话题。并不需要深入理解这些细节（这也是使用 Operator SDK 生成该文件的一个好处！），但我们会在此处做一个总结。大致的步骤如下：
- en: Set the base image for the Operator to build with Go 1.17.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Operator 构建的基础镜像为 Go 1.17。
- en: Copy the Go module dependency files to the new image.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Go 模块依赖文件复制到新镜像中。
- en: Download the module dependencies.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载模块依赖。
- en: Copy the main Operator code, including `main.go`, `api/`, `controllers/`, and
    `assets/` to the new image.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主 Operator 代码，包括 `main.go`、`api/`、`controllers/` 和 `assets/`，复制到新镜像中。
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In this project, we have modified the default Dockerfile to copy the `assets/`
    directory. When it is generated by `operator-sdk`, this Dockerfile only copies
    `main.go` and the `api/` and `controllers/` directories by default. Since the
    tutorial for our nginx Operator included adding a new top-level package under
    `assets/`, we need to ensure that this directory is also included in the Operator
    image. This serves as an example to demonstrate that it is okay to modify the
    project's default Dockerfile (however, using version control or otherwise making
    backups is recommended).
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此项目中，我们修改了默认的 Dockerfile 来复制 `assets/` 目录。当它由 `operator-sdk` 生成时，默认只会复制 `main.go`
    以及 `api/` 和 `controllers/` 目录。由于我们为 nginx Operator 编写的教程包括在 `assets/` 下添加一个新的顶级包，因此我们需要确保该目录也被包含在
    Operator 镜像中。这作为一个示例，展示了修改项目的默认 Dockerfile 是完全可以的（不过建议使用版本控制或其他方式进行备份）。
- en: Alternatively, the `assets` package could have been created under the `controllers/`
    folder, which would not have required any updates to the Dockerfile (because it
    would have been included under the existing `COPY controllers/ controllers/` line).
    See the *Troubleshooting* section of this chapter for more information.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，`assets` 包本可以在 `controllers/` 文件夹下创建，这样就不需要对 Dockerfile 做任何更新（因为它会被包括在现有的
    `COPY controllers/ controllers/` 行中）。有关更多信息，请参见本章的 *故障排除* 部分。
- en: Compile the Operator binary within the image. This is the same as building the
    Operator locally (as shown previously), except it will be packaged within a container.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在镜像内编译 Operator 二进制文件。这与在本地构建 Operator（如前所示）相同，只不过它将被打包进容器中。
- en: Define the Operator's binary as the main command for the built container.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将运算符的二进制文件定义为构建容器的主要命令。
- en: 'With the preceding Dockerfile (including the change to include `COPY assets/
    assets/`), running `make docker-build` will successfully complete. But, before
    we do that, first note that this command includes a variable that we have not
    yet discussed: `${IMG}`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述 Dockerfile（包括包含 `COPY assets/ assets/` 的更改），运行 `make docker-build` 将会成功完成。但在此之前，请首先注意，这个命令包含了一个我们尚未讨论的变量：`${IMG}`。
- en: 'The `Makefile` command uses this `IMG` variable to define the tag for the compiled
    image. That variable is defined earlier in `Makefile` with a default value of
    `controller:latest`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile` 命令使用这个 `IMG` 变量来定义编译后镜像的标签。该变量在 `Makefile` 中较早定义，默认值为 `controller:latest`：'
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is helpful to know because, without updating this variable, the built
    image for our Operator will simply have the name `controller`. In order to build
    an image with a tag that references our actual container registry (for example,
    `docker.io/myregistry`) the `build` command can be invoked like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点很有帮助，因为如果不更新此变量，我们为运算符构建的镜像将简单地命名为 `controller`。为了构建一个带有引用我们实际容器仓库的标签的镜像（例如，`docker.io/myregistry`），可以像这样调用
    `build` 命令：
- en: '[PRE31]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Some output has been omitted, but the important parts to note are the `builder`
    steps, which have been included. These follow the steps as defined in the project's
    Dockerfile.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 部分输出已被省略，但需要注意的重要部分是 `builder` 步骤，这些步骤已被包含。它们遵循项目 Dockerfile 中定义的步骤。
- en: 'With a container image successfully built, the new image should now be present
    on your local machine. You can confirm this by running `docker images`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 成功构建容器镜像后，新的镜像现在应该已经存在于您的本地机器上。您可以通过运行 `docker images` 来确认这一点：
- en: '[PRE32]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the next section, we will push this image to a public registry and deploy
    the Operator in a running Kubernetes cluster.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把这个镜像推送到公共镜像仓库，并在运行中的 Kubernetes 集群中部署运算符。
- en: Deploying in a test cluster
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试集群中部署
- en: Now that the Operator has been built into a container image, it can be deployed
    in a cluster as a container. To do this, you will first need to ensure that you
    have access to a running cluster as well as a public image registry. To host your
    image in a registry, you can obtain a free personal account on **Docker Hub**
    ([https://hub.docker.com](https://hub.docker.com)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运算符已经构建成容器镜像，可以作为容器部署到集群中。要做到这一点，首先需要确保你有访问运行中集群的权限，并且有一个公共镜像仓库。要将镜像托管在仓库中，您可以在
    **Docker Hub** 上获取一个免费的个人账户 ([https://hub.docker.com](https://hub.docker.com))。
- en: For this tutorial, we will be using a local Kubernetes cluster created with
    kind, which deploys a running Kubernetes cluster within Docker containers rather
    than directly on the local machine, and is available at [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/).
    However, the steps described here will be agnostic to any Kubernetes cluster running
    the latest version of the platform. For example, if you are more comfortable using
    development environments such as minikube (or have another cluster already available),
    then you can skip the kind setup shown in this section. The rest of the steps
    in this section will apply to any Kubernetes cluster.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用通过 kind 创建的本地 Kubernetes 集群，该集群在 Docker 容器中运行 Kubernetes 集群，而不是直接在本地机器上运行，您可以在
    [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/) 上访问该项目。然而，这里描述的步骤与任何运行最新版本平台的
    Kubernetes 集群无关。例如，如果您更喜欢使用像 minikube 这样的开发环境（或已经有其他集群可用），那么可以跳过本节中展示的 kind 设置。该节中的其余步骤将适用于任何
    Kubernetes 集群。
- en: 'To start a local cluster with kind, ensure that you have Docker and kind installed
    on your machine and run `kind create cluster`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 kind 启动本地集群，请确保在机器上已安装 Docker 和 kind，然后运行 `kind create cluster`：
- en: '[PRE33]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that `kind create cluster` may take a moment to complete. This bootstraps
    a functional Kubernetes cluster running within Docker. You can confirm that your
    cluster is accessible by running any `kubectl` command, for example, `kubectl
    cluster-info`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`kind create cluster` 可能需要一些时间才能完成。这会在 Docker 中引导一个功能正常的 Kubernetes 集群。您可以通过运行任何
    `kubectl` 命令来确认集群是否可访问，例如，运行 `kubectl cluster-info`：
- en: '[PRE34]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With a cluster running, it's time to make the Operator's image accessible by
    pushing it to a public registry. First, ensure that you have access to your registry.
    For Docker Hub, this means running `docker login` and entering your username and
    password.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 集群运行后，接下来是通过将镜像推送到公共镜像仓库来使运算符的镜像可访问。首先，确保您能够访问您的镜像仓库。对于 Docker Hub，这意味着运行 `docker
    login` 并输入您的用户名和密码。
- en: 'Once logged in, you can push the image using the provided `Makefile` `make
    docker-push` target (which is simply the equivalent of manually running `docker
    push`):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你可以使用提供的`Makefile`中的`make docker-push`目标来推送镜像（这相当于手动运行`docker push`）：
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: (This command may take a moment to run, and your exact output may differ.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: （此命令可能需要一些时间来运行，你的输出可能与示例略有不同。）
- en: 'Note that we have still passed the `IMG` variable to this command. To eliminate
    the need to do this, you can either modify `Makefile` to change the default definition
    of the variable (this definition was shown in the *Building a container image*
    section earlier) or export your image name as an environment variable, like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然将`IMG`变量传递给了此命令。为了避免这样做，你可以修改`Makefile`来更改变量的默认定义（该定义在*构建容器镜像*部分已展示），或将镜像名称作为环境变量导出，如下所示：
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, the image is available publicly on the internet. You may wish to manually
    confirm that your image is accessible by running `docker pull <image>`, but this
    is not required.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，镜像已公开可用。你可以通过运行`docker pull <image>`手动确认镜像是否可以访问，但这不是必须的。
- en: Avoiding Docker Hub
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用Docker Hub
- en: You technically do not have to use a public registry such as Docker Hub to make
    your image accessible to the cluster. There are alternative ways of importing
    your image into the cluster, for example, kind provides the `kind load docker-image`
    command, which manually loads the image into your cluster's internal registry
    (see [https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster](https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster)
    for more information). However, in this tutorial, we have chosen the public registry
    route as it is a common approach (especially for open source Operators that are
    published for others to use) and remains agnostic to the specific cluster you
    may be running.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你不必使用像Docker Hub这样的公共注册表来使镜像对集群可访问。还有其他方式将镜像导入到集群中，例如，kind提供了`kind load
    docker-image`命令，可以将镜像手动加载到集群的内部注册表中（有关更多信息，请参阅[https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster](https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster)）。不过，在本教程中，我们选择了公共注册表方式，因为这是一个常见的方法（特别是对于公开发布供他人使用的开源Operator）且与运行的具体集群无关。
- en: 'With the Operator image accessible (and the public image name defined in an
    environment variable or modified in `Makefile`, as shown earlier), all that is
    required to run the Operator in a cluster now is the `make deploy` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Operator镜像可访问（且公共镜像名称已在环境变量中定义或如前所述在`Makefile`中修改）之后，现在只需运行`make deploy`命令即可在集群中运行Operator：
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you will see a new namespace in your cluster that matches the Operator''s
    name:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在集群中看到一个与Operator名称匹配的新命名空间：
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Exploring this namespace deeper with `kubectl get all` will show that it contains
    a **Deployment**, **ReplicaSet**, **Service**, and **Pod** for the Operator (some
    output has been omitted for brevity):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl get all`深入探索此命名空间将显示其中包含了Operator的**Deployment**、**ReplicaSet**、**Service**和**Pod**（部分输出已省略以简洁呈现）：
- en: '[PRE39]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But where is the operand nginx Pod? Recall that we designed the Operator to
    do nothing if it cannot locate an instance of its CRD. To remedy this, you can
    create your first CRD object (matching the API defined in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*) like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是操作数nginx Pod在哪里呢？回想一下，我们设计Operator时，如果找不到其CRD实例，它将什么也不做。为了解决这个问题，你可以像下面这样创建第一个CRD对象（符合[*第4章*](B18147_04_ePub.xhtml#_idTextAnchor066)中定义的API，*使用Operator
    SDK开发Operator*）：
- en: 'sample-cr.yaml:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: sample-cr.yaml：
- en: '[PRE40]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create this file and save it anywhere on your machine as any name (in this
    case, `sample-cr.yaml` is fine). Then, run `kubectl create -f sample-cr.yaml`
    to create the custom resource object in the nginx Operator''s namespace. Now,
    running `kubectl get pods` will show that the new nginx Pod (named `cluster-xxx`)
    has been created:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此文件并将其保存为任何名称（在此例中，`sample-cr.yaml`即可）。然后，运行`kubectl create -f sample-cr.yaml`来在nginx
    Operator的命名空间中创建自定义资源对象。现在，运行`kubectl get pods`将显示新创建的nginx Pod（命名为`cluster-xxx`）：
- en: '[PRE47]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can modify the custom resource object you just created with `kubectl edit
    nginxoperators/cluster -n nginx-operator-system`. This command (`kubectl edit`)
    will open your local text editor where you can make changes directly to the object''s
    `spec` fields. For example, to change the number of operand replicas, we can run
    the preceding command and set `spec.replicas: 2`, like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以使用 `kubectl edit nginxoperators/cluster -n nginx-operator-system` 修改刚刚创建的自定义资源对象。此命令（`kubectl
    edit`）将打开本地文本编辑器，您可以直接修改对象的 `spec` 字段。例如，要更改操作数副本的数量，可以运行前面的命令并设置 `spec.replicas:
    2`，如下所示：'
- en: $ kubectl edit nginxoperators/cluster -n nginx-operator-system
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl edit nginxoperators/cluster -n nginx-operator-system
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Notice that when using `kubectl edit`, other fields in the Operator (such as
    `status`) are also visible. While you cannot directly modify these fields, this
    is a good spot to point out that our Operator conditions are successfully reporting
    in the CRD''s `status` section. This is indicated by the `OperatorDegraded: False`
    condition type and status.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，使用`kubectl edit`时，Operator中的其他字段（如`status`）也可见。虽然无法直接修改这些字段，但这是一个很好的地方，可以指出我们的
    Operator 条件已成功报告在 CRD 的 `status` 部分。通过 `OperatorDegraded: False` 条件类型和状态可以看出这一点。'
- en: However, take note that this condition may initially be confusing to users because
    it appears to be indicating that `OperatorSucceeded` is `False` at first glance.
    But, upon further inspection, it is indicated that `OperatorSucceeded` is actually
    the reason for `OperatorDegraded` to be `False`. In other words, the *Operator*
    is *not* degraded because the Operator *succeeded*. This example has intentionally
    been chosen to highlight the care that must be taken to implement informative
    and clearly understandable status conditions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，这个条件最初可能会让用户感到困惑，因为它似乎表明 `OperatorSucceeded` 是 `False`。但经过进一步检查后，可以看出
    `OperatorSucceeded` 实际上是 `OperatorDegraded` 为 `False` 的原因。换句话说，*Operator* 并未 *降级*，因为
    Operator *成功* 了。这个例子被特意选择出来，强调在实现具有信息量且易于理解的状态条件时必须小心。
- en: 'Saving the changes to the CRD object and running `kubectl get` pods again now
    shows a new nginx Pod:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 保存对 CRD 对象的更改后，再次运行 `kubectl get` pods 现在会显示一个新的 nginx Pod：
- en: '[PRE66]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Similarly, changing the `spec.replicas` field to `0` will delete all of the
    nginx Pods:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，将 `spec.replicas` 字段更改为 `0` 将删除所有 nginx Pods：
- en: '[PRE67]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This concludes the basic deployment steps for an Operator. The following steps
    summarize what we have done so far:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 Operator 的基本部署步骤。以下步骤总结了我们迄今为止所做的工作：
- en: Built a container image for the Operator
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Operator 构建了容器镜像
- en: Pushed the image to a public registry
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到公共注册表
- en: Used `make deploy` to launch the Operator in a local cluster (in the process,
    pulling the image from the public registry into the cluster)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`make deploy`在本地集群中启动 Operator（在此过程中，将镜像从公共注册表拉取到集群中）
- en: Manually created an instance of the Operator's CRD object
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动创建了 Operator 的 CRD 对象实例
- en: Modified the CRD object within the cluster using `kubectl edit`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl edit` 修改了集群中的 CRD 对象
- en: However, there is still some work to be done in order to enable metrics (which
    was a big part of the work done in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*, and key to achieving higher-level
    functionality within the **capability model**). In the next section, we will demonstrate
    how to make changes to our Operator's deployment and redeploy it in the cluster.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然需要一些工作来启用指标（这也是在[*第5章*](B18147_05_ePub.xhtml#_idTextAnchor078)《开发 Operator
    – 高级功能》中的一个重要部分，并且是实现 **能力模型** 中更高级功能的关键）。在下一部分中，我们将展示如何修改我们的 Operator 部署并重新部署到集群中。
- en: Pushing and testing changes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送并测试更改
- en: During the course of development (for any project, not just Kubernetes Operators)
    it will likely become necessary to make changes to the code or other project files
    (such as resource manifests) and test those changes. In the case of this example,
    we will not be changing any code. Instead, we will redeploy the Operator with
    the proper metrics resources created to make the metrics visible, which we implemented
    in [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an Operator
    – Advanced Functionality*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中（无论是任何项目，不仅仅是 Kubernetes Operator），可能需要对代码或其他项目文件（如资源清单）进行更改并测试这些更改。在此示例中，我们不会更改任何代码。相反，我们将重新部署
    Operator，并创建正确的指标资源以使指标可见，这一点我们在 [*第5章*](B18147_05_ePub.xhtml#_idTextAnchor078)《开发
    Operator – 高级功能》中实现了。
- en: Installing and configuring kube-prometheus
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 kube-prometheus
- en: Metrics are not very useful without a tool to scrape and present them. This
    is what Prometheus is for, and it understands the metrics language in which we
    have implemented our own metrics. There are a number of other tools that can parse
    Prometheus metrics. In this tutorial, we will use **kube-prometheus** ([https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus))
    to install a full end-to-end monitoring stack in our cluster. kube-prometheus
    provides a number of additional features that we won't explicitly explore in this
    book, but it is a very convenient and powerful library for installing monitoring
    in a cluster. In your own environment, you may choose another option, such as
    installing Prometheus directly or using the Prometheus Operator from [https://github.com/prometheus-operator/prometheus-operator](https://github.com/prometheus-operator/prometheus-operator)
    (which is provided by kube-prometheus).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有工具来抓取和展示指标，指标是没有多大用处的。这正是 Prometheus 的作用，它理解我们所实现的自定义指标语言。还有许多其他工具可以解析 Prometheus
    指标。在本教程中，我们将使用 **kube-prometheus** ([https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus))
    来安装一个完整的端到端监控栈到我们的集群中。kube-prometheus 提供了许多额外的功能，虽然我们在本书中不会专门探讨它们，但它是安装监控的一个非常方便和强大的库。在您的环境中，您可以选择其他选项，比如直接安装
    Prometheus，或者使用来自 [https://github.com/prometheus-operator/prometheus-operator](https://github.com/prometheus-operator/prometheus-operator)
    的 Prometheus Operator（由 kube-prometheus 提供）。
- en: 'To get started, follow the steps at [https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus)
    installing to install kube-prometheus in our Operator project. Take note of the
    prerequisites for the *Installing* and *Compiling* sections in that link. Specifically,
    the following tools are required:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，按照 [https://github.com/prometheus-operator/kube-prometheus](https://github.com/prometheus-operator/kube-prometheus)
    中的步骤进行操作，安装 kube-prometheus 到我们的 Operator 项目中。请注意链接中的 *安装* 和 *编译* 部分的前提条件。具体来说，以下工具是必需的：
- en: '`jb`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jb`'
- en: '`gojsontoyaml`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gojsontoyaml`'
- en: '`jsonnet`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonnet`'
- en: 'When kube-prometheus has been successfully installed in the project, we will
    have a new subdirectory (`my-kube-prometheus`, as described in the kube-prometheus
    documentation), which contains the following files:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当 kube-prometheus 成功安装到项目中后，我们将拥有一个新的子目录（`my-kube-prometheus`，如 kube-prometheus
    文档中所述），该目录包含以下文件：
- en: '[PRE68]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we will modify `example.jsonnet` to include our Operator''s namespace.
    This means modifying the `values+::` block within the file to add a `prometheus+`
    object that includes a list of namespaces (in our case, only the `nginx-operator-system`
    namespace):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改 `example.jsonnet` 来包含我们的 Operator 命名空间。这意味着要修改文件中的 `values+::` 块，添加一个包含命名空间列表（在我们的例子中，只有
    `nginx-operator-system` 命名空间）的 `prometheus+` 对象：
- en: 'my-kube-prometheus/example.jsonnet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'my-kube-prometheus/example.jsonnet:'
- en: '[PRE69]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, use `build.sh` to compile the new manifests by running the following
    command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `build.sh` 通过运行以下命令来编译新的清单：
- en: '[PRE83]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, we can create the `kube-prometheus` manifests in our cluster by applying
    them with the following commands (from within the `my-kube-prometheus` directory):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下命令（在 `my-kube-prometheus` 目录内）将 `kube-prometheus` 清单应用到集群中：
- en: '[PRE84]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When finished, the Prometheus dashboard should be accessible by running the
    following commands to open a local proxy to your cluster and the Prometheus service:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以通过运行以下命令打开本地代理到您的集群和 Prometheus 服务，从而访问 Prometheus 仪表板：
- en: '[PRE85]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: (Note, this command will remain running until you manually end it, for example,
    by pressing *Ctrl* + *C*.) The dashboard will be visible by navigating to `http://localhost:9090`
    in your web browser. However, if you try to search for our Operator's metric (recall
    that it was named `reconciles_total`), you will see that it is not available.
    This is because we need to redeploy our Operator with an additional manifest that
    is not created by default.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，这个命令将保持运行状态，直到您手动结束它，例如按 *Ctrl* + *C*。）您可以通过在 Web 浏览器中导航到 `http://localhost:9090`
    来查看仪表板。然而，如果您尝试搜索我们的 Operator 的指标（记得它被命名为 `reconciles_total`），您会发现它不可用。这是因为我们需要使用一个额外的清单重新部署
    Operator，而这个清单在默认情况下不会被创建。
- en: Redeploying the Operator with metrics
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指标重新部署 Operator
- en: Prometheus knows to scrape our Operator's namespace for metrics due to the configuration
    created previously. However, it still needs to know which specific endpoint within
    the namespace to query. This is the role of an object called `ServiceMonitor`
    ([https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor](https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor)).
    This object is not created by default by the Operator SDK when running `make deploy`,
    so we need to modify `config/default/kustomization.yaml`. (This file location
    is relative to the project root directory, not the new `my-kube-prometheus` directory
    that we created previously when installing kube-prometheus).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus通过之前创建的配置知道从我们的Operator命名空间抓取指标。然而，它仍然需要知道命名空间内具体要查询的端点。这是名为`ServiceMonitor`的对象的作用（[https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor](https://pkg.go.dev/github.com/coreos/prometheus-operator/pkg/apis/monitoring/v1#ServiceMonitor)）。这个对象在运行`make
    deploy`时并不会由Operator SDK默认创建，因此我们需要修改`config/default/kustomization.yaml`。（该文件位置相对于项目根目录，而不是我们之前在安装kube-prometheus时创建的`my-kube-prometheus`目录）。
- en: 'In this file, simply find any lines that are marked with `[PROMETHEUS]` and
    uncomment them by removing the leading pound or the hash symbol (`#`). This is
    currently only one line, shown in the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，只需找到标记为`[PROMETHEUS]`的行，并通过删除前面的井号或哈希符号（`#`）来取消注释。当前只有一行，如下所示：
- en: 'config/default/kustomization.yaml:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: config/default/kustomization.yaml：
- en: '[PRE86]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is the default configuration file for **Kustomize** ([https://kustomize.io/](https://kustomize.io/)),
    which is a Kubernetes templating project that the Operator SDK uses to generate
    and deploy project manifests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**Kustomize**的默认配置文件（[https://kustomize.io/](https://kustomize.io/)），Kustomize是一个Kubernetes模板项目，Operator
    SDK使用它来生成和部署项目清单。
- en: 'At this point, you can run `make undeploy` to remove the current Operator installation,
    followed by running `make deploy` once again to recreate it. After a few moments,
    the `reconciles_total` metric should be visible in the Prometheus dashboard. The
    following screenshot shows this metric in the Prometheus dashboard search bar:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以运行`make undeploy`来移除当前的Operator安装，然后再次运行`make deploy`重新创建它。几秒钟后，`reconciles_total`指标应该会出现在Prometheus仪表盘中。以下截图展示了此指标在Prometheus仪表盘搜索栏中的样子：
- en: '![Figure 6.1 – Screenshot of the Prometheus dashboard](img/B18147_06_001.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – Prometheus仪表盘截图](img/B18147_06_001.jpg)'
- en: Figure 6.1 – Screenshot of the Prometheus dashboard
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – Prometheus仪表盘截图
- en: Key takeaways
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要收获
- en: 'While this section may seem focused on just setting up metrics, it actually
    covers some important steps related to the development-driven redeployment of
    an Operator project. Specifically, we covered the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节似乎专注于设置指标，但实际上它涵盖了一些与开发驱动的Operator项目重新部署相关的重要步骤。具体来说，我们涵盖了以下内容：
- en: Installing `kube-prometheus` as a library in our project and configuring it
    to scrape our Operator's namespace
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`kube-prometheus`作为库安装到我们的项目中，并配置它以抓取我们Operator的命名空间
- en: Modifying Kustomize configuration files to include new dependencies in our Operator
    deployment
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改Kustomize配置文件，以便在我们的Operator部署中包含新的依赖项
- en: Using `make undeploy` to remove the existing Operator deployment
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`make undeploy`来移除现有的Operator部署
- en: Technically, we could have simply run `make deploy` without first undeploying
    the project. The idempotent nature of Kubernetes resource manifests means that
    only the new resources would have been created. However, awareness of `make undeploy`
    is very useful in cases where the existing project may need to be completely removed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们本可以直接运行`make deploy`，而无需先卸载项目。Kubernetes资源清单的幂等性意味着只有新资源会被创建。然而，在需要完全移除现有项目的情况下，了解`make
    undeploy`非常有用。
- en: Troubleshooting
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: This chapter introduced several new tools and concepts not yet covered by earlier
    chapters. These include Docker, kind, kubectl, Make, and kube-prometheus. It is
    possible that you may have run into some issues while working with these tools,
    so this section is intended to offer links to references that can help resolve
    common issues. Many of the underlying tools used in this chapter are not exclusive
    to the Operator Framework, which thankfully means that there is a wealth of resources
    available to address problems you may encounter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几个新工具和概念，这些内容在前面的章节中尚未涉及。它们包括Docker、kind、kubectl、Make和kube-prometheus。你可能在使用这些工具时遇到了一些问题，因此本节旨在提供一些参考链接，帮助解决常见问题。本章中使用的许多底层工具并非Operator框架所独有，幸运的是，这意味着有大量的资源可供解决你可能遇到的问题。
- en: Makefile issues
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile问题
- en: '**Make** ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
    is a very popular tool for automating the generation and compilation of countless
    software projects. It was already used in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK,* and [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*, in order to generate the APIs
    and manifests used by our project. In this chapter, it was leveraged even more
    to automate many of the commands for building and deploying.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Make** ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
    是一个非常流行的工具，用于自动化生成和编译无数的软件项目。它已经在[*第4章*](B18147_04_ePub.xhtml#_idTextAnchor066)《使用Operator
    SDK开发Operator》和[*第5章*](B18147_05_ePub.xhtml#_idTextAnchor078)《开发Operator - 高级功能》中使用，用于生成我们的项目所使用的API和清单。在本章中，它被更广泛地应用于自动化构建和部署的许多命令。'
- en: However, the `make ...` commands used throughout this book are shorthand for
    running underlying tools. Therefore, when encountering an error with any `make`
    commands, the first debugging step is to examine the `Makefile` to find what that
    command is actually running. If this happens, you will likely find that you are
    rather encountering an issue with Docker, Go, or Kubernetes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书中使用的`make ...`命令是运行底层工具的简写。因此，当遇到任何`make`命令的错误时，第一步的调试步骤是检查`Makefile`，看看该命令实际上在运行什么。如果发生这种情况，你很可能会发现，实际上你遇到的是Docker、Go或Kubernetes的问题。
- en: These commands have been preemptively provided when `operator-sdk` initialized
    the project, but you are free to modify the provided `Makefile` as you wish to
    customize your project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在`operator-sdk`初始化项目时已经预先提供，但你可以根据需要修改提供的`Makefile`，以定制你的项目。
- en: kind
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kind
- en: In this chapter, we used kind to deploy a test Kubernetes cluster. Using kind
    offers a very quick way to create (and destroy) local Kubernetes clusters. It
    also provides a configurable setup that allows for relatively easy changes to
    the default cluster (for example, starting a cluster with additional nodes).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用kind来部署一个测试的Kubernetes集群。使用kind提供了一种非常快速的方式来创建（和销毁）本地Kubernetes集群。它还提供了一个可配置的设置，可以相对容易地更改默认集群（例如，启动一个包含额外节点的集群）。
- en: The official website for kind is [https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/).
    The website provides extensive documentation and sample configurations for different
    cluster setups. In addition, the kind code base is available on GitHub at [https://github.com/kubernetes-sigs/kind](https://github.com/kubernetes-sigs/kind).
    The kind maintainers and users are also active on the official Kubernetes Slack
    server ([slack.k8s.io](http://slack.k8s.io)) in the **#kind** channel. Both of
    these links are excellent resources for asking questions or searching for answers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: kind的官方网站是[https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)。该网站提供了大量文档和不同集群设置的示例配置。此外，kind的代码库可以在GitHub上找到，网址是[https://github.com/kubernetes-sigs/kind](https://github.com/kubernetes-sigs/kind)。kind的维护者和用户也活跃在官方Kubernetes
    Slack服务器（[slack.k8s.io](http://slack.k8s.io)）的**#kind**频道。这两个链接都是提问或搜索答案的绝佳资源。
- en: Docker
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: If you are working with Kubernetes, you are likely already familiar with Docker
    ([https://www.docker.com/](https://www.docker.com/)). It is just one of several
    options for building and managing container images, which are essential for deploying
    applications on Kubernetes. The key step for transitioning Operator code to a
    deployable image is the `docker build` command (which is called when running `make
    docker-build`). This command follows the `build` steps defined in the Dockerfile.
    More information on Dockerfile syntax is available in the Docker documentation
    at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Kubernetes，可能已经熟悉 Docker（[https://www.docker.com/](https://www.docker.com/)）。它只是构建和管理容器镜像的多个选项之一，这些镜像对于在
    Kubernetes 上部署应用程序至关重要。将操作符代码转换为可部署镜像的关键步骤是 `docker build` 命令（在运行 `make docker-build`
    时调用）。该命令遵循 Dockerfile 中定义的 `build` 步骤。有关 Dockerfile 语法的更多信息，请参见 Docker 文档：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: When building a container image following the steps in this chapter, there are
    some unique issues specific to this tutorial that you may encounter, which are
    explained next.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在按照本章步骤构建容器镜像时，你可能会遇到一些特定于本教程的独特问题，接下来将解释这些问题。
- en: docker build fails with no required module error for assets package
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: docker build 在构建资产包时因缺少必要模块而失败
- en: 'When running `make docker-build`, you may find that your build fails with the
    following error (or something similar):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `make docker-build` 时，你可能会遇到以下错误（或类似的错误）：
- en: '[PRE94]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This error is actually arising from the `go build` command in the final step
    of the Dockerfile. In the context of this specific tutorial, Go is failing to
    build because it cannot locate the `assets` package (created in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, to organize and access the operand
    Deployment manifest).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误实际上源自 Dockerfile 最后一步的 `go build` 命令。在本教程的上下文中，Go 构建失败是因为它无法找到 `assets`
    包（该包是在 [*第 4 章*](B18147_04_ePub.xhtml#_idTextAnchor066) *使用 Operator SDK 开发操作符*
    中创建的，用于组织和访问操作对象的部署清单）。
- en: To fix this, ensure that you have modified the Dockerfile to include the `COPY
    assets/ assets/` directive (see the example in the *Building a container image*
    section of this chapter). Alternatively, you could refactor the Operator code
    to embed the `assets/` directory within the existing `controllers/` directory
    without needing to modify the Dockerfile. This is because both `controllers/`
    and `api/` are already copied to the `builder` image (but it does not semantically
    make sense to store embedded manifests within the API directory, as they are not
    an API).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此问题，确保已修改 Dockerfile，包含 `COPY assets/ assets/` 指令（请参见本章 *构建容器镜像* 部分中的示例）。另外，你也可以重构操作符代码，将
    `assets/` 目录嵌入现有的 `controllers/` 目录中，而无需修改 Dockerfile。原因是 `controllers/` 和 `api/`
    目录已经被复制到 `builder` 镜像中（但将嵌入式清单存储在 API 目录中在语义上并不合理，因为它们不是 API）。
- en: docker push fails with access denied
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: docker push 因访问被拒绝而失败
- en: 'The `make docker-push` command may fail with the following error:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`make docker-push` 命令可能会因以下错误而失败：'
- en: '[PRE95]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This exact error (including the `docker push controller:latest` line) implies
    a misconfigured `IMG` variable for the command. Recall that in the *Building a
    container image* section of this chapter, this variable was discussed as a way
    to tag the built image with an appropriate name. There are a few options for setting
    this value, either as an environment variable or by modifying the `Makefile`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个具体的错误（包括 `docker push controller:latest` 行）意味着该命令的 `IMG` 变量配置错误。回想一下，在本章 *构建容器镜像*
    部分，曾讨论过该变量作为为构建镜像打标签的方式。有几种设置该值的方式，可以作为环境变量或通过修改 `Makefile`。
- en: However you choose to update this variable, it is important to check that the
    value is propagated to the `docker-push` target in the `Makefile` as well. Otherwise,
    Docker will attempt to push this to a generic registry for library images. You
    do not have access to this registry, therefore, Docker returns the `access denied`
    error shown here.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择如何更新此变量，都必须检查该值是否已传播到 `Makefile` 中的 `docker-push` 目标。否则，Docker 会尝试将其推送到用于库镜像的通用注册表。你无法访问该注册表，因此，Docker
    会返回此处显示的 `access denied` 错误。
- en: If instead, the error does include the appropriate public registry with your
    `IMG` variable value (for example, the second line is `docker push docker.io/yourregistry/yourimagename`)
    then it is likely a simple authentication error. Run `docker login` to make sure
    you are logged into your Docker Hub account.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误信息包含了正确的公共注册表和你的 `IMG` 变量值（例如，第二行是 `docker push docker.io/yourregistry/yourimagename`），那么很可能是简单的身份验证错误。运行
    `docker login` 确保你已登录到 Docker Hub 账户。
- en: Operator deploys but fails to start with ImagePull error
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Operator 部署成功，但因 ImagePull 错误无法启动
- en: 'If you run `make deploy`, the command will likely always complete successfully
    (unless you have made significant modifications to the generated manifest files).
    However, when viewing the Operator in your cluster (for example, with `kubectl
    get all -n nginx-operator-system`) you may see that the Operator''s Pod is failing
    to start with the following message:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `make deploy`，命令通常会成功完成（除非你对生成的清单文件进行了重大修改）。然而，在集群中查看 Operator（例如，使用 `kubectl
    get all -n nginx-operator-system`）时，可能会看到 Operator 的 Pod 启动失败，并显示以下信息：
- en: '[PRE96]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This is probably a similar error to the one described previously. In Kubernetes,
    the `ImagePullBackOff` error indicates that, for some reason, the Pod is unable
    to pull the container image it is intended to run. This is usually either an authentication
    error (for example, the registry may be private) or the image is not found. Ensure
    that you have built and pushed the Operator image with the right `IMG` environment
    variable set, as mentioned in the other *Troubleshooting* sections. If you still
    see the error, check to make sure that your image registry is not set to private
    by logging into the Docker Hub web UI.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与之前描述的错误类似。在 Kubernetes 中，`ImagePullBackOff` 错误表示由于某些原因，Pod 无法拉取它需要运行的容器镜像。通常，这可能是身份验证错误（例如，注册表可能是私有的）或镜像未找到。确保你已经使用正确的
    `IMG` 环境变量构建并推送了 Operator 镜像，如其他*故障排除*章节所述。如果仍然看到错误，检查一下是否已通过 Docker Hub Web UI
    登录，确保你的镜像注册表没有设置为私有。
- en: Operator deploys but fails to start with another error
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Operator 部署成功，但遇到另一个错误导致无法启动
- en: In Kubernetes, there are many reasons why any given Pod may fail to start. There
    could be a logical bug in the Operator's code or there may be a system configuration
    issue within the cluster. There is, unfortunately, no *one-size-fits-all* solution
    to this problem. However, there are tools to gather more information. Using `kubectl`
    to inspect the Pod is the most common way to diagnose errors. For example, `kubectl
    describe pod/<podname>` will print events and status updates that can explain
    the failure. Or, `kubectl logs pod/<podname>` will print the log output of the
    Pod (which is helpful for diagnosing runtime errors that usually need to be fixed
    in code). All of the `kubectl` commands will provide documentation by running
    `kubectl -h`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Pod 启动失败的原因有很多。可能是 Operator 代码中存在逻辑错误，或者集群中的系统配置出现问题。不幸的是，解决这个问题没有一个适合所有情况的*通用解决方案*。不过，还是有一些工具可以帮助收集更多的信息。使用
    `kubectl` 来检查 Pod 是诊断错误的最常见方法。例如，`kubectl describe pod/<podname>` 将打印出事件和状态更新，帮助解释失败的原因。或者，`kubectl
    logs pod/<podname>` 会打印出 Pod 的日志输出（这对于诊断运行时错误非常有帮助，通常这些错误需要通过修改代码来解决）。所有 `kubectl`
    命令都可以通过运行 `kubectl -h` 获取文档。
- en: Metrics
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标
- en: As part of developing an Operator with rich features and debugging capabilities,
    this and previous chapters dedicated effort to demonstrating the implementation
    of Prometheus metrics. Prometheus ([https://prometheus.io/](https://prometheus.io/))
    is an open source monitoring platform that is widely used in the Kubernetes ecosystem.
    Therefore, there are many resources available online for various problems (many
    are not specific to the Operator Framework). These community resources are documented
    at [https://prometheus.io/community/](https://prometheus.io/community/).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发具有丰富功能和调试能力的 Operator 的一部分，本章和前几章专门介绍了 Prometheus 指标的实现。Prometheus ([https://prometheus.io/](https://prometheus.io/))
    是一个开源监控平台，在 Kubernetes 生态系统中被广泛使用。因此，网上有许多资源可以解决各种问题（许多问题并非专门针对 Operator 框架）。这些社区资源的文档可以在
    [https://prometheus.io/community/](https://prometheus.io/community/) 找到。
- en: Operator metrics do not show up in Prometheus
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Operator 指标在 Prometheus 中未显示
- en: With Prometheus deployed in a cluster following the `kube-prometheus` steps
    in this tutorial, the custom metrics defined in our Operator code should show
    up in the Prometheus dashboard after a few moments. If, after some time, the custom
    metrics are still not visible, ensure that you have made the correct changes described
    in the *Installing and configuring kube-prometheus* section to instruct Prometheus
    to scrape the Operator's namespace for new metrics.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中部署Prometheus，并按照本教程中的`kube-prometheus`步骤进行操作后，我们在操作符代码中定义的自定义度量应该会在几秒钟后出现在Prometheus仪表板中。如果一段时间后，仍然无法看到自定义度量，请确保您已按照*安装和配置kube-prometheus*部分的说明，正确配置Prometheus，以便它从操作符的命名空间中抓取新的度量。
- en: Additionally, make sure that you have uncommented the `- ../prometheus` line
    in `config/default/kustomization.yaml` before deploying the Operator as described
    in the *Redeploying the Operator with metrics* section. This step ensures that
    the `ServiceMonitor` object (which informs Prometheus which endpoint to scrape
    for metrics) is created in the namespace.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保在部署操作符之前，已经取消注释`config/default/kustomization.yaml`中的`- ../prometheus`行，如*带度量重新部署操作符*部分所述。此步骤确保`ServiceMonitor`对象（它告知Prometheus抓取哪个端点的度量）在命名空间中创建。
- en: Operator deployment fails with no matches for kind 'ServiceMonitor'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符部署失败，提示没有匹配的`ServiceMonitor`类型
- en: 'When running `make deploy`, the following error may appear among several other
    lines showing which resources were created:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`make deploy`时，可能会出现以下错误，并显示其他一些行，说明创建了哪些资源：
- en: '[PRE97]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In this case, the Operator did not actually fail to deploy. However, it did
    fail to create the `ServiceMonitor` object due to an inability to locate the object's
    definition in the Kubernetes API. This is likely due to failing to install Prometheus
    in the cluster before attempting to deploy the Operator with metrics. Specifically,
    `ServiceMonitor` is a CRD that is provided by Prometheus. So, deploying the Operator
    with metrics before installing `kube-prometheus` in this tutorial will lead to
    failures when reporting metrics. To resolve this, ensure that you have followed
    the steps for installing Prometheus before deploying the Operator with metrics.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，操作符实际上并没有失败部署。然而，由于无法在Kubernetes API中找到对象的定义，它确实未能创建`ServiceMonitor`对象。这很可能是因为在尝试部署带有度量的操作符之前，没有在集群中安装Prometheus。具体来说，`ServiceMonitor`是由Prometheus提供的CRD。因此，在本教程中，在安装`kube-prometheus`之前部署带有度量的操作符将导致报告度量时出现失败。为了解决这个问题，请确保在部署带有度量的操作符之前，已经按照安装Prometheus的步骤进行操作。
- en: Additional errors
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他错误
- en: The preceding issues are just some of the technical problems that may arise
    when following this tutorial. It is, unfortunately, not possible for this chapter
    to cover every scenario. However, the Operator Framework community and its resources
    provide solutions to many different types of problems. These, along with the resources
    in the *Troubleshooting* section of [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, are very likely to resolve any
    difficulty that you may face.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题只是跟随本教程时可能出现的一些技术问题。不幸的是，本章无法涵盖所有场景。然而，操作符框架社区及其资源提供了解决许多不同类型问题的方案。通过这些资源，以及[*第4章*](B18147_04_ePub.xhtml#_idTextAnchor066)中*故障排除*部分的资料，您很可能能解决遇到的任何难题。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter's main objective was to compile the Operator code that we have
    been building throughout this book and deploy it in a cluster. To do this, we
    followed steps designed for local development environments. These included building
    the Operator as a local binary and building a container image to deploy in an
    ephemeral test cluster (created using kind). This lightweight process is helpful
    for development and rapid testing, but it lacks the full workflow benefits needed
    for publishing an Operator with the intent of deploying in production.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是将我们在整本书中构建的操作符代码进行编译，并将其部署到集群中。为此，我们按照适用于本地开发环境的步骤进行操作。这些步骤包括将操作符构建为本地二进制文件，并构建容器镜像以便在临时测试集群中部署（该集群是使用kind创建的）。这个轻量级的过程有助于开发和快速测试，但缺乏发布操作符时在生产环境中部署所需的完整工作流优势。
- en: 'In the next chapter, we will explore the final pillars of the Operator Framework:
    **OperatorHub** and the **Operator Lifecycle Manager**. Learning how to prepare
    and submit an Operator to OperatorHub will be a key part of offering any Operator
    available for public use. With that, the Operator Lifecycle Manager is a much
    more elegant solution for deploying Operators (both publicly available on OperatorHub
    or privately deployed). Compared to deploying manually with Make, these processes
    are much better suited for sharing your Operator with the world.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨操作符框架的最终支柱：**OperatorHub** 和 **Operator Lifecycle Manager**。学习如何准备和提交一个操作符到OperatorHub，将是将任何操作符提供给公众使用的关键部分。与此同时，Operator
    Lifecycle Manager是一个更为优雅的解决方案，用于部署操作符（无论是公开在OperatorHub上，还是私下部署）。与手动使用Make部署相比，这些过程更适合将你的操作符与全世界分享。
