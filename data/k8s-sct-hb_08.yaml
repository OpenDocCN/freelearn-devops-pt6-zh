- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Exploring Cloud Secret Store on AWS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 AWS 上的云秘密存储
- en: 'A very common way to store Secrets in the cloud is to utilize the infrastructure
    that is provided by cloud providers. The major cloud providers have two essential
    pieces of infrastructure that help us with efficient Secrets management on Kubernetes:
    Secret Storage and KMS.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中存储秘密的一个非常常见的方法是利用云服务提供商提供的基础设施。主要的云服务提供商有两个重要的基础设施组件，可以帮助我们在 Kubernetes 上高效地管理秘密：秘密存储和
    KMS。
- en: 'In this chapter, we shall examine AWS Secrets Manager, **Elastic Kubernetes
    Service** (**EKS**) integration, and secret encryption with KMS. Specifically,
    we will cover these topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 AWS Secrets Manager、**弹性 Kubernetes 服务**（**EKS**）的集成，以及使用 KMS 进行秘密加密。具体来说，我们将涵盖以下主题：
- en: Overview of AWS Secrets Manager
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 概述
- en: Secrets Store CSI Driver
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密存储 CSI 驱动程序
- en: AWS EKS clusters and AWS Secrets Manager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS EKS 集群和 AWS Secrets Manager
- en: KMS for AWS Kubernetes encryption
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KMS 用于 AWS Kubernetes 加密
- en: By the end of the chapter, we should be able to use AWS Secrets Manager as an
    external Kubernetes secret store, encrypt Secrets on Kubernetes using AWS KMS,
    and search audit logs on secret operations using AWS CloudTrail and AWS CloudWatch.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们应该能够将 AWS Secrets Manager 作为外部 Kubernetes 秘密存储来使用，使用 AWS KMS 对 Kubernetes
    上的秘密进行加密，并通过 AWS CloudTrail 和 AWS CloudWatch 搜索秘密操作的审计日志。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To link concepts with practice, we will use a series of tools and platforms
    that are commonly used to interact with the AWS API and Kubernetes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将概念与实践相结合，我们将使用一系列常用的工具和平台来与 AWS API 和 Kubernetes 交互：
- en: An AWS Free Tier account is required. The free tier is available to new AWS
    customers for a limited period. Once the period expires or the usage exceeds the
    free tier usage limits, pay-as-you-go service rates apply.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个 AWS 免费套餐账户。免费套餐对于新的 AWS 客户在限定时间内可用。一旦该期限到期或使用量超过免费套餐使用限制，将按需付费。
- en: The **AWS CLI** ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/))
    is a unified tool for managing your AWS services. Commands executed through the
    AWS CLI are transformed into API calls toward the AWS API.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CLI** ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)) 是一个统一的工具，用于管理
    AWS 服务。通过 AWS CLI 执行的命令会被转换为对 AWS API 的 API 调用。'
- en: '**Terraform** ([https://www.terraform.io/](https://www.terraform.io/)) is infrastructure-as-code
    software that can be used to provision and manage infrastructure in the cloud.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform** ([https://www.terraform.io/](https://www.terraform.io/)) 是一款基础设施即代码软件，可用于在云中配置和管理基础设施。'
- en: '**kubectl** ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/))
    is a command-line tool used for communicating with a Kubernetes cluster through
    the Kubernetes API.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl** ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/))
    是一个命令行工具，用于通过 Kubernetes API 与 Kubernetes 集群进行通信。'
- en: Overview of AWS Secrets Manager
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 概述
- en: A secret is a concept that exists outside the realm of Kubernetes. Any type
    of application will at some point require sensitive information to be integrated
    with each deployment. An application deployed in the cloud requires secure secret
    handling. For this reason, cloud providers offer components for secret storage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密是一个存在于 Kubernetes 范畴之外的概念。任何类型的应用程序都会在某个时刻需要将敏感信息与每个部署集成。在云中部署的应用程序需要安全地处理秘密。因此，云服务提供商提供了秘密存储组件。
- en: When it comes to Kubernetes, we saw in [*Chapter 1*](B20970_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes Secrets Management*, that secret information is stored
    on etcd. Essentially, etcd is the default secret store of Kubernetes. The crucial
    question is whether it is possible to have external storage for Secrets on Kubernetes
    apart from etcd.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，我们在 [*第 1 章*](B20970_01.xhtml#_idTextAnchor015)，《理解 Kubernetes
    秘密管理》中看到，秘密信息存储在 etcd 中。本质上，etcd 是 Kubernetes 的默认秘密存储。关键问题是，除了 etcd，是否有可能在 Kubernetes
    上使用外部存储来存储秘密。
- en: This is feasible provided you actively use a cloud provider’s secret storage,
    or you consider taking advantage of it and utilizing it on Kubernetes. Thanks
    to the Container Storage Interface and the workload identity, we can utilize the
    available secret stores.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可行的，前提是你主动使用云服务提供商的秘密存储，或者考虑利用它并在 Kubernetes 上使用它。由于容器存储接口和工作负载身份的存在，我们可以利用现有的秘密存储。
- en: AWS Secrets Manager ([https://aws.amazon.com/secrets-manager/](https://aws.amazon.com/secrets-manager/))
    is the secret store provided by AWS. With AWS Secrets Manager, we can store several
    types of credentials, such as database credentials, application credentials, and
    secure tokens. We will now focus on the features that make AWS Secrets Manager
    a good option for handling Secrets, starting with encryption.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Secrets Manager ([https://aws.amazon.com/secrets-manager/](https://aws.amazon.com/secrets-manager/))
    是 AWS 提供的秘密存储服务。使用 AWS Secrets Manager，我们可以存储多种类型的凭证，如数据库凭证、应用程序凭证和安全令牌。接下来，我们将重点介绍使
    AWS Secrets Manager 成为处理密钥的优选方案的功能，从加密开始。
- en: Encryption
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密
- en: AWS Secrets Manager has encryption at rest as well as in transit. It uses AWS
    KMS to perform envelope encryption. The values stored in AWS Secrets Manager are
    encrypted using a data key, and the data key is encrypted using AWS KMS. The data
    encryption key is an AES-256 key. When a value changes on AWS Secrets Manager,
    a new data encryption key is generated and is used to encrypt the new value. We
    can also configure AWS Secrets Manager to use a different KMS key. AWS Secrets
    Manager also provides encryption in transit. The API calls toward Secrets Manager
    happen through secure private endpoints, and each call is required to be signed
    using X.509 certificates or a Secrets Manager secret access key.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 提供静态加密和传输加密功能。它使用 AWS KMS 执行封套加密。存储在 AWS Secrets Manager
    中的值通过数据密钥加密，而数据密钥则使用 AWS KMS 进行加密。数据加密密钥是 AES-256 密钥。当 AWS Secrets Manager 中的值发生变化时，系统会生成一个新的数据加密密钥，并用它加密新值。我们还可以配置
    AWS Secrets Manager 使用不同的 KMS 密钥。AWS Secrets Manager 还提供传输加密功能。与 Secrets Manager
    的 API 调用通过安全的私有端点进行，每个调用都需要使用 X.509 证书或 Secrets Manager 秘密访问密钥进行签名。
- en: Versioning
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: Versioning is another benefit of using AWS Secrets Manager. If we create a secret
    in AWS Secrets Manager, the secret will be stored, and a version will be assigned
    to it. This will be the first version of the secret. Once we update that secret,
    we will have an updated version of the secret, and the old version will still
    be available. When we access the secret, the latest version of it will be retrieved.
    The previous version can be configured to be automatically deleted at a certain
    date. This will make it impossible to retrieve it. If we want to retrieve the
    previous version, we must remove it from pending deletion.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是使用 AWS Secrets Manager 的另一个好处。如果我们在 AWS Secrets Manager 中创建一个秘密，系统会为其分配一个版本号。这将是该秘密的第一个版本。一旦我们更新该秘密，就会获得更新后的版本，而旧版本仍然可用。当我们访问该秘密时，将检索到其最新版本。可以配置将先前的版本在某个日期自动删除，这样就无法再检索到它。如果我们想要检索先前的版本，必须先将其从待删除状态中移除。
- en: Rotation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥轮换
- en: AWS Secrets Manager also permits rotation. An AWS Lambda function can be configured
    to execute a scheduled key rotation; the AWS documentation has a detailed guide
    ([https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html)).
    On invocation, the Lambda function will rotate the key based on a custom code
    snippet that we provided; the function templates can be found on GitHub ([https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas](https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas)).
    During the rotation, the latest version of the key will be tested. On failure,
    the rotation will be retried.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 还支持密钥轮换。可以配置一个 AWS Lambda 函数来执行定期的密钥轮换；AWS 文档提供了详细的指南（[https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html)）。在调用时，Lambda
    函数会根据我们提供的自定义代码片段进行密钥轮换；函数模板可以在 GitHub 上找到（[https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas](https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas)）。在轮换过程中，将会测试密钥的最新版本。如果失败，轮换将会重试。
- en: Cloud-based features
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于云的功能
- en: 'Apart from tackling the storage needs of sensitive information, AWS Secrets
    Manager is a managed AWS component. Every AWS component comes with certain features:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了满足敏感信息存储需求外，AWS Secrets Manager 还是一个托管的 AWS 组件。每个 AWS 组件都有其特定功能：
- en: AWS IAM integration
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS IAM 集成
- en: Logging and auditing on usage
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志记录和审计
- en: High availability and disaster recovery
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性和灾难恢复
- en: Integration with other AWS components
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他 AWS 组件的集成
- en: Let’s look at each of these features.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看这些功能。
- en: AWS IAM integration
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS IAM 集成
- en: With AWS **Identity and Access Management** (**IAM**), we can specify entities
    that can access services and resources in AWS. Those entities can be AWS users
    or AWS roles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过AWS **身份与访问管理**（**IAM**），我们可以指定可以访问AWS服务和资源的实体。这些实体可以是AWS用户或AWS角色。
- en: AWS users are intended to be associated with an actual human user who wants
    to interact with an AWS service and provision resources. AWS roles are a more
    flexible identity. AWS roles are used to delegate access to services, EC2 machines,
    and Kubernetes workloads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: AWS用户旨在与实际的人类用户关联，这些用户希望与AWS服务互动并配置资源。AWS角色是一种更灵活的身份。AWS角色用于委派对服务、EC2机器和Kubernetes工作负载的访问权限。
- en: The identities on AWS can be granted fine-grained permissions on AWS services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AWS上的身份可以被授予细粒度的AWS服务权限。
- en: Logging and auditing
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录与审计
- en: AWS comes with CloudWatch, which is a monitoring and observability solution.
    CloudWatch collects real-time logs and metrics from other AWS components. In our
    case, with CloudWatch we can identify Kubernetes operations through logging; also,
    we can create custom alerts and dashboards based on the metrics provided out of
    the box.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供了CloudWatch，这是一个监控和可观测性解决方案。CloudWatch从其他AWS组件收集实时日志和指标。在我们的案例中，通过CloudWatch，我们可以通过日志识别Kubernetes操作；同时，我们可以基于开箱即用的指标创建自定义警报和仪表板。
- en: CloudTrail is an AWS service targeted toward auditing. With CloudTrail, we can
    track actions taken by an AWS user or an AWS role. Those operations will be recorded
    and will be accessible through AWS CloudTrail. Take, for example, a secret retrieval
    by a role attached to an EC2 machine. The code running on the EC2 machine is granted
    permission to receive the secret, the secret is retrieved, and this action is
    logged to AWS CloudTrail. The EC2 machine has a role assigned with permissions
    to interact with AWS Secrets Manager; the role is an AWS identity, just like an
    AWS console user.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CloudTrail是AWS的一项面向审计的服务。通过CloudTrail，我们可以跟踪AWS用户或AWS角色执行的操作。这些操作将被记录并通过AWS
    CloudTrail进行访问。例如，假设EC2机器上附加的角色检索一个密钥。运行在EC2机器上的代码被授权接收该密钥，密钥被检索，并且此操作会被记录到AWS
    CloudTrail中。EC2机器具有与AWS Secrets Manager交互权限的角色；该角色是一个AWS身份，类似于AWS控制台用户。
- en: 'In the following screenshot, we can see the CloudTrail screen displaying auditing
    information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到显示审计信息的CloudTrail屏幕：
- en: '![Figure 8.1 – AWS CloudTrail screen](img/B20970_08_1.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – AWS CloudTrail屏幕](img/B20970_08_1.jpg)'
- en: Figure 8.1 – AWS CloudTrail screen
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – AWS CloudTrail屏幕
- en: Thanks to CloudTrail, we can identify the action that took place in AWS Secrets
    Manager, the identity that executed it, and at what time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 借助CloudTrail，我们可以识别在AWS Secrets Manager中发生的操作、执行该操作的身份以及执行时间。
- en: High availability and disaster recovery
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高可用性和灾难恢复
- en: Secrets provisioned on Secrets Manager are regionally highly available. This
    means that the secret operations will span the three availability zones that an
    AWS region consists of. If an availability zone becomes unavailable, requests
    for a secret will be served by another availability zone.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Secrets Manager上配置的密钥是区域性高度可用的。这意味着密钥操作将跨越一个AWS区域的三个可用区。如果某个可用区变得不可用，密钥的请求将由另一个可用区提供服务。
- en: Also, with AWS Secrets Manager, we can achieve disaster recovery. By default,
    when we create a secret, we choose an availability zone, where this secret will
    reside. To protect our workloads from situations where a region is lost, we provision
    our infrastructure in a way that disaster recovery is feasible. AWS Secrets Manager
    makes this easy by enabling us to replicate a secret to another region.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用AWS Secrets Manager，我们可以实现灾难恢复。默认情况下，当我们创建一个密钥时，我们会选择一个可用区，这个密钥将驻留在该区域。为了保护我们的工作负载免受某个区域丢失的情况，我们会以灾难恢复可行的方式配置我们的基础设施。AWS
    Secrets Manager通过允许我们将密钥复制到另一个区域，使这一过程变得更加简单。
- en: Integration with other AWS components
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与其他AWS组件的集成
- en: A benefit of using the components provided by the cloud providers is how well
    they are integrated. AWS Secrets Manager can be integrated with other AWS components
    easily. In our case, we are interested in EKS, which is the managed version of
    Kubernetes on AWS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云提供商提供的组件的一个好处是它们的高度集成性。AWS Secrets Manager可以轻松与其他AWS组件集成。在我们的案例中，我们感兴趣的是EKS，它是AWS上Kubernetes的托管版本。
- en: We had an overview of AWS Secrets Manager and saw how it can be integrated with
    other AWS components. We shall proceed with integrating AWS Secrets Manager with
    EKS. To achieve this, we will have an overview of the tool that facilitates this
    integration, Secrets Store CSI Driver.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经概述了 AWS Secrets Manager，并了解了它如何与其他 AWS 组件集成。接下来，我们将继续介绍如何将 AWS Secrets Manager
    与 EKS 集成。为此，我们将概述一款促进这一集成的工具——Secrets Store CSI 驱动。
- en: Secrets Store CSI Driver
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Secrets Store CSI 驱动
- en: Kubernetes CSI is a standardized interface for Kubernetes that enables us to
    utilize different storage providers with Kubernetes. Instead of being limited
    to using the default storage on Kubernetes, we have an interface providing a specification
    upon which we can build storage drivers. This way we can use several types of
    storage by implementing a new driver that complies with the CSI interface.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CSI 是 Kubernetes 的标准化接口，允许我们使用不同的存储提供商与 Kubernetes 配合使用。我们不仅限于使用
    Kubernetes 上的默认存储，还有一个接口提供了一个规范，我们可以基于此规范构建存储驱动程序。通过这种方式，我们可以通过实现符合 CSI 接口的新驱动程序，使用多种存储类型。
- en: 'Here are some popular drivers for CSI:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常用的 CSI 驱动：
- en: AWS Elastic File System
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 弹性文件系统
- en: Azure File
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 文件
- en: Google Cloud Filestore
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Filestore
- en: This is feasible for several forms of storage and is also applicable to the
    Secrets storage components provided by the cloud providers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式适用于多种存储形式，也适用于云服务提供商提供的 Secrets 存储组件。
- en: CSI drivers are provided for secret storage by the cloud providers. Secrets
    Store CSI Driver is a CSI interface that targets Secrets management. We can use
    it to mount Secrets on Kubernetes through another form of storage. Instead of
    consuming Secrets from etcd, thanks to Secrets Store CSI Driver, we can consume
    the Secrets from various external sources, and in our case, those sources are
    the very Secrets Storage solutions that are provided by the cloud providers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 驱动由云服务提供商提供，用于秘密存储。Secrets Store CSI 驱动是一个专注于 Secrets 管理的 CSI 接口。我们可以通过它将
    Secrets 挂载到 Kubernetes 中，利用另一种形式的存储。通过 Secrets Store CSI 驱动，我们可以从不同的外部来源获取 Secrets，而不是从
    etcd 中消费 Secrets，在我们的案例中，这些来源正是由云服务提供商提供的 Secrets 存储解决方案。
- en: In this section, we will focus on AWS Secrets Manager and examine how we can
    integrate a Kubernetes cluster into AWS to consume Secrets from the native cloud
    provider solution for Secrets management by using the corresponding Secrets Store
    CSI Driver.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍 AWS Secrets Manager，并探讨如何通过使用相应的 Secrets Store CSI 驱动将 Kubernetes
    集群与 AWS 集成，从而使用云服务提供商的原生 Secrets 管理解决方案中的 Secrets。
- en: How Secrets Store CSI Driver works
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets Store CSI 驱动的工作原理
- en: We have an application to be hosted on Kubernetes. That application will have
    to use a secret that resides on the Secrets storage solution of the cloud provider.
    The application will reside on a Pod since the Pod is the main compute building
    block of Kubernetes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个应用程序需要托管在 Kubernetes 上。该应用程序必须使用存在于云服务提供商 Secrets 存储解决方案中的秘密。该应用程序将会驻留在
    Pod 上，因为 Pod 是 Kubernetes 的主要计算构建块。
- en: Once a Pod is created, started, or restarted, Secrets Store CSI Driver through
    the Secret Store CSI provider will communicate with the cloud provider’s Secrets
    storage and retrieve the credentials. The credentials will be mounted to the Pod
    as a volume. The volume mounted will be attached to a directory specified.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Pod 被创建、启动或重启，Secret Store CSI 驱动通过 Secret Store CSI 提供者将与云服务提供商的 Secrets
    存储进行通信，并检索凭证。这些凭证将作为卷挂载到 Pod 中。挂载的卷将会附加到指定的目录。
- en: The next question is how Secret Store CSI Driver works.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是 Secret Store CSI 驱动如何工作。
- en: Secret Store CSI Driver is a **DaemonSet**. A DaemonSet exists on Kubernetes
    on every node. A DaemonSet can consist of more than one Pod.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Secret Store CSI 驱动是一个**DaemonSet**。DaemonSet 会在 Kubernetes 的每个节点上存在。一个 DaemonSet
    可以包含多个 Pod。
- en: 'In the case of Secret Store CSI Driver, we have the following Pods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Secret Store CSI 驱动，我们有以下 Pods：
- en: '`node-driver-registrar`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node-driver-registrar`'
- en: '`secrets-store`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets-store`'
- en: '`liveness-probe`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`liveness-probe`'
- en: node-driver-registrar
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: node-driver-registrar
- en: '`node-driver-registrar` will register the CSI driver with the kubelet. A registration
    socket is created and exposed via the host path in the kubelet plugin registry.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-driver-registrar` 将会把 CSI 驱动注册到 kubelet。会创建一个注册套接字，并通过 kubelet 插件注册表中的主机路径暴露出来。'
- en: secrets-store
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: secrets-store
- en: The `secrets-store` component is responsible for mounting secret volumes during
    Pod creation as well as unmounting volumes during Pod deletion. It is based on
    gRPC implementing the CSI node service from the CSI specification.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`secrets-store` 组件负责在 Pod 创建过程中挂载机密卷，以及在 Pod 删除时卸载卷。它基于 gRPC 实现了来自 CSI 规范的
    CSI 节点服务。'
- en: liveness-probe
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: liveness-probe
- en: 'This Pod monitors the health of the CSI driver. The health liveness probe will
    detect any issues with the driver and will restart the Pod in order to fix the
    issue. In the following diagram, we can see how all the components come together:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Pod 监控 CSI 驱动程序的健康状况。健康存活探针将检测驱动程序的任何问题，并会重启 Pod 来修复问题。在下图中，我们可以看到所有组件如何协同工作：
- en: '![Figure 8.2 – Secrets Store CSI and AWS Secrets Manager integration](img/B20970_08_2.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Secrets Store CSI 与 AWS Secrets Manager 的集成](img/B20970_08_2.jpg)'
- en: Figure 8.2 – Secrets Store CSI and AWS Secrets Manager integration
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Secrets Store CSI 与 AWS Secrets Manager 的集成
- en: Now that we know about the CSI driver, we shall proceed with integrating it
    with EKS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 CSI 驱动程序，接下来将继续将其与 EKS 集成。
- en: Integrating AWS Secrets Manager with EKS
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 AWS Secrets Manager 与 EKS 集成
- en: To integrate AWS Secrets Manager with Kubernetes, we shall utilize the Secrets
    Store CSI Driver . As expected, AWS provides us with Secrets Store CSI Driver
    ([https://github.com/aws/secrets-store-csi-driver-provider-aws](https://github.com/aws/secrets-store-csi-driver-provider-aws)).
    To integrate the driver with Kubernetes, we will create a Kubernetes cluster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 AWS Secrets Manager 与 Kubernetes 集成，我们将使用 Secrets Store CSI 驱动程序。正如预期的那样，AWS
    为我们提供了 Secrets Store CSI 驱动程序 ([https://github.com/aws/secrets-store-csi-driver-provider-aws](https://github.com/aws/secrets-store-csi-driver-provider-aws))。为了将驱动程序与
    Kubernetes 集成，我们将创建一个 Kubernetes 集群。
- en: EKS cluster on AWS
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS 上的 EKS 集群
- en: As defined earlier, **EKS** in AWS stands for **Elastic Kubernetes Service**.
    We have the option to set up a Kubernetes cluster on the AWS cloud just like every
    other cloud. We will focus on the managed service offering for the purpose of
    this chapter because it requires less maintenance and setup overhead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，AWS 中的 **EKS** 代表 **弹性 Kubernetes 服务**。我们有选项在 AWS 云上设置 Kubernetes 集群，就像在其他云平台上一样。为了本章的目的，我们将重点关注托管服务，因为它需要更少的维护和设置开销。
- en: If there is already an existing EKS cluster available, the Terraform setup instructions
    can be ignored since the corresponding command-line arguments for AWS will be
    provided.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已有现成的 EKS 集群，则可以忽略 Terraform 配置说明，因为 AWS 的相应命令行参数会提供。
- en: Implementing a Kubernetes cluster on AWS can require different amounts of effort
    based on the installation you want to achieve. One option is to create fully private
    clusters with no connectivity to the internet and everything being served internally
    from AWS. Another option is a cluster on a public network. A quite common option
    nowadays is to deploy the nodes of the cluster on subnets that are private and
    ensure that the connectivity to the internet happens through a NAT gateway. This
    is the option we shall follow.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 上实施 Kubernetes 集群可能需要不同程度的努力，具体取决于您想要实现的安装类型。一种选择是创建完全私有的集群，这些集群无法连接到互联网，所有服务都通过
    AWS 内部提供。另一种选择是创建一个公有网络上的集群。如今，比较常见的选项是将集群的节点部署在私有子网中，并确保通过 NAT 网关实现与互联网的连接。这就是我们将要遵循的选项。
- en: Configuring the Terraform project
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Terraform 项目
- en: 'A Terraform project on AWS requires us to store the state. We can store the
    state locally on our filesystem, but this is not a viable option for infrastructure
    as code targeting a production environment. Our option is to use a **Secure Storage
    Service** (**S3**) bucket to store the state:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 上的 Terraform 项目要求我们存储状态。我们可以将状态存储在本地文件系统中，但这对于面向生产环境的基础设施即代码（IaC）来说并不可行。我们的选择是使用
    **安全存储服务** (**S3**) 桶来存储状态：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, the Terraform code base will use the default credentials that are
    configured for the AWS CLI.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Terraform 代码库将使用为 AWS CLI 配置的默认凭证。
- en: 'We first need to initialize the Terraform project using `init`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要使用 `init` 初始化 Terraform 项目：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will initialize our project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将初始化我们的项目。
- en: 'With Terraform, we have the option of `plan`, which is similar to the `dry-run`
    command from kubectl. Instead of creating the resources, we use `plan` and identify
    what the state of the infrastructure would be like if the Terraform scripts had
    been applied:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform，我们可以使用 `plan` 选项，它类似于 kubectl 的 `dry-run` 命令。我们不会直接创建资源，而是使用 `plan`
    来识别如果应用了 Terraform 脚本，基础设施的状态会是什么样：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To apply the infrastructure, we shall use the `apply` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用基础设施，我们将使用 `apply` 命令：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Terraform basics
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Terraform 基础
- en: 'When using Terraform, infrastructure is defined in `.tf` files. A Terraform
    project involves the following operations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Terraform 时，基础设施是通过 `.tf` 文件定义的。一个 Terraform 项目包含以下操作：
- en: '`init`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`'
- en: '`plan`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plan`'
- en: '`apply`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`'
- en: '`destroy`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy`'
- en: So far, we have seen `init`, which is used to initialize the project and download
    the existing state; `plan`, which is used to evaluate the changes we perform;
    and `apply`, which is the command used to carry out the changes. To destroy the
    provisioned resource, we can use the `destroy` command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到 `init`，它用于初始化项目并下载现有状态；`plan`，它用于评估我们所做的更改；以及 `apply`，它是用来执行更改的命令。若要销毁已配置的资源，我们可以使用
    `destroy` 命令。
- en: 'These operations can be carried out on the project or can target a specific
    resource defined in the Terraform files:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可以在项目中执行，也可以针对 Terraform 文件中定义的特定资源执行：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the case of existing resources, there is the option to import those resources
    in the Terraform state and provide them with a resource definition on the `.``tf`
    files:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有资源，可以选择将这些资源导入 Terraform 状态并在 `.tf` 文件中提供资源定义：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is a recommended structure for Terraform projects. `main.tf` is the primary
    entry point to define resources. As the complexity of the infrastructure increases,
    more `.tf` files can be used. `variables.tf` contains variables that we want to
    be dynamic when provisioning the infrastructure and `outputs.tf` should contain
    the information we want to extract when we provision infrastructure with Terraform.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 项目有推荐的结构。`main.tf` 是定义资源的主要入口点。随着基础设施的复杂性增加，可以使用更多的 `.tf` 文件。`variables.tf`
    包含我们希望在配置基础设施时动态设置的变量，`outputs.tf` 应包含我们在使用 Terraform 配置基础设施时希望提取的信息。
- en: The Terraform project is set up, so we shall proceed with setting the VPC through
    Terraform.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 项目已设置完成，我们将通过 Terraform 配置 VPC。
- en: Creating the VPC
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 VPC
- en: 'Our cluster nodes will reside on AWS VPC. We shall use the VPC module from
    the `terraform-aws-modules` project (https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的集群节点将驻留在 AWS VPC 中。我们将使用 `terraform-aws-modules` 项目中的 VPC 模块（https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest）：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this configuration, we will span a VPC among three availability zones,
    thus enabling us to have a highly available cluster.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此配置，我们将在三个可用区中扩展 VPC，从而实现高可用集群。
- en: We shall create a private subnet in each zone as well as public subnets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个可用区创建一个私有子网以及公共子网。
- en: The Kubernetes workloads will be hosted on the private subnets and external
    traffic will reach the Kubernetes workloads through the public network. To provide
    access to the internet from within the Kubernetes cluster, a NAT gateway will
    be configured.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 工作负载将托管在私有子网上，外部流量将通过公共网络访问 Kubernetes 工作负载。为了让 Kubernetes 集群能够访问互联网，我们将配置一个
    NAT 网关。
- en: Since we have the VPC configured we can now proceed and configure the EKS cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经配置了 VPC，现在可以继续配置 EKS 集群。
- en: Provisioning the EKS cluster
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 EKS 集群
- en: 'We have provisioned the VPC, so now we shall proceed with provisioning the
    EKS cluster. We will pick the EKS module from the `terraform-aws-modules` project
    ([https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest](https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest)):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了 VPC，现在我们将继续配置 EKS 集群。我们将从 `terraform-aws-modules` 项目中选择 EKS 模块（[https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest](https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest)）：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will create an EKS cluster. The master is managed by AWS. By creating the
    cluster, we specified that the nodes span the private subnets we specified previously
    in the VPC section. We will also create a separate log group for the EKS cluster.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 EKS 集群。主节点由 AWS 管理。在创建集群时，我们指定节点跨越之前在 VPC 部分指定的私有子网。我们还将为 EKS 集群创建一个单独的日志组。
- en: To make it easy to interact with the EKS master, we shall configure the cluster
    endpoint to be publicly accessible. The option can be fine-tuned and specify a
    restricted number of IPs to be able to interact with the cluster through the kubectl
    tool.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于与 EKS 主节点交互，我们将配置集群端点为公开可访问。此选项可以进一步优化，并指定一组受限的 IP 地址，以便通过 kubectl 工具与集群进行交互。
- en: Once the cluster is up and running, we can test and even run some kubectl commands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群启动并运行，我们可以进行测试，甚至运行一些 kubectl 命令。
- en: 'To authenticate to the cluster, we shall use the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要对集群进行身份验证，我们将使用以下命令：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command will differ depending on the cluster name and the region we choose.
    Once this is done, we can use kubectl to point to the recently provisioned cluster:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会根据集群名称和选择的区域有所不同。完成后，我们可以使用 kubectl 指向最近配置的集群：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have provisioned the EKS cluster, we can proceed to work with AWS
    Secrets Manager.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经配置了 EKS 集群，现在可以继续与 AWS Secrets Manager 配合工作。
- en: Creating Secrets on Secrets Manager
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Secrets Manager 中创建机密
- en: 'Let’s create a secret using AWS Secrets Manager:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 AWS Secrets Manager 创建一个机密：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `replica` block, we specify the region in which we will replicate the
    secret. This will give us disaster recovery capabilities. Also, the `recovery_window_in_days`
    block defines within how many days we can recover a secret after we set it for
    deletion.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `replica` 块中，我们指定了复制机密的区域。这将为我们提供灾难恢复能力。同时，`recovery_window_in_days` 块定义了在设置删除操作后，我们能在多少天内恢复该机密。
- en: 'Now, let’s add a version for the secret we specified:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为指定的机密添加一个版本：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is our first interaction with AWS Secrets Manager. We have created a secret
    and a version of the secret containing a string.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们与 AWS Secrets Manager 的第一次交互。我们已创建一个机密，并包含一个字符串的机密版本。
- en: 'We will also create a role with the required IAM bindings:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个具有所需 IAM 绑定的角色：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Pay close attention to the role. It is very different from what we are used
    to. This role is created with EKS in mind. This role is a workload identity mapped
    to a role in the Kubernetes cluster.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个角色，它与我们惯用的角色非常不同。这个角色是专为 EKS 创建的，实际上它是映射到 Kubernetes 集群中角色的工作负载身份。
- en: The role is limited in what it can do. We cannot use the role to perform operations
    on other AWS resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色在可执行的操作上有所限制。我们无法使用该角色对其他 AWS 资源执行操作。
- en: 'Alternatively, we can provision the Secrets using the AWS CLI:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用 AWS CLI 来配置 Secrets：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will create a secret and a version.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个机密及其版本。
- en: 'We can also create the role and the policy using the AWC CLI:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 AWS CLI 创建角色和策略：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have a role that can be attached to Kubernetes and retrieve Secrets from
    Secrets Manager. Our next step is to install the CSI plugin.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个可以附加到 Kubernetes 并从 Secrets Manager 中获取机密的角色。下一步是安装 CSI 插件。
- en: AWS Secrets Manager provider for CSI on EKS
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EKS 上的 AWS Secrets Manager CSI 提供程序
- en: It is now time to install the AWS Secrets Manager CSI provider on EKS. The first
    thing to do is to add the Secrets Store CSI Driver plugin to the EKS installation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在 EKS 上安装 AWS Secrets Manager CSI 提供程序了。首先要做的是将 Secrets Store CSI 驱动插件添加到
    EKS 安装中。
- en: 'Let’s start by installing the driver on EKS, since the `secrets-store-csi`
    driver is not available as an add-on:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在 EKS 上安装驱动程序，因为 `secrets-store-csi` 驱动程序不能作为附加组件使用：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following will install the `secret-store-csi-driver` DaemonSet. We can
    validate the installation of `secret-store-csi-driver` with the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将安装 `secret-store-csi-driver` DaemonSet。我们可以使用以下命令验证 `secret-store-csi-driver`
    是否已正确安装：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can proceed with fetching the credentials from the secret store through Kubernetes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Kubernetes 从机密存储中获取凭证。
- en: Fetching Secrets from Kubernetes
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Kubernetes 获取机密
- en: 'First, we want to map the secret through a secret provider class. In the object,
    we specify the name of the secret we want to fetch:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过机密提供者类来映射机密。在对象中，我们指定要获取的机密名称：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We map a Kubernetes secret to a secret provided by AWS Secrets Manager.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Kubernetes 密钥映射到 AWS Secrets Manager 提供的机密。
- en: 'Now we need a Kubernetes service account with permission to retrieve this secret:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个具有获取此机密权限的 Kubernetes 服务帐户：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `eks.amazonaws.com/role-arn` section, we specify the AWS role with the
    permissions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `eks.amazonaws.com/role-arn` 部分，我们指定具有权限的 AWS 角色。
- en: As we can see, the service account is annotated with an AWS role, which is the
    AWS role we created previously.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，服务帐户已用 AWS 角色进行了注解，这个角色是我们之前创建的 AWS 角色。
- en: This service account, provided it is attached to a Pod, will assume this role
    identity by using the Kubernetes OIDC provider. More on OIDC and Kubernetes service
    accounts can be found in the official documentation ([https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 只要该服务账户附加到 Pod，它就会通过 Kubernetes OIDC 提供程序假设这个角色身份。有关 OIDC 和 Kubernetes 服务账户的更多信息，请参阅官方文档（[https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)）。
- en: 'When the Pod is created, it will use that service account and mount that secret
    upon it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Pod 创建时，它会使用该服务账户并挂载该秘密：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can test this by printing the secret:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印秘密来测试这个：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To summarize, we created a Pod with a service account, which was mapped to an
    AWS role. This service account had permission to interact with AWS Secrets Manager.
    As a result, we see the secret that we mounted previously. In the next section,
    we will focus on how we can track the actions that take place in AWS Secrets Manager,
    through auditing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们创建了一个带有服务账户的 Pod，该账户映射到 AWS 角色。这个服务账户有权限与 AWS Secrets Manager 交互。因此，我们可以看到之前挂载的秘密。在接下来的章节中，我们将重点介绍如何通过审计跟踪
    AWS Secrets Manager 中发生的操作。
- en: Auditing
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计
- en: We have successfully created Secrets and made sure we received them securely
    by utilizing AWS IAM. Since secure access has been tackled and we have fine-grained
    permissions, we are interested in also logging the usage of and access to our
    Secrets management instance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了 Secrets，并通过利用 AWS IAM 确保我们安全地接收它们。由于我们已经解决了安全访问问题，并且拥有细粒度权限，因此我们还希望记录对我们的
    Secrets 管理实例的使用和访问。
- en: 'There are two ways to evaluate the secret access that occurs in Kubernetes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以评估 Kubernetes 中发生的秘密访问：
- en: Kubernetes Secrets access logs
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Secrets 访问日志
- en: AWS Secrets Manager logs
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 日志
- en: When auditing occurs, a log message is printed in the output of a program. This
    is integrated with CloudWatch, the logging solution provided by AWS, and CloudTrail,
    the auditing solution that AWS provides.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生审计时，日志消息会打印在程序输出中。这个功能与 AWS 提供的日志解决方案 CloudWatch 和审计解决方案 CloudTrail 集成。
- en: Kubernetes logs on CloudWatch
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 日志在 CloudWatch 上
- en: 'By using CloudWatch, we can browse the Kubernetes logs. Suppose we created
    a secret called `audit-test`. We can search for any operations on Logs Insights
    ([https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights](https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights)).
    We can use the following log:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 CloudWatch，我们可以浏览 Kubernetes 日志。假设我们创建了一个名为 `audit-test` 的秘密。我们可以在 Logs
    Insights 中搜索任何操作（[https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights](https://console.aws.amazon.com/cloudwatch/home?logsV2%3Alogs-insights=#logsV2:logs-insights)）。我们可以使用以下日志：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result entries will show the actual results:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结果条目将显示实际的结果：
- en: '| **Field** | **Value** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@``message` | `{"kind":"Event",...,"verb":"get","user":{"username":"kubernetes-admin",
    "uid":"aws-iam-authenticator:274402012893:AIDAILH3OPGRUQEOHAR3O", "groups":["system:masters","system:authenticated"],
    "extra":{"accessKeyId": ["AKIAI5INYQBL233Y7J6Q"],"arn": ["arn:aws:iam::274402012893:
    user/ gkatzioura"],"canonicalArn": ["arn:aws:iam:: 274402012893: user/gkatzioura"],
    "principalId": ["AIDAILH3OPGRUQEOHAR3O"],"sessionName": [""]}},"sourceIPs":["90.221.185.67"],"userAgent":
    "kubectl/v1.25.4 (darwin/arm64) kubernetes/872a965","objectRef":{"resource": "secrets","namespace":"default",
    "``name":"audit-test", "apiVersion":"v1"},"responseStatus":{"metadata":...}` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `@``消息` | `{"kind":"Event",...,"verb":"get","user":{"username":"kubernetes-admin",
    "uid":"aws-iam-authenticator:274402012893:AIDAILH3OPGRUQEOHAR3O", "groups":["system:masters","system:authenticated"],
    "extra":{"accessKeyId": ["AKIAI5INYQBL233Y7J6Q"],"arn": ["arn:aws:iam::274402012893:
    user/ gkatzioura"],"canonicalArn": ["arn:aws:iam:: 274402012893: user/gkatzioura"],
    "principalId": ["AIDAILH3OPGRUQEOHAR3O"],"sessionName": [""]}},"sourceIPs":["90.221.185.67"],"userAgent":
    "kubectl/v1.25.4 (darwin/arm64) kubernetes/872a965","objectRef":{"resource": "secrets","namespace":"default",
    "``name":"audit-test", "apiVersion":"v1"},"responseStatus":{"metadata":...}` |'
- en: '| `@``timestamp` | `1692687754591` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `@``时间戳` | `1692687754591` |'
- en: This result looks familiar. It is the log we saw previously in [*Chapter 2*](B20970_02.xhtml#_idTextAnchor031),
    *Walking through Kubernetes Secrets Management Concepts*, when we were auditing
    Kubernetes Secrets.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果看起来很熟悉。它是我们之前在 [*第二章*](B20970_02.xhtml#_idTextAnchor031) 中看到的日志，*走进 Kubernetes
    Secrets 管理概念*，当时我们正在审计 Kubernetes Secrets。
- en: Also, CloudWatch gives us the option to create alarms. If there are unexpected
    log entries that indicate access or access attempts to a secret, we can configure
    CloudWatch to create an alert and notify us through the communication channel
    of our choice, for example, email.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CloudWatch 允许我们创建警报。如果存在意外的日志条目，表明访问或尝试访问某个密钥，我们可以配置 CloudWatch 创建警报，并通过我们选择的通信渠道通知我们，例如通过电子邮件。
- en: AWS Secrets Manager logs on AWS CloudTrail
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS Secrets Manager 在 AWS CloudTrail 上的日志记录
- en: AWS CloudTrail is a service specifically for audit logs. With CloudTrail, we
    can identify the retrieval of Kubernetes Secrets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudTrail 是一个专门用于审计日志的服务。通过 CloudTrail，我们可以识别 Kubernetes 密钥的检索操作。
- en: 'For example, we can use this URL to view the Secrets that have been recently
    retrieved in our AWS account: [https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue](https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用此 URL 查看我们 AWS 账户中最近检索的密钥：[https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue](https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=GetSecretValue)。
- en: 'If we navigate to the URL, the retrieval information from AWS Secrets Manager
    will be displayed:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问该 URL，AWS Secrets Manager 中的检索信息将会显示：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The user identity is the AWS role we created previously. The event name is a
    `GetSecretValue` event. `r``equestParameters` is the resource the operation is
    executed on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 用户身份是我们之前创建的 AWS 角色。事件名称是 `GetSecretValue` 事件。`r``equestParameters` 是执行操作的资源。
- en: KMS for AWS Secrets encryption
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Secrets 加密的 KMS
- en: Kubernetes gives us the option to specify certain encryption providers when
    storing the Secrets on etcd. AWS KMS can be used as an encryption provider to
    encrypt the Secrets hosted on etcd.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 允许我们在将密钥存储到 etcd 时指定特定的加密提供者。AWS KMS 可以作为加密提供者来加密托管在 etcd 上的密钥。
- en: Provisioning KMS
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 KMS
- en: 'We shall provision a KMS key using Terraform:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Terraform 配置一个 KMS 密钥：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That key is now ready to be used standalone or with other AWS components.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该密钥现在可以单独使用，也可以与其他 AWS 组件一起使用。
- en: Using KMS with EKS
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 EKS 中使用 KMS
- en: 'Having created the EKS cluster, we can now specify the credentials that will
    decrypt the Secrets:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 EKS 集群后，我们可以指定将解密密钥的凭证：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we try to fetch the credentials from Kubernetes, the Secrets will be decrypted
    using the KMS we specified. We can use AWS CloudTrail to identify the usage. We
    can access CloudTrail events by following this link: [https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt](https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从 Kubernetes 获取凭证，密钥将使用我们指定的 KMS 进行解密。我们可以使用 AWS CloudTrail 来识别使用情况。我们可以通过以下链接访问
    CloudTrail 事件：[https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt](https://console.aws.amazon.com/cloudtrail/home?#/events?EventName=Decrypt)。
- en: If we navigate to the page, the decryption operation will be displayed onscreen.
    Also, it will display the user responsible for the decryption operation that took
    place, which in our case is the role associated with the Kubernetes cluster.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问该页面，解密操作将显示在屏幕上。同时，它将显示进行解密操作的用户，在我们的案例中是与 Kubernetes 集群关联的角色。
- en: 'The information will be in JSON format:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 信息将以 JSON 格式呈现：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We managed to store our Secrets encrypted on `etcd` using AWS KMS. Our secret
    residing on etcd will be encrypted and we should be able to monitor any encryption/decryption
    operations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 AWS KMS，将我们的密钥以加密形式存储在 `etcd` 上。存储在 etcd 上的密钥将被加密，我们应该能够监控任何加密/解密操作。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we created a VPC network that spans three availability zones.
    On top of that network, we provisioned an EKS cluster. We managed to integrate
    the EKS cluster with AWS Secrets Manager. This was done securely by implementing
    a fine-grained role on AWS mapped to our Kubernetes workloads. We then proceeded
    to identify the operations that took place with regard to the Secrets stored on
    AWS Secrets Manager by checking CloudWatch and CloudTrail logs. Lastly, we encrypted
    the Secrets residing on an EKS cluster by using a managed KMS. In the next chapter,
    we shall focus on another popular cloud provider and its secret-handling capabilities:
    Microsoft Azure.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个跨越三个可用区的 VPC 网络。在该网络之上，我们配置了一个 EKS 集群。我们成功地将 EKS 集群与 AWS Secrets
    Manager 集成。这是通过在 AWS 上实现精细粒度的角色映射到我们的 Kubernetes 工作负载来安全完成的。接着，我们通过检查 CloudWatch
    和 CloudTrail 日志，确定了与 AWS Secrets Manager 上存储的密钥相关的操作。最后，我们通过使用托管的 KMS 对存储在 EKS
    集群上的密钥进行了加密。在下一章中，我们将重点介绍另一个流行的云服务提供商及其密钥处理能力：微软 Azure。
