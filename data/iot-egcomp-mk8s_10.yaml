- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Going Serverless with Knative and OpenFaaS Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Knative 和 OpenFaaS 框架实现无服务器
- en: In the last chapter, we discussed Kubeflow, which provides an easy-to-deploy,
    simple-to-use toolchain for data scientists to integrate the various resources
    they will need to run models on Kubernetes, such as Jupyter notebooks, Kubernetes
    deployment files, and machine learning libraries such as PyTorch and TensorFlow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 Kubeflow，它为数据科学家提供了一个易于部署、简便使用的工具链，使他们能够集成运行模型所需的各种资源，如 Jupyter
    笔记本、Kubernetes 部署文件以及像 PyTorch 和 TensorFlow 这样的机器学习库。
- en: By using Kubeflow’s built-in Notebooks services, you can create notebooks and
    share them with your teams. We also went over how to set up a machine learning
    pipeline to develop and deploy an example model using the Kubeflow machine learning
    platform. Additionally, we established that Kubeflow on MicroK8s is simple to
    set up and configure, lightweight, and capable of simulating real-world conditions
    while building, migrating, and deploying pipelines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Kubeflow 内置的 Notebooks 服务，您可以创建笔记本并与团队共享。我们还讲解了如何设置机器学习管道，利用 Kubeflow 机器学习平台开发和部署示例模型。此外，我们已经确认，Kubeflow
    在 MicroK8s 上的设置和配置简单、轻量，能够在构建、迁移和部署管道时模拟真实世界的条件。
- en: In this chapter, we will look at the most popular open source serverless frameworks
    that extend Kubernetes with components for deploying, operating, and managing
    serverless, cloud-native apps. These frameworks enable you to create a service
    by encapsulating the code in a container image and delivering the required functionalities.
    Serverless frameworks automatically start and stop instances, so your code only
    runs when it’s needed. Unless your code needs to accomplish something, resources
    aren’t used.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨最受欢迎的开源无服务器框架，这些框架通过为部署、操作和管理无服务器云原生应用程序提供组件，扩展了 Kubernetes。这些框架使您能够通过将代码封装在容器镜像中并提供所需的功能来创建服务。无服务器框架会自动启动和停止实例，因此您的代码仅在需要时运行。除非您的代码需要完成某些任务，否则不会使用资源。
- en: Kubernetes’ container orchestration capabilities (such as scheduling, load balancing,
    and health monitoring) make container proliferation much easier. However, this
    requires developers to perform or template several repetitive tasks, such as pulling
    application source code from repositories, building and provisioning a container
    image around the code, and configuring network connections outside of Kubernetes
    using various tools. Additionally, integrating Kubernetes-managed containers into
    an automated **continuous integration/continuous delivery** (**CI/CD**) pipeline
    necessitates the use of new tools and scripting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的容器编排能力（如调度、负载均衡和健康监控）使容器的扩展变得更加容易。然而，这要求开发者执行或模板化多个重复性任务，如从代码仓库中拉取应用源代码、围绕代码构建和配置容器镜像，以及使用各种工具配置
    Kubernetes 之外的网络连接。此外，将 Kubernetes 管理的容器集成到自动化的**持续集成/持续交付**（**CI/CD**）管道中，需使用新的工具和脚本。
- en: With serverless frameworks automating the aforementioned activities from within
    Kubernetes, it eliminates complexity. A developer would be able to define the
    contents and configuration of a container in a single YAML manifest file, and
    serverless frameworks would take care of the rest, including building the container
    and conducting network programming to set up a route, should be Ingress, load
    balancing, and more.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过无服务器框架在 Kubernetes 内自动化上述活动，消除了复杂性。开发者可以在单一的 YAML 清单文件中定义容器的内容和配置，其他工作将由无服务器框架处理，包括构建容器、进行网络编程以设置路由，应该是
    Ingress、负载均衡等。
- en: Serverless computing is becoming the preferred cloud-native execution approach
    as it makes developing and running applications much easier and more cost-effective.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算正在成为首选的云原生执行方式，因为它使得开发和运行应用程序变得更加容易和具有成本效益。
- en: 'The serverless model of computing offers the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算模型提供以下优势：
- en: Provisioning of resources on demand, scaling transparently based on demands,
    and scaling to zero when no more requests are made
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需提供资源，基于需求透明地进行扩展，并在没有请求时扩展到零
- en: Offloading all infrastructure management responsibilities to the infrastructure
    provider, allowing developers to spend their time and effort on creation and innovation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有基础设施管理责任转移给基础设施提供商，让开发者可以将时间和精力用于创造和创新
- en: Allowing users to pay only for resources that are used, never for idle capacity
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅按实际使用的资源收费，避免闲置容量的费用
- en: Kubernetes cannot run serverless apps on its own; we would need customized software
    that combines Kubernetes with a specific infrastructure provider’s serverless
    platform. By abstracting away the code and handling network routing, event triggers,
    and autoscaling, the serverless frameworks would enable any container to run as
    a serverless workload on any Kubernetes cluster; it doesn’t matter whether the
    container is built around a serverless function or other application code (for
    example, microservices).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 本身无法运行无服务器应用；我们需要定制的软件，将 Kubernetes 与特定基础设施提供商的无服务器平台结合起来。通过抽象代码并处理网络路由、事件触发和自动扩展，服务器无框架将使任何容器都能在任何
    Kubernetes 集群上作为无服务器工作负载运行；无论该容器是围绕无服务器函数构建的，还是其他应用程序代码（例如微服务）。
- en: Serverless computing, especially when deployed at the network’s edge, is considered
    a key enabler for the building of increasingly complex **Internet of Things**
    (**IoT**) systems in the future. However, when installing new edge infrastructures
    for serverless workloads, additional attention must be paid to resource usage
    and network connectivity. Studies show that edge-oriented distributions, such
    as MicroK8s, perform better in the majority of tests, including cold start delay,
    serial execution performance, parallel execution with a single replica, and parallel
    execution using various autoscaling techniques.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算，尤其是在网络边缘部署时，被认为是未来构建日益复杂的**物联网**（**IoT**）系统的关键推动力。然而，在为无服务器工作负载安装新的边缘基础设施时，必须特别关注资源使用和网络连接性。研究表明，面向边缘的分发版，如
    MicroK8s，在大多数测试中表现更好，包括冷启动延迟、串行执行性能、单副本并行执行以及使用各种自动扩展技术的并行执行。
- en: 'We’ll look at two of the most popular serverless frameworks included with MicroK8s
    in this chapter: Knative and OpenFaaS. Both serverless frameworks are Kubernetes-based
    platforms for building, deploying, and managing modern serverless workloads. In
    this chapter, we’re going to cover the following main topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论 MicroK8s 附带的两大流行无服务器框架：Knative 和 OpenFaaS。这两大无服务器框架都是基于 Kubernetes 的平台，用于构建、部署和管理现代的无服务器工作负载。本章我们将涵盖以下主要内容：
- en: Overview – Knative framework
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative 框架概述
- en: Enabling the Knative add-on
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 Knative 插件
- en: Deploying and running a sample service on Knative
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Knative 上部署和运行示例服务
- en: Overview – OpenFaaS framework
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenFaaS 框架概述
- en: Enabling the OpenFaaS add-on
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 OpenFaaS 插件
- en: Deploying and running a sample function on OpenFaaS
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenFaaS 上部署和运行示例函数
- en: Best practices for developing and deploying serverless applications
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和部署无服务器应用的最佳实践
- en: Overview of the Knative framework
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knative 框架概述
- en: 'Knative is a Kubernetes-based platform for deploying, managing, and scaling
    modern serverless workloads. Knative has the following three main components:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 是一个基于 Kubernetes 的平台，用于部署、管理和扩展现代的无服务器工作负载。Knative 具有以下三个主要组件：
- en: '**Build**: Provides streamlined source-to-container builds that are easy to
    utilize. By utilizing common constructs, you gain an advantage.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：提供简化的源代码到容器的构建，使用起来非常方便。通过利用常见的构建模块，你将获得优势。'
- en: '**Serving**: Networking, autoscaling, and revision tracking are all handled
    by Knative. All you have to do now is concentrate on your core logic.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：Knative 处理所有的网络、自动扩展和版本跟踪。现在你只需要专注于你的核心逻辑。'
- en: '**Eventing**: Handles the subscription, delivery, and management of events.
    By connecting containers to a data stream via declarative event connection and
    developer-friendly object architecture, you can create modern apps.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理**：处理事件的订阅、传递和管理。通过声明式事件连接和开发者友好的对象架构将容器连接到数据流，你可以创建现代应用程序。'
- en: MicroK8s is the optimal solution to getting started with all of the components
    of Knative (Build, Serving, and Eventing) because it provides native support for
    Knative. We’ll go through each component in detail in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MicroK8s 是启动 Knative（构建、服务和事件处理）所有组件的最佳解决方案，因为它原生支持 Knative。我们将在下一节详细讨论每个组件。
- en: Build components
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建组件
- en: 'The Knative Build component simplifies the process of building a container
    from source code. This procedure usually consists of the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Knative Build 组件简化了从源代码构建容器的过程。这个过程通常包括以下步骤：
- en: Downloading source code from a code repository such as GitHub
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码仓库（如 GitHub）下载源代码
- en: Installing the underlying dependencies that the code requires to run, such as
    environment variables and software libraries
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装代码运行所需的基础依赖项，如环境变量和软件库
- en: Container image creation
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器镜像创建
- en: Placing container images in a registry accessible to the Kubernetes cluster
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器镜像放置在 Kubernetes 集群可访问的镜像库中
- en: For its Build process, Knative makes use of Kubernetes **application programming
    interfaces** (**APIs**) and other technologies. The developer can use a single
    manifest (usually a YAML file) that describes all of the variables’ location of
    the source code, required dependencies, and so on. Knative leverages the manifest
    to automate the container building and image creation process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在其构建过程中，Knative 利用 Kubernetes **应用程序编程接口** (**APIs**) 及其他技术。开发人员可以使用单一清单（通常是
    YAML 文件）来描述源代码的位置、所需的依赖项等所有变量。Knative 利用该清单自动化容器构建和镜像创建过程。
- en: Serving components
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serving 组件
- en: 'Containers are deployed and run as scalable Knative services via the Serving
    component. The following are the key capabilities provided by the Serving component:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过 Serving 组件作为可扩展的 Knative 服务进行部署和运行。以下是 Serving 组件提供的关键功能：
- en: '**Configuration**: A service’s state is defined and maintained by configuration.
    It also has version control. Each change to the configuration creates a new version
    of the service, which is saved alongside earlier versions.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：服务的状态由配置定义并维护。它还具有版本控制功能。每次更改配置时，都会创建服务的新版本，并与早期版本一起保存。'
- en: '**Intelligent service routing**: Developers can use intelligent service routing
    to direct traffic to different versions of the service. Assume you’ve produced
    a new version of a service and want to test it out on a small group of users before
    moving everyone. Intelligent service routing allows you to send a portion of user
    requests to the new service and the rest to an older version. As you gain confidence
    in the new service, you can send more traffic to it.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能服务路由**：开发人员可以使用智能服务路由将流量引导到服务的不同版本。例如，你已创建了服务的新版本，并希望在将所有用户切换过去之前，先在小范围内测试。智能服务路由允许你将一部分用户请求发送到新服务，其余请求发送到旧版本。随着对新服务的信心增加，你可以将更多流量发送到它。'
- en: '**Autoscaling**: Knative can scale services up to thousands of instances and
    down to zero instances, which is critical for serverless applications.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动扩缩**：Knative 可以将服务扩展到数千个实例，或缩减到零实例，这对于无服务器应用程序至关重要。'
- en: '**Istio** ([https://istio.io/](https://istio.io/)): This is an open source
    Kubernetes service mesh deployed along with Knative. It offers service request
    authentication, automatic traffic encryption for safe communication between services,
    and extensive metrics on microservices and serverless function operations for
    developers and administrators to use to improve infrastructure.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Istio** ([https://istio.io/](https://istio.io/)): 这是一个开源 Kubernetes 服务网格，与
    Knative 一同部署。它提供服务请求认证、自动流量加密以保证服务间的安全通信，并为开发人员和管理员提供微服务和无服务器函数操作的广泛指标，用于改进基础设施。'
- en: 'Knative Serving is defined by a set of objects known as Kubernetes **Custom
    Resource Definitions** (**CRDs**). The following components define and govern
    the behavior of your serverless workload on the cluster:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Knative Serving 由一组被称为 Kubernetes **自定义资源定义** (**CRDs**) 的对象定义。以下组件定义并管理集群中无服务器工作负载的行为：
- en: '**Service**: Controls the entire life cycle of your workload for you. It ensures
    that your app has a route, a configuration, and a new revision for each service
    update by controlling the creation of additional objects. The service can be configured
    to always send traffic to the most recent revision or a pinned revision.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：控制工作负载的整个生命周期。它通过控制附加对象的创建，确保应用程序始终有路由、配置和每次服务更新时的新修订版本。可以将服务配置为始终将流量发送到最新的修订版本，或固定某个修订版本。'
- en: '**Route**: A network endpoint is mapped to one or more revisions. Traffic can
    be managed in a variety of ways, including fractional traffic and named routes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：网络端点映射到一个或多个修订版本。流量可以通过多种方式进行管理，包括流量分配和命名路由。'
- en: '**Revision**: This is a snapshot of the code and configuration for each change
    made to the workload at a specific moment in time. Revisions are immutable objects
    that can be kept for as long as they are needed. Knative Serving Revisions can
    be scaled up and down automatically in response to incoming traffic.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订版本**：这是工作负载在特定时间点对代码和配置的快照。修订版本是不可变对象，可以根据需要保留。Knative Serving 修订版本可以根据流量的变化自动进行扩缩容。'
- en: '**Configuration**: This keeps your deployment in the desired state. It adheres
    to the Twelve-Factor App paradigm and provides a clear separation between code
    and configuration. A new revision is created when you change a configuration.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：这保持了部署在所需的状态下。它遵循十二因素应用（Twelve-Factor App）范式，并提供代码与配置之间的清晰分离。每当更改配置时，都会创建一个新的修订版本。'
- en: To summarize, the Serving component is responsible for deploying and running
    containers as scalable Knative services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Serving 组件负责部署和运行容器，作为可扩展的 Knative 服务。
- en: Eventing components
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eventing 组件
- en: Knative’s Eventing component allows various events to trigger container-based
    services and functions. There is no need to develop scripts or implement middleware
    because Knative queues handle the distribution of events to the respective containers.
    A messaging bus that distributes events to containers and channels, which are
    nothing but queues of events (from which developers can choose), is also handled
    by Knative. Developers can also establish feeds that connect an event to a specific
    action that their containers should execute.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 的 Eventing 组件允许各种事件触发基于容器的服务和函数。无需开发脚本或实现中间件，因为 Knative 队列处理事件的分发到相应的容器。一个分发事件到容器和通道的消息总线（通道仅仅是事件队列，开发者可以选择）也由
    Knative 处理。开发人员还可以建立连接事件和特定操作的馈送，指示容器应执行的动作。
- en: Knative event sources make integration with third-party event providers easier
    for developers. The Eventing component will connect to the event producer and
    route the generated events automatically. It also provides tools for routing events
    from event producers to sinks, allowing developers to build applications that
    use an event-driven architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 事件源让开发人员与第三方事件提供者的集成变得更加简单。Eventing 组件将连接到事件生产者，并自动路由生成的事件。它还提供了将事件从事件生产者路由到接收器的工具，允许开发人员构建使用事件驱动架构的应用程序。
- en: 'Knative Eventing resources are loosely coupled and can be developed and deployed
    separately. Any producer can generate events and any event consumer can express
    interest in that event or group of events. Knative Eventing also takes care of
    sending and receiving events between event producers and sinks using standard
    HTTP POST requests. The following are the Eventing components:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Knative Eventing 资源是松散耦合的，可以单独开发和部署。任何生产者都可以生成事件，任何事件消费者都可以对该事件或一组事件表示兴趣。Knative
    Eventing 还负责通过标准的 HTTP POST 请求在事件生产者和接收器之间发送和接收事件。以下是 Eventing 组件：
- en: '**Event sources**: These are the primary event producers in a Knative Eventing
    deployment. Events are routed to either a sink or a subscriber.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件源**：这些是 Knative Eventing 部署中的主要事件生产者。事件被路由到接收器或订阅者。'
- en: '**Brokers and Triggers**: These provide an event mesh model that allows event
    producers to deliver events to a Broker, which then distributes them uniformly
    to consumers via Triggers.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Broker 和 Trigger**：这些提供了一个事件网格模型，允许事件生产者将事件交付给 Broker，Broker 然后通过 Trigger
    均匀地分发给消费者。'
- en: '**Channels and Subscriptions**: These work together to create an event pipe
    model that transforms and routes events between channels via Subscriptions. This
    model is suitable for event pipelines in which events from one system must be
    transformed before being routed to another process.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道与订阅**：这些组件共同作用，创建一个事件管道模型，通过订阅在通道之间转换和路由事件。该模型适用于事件流水线，其中来自一个系统的事件必须在路由到另一个进程之前进行转换。'
- en: '**Event registry**: Knative Eventing defines an EventType object to help consumers
    discover the types of events available from Brokers. The registry is made up of
    various event types. The event types stored in the registry contain all of the
    information needed for a consumer to create a Trigger without using an out-of-band
    mechanism.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件注册**：Knative Eventing 定义了一个 EventType 对象，帮助消费者发现来自 Broker 的可用事件类型。注册表由各种事件类型组成。存储在注册表中的事件类型包含了消费者创建触发器所需的所有信息，而无需使用带外机制。'
- en: 'In the following figure, Knative components are represented. Serving and Eventing
    collaborate on tasks and applications to automate and manage them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，展示了Knative组件。Serving和Eventing共同协作执行任务和应用程序，以自动化和管理它们：
- en: '![Figure 10.1 – Knative components ](img/Figure_10.01_B18115.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – Knative组件](img/Figure_10.01_B18115.jpg)'
- en: Figure 10.1 – Knative components
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Knative组件
- en: 'To recap, Knative provides components that allow the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Knative提供了以下组件：
- en: Serverless containers can be deployed quickly.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器容器可以快速部署。
- en: Scaling pods down to zero as well as autoscaling based on demands.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将Pod缩放到零，并根据需求进行自动缩放。
- en: Multiple networking layers are supported for integration including Contour,
    Kourier, and Istio.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个网络层的集成，包括Contour、Kourier和Istio。
- en: Support for point-in-time snapshots of deployed code and configurations.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持已部署代码和配置的时间点快照。
- en: Support for both HTTP and HTTPS networking protocols.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTTP和HTTPS网络协议。
- en: Now that we’ve covered the basics of Knative, we’ll enable the add-on and deploy
    one of the samples in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了Knative的基础知识，接下来我们将在下一部分启用附加组件并部署其中一个示例。
- en: Enabling the Knative add-on
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Knative附加组件
- en: Since Knative isn’t available for ARM64 architecture, we will be using an Ubuntu
    virtual machine for this section. The instructions for setting up the MicroK8s
    cluster are the same as in [*Chapter 5*](B18115_05.xhtml#_idTextAnchor070)*,*
    *Creating and Implementing Updates on Multi-Node Raspberry Pi Kubernetes Clusters*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Knative不支持ARM64架构，我们将在本部分使用Ubuntu虚拟机。设置MicroK8s集群的说明与[*第五章*](B18115_05.xhtml#_idTextAnchor070)中*，*《创建和实现多节点树莓派Kubernetes集群的更新》相同。
- en: 'We’ll enable the Knative add-on that adds Knative middleware to your cluster.
    Use the following command to enable the Knative add-on:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启用Knative附加组件，将Knative中间件添加到您的集群中。使用以下命令启用Knative附加组件：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you enable this add-on, Istio and DNS will be also added to MicroK8s.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此附加组件时，Istio和DNS也将添加到MicroK8s。
- en: 'The following command execution output confirms that the Knative add-on is
    being enabled:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出确认Knative附加组件正在启用：
- en: '![Figure 10.2 – Enabling the Knative add-on ](img/Figure_10.02_B18115.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 启用Knative附加组件](img/Figure_10.02_B18115.jpg)'
- en: Figure 10.2 – Enabling the Knative add-on
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 启用Knative附加组件
- en: 'It will take some time to finish activating the add-on. The following command
    execution output shows that Knative has been successfully enabled:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 启动附加组件需要一些时间。以下命令执行输出显示Knative已成功启用：
- en: '![Figure 10.3 – Knative add-on activated ](img/Figure_10.03_B18115.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – Knative附加组件已激活](img/Figure_10.03_B18115.jpg)'
- en: Figure 10.3 – Knative add-on activated
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – Knative附加组件已激活
- en: Before moving on to the next step, let’s verify whether the add-on has been
    enabled and that all the required pods are running.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一步之前，让我们验证附加组件是否已启用，并且所有必需的Pod都在运行。
- en: 'To see whether the add-on is activated or not, use the `kubectl get pods -n
    knative-serving` command. The following command execution output indicates that
    Knative Serving components are running:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看附加组件是否已激活，请使用`kubectl get pods -n knative-serving`命令。以下命令执行输出表明Knative Serving组件正在运行：
- en: '![Figure 10.4 – Knative Serving component pods are running ](img/Figure_10.04_B18115.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – Knative Serving组件的Pod正在运行](img/Figure_10.04_B18115.jpg)'
- en: Figure 10.4 – Knative Serving component pods are running
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – Knative Serving组件的Pod正在运行
- en: 'Before we move on to the next step, let’s make sure that all of the Knative
    Eventing components are up and running using the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一步之前，让我们使用以下命令确认所有Knative Eventing组件是否都已启动并正常运行：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following command execution output indicates that Knative Eventing components
    are also running:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明Knative Eventing组件也在运行：
- en: '![Figure 10.5 – Knative Eventing components are running ](img/Figure_10.05_B18115.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – Knative Eventing组件正在运行](img/Figure_10.05_B18115.jpg)'
- en: Figure 10.5 – Knative Eventing components are running
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – Knative Eventing组件正在运行
- en: We now have all of the components of Knative up and running.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动并运行了所有Knative组件。
- en: We will proceed to the next step of installing the Knative `kn`. Without having
    to create or edit YAML files manually, `kn` provides a quick and easy interface
    for building Knative resources, such as services and event sources. It also makes
    it easier to complete tasks such as autoscaling and traffic splitting that might
    otherwise be difficult.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续安装 Knative `kn` 的下一步。无需手动创建或编辑 YAML 文件，`kn` 提供了一个快速简便的界面来构建 Knative 资源，如服务和事件源。它还简化了诸如自动扩展和流量分配等任务，这些任务否则可能会比较复杂。
- en: 'The `kn` binary can be downloaded from the release page ([https://github.com/knative/client/releases](https://github.com/knative/client/releases))
    and copied to `/usr/local/bin` using the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从发布页面下载 `kn` 二进制文件（[https://github.com/knative/client/releases](https://github.com/knative/client/releases)），并使用以下命令将其复制到
    `/usr/local/bin` 目录：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following command execution output confirms that the `kn` CLI has been
    downloaded successfully and is available at `/usr/local/bin`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出确认 `kn` CLI 已成功下载，并且可在 `/usr/local/bin` 目录下使用：
- en: '![Figure 10.6 – Installing the Knative CLI ](img/Figure_10.06_B18115.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 安装 Knative CLI](img/Figure_10.06_B18115.jpg)'
- en: Figure 10.6 – Installing the Knative CLI
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 安装 Knative CLI
- en: 'Before moving on to the next step, let’s verify whether the `kn` CLI is working
    by running the following `kn version` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一步之前，让我们通过运行以下 `kn version` 命令来验证 `kn` CLI 是否正常工作：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following output confirms that the `kn` CLI is operational, and its version
    and build date are displayed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出确认 `kn` CLI 正常运行，并显示其版本和构建日期：
- en: '![Figure 10.7 – Verifying whether the kn CLI is operational ](img/Figure_10.07_B18115.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 验证 kn CLI 是否正常运行](img/Figure_10.07_B18115.jpg)'
- en: Figure 10.7 – Verifying whether the kn CLI is operational
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 验证 kn CLI 是否正常运行
- en: 'For the `kn` CLI to access Kubernetes configuration, copy the MicroK8s configuration
    file to `$HOME/.kube/config` as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `kn` CLI 访问 Kubernetes 配置文件，请将 MicroK8s 配置文件复制到 `$HOME/.kube/config`，操作命令如下：
- en: '![Figure 10.8 – Copy MicroK8s configuration file to $HOME folder ](img/Figure_10.08_B18115.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 将 MicroK8s 配置文件复制到 $HOME 文件夹](img/Figure_10.08_B18115.jpg)'
- en: Figure 10.8 – Copy MicroK8s configuration file to $HOME folder
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 将 MicroK8s 配置文件复制到 $HOME 文件夹
- en: 'All of the Knative components, as well as the Knative CLI `kn` setup, are now
    up and running. We’ll now move on to the following step: deploying and running
    the sample service.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Knative 组件以及 Knative CLI `kn` 配置现在都已启动并运行。接下来我们将进入下一步：部署并运行示例服务。
- en: Deploying and running a sample service on Knative
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Knative 上部署并运行示例服务
- en: In this section, we will deploy the `Hello world` sample service from the Knative
    samples repo. The sample service prints `Hello` `$TARGET!` after reading the `TARGET`
    environment variable. If `TARGET` is not given, the default value is “`World`”.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从 Knative 示例仓库中部署 `Hello world` 示例服务。该示例服务会读取 `TARGET` 环境变量并打印 `Hello`
    `$TARGET!`。如果没有提供 `TARGET`，默认值为 "`World`"。
- en: Now in the following steps, we’ll deploy the service by specifying the image
    location and the `TARGET` environment variable. We are going to create a Knative
    service (Serving component), which is a time-based representation of a single
    serverless container environment (such as a microservice). It includes both the
    network address for accessing the service and the application code and settings
    required to run the service.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤中，我们将通过指定镜像位置和 `TARGET` 环境变量来部署服务。我们将创建一个 Knative 服务（Serving 组件），它是基于时间的单一无服务器容器环境（如微服务）的表示形式。它包含访问该服务的网络地址以及运行该服务所需的应用程序代码和设置。
- en: 'A Knative service lifespan is controlled by the `serving.knative.dev` CRD.
    To create the Knative service, we’ll use the `kn` CLI as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 服务的生命周期由 `serving.knative.dev` CRD 控制。为了创建 Knative 服务，我们将使用 `kn` CLI，具体命令如下：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following command execution output indicates that the service creation
    is successful and the service can be accessed at the URL `http//kn-serverless.default.example.com`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表示服务创建成功，并且可以通过 URL `http//kn-serverless.default.example.com` 访问该服务：
- en: '![Figure 10.9 – Creating a new Knative service ](img/Figure_10.09_B18115.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 创建新的 Knative 服务](img/Figure_10.09_B18115.jpg)'
- en: Figure 10.9 – Creating a new Knative service
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 创建新的 Knative 服务
- en: Congrats! We have successfully created a new Knative service and deployed it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功创建了一个新的 Knative 服务并进行了部署。
- en: 'The following is a recap of the Serving components:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Serving 组件的概览：
- en: '**Service**: Manages the whole life cycle of your workload'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：管理工作负载的整个生命周期'
- en: '**Route**: Takes care of mapping the network endpoint to one or more revisions'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：负责将网络端点映射到一个或多个修订版本'
- en: '**Configuration**: Maintains the desired state for the deployment'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：保持部署的期望状态'
- en: '**Revision**: A point-in-time snapshot of the code and configuration of the
    workload'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订**：工作负载代码和配置的某一时刻快照'
- en: 'The Serving components involved in the definition and control of how serverless
    workloads behave on the cluster are depicted in the following diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义和控制无服务器工作负载在集群上行为的Serving组件，如下图所示：
- en: '![Figure 10.10 – Knative Serving components ](img/Figure_10.10_B18115.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – Knative Serving组件](img/Figure_10.10_B18115.jpg)'
- en: Figure 10.10 – Knative Serving components
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – Knative Serving组件
- en: 'We can now invoke the service that we previously created using the `curl` command
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像下面这样使用`curl`命令调用我们之前创建的服务：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`$SERVICE_IP` and `$INGRESS_PORT` point to the Knative service and the Ingress
    port that is exposed. The output of the following command confirms that the Knative
    service has been invoked and output has been displayed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`$SERVICE_IP`和`$INGRESS_PORT`指向Knative服务和暴露的Ingress端口。以下命令的输出确认Knative服务已经被调用，并且已显示输出：'
- en: '![Figure 10.11 – Invoking the Knative service ](img/Figure_10.11_B18115.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 调用Knative服务](img/Figure_10.11_B18115.jpg)'
- en: Figure 10.11 – Invoking the Knative service
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 调用Knative服务
- en: 'To observe how a pod is created to service the requests, run the `watch kubectl
    get pods` command in a new Terminal tab. If there are no inbound requests for
    60 seconds, Knative will automatically scale this pod down to zero as shown in
    the following command execution output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要观察Pod如何被创建以处理请求，请在新的终端标签页中运行`watch kubectl get pods`命令。如果60秒内没有传入请求，Knative将自动将该Pod缩减至零，如下所示的命令执行输出：
- en: '![Figure 10.12 – Pods are terminated if there are no inbound requests for 60
    seconds ](img/Figure_10.12_B18115.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 如果60秒内没有传入请求，Pods将被终止](img/Figure_10.12_B18115.jpg)'
- en: Figure 10.12 – Pods are terminated if there are no inbound requests for 60 seconds
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 如果60秒内没有传入请求，Pods将被终止
- en: 'You may also issue the preceding `curl` command after the pods have scaled
    down to zero to watch the pod spin up and serve the request zero as shown in the
    following command execution output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pods缩减至零后，您也可以发出前述的`curl`命令，以查看Pod如何启动并服务请求零，如下所示的命令执行输出：
- en: '![Figure 10.13 – Pods are spun up to serve the requests ](img/Figure_10.13_B18115.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – Pods被启动以服务请求](img/Figure_10.13_B18115.jpg)'
- en: Figure 10.13 – Pods are spun up to serve the requests
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – Pods被启动以服务请求
- en: Knative, in a nutshell, is a Kubernetes-powered platform for developing, deploying,
    and managing modern serverless workloads. We also discovered that MicroK8s has
    native Knative support and is the best way to get started with all of Knative’s
    components (Build, Serving, and Eventing).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Knative是一个基于Kubernetes的开发、部署和管理现代无服务器工作负载的平台。我们还发现，MicroK8s原生支持Knative，并且是入门Knative所有组件（构建、服务和事件）的最佳方式。
- en: We have deployed a sample application and used its endpoints to call it from
    the command line. We will now look at the next choice, OpenFaaS, in the next section
    to run the sample application, and analyze the features it offers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已部署了一个示例应用程序，并使用其端点从命令行调用它。接下来，我们将在下一节中查看选择OpenFaaS以运行示例应用程序，并分析它提供的功能。
- en: Overview of the OpenFaaS framework
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenFaaS框架概述
- en: OpenFaaS (**FaaS** standing for **functions as a service**) is a framework for
    creating serverless functions using the Docker and Kubernetes container technologies.
    Any process can be packaged as a function, allowing the consumption of a variety
    of web events without having to write boilerplate code over and over. It’s an
    open source initiative that’s gaining a lot of traction in the community.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS（**FaaS**代表**函数即服务**）是一个使用Docker和Kubernetes容器技术创建无服务器函数的框架。任何进程都可以被封装为一个函数，从而无需重复编写样板代码即可消费各种Web事件。这是一个开源项目，在社区中正获得越来越多的关注。
- en: 'Some of the key advantages of the OpenFaaS framework are the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaaS框架的一些关键优势如下：
- en: Running functions on any infrastructure without concern of lock-in with an open
    source functions framework.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何基础设施上运行函数，无需担心与开源函数框架的锁定问题。
- en: Creating functions in any programming language and packaging them in Docker/OCI
    containers.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何编程语言中创建函数并将其打包在 Docker/OCI 容器中。
- en: Built-in UI, robust CLI, and one-click installation make it simple to use.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置 UI、强大的 CLI 和一键安装使其使用起来非常简单。
- en: Scale as you go – handle traffic spikes and scale down when not in use.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着需求增长进行扩展——处理流量峰值，并在不使用时缩减规模。
- en: A community edition and a pro edition are available along with production support.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供社区版和专业版，并附带生产支持。
- en: Now that we’ve covered the concepts of OpenFaaS, we’ll enable the add-on and
    deploy one of the samples in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 OpenFaaS 的基本概念，接下来我们将在下一部分启用插件并部署其中一个示例。
- en: Enabling the OpenFaaS add-on
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 OpenFaaS 插件
- en: Since OpenFaaS isn’t available for ARM64 architecture, we will be using an Ubuntu
    virtual machine for this section. The instructions for setting up the MicroK8s
    cluster are the same as in [*Chapter 5*](B18115_05.xhtml#_idTextAnchor070)*,*
    *Creating and Implementing Updates on Multi-Node Raspberry Pi Kubernetes Clusters*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenFaaS 不支持 ARM64 架构，我们将在本部分使用 Ubuntu 虚拟机。设置 MicroK8s 集群的指令与 [*第 5 章*](B18115_05.xhtml#_idTextAnchor070)
    相同，*创建和实施多节点 Raspberry Pi Kubernetes 集群的更新*。
- en: 'Before enabling the OpenFaaS add-on, enable the DNS and Registry add-ons using
    the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 OpenFaaS 插件之前，使用以下命令启用 DNS 和注册表插件：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The DNS is used to provide address resolution services to Kubernetes so that
    services can communicate with each other. The following command execution output
    confirms that the DNS add-on is enabled:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 用于为 Kubernetes 提供地址解析服务，以便各个服务能够相互通信。以下命令执行输出确认 DNS 插件已启用：
- en: '![Figure 10.14 – Enabling the DNS add-on ](img/Figure_10.14_B18115.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 启用 DNS 插件](img/Figure_10.14_B18115.jpg)'
- en: Figure 10.14 – Enabling the DNS add-on
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 启用 DNS 插件
- en: 'Now that the DNS add-on is enabled, we will move on to the next step of enabling
    the Registry add-on using the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 插件已启用后，我们将继续启用注册表插件，使用以下命令：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Registry add-on creates a private registry in Docker and exposes it at
    `localhost:32000`. As part of this add-on, the storage add-on will also be enabled
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表插件在 Docker 中创建一个私有注册表，并将其暴露在 `localhost:32000`。作为此插件的一部分，存储插件也将按以下方式启用：
- en: '![Figure 10.15 – Enabling the Registry add-on ](img/Figure_10.15_B18115.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 启用注册表插件](img/Figure_10.15_B18115.jpg)'
- en: Figure 10.15 – Enabling the Registry add-on
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 启用注册表插件
- en: We can move on to the next step of enabling the OpenFaaS add-on now that we’ve
    enabled the DNS and Registry add-ons.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用了 DNS 和注册表插件后，我们可以继续下一步启用 OpenFaaS 插件。
- en: 'Use the following command to enable the OpenFaaS add-on:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启用 OpenFaaS 插件：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following command execution output confirms that the OpenFaaS add-on is
    being enabled:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出确认 OpenFaaS 插件正在启用：
- en: '![Figure 10.16 – Enabling the OpenFaaS add-on ](img/Figure_10.16_B18115.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 启用 OpenFaaS 插件](img/Figure_10.16_B18115.jpg)'
- en: Figure 10.16 – Enabling the OpenFaaS add-on
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 启用 OpenFaaS 插件
- en: 'It will take some time to finish activating the add-on. The following command
    execution output shows that the OpenFaaS add-on has been successfully enabled:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 启用插件需要一些时间。以下命令执行输出显示 OpenFaaS 插件已成功启用：
- en: '![Figure 10.17 – The OpenFaaS add-on is enabled ](img/Figure_10.17_B18115.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – OpenFaaS 插件已启用](img/Figure_10.17_B18115.jpg)'
- en: Figure 10.17 – The OpenFaaS add-on is enabled
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – OpenFaaS 插件已启用
- en: As you can see, deployment scripts generate a username (admin) and password
    combination during the installation. Save the credentials so we can use them in
    the following steps.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，部署脚本在安装过程中会生成一个用户名（admin）和密码组合。请保存凭据，以便在后续步骤中使用。
- en: Before moving on to the next step, let’s verify whether the add-on has been
    enabled and that all the required pods are running.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一步之前，让我们验证插件是否已启用，并且所有所需的 pods 都在运行。
- en: 'To see whether the add-on is activated, use the `kubectl get pods` command.
    The following command execution output indicates that OpenFaaS components are
    running:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看插件是否已激活，请使用 `kubectl get pods` 命令。以下命令执行输出表明 OpenFaaS 组件正在运行：
- en: '![Figure 10.18 – OpenFaaS pods are running ](img/Figure_10.18_B18115.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – OpenFaaS pods 正在运行](img/Figure_10.18_B18115.jpg)'
- en: Figure 10.18 – OpenFaaS pods are running
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – OpenFaaS pods 正在运行
- en: 'We now have all of the following components of OpenFaaS up and running:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经启动并运行了 OpenFaaS 的以下所有组件：
- en: '`nats` provides asynchronous execution and queuing.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nats` 提供异步执行和排队功能。'
- en: '`prometheus` provides metrics and enables auto-scaling through `alertmanager`.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`prometheus` 提供指标并通过 `alertmanager` 启用自动扩展。'
- en: '`gateway` provides an external route into the functions and also scales functions
    according to demand.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gateway` 提供了外部访问函数的路由，并根据需求对函数进行扩展。'
- en: '`queue-worker` is in charge of handling asynchronous requests.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queue-worker` 负责处理异步请求。'
- en: We will proceed to the next step of installing the OpenFaaS CLI tool. The CLI
    can be used to create and deploy OpenFaaS functions. From a set of supported language
    templates, you can create OpenFaaS functions (such as Node.js, Python, C#, and
    Ruby). Please see the list of supported languages at [https://github.com/openfaas/templates](https://github.com/openfaas/templates)
    for further information.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续安装 OpenFaaS CLI 工具。该 CLI 可用于创建和部署 OpenFaaS 函数。通过一组支持的语言模板，您可以创建 OpenFaaS
    函数（例如 Node.js、Python、C# 和 Ruby）。更多信息，请参见 [https://github.com/openfaas/templates](https://github.com/openfaas/templates)。
- en: 'You can use the `curl` command to install the CLI after acquiring the binaries
    from the releases page as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `curl` 命令安装 CLI，方法是从发布页面获取二进制文件，如下所示：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here we are using the `–insecure` flag to avoid any certificate download issues.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 `–insecure` 标志来避免任何证书下载问题。
- en: 'The following command execution output confirms that the CLI installation is
    successful. The `faas-cli` command and the `faas` alias are available post-installation
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行结果确认 CLI 安装成功。安装完成后，`faas-cli` 命令和 `faas` 别名可用，如下所示：
- en: '![Figure 10.19 – Installing the OpenFaaS CLI ](img/Figure_10.19_B18115.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – 安装 OpenFaaS CLI](img/Figure_10.19_B18115.jpg)'
- en: Figure 10.19 – Installing the OpenFaaS CLI
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 安装 OpenFaaS CLI
- en: Now that we’ve installed `faas-cli`, we can use the `faas-cli` command to start
    creating and deploying functions in the next section
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 `faas-cli`，接下来我们可以使用 `faas-cli` 命令来创建和部署函数，进入下一部分。
- en: Deploying and running a sample function on OpenFaaS
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 OpenFaaS 上部署并运行一个示例函数
- en: 'This section will cover the creation, build, and deployment of a new FaaS Python
    function. We’ll also use OpenFaaS CLI commands to test the deployed function.
    The OpenFaaS CLI has a template engine that can be used to set up new functions
    in any programming language. To create a new function, use the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍创建、构建和部署新的 FaaS Python 函数。我们还将使用 OpenFaaS CLI 命令来测试已部署的函数。OpenFaaS CLI
    拥有一个模板引擎，可以用来设置任何编程语言的新函数。要创建一个新函数，请使用以下命令：
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here `–prefix` `localhost:32000` refers to the local MicroK8s registry that
    we have enabled in the preceding steps.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `–prefix` `localhost:32000` 指的是我们在前面步骤中启用的本地 MicroK8s 注册表。
- en: This command works by reading a list of templates from the `./template` directory
    in your current working folder.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通过读取当前工作文件夹中 `./template` 目录下的模板列表来工作。
- en: You can also use the `faas-cli template pull` command to pull the templates
    from the official OpenFaaS language templates from GitHub.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `faas-cli template pull` 命令，从 GitHub 拉取官方 OpenFaaS 语言模板。
- en: To check the list of languages that are supported, use the `faas-cli new –list`
    command.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看支持的语言列表，请使用 `faas-cli new –list` 命令。
- en: 'The following command execution indicates that the new `openfaas-serverless`
    Python function has been created:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行结果表明新的 `openfaas-serverless` Python 函数已创建：
- en: '![Figure 10.20 – Creating a new function using the CLI ](img/Figure_10.20_B18115.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – 使用 CLI 创建新函数](img/Figure_10.20_B18115.jpg)'
- en: Figure 10.20 – Creating a new function using the CLI
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 使用 CLI 创建新函数
- en: 'A stack file and a new folder with the function name are generated in the current
    working folder as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前工作文件夹中，生成了一个堆栈文件和一个以函数名命名的新文件夹，如下所示：
- en: '![Figure 10.21 – A stack file and a new folder with the function name ](img/Figure_10.21_B18115.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21 – 生成堆栈文件和包含函数名称的新文件夹](img/Figure_10.21_B18115.jpg)'
- en: Figure 10.21 – A stack file and a new folder with the function name
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – 生成堆栈文件和包含函数名称的新文件夹
- en: Now that we’ve created a new function, we’ll need to build it so that a container
    image can be created and used in the following steps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个新函数，接下来我们需要构建它，以便在后续步骤中创建和使用容器镜像。
- en: 'Use the following command to build the new function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来构建新函数：
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `faas-cli build` command creates a Docker image on your local MicroK8s registry,
    which could be used locally or could be uploaded to a remote container registry
    (in case of a multi-node cluster setup). Each change to your function necessitates
    issuing a new `faas-cli build` command.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`faas-cli build` 命令在本地 MicroK8s 注册中心创建一个 Docker 镜像，该镜像可以在本地使用，也可以上传到远程容器注册中心（如果是多节点集群设置）。每次更改函数时，都需要执行新的
    `faas-cli build` 命令。'
- en: 'The following command execution indicates that the new `openfaas-serverless`
    Python function has been built successfully:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行表明新的 `openfaas-serverless` Python 函数已成功构建：
- en: '![Figure 10.22 – Building a new OpenFaaS function ](img/Figure_10.22_B18115.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – 构建新的 OpenFaaS 函数](img/Figure_10.22_B18115.jpg)'
- en: Figure 10.22 – Building a new OpenFaaS function
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 构建新的 OpenFaaS 函数
- en: 'It may take some time to complete the build process, but once completed, you
    should see the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程可能需要一些时间，但一旦完成，您应该看到以下输出：
- en: '![Figure 10.23 – Successful OpenFaaS function build ](img/Figure_10.23_B18115.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23 – 成功构建 OpenFaaS 函数](img/Figure_10.23_B18115.jpg)'
- en: Figure 10.23 – Successful OpenFaaS function build
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 成功构建 OpenFaaS 函数
- en: We can move on to the next step of pushing the Docker image to the registry
    now that the images have been built.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于镜像已构建完成，我们现在可以进入下一步，将 Docker 镜像推送到注册中心。
- en: 'Use the following command to push Docker images to our local registry:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将 Docker 镜像推送到我们的本地注册中心：
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following command execution output indicates that the `openfaas-serverless`
    function has been pushed to the registry successfully:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明 `openfaas-serverless` 函数已成功推送到注册中心：
- en: '![Figure 10.24 – OpenFaaS function pushed to the local registry ](img/Figure_10.24_B18115.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24 – OpenFaaS 函数已推送到本地注册中心](img/Figure_10.24_B18115.jpg)'
- en: Figure 10.24 – OpenFaaS function pushed to the local registry
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 – OpenFaaS 函数已推送到本地注册中心
- en: Let’s set an `OPENFAAS_URL` environment variable and also retrieve the necessary
    admin credentials before moving on to the next step of deploying the function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一步部署函数之前，让我们设置 `OPENFAAS_URL` 环境变量并检索所需的管理员凭证。
- en: 'An `OPENFAAS_URL` environment variable defines the default gateway URL that
    the CLI uses to contact the OpenFaaS server as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `OPENFAAS_URL` 环境变量定义了 CLI 用来联系 OpenFaaS 服务器的默认网关 URL，如下所示：
- en: '![Figure 10.25 – Set the OPENFAAS_URL environment variable ](img/Figure_10.25_B18115.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.25 – 设置 OPENFAAS_URL 环境变量](img/Figure_10.25_B18115.jpg)'
- en: Figure 10.25 – Set the OPENFAAS_URL environment variable
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 – 设置 OPENFAAS_URL 环境变量
- en: 'To retrieve the admin credentials, use the following command that was printed
    during the installation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索管理员凭证，请使用在安装过程中打印的以下命令：
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following command execution output indicates that the command was successfully
    executed and that the password was retrieved:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明命令已成功执行，并且密码已被检索：
- en: '![Figure 10.26 – Retrieving admin credentials ](img/Figure_10.26_B18115.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.26 – 检索管理员凭证](img/Figure_10.26_B18115.jpg)'
- en: Figure 10.26 – Retrieving admin credentials
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26 – 检索管理员凭证
- en: 'Let’s log in to the OpenFaaS server with the admin credentials so we can deploy
    the function. The following command execution output indicates that the login
    was successful and the credentials were saved to the local store:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用管理员凭证登录到 OpenFaaS 服务器，以便我们可以部署该函数。以下命令执行结果表示登录成功，并且凭证已保存到本地存储：
- en: '![Figure 10.27 – Using the retrieved password to log in to the OpenFaaS server
    ](img/Figure_10.27_B18115.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.27 – 使用检索到的密码登录到 OpenFaaS 服务器](img/Figure_10.27_B18115.jpg)'
- en: Figure 10.27 – Using the retrieved password to log in to the OpenFaaS server
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27 – 使用检索到的密码登录到 OpenFaaS 服务器
- en: We can proceed to the next step of deploying the function to the OpenFaaS server
    now that the credentials have been saved.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证已保存后，我们可以继续部署该函数到 OpenFaaS 服务器的下一步骤。
- en: 'Use the following command to deploy the function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来部署该函数：
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following command execution output indicates that the deployment is successful
    and we now have the URL for accessing the function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令执行输出表明部署成功，并且我们现在拥有访问该函数的 URL：
- en: '![Figure 10.28 – Successful function deployment ](img/Figure_10.28_B18115.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.28 – 函数部署成功](img/Figure_10.28_B18115.jpg)'
- en: Figure 10.28 – Successful function deployment
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.28 – 函数部署成功
- en: Alternatively, you can use the `faas-cli up` command to build, push, and deploy
    the function in a single command.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `faas-cli up` 命令在一个命令中构建、推送并部署函数。
- en: Congrats! We have successfully created a new function and deployed it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们成功创建了一个新函数并部署了它。
- en: 'To call the function, we’ll utilize the CLI’s `invoke` function as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用函数，我们将使用 CLI 的 `invoke` 功能，如下所示：
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By default, the function accepts an input parameter and outputs the input parameter
    value. To change the logic, the stack file and the handler file need to be modified,
    and then the function needs to be redeployed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，函数接受一个输入参数并输出该参数值。要更改逻辑，需修改堆栈文件和处理程序文件，然后重新部署函数：
- en: '![Figure 10.29 – Invoking the function ](img/Figure_10.29_B18115.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.29 – 调用函数](img/Figure_10.29_B18115.jpg)'
- en: Figure 10.29 – Invoking the function
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.29 – 调用函数
- en: 'You could also use the OpenFaaS UI to invoke the deployed functions as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 OpenFaaS 用户界面来调用已部署的函数，如下所示：
- en: '![Figure 10.30 – OpenFaaS UI ](img/Figure_10.30_B18115.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.30 – OpenFaaS 用户界面](img/Figure_10.30_B18115.jpg)'
- en: Figure 10.30 – OpenFaaS UI
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.30 – OpenFaaS 用户界面
- en: 'To summarize, in simple terms, OpenFaaS provides the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，OpenFaaS 提供以下功能：
- en: A simple approach to package any code or binary, as well as a diverse ecosystem
    of language templates
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种简单的方法来打包任何代码或二进制文件，以及一个多样化的语言模板生态系统
- en: Built-in autoscaling and a function repository for collaboration and sharing
    metrics
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的自动扩展和用于协作与共享度量的函数库
- en: A Kubernetes-native experience and a devoted community
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生支持 Kubernetes 体验以及一个专注的社区
- en: The best practices for developing and deploying serverless apps will be discussed
    in the following section.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将讨论开发和部署无服务器应用程序的最佳实践。
- en: Best practices for developing and deploying serverless applications
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和部署无服务器应用程序的最佳实践
- en: We must adhere to best practices in order to safeguard our resources, applications,
    and infrastructure service provider accounts. Here are some guiding principles
    that need to be considered.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须遵循最佳实践，以保护我们的资源、应用程序和基础设施服务提供商账户。以下是需要考虑的一些指导原则。
- en: Serverless function = specific function
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器函数 = 特定函数
- en: A serverless function must accomplish a certain task. A serverless function
    should execute a logical function, similar to how a function or method in any
    code should accomplish one thing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数必须完成特定任务。无服务器函数应该执行一个逻辑功能，类似于任何代码中的函数或方法应该完成一件事情。
- en: Using microservices
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用微服务
- en: Microservices enable us to link together the data storage and functions in a
    manageable manner. The microservice will be bound by a contract that specifies
    what it is allowed and prohibited to do. A payment microservice, for example,
    can be used to create, update, and delete user payments. Outside of the user account
    data storage, this microservice should never modify any data. It will also have
    its own API. Other microservices can now interact with user account serverless
    functions in a consistent manner without modifying any of the user account data
    stores.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务使我们能够以可管理的方式将数据存储和功能链接在一起。微服务将受合同约束，规定允许和禁止的操作。例如，一个支付微服务可以用来创建、更新和删除用户支付记录。除用户账户数据存储之外，这个微服务不应修改任何数据。它还会有自己的
    API。其他微服务现在可以以一致的方式与用户账户无服务器函数交互，而无需修改任何用户账户数据存储。
- en: Using appropriate stacks for various resources
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为不同资源使用适当的堆栈
- en: When deploying resources, serverless frameworks allow us to employ several language
    stacks, and each framework configuration deploys the appropriate stack. One stack
    per resource type should be the goal. Our user payment microservice, for example,
    might have a database stack (to store account metadata in MongoDB), an **identity
    provider** (**IdP**) stack (to set up and maintain user sessions with an OAuth2
    provider), a function stack (to deploy functions that provide the user payment
    microservice API), and an object store stack (to capture user account profile
    pictures in S3). This enables us to edit one resource type without affecting another.
    If you make a mistake in the deployment of a function’s stack, for example, your
    other stacks are unaffected.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署资源时，无服务器框架允许我们使用多种语言栈，每个框架配置都部署相应的栈。每种资源类型应该有一个目标栈。例如，我们的用户支付微服务可能会有一个数据库栈（用于存储MongoDB中的账户元数据）、一个**身份提供者**（**IdP**）栈（用于设置和维护与OAuth2提供者的用户会话）、一个函数栈（用于部署提供用户支付微服务API的函数）和一个对象存储栈（用于在S3中捕捉用户账户的头像）。这使得我们能够在不影响其他资源的情况下编辑某一资源类型。例如，如果你在部署函数栈时出错，其他栈不会受到影响。
- en: Applying the principle of least privilege
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用最小权限原则
- en: The minimal set of IAM permissions should be applied to all of your resources.
    A serverless function that reads a MongoDB table, for example, should only contain
    the read action for that MongoDB table. When defining privileges, you should avoid
    using an asterisk (*) whenever feasible. A hacker can read and delete all database
    data if your function is ever compromised and it employs asterisks to make all
    MongoDB accessible and every operation permissible.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 应该对所有资源应用最小权限的IAM权限。例如，一个读取MongoDB表格的无服务器函数，只应包含该MongoDB表格的读取权限。在定义权限时，应尽量避免使用星号（*）。如果你的函数被攻击者利用且使用了星号，那么它就能读取和删除所有数据库数据，从而使得所有MongoDB资源可访问，且每个操作都可执行。
- en: Performing load testing
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行负载测试
- en: Load testing your serverless functions would help you identify how much memory
    to allocate and what timeout value to use. In a serverless environment, there
    could be complicated apps, and you may not be aware of dependencies inside applications
    that prevent them from performing a function on heavy loads. Load testing allows
    you to identify possible problems that are critical to running a high-availability
    application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对无服务器函数进行负载测试有助于你识别需要分配多少内存以及使用什么超时值。在无服务器环境中，可能会有复杂的应用程序，而且你可能没有意识到应用程序内部的依赖关系，这些依赖关系会在高负载下阻止其执行功能。负载测试使你能够识别可能会影响高可用性应用程序运行的关键问题。
- en: Using a CI/CD pipeline
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CI/CD管道
- en: It’s fine to deploy using the CLI when you’re starting to build an application.
    Ideally, you should use a CI/CD pipeline to deploy your code before releasing
    it to production. Before enabling a pull request to merge, the CI section of the
    pipeline allows you to perform linting checks, unit tests, and a variety of additional
    automated checks. When a PR is merged or a branch is updated, the CD section of
    the pipeline allows you to deploy your serverless application automatically. Using
    a CI/CD pipeline eliminates human error and ensures that your process is repeatable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建应用程序时，通过CLI进行部署是可以的。理想情况下，你应该在将代码发布到生产环境之前，使用CI/CD管道来部署代码。在启用拉取请求合并之前，管道的CI部分允许你进行代码风格检查、单元测试和其他各种自动化检查。当PR合并或分支更新时，管道的CD部分允许你自动部署无服务器应用程序。使用CI/CD管道可以消除人为错误，并确保你的流程可重复。
- en: Constant monitoring is required
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要持续监控
- en: We should monitor our serverless resources using services such as Knative monitoring
    and Prometheus. There may be many resources and they may be used so frequently
    that manually checking them for faults would be difficult. Health, longer executions,
    delays, and errors can all be reported by monitoring services. Having a service
    that alerts us (such as Alert Manager) when our serverless application and resources
    are experiencing problems allows us to locate and resolve issues more quickly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用Knative监控、Prometheus等服务来监控我们的无服务器资源。可能会有许多资源，而且它们的使用频繁，手动检查它们是否存在故障将会很困难。健康状况、执行时间过长、延迟和错误等都可以通过监控服务报告。当我们的无服务器应用和资源出现问题时，拥有一个服务（如Alert
    Manager）来向我们发出警报，可以让我们更快地定位和解决问题。
- en: Auditing in addition to monitoring
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 除了监控，还需要审计
- en: We want to audit in addition to monitoring. When anything stops working or has
    problems, monitoring alerts you. When our resources stray from a known configuration
    or are wrongly configured, auditing alerts us. We may develop rules that audit
    our resources and their configurations using services such as Knative Config or
    an OpenFaaS stack file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望除了监控之外，还能进行审计。当任何事情停止工作或出现问题时，监控会发出警报。当我们的资源偏离已知配置或配置错误时，审计会发出警报。我们可能会开发规则，使用
    Knative 配置或 OpenFaaS 堆栈文件等服务来审计我们的资源及其配置。
- en: Auditing software dependencies
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计软件依赖
- en: We’d like to audit our software dependencies as well. Just because we don’t
    have a server anymore doesn’t mean we’re immune to “patching.” We want to make
    sure that any software dependencies we specify are current and do not include
    any known vulnerabilities. We can utilize automated tools to keep track of which
    software packages need to be updated.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望审计我们的软件依赖。仅仅因为我们不再有服务器，并不意味着我们免于“打补丁”。我们希望确保我们指定的任何软件依赖都是最新的，并且不包含已知的漏洞。我们可以利用自动化工具来跟踪哪些软件包需要更新。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined two of the most popular serverless frameworks included
    with MicroK8s, Knative and OpenFaaS, both of which are Kubernetes-based platforms
    for developing, deploying, and managing modern serverless workloads. We’ve deployed
    a few of the samples and used their endpoints to invoke them via the CLI. We also
    looked at how serverless frameworks scale down pods to zero when there are no
    requests and spin up new pods when there are more requests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了 MicroK8s 中最流行的两种无服务器框架：Knative 和 OpenFaaS，它们都是基于 Kubernetes 的平台，用于开发、部署和管理现代的无服务器工作负载。我们部署了一些示例，并通过
    CLI 调用它们的端点。我们还看到了无服务器框架如何在没有请求时将 Pod 缩减到零，并在有更多请求时启动新的 Pod。
- en: We realized that the ease of deployment of MicroK8s appears to be related to
    the ease with which serverless frameworks can be implemented. We’ve also discussed
    some guiding principles to keep in mind when developing and deploying serverless
    applications. However, deploying serverless resources is pretty simple. We also
    understood that in order to protect our resources, apps, and infrastructure service
    provider accounts, we needed to adhere to best practices.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到，MicroK8s 的部署简便性似乎与无服务器框架的实现难易度相关。我们还讨论了一些在开发和部署无服务器应用时需要牢记的指导原则。然而，部署无服务器资源非常简单。我们还意识到，为了保护我们的资源、应用和基础设施服务提供商账户，我们需要遵循最佳实践。
- en: In the next chapter, we’ll look at how to use OpenEBS to implement storage replication
    that synchronizes data across several nodes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 OpenEBS 实现存储复制，从而在多个节点之间同步数据。
- en: 'Part 4: Deploying and Managing Applications on MicroK8s'
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：在 MicroK8s 上部署和管理应用
- en: This part focuses on the deployment and management aspects of typical IoT/Edge
    computing applications, such as setting up storage replication for your stateful
    applications, implementing a service mesh for cross-cutting concerns and a high
    availability cluster to withstand a component failure and continue to serve workloads
    without interruption, configuring containers with workload isolation, and running
    secured containers in isolation from a host system.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分重点介绍了典型物联网/边缘计算应用的部署和管理方面，例如为有状态应用设置存储复制，为跨切关注点实现服务网格，以及设置高可用集群以应对组件故障并继续无中断地提供工作负载服务，配置带有工作负载隔离的容器，并在与主机系统隔离的环境中运行受保护的容器。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分包括以下章节：
- en: '[*Chapter 11*](B18115_11.xhtml#_idTextAnchor180)*, Managing Storage Replication
    with OpenEBS*'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18115_11.xhtml#_idTextAnchor180)*，使用 OpenEBS 管理存储复制*'
- en: '[*Chapter 12*](B18115_12.xhtml#_idTextAnchor196)*, Implementing Service Mesh
    for Cross-Cutting Concerns*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18115_12.xhtml#_idTextAnchor196)*，为跨切关注点实现服务网格*'
- en: '[*Chapter 13*](B18115_13.xhtml#_idTextAnchor212)*, Resisting Component Failure
    Using HA Cluster*'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18115_13.xhtml#_idTextAnchor212)*，通过 HA 集群抵御组件故障*'
- en: '[*Chapter 14*](B18115_14.xhtml#_idTextAnchor223)*, Hardware Virtualization
    for Securing Containers*'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18115_14.xhtml#_idTextAnchor223)*，用于安全容器的硬件虚拟化*'
- en: '[*Chapter 15*](B18115_15.xhtml#_idTextAnchor243)*, Implementing Strict Confinement
    for Isolated Containers*'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18115_15.xhtml#_idTextAnchor243)*，为隔离容器实现严格限制*'
- en: '[*Chapter 16*](B18115_16.xhtml#_idTextAnchor257)*, Diving into the Future*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B18115_16.xhtml#_idTextAnchor257)*，深入未来*'
