- en: '*Chapter 6*: Machine Learning Engineering'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：机器学习工程'
- en: In this chapter, we will move the discussion to the model building and model
    management activities of the **machine learning** (**ML**) engineering lifecycle.
    You will learn about the ML platform's role of providing a self-serving solution
    to data scientist so they can work more efficiently and collaborate with data
    teams and fellow data scientists.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把讨论转向 **机器学习**（**ML**）工程生命周期中的模型构建和模型管理活动。您将学习 ML 平台在为数据科学家提供自服务解决方案中的角色，以便他们能够更高效地工作，并与数据团队和其他数据科学家进行合作。
- en: The focus of this chapter is not on building models; instead, it is on showing
    how the platform can bring consistency and security across different environments
    and different members of your teams. You will learn how the platform simplifies
    the work of data scientists in terms of preparing and maintaining their data science
    workspaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点不在于构建模型，而是展示平台如何在不同环境和团队成员之间提供一致性和安全性。您将学习平台如何简化数据科学家在准备和维护数据科学工作空间方面的工作。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Understanding ML engineering?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解机器学习工程？
- en: Using a custom notebook image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义笔记本镜像
- en: Introducing MLflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 MLflow
- en: Using MLflow as an experiment tracking system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MLflow 作为实验跟踪系统
- en: Using MLflow as a model registry system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MLflow 作为模型注册系统
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter includes some hands-on setup and exercises. You will need a running
    Kubernetes cluster configured with **Operator Lifecycle Manager** (**OLM**). Building
    such a Kubernetes environment is covered in [*Chapter 3*](B18332_03_ePub.xhtml#_idTextAnchor040),
    *Exploring Kubernetes*. Before attempting the technical exercises in this chapter,
    please make sure that you have a working Kubernetes cluster and that **Open Data
    Hub** (**ODH**) is installed on your Kubernetes cluster. Installing ODH is covered
    in [*Chapter 4*](B18332_04_ePub.xhtml#_idTextAnchor055), *The Anatomy of a Machine
    Learning Platform*. You can find all the code associated with this book at [https://github.com/PacktPublishing/Machine-Learning-on-Kubernetes](https://github.com/PacktPublishing/Machine-Learning-on-Kubernetes).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含一些动手设置和练习。您需要一个配置了 **操作员生命周期管理器**（**OLM**）的运行中 Kubernetes 集群。构建这样的 Kubernetes
    环境在 [*第 3 章*](B18332_03_ePub.xhtml#_idTextAnchor040)《探索 Kubernetes》中已有介绍。在尝试本章的技术练习之前，请确保您已经有一个正常运行的
    Kubernetes 集群，并且 **开放数据中心**（**ODH**）已安装在您的 Kubernetes 集群上。ODH 的安装方法在 [*第 4 章*](B18332_04_ePub.xhtml#_idTextAnchor055)《机器学习平台的构造》中有详细说明。您可以在
    [https://github.com/PacktPublishing/Machine-Learning-on-Kubernetes](https://github.com/PacktPublishing/Machine-Learning-on-Kubernetes)
    找到与本书相关的所有代码。
- en: Understanding ML engineering
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解机器学习工程
- en: ML engineering is the process of applying software engineering principles and
    practices to ML projects. In the context of this book, ML engineering is also
    a discipline that facilitates applying application development practices to the
    data science lifecycle. When you write a traditional application such as a website
    or a banking system, there are processes and tools to assist you in writing high-quality
    code right from the start. Smart IDEs, standard environments, continuous integration,
    automated testing, and static code analysis are just a few examples. Automation
    and continuous deployment practices enable organizations to deploy applications
    many times in a day and with no downtime.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习工程是将软件工程原则和实践应用于机器学习项目的过程。在本书的上下文中，机器学习工程也是一种学科，它有助于将应用开发实践应用于数据科学生命周期。当你编写传统应用程序，如网站或银行系统时，有一系列流程和工具帮助你从一开始就编写高质量的代码。例如，智能
    IDE、标准化环境、持续集成、自动化测试和静态代码分析等，都是一些常见的工具。自动化和持续部署实践使得组织能够在一天内多次部署应用程序，且不会出现停机时间。
- en: ML engineering is a loose term that brings the benefits of traditional software
    engineering practices to the model development world. However, most data scientists
    are not developers. They may not be familiar with software engineering practices.
    Also, the tools that the data scientists use may not be the right tools to perform
    ML engineering tasks. Having said that, the model is just another piece of software.
    Therefore, we can also apply existing software engineering approaches to ML models.
    Using containers to package and deploy ML models is one such example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习工程是一个宽泛的术语，它将传统软件工程实践的好处带入到模型开发领域。然而，大多数数据科学家并非开发人员。他们可能不熟悉软件工程实践。此外，数据科学家使用的工具可能并不是执行机器学习工程任务的最佳工具。话虽如此，模型只是另一种软件。因此，我们也可以将现有的软件工程方法应用于机器学习模型。使用容器打包和部署机器学习模型就是一个例子。
- en: 'Some teams may employ ML engineers to supplement the work of data scientists.
    While the data scientist''s primary responsibility is to build ML or deep learning
    models that solve business problems, ML engineers focus more on the software engineering
    facets. Some of the responsibilities of data engineers include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队可能会雇佣机器学习工程师来补充数据科学家的工作。虽然数据科学家的主要职责是构建能够解决业务问题的机器学习或深度学习模型，但机器学习工程师更多地关注软件工程方面的工作。数据工程师的一些职责包括：
- en: Model optimization (also about making sure that the built model is optimized
    for the target environment where the model will be hosted).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型优化（也包括确保构建的模型针对将托管模型的目标环境进行了优化）。
- en: Model packaging (making ML models portable, shippable, executable, and version-controlled).
    Model packaging may also include model serving and containerization.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型打包（使机器学习模型可移植、可交付、可执行并进行版本控制）。模型打包还可能包括模型服务和容器化。
- en: Monitoring (establishing an infrastructure for collecting performance metrics,
    logging, alerting, and anomaly detection such as drift and outlier detection).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控（建立收集性能指标、日志记录、警报和异常检测（如漂移和离群点检测）基础设施）。
- en: Model testing (including facilitation and automation of A/B testing).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型测试（包括促进和自动化A/B测试）。
- en: Model deployment.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型部署。
- en: Building and maintenance of MLOps infrastructure.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和维护MLOps基础设施。
- en: Implementation of continuous integration and continuous deployment pipelines
    for ML models.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现机器学习模型的持续集成和持续部署流水线。
- en: Automation of ML lifecycle processes.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化机器学习生命周期过程。
- en: There are other responsibilities of ML engineers that are not listed in the
    preceding list, but this list should already give you an idea of how to differentiate
    data science from ML engineering.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习工程师还有其他职责，虽然这些职责没有列在前面，但这个列表应该能让您对如何区分数据科学与机器学习工程有个大致的了解。
- en: The ML platform that you are building will reduce the number of ML engineering
    tasks to be done manually to a point where even the data scientists can do most
    of the ML engineering tasks by themselves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在构建的机器学习平台将减少需要手动完成的机器学习工程任务的数量，直到即使是数据科学家也能独立完成大部分机器学习工程任务。
- en: In the next sections, you will see how data scientists can track the model development
    iterations to improve model quality and share the learning with the team. You
    will see how teams can apply version control to ML models and other practices
    of software engineering to the ML world.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将看到数据科学家如何跟踪模型开发的迭代，以提高模型质量并与团队分享学习成果。您将看到团队如何将版本控制应用于机器学习模型，以及如何将其他软件工程实践应用于机器学习领域。
- en: We will continue our journey of ML engineering into the next chapter, where
    you will see how models can be packaged and deployed in a standard way and see
    how the deployment process can be automated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中继续我们的机器学习工程之旅，您将看到如何以标准化方式打包和部署模型，并了解如何自动化部署过程。
- en: Let's start with building standard development environments for our data science
    team.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为数据科学团队构建标准开发环境开始。
- en: Using a custom notebook image
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义笔记本镜像
- en: As you have seen in [*Chapter 5*](B18332_05_ePub.xhtml#_idTextAnchor069), *Data
    Engineering*, JupyterHub allows you to spin up Jupyter Notebook-based development
    environments in a self-service manner. You have launched the **Base Elyra Notebook
    Image** container image and used it to write the data processing code using Apache
    Spark. This approach enables your team to use a consistent or standardized development
    environment (for example, same Python versions and same libraries for building
    code) and apply security policies to the known set of software being used by your
    team. However, you may also want to create your own custom images with a different
    set of libraries or a different ML framework. The platform allows you to do that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[*第 5 章*](B18332_05_ePub.xhtml#_idTextAnchor069)《数据工程》中看到的那样，JupyterHub
    允许你以自助服务的方式启动基于 Jupyter Notebook 的开发环境。你已启动 **Base Elyra Notebook Image** 容器镜像，并使用它编写了基于
    Apache Spark 的数据处理代码。这种方法使你的团队能够使用一致或标准化的开发环境（例如，相同的 Python 版本和相同的库来构建代码），并对你的团队使用的已知软件集应用安全策略。然而，你可能还希望创建自己的自定义镜像，使用不同的库或不同的
    ML 框架。平台允许你做到这一点。
- en: In the following subsection, you will build and deploy a custom container image
    to be used within your team.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，你将构建并部署一个自定义容器镜像，以供你的团队使用。
- en: Building a custom notebook container image
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义笔记本容器镜像
- en: 'Let''s assume that your team wants to use a specific version of the Scikit
    library along with some other supporting libraries such as `joblib`. You then
    want your team to use this library while developing their data science code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的团队希望使用特定版本的 Scikit 库以及其他一些支持库，例如 `joblib`。然后，你希望你的团队在开发数据科学代码时使用此库：
- en: 'Open the `Dockerfile` provided in the code repository of this book at `chapter6/CustomNotebookDockerfile`.
    This file uses the base image provided and used by ODH and then adds the required
    libraries. The file is shown in *Figure 6.1*:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本书代码库中提供的 `Dockerfile`，路径为 `chapter6/CustomNotebookDockerfile`。该文件使用了 ODH
    提供并使用的基础镜像，然后添加了所需的库。文件如 *图 6.1* 所示：
- en: '![Figure 6.1 – Dockerfile for the custom notebook image'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 自定义笔记本镜像的 Dockerfile'
- en: '](img/B18332_06_001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_001.jpg)'
- en: Figure 6.1 – Dockerfile for the custom notebook image
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 自定义笔记本镜像的 Dockerfile
- en: Note the first line, which refers to the latest image at the time of writing.
    This image is used by ODH. Lines 4 and 5 install the Python packages defined in
    the `requirements.txt` file. Line 8 installs the dependencies that are not in
    the `requirements.txt` file. If you wish to add additional packages to the image,
    you can simply insert a line in `requirements.txt`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第一行，它指的是写作时最新的镜像。这个镜像由 ODH 使用。第 4 行和第 5 行安装了 `requirements.txt` 文件中定义的 Python
    包。第 8 行安装了 `requirements.txt` 文件中未包含的依赖项。如果你希望将其他包添加到镜像中，只需在 `requirements.txt`
    中插入一行即可。
- en: 'Build the image using the file provided in the preceding step. Run the following
    command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一步提供的文件构建镜像。运行以下命令：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the following response:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '![Figure 6.2 – Output of the container build command'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 容器构建命令的输出'
- en: '](img/B18332_06_002.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_002.jpg)'
- en: Figure 6.2 – Output of the container build command
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 容器构建命令的输出
- en: 'Tag the built image as per your liking. You will need to push this image to
    a registry from where your Kubernetes cluster can access it. We use `quay.io`
    as the public Docker repository of choice, and you can use your preferred repository
    here. Notice that you will need to adjust the following command and change the
    `quay.io/ml-on-k8s/` part before execution of the command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的喜好标记构建好的镜像。你需要将此镜像推送到一个注册表，Kubernetes 集群可以从该注册表访问它。我们使用 `quay.io` 作为首选的公共
    Docker 仓库，你也可以在这里使用你偏好的仓库。请注意，在执行命令之前，你需要调整以下命令并更改 `quay.io/ml-on-k8s/` 部分：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is no output of the preceding command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令没有输出。
- en: 'Push the image to the Docker repository of your choice. Use the following command
    and make sure to change the repository location as per *Step 3*. This image may
    take some time to be pushed to an internet repository based on your connection
    speed. Be patient:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到你选择的 Docker 仓库。使用以下命令，并确保按照 *第 3 步* 更改仓库位置。根据你的网络连接速度，推送该镜像到互联网仓库可能需要一些时间，请耐心等待：
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should see the output of this command as shown in *Figure 6.3*. Wait for
    the push to complete.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下所示的命令输出，参见 *图 6.3*。等待推送完成。
- en: '![Figure 6.3 – Pushing the custom notebook image to a Docker repository'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 将自定义笔记本镜像推送到 Docker 仓库'
- en: '](img/B18332_06_003.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_003.jpg)'
- en: Figure 6.3 – Pushing the custom notebook image to a Docker repository
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 将自定义 notebook 镜像推送到 Docker 仓库
- en: Now, the image is available to be used. You will configure ODH manifests in
    the next steps to use this image.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，镜像已可以使用。接下来的步骤中，您将配置 ODH manifests 以使用此镜像。
- en: 'Open the `manifests/jupyterhub-images/base/customnotebook-imagestream.yaml`
    file. This file is shown as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `manifests/jupyterhub-images/base/customnotebook-imagestream.yaml` 文件。该文件如下所示：
- en: '![Figure 6.4 – ImageStream object'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – ImageStream 对象'
- en: '](img/B18332_06_004.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_004.jpg)'
- en: Figure 6.4 – ImageStream object
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – ImageStream 对象
- en: JupyterHub from ODH uses a CRD called `manifests/odh-common/base/imagestream-crd.yaml`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ODH 中的 JupyterHub 使用一个名为 `manifests/odh-common/base/imagestream-crd.yaml` 的
    CRD。
- en: Notice on lines 7 and 8, we have defined some annotations. JupyterHub reads
    all the `imagestream` objects and uses these annotations to be displayed on the
    JupyterHub landing page. JupyterHub also looks at the field named `dockerImageReference`
    to load these container images upon request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第 7 行和第 8 行，我们定义了一些注释。JupyterHub 会读取所有 `imagestream` 对象，并使用这些注释在 JupyterHub
    登陆页面上显示。JupyterHub 还会查看名为 `dockerImageReference` 的字段，以便在请求时加载这些容器镜像。
- en: We encourage you to fork the code repository of this book onto your own Git
    account and add more images. Keep in mind to change the location of the Git repository
    in the `manifests/kfdef/ml-platform.yaml` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您将本书的代码仓库 fork 到您自己的 Git 账户中，并添加更多镜像。请记得在 `manifests/kfdef/ml-platform.yaml`
    文件中更改 Git 仓库的位置。
- en: 'For the JupyterHub server to see the newly created image, you will need to
    restart the JupyterHub pod. You can find the pod via the following command and
    delete this pod. After a few seconds, Kubernetes will restart this pod and your
    new image will appear on the JupyterHub landing page:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 JupyterHub 服务器看到新创建的镜像，您需要重启 JupyterHub pod。您可以通过以下命令找到该 pod 并删除它。几秒钟后，Kubernetes
    将重启此 pod，您的新镜像将在 JupyterHub 登陆页面上显示：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the following response. Note that the pod name will be different
    for your setup:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如下响应。请注意，pod 名称将根据您的设置有所不同：
- en: '![Figure 6.5 – Pods with names containing jupyterhub'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 名称中包含 jupyterhub 的 Pods'
- en: '](img/B18332_06_005.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_005.jpg)'
- en: Figure 6.5 – Pods with names containing jupyterhub
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 名称中包含 jupyterhub 的 Pods
- en: 'Delete the JupyterHub pod by running the following command. Note that you do
    not need to delete this pod for this exercise, because the custom image is already
    present in our manifest files. This step will be required once you add a new customer
    notebook image using the steps mentioned in this section:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令删除 JupyterHub pod。请注意，您在此练习中不需要删除此 pod，因为我们的 manifest 文件中已经包含了自定义镜像。当您按照本节中的步骤添加新的客户
    notebook 镜像时，此步骤才是必需的：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following response. Note that the pod name will be different
    for your setup:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如下响应。请注意，pod 名称将根据您的设置有所不同：
- en: '![Figure 6.6 – Output of the delete pod command'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – 删除 pod 命令的输出'
- en: '](img/B18332_06_006.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_006.jpg)'
- en: Figure 6.6 – Output of the delete pod command
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 删除 pod 命令的输出
- en: 'Log in to JupyterHub and you will see the new notebook image listed there:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 JupyterHub 后，您将看到新的 notebook 镜像列在其中：
- en: '![Figure 6.7 – JupyterHub landing page showing the new notebook image'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 显示新 notebook 镜像的 JupyterHub 登陆页面'
- en: '](img/B18332_06_007.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_007.jpg)'
- en: Figure 6.7 – JupyterHub landing page showing the new notebook image
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 显示新 notebook 镜像的 JupyterHub 登陆页面
- en: In the next section, you will learn about MLflow, a software that assists teams
    in recording and sharing the outcomes of model training and tuning experiments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解 MLflow，这是一款帮助团队记录和共享模型训练与调优实验结果的软件。
- en: Introducing MLflow
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MLflow
- en: Simply put, MLflow is there to simplify the model development lifecycle. A lot
    of the data scientist's time is spent finding the right algorithms with the right
    hyperparameters for the given dataset. As a data scientist, you experiment with
    different combinations of parameters and algorithms, then review and compare the
    results to make the right choice. MLflow allows you to record, track, and compare
    these parameters, their results, and associated metrics. The component of MLflow
    that captures the details of each of your experiments is called the **tracking
    server**. The tracking server captures the environment details of your notebook,
    such as the Python libraries and their versions, and the artifacts generated by
    your experiment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，MLflow 旨在简化模型开发生命周期。数据科学家会花费大量时间寻找适合给定数据集的正确算法和超参数。作为数据科学家，你会尝试不同的参数和算法组合，然后回顾并比较结果，从中做出正确的选择。MLflow
    使你能够记录、跟踪和比较这些参数、它们的结果以及相关的度量。捕获每个实验细节的 MLflow 组件称为 **跟踪服务器**。跟踪服务器捕获你的笔记本环境细节，例如
    Python 库及其版本，以及实验生成的工件。
- en: The tracking server allows you to compare the data captured between different
    runs of an experiment, such as the performance metrics (for example, accuracy)
    alongside the hyperparameters used. You can also share this data with your team
    for collaboration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪服务器允许你比较不同实验运行之间捕获的数据，例如性能指标（例如准确率）以及使用的超参数。你还可以与团队共享这些数据进行协作。
- en: The second key capability of the MLflow tracking server is the model registry.
    Consider that you have run ten different experiments for the given dataset, while
    each of the experiments resulted in a model. Only one of the models will be used
    for the given problem. The model registry allows you to tag the selected model
    with one of the three stages (**Staging**, **Production**, and **Archived**).
    The model registry has APIs that allow you to access these models from your automated
    jobs. Versioning models in a registry will enable you to roll back to previous
    versions of the model using your automation tools in production if needed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 跟踪服务器的第二个关键功能是模型注册。假设你已经为给定的数据集运行了十个不同的实验，每个实验都得到了一个模型。最终，只有一个模型会用于解决给定的问题。模型注册功能允许你为选择的模型打上三个阶段标签之一（**Staging**、**Production**
    和 **Archived**）。模型注册有 API，允许你通过自动化作业访问这些模型。在生产环境中，版本控制模型注册中的模型将使你在需要时可以使用自动化工具回滚到模型的先前版本。
- en: '*Figure 6.8* shows the two major capabilities of the MLflow software:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.8* 显示了 MLflow 软件的两个主要功能：'
- en: '![Figure 6.8 – MLflow major capabilities'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – MLflow 主要功能'
- en: '](img/B18332_06_008.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_008.jpg)'
- en: Figure 6.8 – MLflow major capabilities
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – MLflow 主要功能
- en: Now that you know what MLFlow is used for, let's take a look at the components
    that made up MLFlow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了 MLflow 的用途，让我们来看看组成 MLflow 的各个组件。
- en: Understanding MLflow components
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 MLflow 组件
- en: Let's see what the major components of the MLflow system are and how it fits
    into our ML platform's ecosystem.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 MLflow 系统的主要组件是什么，它是如何融入我们机器学习平台的生态系统中的。
- en: MLflow server
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MLflow 服务器
- en: MLflow is deployed as a container, and it contains a backend server, a GUI,
    and an API to interact with it. In the later sections of this chapter, you will
    use the MLflow API to store the experiment data onto it. You will use the GUI
    component to visualize experiment tracking and the model registry parts. You can
    find this configuration at `manifests/mlflow/base/mlflow-dc.yaml`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 以容器的形式部署，包含一个后端服务器、一个图形用户界面（GUI）和一个 API 用于与之交互。在本章的后续部分，你将使用 MLflow API
    将实验数据存储到其中。你将使用 GUI 组件来可视化实验跟踪和模型注册部分。你可以在 `manifests/mlflow/base/mlflow-dc.yaml`
    文件中找到此配置。
- en: MLflow backend store
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MLflow 后端存储
- en: The MLflow server needs a backend store to store the metadata about experiments.
    The ODH component automatically provisions a PostgreSQL database to be used as
    a backend store for MLflow. You can find this configuration at `manifests/mlflow/base/mlflow-postgres-statefulset.yaml`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 服务器需要一个后端存储来存储关于实验的元数据。ODH 组件会自动配置一个 PostgreSQL 数据库，用作 MLflow 的后端存储。你可以在
    `manifests/mlflow/base/mlflow-postgres-statefulset.yaml` 文件中找到此配置。
- en: MLflow storage
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MLflow 存储
- en: The MLflow server supports several types of storage, such as S3 and databases.
    This storage will serve as the persistent storage for the artifacts, such as files
    and model files. In our platform, you will provision an open source S3 compatible
    storage service known as `manifests/minio/base/minio-dc.yaml`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 服务器支持多种类型的存储，如 S3 和数据库。这些存储将作为持久存储，用于存放工件，如文件和模型文件。在我们的平台上，您将配置一个开源的
    S3 兼容存储服务，称为 `manifests/minio/base/minio-dc.yaml`。
- en: MLflow authentication
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MLflow 认证
- en: MLflow does not have an out-of-the-box authentication system at the time of
    writing. In our platform, we have configured a proxy server in front of the MLflow
    GUI that will authenticate the request before forwarding it to the MLflow server.
    We are using the open source component at [https://github.com/oauth2-proxy/oauth2-proxy](https://github.com/oauth2-proxy/oauth2-proxy)
    for this purpose. The proxy has been configured to perform **Single-Sign-On**
    (**SSO**) with the **Keycloak** service of the platform.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 在编写时没有现成的认证系统。在我们的平台中，我们在 MLflow GUI 前面配置了一个代理服务器，它将在将请求转发到 MLflow 服务器之前进行认证。我们使用的是开源组件
    [https://github.com/oauth2-proxy/oauth2-proxy](https://github.com/oauth2-proxy/oauth2-proxy)
    来实现这一目的。代理已配置为与平台的 **Keycloak** 服务进行 **单点登录**（**SSO**）认证。
- en: '![Figure 6.9 – MLflow and associated components in the platform'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.9 – 平台中的 MLflow 及相关组件'
- en: '](img/B18332_06_009.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_009.jpg)'
- en: Figure 6.9 – MLflow and associated components in the platform
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 平台中的 MLflow 及相关组件
- en: 'As you can see in *Figure 6.9*, the MLflow pod has two containers in it: the
    MLflow server and the OAuth2 proxy. The Oauth2 proxy has been configured to use
    the Keycloak instance you installed.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 6.9*所示，MLflow pod 中有两个容器：MLflow 服务器和 OAuth2 代理。OAuth2 代理已配置为使用您安装的 Keycloak
    实例。
- en: When you created a new instance of ODH in [*Chapter 5*](B18332_05_ePub.xhtml#_idTextAnchor069),
    *Data Engineering*, it installed many platform components, including MLflow and
    Minio. Now, let's validate the MLflow installation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在[*第 5 章*](B18332_05_ePub.xhtml#_idTextAnchor069)“数据工程”中创建了 ODH 的新实例时，它安装了许多平台组件，包括
    MLflow 和 Minio。现在，让我们验证 MLflow 的安装。
- en: Validating the MLflow installation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 MLflow 安装
- en: 'ODH has already installed the MLflow and associated components for you. Now,
    you will use the MLflow GUI to get yourself familiar with the tool. You can imagine
    all the team members will have access to experiments and models, which will improve
    your team''s collaboration:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ODH 已为您安装了 MLflow 和相关组件。现在，您将使用 MLflow 图形用户界面（GUI）来熟悉该工具。您可以想象，所有团队成员都可以访问实验和模型，这将提高团队的协作：
- en: 'Get the ingress objects created in your Kubernetes environment using the following
    command. This is to get the URL of the endpoints where our services are deployed:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在您的 Kubernetes 环境中创建入口对象。这是为了获取我们服务部署的端点的 URL：
- en: '[PRE5]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following response:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 6.10 – All ingress objects in your cluster namespace'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – 您集群命名空间中的所有入口对象'
- en: '](img/B18332_06_010.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_010.jpg)'
- en: Figure 6.10 – All ingress objects in your cluster namespace
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 您集群命名空间中的所有入口对象
- en: 'Open the Minio GUI, our S3 component, and validate that there is a bucket available
    for MLflow to be used as its storage. The URL for the Minio component will look
    like `https://minio.192.168.61.72.nip.io`, where you will adjust the IP address
    as per your environment. The password is configured in the manifests file, and
    it is `minio123`. We have added Minio to the manifests to show that there is an
    option available using open source technologies, but making it suitable for production
    is out of scope for this book. Click on the buckets menu item on the left-hand
    side of the screen and you will see the available buckets:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Minio 图形用户界面，这是我们的 S3 组件，验证是否有一个存储桶可供 MLflow 使用作为其存储。Minio 组件的 URL 将类似于 `https://minio.192.168.61.72.nip.io`，您需要根据您的环境调整
    IP 地址。密码已在 manifests 文件中配置，默认为 `minio123`。我们已将 Minio 添加到 manifests 中，展示了可以使用开源技术的选项，但将其适配生产环境超出了本书的范围。点击屏幕左侧的存储桶菜单项，您将看到可用的存储桶：
- en: '![Figure 6.11 – Minio bucket list'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – Minio 存储桶列表'
- en: '](img/B18332_06_011.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_011.jpg)'
- en: Figure 6.11 – Minio bucket list
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – Minio 存储桶列表
- en: How are all of these buckets created? In the manifests, we have a Kubernetes
    job that creates the buckets. You can find the job at `manifests/minio/base/minio-job.yaml`.
    The job is using the Minio command-line client, `mc`, to create the buckets. You
    can find these commands under the `command` field name in this file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些桶是如何创建的？在清单中，我们有一个 Kubernetes 作业来创建这些桶。你可以在 `manifests/minio/base/minio-job.yaml`
    文件中找到该作业。该作业使用 Minio 命令行客户端 `mc` 来创建桶。你可以在该文件的 `command` 字段下找到这些命令。
- en: The configuration of S3 that is being used by MLflow is configured at `manifests/mlflow/base/mlflow-dc.yaml
    file`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 使用的 S3 配置已在 `manifests/mlflow/base/mlflow-dc.yaml` 文件中配置。
- en: 'You can see the settings as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到如下设置：
- en: '![Figure 6.12 – MLflow configuration to use Minio'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.12 – 配置 MLflow 使用 Minio](img/B18332_06_013.jpg)'
- en: '](img/B18332_06_012.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_012.jpg)'
- en: Figure 6.12 – MLflow configuration to use Minio
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 配置 MLflow 使用 Minio
- en: Open a browser and paste the `HOSTS` value for the `jupyterhub` ingress into
    your browser. For me, it was [https://mlflow.192.168.61.72.nip.io](https://mlflow.192.168.61.72.nip.io).
    This URL will take you to the Keycloak login page, which is the SSO server as
    shown in the following figure. Make sure that you replace the IP address with
    yours in this URL. Recall that the authentication part of MLflow is being managed
    by a proxy that you have configured in `manifests/mlflow/base/mlflow-dc.yaml`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，将`jupyterhub`入口的`HOSTS`值粘贴到浏览器中。对我来说，它是 [https://mlflow.192.168.61.72.nip.io](https://mlflow.192.168.61.72.nip.io)。这个
    URL 会将你带到 Keycloak 登录页面，这是如图所示的单点登录（SSO）服务器。确保将这个 URL 中的 IP 地址替换为你自己的。回想一下，MLflow
    的认证部分是由你在 `manifests/mlflow/base/mlflow-dc.yaml` 中配置的代理管理的。
- en: 'You can see the configuration of the OAuth proxy for MLflow as follows. Because
    `oauth-proxy` and MLflow belong to the same pod, all we have done is route the
    traffic from `oauth-proxy` to the MLflow container. This is set up with the `–upstream`
    property. You can also see `oauth-proxy` needs the name of the identity provider
    server, which is Keycloak, and it is configured under the `–oidc-issuer` property:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到如下的 OAuth 代理配置。由于 `oauth-proxy` 和 MLflow 属于同一个 pod，我们所做的就是将流量从 `oauth-proxy`
    路由到 MLflow 容器。这是通过 `–upstream` 属性进行设置的。你还可以看到 `oauth-proxy` 需要身份提供者服务器的名称，这里是
    Keycloak，并且它被配置在 `–oidc-issuer` 属性下：
- en: '![Figure 6.13 – OAuth proxy configuration for MLflow'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13 – 配置 MLflow 的 OAuth 代理](img/B18332_06_014.jpg)'
- en: '](img/B18332_06_013.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_013.jpg)'
- en: Figure 6.13 – OAuth proxy configuration for MLflow
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 配置 MLflow 的 OAuth 代理
- en: The landing page of MLflow looks like the page in *Figure 6.14*. You will notice
    there are two sections on the top bar menu. One has the label **Experiments**
    and the other one, **Models**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 的登录页面如下图所示 *图 6.14*。你会注意到顶部栏菜单有两个部分，一个是标有 **实验**，另一个是 **模型**。
- en: Before you see this page, the SSO configuration will display the login page.
    Enter the user ID as `mluser` and the password as `mluser` to log in. The username
    and password were configured in [*Chapter 4*](B18332_04_ePub.xhtml#_idTextAnchor055),
    *The* *Anatomy of a Machine Learning Platform*, in the *Creating a Keycloak user*
    section.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你看到此页面之前，SSO 配置将显示登录页面。输入用户 ID 为 `mluser`，密码为 `mluser` 以登录。用户名和密码是在 [*第 4 章*](B18332_04_ePub.xhtml#_idTextAnchor055)
    中配置的，*机器学习平台的构成*，在 *创建 Keycloak 用户* 部分。
- en: '![Figure 6.14 – MLflow experiment tracking page'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.14 – MLflow 实验追踪页面](img/B18332_06_014.jpg)'
- en: '](img/B18332_06_014.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_014.jpg)'
- en: Figure 6.14 – MLflow experiment tracking page
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – MLflow 实验追踪页面
- en: The left-hand side of the **Experiments** screen contains the list of experiments,
    and the right-hand side displays the details of experiment runs. Think of the
    experiment as the data science project you are working on, such as fraud detection
    in consumer transactions, and the **Notes** section captures the combination of
    parameters, algorithms, and other information used to run the experiment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验**页面的左侧显示实验列表，右侧显示实验运行的详细信息。可以把实验看作是你正在进行的数据科学项目，比如消费者交易中的欺诈检测，**备注**部分则记录了运行实验时使用的参数、算法及其他信息的组合。'
- en: Click on the **Models** tab to see the landing page of the model registry.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **模型** 选项卡，查看模型注册表的登录页面。
- en: The **Models** tab contains the list of models in the registry, their versions,
    and their corresponding stages, which mention what environment the models are
    deployed in.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**选项卡包含注册表中模型的列表、它们的版本以及对应的阶段，显示了这些模型被部署的环境。'
- en: '![Figure 6.15 – MLflow model registry page'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15 – MLflow 模型注册页面](img/B18332_06_015.jpg)'
- en: '](img/B18332_06_015.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_015.jpg)'
- en: Figure 6.15 – MLflow model registry page
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – MLflow 模型注册页面
- en: If you can open the MLflow URL and see the pages as described in the preceding
    steps, then you have just validated that MLflow is configured in your platform.
    The next step is to write a notebook that will train a basic model while recording
    the details in your MLflow server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能打开 MLflow 的 URL 并查看前述步骤中描述的页面，那么你就验证了 MLflow 已在你的平台中配置成功。下一步是编写一个笔记本，训练一个基本模型并将详细信息记录到你的
    MLflow 服务器中。
- en: Using MLFlow as an experiment tracking system
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MLFlow 作为实验跟踪系统
- en: In this section, you will see how the MLflow library allows you to record your
    experiments with the MLflow server. The custom notebook image, which you saw in
    the first part of this chapter, already has MLflow libraries packaged into the
    container. Please refer to the `chapter6/requirements.txt` file for the exact
    version of the MLflow library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将看到 MLflow 库如何允许你将实验记录到 MLflow 服务器中。你在本章第一部分看到的自定义笔记本映像已经将 MLflow 库打包进容器中。请参考
    `chapter6/requirements.txt` 文件，以确认 MLflow 库的确切版本。
- en: 'Before we start this activity, it is important to understand two main concepts:
    **experiment** and **run**.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始此活动之前，理解两个主要概念非常重要：**实验** 和 **运行**。
- en: An experiment is a logical name under which MLflow records and groups the metadata,
    for example, an experiment could be the name of your project. Let's say you are
    working on building a model for predicting credit card fraud for your retail customer.
    This could become the experiment name.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实验是一个逻辑名称，MLflow 会在其中记录和归类元数据，例如，实验可以是你项目的名称。假设你正在为你的零售客户构建一个预测信用卡欺诈的模型，这个名称就可以作为实验的名称。
- en: A run is a single execution of an experiment that is tracked in MLflow. A run
    belongs to an experiment. Each run may have a slightly different configuration,
    different hyperparameters, and sometimes, different datasets. You will tweak these
    parameters of the experiment in a Jupyter notebook. Each execution of model training
    is typically considered a run.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行是对实验的单次执行，MLflow 会跟踪它。每次运行都属于一个实验。每个运行可能有稍微不同的配置、不同的超参数，有时甚至使用不同的数据集。你将在 Jupyter
    笔记本中调整这些实验参数。每次模型训练的执行通常被视为一次运行。
- en: MLflow has two main methods of recording the experiment details. The first one,
    which is our preferred method, is to enable the auto-logging features of MLflow
    to work with your ML library. It has integration with Scikit, TensorFlow, PyTorch,
    XGBoost, and a few more. The second way is to record everything manually. You
    will see both options in the following steps.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: MLflow 记录实验详情的方式有两种。第一种，也是我们推荐的方式，是启用 MLflow 的自动记录功能，使其与 ML 库一起使用。它与 Scikit、TensorFlow、PyTorch、XGBoost
    等库都有集成。第二种方式是手动记录所有内容。你将在接下来的步骤中看到这两种方法。
- en: 'These steps will show you how an experiment run or a model training can be
    recorded in MLflow while executing in a Jupyter notebook:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将展示如何在执行 Jupyter 笔记本时，将实验运行或模型训练记录到 MLflow：
- en: Log in to JupyterHub and make sure to select the custom container, for example,
    **Scikit v1.10 - Elyra Notebook Image**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 JupyterHub，并确保选择自定义容器，例如 **Scikit v1.10 - Elyra 笔记本映像**。
- en: Before you hit the **Start Server** button, add an environment variable by clicking
    on the **Add more variables** link. This variable may contain sensitive information
    such as passwords. MLflow needs this information to upload the artifacts to the
    Minio S3 server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击 **启动服务器** 按钮之前，通过点击 **添加更多变量** 链接，添加一个环境变量。这个变量可能包含敏感信息，如密码。MLflow 需要这些信息来上传工件到
    Minio S3 服务器。
- en: 'The landing page will look like the screenshot in *Figure 6.16*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面将呈现出如 *图 6.16* 所示的截图：
- en: '![Figure 6.16 – JupyterHub with an environment variable'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.16 – 带有环境变量的 JupyterHub'
- en: '](img/B18332_06_016.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_016.jpg)'
- en: Figure 6.16 – JupyterHub with an environment variable
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 带有环境变量的 JupyterHub
- en: Open the notebook at `chapter6/hellomlflow.ipynb`. This notebook shows you how
    you can record your experiment data onto the MLflow server.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `chapter6/hellomlflow.ipynb` 笔记本。这个笔记本展示了如何将你的实验数据记录到 MLflow 服务器中。
- en: '![Figure 6.17 – Notebook with Mlflow integration'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17 – 带有 MLflow 集成的笔记本'
- en: '](img/B18332_06_017.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_017.jpg)'
- en: Figure 6.17 – Notebook with Mlflow integration
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 带有 MLflow 集成的笔记本
- en: Note that at the first code cell, you have imported the MLflow library. In the
    second code cell, you have set up the location of the MLflow server through the
    `set_tracking_uri` method. Note that because your notebook and the MLflow server
    are running on Kubernetes, we just put the location of the Kubernetes Service
    that is stored in the `HOST` variable name and is being used in this method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个代码单元中，您已导入了MLflow库。在第二个代码单元中，您通过`set_tracking_uri`方法设置了MLflow服务器的位置。请注意，因为您的笔记本和MLflow服务器都在Kubernetes上运行，所以我们仅仅将存储在`HOST`变量中的Kubernetes服务位置放在此方法中使用。
- en: You then set the name of the experiment using the `set_experiment` method. This
    is one important variable through which all your experiment runs will be stored
    in the MLflow server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您通过`set_experiment`方法设置实验名称。这是一个重要的变量，通过它，所有的实验运行将被存储在MLflow服务器中。
- en: The last method in this cell is `sklearn.autolog`, which is a way to tell MLflow
    that we are using the Scikit library for our training, and MLflow will record
    the data through Scikit APIs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此单元格中的最后一个方法是`sklearn.autolog`，它是告诉MLflow我们正在使用Scikit库进行训练的一种方式，MLflow将通过Scikit
    API记录数据。
- en: '![Figure 6.18 – Notebook cell with MLflow configuration'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18 – 带有MLflow配置的笔记本单元'
- en: '](img/B18332_06_018.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_018.jpg)'
- en: Figure 6.18 – Notebook cell with MLflow configuration
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 带有MLflow配置的笔记本单元
- en: In the last cell of this notebook, you are using a simple `DecisionTreeClassifier`
    to train your model. Notice that this is quite a simple model and is used to highlight
    the capabilities of the MLflow server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此笔记本的最后一个单元格中，您使用了一个简单的`DecisionTreeClassifier`来训练您的模型。请注意，这是一个相当简单的模型，旨在突出显示MLflow服务器的功能。
- en: Run the notebook by selecting the **Run > Run all cells** menu option.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**运行 > 运行所有单元**菜单选项来运行笔记本。
- en: Log in to the MLflow server and click on the experiment name `HelloMlFlow`.
    The URL of MLflow will be like [https://mlflow.192.168.61.72.nip.io](https://mlflow.192.168.61.72.nip.io)
    with the IP address replaced as per your environment. As mentioned earlier in
    this chapter, you get this URL by listing the *ingress* objects of your Kubernetes
    cluster.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录MLflow服务器并点击实验名称`HelloMlFlow`。MLflow的URL将类似于[https://mlflow.192.168.61.72.nip.io](https://mlflow.192.168.61.72.nip.io)，其中的IP地址根据您的环境进行替换。正如本章前面提到的，您可以通过列出Kubernetes集群的*ingress*对象来获得此URL。
- en: 'You will see the screen as shown in *Figure 6.19*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到如*图6.19*所示的屏幕：
- en: '![Figure 6.19 – MLflow experiments tracking screen showing an experiment run'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19 – MLflow实验跟踪屏幕，显示实验运行'
- en: '](img/B18332_06_019.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_019.jpg)'
- en: Figure 6.19 – MLflow experiments tracking screen showing an experiment run
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – MLflow实验跟踪屏幕，显示实验运行
- en: You will notice that the table on the right-hand side contains one record. This
    is the experiment run you performed in *Step 6*. If you have executed your notebook
    multiple times with different parameters, each run will be recorded as a row in
    this table.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到右侧的表格中包含一条记录。这是您在*第6步*中执行的实验运行。如果您使用不同的参数多次执行笔记本，每次运行都会作为一行记录在此表格中。
- en: Click on the first row of the table.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击表格的第一行。
- en: 'You will get to the details of the run you selected in the previous step. The
    screen will look like the screenshot in *Figure 6.20*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到您在上一步中选择的运行的详细信息。屏幕将显示如*图6.20*所示的截图：
- en: '![Figure 6.20 – MLflow run details'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20 – MLflow运行详情'
- en: '](img/B18332_06_020.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_020.jpg)'
- en: Figure 6.20 – MLflow run details
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 – MLflow运行详情
- en: 'Let''s understand the information that is available on this screen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下此屏幕上可用的信息：
- en: '`4`, you will see that the parameters that we have used for `DecisionTreeClassifier`
    are recorded here too. One such example is the `max_depth` parameter, as shown
    in *Figure 6.21*:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`，您将看到我们为`DecisionTreeClassifier`使用的参数也记录在这里。一个这样的例子是`max_depth`参数，如*图6.21*所示：'
- en: '![Figure 6.21 – MLflow run parameters'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.21 – MLflow运行参数'
- en: '](img/B18332_06_021.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_021.jpg)'
- en: Figure 6.21 – MLflow run parameters
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 – MLflow运行参数
- en: '`training_accuracy` in the screenshot, as shown in *Figure 6.22*:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截图中的`training_accuracy`，如*图6.22*所示：
- en: '![Figure 6.22 – MLflow run metrics'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22 – MLflow运行指标'
- en: '](img/B18332_06_022.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_022.jpg)'
- en: Figure 6.22 – MLflow run metrics
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 – MLflow运行指标
- en: '`estimator_class`), which define the type of ML algorithm you have used. Note
    that you can add your own tags if needed. In the next section, we will show how
    to associate a custom tag for your run. *Figure 6.23* shows an example of tags:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`estimator_class`)，它定义了你使用的 ML 算法的类型。请注意，如果需要，你可以添加自己的标签。在接下来的部分中，我们将展示如何为你的运行关联一个自定义标签。*图
    6.23* 展示了标签的示例：'
- en: '![Figure 6.23 – MLflow run tags'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.23 – MLflow 运行标签'
- en: '](img/B18332_06_023.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_023.jpg)'
- en: Figure 6.23 – MLflow run tags
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – MLflow 运行标签
- en: '`model.pkl` file.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model.pkl` 文件。'
- en: '![Figure 6.24 – MLflow run artifacts'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.24 – MLflow 运行工件'
- en: '](img/B18332_06_024.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_024.jpg)'
- en: Figure 6.24 – MLflow run artifacts
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – MLflow 运行工件
- en: 'To validate that these files are indeed stored in the S3 server, log in to
    the Minio server, select **Buckets**, and click on **Browse** button for the MLflow
    bucket. You will find a folder created with the name of your run. This name is
    displayed in the top-left corner of your experiment screen; consult the top-left
    corner of the preceding screen and you will see a label with a combination of
    32 alphanumeric characters. This long number is your **run ID**, and you can see
    a folder label with a combination of 32 alphanumeric characters in your S3 bucket,
    as shown in the following screenshot. You can click on this link to find the artifacts
    stored on the S3 bucket:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证这些文件确实存储在 S3 服务器中，请登录 Minio 服务器，选择 **Buckets**，然后点击 MLflow 存储桶的 **Browse**
    按钮。你会发现一个以运行名称命名的文件夹。这个名称显示在实验屏幕的左上角；查看前一个屏幕的左上角，你会看到一个由 32 个字母数字字符组成的标签。这个长数字就是你的
    **运行 ID**，你可以在 S3 存储桶中看到一个由 32 个字母数字字符组成的文件夹标签，如下图所示。你可以点击此链接查看存储在 S3 存储桶中的工件：
- en: '![Figure 6.25 – Minio bucket location'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.25 – Minio 存储桶位置'
- en: '](img/B18332_06_025.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_025.jpg)'
- en: Figure 6.25 – Minio bucket location
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25 – Minio 存储桶位置
- en: You have just successfully trained a model in JupyterHub and tracked the training
    run in MLflow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚在 JupyterHub 中成功训练了一个模型，并在 MLflow 中跟踪了训练过程。
- en: You have seen how MLflow associates the data with each of your runs. You can
    even compare the data between multiple runs by selecting multiple runs from the
    table shown in *Step 6* and clicking on the **Compare** button.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 MLflow 如何将数据与每次运行关联。你甚至可以通过从 *步骤 6* 中选择多个运行并点击 **Compare** 按钮，比较多个运行之间的数据。
- en: Adding custom data to the experiment run
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向实验运行添加自定义数据
- en: 'Now, let''s see how we can add more data for each run. You will learn how to
    use the MLflow API to associate custom data with your experiment:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为每次运行添加更多数据。你将学习如何使用 MLflow API 将自定义数据与实验关联：
- en: Start by firing up the Jupyter notebook as you did in the preceding section.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从启动 Jupyter 笔记本开始，方法和上一节一样。
- en: 'Open the notebook at `chapter6/hellomlflow-custom.ipynb`. This notebook shows
    you how you can customize the recording of your experiment data onto the MLflow
    server. The notebook is similar to the previous notebook, except for the code
    in cell number `6`, which is shown in *Figure 6.26*. This code cell contains the
    functions that show how to associate data with your experiment:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `chapter6/hellomlflow-custom.ipynb` 笔记本。这个笔记本展示了如何将你的实验数据记录到 MLflow 服务器上。这个笔记本与之前的笔记本相似，唯一的区别是第`6`号单元格的代码，见*图
    6.26*。这个代码单元包含了展示如何将数据与实验关联的函数：
- en: '![Figure 6.26 – MLflow customized data collection notebook'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.26 – MLflow 自定义数据收集笔记本'
- en: '](img/B18332_06_026.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_026.jpg)'
- en: Figure 6.26 – MLflow customized data collection notebook
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 – MLflow 自定义数据收集笔记本
- en: 'Let''s understand these functions in the next few steps. The code snippet in
    code cell number `6` is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几步中理解这些函数。第`6`号代码单元中的代码片段如下：
- en: '[PRE6]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code will include a custom tag labeled `code.repoURL`. This makes
    it easier to trace back the original source code that produced the model in a
    given experiment run.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将包括一个名为 `code.repoURL` 的自定义标签。这样可以更轻松地追溯生成某次实验运行模型的原始源代码。
- en: You can associate any tags while calling the `start_run` function. Tag keys
    that start with *mlflow* are reserved for internal use. You can see that we have
    associated the GIT commit hash with the first property. This will help us in following
    through on what experiment belongs to what code version in your code repository.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `start_run` 函数时，你可以关联任何标签。以 *mlflow* 开头的标签键是保留用于内部使用的。你可以看到我们将 GIT 提交哈希与第一个属性关联。这将帮助我们跟踪哪些实验属于代码仓库中的哪个代码版本。
- en: You will find that the `code.repoURL` tag contains the Git repository location.
    You can add as many tags as you want. You can see the tags by going to the MLflow
    UI and opening the experiment. Note that the notebook has a different experiment
    name, and it is being referenced as `HelloMlFlowCustom`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`code.repoURL`标签包含了 Git 仓库的位置。你可以根据需要添加任意数量的标签。通过进入 MLflow UI 并打开实验，你可以看到这些标签。请注意，笔记本使用了不同的实验名称，它被引用为`HelloMlFlowCustom`。
- en: 'Note the `code.repoURL` in the **Tags** section:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`code.repoURL`位于**标签**部分：
- en: '![ Figure 6.27 – MLflow custom tags'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.27 – MLflow 自定义标签'
- en: '](img/B18332_06_027.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_027.jpg)'
- en: Figure 6.27 – MLflow custom tags
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27 – MLflow 自定义标签
- en: The second function that we have used is `record_libraries`. This is a wrapper
    function that internally uses the `mlflow.log_artifact` function to associate
    a file with the run. This utility function is capturing the `pip freeze` output,
    which gives the libraries in the current environment. The utility function then
    writes it to a file and uploads the file to the MLflow experiment. You can look
    at this, and all the other functions, in the `chapter6/mlflow_util.py` file.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用的第二个函数是`record_libraries`。这是一个封装函数，内部使用`mlflow.log_artifact`函数将文件与运行关联。这个工具函数捕获了`pip
    freeze`命令的输出，该命令列出了当前环境中的库。然后，该工具函数将其写入文件并将文件上传到 MLflow 实验。你可以查看这个函数以及其他所有函数，位于`chapter6/mlflow_util.py`文件中。
- en: 'You can see in the `pip_freeze.txt`, is available, and it records the output
    of the `pipe freeze` command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在`pip_freeze.txt`中记录了`pip freeze`命令的输出：
- en: '![Figure 6.28 – MLflow customized artifacts'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.28 – MLflow 自定义工件'
- en: '](img/B18332_06_028.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_028.jpg)'
- en: Figure 6.28 – MLflow customized artifacts
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.28 – MLflow 自定义工件
- en: 'The `log_metric` function records the metric name and its associated value.
    Note that the value for the metric is expected to be a number. For the sample
    code, you can see that we have just put a hardcoded value (`1`), however, in the
    real world, this would be a dynamic value that refers to something relative to
    each run of your experiment. You can find your custom metric in the **Metrics**
    section of the page:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log_metric`函数记录指标名称及其相关值。请注意，指标的值应为数字。在示例代码中，我们只是放入了一个硬编码的值（`1`），然而，在实际应用中，这将是一个动态值，指向与每次实验运行相关的内容。你可以在页面的**指标**部分找到自定义的指标：'
- en: '![Figure 6.29 – MLflow customized metrics'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.29 – MLflow 自定义指标'
- en: '](img/B18332_06_029.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_029.jpg)'
- en: Figure 6.29 – MLflow customized metrics
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29 – MLflow 自定义指标
- en: 'The `log_param` function is like the `log_metric` function, but it can take
    any type of value against a given parameter name. For example, we have recorded
    the Docker image used by the Jupyter notebook. Recall that this is the custom
    image you built to be used by the data scientist team. You can see the following
    `docker_image_name` parameter that contains the desired value:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log_param`函数与`log_metric`函数类似，但它可以接受任何类型的值与给定的参数名称。例如，我们记录了 Jupyter 笔记本使用的
    Docker 镜像。请记住，这是你为数据科学团队构建的自定义镜像。你可以看到下面的`docker_image_name`参数，它包含了所需的值：'
- en: '![Figure 6.30 – MLflow customized parameters'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.30 – MLflow 自定义参数'
- en: '](img/B18332_06_030.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_030.jpg)'
- en: Figure 6.30 – MLflow customized parameters
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30 – MLflow 自定义参数
- en: You have used MLflow to track, add custom tags, and custom artifacts to an experiment
    run. In the next section, you will see the capabilities of MLflow as a model registry
    component. Let's dig in.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用 MLflow 跟踪、添加自定义标签和自定义工件到实验运行中。在下一部分中，你将看到 MLflow 作为模型注册组件的功能。让我们深入了解。
- en: Using MLFlow as a model registry system
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MLFlow 作为模型注册系统
- en: 'Recall that MLflow has a model registry feature. The registry provides the
    versioning capabilities for your models. Automation tools can get the models from
    the registry to deploy or even roll back your models across different environments.
    You will see in the later chapters that automation tools in our platform fetch
    the model from this registry via the API. For now, let''s see how to use the registry:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，MLflow 具有模型注册功能。该注册表为你的模型提供版本控制功能。自动化工具可以从注册表中获取模型来进行部署，甚至在不同环境间回滚你的模型。在后续章节中，你将看到我们的平台中的自动化工具通过
    API 从这个注册表中获取模型。现在，让我们来看一下如何使用注册表：
- en: 'Log in to the MLflow server by accessing the UI and clicking on the **Models**
    link. You should see the following screen. Click on the **Create Model** button:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 UI 并点击**模型**链接，登录到 MLflow 服务器。你应该能看到以下屏幕。点击**创建模型**按钮：
- en: '![Figure 6.31 – MLflow registering a new model'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.31 – MLflow 注册新模型'
- en: '](img/B18332_06_031.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_031.jpg)'
- en: Figure 6.31 – MLflow registering a new model
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.31 – MLflow 注册新模型
- en: 'Type a name for your model in the pop-up window, as shown in the following
    screenshot, and click on the **Create** button. This name could mention the name
    of the project that this model is serving:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出窗口中输入模型名称，如下图所示，然后点击**创建**按钮。这个名称可以提到该模型所服务的项目名称：
- en: '![Figure 6.32 – MLflow model name prompt'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.32 – MLflow 模型名称提示'
- en: '](img/B18332_06_032.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_032.jpg)'
- en: Figure 6.32 – MLflow model name prompt
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32 – MLflow 模型名称提示
- en: Now, you need to attach a model file to this registered name. Recall from the
    preceding section that you have multiple *runs* in your *experiment*. Each run
    defines the set of configuration parameters and associated models with it. Select
    the experiment and run for which you want to register your model.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要将模型文件附加到这个注册的名称上。回想一下前面的部分，你在*实验*中有多个*运行*。每次运行都定义了一组配置参数并将模型与之关联。选择你想注册模型的实验和运行。
- en: 'You will see a screen like the following. Select the **model** label in the
    **Artifacts** section, and you will notice a **Register Model** button on the
    right-hand side. Click on this button:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到如下屏幕。选择**工件**部分中的**模型**标签，你会注意到右侧有一个**注册模型**按钮。点击这个按钮：
- en: '![Figure 6.33 – MLflow showing the Register Model button'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.33 – MLflow 显示注册模型按钮'
- en: '](img/B18332_06_033.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_033.jpg)'
- en: Figure 6.33 – MLflow showing the Register Model button
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33 – MLflow 显示注册模型按钮
- en: From the pop-up window, select the model name you created in *Step 1* and click
    on **Register**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出窗口中，选择你在*步骤 1* 中创建的模型名称，然后点击**注册**。
- en: '![Figure 6.34 – Model name dialog when registering a model in MLflow'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.34 – 在 MLflow 中注册模型时的模型名称对话框'
- en: '](img/B18332_06_034.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_034.jpg)'
- en: Figure 6.34 – Model name dialog when registering a model in MLflow
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34 – 在 MLflow 中注册模型时的模型名称对话框
- en: 'Go to the `mlflowdemo`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `mlflowdemo`：
- en: '![Figure 6.35 – MLflow showing the list of registered models and their versions'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.35 – MLflow 显示已注册模型及其版本的列表'
- en: '](img/B18332_06_035.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_035.jpg)'
- en: Figure 6.35 – MLflow showing the list of registered models and their versions
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.35 – MLflow 显示已注册模型及其版本的列表
- en: 'You will see the detail screen where you can attach the stage of the model
    as referred to by the **Stage** label. You can also edit other properties, and
    we will leave it to you to explore the data you can associate with this model:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到详细信息屏幕，在这里你可以附加模型的阶段，如**阶段**标签所示。你还可以编辑其他属性，我们将留给你去探索与此模型相关的数据：
- en: '![Figure 6.36 – MLflow showing the buttons for promoting registered models
    to higher environments'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.36 – MLflow 显示用于将已注册模型提升到更高环境的按钮'
- en: '](img/B18332_06_036.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18332_06_036.jpg)'
- en: Figure 6.36 – MLflow showing the buttons for promoting registered models to
    higher environments
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.36 – MLflow 显示用于将已注册模型提升到更高环境的按钮
- en: Congratulations! You have just experienced using MLflow as a model registry!
    You have also seen how the model version can be promoted to the different stages
    of the lifecycle.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你刚刚体验了使用 MLflow 作为模型注册表！你还看到了如何将模型版本提升到生命周期的不同阶段。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have gained a better understanding of ML engineering and
    how it differs from data science. You have also learned about some of the responsibilities
    of ML engineers. You must take note that the definition of ML engineering and
    the role of ML engineers are still evolving, as more and more techniques are surfacing.
    One such technique that we will not talk about in this book is **online ML**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你对 ML 工程有了更深入的了解，并且了解了它与数据科学的区别。你还了解了一些 ML 工程师的职责。你必须注意，ML 工程学的定义和 ML 工程师的角色仍在不断发展，因为越来越多的技术正在浮现。我们本书中不会讨论的一项技术是**在线
    ML**。
- en: You have also learned how to create a custom notebook image and use it to standardize
    notebook environments. You have trained a model in the Jupyter notebook while
    using MLflow to track and compare your model development parameters, training
    results, and metrics. You have also seen how MLflow can be used as a model registry
    and how to promote model versions to different stages of the lifecycle.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何创建自定义的笔记本镜像，并使用它来标准化笔记本环境。你已经在 Jupyter 笔记本中训练了一个模型，同时使用 MLflow 跟踪和比较模型开发的参数、训练结果和指标。你还了解了
    MLflow 如何作为模型注册表使用，以及如何将模型版本提升到生命周期的不同阶段。
- en: The next chapter will continue the ML engineering domain and you will package
    and deploy ML models to be consumed as an API. You will then automate the package
    and deploy the process using the tools available in the ML platform.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续讲解机器学习工程领域，你将学习如何将机器学习模型打包并部署，以便作为API进行使用。然后，你将使用机器学习平台提供的工具来自动化打包和部署过程。
