- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Managing Secrets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理机密
- en: Everyone has secrets, and Kubernetes clusters are no different. **Secrets**
    can be used to store credentials for connecting to databases, private keys for
    encryption or authentication, or anything else that’s deemed confidential. In
    this chapter, we’ll explore why secret data has to be handled differently than
    other configuration data, how to model threats against your cluster’s secrets,
    and different ways to integrate external secret managers into your clusters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都有秘密，Kubernetes集群也不例外。**机密**可以用于存储连接数据库的凭据、加密或身份验证的私钥，或任何其他被认为是机密的信息。在本章中，我们将探讨为何机密数据需要与其他配置数据以不同方式处理，如何对集群的机密进行威胁建模，以及如何将外部机密管理器集成到您的集群中。
- en: In *Chapter 6**, Integrating Authentication into Your Cluster*, we created some
    secrets for **OpenUnison**. These Secrets were simple Kubernetes objects and weren’t
    treated any differently then we’d treat other configuration data. This makes it
    difficult to follow common enterprise requirements for secret data, such as periodic
    rotation and tracking usage. It’s important to understand why enterprises generally
    have these requirements and how to implement them. It’s also important to be able
    to model threats from a realistic perspective and to avoid creating security holes
    by trying to make things more secure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*《将身份验证集成到您的集群》中，我们为**OpenUnison**创建了一些机密。这些机密是简单的Kubernetes对象，并没有与其他配置数据有所不同地处理。这使得我们很难遵循常见的企业机密数据要求，例如定期轮换和使用情况跟踪。了解企业为什么通常有这些要求，以及如何实施这些要求，非常重要。同时，也要能够从现实角度进行威胁建模，并避免通过试图提高安全性而创建安全漏洞。
- en: 'This chapter will walk through why you need to treat secret data different
    from other configuration data and provide you the tools you’ll need to determine
    your secrets management requirements and to build out your secrets management
    platform. We’ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍为何需要将机密数据与其他配置数据区别对待，并提供您所需的工具，以确定您的机密管理需求并构建您的机密管理平台。我们将涵盖：
- en: Examining the difference between Secrets and Configuration Data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查机密与配置数据之间的区别
- en: Understanding Secrets Managers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解机密管理器
- en: Integrating Secrets into your Deployments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将机密集成到您的部署中
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: An Ubuntu 22.04+ server running Docker with a minimum of 4 GB of RAM, though
    8 GB is suggested
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行Docker的Ubuntu 22.04+服务器，至少需要4 GB内存，建议8 GB内存
- en: 'Scripts from the `chapter8` folder from the repo, which you can access by going
    to this book’s GitHub repository: [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`chapter8`文件夹中的脚本，您可以通过访问本书的GitHub仓库来获取：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition)
- en: Getting Help
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帮助
- en: We do our best to test everything, but there are sometimes half a dozen systems
    or more in our integration labs. Given the fluid nature of technology, sometimes
    things that work in our environment don’t work in yours. Don’t worry, we’re here
    to help! Open an issue on our GitHub repo at [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues)
    and we’ll be happy to help you out!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽力测试所有内容，但在我们的集成实验室中，有时会有六个或更多系统。鉴于技术的流动性，有时候在我们的环境中有效的东西在您的环境中可能不起作用。别担心，我们在这里帮忙！在我们的GitHub仓库上打开一个问题：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues)，我们将很乐意为您提供帮助！
- en: Examining the difference between Secrets and Configuration Data
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查机密与配置数据之间的区别
- en: What makes a `Secret` different than the configuration data stored in a `ConfigMap`
    or a **CRD**? From a Kubernetes perspective, the only real difference is that
    both `ConfigMaps` and CRDs are represented as text, where as a `Secret` is represented
    as a **base64** encoded string, allowing secrets to contain binary data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使得`Secret`与存储在`ConfigMap`或**CRD**中的配置数据不同？从Kubernetes的角度来看，唯一的实际区别是，`ConfigMap`和CRD都表示为文本，而`Secret`则表示为**base64**编码的字符串，这使得机密可以包含二进制数据。
- en: If you are new to base64, it is an encoding process, known for using a 64-character
    set that converts binary data into an ASCII character string. This provides a
    reliable method to send binary information during transmission as text, which
    is beneficial when direct binary support is unsupported or where the risk of data
    corruption in a plain text transmission is a concern, making it useful for transmitting
    images, audio, and binary files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对base64不熟悉，它是一种编码过程，使用64个字符集将二进制数据转换为ASCII字符字符串。这提供了一种可靠的方法，将二进制信息在传输过程中作为文本发送，当直接的二进制支持不可用或纯文本传输可能导致数据损坏的风险时，它非常有用，因此适用于传输图像、音频和二进制文件。
- en: There can be some confusion between the terms encoding and encryption. Encryption
    requires a key to decode, while encoding does not. While encoding might provide
    some obscurity to text, it doesn’t protect it. If you didn’t need a key to encode
    your data, it’s not encrypted.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编码和加密这两个术语之间可能会有一些混淆。加密需要密钥来解码，而编码则不需要。虽然编码可能为文本提供一些模糊性，但它并不保护文本。如果你在编码数据时不需要密钥，那就不是加密。
- en: 'Now, let’s look at a `Secret` object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一个`Secret`对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This looks very similar to a `ConfigMap`, but there are two differences:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与`ConfigMap`非常相似，但有两个不同之处：
- en: The addition of the `type` directive tells Kubernetes what kind of Secret this
    is.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`type`指令告诉Kubernetes这是什么类型的`Secret`。
- en: All of the fields in the `data` section are base64 encoded.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`部分的所有字段都是base64编码的。'
- en: The `type` directive tells Kubernetes what kind of `Secret` you’re creating.
    In this case, `type` `Opaque` means that there is no format to the `Secret`'s
    `data` section. This will likely be the most common `type` you will see.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`指令告诉Kubernetes你正在创建哪种类型的`Secret`。在这种情况下，`type` `Opaque`意味着`Secret`的`data`部分没有特定格式。这将是你最常见的`type`。'
- en: 'There are no requirements for the `type` directive; you can specify whatever
    you want if you wish to provide your own value. That said, if you do provide one
    of Kubernetes’ pre-defined types, the cluster will validate that the format matches.
    You can find the list of pre-defined types in Kubernetes’ `Secret` documentation:
    [https://kubernetes.io/docs/concepts/configuration/secret/#secret-types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`指令没有任何要求；如果你希望提供自己的值，可以随意指定。然而，如果你提供了Kubernetes预定义的类型之一，集群会验证格式是否匹配。你可以在Kubernetes的`Secret`文档中找到预定义类型的列表：[https://kubernetes.io/docs/concepts/configuration/secret/#secret-types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)'
- en: 'For instance, if you were to set the `type` to `kubernetes.io/tls` your `Secret`
    must have a key called `tls.crt` (i.e., a base64-encoded PEM encoded certificate)
    and a key called `tls.key` (i.e., a base64 encoded PEM private key), otherwise
    the API server will fail to create your `Secret` and give you an error. Here’s
    an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你将`type`设置为`kubernetes.io/tls`，那么你的`Secret`必须包含一个名为`tls.crt`（即，base64编码的PEM证书）的键，以及一个名为`tls.key`（即，base64编码的PEM私钥）的键，否则API服务器将无法创建你的`Secret`并返回错误。以下是一个示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The base64 encoding of data is for a very simple reason, but is also the source
    of considerable confusion. Kubernetes `Secret` data *must* be base64 encoded because
    secret data is often case sensitive or binary and so must be encoded to ensure
    that it survives the translation from YAML -JSON -binary storage.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的base64编码有一个非常简单的原因，但也是许多困惑的来源。Kubernetes的`Secret`数据*必须*是base64编码的，因为机密数据通常是区分大小写的或是二进制数据，因此必须编码以确保它在从YAML
    - JSON - 二进制存储的转换过程中能够正常存活。
- en: It’s important to understand how YAML gets stored in the Kubernetes API server
    to understand why.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解YAML在Kubernetes API服务器中如何存储非常重要，因为这有助于理解为什么需要这种方式。
- en: When we work with a YAML file, the text is represented in the file by a byte
    (or more). This YAML is then converted to JSON by `kubectl` for interacting with
    the Kubernetes API. The JSON that is sent to the API server is then translated
    into a binary format when it is stored. The problem we run into with many text-based
    formats is that there are multiple ways to represent text-based data in a binary
    format.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理YAML文件时，文本在文件中由一个字节（或多个字节）表示。然后，`kubectl`将该YAML转换为JSON以与Kubernetes API进行交互。发送到API服务器的JSON在存储时会被转换为二进制格式。我们在许多基于文本的格式中遇到的问题是，有多种方法可以以二进制格式表示文本数据。
- en: For instance, **UTF-8**, which is one of the most common encodings, can use
    from one to four bytes to represent a certain character. **UTF-16** uses one to
    four 16-bit “code units”. **ASCII** can only encode the English alphabet, Arabic
    numerals, and common English punctuation. If the encoding from YAML – JSON - binary
    and back involves switches encoding types, data can be lost or corrupted.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**UTF-8** 是最常见的编码方式之一，它可以使用从一个到四个字节来表示某个字符。**UTF-16** 使用一个到四个 16 位的“代码单元”。**ASCII**
    只能编码英文字母、阿拉伯数字和常见的英文标点符号。如果 YAML、JSON 和二进制之间的编码转换涉及到编码类型的切换，数据可能会丢失或损坏。
- en: Preserving binary data in text is where the base64 standard comes in. Base64
    allows any data to be stored as ASCII text, which is a subset universally across
    different encoding types. This means that the base64-encoded data can be reliably
    transmitted across encoding types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本中保留二进制数据就是 base64 标准的应用所在。Base64 允许将任何数据以 ASCII 文本的形式存储，这是一种在不同编码类型中通用的子集。这意味着
    base64 编码的数据可以可靠地跨编码类型进行传输。
- en: 'If you’re still skeptical of why base64 encoding your secret data is important,
    have you ever copied a file created on Windows to a Linux system and started seeing
    `^M` in the text? That’s an additional risk of traversing systems: different systems
    represent new lines with different control characters. Base64 encoding your secret
    data means that the information in the YAML file is the same as what’s stored
    byte-for-byte.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对为什么将你的机密数据进行 base64 编码感到怀疑，试想一下你是否曾将一个在 Windows 上创建的文件复制到 Linux 系统，并开始在文本中看到
    `^M`？这就是跨系统的额外风险：不同的系统用不同的控制字符表示换行。将机密数据进行 base64 编码意味着 YAML 文件中的信息与存储的字节逐字节相同。
- en: One thing that’s incredibly important to understand is that base64 encoding
    is not encryption. There is no security benefit to encoding, it will not stop
    someone from snooping on your secrets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一件非常重要的事情是，base64 编码并不是加密。编码没有安全性上的好处，它不能阻止别人窃取你的机密。
- en: Now that we know why `Secret` `data` is base64 encoded, why are `Secrets` their
    own objects? Why don’t we just base64 encode `ConfigMaps`? The answer is to more
    easily use RBAC to restrict access. In the last chapter, we explored Kubernetes’
    RBAC system for authorizing access to resources. In the chapter before that, we
    explored how Kubernetes creates `ServiceAccount` tokens, which can be stored in
    `Secret` objects. Combining the knowledge from these two chapters, we see how
    storing sensitive data in a `ConfigMap` can generate unintended consequences when
    we consider the `view` `ClusterRole`, which is intended to give read-only access
    to a `namespace`. This `ClusterRole` does not include the `Secret` type, so `view`
    will allow you to read `ConfigMaps`, view pod status, etc., but not read a `Secret`.
    This is because a `Secret` might contain a token for a `ServiceAccount`, which
    is bound to a higher-privilege `Role` or `ClusterRole`, so a user with read-only
    access can escalate that access if we’re not careful. If secret data were stored
    in `ConfigMaps`, RBAC would either need to support some way to exclude resources
    or enumerate specific `ConfigMap` objects that should be allowed to be viewable
    by the `view ClusterRole`, making it likely to not be used properly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道为什么 `Secret` `data` 是 base64 编码的，为什么 `Secrets` 要作为独立的对象存在？为什么不直接对 `ConfigMaps`
    进行 base64 编码呢？答案是为了更容易使用 RBAC 限制访问权限。在上一章中，我们探讨了 Kubernetes 的 RBAC 系统，用于授权对资源的访问。在之前的一章中，我们探讨了
    Kubernetes 如何创建 `ServiceAccount` 令牌，并将其存储在 `Secret` 对象中。结合这两章的知识，我们可以看到，将敏感数据存储在
    `ConfigMap` 中可能会带来意想不到的后果，特别是在考虑到 `view` `ClusterRole` 时，它旨在为 `namespace` 提供只读访问权限。这个
    `ClusterRole` 不包括 `Secret` 类型，因此 `view` 只会允许你读取 `ConfigMaps`、查看 Pod 状态等，但不能读取
    `Secret`。这是因为 `Secret` 可能包含一个绑定到更高权限的 `Role` 或 `ClusterRole` 的 `ServiceAccount`
    令牌，如果不小心，拥有只读访问权限的用户可能会提升访问权限。如果将机密数据存储在 `ConfigMaps` 中，RBAC 就需要支持某种方法来排除资源或列举出应允许
    `view ClusterRole` 查看特定的 `ConfigMap` 对象，这使得它可能会被使用不当。
- en: Now that we know what makes a `Secret` different than other configuration objects,
    we will explore why you need to treat `Secret` objects differently than `ConfigMaps`
    and CRDs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `Secret` 与其他配置对象的不同之处，接下来我们将探讨为什么你需要将 `Secret` 对象与 `ConfigMaps` 和 CRDs
    区别对待。
- en: Managing Secrets in an Enterprise
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在企业中管理 Secrets
- en: The title of this book includes the word “enterprise,” and secret data management
    is a big area where this is important. Most enterprises have very specific rules
    around secrets management. Some of these rules involve being able to audit when
    a secret is used, and others require that secrets be rotated on a periodic basis.
    Following these rules is a process referred to as “compliance” and is often one
    of the largest cost drivers for any enterprise deployment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的标题中包含“企业”一词，秘密数据管理是一个非常重要的领域。大多数企业对于秘密管理有非常具体的规则。其中一些规则要求能够审计秘密何时被使用，另一些规则则要求秘密定期轮换。遵循这些规则的过程被称为“合规”，并且通常是任何企业部署中的最大成本驱动因素之一。
- en: Security and compliance are often grouped together, but they do not mean the
    same thing. It’s quite easy to build a 100% compliant system that makes your auditors
    happy, but will fail to secure your applications and data. That’s why it’s important
    to understand why you’re building certain features into your platforms. You need
    to ask yourself, are they satisfying compliance, security, or both?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性和合规性通常被放在一起讨论，但它们并不意味着相同的事情。构建一个 100% 合规的系统是很容易的，这样会让你的审计员满意，但却可能无法保护你的应用和数据的安全。这就是为什么理解你在平台中构建某些功能的目的非常重要。你需要问自己，它们是在满足合规性、安全性，还是两者兼顾？
- en: In order to answer this question, you need to understand the threats to your
    data and systems. This process is referred to as **threat modeling**, and several
    books have been written on the topic. In this chapter, we’re going to build a
    very basic threat model for Kubernetes secrets based on where they are in the
    application’s deployment. We’ll start with secrets at rest.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，你需要理解数据和系统面临的威胁。这个过程被称为**威胁建模**，并且已经有许多书籍专门讨论这一主题。在本章中，我们将基于 Kubernetes
    秘密在应用程序部署中的位置，构建一个非常基础的威胁模型。我们将从静态秘密开始。
- en: Threats to Secrets at Rest
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态秘密的威胁
- en: When a secret, such as a credential or a key, is in storage it is referred to
    being “at rest,” since data is not being moved. Nearly every compliance framework
    requires that secrets at rest be encrypted. This makes sense; why wouldn’t you
    encrypt your data at rest? In Kubernetes, you can configure `etcd` to encrypt
    data at rest and you may think you’ve not only met a compliance requirement (often
    referred to as “checking the box”) but increased the security of your cluster!
    The truth is much more complicated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个秘密，比如凭证或密钥，处于存储状态时，它被称为“静态”，因为数据没有被移动。几乎每个合规框架都要求静态数据必须进行加密。这是有道理的；你为什么不加密存储中的数据呢？在
    Kubernetes 中，你可以配置 `etcd` 来加密静态数据，你可能认为自己不仅满足了合规要求（通常称为“打勾”），而且提高了集群的安全性！但事实远比这复杂。
- en: 'Before we dive into how Kubernetes encrypts data at rest, let’s do a quick
    recap of how encryption works. All encryption involves three basic components:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 Kubernetes 如何加密静态数据之前，先快速回顾一下加密的基本原理。所有的加密都涉及三个基本组件：
- en: '**Data**: Either encrypted (cipher text) or decrypted (plain text).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：可以是加密后的密文，也可以是解密后的明文。'
- en: '**Key**:Used to encrypt your plain text to cipher text and to decrypt your
    cipher text to plain text.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥**：用于将明文加密为密文，也用于将密文解密为明文。'
- en: '**Algorithm**: Some process to combine the key and data to encrypt or decrypt
    it.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**：将密钥和数据结合的某种过程，用于加密或解密。'
- en: Every encryption class or book will teach you that the key is always a secret
    while hiding the algorithm should never be relied upon for secrecy. This means
    that if an attacker knows you’re using AES-256, it really doesn’t matter because
    it’s the key that’s the secret.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每本关于加密的书或课程都会教你，密钥永远是一个秘密，而算法的保密性不应被依赖。这意味着，如果攻击者知道你使用的是 AES-256，这其实并不重要，因为密钥才是秘密。
- en: What’s important here is that if you’re using encryption, you must have a key
    available to encrypt and decrypt the data. There is a great deal of nuance in
    how the different algorithms work, differences between block and stream ciphers,
    how keys are generated, etc. That nuance isn’t important to this discussion, no
    matter how fascinating it is. The fact that you need your key and data in the
    same place at the same time limits the security impact of encrypting data at rest
    because the security is only increased if the data and the key are separate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，如果你使用加密，你必须有一个密钥来加密和解密数据。不同算法的工作方式、块加密与流加密的区别、密钥的生成方式等存在许多细微差别。虽然这些差别非常有趣，但它们对本讨论并不重要。关键是，你需要在同一时间将密钥和数据放在一起，这限制了加密静态数据的安全影响，因为只有当数据和密钥分开时，安全性才会得到提高。
- en: With that sidebar in encryption completed, you might start to see the issue
    with encrypting data in Kubernetes’ database. Kubernetes does support encrypting
    data and we’re not going to cover it here because of the complexities, other than
    to describe it at a high level.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了关于加密的旁白，你可能开始意识到在 Kubernetes 数据库中加密数据的问题。Kubernetes 确实支持数据加密，我们不会在这里详细讨论它，因为涉及的复杂性，除非从高层次进行描述。
- en: Kubernetes encryption works by configuring an `EncryptionConfiguration` object
    that identifies what data is encrypted and with what keys. This object is accessible
    from the host running your API servers. Do you see the flaw with this? If someone
    has access to the cluster, they have the keys!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 加密通过配置 `EncryptionConfiguration` 对象来工作，该对象指定了哪些数据被加密以及使用什么密钥进行加密。这个对象可以从运行
    API 服务器的主机访问。你看出这个问题了吗？如果有人可以访问集群，他们就有密钥！
- en: If your `etcd` instances are run on different servers there’s some additional
    security, but does that benefit offset the risks involved when you need to decrypt
    and re-encrypt for key rotation? That’s a decision you need to make on your own.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `etcd` 实例运行在不同的服务器上，那么会有一些额外的安全性，但是当你需要为密钥轮换进行解密和重新加密时，这种好处是否能抵消相关的风险呢？这是你需要自己做出的决定。
- en: 'Does encrypting your data at rest make your clusters less secure? Consider
    the “**CIA triad** of security” that’s most often used to describe the security
    requirements and impacts on a system. **CIA** stands for:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 加密静态数据会让你的集群更加安全吗？考虑一下“**CIA 三位一体**”安全模型，它通常用于描述系统的安全需求和影响。**CIA** 代表：
- en: '**Confidentiality**: Can we ensure we’re the only ones who have access to this
    data?'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：我们能确保只有我们自己能够访问这些数据吗？'
- en: '**Integrity**: How sure are we that the data hasn’t been tampered with?'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：我们怎么确定数据没有被篡改？'
- en: '**Availability**: Is the data available when we need it?'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：我们需要数据时，它是否可用？'
- en: Encrypting the data helps with the C+I portion of the CIA triad, assuming we
    can trust the keys (we’ll talk about that in a moment). If the key rotation requires
    downtime, or has a high risk of an outage, our “A” can be impacted.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加密数据有助于保护 CIA 三位一体中的 C+I 部分，前提是我们可以信任密钥（我们稍后会谈到）。如果密钥轮换需要停机，或者停机风险较高，那么我们的“A”（可用性）可能会受到影响。
- en: There’s an argument that encryption doesn’t provide data integrity assurances
    because encrypted data can be corrupted and you need signatures to validate data.
    **Signatures** are just a form of encryption with a private key that can be validated
    with a public key, so it’s all still encryption. If someone can tamper with encrypted
    data in a way that bypasses your keys, or using your keys, then the data can’t
    be trusted. This is why I include integrity as a benefit of encryption.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种观点认为加密并不能提供数据完整性保证，因为加密数据可能会被破坏，需要使用签名来验证数据。**签名**本质上是一种使用私钥加密、可以通过公钥验证的加密方式，所以这仍然是加密。如果有人可以篡改加密数据，绕过你的密钥或使用你的密钥，那么数据就无法信任。这就是为什么我把完整性视为加密的一个好处。
- en: 'Speaking of the keys, maybe we don’t store the keys locally. Kubernetes does
    support external key management systems. We’ll dive into the details of how your
    cluster authenticates with a vault or **KMS** later in the chapter. For now, what’s
    important is that to make sure that generated authentication tokens are being
    given to the correct system, you need a local key to use for authenticating, leading
    to the same impact as having the decryption key local to your cluster: a local
    compromise means an attacker will have both the keys and the encrypted data at
    the same time and so can decrypt it.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 说到密钥，或许我们并不把密钥存储在本地。Kubernetes 确实支持外部密钥管理系统。我们将在本章后面深入探讨集群如何与保管库或**KMS**进行身份验证。现在，重要的是要确保生成的身份验证令牌被正确地分配给目标系统，你需要一个本地密钥用于身份验证，这会带来与将解密密钥存储在集群本地相同的影响：本地的安全漏洞意味着攻击者会同时拥有密钥和加密数据，从而能够解密数据。
- en: So, you’ve gone through the process of encrypting data in your cluster and you’ve
    checked the box. Is your cluster secure? This is where security and compliance
    aren’t the same thing. If you’ve deployed this encrypted database onto a system
    with a single user account that’s shared across multiple users, you’ve created
    a new way to get attacked while thinking you’re secure! It’s important to note
    that most compliance frameworks still require some form of authorization management,
    but many vendors push this off to another system and often the answer is “we keep
    the keys in a vault,” creating a circular compliance issue. These complexities
    are what make securing Kubernetes and being compliant so difficult.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经完成了加密集群数据的过程，并且打了勾。你的集群安全吗？这时，安全和合规性并不完全相同。如果你将这个加密的数据库部署到一个拥有多个用户共享的单一用户账户的系统上，你就创造了一种新的攻击方式，而你却以为自己是安全的！需要注意的是，大多数合规框架仍然要求某种形式的授权管理，但许多供应商将此推给了另一个系统，通常的回答是“我们把密钥保存在保管库中”，这就形成了一个循环合规问题。这些复杂性正是使得保障
    Kubernetes 安全并保持合规性变得如此困难的原因。
- en: Having examined how we can approach encryption of Kubernetes’ data at rest,
    we’ll next explore threats to Kubernetes’ secrets in transit between systems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了如何加密 Kubernetes 静态数据后，我们接下来将探讨 Kubernetes 系统之间传输中的机密威胁。
- en: Threats to Secrets in Transit
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输中的机密威胁
- en: After spending time looking at the issues with encrypting data at rest you may
    think that the same issues apply to data in transit. The keys need to be in the
    same place as the data, so why bother?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在花时间研究静态数据加密的问题后，你可能会认为相同的问题也适用于传输中的数据。密钥需要和数据在同一个地方，那么为什么还要费劲呢？
- en: It turns out this isn’t the case. Kubernetes and API driven certificate authorities
    like **JetStack’s** cert-manager make certificate management pretty much non-existent.
    We already deployed cert-manager in the authentication chapter with an internal
    certificate when we tested out pipeline authentication. We deployed cert-manager
    with a private key and a self-signed root certificate that is good for ten years.
    We trust that certificate throughout our cluster and configure our Ingress objects
    to use that internal CA to generate three-month certificates. A combination of
    NGINX and cert-manager make sure that we don’t ever think about renewing certificates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，情况并非如此。像**JetStack**的 cert-manager 这样的 Kubernetes 和 API 驱动的证书颁发机构使得证书管理几乎不存在。在认证章节中，我们已经使用内部证书部署了
    cert-manager，并测试了管道认证。我们部署了 cert-manager，并使用了一个私钥和一个自签名的根证书，该证书有效期为十年。我们在整个集群中信任这个证书，并配置了我们的
    Ingress 对象，以使用这个内部 CA 生成三个月有效期的证书。NGINX 和 cert-manager 的结合确保我们不需要再考虑证书的续期问题。
- en: For intracluster communications, you can use the same approach, or you can deploy
    a service mesh like Istio to generate certificates and provide TLS. We’ll dive
    into this later in the book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集群内部的通信，你可以使用相同的方法，或者部署像 Istio 这样的服务网格来生成证书并提供 TLS。我们将在本书后面深入探讨这一内容。
- en: From an availability standpoint, data in transit is much more ephemeral than
    data at rest. If there is a break in availability due to an expired certificate,
    there are technologies to perform retries that can be used to mitigate this risk.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从可用性的角度来看，传输中的数据比静态数据更加短暂。如果由于证书过期而导致可用性中断，现有技术可以执行重试操作来缓解这一风险。
- en: The point is there’s no reason not to encrypt your data in transit. It’s true
    that the CA and private key are still in the cluster, so a compromised cluster
    leads to decryptable traffic, but the likelihood of availability going down due
    to key rotation is much reduced, making this a much easier decision.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，没理由不对传输中的数据进行加密。虽然 CA 和私钥仍然存在于集群中，因此一旦集群被攻破，流量就可能被解密，但由于密钥轮换，系统的可用性下降的可能性大大降低，这使得这个决策变得更加容易。
- en: If encrypting data in transit increases security, is it compliant? This is where
    we get the opposite of the “data at rest” scenario. From a technical perspective,
    a certificate authority is easy to build. Back before we had cert-manager or Kubernetes,
    I built a simple API-based CA for a customer that wanted to lock down APIs from
    a mobile app using Java and the `openssl` command. Building a compliant CA is
    much harder. It often involves volumes of management and regulations. For this
    reason, while most large enterprises have an internal CA that could be used, you
    can’t use it from within Kubernetes. If your cluster doesn’t match all the rules
    of your CA, it invalidates the compliance of those rules and breaks your compliance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加密传输中的数据能增加安全性，它是否符合合规性要求？这就是与“静态数据”场景相反的地方。从技术角度看，建立一个证书授权机构（CA）是相对简单的。早在我们还没有
    cert-manager 或 Kubernetes 之前，我为一个客户构建了一个基于 API 的 CA，他们希望使用 Java 和 `openssl` 命令来限制移动应用程序访问
    API。构建一个符合合规性的 CA 则要困难得多。它通常涉及大量的管理工作和规定。因此，尽管大多数大型企业拥有可以使用的内部 CA，但你无法在 Kubernetes
    中使用它。如果你的集群不符合 CA 的所有规则，那就会使这些规则的合规性失效，从而破坏合规性。
- en: The compromise that is often struck is for your ingress controller to have a
    wildcard certificate while an internal CA is used for communications within a
    cluster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的妥协方式是让你的入口控制器使用通配符证书，而集群内部通信使用内部 CA。
- en: There is a strong argument that the increase in automation overcomes the introduced
    weakness of an in-cluster key for a CA, but as compliance is often a legal requirement
    those arguments generally fail. This is why it’s so important to understand the
    difference between security and compliance. In these two use cases we’ve shown
    how they conflict and why you need to understand those conflicts to make design
    choices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种强烈的观点认为，自动化的增加克服了集群内 CA 密钥带来的弱点，但由于合规性通常是法律要求，这些观点通常会失败。这也是为什么理解安全性与合规性之间的差异如此重要。在这两个用例中，我们展示了它们如何发生冲突，并且为什么你需要理解这些冲突，以便做出设计决策。
- en: Having walked through how to encrypt secret data in transit, the last scenario
    to explore is secrets when they’re used in your applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 走过如何加密传输中的秘密数据后，最后一个需要探讨的场景是当秘密数据被用于你的应用程序时的情况。
- en: Protecting Secrets in Your Applications
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在应用程序中保护秘密数据
- en: Let’s walk through a potential, and all too common, scenario. You’ve built a
    “secure” cluster. Your secret data is all stored in a well-designed secrets manager.
    You’re following all the guidance on how to manage that data. Every connection
    is encrypted. Your application loads, gets a password, and connects to a database.
    It turns out that two years ago someone found a flaw in your parsing library that
    lets an attacker open a shell on your app and get access to that password and
    since you need to talk to that database they can connect and extract all the data!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍一个潜在的且非常常见的场景。你已经建立了一个“安全”的集群。你的秘密数据全部存储在一个设计良好的秘密管理工具中。你遵循了所有关于如何管理这些数据的指导。每个连接都被加密。你的应用程序加载后，获取密码并连接到数据库。结果发现，两年前有人发现了你解析库中的一个漏洞，攻击者借此漏洞在你的应用上打开了一个
    shell，获取了那个密码，而由于你需要连接到数据库，他们能够连接并提取所有数据！
- en: What went wrong? Going back to the previous two scenarios, we established multiple
    times that you must have the secret in hand to use it. This means that if your
    application has a security flaw, it doesn’t matter how well designed your secrets
    management process is, it becomes the weakest link.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 出了什么问题？回到前面提到的两个场景，我们多次强调过，必须掌握秘密数据才能使用它。这意味着，如果你的应用程序存在安全漏洞，那么无论你的秘密管理过程设计得多么完善，它都将成为最薄弱的环节。
- en: This doesn’t mean we should abandon secrets management. Supply chain security
    is its own focus and one we will cover later in this book. The point is that when
    you consider how to build your secrets management systems and processes, remember
    that your application is probably the easiest place to lose control and you must
    plan accordingly. For instance, adding additional layers that impact automation
    will not likely buy you additional security, but you may push your developers
    into spending time to work around your systems or drive up costs unnecessarily.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们应该放弃秘密管理。供应链安全是一个独立的关注点，我们将在本书稍后讨论。重点是，当你考虑如何构建秘密管理系统和流程时，要记住，应用程序很可能是最容易失控的地方，你必须据此进行规划。例如，增加影响自动化的额外层级可能不会带来额外的安全性，但你可能会迫使开发人员花时间绕过你的系统，或不必要地提高成本。
- en: Now that we’ve walked through how secrets can be attacked, we can explore how
    secrets managers work and look at different strategies for managing secret data
    in your clusters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了秘密如何被攻击，我们可以探讨秘密管理器是如何工作的，并查看在集群中管理秘密数据的不同策略。
- en: Understanding Secrets Managers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解秘密管理器
- en: 'We’ve covered what makes `Secrets` special and how to approach secret data,
    now we need to talk about how to manage them. There are four ways most clusters
    manage `Secrets`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了 `Secrets` 的特殊之处以及如何处理秘密数据，现在需要讨论如何管理它们。大多数集群管理 `Secrets` 的方式有四种：
- en: '**Kubernetes Secrets**: Storing all secrets as `Secret` objects without any
    kind of external management.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes Secrets**：将所有秘密存储为 `Secret` 对象，而无需任何外部管理。'
- en: '**Sealed Secrets**: Secret data is encrypted in files stored in Git.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sealed Secrets**：秘密数据在存储在 Git 中的文件中加密。'
- en: '**External Secrets Manager**: An external service, such as HashiCorp’s Vault
    or a cloud-based secrets manager, is used to store secrets for your cluster.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部秘密管理器**：使用外部服务，如 HashiCorp 的 Vault 或基于云的秘密管理器，来存储你的集群的秘密。'
- en: '**Hybrid**: By syncing secret data from an external secrets manager into generic
    Kubernetes `Secret` objects you get an approach that allows for the `Secrets`
    API while still maintaining your source of truth about secret data outside of
    your cluster.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合模式**：通过将外部秘密管理器中的秘密数据同步到通用的 Kubernetes `Secret` 对象中，你可以获得一种方法，既能使用 `Secrets`
    API，又能保持关于秘密数据的真实来源在集群外部。'
- en: Let’s walk through each approach to managing secrets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讲解管理秘密的每种方法。
- en: Storing Secrets as Secret Objects
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将秘密存储为 Secret 对象
- en: 'The first option seems like the easiest. Leveraging Kubernetes `Secret` objects
    provides several benefits:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项看起来是最简单的。利用 Kubernetes `Secret` 对象提供了几个好处：
- en: There’s a standard API for accessing `Secret` objects.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 `Secret` 对象有一个标准 API。
- en: The API can be restricted via RBAC, mostly.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 大部分可以通过 RBAC 进行限制。
- en: There are multiple ways for containers to access `Secret` objects without having
    to make API calls.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器有多种方式可以访问 `Secret` 对象，而无需进行 API 调用。
- en: The last two points can be a double-edged sword. When Kubernetes was first created,
    one of the goals was to allow application developers to run a workload on Kubernetes
    without the application knowing anything about Kubernetes. This meant that having
    a standard `Secret` API was less important than having an easy way for applications
    to access the secret data. To this end, Kubernetes made the easiest path to accessing
    secret data either mounting the secrets as virtual files in the container or setting
    them as environment variables. We’ll discuss the benefits and risks of both approaches
    later in this chapter. The impact of this design decision is that while you can
    limit who can access a `Secret` via an API using RBAC, you can’t limit who can
    mount a `Secret` into a pod within a `Namespace`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点可能是把双刃剑。当 Kubernetes 最初创建时，其中一个目标是让应用程序开发者能够在 Kubernetes 上运行工作负载，而无需应用程序了解任何
    Kubernetes 相关的内容。这意味着，拥有一个标准的 `Secret` API 比提供应用程序访问秘密数据的简便方式要次要。为此，Kubernetes
    提供了最简单的方式来访问秘密数据，即将秘密挂载为容器中的虚拟文件，或将它们设置为环境变量。我们将在本章稍后讨论这两种方法的优缺点。这一设计决策的影响是，虽然你可以通过使用
    RBAC 限制谁可以通过 API 访问 `Secret`，但你无法限制谁可以将 `Secret` 挂载到 `Namespace` 内的 Pod 中。
- en: This point been said previously in this book and will be repeated often. The
    `Namespace` is the security boundary in Kubernetes. If you want to limit access
    to specific `Secrets` within a `Namespace`, it’s time to create a new `Namespace`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中之前已经提到过这一点，并且会经常重复。`Namespace` 是 Kubernetes 中的安全边界。如果你想限制对特定 `Secrets` 的访问，就该创建一个新的
    `Namespace`。
- en: 'In April 2022, Mac Chaffee wrote a great blog post titled *Plain Kubernetes
    Secrets are fine* ([https://www.macchaffee.com/blog/2022/k8s-secrets/](https://www.macchaffee.com/blog/2022/k8s-secrets/))
    where he gave a great summary of why, from a security standpoint, it’s OK to use
    plain Kubernetes `Secrets`. The blog post points out that you need to model the
    threats to your secret data before assuming a path forward for securing them.
    You may recognize many of the same arguments from this blog post in the previous
    section. Mac did a better job of articulating what I always thought to be true,
    and I really enjoyed his approach. The “too long, didn’t read” of the post is:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年4月，Mac Chaffee写了一篇很棒的博客文章，标题为*Plain Kubernetes Secrets are fine*（[https://www.macchaffee.com/blog/2022/k8s-secrets/](https://www.macchaffee.com/blog/2022/k8s-secrets/)），他很好地总结了从安全角度来看，使用普通Kubernetes
    `Secrets`是可以的。这篇博客文章指出，在决定如何保护秘密数据之前，你需要先评估这些数据可能面临的威胁。你可能会在这篇博客文章中看到上一部分的很多相同论点。Mac在表达我一直认为正确的观点时做得更好，我真的很喜欢他的处理方式。文章的“简短总结”是：
- en: Secret managers, like **Vault**, are rarely deployed in a way that adds any
    additional security over any other key/value database.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像**Vault**这样的秘密管理器，通常并不会以一种能增加额外安全性的方式部署，这和其他任何键/值数据库没有区别。
- en: Encrypting secrets at rest doesn’t accomplish anything.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对秘密进行静态加密并不能解决任何问题。
- en: Your application is the most likely spot where you’ll lose a secret.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序是最有可能丢失秘密的地方。
- en: 'If a Kubernetes `Secret` is fine, why are we bothering with secrets managers
    at all? There are two reasons: compliance and **GitOps**.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Kubernetes `Secret`已经足够好，为什么我们还要使用秘密管理器呢？这里有两个原因：合规性和**GitOps**。
- en: From a compliance perspective, most compliance frameworks require that you not
    only know when secret data changes, but also when it’s used. For instance, **NIST-800-53**
    requires that you continuously monitor the usage of credentials (which makes up
    the bulk of secret data). While you could set up logging in Kubernetes to track
    this, it makes it much easier to audit by having it in a central location.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从合规性角度来看，大多数合规框架要求你不仅要知道秘密数据何时发生变化，还要知道它何时被使用。例如，**NIST-800-53**要求你持续监控凭证的使用情况（凭证构成了大部分秘密数据）。虽然你可以在Kubernetes中设置日志记录来追踪这一点，但将其集中在一个地方进行审计会更方便。
- en: The next reason why we should evaluate a secrets manager is **GitOps**. In the
    last two chapters, we’re going to explore GitOps, a large part of which is storing
    our configuration in a Git repository. You should never, ever, EVER, **EVER**,
    **EVER** store secret data in a Git repository either in plain text or as encrypted
    data. Git repositories are designed to be easily forked. Once forked, you’ve lost
    control of that repository. Going back to compliance, this is a big risk as you
    have no way of knowing if a developer forked your internal repository and accidentally
    pushed it to a public GitHub repository. There are other reasons why keeping secrets
    in Git should be considered an anti-pattern, but we’ll cover that when we talk
    about sealed secrets. Using a secrets manager allows us to externalize our secret
    data from our cluster, even though `Secret` objects are most likely fine for most
    clusters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该评估秘密管理器的下一个原因是**GitOps**。在接下来的两章中，我们将探讨GitOps，其中一个重要部分是将我们的配置存储在Git仓库中。你绝对不应该，也**绝对**不能将秘密数据存储在Git仓库中，无论是以明文形式还是加密数据的形式。Git仓库设计上容易被分叉。一旦被分叉，你就失去了对该仓库的控制。回到合规性，这带来了一个大风险，因为你无法知道是否有开发人员将你的内部仓库分叉并不小心推送到了公开的GitHub仓库中。还有其他原因表明在Git中存储秘密应该被视为反模式，但我们会在讨论密封秘密时再深入探讨。使用秘密管理器使我们能够将秘密数据从集群中外部化，尽管`Secret`对象对于大多数集群来说可能已经足够。
- en: Having looked at why regular Kubernetes `Secrets` are usually fine from a security
    standpoint, let’s look at what sealed secrets are and why they’re an anti-pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了为什么从安全角度来看常规的Kubernetes `Secrets`通常是可以的，现在让我们来看看什么是密封秘密以及为什么它们是反模式。
- en: Sealed Secrets
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密封秘密
- en: If you are externalizing your Kubernets manifests into a Git repository, you
    may be tempted to store sensitive secret data there too. You don’t want anyone
    to get that data though, so you decide to encrypt it. Now, however, you need to
    decrypt it to get it back into your clusters. Bitnami (now owned by VMware) released
    a tool called **Sealed Secrets** ([https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets))
    that does just this. You install the operator into your cluster and when it sees
    a `SealedSecret`, it decrypts it for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 Kubernetes 清单外部化到 Git 仓库中，你可能会想要将敏感的秘密数据也存储在那里。不过，你不希望任何人获取这些数据，于是你决定加密它。然而，现在你需要解密它，以便将其重新导入到集群中。Bitnami（现为
    VMware 所拥有）发布了一款名为 **Sealed Secrets** 的工具（[https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets)），它正是为了解决这个问题。你可以将操作员安装到集群中，当它看到一个
    `SealedSecret` 时，它会为你解密它。
- en: This seems like a simple and elegant solution for externalizing secret data
    securely. Unfortunately, its apparent simplicity is what leads to this solution
    being an anti-pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是一个简单而优雅的解决方案，用于安全地外部化敏感数据。不幸的是，它表面上的简洁性正是导致这个解决方案成为反模式的原因。
- en: 'The first issue with Sealed Secrets is that secret data is stored in Git. We
    pointed out in the previous section that this is a bad idea from a security perspective.
    One of the main goals of secrets management is being able to track the usage of
    secrets. It’s incredibly easy for a developer to push an internal repository to
    a public service like GitHub or GitLab. Take this simple command line:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Sealed Secrets 的第一个问题是敏感数据存储在 Git 中。我们在前一节中已经指出，从安全的角度来看，这个做法是一个坏主意。秘密管理的主要目标之一是能够追踪秘密的使用情况。开发者很容易将一个内部仓库推送到
    GitHub 或 GitLab 等公共服务上。看看这个简单的命令行：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So long as the user is signed into GitHub, your internal repo is now public!
    In theory you could limit access to public Git repositories, but that would probably
    be counterproductive. My general advice is never put something in Git that you
    wouldn’t want on GitHub. Once the code is on GitHub, or any other remote repository,
    you’ve lost all control.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只要用户登录了 GitHub，你的内部仓库现在就是公开的！理论上，你可以限制对公共 Git 仓库的访问，但那可能适得其反。我的一般建议是，永远不要将你不希望出现在
    GitHub 上的内容放入 Git。一旦代码被推送到 GitHub 或任何其他远程仓库，你就失去了所有控制权。
- en: 'Your first response to this issue of pushing to public repositories may be:
    “But it’s encrypted!” As a species, we’re bad at keeping secrets. As an industry,
    we’re very bad at protecting the keys used to encrypt secrets. If you’ve lost
    the repository, there’s a good chance you’ll also lose the keys.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 针对将数据推送到公共仓库这个问题，你的第一反应可能是：“但它是加密的！”作为一个物种，我们很不擅长保守秘密。作为一个行业，我们更不擅长保护用来加密秘密的密钥。如果你丢失了仓库，很有可能你也会丢失密钥。
- en: Three may keep a secret, if two are dead – Benjamin Franklin
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “三个人可以保守一个秘密，前提是其中两个已经死了。”——本杰明·富兰克林
- en: 'This isn’t just true in the Kubernetes world, but really any technology. This
    is why it’s so important to plan for losing secrets and being able to quickly
    change them. If your Git repository with secrets, whether encrypted or not, were
    to be pushed outside of your enterprise, you’d want to:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅在 Kubernetes 世界中成立，实际上在任何技术领域都是如此。这就是为什么计划好如何应对丢失敏感数据，并能够快速更换它们是如此重要的原因。如果你的
    Git 仓库包含敏感数据（无论是否加密），并且它被推送到了你公司外部，你会希望：
- en: Go through all of the Sealed Secrets and generate new secret data (i.e. credentials).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有 Sealed Secrets 进行操作并生成新的秘密数据（即凭证）。
- en: Generate a new encryption key.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个新的加密密钥。
- en: Re-encrypt and re-post all of the Sealed Secrets to Git.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加密并重新推送所有 Sealed Secrets 到 Git。
- en: Depending on the size of your clusters and how well you manage your keys this
    could become a monumental task very quickly. It turns out a secret manager is
    pretty good at handling this failure mode.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的集群大小以及密钥管理的情况，这可能会很快变成一项艰巨的任务。事实证明，秘密管理工具在处理这种失败模式时表现得非常出色。
- en: In addition to being able to handle the failure mode of losing your repository,
    you need to account for losing the keys used to encrypt and decrypt your secrets.
    If you lose the key used to encrypt the secrets and lose the secrets…suffice it
    to say that you’re setting yourself up for a bad week, or what some call a *resume-building
    event*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够处理丢失仓库的失败模式之外，你还需要考虑丢失用来加密和解密敏感数据的密钥。如果你丢失了用来加密秘密的密钥，并且丢失了秘密…可以说，你正为一个糟糕的一周做准备，或者某些人所称的*简历建设事件*。
- en: While Sealed Secrets appears to be a simple way to handle secrets management,
    they fail to account for failure in a way that would be acceptable in the aftermath
    of most breaches. While you wouldn’t want to store your secret data in Git, it
    is acceptable to store metadata about secrets in Git. We’ll see in the next section
    that secret managers can be integrated into your cluster using metadata that describes
    where to get secret data without having any secrets in the repository.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Sealed Secrets 看起来是处理密钥管理的一种简单方式，但它们在应对大多数安全漏洞后的失败时没有考虑到可接受的处理方式。虽然你不希望将机密数据存储在
    Git 中，但将有关机密的元数据存储在 Git 中是可以接受的。我们将在下一节中看到，密钥管理器可以通过描述获取密钥数据位置的元数据集成到你的集群中，而无需在存储库中存储任何机密。
- en: External Secrets Managers
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部密钥管理器
- en: In the last section we discussed why storing `Secrets` in Git, whether encrypted
    or not, is an antipattern. We also discussed that you may want to externalize
    your secret data management to make compliance and **GitOps** easier. The most
    common approach to satisfying these requirements is a secrets manager.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了为什么将 `Secrets` 存储在 Git 中，无论是加密还是未加密，都是一种反模式。我们还讨论了，你可能希望将密钥数据管理外部化，以便使合规性和
    **GitOps** 更加简便。满足这些要求的最常见方法是使用密钥管理器。
- en: 'Secrets managers are key/value databases that have some additional features
    not often found in generic key/value databases:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥管理器是键值数据库，具有一些通用键值数据库中通常没有的附加功能：
- en: '**Authentication**: Secrets managers can generally authenticate with multiple
    methods. The best solutions allow you to use either your Pod’s credentials directly
    or using a credential derived from it. This allows your secret manager to track
    which workloads are working with secret data and provide richer policies for managing
    access to that data.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：密钥管理器通常可以使用多种方法进行认证。最佳解决方案允许你直接使用 Pod 的凭证或使用从中派生的凭证。这使得密钥管理器能够跟踪哪些工作负载正在处理机密数据，并为管理对这些数据的访问提供更丰富的策略。'
- en: '**Policies**: Most secret managers provide a richer policy framework than generic
    databases. When combined with flexible authentication, options for the secrets
    manager can help lock down secrets to the workload while also tracking usage without
    an administrator getting involved with each onboarding.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：大多数密钥管理器提供比通用数据库更丰富的策略框架。结合灵活的认证，密钥管理器的选项可以帮助将密钥锁定到工作负载，同时跟踪使用情况，而无需管理员参与每次的入驻过程。'
- en: '**Auditing**: In addition to tracking changes, secrets managers track reads
    as well. This is a key compliance requirement.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：除了跟踪更改外，密钥管理器还会跟踪读取操作。这是一个关键的合规性要求。'
- en: The authentication tools for secrets managers are important. It doesn’t really
    add much to your security or your compliance if you’re using a generic credential
    to access your secrets manager. Back in *Chapter 6*, *Integrating Authentication
    into Your Cluster*, we discussed how each pod gets a unique identity based on
    their `ServiceAccount` and how that `ServiceAccount` can be validated either by
    using the cluster’s OIDC discovery document or by submitting a `TokenReview` to
    validate that the token is still valid. This token should be used when communicating
    with your secret manager. If you’re running on a cloud-managed Kubernetes, this
    can also be an identity supplied by your cloud. The point is, you’re using a local
    identity, not a static key. This local identity is what shows up in your audit
    logs, allowing your security team and auditors to know who is accessing secrets.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥管理器的认证工具非常重要。如果你使用通用凭证来访问密钥管理器，它实际上并不会增加太多的安全性或合规性。在*第六章*，*将认证集成到集群中*，我们讨论了每个
    pod 如何根据其 `ServiceAccount` 获取唯一的身份，并且如何通过使用集群的 OIDC 发现文档或提交 `TokenReview` 来验证该
    token 是否仍然有效。当与密钥管理器进行通信时，应该使用此 token。如果你在云托管的 Kubernetes 上运行，这个身份也可以是云提供的身份。关键是，你使用的是本地身份，而不是静态密钥。这个本地身份会出现在你的审计日志中，允许你的安全团队和审计员知道是谁在访问密钥。
- en: Finally, utilizing your `Pod`'s identity to access your secrets manager makes
    onboarding and automation easier. We’ll look at multiple forms of multitenancy
    later in the book, which all have automation in common. Most secrets managers
    make it easier to design policies that allow for segmenting secrets access based
    on information in the authentication token, such as the `namespace`. This means
    you don’t need to make API calls to your secrets manager whenever you onboard
    a new tenant.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，利用你的`Pod`身份来访问秘密管理工具，使得上手和自动化更为简便。我们将在本书稍后讨论多租户的多种形式，这些形式都具备自动化的共同点。大多数秘密管理工具都简化了设计策略的过程，这些策略允许根据身份验证令牌中的信息（如`namespace`）来划分秘密访问权限。这意味着在为新租户引导时，你不需要每次都向秘密管理工具发出API请求。
- en: 'There are several secrets managers available; every major cloud has its own
    offering and there are several open-source managers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个秘密管理工具可用；每个主要云服务商都有自己的解决方案，并且有多个开源管理工具：
- en: '**HashiCorp Vault**: [https://github.com/hashicorp/vault](https://github.com/hashicorp/vault)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HashiCorp Vault**: [https://github.com/hashicorp/vault](https://github.com/hashicorp/vault)'
- en: '**CyberArk Conjur**: [https://github.com/cyberark/conjur](https://github.com/cyberark/conjur)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CyberArk Conjur**: [https://github.com/cyberark/conjur](https://github.com/cyberark/conjur)'
- en: '**VMware Tanzu Secrets Manager**: [https://github.com/vmware-tanzu/secrets-manager](https://github.com/vmware-tanzu/secrets-manager)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMware Tanzu Secrets Manager**: [https://github.com/vmware-tanzu/secrets-manager](https://github.com/vmware-tanzu/secrets-manager)'
- en: We don’t want you to have to sign up for a cloud service, so for the examples
    in this chapter (and whenever we need secrets for the rest of the book), we’ll
    use HashiCorp’s Vault.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望你必须注册云服务，因此在本章的示例中（以及本书其余部分需要秘密时），我们将使用HashiCorp的Vault。
- en: In August, 2023, HashiCorp announced a change of license for its projects, including
    **Vault**, from the **Mozilla Public License** (**MPL**) to the **Business Source
    License** (**BUSL**). While the BUSL is not an approved Open Source™ license from
    the Open Source Institute, it does allow for free use in both production and non-production
    environments. We decided to continue with Vault because even though the community
    around HashiCorp’s projects is making calls for forks or moves, enterprises have
    invested hundreds of thousands of dollars between software, people, and automation
    for Vault deployments. It’s still the most common secrets manager and likely will
    be for some time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 2023年8月，HashiCorp宣布其项目，包括**Vault**，的许可变更，从**Mozilla公共许可证**（**MPL**）变更为**商业源代码许可证**（**BUSL**）。虽然BUSL并不是开放源代码协会（Open
    Source Institute）认可的开放源代码™许可证，但它允许在生产环境和非生产环境中免费使用。我们决定继续使用Vault，因为尽管HashiCorp项目的社区提出了分叉或转移的呼声，但企业已经在软件、人员和自动化方面为Vault部署投入了数十万美元。它仍然是最常见的秘密管理工具，且可能会持续一段时间。
- en: 'To deploy Vault, start with a fresh cluster and run the `chapter8/vault/deploy_vault.sh`
    script:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署Vault，请从一个新的集群开始，并运行`chapter8/vault/deploy_vault.sh`脚本：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This script deploys vault into your cluster by:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本通过以下方式将Vault部署到集群中：
- en: Deploying cert-manager with a self-signed CA for ingress certificates
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署带有自签名CA的cert-manager用于入口证书
- en: Installing the **Vault Helm chart**
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**Vault Helm图表**
- en: Deploying Vault into the cluster with the UI and with `ClusterIP` `Service`
    objects
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用UI和`ClusterIP` `Service`对象将Vault部署到集群中
- en: Retrieving the keys used to unseal the Vault database
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索用于解封Vault数据库的密钥
- en: Unsealing the Vault database
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解封Vault数据库
- en: Deploying `Ingress` objects you can access the UI and web services via NGINX
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署`Ingress`对象后，你可以通过NGINX访问UI和Web服务
- en: 'Vault encrypts its data, so when you start the pod you need to “unseal” it
    so it can be managed. You can log in to your Vault instance by first retrieving
    the token from the `~/unseal-keys.json` file generated by the deployment:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Vault加密其数据，因此当你启动Pod时，需要“解封”它以便管理。你可以通过先从部署生成的`~/unseal-keys.json`文件中检索令牌，登录到你的Vault实例：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, use this token to log in to Vault by going to [https://vault.apps.IP.nip.io](https://vault.apps.IP.nip.io),
    where `IP` is the IP address of your Kubernetes cluster with dashes instead of
    dots. For instance, our cluster is at `192.168.2.82` so our Vault URL is [https://vault.apps.192-168-2-82.nip.io/](https://vault.apps.192-168-2-82.nip.io/).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用此令牌通过访问[https://vault.apps.IP.nip.io](https://vault.apps.IP.nip.io)登录Vault，其中`IP`是你的Kubernetes集群的IP地址，点被替换为连字符。例如，我们的集群的IP是`192.168.2.82`，因此我们的Vault
    URL是[https://vault.apps.192-168-2-82.nip.io/](https://vault.apps.192-168-2-82.nip.io/)。
- en: We’re not going to dig too deeply into how Vault is configured outside of specific
    examples to illustrate how to integrate an external secrets manager into your
    cluster. If you want to go through all its options, the documentation is available
    online at [https://developer.hashicorp.com/vault/docs](https://developer.hashicorp.com/vault/docs).
    It’s also important to point out that this isn’t a production-capable deployment
    either, since it’s not highly available nor are there any processes built around
    starting and managing onboarding.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论Vault如何配置，除了一些具体的例子来说明如何将外部的密钥管理器集成到你的集群中。如果你想了解所有选项，可以在线查看文档：[https://developer.hashicorp.com/vault/docs](https://developer.hashicorp.com/vault/docs)。同时也需要指出，这并不是一个适用于生产的部署，因为它没有高可用性，也没有围绕启动和管理入驻流程的任何机制。
- en: 'With our Vault deployed, the next step is to integrate Vault into our cluster.
    Earlier, we discussed that it’s important to use the `Pod`''s identity to interact
    with your secrets manager. We’ll do that with Vault by configuring Vault to submit
    a `TokenReview` to our cluster to validate that the token was issued by our cluster
    and that the pod that the identity is tied to is still running:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Vault后，下一步是将Vault集成到我们的集群中。之前我们讨论过，使用`Pod`的身份与密钥管理器交互是很重要的。我们将通过配置Vault来提交`TokenReview`，以验证令牌是否由我们的集群颁发，并且与该身份关联的Pod是否仍然运行。
- en: '![Diagram  Description automatically generated](img/B21165_08_01.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图示说明自动生成](img/B21165_08_01.png)'
- en: 'Figure 8.1: Vault integration with Kubernetes'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：Vault与Kubernetes的集成。
- en: 'The above diagram shows the flow:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了流程：
- en: A pod makes a request to the Vault API using its `ServiceAccount` token projected
    via the `TokenRequest` API
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Pod使用其通过`TokenRequest` API投射的`ServiceAccount`令牌向Vault API发出请求。
- en: Vault submits a `TokenReview` request to the API server with the `Pod's` token
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vault向API服务器提交`TokenReview`请求，携带`Pod`的令牌。
- en: The API server validates whether the token is still valid or not.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API服务器验证令牌是否仍然有效。
- en: Using the above process gives us the ability to validate a `Pod's` token, getting
    confidence that the pod it’s assigned to is still valid. If an attacker were to
    exfiltrate a Pod’s token and attempt to use it after the Pod’s been destroyed,
    then `TokenReview` will be rejected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述过程使我们能够验证`Pod`的令牌，从而确认与该令牌关联的Pod仍然有效。如果攻击者窃取了Pod的令牌并试图在Pod被销毁后使用它，那么`TokenReview`请求将被拒绝。
- en: In addition to using the `TokenReview` API, Vault can be configured to use OIDC
    to validate tokens without a callback to the API server. We aren’t going down
    this route because we want Vault to validate that the pod associated with the
    token is still valid.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`TokenReview` API外，Vault还可以配置为使用OIDC来验证令牌，而无需回调API服务器。我们不会走这条路，因为我们希望Vault验证与令牌关联的Pod是否仍然有效。
- en: 'To integrate our Vault into our cluster, run `chapter8/vault/vault_integrate_cluster.sh`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Vault集成到我们的集群中，运行`chapter8/vault/vault_integrate_cluster.sh`：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This script will integrate your Vault deployment with the KinD cluster by:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将通过以下方式将你的Vault部署与KinD集群集成：
- en: Creating the `vault-integration` `namespace` and the `vault-client ServiceAccount`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`vault-integration`命名空间和`vault-client ServiceAccount`。
- en: Creating a `ClusterRoleBinding` for the `vault-client ServiceAccount` to the
    `system:auth-delegator ClusterRole`
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`vault-client ServiceAccount`创建一个`ClusterRoleBinding`，将其绑定到`system:auth-delegator
    ClusterRole`。
- en: Creating a token for the vault-client `ServiceAccount` that’s good for about
    a year
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`vault-client`的`ServiceAccount`创建一个大约有效一年期的令牌。
- en: Creating an `Ingress` for our API server so that Vault can communicate with
    it
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的API服务器创建一个`Ingress`，使Vault能够与其通信。
- en: Creating a Vault Kubernetes authentication configuration with our cluster
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建与我们集群的Vault Kubernetes认证配置。
- en: The Vault deployment is being treated as a stand-alone deployment, even though
    it’s running on our cluster because Vault is often run this way in enterprise
    deployments. Vault is a complex system that requires highly specialized knowledge
    to run, so it’s much easier to centralize Vault knowledge into a centralized team.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Vault的部署被视为独立部署，尽管它运行在我们的集群上，因为Vault在企业部署中通常是这样运行的。Vault是一个复杂的系统，运行它需要高度专业的知识，因此将Vault知识集中到一个集中团队中会更容易。
- en: You might also notice that we’re creating a token for Vault to use to interact
    with your cluster that’s good for a year. This violates our goal of using short-lived
    tokens. This is a chicken-and-egg problem, because Vault needs to authenticate
    to Kubernetes in order to validate the token. The cluster could be configured
    to allow anonymous `TokenReview` access, which would leave it opened to potential
    escalation attacks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，我们正在为 Vault 创建一个有效期为一年的令牌，用来与集群进行交互。这违反了我们使用短期令牌的目标。这是一个先有鸡还是先有蛋的问题，因为
    Vault 需要对 Kubernetes 进行身份验证才能验证令牌。集群可以配置为允许匿名的 `TokenReview` 访问，这样就可能暴露于潜在的升级攻击中。
- en: It would be great if Vault supported using its own OIDC tokens to talk to Kubernetes
    like a workload we defined in *Chapter 6*, *Integrating Authentication into Your
    Cluster*, but that’s not a capability at this time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Vault 支持像我们在 *第6章*《将身份验证集成到您的集群》中定义的工作负载那样，使用它自己的 OIDC 令牌与 Kubernetes 进行通信，那就太好了，但目前还不具备这样的能力。
- en: We’ve covered what makes an external secrets manager different than other key/value
    stores and deployed HashiCorp’s vault. Vault’s been deployed and integrated into
    the cluster. You now have a foundation for working with externalized secrets and
    exploring the different ways to integrate that foundation into your cluster. Next,
    we’ll cover a hybrid approach between using an external secrets manager and native
    Kubernetes `Secrets`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了外部机密管理器与其他键值存储的不同，并部署了 HashiCorp 的 Vault。Vault 已经部署并集成到集群中。现在你已经建立了一个与外部化机密数据工作并探索将其集成到集群的不同方式的基础。接下来，我们将讨论使用外部机密管理器和原生
    Kubernetes `Secrets` 的混合方法。
- en: Using a Hybrid of External Secrets Management and Secret Objects
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用外部机密管理和机密对象的混合方式
- en: So far, we have covered the use of generic Kubernetes `Secret` objects, the
    antipattern of storing secret data in encrypted files in git, and finally using
    an external secrets manager. Since we’ve already established that plain Kubernetes
    `Secrets` are likely not a substantial risk based on our threat model, but we
    prefer to externalize secrets into a tool like Vault, it would be great if we
    could use the Kubernetes `Secrets` API to access secret data in external vaults.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了使用通用 Kubernetes `Secret` 对象、将机密数据存储在 Git 中的加密文件中的反模式，以及最终使用外部机密管理器。由于我们已经确定基于我们的威胁模型，普通的
    Kubernetes `Secrets` 不太可能构成重大风险，但我们更倾向于将机密外部化到像 Vault 这样的工具中，因此，如果我们能使用 Kubernetes
    `Secrets` API 来访问外部保管库中的机密数据，那就太好了。
- en: 'The use of the `Secret` API to access external secret data is unlikely to ever
    happen. However, we can synchronize secret data from our Vault into Kubernetes
    `Secret` objects. This hybrid approach allows us to get the best of both approaches:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Secret` API 访问外部机密数据不太可能发生。然而，我们可以将机密数据从我们的 Vault 同步到 Kubernetes `Secret`
    对象中。这种混合方法使我们能够结合两者的优点：
- en: '**Centralized secret data**: The source of truth for our secret data is our
    vault. The data in the `Secret` object is a replica of that data.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中化的机密数据**：我们机密数据的真实来源是我们的 Vault。`Secret` 对象中的数据是该数据的副本。'
- en: '**Metadata can be stored in git**: The metadata that’s used to describe where
    the secret data is stored is not itself secret. It can be stored in Git without
    the same adverse consequences of storing the actual secrets in Git.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据可以存储在 Git 中**：用于描述机密数据存储位置的元数据本身并不是机密的。它可以存储在 Git 中，而不会像存储实际的机密数据那样带来负面后果。'
- en: '**Audit Data**: The access audit logs can be configured in both the API server’s
    access logs and the vault’s access logs.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计数据**：可以在 API 服务器的访问日志和 Vault 的访问日志中配置访问审计日志。'
- en: 'There are multiple projects that support synchronizing secrets from a vault
    into Kubernetes. The two that come up the most are:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个项目支持将机密从保管库同步到 Kubernetes。最常见的两个项目是：
- en: '**Kubernetes Secret Store CSI Driver** [(https://secrets-store-csi-driver.sigs.k8s.io/introduction](https://secrets-store-csi-driver.sigs.k8s.io/introduction)):
    The Secret Store CSI driver is a **special interest group** (**SIG**) in the Kubernetes
    project provides a storage driver for accessing secret stores such as Vault. It
    includes a synchronization engine that will generate generic `Secret` objects.
    The main challenge of using this project is that before you can synchronize from
    a vault into a `Secret`, you need to mount it a pod.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes Secret Store CSI Driver** [(https://secrets-store-csi-driver.sigs.k8s.io/introduction](https://secrets-store-csi-driver.sigs.k8s.io/introduction))：Secret
    Store CSI驱动程序是Kubernetes项目中的**特别兴趣小组**（**SIG**），为访问Vault等密钥存储提供存储驱动程序。它包括一个同步引擎，将生成通用的`Secret`对象。使用这个项目的主要挑战是，在你能够将Vault中的数据同步到`Secret`之前，需要先将其挂载到Pod。  '
- en: '**External Secrets Operator** ([https://external-secrets.io/latest/](https://external-secrets.io/latest/)):
    The External Secrets Operator project provides a direct synchronization of secret
    data into `Secret` objects.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部密钥操作员** ([https://external-secrets.io/latest/](https://external-secrets.io/latest/))：外部密钥操作员项目提供将密钥数据直接同步到`Secret`对象。  '
- en: 'This section will focus on using the **External Secrets Operator** project.
    We chose to use External Secrets Operator because it doesn’t require a pod to
    first mount the secret data before synchronizing it into a `Secret`. First, deploy
    the synchronization operator:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '本节将重点介绍如何使用**外部密钥操作员**项目。我们选择使用外部密钥操作员，因为它不要求Pod在同步到`Secret`之前先挂载密钥数据。首先，部署同步操作员：  '
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The above script does several things:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '上述脚本完成了以下几件事情：  '
- en: Deploys **External Secrets Operator**
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '部署**外部密钥操作员**  '
- en: Creates a `Namespace` to store the synchronized Secret object
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个`Namespace`来存储同步后的Secret对象  '
- en: Creates a `ServiceAccount` to access Vault
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个`ServiceAccount`来访问Vault  '
- en: Creates a secret password in Vault
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vault中创建一个密钥密码
- en: Creates a policy in Vault to access the secret with the above `ServiceAccount`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在Vault中创建一个策略，以通过上述`ServiceAccount`访问密钥  '
- en: Creates a `ExternalSecret` object to tell the operator where and how to synchronize
    our secret data into our cluster
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个`ExternalSecret`对象，告诉操作员在哪里以及如何将我们的密钥数据同步到集群中  '
- en: 'There’s quite a bit going on here. The operator itself is deployed via a Helm
    chart. The `namespace` where we keep the `Secret` and its associated `ServiceAccount`
    builds off of our Vault integration to allow pods to use a specific identity instead
    of using a static `ServiceAccount''s` token. After creating the `Namespace` and
    `ServiceAccount`, a Vault policy is created to allow the `ServiceAccount` to read
    the secret data. Finally, a `SecretStore` and `ExternalSecret` object is created
    to tell the operator how to synchronize the secret data. Let’s take a look at
    these objects. First, we created the `SecretStore` to tell the operator where
    the Vault is and how to access it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有很多操作。操作员本身是通过Helm chart部署的。我们用来存储`Secret`及其相关`ServiceAccount`的`namespace`基于Vault集成构建，允许Pod使用特定的身份，而不是使用静态的`ServiceAccount`令牌。在创建了`Namespace`和`ServiceAccount`之后，会创建Vault策略，允许`ServiceAccount`读取密钥数据。最后，创建一个`SecretStore`和`ExternalSecret`对象，告诉操作员如何同步密钥数据。接下来，我们来看一下这些对象。首先，我们创建了`SecretStore`，告诉操作员Vault的位置以及如何访问它：  '
- en: '[PRE7]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first object, `SecretStore`, tells **External Secrets Operator** where the
    secrets are stored and how to access them. In this case, we’re connecting to Vault
    using the URL `https://vault.apps.192-168-2-82.nip.io` using the certificate stored
    in the `cacerts` `ConfigMap` to trust for TLS. The `auth` section tells the operator
    how to authenticate, using a token for the `ServiceAccount ext-secret-vault`.
    With the `SecretStore` defined, the next step is to begin defining what `Secret`
    objects need to be created.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个对象`SecretStore`告诉**外部密钥操作员**密钥存储的位置以及如何访问它。在这种情况下，我们通过URL `https://vault.apps.192-168-2-82.nip.io`连接到Vault，并使用存储在`cacerts`
    `ConfigMap`中的证书来进行TLS信任。`auth`部分告诉操作员如何进行身份验证，使用`ServiceAccount ext-secret-vault`的令牌。定义了`SecretStore`后，下一步是开始定义需要创建的`Secret`对象。  '
- en: 'In order to synchronize secret data into `Secret` objects, there needs to be
    an `ExternalSecret` object:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '为了将密钥数据同步到`Secret`对象，需要有一个`ExternalSecret`对象：  '
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ExternalSecret` object defines how to synchronize data from your vault
    into your cluster. Here, the data is being pulled from the `SecretStore` that
    was created to communicate with the Vault deployment. This object tells **External
    Secrets Operator** to create the `somepassword` key on the `Secret secret-to-be-created`
    from the `/data/extsecret/config` object in Vault, getting the value from the
    `some-password` property.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalSecret`对象定义了如何将数据从Vault同步到你的集群。在这里，数据是从与Vault部署通信的`SecretStore`中提取的。该对象指示**External
    Secrets Operator**从Vault中的`/data/extsecret/config`对象中获取值，并在`Secret secret-to-be-created`中创建`somepassword`密钥，该值来自`some-password`属性。'
- en: 'To give some context, here’s the Vault configuration from the script:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一些背景信息，以下是脚本中的Vault配置：
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the synchronization process runs, we see that there’s now data from Vault
    in our `Secret`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦同步过程运行，我们可以看到现在在我们的`Secret`中有来自Vault的数据：
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Given the approach provided by the **External Secrets Operator** project, metadata
    for where and how to access secret data can be created and stored in a git repository
    without adverse security impacts. Clusters are able to access secrets using the
    well-defined `Secrets` API while still getting the benefits of externalizing their
    secret data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 基于**External Secrets Operator**项目提供的方法，可以在git仓库中创建和存储访问机密数据的元数据，而不会对安全性产生不利影响。集群能够使用定义良好的`Secrets`
    API访问机密，同时仍能享受将机密数据外部化的好处。
- en: In the next section, we’re going to take the secret data that is now available
    in our cluster and look at how to consume that data from workloads.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看如何从工作负载中使用现在在集群中可用的机密数据。
- en: Integrating Secrets into Your Deployments
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将机密集成到你的部署中
- en: So far, this chapter has been focused on how to store and manage secret data.
    We’ve covered different strategies for managing secrets with their associated
    risks and benefits. In this section, the focus will be on consuming that secret
    data in your workloads.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章重点讨论了如何存储和管理机密数据。我们已经介绍了管理机密的不同策略及其相关的风险和收益。本节将重点讨论如何在工作负载中使用这些机密数据。
- en: 'There are four ways that a workload can consume secret data:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载有四种方式可以消耗机密数据：
- en: '**Volume mounts**: Similar to reading a file from a `PersistentVolumeClaim`,
    secrets can be mounted to a pod and be accessed as a file. This approach can be
    used with both external secrets and with `Secret` objects. This is generally the
    preferred approach when working with security teams. If a `Secret` is updated
    while a pod is running, the volume will eventually get updated, though this can
    take some time based on your Kubernetes distribution.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷挂载**：与从`PersistentVolumeClaim`读取文件类似，机密可以挂载到Pod中并作为文件访问。此方法可以用于外部机密和`Secret`对象。当与安全团队合作时，这通常是首选方法。如果在Pod运行时更新了`Secret`，该卷最终会更新，尽管这可能需要一些时间，具体取决于你的Kubernetes发行版。'
- en: '**Environment variables**: Secret data can be injected into environment variables
    and consumed from the workload like any other environment variable. This is often
    referred to as “insecure” since it’s a common practice for application developers
    to dump environment variables for debugging purposes. It’s not an uncommon occurrence
    for debugging components to be accidently kept in production that are leaking
    environment variables. It’s better to avoid this approach if possible. It’s important
    to note that if a `Secret` is updated while a pod is running, the environment
    variable in the running pod is not updated.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：机密数据可以注入到环境变量中，并像其他任何环境变量一样被工作负载使用。这通常被称为“不安全”，因为应用程序开发人员常常为了调试目的而转储环境变量。在生产环境中，调试组件意外地泄漏环境变量并不罕见。如果可能的话，最好避免这种方法。需要注意的是，如果在Pod运行时更新了`Secret`，运行中的Pod中的环境变量将不会更新。'
- en: '**Secrets API**: Kubernetes is an API and `Secrets` can be accessed directly
    via the `Secret` API. This approach provides more flexibility than either environment
    variables or volume mounts, but requires knowledge of how to call the API. If
    you need to be able to dynamically retrieve `Secrets`, this is a good approach
    but is probably overkill for most applications.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Secrets API**：Kubernetes是一个API，`Secrets`可以通过`Secret` API直接访问。与环境变量或卷挂载相比，这种方法提供了更多灵活性，但需要了解如何调用API。如果你需要能够动态地检索`Secrets`，这是一个不错的方法，但对于大多数应用来说可能是过度设计。'
- en: '**Vault API**: Every external vault provides an API. While we’re using tools
    like **External Secrets Operator** or a sidecar to interact with these APIs, there’s
    nothing stopping a developer from calling these APIs on their own. It would cut
    down on the external configuration, but at the cost of tightly binding your system
    to a particular project or vendor.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vault API**：每个外部Vault都提供一个API。虽然我们正在使用像**External Secrets Operator**或sidecar这样的工具与这些API交互，但没有任何东西阻止开发者自己调用这些API。这会减少外部配置，但代价是将系统紧密绑定到特定的项目或供应商。'
- en: Next, we’re going to walk through these options to see how they’re implemented.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐步走过这些选项，看看它们是如何实现的。
- en: Volume Mounts
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卷挂载
- en: 'The preferred way to add `Secrets` to your workloads is to treat them as files
    and load them into your application. This approach has multiple advantages over
    the other approaches listed above:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 向工作负载添加`Secrets`的首选方式是将它们视为文件并加载到应用程序中。这种方法比上面列出的其他方法有多个优势：
- en: '**Less likely to be leaked during debugging**: There’s nothing that stops a
    developer from printing the contents of a file to the logs or an output stream,
    but a call to the `env` command won’t automatically print out secret data.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在调试过程中泄露的可能性较小**：没有任何东西可以阻止开发者将文件内容打印到日志或输出流中，但调用`env`命令不会自动打印出机密数据。'
- en: '**Can be updated**: When a file is updated, that update is reflected in your
    pod. The same is true for secret data that is mounted via a volume. If the application
    in your pod knows to look for updates, it will eventually get them.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可以更新**：当文件被更新时，该更新会反映在你的pod中。对于通过卷挂载的机密数据也是如此。如果pod中的应用程序知道检查更新，它最终会获取到这些更新。'
- en: '**Richer options**: A configuration file mounted onto a volume can be more
    than name/value pairs. It can be full configuration files, simplifying management.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更丰富的选项**：挂载到卷上的配置文件不仅仅是名称/值对。它可以是完整的配置文件，从而简化管理。'
- en: Mounting a secret as a volume has been a feature of Kubernetes since `Secrets`
    were available. In this section we’ll walk through mounting both generic Kubernetes
    `Secret` objects and interacting with our Vault deployment directly using the
    **Vault Sidecar**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将机密作为卷挂载自Kubernetes的`Secrets`功能已经有一段时间了。在这一节中，我们将介绍如何挂载通用Kubernetes `Secret`对象，并直接使用**Vault
    Sidecar**与我们的Vault部署进行交互。
- en: Using Kubernetes Secrets
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Kubernetes Secrets
- en: 'Mounting a Kubernetes `Secret` as a volume into your pods is a matter of naming
    the `Secret` in your spec. For instance, if you created the pod from `chapter8/integration/volumes/volume-secrets.yaml`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将Kubernetes `Secret`作为卷挂载到pod中，只需要在spec中命名该`Secret`。例如，如果你从`chapter8/integration/volumes/volume-secrets.yaml`创建了pod：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It will generate the following log:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它将生成以下日志：
- en: '[PRE12]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This pod added the `Secret` we synchronized from Vault directly to our pod.
    We can update that secret in Vault and see what happens to the mounted value in
    a longer-running pod. First, create the pod in `chapter8/integration/volumes/volume-secrets-watch.yaml`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个pod将我们从Vault同步的`Secret`直接添加到pod中。我们可以在Vault中更新该机密，并查看它在长期运行的pod中的挂载值发生了什么变化。首先，创建`chapter8/integration/volumes/volume-secrets-watch.yaml`中的pod：
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we’re watching our mounted volume, let’s update the secret in Vault:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在监视挂载的卷，让我们更新Vault中的机密：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It may take a minute or two, but the `Secret` in our cluster gets synchronized.
    Next, let’s look at our running pod:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要一两分钟，但我们集群中的`Secret`会被同步。接下来，让我们查看我们正在运行的pod：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see that the volume did get updated. So, if we do have a long running
    pod, we can watch mounted volumes to look for updates.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到卷确实得到了更新。所以，如果我们有一个长时间运行的pod，我们可以监视挂载的卷，查找更新。
- en: In this section, we integrated a `Secret` directly into our pod. When using
    an external secrets vault, such as HashiCorp’s Vault, this requires synchronizing
    the `Secret` using a tool like **External Secrets Operator**. Next, we’ll create
    a volume directly from Vault using Vault’s injector sidecar.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将`Secret`直接集成到pod中。当使用外部机密库（如HashiCorp的Vault）时，这需要使用像**External Secrets
    Operator**这样的工具来同步`Secret`。接下来，我们将使用Vault的injector sidecar直接从Vault创建一个卷。
- en: Using Vault’s Sidecar Injector
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Vault的Sidecar Injector
- en: In the previous section, we integrated a generic Kubernetes `Secret` into our
    pod. In this section, we’ll integrate directly with Vault using its injector **sidecar**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将一个通用的Kubernetes `Secret`集成到我们的pod中。在这一节中，我们将直接使用Vault的injector **sidecar**与Vault进行集成。
- en: A **sidecar** is a special container that runs along with your primary workload
    to perform additional functions transparently and independently of your main workload.
    The sidecar pattern allows you to create containers that intercept network traffic,
    manage logs, or in the case of Vault, inject secrets. Starting in 1.28, sidecars
    moved from being a well-known pattern to becoming a first-class configuration
    option. This approach is still very new and has not yet been adopted by most implementations.
    You can learn more about the changes to sidecars in the Kubernetes blog at [https://kubernetes.io/blog/2023/08/25/native-sidecar-containers/](https://kubernetes.io/blog/2023/08/25/native-sidecar-containers/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sidecar**是与主工作负载一起运行的特殊容器，用于执行额外的功能，且透明地独立于主工作负载。Sidecar模式使你能够创建拦截网络流量、管理日志，或者在Vault的情况下，注入机密的容器。从1.28版本开始，sidecar从一个广为人知的模式转变为成为一个一等配置选项。这种方法仍然非常新，尚未被大多数实现采用。你可以在Kubernetes博客中了解更多有关sidecar变化的内容，链接：[https://kubernetes.io/blog/2023/08/25/native-sidecar-containers/](https://kubernetes.io/blog/2023/08/25/native-sidecar-containers/)。'
- en: 'Vault’s **sidecar injector** has two primary components that let us inject
    secret data into our pods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Vault的**sidecar注入器**有两个主要组件，让我们能够将机密数据注入到Pod中：
- en: '**Injector Mutating Admission Controller**: We’ll cover admission controllers
    in more detail in *Chapter 11*, *Extending Security Using Open Policy Agent*.
    For now, what you need to know about this controller is that it looks for pods
    to be created with specific `annotations` to configure the sidecar that interacts
    with the Vault service.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入器变异接收控制器**：我们将在*第11章*中更详细地讨论接收控制器，*通过Open Policy Agent扩展安全性*。现在，你需要知道的是，这个控制器会寻找具有特定`annotations`的Pod，以配置与Vault服务交互的sidecar。'
- en: '**Sidecar**: The sidecar does the work of interacting with our Vault deployment.
    You don’t need to configure the sidecar manually, the admission controller mutator
    will do that for you based on `annotations`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sidecar**：Sidecar负责与我们的Vault部署进行交互的工作。你不需要手动配置sidecar，接收控制器变异器会根据`annotations`为你完成这个任务。'
- en: 'First, let’s look at our pod that is getting secret data directly from Vault:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下从Vault直接获取机密数据的Pod：
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s focus on the Vault connection options:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们集中讨论Vault的连接选项：
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first `annotation` tells the admission controller that we want to generate
    the sidecar configuration for this pod. The next `annotation` tells Vault where
    the Vault service is. We then enable detailed logging and then set the role for
    authentication. This role in Vault was created in `chapter8/external-secrets/install_external_secrets.sh`
    with the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`annotation`告诉接收控制器我们希望为这个Pod生成sidecar配置。接下来的`annotation`告诉Vault Vault服务的位置。然后我们启用详细日志记录，并设置认证的角色。这个角色在Vault中是在`chapter8/external-secrets/install_external_secrets.sh`中创建的，具体如下：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The role maps our `ServiceAccount` to an allowed policy. Finally, we tell the
    agent to skip TLS verification. In a production deployment, you don’t want to
    skip TLS verification. We could mount our CA certificate, and that’s what you’ll
    want to do in production.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 角色将我们的`ServiceAccount`映射到一个允许的策略。最后，我们告诉代理跳过TLS验证。在生产环境中，你不应该跳过TLS验证。我们可以挂载我们的CA证书，这也是你在生产环境中应该做的。
- en: Notice, we didn’t specify a key or a `Secret` for authentication. That’s because
    we’re using our `Pod's` own identity. The `serviceAccount` and `serviceAccountName`
    options on the pod dictate which identity is used. When we configured external
    secrets, we use the `ext-secret-vault ServiceAccount`, so we reused that identity
    here.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有指定用于认证的密钥或`Secret`。这是因为我们使用的是我们`Pod`本身的身份。Pod上的`serviceAccount`和`serviceAccountName`选项决定了使用哪个身份。当我们配置外部机密时，我们使用了`ext-secret-vault
    ServiceAccount`，因此我们在这里复用了该身份。
- en: 'Having defined how we talk to Vault, next let’s look at how we define our data:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了如何与Vault通信后，接下来让我们看一下如何定义我们的数据：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first annotation says, “Create a configuration called `myenv` that points
    to the Vault object `/secret/data/extsecret/config`.” `myenv` is like a variable
    that allows you to track configuration options across multiple `annotations`.
    The next `annotation` says that we want to place everything into the `/etc/secrets/myenv`
    file. If we didn’t specify this annotation, the sidecar would have put the resulting
    `myenv` file in the `/vault/secrets` directory.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个annotation说：“创建一个名为`myenv`的配置，指向Vault对象`/secret/data/extsecret/config`。”`myenv`就像一个变量，允许你在多个`annotations`中跟踪配置选项。接下来的`annotation`表示我们希望将所有内容放入`/etc/secrets/myenv`文件中。如果我们没有指定这个annotation，sidecar将把生成的`myenv`文件放入`/vault/secrets`目录。
- en: The final `annotation` creates the content of the `myenv` file. If the syntax
    looks like Helm, that’s because it uses the same template engine. Here, we’re
    creating a file with a name/value pair. This can be a configuration file template
    too.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 `annotation` 创建了 `myenv` 文件的内容。如果语法看起来像 Helm，那是因为它使用了相同的模板引擎。在这里，我们创建了一个名称/值对的文件。这也可以是一个配置文件模板。
- en: 'Now that we’ve walked through the configuration, let’s create the object:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配置，让我们来创建对象：
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our original workload is unaware of Vault, but is able to retrieve the secret
    data from the generated template. There are scenarios where Vault will refresh
    the template, but they’re Vault-specific configuration options that we’re not
    going to dive into.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原始工作负载并不了解 Vault，但能够从生成的模板中检索秘密数据。有些场景中 Vault 会刷新模板，但这些是 Vault 特有的配置选项，我们不打算深入探讨。
- en: The annotation-based injection of sidecars is a common pattern amongst secrets
    management integrations with Kubernetes. If you’re looking to integrate other
    external secrets management systems, this is a consistent approach to use.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 基于注解的 sidecar 注入是与 Kubernetes 集成的秘密管理中的一种常见模式。如果你打算集成其他外部秘密管理系统，这是一个一致的使用方式。
- en: We’ve looked at how to use volumes to bind secrets to workloads using both standard
    Kubernetes `Secret` objects and our external Vault. Both approaches allow you
    to externalize your secrets. Next, we’ll look at how to inject secret data as
    environment variables.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过如何使用卷将秘密绑定到工作负载，既可以使用标准的 Kubernetes `Secret` 对象，也可以使用我们的外部 Vault。这两种方法都允许你将秘密外部化。接下来，我们将讨论如何将秘密数据注入为环境变量。
- en: Environment Variables
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: Using environment variables is the easiest way to consume any data. Every language
    and platform has a standard way to access an environment variable. The downside
    to this ease of access is that it’s common for developers to print out or dump
    all their environment variables for debugging. This means that the data could
    end up in a log, or even worse a debugging webpage that prints out environment
    variables. This mechanism will often be flagged by security teams, so it should
    be avoided if possible. That said, some workloads require environment variables,
    so let’s look at how to integrate both plain Kubernetes `Secrets` and secrets
    from our external Vault into a pod.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量是获取任何数据的最简单方法。每种语言和平台都有一种标准的方式来访问环境变量。尽管这种方式很容易访问，但开发者常常会为了调试而打印出或转储所有的环境变量。这样一来，数据可能会出现在日志中，甚至更糟，出现在打印出环境变量的调试网页上。这种机制通常会被安全团队标记出来，因此如果可能的话应该避免使用。然而，一些工作负载确实需要环境变量，因此我们来看一下如何将
    Kubernetes `Secrets` 和来自外部 Vault 的秘密集成到 Pod 中。
- en: Using Kubernetes Secrets
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Kubernetes Secrets
- en: 'Kubernetes can plug a `Secret` object’s data directly into an environment variable
    inside of the `Pod` definition of the container. Here’s a simple example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 可以将 `Secret` 对象的数据直接插入到容器的 `Pod` 定义中的环境变量里。这里是一个简单的示例：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Looking at `.spec.containers[name=test].env`, you can see that we create an
    environment variable from an existing `Secret`. The command of this container
    is simply the `env` command, which prints out all the environment variables. To
    see this container in action, apply the YAML from the `chapter8/integration/envvars/envars-secrets.yaml`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 看 `.spec.containers[name=test].env`，你可以看到我们从现有的 `Secret` 创建了一个环境变量。这个容器的命令仅仅是
    `env` 命令，它会打印出所有的环境变量。要查看这个容器的运行效果，应用来自 `chapter8/integration/envvars/envars-secrets.yaml`
    的 YAML：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What happens if we update our `Secret`? Kubernetes won’t update the environment
    variable. Let’s verify this point. First, create a pod that watches our environment
    variables:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更新 `Secret` 会发生什么？Kubernetes 不会更新环境变量。让我们验证一下这一点。首先，创建一个监视我们环境变量的 Pod：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This pod will continuously echo the environment variable we created. Next,
    let’s update Vault:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Pod 将持续回显我们创建的环境变量。接下来，让我们更新 Vault：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It can take up to a minute for our new password to be synchronized into the
    `Secret`. Wait until that synchronization is complete. Once synchronized, let’s
    watch our logs:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新密码同步到 `Secret` 中可能需要最多一分钟的时间。请等待同步完成。一旦同步完成，让我们查看日志：
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The environment variables in the pod are not updated. You can continue to let
    this run, but it won’t change. You’ll need something to watch the `Secret` and
    restart your workload if you want to support dynamic changes with environment
    variables.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 中的环境变量未更新。你可以继续运行它，但它不会发生变化。如果你希望支持环境变量的动态变化，你需要某些机制来监控 `Secret` 并在需要时重启工作负载。
- en: Now that we’re able to incorporate a Kubernetes `Secret` as an environment variable,
    next, we’ll work with the Vault sidecar to integrate that same variable into a
    pod.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够将 Kubernetes `Secret` 作为环境变量进行使用，接下来，我们将与 Vault 侧车一起工作，将这个变量集成到 pod 中。
- en: Using the Vault Sidecar
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Vault 侧车
- en: 'The **Vault sidecar** doesn’t support injecting environment variables directly,
    because sidecar images can’t share environment variables. If your pod does require
    environment variables, you need to generate a file that has a script that exports
    those variables. Here’s an example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vault 侧车**不支持直接注入环境变量，因为侧车镜像无法共享环境变量。如果你的 pod 确实需要环境变量，你需要生成一个包含导出这些变量的脚本的文件。这里有一个例子：'
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This pod definition looks almost identical to the volume-based Vault integration
    we created before. The main difference is that we are running a command in our
    container to generate the environment variables from the template we created in
    our annotations. While this approach will work, it means updating your manifests
    so that they are looking looking for a specific file. This approach breaks accepted
    patterns for manifest reusability and will make it difficult to use externally
    generated images.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pod 定义几乎与我们之前创建的基于卷的 Vault 集成完全相同。主要的区别在于，我们在容器中运行一个命令，从我们在注释中创建的模板生成环境变量。虽然这种方法可以工作，但它意味着需要更新你的清单，以便它们查找特定的文件。这种方法打破了清单可重用性的既定模式，并且会使得使用外部生成的镜像变得困难。
- en: The issues with trying to generate environment variables with an external secrets
    manager reinforces that this is an antipattern that should be avoided. Next, we’ll
    look at using the Kubernetes API directly for retrieving `Secrets`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过外部秘密管理器生成环境变量的问题强化了这一点：这是一种反模式，应当避免。接下来，我们将直接使用 Kubernetes API 来获取 `Secrets`。
- en: Using the Kubernetes Secrets API
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kubernetes Secrets API
- en: So far, we have focussed on abstractions for interacting with APIs so that our
    workloads do not need to know about the Kubernetes API. For most workloads, this
    makes sense as secret metadata is often static. For instance, your application
    may need to talk to a database whose credentials may change but the fact that
    you need credentials won’t. What if you need something more dynamic? If you’re
    building a system that services other systems, this might be the case. In this
    section, we’ll walk through why you would call the `Secrets` API directly from
    your pod.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注与 API 交互的抽象，以便我们的工作负载不需要了解 Kubernetes API。对于大多数工作负载来说，这是合理的，因为秘密元数据通常是静态的。例如，你的应用程序可能需要与一个数据库通信，虽然凭证可能会发生变化，但你需要凭证这一事实不会改变。那如果你需要更动态的东西呢？如果你正在构建一个为其他系统提供服务的系统，可能就需要这种动态性。在本节中，我们将介绍为什么你会直接从
    pod 中调用 `Secrets` API。
- en: 'The first question you might be asking is “why?” With the multiple options
    for abstraction on top of the Kubernetes `Secrets` API, why would you want to
    call the Kubernetes API directly? There have been some interesting trends that
    will likely make this more of a reality:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问的第一个问题是“为什么？”在 Kubernetes `Secrets` API 上有多种抽象选项的情况下，为什么你还要直接调用 Kubernetes
    API？最近有一些有趣的趋势，可能会让这种做法成为现实：
- en: '**More monoliths**: In recent months there’s been a trend of re-examining if
    microservices are the right architecture for most systems. One of the most visible
    moves to monoliths was Amazon’s Prime Video **Quality of Service** (**QoS**) going
    from Lambda to a monolith. We discuss the trade-offs between these approaches
    when we talk about Istio in *Chapter 17*, *Building and Deploying Applications
    on Istio*. If you were to build a monolith, you may need to provide more flexibility
    in how you access your `Secrets`. Static metadata definitions may not be adequate.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更多的单体架构**：近几个月来，重新审视微服务是否是大多数系统的正确架构成为一种趋势。向单体架构转变最显著的例子之一是亚马逊的 Prime Video
    **服务质量**（**QoS**）从 Lambda 转向单体架构。我们在*第 17 章*《在 Istio 上构建和部署应用程序》中讨论了这些方法之间的权衡。如果你要构建一个单体应用，可能需要提供更多的灵活性来访问你的
    `Secrets`。静态元数据定义可能不足以满足需求。'
- en: '**Kubernetes as a data center API**: It turns out that Kubernetes’ API is simple
    enough to be easily adapted to multiple use cases, yet powerful enough to be scaled
    out. A great example is the **KubeVirt** ([https://kubevirt.io/](https://kubevirt.io/))
    project that lets your Kubernetes cluster manage and deploy virtual machines.
    More workloads are using **custom resource definitions** (**CRDs**) to store configuration
    information, and since you’d never keep a secret in a CRD, you may need to interact
    with the `Secrets` API to get access to your secret data.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes作为数据中心API**：事实证明，Kubernetes的API足够简单，可以轻松适应多个使用场景，同时又足够强大，能够进行扩展。一个很好的例子是**KubeVirt**
    ([https://kubevirt.io/](https://kubevirt.io/)) 项目，它让你的Kubernetes集群能够管理和部署虚拟机。越来越多的工作负载开始使用**自定义资源定义**（**CRDs**）来存储配置信息，并且由于你永远不会将秘密存储在CRD中，因此你可能需要与`Secrets`
    API进行交互，以访问你的秘密数据。'
- en: '**Platform engineering**: More teams are moving to the idea of creating an
    **internal developer platform** (**IDP**) that provides a one-stop-shop for self-service
    access to services such as Kubernetes. If your IDP is built on Kubernetes, you’ll
    likely need to interact with the `Secrets` API.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台工程**：越来越多的团队开始转向创建**内部开发者平台**（**IDP**）的理念，该平台提供一站式自服务访问，允许访问Kubernetes等服务。如果你的IDP是基于Kubernetes构建的，你可能需要与`Secrets`
    API进行交互。'
- en: This book spends quite a bit of time on identity in Kubernetes and will often
    refer to IdPs. The case of the “d” is important because an **IdP** is an **Identity
    Provider**, while an **IDP** is an **Internal Developer Portal**.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书花了相当多的篇幅讨论Kubernetes中的身份问题，并且会经常提到IdP。这里的“d”很重要，因为**IdP**是**身份提供者**，而**IDP**是**内部开发者门户**。
- en: With these points in mind, you may find yourself needing to interact directly
    with the Kubernetes API to retrieve `Secrets`. The good news is that you’re not
    really doing anything different for the `Secrets` API than any other API. Most
    of the Kubernetes client SDKs even handle base64 decoding the data from `Secret`
    objects.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些要点，你可能会发现自己需要直接与Kubernetes API交互以检索`Secrets`。好消息是，你在`Secrets` API上的操作与任何其他API没什么不同。大多数Kubernetes客户端SDK甚至处理从`Secret`对象中解码base64数据的工作。
- en: 'Since this isn’t a programming book, and there are many ways to interact with
    the API, we’re not going to dive into any SDK specifics. We’re going to cover
    some specific guidance:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不是一本编程书籍，而且与API交互有很多种方式，我们不会深入探讨任何SDK的具体内容。我们将提供一些具体的指导：
- en: '**Use Your Pod’s Identity**: Just like interacting with external vaults, use
    your Pod’s own identity when interacting with the API server. Don’t use a hardcoded
    Secret.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用你的Pod身份**：就像与外部Vault交互一样，使用Pod自身的身份与API服务器进行交互。不要使用硬编码的Secret。'
- en: '**Use an SDK**: This is good general advice. Yes, you can use the Kubernetes
    API via a direct RESTful call, but let the SDK do the work for you. It will make
    life easier and lead to fewer security issues (who hasn’t accidently logged a
    token while testing an HTTPS call? I mean, besides me).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用SDK**：这是一个很好的通用建议。是的，你可以通过直接的RESTful调用使用Kubernetes API，但让SDK为你处理这项工作。它会让生活更轻松，并减少安全问题（谁没有在测试HTTPS调用时不小心记录了令牌呢？我说的是，除了我之外）。'
- en: '**Store Metadata in CRDs**: Any situation where you’re going to describe a
    secret should be done in a CRD. This gives you the benefit of having a schema
    language that you can use to generate your own SDKs.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在CRD中存储元数据**：任何需要描述秘密的情况都应在CRD中进行。这为你提供了一个模式语言，借此你可以生成自己的SDK。'
- en: While it is more difficult to interact with the `Secrets` API than to use Kubernetes’
    multiple abstractions for interacting with secrets, it does provide tremendous
    flexibility that is not available to the more common abstractions. Next, we’ll
    look at whether interacting directly with our vault’s API can provide the same
    benefits.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与`Secrets` API进行交互比使用Kubernetes的多个抽象层来与秘密交互更困难，但它提供了其他常见抽象层所没有的巨大灵活性。接下来，我们将探讨直接与我们的Vault
    API交互是否能提供相同的好处。
- en: Using the Vault API
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vault API
- en: Every vault service has an API. That’s how the sidecars that integrate with
    them interact with their vaults so that they can inject secrets into your workloads.
    In the previous section, we walked through the advantages of directly calling
    the Kubernetes `Secrets` API. Does the same logic apply to the Vault API? The
    reasoning for calling the Vault API, or any secrets management API, directly is
    the same as calling the `Secrets` API.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Vault 服务都有一个 API。这就是与其集成的 sidecar 如何与 Vault 进行交互，从而将秘密注入到你的工作负载中的方式。在前面的部分中，我们讲解了直接调用
    Kubernetes `Secrets` API 的优点。那么，是否可以将相同的逻辑应用于 Vault API？直接调用 Vault API 或任何秘密管理
    API 的理由与调用 `Secrets` API 相同。
- en: What are the disadvantages of calling the Vault API directly? The main drawback
    is that you are now tightly binding your workload to a specific vendor or project.
    One of the benefits of the Kubernetes API is that it is relatively consistent
    across implementations. While this isn’t always true, at least for the `Secret`
    API it is.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用 Vault API 的缺点是什么？主要的缺点是你现在将工作负载紧密绑定到一个特定的供应商或项目上。Kubernetes API 的一个好处是它在不同的实现中相对一致。虽然这并非总是如此，但至少在
    `Secret` API 中是这样。
- en: There is unfortunately no standard API for secrets, nor is there likely to ever
    be one. HashiCorp, AWS, Microsoft, Google, VMWare, etc. all have their own ideas
    as to how secrets should be managed and there isn’t much incentive to create a
    standard. There’s also no standard for integrating language bindings. For instance,
    the database world often has common standards for integrating into programming
    languages such as the JDBC standard in Java. It would be great for Kubernetes
    to make the `Secrets` API pluggable, but that will never happen. The complexities
    at both the technical and non-technical levels are just too high for Kubernetes
    to own such an undertaking.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前没有一个标准的秘密 API，未来也可能永远不会有。HashiCorp、AWS、微软、谷歌、VMWare 等公司都有自己关于如何管理秘密的想法，且没有太多动力去创建标准。语言绑定的集成也没有标准。例如，数据库领域通常有用于编程语言集成的常见标准，如
    Java 中的 JDBC 标准。如果 Kubernetes 能够使 `Secrets` API 可插拔，那将是很棒的，但这永远不会发生。技术和非技术层面的复杂性使得
    Kubernetes 不可能承担这样的任务。
- en: With that said, the same recommendations that were made for using the Kubernetes
    `Secrets` API should be followed when integrating your workloads directly into
    the Vault API. Make sure that you’re using a language SDK and rely on your workload’s
    identity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在将工作负载直接集成到 Vault API 时，应该遵循与使用 Kubernetes `Secrets` API 时相同的建议。确保你使用了语言
    SDK，并依赖于工作负载的身份。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter walked through multiple aspects of secrets management. We began
    by discussing the difference between secret data and more generic configuration
    data. We considered why Kubernetes stores and represents Secret objects as base64-encoded
    text, and why you shouldn’t store secret data in git. There was also a discussion
    on threat modelling secret data in Kubernetes clusters. Next, we then walked through
    various ways to store and manage secret data including Secret objects, external
    vaults, Sealed Secrets, and hybrid approaches. Finally, we walked through integrating
    your secrets into your workloads via volume mounts, environment variables, and
    directly with APIs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解了秘密管理的多个方面。我们首先讨论了秘密数据和更通用的配置数据之间的区别。我们考虑了为什么 Kubernetes 将 Secret 对象存储并表示为
    base64 编码的文本，以及为什么不应将秘密数据存储在 git 中。还讨论了在 Kubernetes 集群中对秘密数据进行威胁建模。接下来，我们介绍了存储和管理秘密数据的各种方式，包括
    Secret 对象、外部保险库、Sealed Secrets 和混合方法。最后，我们讲解了如何通过卷挂载、环境变量以及直接通过 API 将秘密集成到工作负载中。
- en: Having finished this chapter, you should now have enough information and examples
    to build your own secrets management strategy for your clusters.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该已经拥有足够的信息和示例来为你的集群构建自己的秘密管理策略。
- en: In the next chapter, we are going to begin focusing on multi-tenancy with virtual
    clusters.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始关注虚拟集群的多租户。
- en: Questions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Compliance and security are the same thing.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合规性和安全性是同一回事。
- en: 'True'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Base64 is a type of encryption.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Base64 是一种加密方式。
- en: 'True'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'The best way to authenticate to an external vault is:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 身份验证外部 Vault 的最佳方式是：
- en: Using a password
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用密码
- en: Using your `Pod's` identity
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Pod` 的身份
- en: Using a password that changes every 3 months
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用每三个月更换一次的密码
- en: Which integration type is automatically updated in a pod when a secret is updated?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新秘密时，哪种集成类型会在 pod 中自动更新？
- en: A `Secret` with an environment variable
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有环境变量的 `Secret`
- en: An external vault with an environment variable
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个带有环境变量的外部保险库
- en: An external vault with a volume
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个带有卷的外部保险库
- en: A `Secret` with a volume
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个带有卷的`Secret`
- en: When discussing IT security, what does CIA stand for?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在讨论IT安全时，CIA代表什么？
- en: Confidentiality, Integrity, Availability
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保密性、完整性、可用性
- en: Central Intelligence Agency
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中央情报局
- en: Confidentiality, Interesting, Availability
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保密性、趣味性、可用性
- en: Culinary Institute of America
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 美国烹饪学院
- en: Answers
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b – False
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b – 错误
- en: b – False
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b – 错误
- en: c – Using your `Pod's` identity
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c – 使用你的`Pod`身份
- en: d – A `Secret` with a volume
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d – 一个带有卷的`Secret`
- en: a – Confidentiality, Integrity, Availability
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – 保密性、完整性、可用性
