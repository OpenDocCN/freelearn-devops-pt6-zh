- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Exploring External Secret Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索外部秘密存储
- en: Previously, we worked with the cloud providers AWS, Azure, and GCP. We ran our
    application and integrated it with the secret providers offered on these platforms.
    We used the Secrets management facilities of each cloud provider and benefited
    from the ecosystem of tools that the cloud providers provides us with. This made
    it feasible to tackle concerns such as auditing high availability and disaster
    recovery. In this chapter, we shall explore external secret stores that are not
    part of a cloud provider’s offerings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们与云服务提供商 AWS、Azure 和 GCP 一起工作。我们运行了应用程序，并将其与这些平台上提供的秘密提供商集成。我们使用了每个云服务商的
    Secrets 管理设施，并受益于云服务商为我们提供的工具生态系统。这使得我们能够应对诸如审计、高可用性和灾难恢复等问题。在本章中，我们将探讨不属于云服务提供商产品的一些外部秘密存储。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Overview of external secret store providers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部秘密存储提供商概述
- en: The different types of external secret stores, such as HashiCorp Vault, and
    CyberArk Secrets Manager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部秘密存储的不同类型，如 HashiCorp Vault 和 CyberArk Secrets Manager
- en: Managing Secrets in an external secret store for Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在外部秘密存储中管理 Kubernetes 的 Secrets
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To link concepts with hands-on examples, we are leveraging a series of tools
    and platforms commonly used to interact with the Google Cloud API and Kubernetes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将概念与动手实践结合，我们使用了一系列常用工具和平台来与 Google Cloud API 和 Kubernetes 进行交互：
- en: '**kubectl**: This is the command-line tool used for communicating with a Kubernetes
    cluster through the Kubernetes API ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl**：这是用于通过 Kubernetes API 与 Kubernetes 集群通信的命令行工具 ([https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/))。'
- en: '**minikube**: This is a local Kubernetes distribution used for Kubernetes learning
    and development. To install minikube on your system, you can follow the instructions
    from the official documentation ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minikube**：这是一个用于 Kubernetes 学习和开发的本地 Kubernetes 发行版。要在您的系统上安装 minikube，您可以参考官方文档中的安装说明
    ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/))。'
- en: '**Vault CLI**: This is used to interact with a HashiCorp Vault installation
    ([https://developer.hashicorp.com/vault/docs/install](https://developer.hashicorp.com/vault/docs/install)).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vault CLI**：用于与 HashiCorp Vault 安装进行交互 ([https://developer.hashicorp.com/vault/docs/install](https://developer.hashicorp.com/vault/docs/install))。'
- en: '`kubectl` commands ([https://jqlang.github.io/jq/](https://jqlang.github.io/jq/)).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` 命令 ([https://jqlang.github.io/jq/](https://jqlang.github.io/jq/)).'
- en: '**Helm**: This is a package manager for Kubernetes that we will be using to
    simplify the deployment and management of Kubernetes resources ([https://helm.sh](https://helm.sh)).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm**：这是 Kubernetes 的一个包管理器，我们将使用它来简化 Kubernetes 资源的部署和管理 ([https://helm.sh](https://helm.sh))。'
- en: Overview of external secret providers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部密钥提供商概述
- en: By default, Secrets on Kubernetes are stored in **etcd** as mentioned in [*Chapter
    1*](B20970_01.xhtml#_idTextAnchor015), *Understanding Kubernetes Secrets Management*.
    Storing Secrets on etcd comes with certain security concerns, as mentioned in
    [*Chapter 7*](B20970_07.xhtml#_idTextAnchor142), *Challenges and Risks in Managing
    Secrets*. Alternative forms of secret storage can help us harden our security
    and also segregate the concerns that come with secret usage. We will focus on
    the components that make it feasible to have external secret providers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 上的 Secrets 存储在**etcd**中，正如在[*第 1 章*](B20970_01.xhtml#_idTextAnchor015)《理解
    Kubernetes Secrets 管理》中所提到的那样，*理解 Kubernetes Secrets 管理*。将 Secrets 存储在 etcd 中会带来一些安全问题，正如在[*第
    7 章*](B20970_07.xhtml#_idTextAnchor142)《管理 Secrets 中的挑战与风险》一章中提到的那样。使用其他形式的秘密存储可以帮助我们增强安全性，并且分隔与秘密使用相关的关注点。我们将重点关注使外部密钥提供商可行的组件。
- en: 'First, let us have a look at the available external secret store providers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下可用的外部秘密存储提供商：
- en: AWS Secrets Manager
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Secrets Manager
- en: Azure Key Vault
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Key Vault
- en: GCP Secret Manager
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP Secret Manager
- en: HashiCorp Vault
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault
- en: CyberArk Conjur
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CyberArk Conjur
- en: The way these providers offer integration with Kubernetes might differ. A very
    popular approach to achieving integration with a secret store provider is through
    the Secrets Store CSI Driver.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提供商与 Kubernetes 集成的方式可能有所不同。实现与密钥存储提供商集成的一种非常流行的方法是通过 Secrets Store CSI Driver。
- en: Secrets Store CSI Driver
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets Store CSI Driver
- en: The Secrets Store CSI Driver makes it feasible to integrate Kubernetes Secrets
    through a **container storage interface** (**CSI**) volume. The Kubernetes Secrets
    Store interface is based on the Kubernetes CSI plugin. Through CSI, we can integrate
    external store providers to Kubernetes by implementing a CSI plugin, which can
    extend our cluster’s storage capabilities without having to change the Kubernetes
    core code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets Store CSI驱动程序使得通过**容器存储接口**（**CSI**）卷集成Kubernetes秘密成为可能。Kubernetes Secrets
    Store接口基于Kubernetes CSI插件。通过CSI，我们可以通过实现CSI插件将外部存储提供者集成到Kubernetes中，从而扩展集群的存储能力，而无需更改Kubernetes的核心代码。
- en: External secret store providers with CSI plugins
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部秘密存储提供者与CSI插件
- en: 'There are a handful of CSI provider plugins:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些CSI提供者插件：
- en: AWS provider
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS提供者
- en: Azure provider
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure提供者
- en: GCP provider
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP提供者
- en: Vault provider
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault提供者
- en: In the previous chapters, we focused on the CSI Secrets Store CSI Driver that
    came along with the cloud provider solutions. We mention a new provider, the Vault
    provider, which is HashiCorp’s secret storage.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们重点介绍了与云服务提供商解决方案一起提供的CSI Secrets Store CSI驱动程序。我们提到了一个新的提供者——Vault提供者，它是HashiCorp的秘密存储解决方案。
- en: All the secret providers on the list give the option of high availability, and
    all secret providers provide auditing and logging. Those elements ensure data
    governance and security. Apart from the CSI Driver solution, there are also other
    approaches available for Secrets management integration. One of them is the Secrets
    Injector component, which we will cover next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的所有秘密提供者都提供高可用性选项，并且所有的秘密提供者都提供审计和日志记录。这些元素确保了数据治理和安全性。除了CSI驱动程序解决方案外，还有其他可用的秘密管理集成方法。其中之一就是Secrets
    Injector组件，我们将在接下来介绍。
- en: Secrets Injector
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets Injector
- en: The Secrets Injector component offers another way to inject Secrets on an application
    and Secrets hosted on an external secret store provider.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets Injector组件提供了另一种方式，可以将秘密注入到应用程序以及托管在外部秘密存储提供者上的秘密。
- en: Secret managers such as HashiCorp Vault and CyberArk Conjur support secret storage
    usage through the Sidecar Injector. Those sidecar injectors focus on the aspects
    of authorization and authentication when it comes to receiving the Secrets from
    the secret storage. Also, they tackle the integration with the Kubernetes workloads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 像HashiCorp Vault和CyberArk Conjur这样的秘密管理器通过Sidecar Injector支持秘密存储的使用。这些sidecar注入器专注于在从秘密存储中接收秘密时的授权和认证方面。同时，它们也解决了与Kubernetes工作负载的集成问题。
- en: However, take note that injecting Secrets is not an action that always requires
    a sophisticated binary that interacts with Kubernetes. For example, let us consider
    GCP Secret Manager. There is no official binary that will receive the Secrets
    from Secret Manager and then attach them to the Pod. This does not prevent us
    from implementing a solution that will securely achieve the same result. We can
    utilize Workload Identity, as mentioned in [*Chapter 10*](B20970_10.xhtml#_idTextAnchor193),
    *Exploring Cloud Secret Store on GCP*. Through Workload Identity, our Kubernetes
    workloads can interact with Secret Manager. We can then use the client libraries
    of GCP Secret Manager, and through an initialization container, the Secrets can
    be mounted locally to the Pod.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，注入秘密并不是总需要一个与Kubernetes交互的复杂二进制文件。例如，我们可以考虑GCP Secret Manager。没有官方的二进制文件可以从Secret
    Manager接收秘密并将其附加到Pod上。但这并不妨碍我们实现一个安全的解决方案来实现相同的结果。我们可以利用工作负载身份，如在[*第10章*](B20970_10.xhtml#_idTextAnchor193)《探索GCP上的云秘密存储》中提到的那样，通过工作负载身份，我们的Kubernetes工作负载可以与秘密管理器进行交互。然后我们可以使用GCP
    Secret Manager的客户端库，并通过初始化容器，将秘密安全地挂载到Pod上。
- en: This recipe can be applied to any other form of storage. The key element to
    note is the usage of Workload Identity; the security remained intact by utilizing
    it. We did not have to store any Secrets on etcd that would make it feasible to
    interact with Secret Manager. Instead, Kubernetes workloads would get assigned
    certain permissions to make it feasible to interact with Secret Manager.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案可以应用于任何其他形式的存储。关键要点是使用了工作负载身份（Workload Identity）；通过它，安全性得到了保障。我们不需要在etcd上存储任何秘密，从而能够与秘密管理器进行交互。相反，Kubernetes工作负载会被分配特定的权限，从而使得与秘密管理器的交互成为可能。
- en: In other forms of Secrets management, such as HashiCorp Vault, authentication
    and interaction with the secret storage are a bit different from what we have
    seen so far, yet the security qualities remain the same. Access to the Secrets
    is achieved in a secure and authorized way where the principle of least permissions
    is followed. We will examine this in the following chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他形式的秘密管理系统中，如HashiCorp Vault，身份验证和与秘密存储的交互与我们之前看到的有所不同，但其安全性特性保持一致。对秘密的访问是通过安全和授权的方式实现的，并遵循最小权限原则。我们将在接下来的章节中详细讨论这一点。
- en: To summarize, we had an overview of the external Secrets Provider that we can
    use to inject our Secrets into Kubernetes. Going forward, we will focus on the
    HashiCorp Vault and its capabilities.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们概述了可以用来将Secrets注入Kubernetes的外部Secrets提供程序。接下来，我们将重点介绍HashiCorp Vault及其功能。
- en: HashiCorp Vault
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashiCorp Vault
- en: In the rapidly evolving landscape of distributed computing, securing sensitive
    information is paramount. Kubernetes, a leader in container orchestration, requires
    robust solutions to manage Secrets—sensitive data necessary for the proper configuration
    and operation of applications. HashiCorp Vault stands out as a central figure
    in addressing these challenges, providing a comprehensive suite of tools for secure
    Secrets management across Kubernetes clusters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算迅速发展的背景下，保护敏感信息至关重要。Kubernetes，作为容器编排的领头羊，需要强大的解决方案来管理Secrets——那些对应用程序配置和操作至关重要的敏感数据。HashiCorp
    Vault凭借其全面的工具套件，成为解决这些挑战的核心，为Kubernetes集群中的Secrets管理提供了安全的方案。
- en: HashiCorp Vault offers a centralized, encrypted solution, ensuring that Secrets
    remain confidential and are never exposed in application code or configuration
    files. Its integration with Kubernetes not only simplifies Secrets management
    but also fortifies the security of containerized applications, introducing features
    such as dynamic Secrets, secure secret injection into Pods, and a Kubernetes-native
    authentication method. These features foster secure communications and secret
    retrieval between HashiCorp Vault and Kubernetes, enhancing flexibility, security,
    and efficiency in managing Secrets.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Vault提供了一个集中化的加密解决方案，确保Secrets保持机密，并且从不在应用程序代码或配置文件中暴露。它与Kubernetes的集成不仅简化了Secrets管理，还增强了容器化应用程序的安全性，引入了动态Secrets、Pods中的安全秘密注入和Kubernetes原生身份验证等功能。这些功能促进了HashiCorp
    Vault与Kubernetes之间的安全通信和Secrets检索，提升了管理Secrets的灵活性、安全性和效率。
- en: HashiCorp Vault’s capability to dynamically generate short-lived credentials
    on demand distinguishes it from native Kubernetes Secrets, which are often stored
    unencrypted in etcd and become unwieldy as applications scale. HashiCorp Vault’s
    approach minimizes the attack surface, enhances security, and addresses the potential
    mismanagement of Secrets.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Vault能够按需动态生成短期凭证，这一点将其与本地Kubernetes Secrets区分开来。后者通常以未加密的形式存储在etcd中，并且随着应用程序的扩展，管理起来变得更加困难。HashiCorp
    Vault的方法最小化了攻击面，增强了安全性，并解决了Secrets管理不当的潜在问题。
- en: Moreover, HashiCorp Vault’s extensive audit logging ensures transparency and
    accountability, aiding compliance and facilitating swift responses to security
    incidents. By integrating HashiCorp Vault into Kubernetes deployments, organizations
    position themselves to achieve a robust, secure, and compliant containerized application
    environment, overcoming the limitations of native Kubernetes Secrets and elevating
    their Secrets management practices to the highest security standards.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HashiCorp Vault的广泛审计日志功能确保了透明度和问责制，帮助合规并促进了对安全事件的迅速响应。通过将HashiCorp Vault集成到Kubernetes部署中，组织能够建立一个强大、安全且符合合规要求的容器化应用环境，克服本地Kubernetes
    Secrets的局限性，将Secrets管理提升到最高的安全标准。
- en: There is an open source and an enterprise version, and we will focus on the
    open source version next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它有开源版和企业版，我们接下来将重点介绍开源版。
- en: Using HashiCorp Vault as a secret storage
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HashiCorp Vault作为秘密存储
- en: 'HashiCorp Vault can be used as a secret storage; it can contain the Secrets
    of our application. This makes it feasible to host Kubernetes Secrets on Vault.
    This can be done in two ways: either having the Vault hosted outside of Kubernetes
    or hosting the Vault with Kubernetes.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Vault可以作为秘密存储，它可以包含我们应用程序的Secrets。这使得将Kubernetes Secrets托管在Vault中成为可能。可以通过两种方式实现：要么将Vault托管在Kubernetes之外，要么将Vault与Kubernetes一起托管。
- en: Let us examine how we can integrate an external HashiCorp Vault with Kubernetes.
    For our needs, we shall use a minikube installation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将外部 HashiCorp Vault 与 Kubernetes 集成。为了满足我们的需求，我们将使用 minikube 安装。
- en: External Vault storage
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部 Vault 存储
- en: 'We will proceed with creating a Vault instance, which will be run through a
    Docker container. We can run Vault using Docker Compose:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续创建一个 Vault 实例，它将在 Docker 容器中运行。我们可以使用 Docker Compose 运行 Vault：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can run Vault using the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行 Vault：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another solution is to run Vault by using a plain Docker command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是通过使用普通的 Docker 命令运行 Vault：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is no difference in the outcome of those two commands. Compose has the
    convenience of being just one file, but standalone docker commands also work as
    well. It is a matter of preference.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令的结果没有区别。Compose 的便利性在于它只有一个文件，而独立的 Docker 命令也可以正常工作。这完全是个人偏好问题。
- en: It is important to understand that we run Vault in development mode for debugging
    purposes. This is not a secure way to run Vault, which we will see in the *Development
    mode versus production mode* section of this chapter. Development mode will be
    used to make our example use case simpler.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，我们在开发模式下运行 Vault 是为了调试目的。这并不是一种安全的运行 Vault 的方式，我们将在本章的 *开发模式与生产模式* 部分看到这一点。开发模式将用于使我们的示例用例更简单。
- en: Let us examine Vault. We specified the root token; this is a token with root
    permissions. We also set the level of logging to `debug`. This is to help us with
    troubleshooting our installation. The `VAULT_DEV_LISTEN_ADDRESS` is the address
    to bind when in development mode. For now, this is sufficient to proceed with
    integrating with Kubernetes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下 Vault。我们指定了 root token，这是一个具有 root 权限的令牌。我们还将日志级别设置为 `debug`，以帮助我们进行安装故障排除。`VAULT_DEV_LISTEN_ADDRESS`
    是在开发模式下绑定的地址。现在，这足以继续与 Kubernetes 集成。
- en: Installing Vault on Kubernetes
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上安装 Vault
- en: To be able to integrate Vault with Kubernetes, we need to install the Vault
    binaries. The easiest way to do so is through a Helm chart.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将 Vault 与 Kubernetes 集成，我们需要安装 Vault 二进制文件。最简单的方式是通过 Helm 图表。
- en: 'First, we shall acquire a reference for our Vault installation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将获取我们的 Vault 安装的参考：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we will install Vault on Kubernetes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在 Kubernetes 上安装 Vault：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We installed the Vault package on Kubernetes and set an external Vault address
    that Kubernetes will point to. Also, we enabled the CSI since we will show the
    CSI capabilities in another example. To check that our installation was successful,
    we can check whether the deployment of `vault-agent-injector` is in our cluster.
    By using `kubectl`, we can identify whether a `vault-agent-injector` deployment
    exists:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Kubernetes 上安装了 Vault 包，并设置了 Kubernetes 将指向的外部 Vault 地址。此外，我们启用了 CSI，因为我们将在另一个示例中展示
    CSI 功能。要检查我们的安装是否成功，我们可以检查 `vault-agent-injector` 是否已部署在我们的集群中。通过使用 `kubectl`，我们可以判断是否存在
    `vault-agent-injector` 部署：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let us understand how the Vault Agent Injector works.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下 Vault Agent Injector 的工作原理。
- en: Vault Agent Injector
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Vault Agent Injector
- en: If we examine the Vault Agent Injector, we shall see that it uses a specific
    service account, `vault-agent-injector`. This component is responsible for changing
    the Pod specifications so agent containers can be included. These Vault Agent
    containers render Secrets from Vault to a shared memory volume.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 Vault Agent Injector，将会看到它使用了一个特定的服务账户 `vault-agent-injector`。这个组件负责更改
    Pod 规格，以便可以包含代理容器。这些 Vault Agent 容器将 Vault 中的 Secrets 渲染到共享内存卷中。
- en: 'On an initialization of a Pod that uses Vault Secrets, the following actions
    occur:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个使用 Vault Secrets 的 Pod 初始化时，以下操作将发生：
- en: The agent will identify the Pod that uses the Vault Secrets.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理将识别使用 Vault Secrets 的 Pod。
- en: The Pod specification will be changed and will include the Vault Agent containers.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pod 规格将被更改，并将包括 Vault Agent 容器。
- en: The Vault init container will fetch the Secrets and attach them to the Pod as
    shared memory volume.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vault 初始化容器将提取 Secrets，并将它们附加到 Pod 作为共享内存卷。
- en: If the Secrets change in the Vault, the Vault Sidecar Injector will change the
    Secrets.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Vault 中的 Secrets 发生变化，Vault Sidecar Injector 会改变这些 Secrets。
- en: The `vault-agent-injector` Pod is assigned the `vault-agent-injector-clusterrole`
    role.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`vault-agent-injector` Pod 被分配了 `vault-agent-injector-clusterrole` 角色。'
- en: 'We can see the `vault-agent-injector-clusterrole` cluster role:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `vault-agent-injector-clusterrole` 集群角色：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `vault-agent-injector` is registered to Kubernetes as a `vault-agent-injector`
    will intercept the creation request and rewrite the Pod definition.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`vault-agent-injector` 被注册到 Kubernetes，作为一个 `vault-agent-injector`，它将拦截创建请求并重写
    Pod 定义。'
- en: 'The Vault annotations would be like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 注释将如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see, we enable the injection method. Then, we specify the Vault role
    that will be used to fetch the Secrets and the Secrets that will be fetched:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们启用了注入方法。然后，我们指定将用于获取密钥的 Vault 角色以及将要获取的密钥：
- en: '![Figure 11.1 – Vault Injector and application hosted on Kubernetes](img/B20970_11_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Vault Injector 和托管在 Kubernetes 上的应用程序](img/B20970_11_01.jpg)'
- en: Figure 11.1 – Vault Injector and application hosted on Kubernetes
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Vault Injector 和托管在 Kubernetes 上的应用程序
- en: By rewriting the Pod definition, the Pod will now contain Vault Agent containers.
    The Vault Agent containers will then interact with Vault to retrieve the Secrets
    and inject them into the Pod.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写 Pod 定义，Pod 现在将包含 Vault Agent 容器。Vault Agent 容器将与 Vault 交互以检索密钥并将其注入到 Pod
    中。
- en: Vault service account and Kubernetes authentication
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Vault 服务账户和 Kubernetes 身份验证
- en: For Vault to interact with Kubernetes, it must use a service account. By installing
    the Vault Helm package, a service account will also be created. The service account
    is named `vault`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Vault 与 Kubernetes 交互，它必须使用服务账户。通过安装 Vault Helm 包，也将创建一个服务账户。该服务账户命名为 `vault`。
- en: We need to create a token for that service account. From [*Chapter 2*](B20970_02.xhtml#_idTextAnchor031),
    *Walking through Kubernetes Secrets Management Concepts*, we know that in new
    versions of Kubernetes, we must create a secret for the service account by ourselves.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为该服务账户创建一个 token。根据[*第 2 章*](B20970_02.xhtml#_idTextAnchor031)《Kubernetes
    密钥管理概念解析》，我们知道在 Kubernetes 的新版本中，我们必须自己为服务账户创建密钥。
- en: 'Let’s create the secret for the service account. We will create a YAML file
    with the following specifications:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为服务账户创建密钥。我们将创建一个 YAML 文件，内容如下：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we shall apply the YAML file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将应用 YAML 文件：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The secret will be created, and we should be able to use it for Vault. Now we
    should configure Vault to enable the Kubernetes authentication.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥将被创建，我们应该能够将其用于 Vault。现在我们应该配置 Vault 以启用 Kubernetes 身份验证。
- en: Kubernetes authentication
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kubernetes 身份验证
- en: We can authenticate Vault by using a Kubernetes service account token. This
    is the Kubernetes auth method. Essentially, we configure a Kubernetes service
    account token on Vault. Then, this service account token is used to interact with
    the Kubernetes API. To enable this, we need to have the auth method enabled on
    Vault.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Kubernetes 服务账户 token 来验证 Vault。这是 Kubernetes 身份验证方法。实际上，我们在 Vault
    上配置一个 Kubernetes 服务账户 token，然后使用该 token 与 Kubernetes API 交互。为了启用此功能，我们需要在 Vault
    上启用身份验证方法。
- en: 'The following steps should be executed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤应按顺序执行：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us see how this works behind the scenes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在后台是如何工作的：
- en: A service account is configured on Vault. It has the permissions to interact
    with the Kubernetes API and execute TokenReview requests.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vault 上配置了一个服务账户。它具有与 Kubernetes API 交互并执行 TokenReview 请求的权限。
- en: A role is created on Vault with permissions to interact with a secret residing
    in Vault. The role is mapped to a Kubernetes service account.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vault 上创建一个角色，具有与 Vault 中的密钥交互的权限。该角色与一个 Kubernetes 服务账户映射。
- en: A Pod is created and gets assigned the service account we created in the previous
    step. The Vault Injector issues a request to Vault using the service account JWT
    in order to fetch the secret from Vault.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Pod，并为其分配我们在上一步创建的服务账户。Vault Injector 使用该服务账户的 JWT 发出请求，以便从 Vault 获取密钥。
- en: Vault issues a TokenReview request to the Kubernetes API in order to validate
    the JWT token.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault 向 Kubernetes API 发出 TokenReview 请求，以验证 JWT token。
- en: Kubernetes validates the token.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 验证 token。
- en: Vault checks whether the service account mapped to the token is mapped to a
    role with access to the secret requested.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault 检查与 token 关联的服务账户是否与有权限访问所请求密钥的角色相匹配。
- en: Vault responds with the secret value.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault 返回密钥值。
- en: The Vault Injector injects the secret into the Pod.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault Injector 将密钥注入到 Pod 中。
- en: 'The following is a diagram of the flow we discussed so far:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们到目前为止讨论的流程图：
- en: '![Figure 11.1 – Kubernetes auth flow](img/B20970_11_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Kubernetes 身份验证流程](img/B20970_11_02.jpg)'
- en: Figure 11.2 – Kubernetes auth flow
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Kubernetes 身份验证流程
- en: We configured Kubernetes authentication. One of the problems we will face is
    that `$KUBE_HOST` points to `localhost`; thus, the certificate is mapped to `localhost`.
    This can be an issue since Vault can access minikube through the Docker host address,
    thus a different address from `localhost`. For this reason, we shall use the `proxy`
    file we mounted previously. The port will have to change with the port of the
    `$KUBE_HOST`, which changes dynamically.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了 Kubernetes 身份验证。我们将面临的问题之一是 `$KUBE_HOST` 指向 `localhost`，因此证书映射到 `localhost`。这可能会成为一个问题，因为
    Vault 可以通过 Docker 主机地址访问 minikube，而该地址与 `localhost` 不同。因此，我们将使用之前挂载的 `proxy` 文件。端口将根据
    `$KUBE_HOST` 的端口动态变化而改变。
- en: 'On another terminal, we shall execute the following commands and enable port
    forwarding:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端上，我们将执行以下命令并启用端口转发：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since this form of authentication involves many steps, auditing will help to
    increase our observability:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种身份验证方式涉及多个步骤，审计将有助于提高我们的可观察性：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The audit log file at `/tmp/vault_audit.log` can be tailed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`/tmp/vault_audit.log` 的审计日志文件可以通过以下命令查看：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since authentication is enabled and we have configured the service account needed,
    we should proceed and provide permissions for Vault to certain service accounts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于身份验证已启用并且我们已配置所需的服务账户，我们应该继续为 Vault 提供对某些服务账户的权限。
- en: Vault policies and bindings
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Vault 策略和绑定
- en: The benefit of using a secret provider such as Vault is the fact that we can
    store our Secrets and provide fine-grained policies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Vault 这样的秘密提供者的好处在于，我们可以存储秘密并提供细粒度的策略。
- en: 'For example, we shall store the following secret in Vault:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将在 Vault 中存储以下秘密：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We would like to have a restrictive read-only policy for the secret.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为该秘密设置一个严格的只读策略。
- en: 'Thus, we shall implement a policy with read-only permissions to the `secret/webapp/admin`
    secret:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将实现一个具有只读权限的策略，用于访问 `secret/webapp/admin` 秘密：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The policy is in place, so if we want certain workloads to be able to use this
    policy, we need to declaratively specify so. In our case, we shall have a Kubernetes
    service account mapped to a Pod that would require Secrets from Vault. The service
    account name would be `simple-app`. Our next step would be to bind the policy
    we created previously with that service account:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 策略已经到位，因此，如果我们希望某些工作负载能够使用此策略，我们需要明确指定。在我们的例子中，我们将有一个 Kubernetes 服务账户映射到一个需要
    Vault 中秘密的 Pod。服务账户的名称为 `simple-app`。我们的下一步是将之前创建的策略绑定到该服务账户：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we should create that service account on Kubernetes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在 Kubernetes 上创建该服务账户：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This service account would be used by Vault Injector to inject the Secrets
    into the application. Provisioning the service account alone is not sufficient
    enough to interact with Vault. A cluster role binding is required:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务账户将被 Vault Injector 用来将秘密注入到应用程序中。仅仅配置服务账户不足以与 Vault 交互，还需要一个集群角色绑定：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`auth-delegator` is a role that allows delegated authentication and authorization
    checks. This way, the service account we configured on Vault can issue a TokenReview
    request for a JWT token that is bound to the `simple-app` service account.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth-delegator` 是一个角色，允许委托身份验证和授权检查。通过这种方式，我们在 Vault 上配置的服务账户可以发出一个 TokenReview
    请求，以获取绑定到 `simple-app` 服务账户的 JWT token。'
- en: Using Vault Secrets in an application
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在应用程序中使用 Vault 秘密
- en: The `simple-app` service account will have the `auth-delegator` cluster role.
    The role enables delegated authentication and checks. Vault would be able to perform
    delegated authentication.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple-app` 服务账户将拥有 `auth-delegator` 集群角色。该角色启用委托身份验证和检查。Vault 将能够执行委托身份验证。'
- en: 'We shall create the application that will fetch the secret:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序来获取秘密：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The highlighted annotations used are crucial for `vault-agent-injector` to rewrite
    the Pod configuration so that the Vault initialization containers will take effect.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的高亮注解对于 `vault-agent-injector` 来说至关重要，它会重写 Pod 配置，以便 Vault 初始化容器生效。
- en: 'Once our application is up and running, we can now check the credentials:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的应用程序启动并运行，我们现在可以检查凭证：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Overall, we managed to interact with Vault in a secure way without having to
    mount any Vault-specific credentials to Kubernetes Secrets and thus on etcd. Instead,
    we relied on using the Kubernetes auth method supported by Vault. Now we can finally
    inject our credentials into the application by using the Vault sidecar container.
    However, Vault also supports another method of injecting Secrets into Kubernetes:
    the familiar CSI Driver method.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们成功地以安全的方式与 Vault 进行交互，而无需将任何 Vault 特定的凭据挂载到 Kubernetes Secrets 中，进而也不会出现在
    etcd 上。相反，我们依赖于使用 Vault 支持的 Kubernetes 身份验证方法。现在，我们可以通过使用 Vault sidecar 容器最终将凭据注入到应用程序中。不过，Vault
    也支持另一种将 Secrets 注入 Kubernetes 的方法：熟悉的 CSI Driver 方法。
- en: Vault and CSI Driver
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vault 和 CSI Driver
- en: Thanks to previous chapters, we are familiar with the Secret Store CSI Driver.
    Vault also enables us to use this approach. Using the CSI Driver is a different
    approach to mounting the Secrets from Vault on a Pod; however, it benefits from
    the same components. Since we have the Kubernetes auth method configured, we have
    the Vault authentication requirements tackled.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了前几章的内容，我们已经熟悉了 Secret Store CSI Driver。Vault 也让我们能够使用这种方式。使用 CSI Driver 是一种将
    Vault 中的 Secrets 挂载到 Pod 上的不同方法；然而，它受益于相同的组件。由于我们已配置 Kubernetes 身份验证方法，我们已经解决了
    Vault 身份验证的需求。
- en: 'However, we do need to have the `secrets-store-csi-driver` package installed.
    We shall execute the following Helm commands:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实需要安装`secrets-store-csi-driver`包。我们将执行以下 Helm 命令：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to create `SecretProviderClass` pointing to the Secrets located
    in Vault:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建指向 Vault 中 Secrets 的 `SecretProviderClass`：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next step is to provision the app, which will use the CSI provider:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置应用程序，它将使用 CSI 提供者：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We managed to securely integrate Vault with Kubernetes. We achieved this using
    the CSI and Vault Injector methods. There is another method to integrate Kubernetes
    workloads with Vault and this is by running an installation of Vault on Kubernetes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地将 Vault 安全地与 Kubernetes 集成。我们通过 CSI 和 Vault Injector 方法实现了这一点。还有一种将 Kubernetes
    工作负载与 Vault 集成的方法，那就是在 Kubernetes 上运行 Vault 安装。
- en: Vault hosted on Kubernetes
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vault 托管在 Kubernetes 上
- en: In certain cases, a Vault cluster might be hosted on Kubernetes. It is an approach
    with several benefits. From a maintenance perspective, you take advantage of Kubernetes,
    and from a latency perspective, it can be faster, provided that the previous Vault
    installation was deployed on another network.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Vault 集群可能会托管在 Kubernetes 上。这是一种具有多种优点的方式。从维护角度来看，你可以利用 Kubernetes 的优势，而从延迟角度来看，只要先前的
    Vault 安装是在另一个网络上部署的，它会更快。
- en: We shall do the installation through minikube.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 minikube 进行安装。
- en: 'We shall configure the values for the Vault installation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 Vault 安装配置值：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Due to running Vault on minikube, we do not have the option to run on multiple
    nodes. Thus, we disable the network affinity. Also, we shall run Vault with high
    availability enabled using three replicas:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Vault 运行在 minikube 上，我们无法选择在多个节点上运行。因此，我们禁用了网络亲和性。同时，我们将启用高可用性并使用三个副本来运行
    Vault：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By running Vault in a high availability mode, the Raft consensus algorithm is
    used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在高可用模式下运行 Vault，将使用 Raft 一致性算法。
- en: Take note that Vault is installed using `StatefulSet` and the default number
    is `3` nodes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Vault 是通过 `StatefulSet` 安装的，默认节点数为 `3` 个。
- en: 'If we check the logs, we shall see that Vault is not initialized:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看日志，我们会看到 Vault 尚未初始化：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now need to initialize Vault:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要初始化 Vault：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will create the `cluster-keys.json` file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 `cluster-keys.json` 文件。
- en: 'Let us see the contents of the cluster key:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看集群密钥的内容：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our next step is to unseal the vault using the unseal key:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是使用解封密钥来解封 Vault：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we need to join the nodes one by one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们需要逐个加入节点：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By joining the nodes on the cluster, the leader election process should start
    taking place.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过加入集群中的节点，领导者选举过程应该会开始进行。
- en: 'Now we have to unseal the other nodes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须解封其他节点：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that unsealing has been done, we can start adding data to Vault.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 解封操作完成后，我们可以开始向 Vault 中添加数据。
- en: 'A port forward on Kubernetes should be effective:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上进行端口转发应该是有效的：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, execute the following commands:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行以下命令：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let us stop forwarding to `vault-0` and forward to another node:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止转发到 `vault-0` 并转发到另一个节点：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also evaluate whether we can fetch the Secrets:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会评估是否能够获取 Secrets：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As expected, we got our Secrets:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到了我们的 Secrets：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The Secrets were stored and replicated through the node.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets 已经通过节点存储并复制。
- en: Take note that in this example we enabled the `kv-v2` engine. The engine allows
    us to have multiple versions of Secrets. We will examine this functionality in
    the following section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个示例中，我们启用了`kv-v2`引擎。该引擎允许我们拥有多个版本的机密。我们将在接下来的部分中探讨此功能。
- en: We read through an overview of running Vault on Kubernetes, which covered aspects
    of running Vault in production mode. Therefore, it is worth noting the differences
    between running Vault in development mode and in production mode.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们阅读了关于在Kubernetes上运行Vault的概述，其中涉及了在生产模式下运行Vault的各个方面。因此，值得注意的是，在开发模式和生产模式下运行Vault的区别。
- en: Development mode versus production mode
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发模式与生产模式
- en: 'We have run Vault so far in development mode. Development mode has certain
    characteristics:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在开发模式下运行Vault。开发模式有一些特征：
- en: Lack of high availability
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏高可用性
- en: Unsealed by default
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认解封
- en: Single unseal key
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一解封密钥
- en: Initialized by default
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认初始化
- en: Data stored in memory
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储在内存中
- en: When it comes to production, things should be different.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到生产时，情况应该有所不同。
- en: Production mode
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产模式
- en: In production mode, high availability should be in place. This is achieved with
    the Raft protocol. When Vault is run in production, we do not have a standalone
    Vault instance but a Vault cluster based on the Raft protocol. This comes with
    the benefit of high availability; if a Vault node goes down, the requests can
    be served by another node that is available. Also, we can have performance standby
    nodes, nodes that are used to serve read requests, thus achieving horizontal scalability
    on read operations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式下，应该具备高可用性。这是通过Raft协议实现的。当Vault在生产环境中运行时，我们不是使用独立的Vault实例，而是基于Raft协议的Vault集群。这样可以提供高可用性；如果某个Vault节点出现故障，其他可用节点可以继续处理请求。同时，我们还可以设置性能备份节点，这些节点用于处理读取请求，从而实现读取操作的横向扩展。
- en: Another thing that is much different in production mode is the initialization.
    When a Vault cluster is created it must be initialized.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式下，另一个非常不同的方面是初始化。当创建Vault集群时，必须进行初始化。
- en: Seal and unseal
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 密封和解封
- en: To be able to use a Vault installation, Vault needs to be initialized so that
    the storage backend will be prepared to receive data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用Vault安装，Vault需要进行初始化，以便存储后端准备好接收数据。
- en: 'During the initialization, the following happens:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，发生了以下情况：
- en: A root key is generated
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成根密钥
- en: The root key is stored in the storage backend
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根密钥存储在存储后端
- en: The root key is encrypted
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根密钥被加密
- en: The root key is stored in its encrypted form
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根密钥以加密形式存储
- en: Since the root key is encrypted, it cannot be used; it needs to be decrypted.
    In order to decrypt a root key, an unseal key is needed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于根密钥是加密的，它不能直接使用；需要解密。为了解密根密钥，需要使用解封密钥。
- en: The unseal key is not distributed as a single key. It uses Shamir’s secret-sharing
    algorithm ([https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing)).
    The unseal key is divided into parts called *shares*, and those shares are spread
    throughout the cluster. For the key to be reassembled, it requires several shares
    to be reassembled, which is called the **threshold**. Supposing an attacker steals
    some shares. It will not be possible to reconstruct the unseal key if the shares
    stolen are less than the threshold. By using Shamir’s secret sharing algorithm,
    Vault becomes more resilient to attacks that aim to acquire an unseal key.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解封密钥不会以单一密钥的形式分发。它使用Shamir的秘密共享算法（[https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing)）。解封密钥被分为多个部分，称为*份额*，这些份额分散在集群中。为了重新组装密钥，需要多个份额的合成，这就是所谓的**阈值**。假设攻击者窃取了一些份额。如果被窃取的份额少于阈值，则无法重构解封密钥。通过使用Shamir的秘密共享算法，Vault变得更加抗攻击，尤其是那些试图获取解封密钥的攻击。
- en: When we unseal a vault, we use the unseal keys to retrieve the root key unencrypted.
    Then, the root key will reside unencrypted in the Vault memory. Vault, by using
    the root key, will be able to decrypt the encryption key needed to store data
    in Vault.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解封Vault时，我们使用解封密钥来检索未加密的根密钥。然后，根密钥将以未加密的形式存储在Vault内存中。Vault通过使用根密钥，能够解密存储数据所需的加密密钥。
- en: When we run Vault in production mode, the initialization is manual. The initialization
    is executed using the `vault operator init` command. We can specify the number
    of shares—the unseal keys. As a result, we shall have printed some unseal keys
    and a root token. The unseal keys will be used to reassemble the root token. The
    root token is a token to which the root policy is attached. It is a token that
    can perform operations using the root key.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在生产模式下运行 Vault 时，初始化是手动进行的。初始化是通过执行 `vault operator init` 命令来完成的。我们可以指定分割份数——解封密钥。结果，我们将打印出一些解封密钥和一个根令牌。解封密钥将用于重新组合根令牌。根令牌是附带根策略的令牌。它是一个可以使用根密钥执行操作的令牌。
- en: In the case of an intrusion, it is feasible to seal the vault. By sealing, the
    root key will be purged from Vault’s memory, and the vault will no longer be able
    to decrypt the data residing in its storage. Furthermore, operations and Vault
    services will stop.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生入侵时，可以封存 Vault。通过封存，根密钥将从 Vault 的内存中清除，Vault 将无法解密存储中存在的数据。此外，操作和 Vault 服务将停止。
- en: High availability
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高可用性
- en: As we have seen by installing Vault on Kubernetes, we had three instances deployed
    by default in StatefulSets. This is because of Raft. Vault is a distributed system
    and Raft is the consensus algorithm used. The minimum number of nodes is three.
    With three nodes, a failure of one node can be tolerated, provided the other two
    nodes continue operating. To calculate the node tolerance, use the formula *(n-1)/2*,
    where *n* is the number of total nodes. For example, on a Vault installation consisting
    of five nodes, Vault will continue to be operational if two nodes fail. Once Vault
    is up and the nodes achieve consensus, data is written to the leader. The leader
    must replicate the data written to the followers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们通过在 Kubernetes 上安装 Vault 所看到的，默认情况下，Vault 会在 StatefulSets 中部署三个实例。这是因为使用了
    Raft。Vault 是一个分布式系统，Raft 是使用的共识算法。最小节点数为三个。拥有三个节点时，可以容忍一个节点的故障，前提是其他两个节点继续运行。要计算节点容忍度，可以使用公式
    *(n-1)/2*，其中 *n* 是总节点数。例如，在由五个节点组成的 Vault 安装中，如果两个节点发生故障，Vault 仍将继续运行。一旦 Vault
    启动并且节点达成共识，数据将写入领导节点。领导节点必须将写入的数据复制到跟随节点。
- en: '![Figure 11.2 – Replication of data](img/B20970_11_03.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 数据的复制](img/B20970_11_03.jpg)'
- en: Figure 11.3 – Replication of data
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 数据的复制
- en: Take note that if a write operation is tried on a follower, Vault will respond
    to the caller with the leader address. This way, the data will be written to the
    leader.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果尝试在跟随节点上执行写操作，Vault 将响应调用者并提供领导节点的地址。这样，数据将被写入领导节点。
- en: '![Figure 11.3 – Client redirect](img/B20970_11_04.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 客户端重定向](img/B20970_11_04.jpg)'
- en: Figure 11.4 – Client redirect
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 客户端重定向
- en: Raft on Vault tackles the problem of state synchronization, thus enabling the
    option of integrated storage. However, Vault can be backed by various forms of
    external storage.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 上的 Raft 解决了状态同步问题，从而启用了集成存储选项。然而，Vault 也可以使用各种形式的外部存储。
- en: Storage
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储
- en: Vault has various options for storage. There are options for external storage,
    which include databases such as Cassandra, DynamoDB, and more. Those options provide
    all the benefits that come with the underlying external storage. For example,
    in the case of DynamoDB, Vault can benefit from the backups, auditing, high availability,
    and all the other features that come with DynamoDB.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 提供了多种存储选项。包括外部存储的选项，例如 Cassandra、DynamoDB 等数据库。这些选项提供了底层外部存储所带来的所有好处。例如，在
    DynamoDB 的情况下，Vault 可以利用 DynamoDB 提供的备份、审计、高可用性以及其他所有功能。
- en: The other storage that is recommended is integrated storage. Integrated storage
    is maintained by HashiCorp. It is collocated with the host; this makes operations
    more efficient due to avoiding network hops. Also, by using integrated storage,
    the operational complexity is reduced and extra expertise on external storage
    is not required.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个推荐的存储是集成存储。集成存储由 HashiCorp 维护，和主机共同部署；这种方式由于避免了网络跳跃，使得操作更加高效。此外，使用集成存储可以减少操作复杂性，也不需要外部存储的额外专业知识。
- en: KV-2 vs KV-1 storage engine
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: KV-2 与 KV-1 存储引擎
- en: The `kv` Secrets engine is used to store Secrets in the physical storage in
    Vault. The latest version of `kv`, KV version 2, offers versioning on secret storage.
    By default, 10 versions of a secret are retained. The number is configurable.
    The older versions of a secret can be retrieved. Versioning increases storage
    costs. Deleting a version marks it as deleted, but the version is not physically
    deleted; it can be undeleted. To force a version’s physical deletion, the `destroy`
    command needs to be used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`kv` 机密引擎用于将机密存储在 Vault 的物理存储中。`kv` 的最新版本 KV 版本 2 提供了机密存储的版本控制功能。默认情况下，保留 10
    个版本的机密。这个数字是可配置的。可以检索机密的旧版本。版本控制会增加存储成本。删除某个版本会将其标记为已删除，但该版本并没有被物理删除；它可以恢复。要强制删除某个版本的物理存储，需要使用
    `destroy` 命令。'
- en: 'Here is an example of the `destroy` command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `destroy` 命令的示例：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first version of the `kv` engine, KV version 1, does not have the versioning
    feature; thus, the storage needs are less than for KV version 2.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`kv` 引擎的第一个版本，KV 版本 1，不具备版本控制功能，因此其存储需求比 KV 版本 2 少。'
- en: Policies
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: The principle of least permissions is crucial to ensuring the security of our
    Secrets. This is achieved by Vault policies.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最小权限原则对确保我们的机密安全至关重要。这是通过 Vault 策略实现的。
- en: By using policies, we can specify access privileges. Take, for example, the
    policies we created previously to fetch the Secrets from Vault on a Kubernetes
    application. We created the policy `devwebapp`, which will provide read capabilities
    to the `secret/devwebapp/config` path. This policy was attached to the service
    account of the Kubernetes application that would use that secret. Thus, the tokens
    generated for that service account would be able to read only the secret specified.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用策略，我们可以指定访问权限。以我们之前为 Kubernetes 应用程序创建的策略为例，我们创建了 `devwebapp` 策略，它将提供对 `secret/devwebapp/config`
    路径的读取权限。该策略被附加到将使用该机密的 Kubernetes 应用程序的服务账户上。因此，为该服务账户生成的令牌将仅能读取指定的机密。
- en: 'To summarize, we had an overview of HashiCorp Vault and how it can be integrated
    with Kubernetes. Next, we will focus on another secret manager provider: CyberArk
    Conjur.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们回顾了 HashiCorp Vault 以及如何将其与 Kubernetes 集成。接下来，我们将重点介绍另一个机密管理提供商：CyberArk
    Conjur。
- en: CyberArk Conjur
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CyberArk Conjur
- en: Conjur from CyberArk is a Secrets management solution. It has a commercial and
    an open source version.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: CyberArk 的 Conjur 是一个机密管理解决方案。它有商业版和开源版。
- en: 'Conjur as a solution comes with the following benefits:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 作为一个解决方案，具备以下优点：
- en: '**Role-based access** **control** (**RBAC**)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问** **控制**（**RBAC**）'
- en: Logging and auditing
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录和审计
- en: Integration with Kubernetes
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Kubernetes 集成
- en: High availability
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性
- en: Let us take a closer look at Conjur and see how it achieves these qualities.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 Conjur，并看看它是如何实现这些特性的。
- en: How Conjur works
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Conjur 的工作原理
- en: 'Conjur requires the following components:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 需要以下组件：
- en: Reverse Nginx proxy
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向 Nginx 代理
- en: Conjur application
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Conjur 应用程序
- en: Database
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: The reverse proxy is used to handle the TLS termination. It sits in front of
    the Conjur application. The Conjur application is a Ruby-based application and
    is responsible for securely storing Secrets. This application is backed by a PostgreSQL
    database.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理用于处理 TLS 终止。它位于 Conjur 应用程序前面。Conjur 应用程序是基于 Ruby 的应用程序，负责安全存储机密。该应用程序由
    PostgreSQL 数据库支持。
- en: High availability
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高可用性
- en: Conjur uses Raft to make high availability possible. It has a leader–follower
    architecture. The master will serve inbound traffic. In case of a master failure,
    a follower instance will be promoted to master.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 使用 Raft 协议实现高可用性。它采用领导者-跟随者架构。主节点将处理传入流量。如果主节点出现故障，跟随节点将提升为主节点。
- en: Server keys
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器密钥
- en: Conjur uses a data key, a Conjur UI key, and SSL keys. Those keys are generated
    during the Conjur server initialization plaintext. They should be encrypted to
    harden the initialization. This happens through the usage of a master key.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 使用数据密钥、Conjur UI 密钥和 SSL 密钥。这些密钥在 Conjur 服务器初始化时生成明文。为了增强初始化的安全性，这些密钥应进行加密。这是通过使用主密钥来实现的。
- en: By using the master key, the keys are encrypted.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用主密钥，密钥被加密。
- en: Before using the Conjur services, we need to unlock the keys using the master
    key. Once the encrypted keys are unlocked using the master key, they will reside
    on the Linux keyring and memory-based file system. Conjur offers the option to
    use AWS KMS or a hardware security module as a master key.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Conjur 服务之前，我们需要使用主密钥解锁密钥。一旦使用主密钥解锁加密的密钥，它们将存储在 Linux 密钥链和基于内存的文件系统中。Conjur
    提供了使用 AWS KMS 或硬件安全模块作为主密钥的选项。
- en: Storage
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储
- en: For storing Secrets, Conjur is backed by a database. Conjur uses PostgreSQL
    to store the Secrets. Conjur benefits from all the features that come with a PostgreSQL
    database. A PostgreSQL database comes with many features, such as replication,
    auditing, and fine-grained permissions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 用 PostgreSQL 数据库来存储秘密。Conjur 享受 PostgreSQL 数据库提供的所有功能，比如复制、审计和精细的权限管理。
- en: 'For example, a secret stored on Conjur can be found on the PostgreSQL database
    by querying the Secrets table:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，存储在 Conjur 中的一个秘密可以通过查询 Secrets 表在 PostgreSQL 数据库中找到：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This secret is unusable since it is encrypted. In case of a breach, the names
    of the Secrets would be leaked but not the actual value of the Secrets since the
    decryption key is needed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个秘密是不可用的，因为它已经被加密。在发生泄露时，秘密的名称可能会泄露，但实际的秘密值不会泄露，因为需要解密密钥。
- en: Versioning
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制
- en: Conjur also has the secret versioning feature. It keeps the last 20 versions
    of a secret.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 还具有秘密版本控制功能。它会保留一个秘密的最后 20 个版本。
- en: Policies
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略
- en: By using Conjur policies, we can define security rules that describe which roles
    have permissions to perform certain operations on a Conjur resource.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Conjur 策略，我们可以定义安全规则，描述哪些角色有权限对 Conjur 资源执行特定操作。
- en: 'Here’s an example of a Conjur policy:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Conjur 策略的示例：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, the `ExamplePolicy` policy provides to the non-human identity
    `webApp` the permission to read the `secretVar` variable.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`ExamplePolicy` 策略为非人类身份 `webApp` 提供了读取 `secretVar` 变量的权限。
- en: Audit logs
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审计日志
- en: As we have seen in previous chapters, audit logs are crucial when it comes to
    Secrets management.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中所看到的，审计日志在秘密管理中至关重要。
- en: 'From the documentation, we can see what an audit log in JSON format looks like:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从文档中，我们可以看到审计日志的 JSON 格式示例：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding log has all the information that we need to identify what happened
    on our Conjur server. `action` displays the action that took place, `auth` displays
    the entity that executed the action that took place, and `subject` displays the
    resource affected.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述日志包含了我们识别 Conjur 服务器上发生事件所需的所有信息。`action` 显示了发生的操作，`auth` 显示了执行该操作的实体，`subject`
    显示了受影响的资源。
- en: Kubernetes integration
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 集成
- en: Conjur has many options for enabling Kubernetes integration. One of them is
    the Kubernetes Authenticator Client.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 提供了多种启用 Kubernetes 集成的选项，其中之一是 Kubernetes 认证客户端。
- en: Kubernetes Authenticator Client
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kubernetes 认证客户端
- en: Conjur has the Kubernetes Authenticator Client. The Kubernetes application that
    uses Conjur Secrets has a sidecar container with a Conjur client. The client using
    the service account will authenticate with Conjur. Then, Conjur will issue a temporary
    token. The sidecar container will use that temporary token to retrieve the Secrets.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Conjur 拥有 Kubernetes 认证客户端。使用 Conjur Secrets 的 Kubernetes 应用程序有一个侧车容器，里面有 Conjur
    客户端。使用服务账户的客户端将与 Conjur 进行认证。然后，Conjur 将发放一个临时令牌。侧车容器将使用该临时令牌来检索秘密。
- en: In this section, we learned more about the secret manager Conjur. We identified
    its features and how it can integrate with Kubernetes. Those features, along with
    the features that we focused on in the previous chapters, form the standards for
    managing Secrets using an external secret store.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们更深入地了解了秘密管理器 Conjur，识别了它的功能以及它如何与 Kubernetes 集成。这些功能与我们在前几章中重点讨论的功能一起，构成了使用外部秘密存储来管理秘密的标准。
- en: Qualities for securely managing Secrets
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全管理秘密的特性
- en: As we have seen, there are certain qualities when it comes to storing external
    Secrets. In this chapter, we took a deep dive into the HashiCorp Vault and how
    it integrates with Kubernetes. We also had a look at another Secrets management
    provider, Conjur.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，存储外部秘密时有一些特性。在本章中，我们深入探讨了 HashiCorp Vault 及其如何与 Kubernetes 集成。我们还了解了另一个秘密管理提供商——Conjur。
- en: 'A secret manager needs to have certain qualities:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个秘密管理器需要具备某些特性：
- en: High availability
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性
- en: Encryption of data
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据加密
- en: Secure access
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全访问
- en: Versioning
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: RBAC
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: Integration with Kubernetes
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Kubernetes 的集成
- en: Auditing
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计
- en: Those qualities are essential to ensuring the secure and robust storage of an
    application’s Secrets.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性对于确保应用程序秘密的安全和稳健存储至关重要。
- en: High availability
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高可用性
- en: High availability is required to ensure our data is safe. It can protect us
    from losing any data in case of a service outage. It ensures business continuity.
    External secret stores such as Vault and Conjur achieve high availability by utilizing
    Raft, the popular consensus method. By having a consensus method, the cluster
    approach for availability is feasible; we can add multiple nodes to different
    data centers, which will form a cluster and share workloads. Thanks to this choice,
    in case of a failure, data is distributed in a way that can tolerate failures.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 高可用性是确保我们数据安全所必需的。它可以在服务中断的情况下保护我们免于丢失任何数据，确保业务的持续性。像 Vault 和 Conjur 这样的外部密钥存储通过利用
    Raft（一种流行的共识方法）来实现高可用性。通过采用共识方法，集群方式的高可用性成为可能；我们可以向不同数据中心添加多个节点，形成集群并共享工作负载。由于这一选择，万一出现故障，数据将以能够容忍故障的方式进行分布。
- en: Encryption of data
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据加密
- en: The data in an external secret store should be encrypted. The encryption keys
    that encrypt the data in the external secret store should also be encrypted. As
    we have seen previously, providers achieve this by implementing mechanisms such
    as Shamir’s secret sharing or by using a master key to encrypt the data encryption
    keys. Then, the data encryption keys are used to encrypt the actual data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 外部密钥存储中的数据应该进行加密。用于加密外部密钥存储中数据的加密密钥也应该加密。正如我们之前所见，提供者通过实现诸如 Shamir 秘密共享机制或使用主密钥加密数据加密密钥来实现这一点。然后，数据加密密钥被用来加密实际数据。
- en: Secure access
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全访问
- en: Access is secured with proper authentication methods and the principle of least
    privilege. We can achieve this with policies. External secret stores such as Vault
    and Conjur give us the option of policies. With policies, we can specify the operations
    that an identity can perform on a secret resource. This allows us to create fine-grained
    permissions that minimize the risks that come with overprivileged accounts that
    interact with the Secrets storage.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 访问通过适当的身份验证方法和最小权限原则来确保安全。我们可以通过策略实现这一点。像 Vault 和 Conjur 这样的外部密钥存储为我们提供了策略选项。通过策略，我们可以指定某个身份对密钥资源可以执行的操作。这使我们能够创建精细的权限，从而减少与过度授权帐户交互带来的风险。
- en: Versioning
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: All the secret store providers we worked with throughout this book offered versioning.
    Versioning is crucial in preventing accidental deletion and enabling smooth rotation.
    Secrets, by their nature, are sensitive, which makes rotation a necessity. Having
    a versioning of Secrets enables developer teams to proceed with the secret rotation
    operations in a robust and resilient way.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们使用的所有密钥存储提供者都提供了版本控制。版本控制对于防止意外删除和实现平滑的密钥轮换至关重要。由于秘密本质上是敏感的，这使得密钥轮换成为必要。拥有版本控制可以使开发团队以稳健且有韧性的方式进行密钥轮换操作。
- en: Integration with Kubernetes
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Kubernetes 的集成
- en: As we can see, integration with Kubernetes is achieved using the least permissions
    needed, and we did not store any sensitive keys in etcd. Instead, HashiCorp Vault
    or Conjur were managed through Kubernetes service accounts.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，与 Kubernetes 的集成是通过使用最小权限来实现的，并且我们没有将任何敏感的密钥存储在 etcd 中。相反，HashiCorp Vault
    或 Conjur 是通过 Kubernetes 服务帐户进行管理的。
- en: Secrets were injected into our applications without having to store them in
    etcd. Also, we did not have to store any Secrets that could communicate with the
    secret storage.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密被注入到我们的应用程序中，而无需将其存储在 etcd 中。此外，我们不需要存储任何能够与秘密存储通信的秘密。
- en: Auditing
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计
- en: Auditing is crucial for Secrets management. Through auditing, we achieve a record
    of activity towards the resources that reside on an external secret store. In
    all the options for external Secrets storage, auditing capabilities are present.
    In case of a breach or any malevolent action, auditing can help us identify the
    exposure and take remediation actions. Auditing can also help in debugging as
    well as ensure that the system operates properly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 审计对秘密管理至关重要。通过审计，我们能够记录对外部密钥存储资源的活动。在所有外部密钥存储选项中，审计功能都是存在的。在发生泄漏或任何恶意行为的情况下，审计可以帮助我们识别暴露的情况并采取补救措施。审计还可以帮助调试，并确保系统正常运行。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a deep dive into HashiCorp Vault, how it integrates
    with Kubernetes, and the different methods that can be used to access the Vault
    Secrets through Kubernetes workloads. We used Secrets from Vault either through
    the `vault-agent-injector` method or through the CSI Driver. Furthermore, we performed
    an installation of Vault on Kubernetes and identified the qualities for a Vault
    production deployment. We also learned about another Secrets provider, CyberArk
    Conjur, and its capabilities. In the next chapter, we will focus on the overall
    use cases of Secrets and the different approaches that we can follow for integrating
    with external secret stores. Also, we will take a deep dive into the approaches
    to integration with external secret stores.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 HashiCorp Vault，它如何与 Kubernetes 集成，以及可以通过 Kubernetes 工作负载访问 Vault
    秘密的不同方法。我们通过 `vault-agent-injector` 方法或 CSI 驱动程序来使用 Vault 中的秘密。此外，我们还在 Kubernetes
    上进行了 Vault 安装，并确定了 Vault 生产部署的特性。我们还了解了另一个秘密提供者 CyberArk Conjur 及其功能。在下一章中，我们将重点关注秘密的整体使用案例以及可以采用的不同方法，以便与外部秘密存储集成。我们还将深入探讨与外部秘密存储集成的方法。
