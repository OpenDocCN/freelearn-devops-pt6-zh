- en: '*Chapter 16*: Setting Up a CI/CD Pipeline and Image Registry'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：设置CI/CD管道和镜像注册表'
- en: This chapter covers **Continuous Integration/Continuous Delivery** (**CI/CD**)
    pipelines and how they work with Rancher to deploy applications in standardized
    and controlled processes, including how injecting secrets such as database credentials
    into a deployment allows the application to use them without giving application
    teams access to the raw credentials. Then, this chapter covers how to set up and
    configure Harbor as a Docker image repository, including how to configure Harbor
    as a pull-through cache to work around the Docker Hub pull limits. And finally,
    we'll look at how to integrate Harbor as a private registry in place of the Docker
    defaults.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了**持续集成/持续交付**（**CI/CD**）管道，以及它们如何与Rancher协同工作，通过标准化和可控的流程来部署应用程序，包括如何将数据库凭证等秘密信息注入到部署中，使得应用程序能够使用这些凭证，而无需给应用团队访问原始凭证的权限。然后，本章介绍了如何设置和配置Harbor作为Docker镜像仓库，包括如何将Harbor配置为拉取缓存，以绕过Docker
    Hub的拉取限制。最后，我们将讨论如何将Harbor集成作为私有注册表，替代Docker默认的注册表。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: What is a CI/CD pipeline?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是CI/CD管道？
- en: Rules for architecting a solution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构解决方案的规则
- en: How to deploy Drone and its runners in Kubernetes with Rancher
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Kubernetes中通过Rancher部署Drone及其执行器
- en: Injecting secrets into a pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密注入到管道中
- en: What is an image repository, and rules for architecting a solution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是镜像仓库，以及架构解决方案的规则
- en: How to deploy Harbor in Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Kubernetes中部署Harbor
- en: Integrating a private registry into Kubernetes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将私有注册表集成到Kubernetes中
- en: What is a CI/CD pipeline?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是CI/CD管道？
- en: CI refers to a coding philosophy and practices that encourage developers to
    frequently commit code to version control systems in software development. The
    goal is your applications and environment are defined as code commonly called
    **Infrastructure as Code** (**IaC**) or **Platform as Code** (**PaC**). As applications
    move from traditional monolithic architecture to more cloud-native microservice
    architecture, building, packaging, and testing applications become more complex.
    CI addresses this issue by focusing on being consistent and automated. This is
    done by moving these steps into a software framework such as Drone, which we'll
    be covering in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CI指的是一种编码哲学和实践，鼓励开发人员在软件开发中频繁地将代码提交到版本控制系统。其目标是将你的应用程序和环境定义为代码，这通常被称为**基础设施即代码**（**IaC**）或**平台即代码**（**PaC**）。随着应用程序从传统的单体架构转向更具云原生特性的微服务架构，构建、打包和测试应用程序变得更加复杂。CI通过专注于一致性和自动化来解决这个问题。通过将这些步骤集成到像Drone这样的软件框架中，我们可以自动化整个过程，本章将对此进行讲解。
- en: Of course, CI is only the first half of the solution, with the other half being
    CD. The idea is that once an application has been compiled, tested, and packaged,
    we need a way to publish the application and its changes to our environments in
    a consistent and repeatable fashion. Because Kubernetes uses a desired state-driven
    technology, we only need to modify the desired configuration if we want to change
    something about our cluster. Kubernetes takes care of making the current state
    match the desired state. We covered how this process works back in [*Chapter 2*](B18053_02_Epub.xhtml#_idTextAnchor025),
    *Rancher and Kubernetes High-Level Architecture*. CD takes advantage of Kubernetes
    by allowing an application developer to define their application as a YAML file
    or Helm chart. We can deploy to our cluster in a repeatable way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CI只是解决方案的前半部分，后半部分是CD。其思想是，一旦应用程序经过编译、测试和打包，我们需要一种方式以一致且可重复的方式将应用程序及其变更发布到我们的环境中。由于Kubernetes使用的是期望状态驱动的技术，我们只需要修改期望配置，如果我们想改变集群中的某些内容，Kubernetes会自动确保当前状态与期望状态相符。我们在[*第2章*](B18053_02_Epub.xhtml#_idTextAnchor025)中介绍了这一过程，*Rancher和Kubernetes高级架构*。CD通过允许应用程序开发人员将应用定义为YAML文件或Helm图表，利用Kubernetes的优势。我们可以以可重复的方式将应用部署到我们的集群中。
- en: Of course, it's common to put both parts (CI/CD) together into what we call
    a pipeline, and the best way I have found to walk through a pipeline from start
    to finish is shown here.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通常将CI/CD两个部分组合成我们所说的管道，而我发现的最佳方式是从头到尾逐步讲解管道，如下所示。
- en: '![Figure 16.1 – Example CI/CD pipeline'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 – 示例CI/CD管道'
- en: '](img/B18053_16_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_01.jpg)'
- en: Figure 16.1 – Example CI/CD pipeline
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 示例CI/CD管道
- en: 'These are the high-level steps for most CI/CD pipelines with a description
    of each step:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是大多数CI/CD管道的高层步骤，并对每个步骤进行了描述：
- en: '**Step 1 (Dev Team)**: The process starts with a developer checking the code
    for the repo (GitHub, GitLab, Git server) and making a change to the code, that
    is, fixing a bug, adding a feature, and so on. At this point, the developer might
    run the application locally to test their changes. But when developers are ready,
    they''ll commit their changes to the repo.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1（开发团队）**：流程从开发者检查仓库（GitHub、GitLab、Git 服务器）的代码开始，开发者进行代码修改，即修复一个 bug、添加一个功能等。在此时，开发者可能会在本地运行应用程序来测试他们的更改。但当开发者准备好后，他们将把更改提交到仓库。'
- en: '**Step 2 (Git Commit)**: In this step, a developer would generally create a
    branch for their new feature or bug fix. Depending on the setup, the developer
    might fork the repository and push their changes into the fork instead of the
    main repository. But the critical part of understanding this step is that the
    Git commit is the only way to make changes to your code, application, deployment,
    and infrastructure.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2（Git 提交）**：在此步骤中，开发者通常会为新的功能或 bug 修复创建一个分支。根据设置，开发者可能会将仓库进行分叉，并将更改推送到分叉仓库，而不是主仓库。但理解这一步骤的关键是，Git
    提交是对你的代码、应用程序、部署和基础设施进行更改的唯一方式。'
- en: '**Step 3 (Git Repo)**: Once the Git commit has been pushed into the repository,
    the repository takes over. The first step is to validate that the developer has
    permission to push changes into the repository. For example, they might have permission
    to commit changes to the feature branch but not to the main/master branch. Then,
    typically, the next step would be to create a **Pull Request** (**PR**), which
    initiates a request to merge the changes from one branch/fork into another. For
    example, you might create a PR to merge your feature into the main branch. It''s
    common at this point for the CI/CD software to come into the picture. For example,
    you are using GitHub and Drone. Once you create a PR request, GitHub will send
    an HTTP request, called a webhook, to your Drone server, which initiates the next
    step.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3（Git 仓库）**：一旦 Git 提交被推送到仓库，仓库接管管理。第一步是验证开发者是否有权限将更改推送到仓库。例如，他们可能有权限提交更改到功能分支，但没有权限提交到主分支（main/master）。然后，通常的下一步是创建一个**Pull
    Request**（**PR**），它发起将一个分支/派生库的更改合并到另一个分支的请求。例如，你可能会创建一个 PR 将你的功能合并到主分支。这时，CI/CD
    软件通常会参与进来。例如，你正在使用 GitHub 和 Drone。一旦你创建了一个 PR 请求，GitHub 会发送一个 HTTP 请求，称为 webhook，发送到你的
    Drone 服务器，进而启动下一步操作。'
- en: '**Step 4 (Build)**: This step is where stuff starts happening. We will continue
    the Drone example where the Drone server has received a webhook from GitHub, which
    includes some details about the change to the repo. For example, it consists of
    the repo name, branch, commit hash, and commit message. But it is important to
    note that it doesn''t include the code.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4（构建）**：在这个步骤中，事情开始发生。我们将继续使用 Drone 的例子，在这个例子中，Drone 服务器已经从 GitHub 收到了
    webhook，其中包含关于仓库更改的一些细节。例如，它包含仓库名称、分支、提交哈希和提交消息。但需要注意的是，它不包括代码内容。'
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to see what is included in the webhook payload, please see
    GitHub's official documentation at [https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads](https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看 webhook 载荷中包含的内容，请参阅 GitHub 的官方文档：[https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads](https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads)。
- en: The process might change depending on your pipeline software, but in general,
    the first step is to clone the code repository into a temporary location. This
    is why your pipeline server needs access to your code repository. The second step
    is to load the pipeline configuration file for Drone, which is `.drone.yml`. This
    file stores the steps that will be used during the build process. An example might
    be pulling down any dependencies and running some commands to compile your binaries.
    It is important to note that most pipeline software includes prebuilt plugins/modules
    for compiling common languages such as Go, npm, C++, and so on. For Drone, you
    can find a list at [https://plugins.drone.io](https://plugins.drone.io), but one
    of the nice things about modern pipeline software such as Drone and GitHub Actions
    is they use containers for these plugins/modules, so making your custom steps
    can be a straightforward process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 流程可能会根据您的管道软件而变化，但一般来说，第一步是将代码存储库克隆到临时位置。这就是为什么您的管道服务器需要访问您的代码存储库。第二步是加载 Drone
    的管道配置文件，即`.drone.yml`。此文件存储了构建过程中将使用的步骤。例如，可能会拉取任何依赖项并运行一些命令来编译您的二进制文件。重要的是要注意，大多数管道软件都包含预构建的插件/模块，用于编译诸如
    Go、npm、C++ 等常见语言。对于 Drone，您可以在 [https://plugins.drone.io](https://plugins.drone.io)
    找到一个列表，但是像 Drone 和 GitHub Actions 这样的现代管道软件之一的好处是它们使用容器来运行这些插件/模块，因此制作自定义步骤可以是一个简单的过程。
- en: You may ask, where does this build step run? The answer to that question depends
    on the software and where it's hosted. For example, this whole process might be
    in a cloud using something such as GitHub Actions, or if you are using self-hosted
    Drone, it'll be running on your own computer. These are typically called **runners**
    because they run your code. For the example we will cover later in this chapter,
    we will deploy Drone's runners in a Kubernetes cluster where it will create temporary
    pods for each build with sidecars for each step.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问，此构建步骤在哪里运行？这个问题的答案取决于软件以及它的托管位置。例如，整个过程可能在使用 GitHub Actions 等云端工具时进行，或者如果您正在使用自托管的
    Drone，则会在您自己的计算机上运行。这些通常被称为**运行器**，因为它们运行您的代码。例如，在本章后面我们将涵盖的示例中，我们将在 Kubernetes
    集群中部署 Drone 的运行器，它将为每个构建创建临时 pod，并为每个步骤创建 sidecar。
- en: '**Step 5 (Test)**: So far, we have the application built, but we need to test
    it and verify whether it''s working as planned. This step can be as simple as
    being compiled at the end of testing, or it can be as complex as deploying to
    a test cluster, then simulating end users using the application, and everything
    in-between. This step depends on your application and programming language. For
    example, Go has built-in testing for writing tests directly into the application.
    Like a LAMP (Linux, Apache, MySQL, and PHP) stack, applications might need a couple
    of different components, including a database, to start. At the same time, there''s
    the question of how easily you can test your application. For example, do you
    already have scripts to test logging in, running a report, making a test sale,
    and more? If you do, then in this step, you''ll want to create a process to run
    these tests. The idea is that you want to verify that whatever changes are part
    of this commit will not disrupt production.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5（测试）**：到目前为止，我们已经构建了应用程序，但我们需要测试它并验证它是否按计划工作。这一步骤可以简单到最后的编译测试，也可以复杂到部署到测试集群，然后模拟终端用户使用应用程序，以及中间的一切。这一步骤取决于您的应用程序和编程语言。例如，Go
    有内置的测试，可以直接编写到应用程序中进行测试。像 LAMP（Linux、Apache、MySQL 和 PHP）堆栈一样，应用程序可能需要几个不同的组件，包括数据库，才能启动。同时，还有一个问题，即您是否可以轻松地测试您的应用程序。例如，您是否已经有了测试登录、运行报告、进行测试销售等的脚本？如果有的话，在这一步骤中，您将希望创建一个流程来运行这些测试。总的想法是您希望验证此提交的任何更改不会影响生产环境。'
- en: '**Step 6 (Publish)**: Once all our testing is done and we''re ready to start
    spinning up our application in our Kubernetes cluster(s), we need to make the
    container images that we just created available to our clusters. We do this by
    publishing them to a Docker registry of some kind. Of course, there are several
    different solutions to this problem, some of which we''ll be covering later in
    this chapter. But the key thing to understand here is we need a location to publish
    images, whether that is Docker Hub, a simple private registry, or a more enterprise
    solution such as Harbor.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 6（发布）**：一旦我们完成所有测试，并准备好在 Kubernetes 集群中启动应用程序，我们需要将刚刚创建的容器镜像提供给集群。我们通过将镜像发布到某种
    Docker 注册表来实现这一点。当然，解决这个问题有多种不同的方案，其中一些将在本章后续讲解。但这里需要理解的关键是，我们需要一个发布镜像的位置，无论是
    Docker Hub、简单的私有注册表，还是像 Harbor 这样的企业级解决方案。'
- en: This step is pretty straightforward for Drone and most CI/CD software, mainly
    tagging the image(s) with a version/build number, then running the `docker push
    image…` command to your registry of choice. As part of publishing the images to
    our registry, it's common to do security scans looking for known vulnerabilities.
    For example, you might want to block all images that include software versions
    that are vulnerable to the Log4j (CVE-2021-44228) issue with most CI/CD software
    using a tool such as Clair, which handles this process and will alert or block
    images depending on the number of CVEs found and their severity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Drone 和大多数 CI/CD 软件而言，这一步是相当直接的，主要是为镜像添加版本/构建号标签，然后运行 `docker push image…`
    命令将镜像推送到所选的注册表。作为将镜像发布到注册表的一部分，通常会进行安全扫描，查找已知的漏洞。例如，您可能希望阻止所有包含易受 Log4j（CVE-2021-44228）漏洞影响的软件版本的镜像，大多数
    CI/CD 软件使用像 Clair 这样的工具来处理这一过程，并根据找到的 CVE 数量和严重性，发出警报或阻止镜像。
- en: '**Step 7 (Deploy)**: Once everything is ready, the fun part of deploying the
    application to our Kubernetes clusters comes into the picture. This step mainly
    is to create/prepare our deployment files, which could be as simple as a YAML
    file or as complex as a Helm chart, or even a mix of both. We will not dive too
    deep into Helm charts in this chapter, as we''ll cover that topic in the next
    chapter. This process mainly includes updating the image tags in our deployment
    file for the newly created images.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 7（部署）**：一旦一切准备就绪，应用程序部署到我们的 Kubernetes 集群的有趣部分就开始了。 这一步主要是创建/准备我们的部署文件，文件可以是简单的
    YAML 文件，也可以是复杂的 Helm 图表，甚至是两者的混合。在本章中，我们不会深入讨论 Helm 图表，因为这个话题会在下一章讲解。此过程主要包括更新部署文件中的镜像标签，以适应新创建的镜像。'
- en: At this point, our CI/CD starts the process of publishing our application to
    the cluster. This can, of course, be as simple as running the `kubectl apply -f
    deploy.yaml` command or can be as complicated as deploying a public Helm chart
    for the database, that is, `helm install mysql`, then verifying that the database
    is up and ready before running a Kubernetes job (a single-use pod that only runs
    once) to create the database, and finally loading our data from an S3 bucket.
    Then, eventually, we run `kubectl apply` to spin up our application and run some
    test commands to verify everything is working as expected. The essential item
    to understand about this step is that this step is how we give our developers
    access to our production Kubernetes cluster in a safe and controlled manner without
    giving them direct access to the cluster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的 CI/CD 已经开始将应用程序发布到集群的过程。 当然，这可以简单到运行 `kubectl apply -f deploy.yaml`
    命令，或者复杂到为数据库部署公共 Helm 图表，即 `helm install mysql`，然后在运行 Kubernetes 作业（一个仅运行一次的单次使用
    Pod）来创建数据库之前，验证数据库是否已经启动并准备好，最后从 S3 存储桶加载数据。然后，我们最终运行 `kubectl apply` 来启动我们的应用程序，并运行一些测试命令来验证一切是否按预期工作。需要理解的关键点是，这一步骤是我们如何以安全且受控的方式，给开发人员访问我们的生产
    Kubernetes 集群，而不直接给他们访问集群的权限。
- en: At this point, the pipeline is done, and we will start all over again for the
    next feature or bug fix. The big idea is that pipelines are designed to make this
    process repeatable and controllable, allowing developers to move fast but not
    break our clusters. In the next section, we will dive into creating a CI/CD solution,
    followed by an installation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，管道完成，我们将从头开始处理下一个功能或 bug 修复。核心思想是，管道的设计使得这一过程可以重复且可控，允许开发人员快速推进，但又不会破坏我们的集群。在下一节中，我们将深入探讨创建
    CI/CD 解决方案，并进行安装。
- en: Rules for architecting a solution
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构解决方案的规则
- en: Now that we understand what CI/CD is, we will go over designing a solution,
    including the pros and cons of standard designs. It is important to note that
    each environment/application is unique and will require tuning for the best experience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了 CI/CD 的概念，我们将讨论如何设计解决方案，包括标准设计的优缺点。需要注意的是，每个环境/应用都是独特的，可能需要进行调整以获得最佳体验。
- en: 'Before designing a solution, you should be able to answer the following questions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计解决方案之前，你应该能够回答以下问题：
- en: Does your application team already have a CI/CD solution that supports Kubernetes?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用团队是否已经有支持 Kubernetes 的 CI/CD 解决方案？
- en: Will a single team use this CI/CD solution, or will multiple teams share it?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否只有一个团队使用此 CI/CD 解决方案，还是多个团队共享它？
- en: How many pipelines/builds do you think will be created?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你认为会创建多少个管道/构建？
- en: What kind of deployment schedules do your developers follow?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的开发者遵循什么样的部署计划？
- en: Will they be making changes at any time, or will it be in big patches, that
    is, every Friday is *build day*?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们是否会随时进行更改，还是会进行大规模的补丁更新，也就是说，每个星期五是*构建日*？
- en: How important is speed to the pipeline process? Is it okay if a pipeline takes
    an hour or should it run in minutes?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过程的速度有多重要？如果一个管道需要一个小时运行，可以接受吗，还是它应该在几分钟内完成？
- en: Will you be using a self-hosted or **Software as a service** (**SaaS**) offering?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你们将使用自托管的还是**软件即服务**（**SaaS**）的方案？
- en: What software stack will you be deploying (Go, LAMP, Node.js, DotNet, and so
    on)?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你们将部署哪种软件栈（Go、LAMP、Node.js、DotNet 等）？
- en: What kind of tools/packages will you need to build your applications?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要哪些工具/软件包来构建你的应用？
- en: Do your build tools require special licensing?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的构建工具是否需要特殊的许可？
- en: What CPU architecture and OS family do you need to build on (Linux, Windows,
    AMD64, ARM)?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在哪种 CPU 架构和操作系统平台上构建（Linux、Windows、AMD64、ARM）？
- en: Is your code private or public?
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码是私有的还是公开的？
- en: Will the build processes and output need to be publicly accessible (most open
    source projects do)?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过程和输出是否需要公开访问（大多数开源项目是这样）？
- en: Will only internal employees create commits and publish them or is this a public
    project so outside users might be triggering builds?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有内部员工会创建提交并发布，还是这是一个公开项目，因此外部用户可能会触发构建？
- en: What is your budget for both software and hardware?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的软件和硬件预算是多少？
- en: Once we have answers to many of these questions, we can evaluate solutions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对这些问题有了答案，我们就可以评估解决方案。
- en: Drone
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Drone
- en: Drone is a Go-based application that performs all actions that are done within
    containers. Thus, it is a perfect fit for platforms such as Kubernetes, where
    launching containers is a breeze. Drone uses a server for management and orchestration,
    with runners handling the creation of containers for build tasks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Drone 是一个基于 Go 的应用程序，执行所有容器内的操作。因此，它非常适合像 Kubernetes 这样的平台，在这里启动容器非常简单。Drone
    使用服务器进行管理和编排，运行器负责创建用于构建任务的容器。
- en: 'The **pros** are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: Free for open source projects.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于开源项目是免费的。
- en: Verified good integration with GitHub, Bitbucket, and GitLab.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 GitHub、Bitbucket 和 GitLab 的集成已被验证良好。
- en: The Drone server and its runners are lightweight and can be deployed on low-end
    hardware such as a Raspberry Pi.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone 服务器及其运行器是轻量级的，可以部署在像 Raspberry Pi 这样的低端硬件上。
- en: Pipelines as code, meaning your pipeline becomes part of your application development.
    There is no need to change your pipeline configurations outside your source control.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将管道作为代码，这意味着你的管道成为应用开发的一部分。无需在源代码控制之外更改管道配置。
- en: Both internal and external secret management via Vault, KMS, and third parties.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Vault、KMS 和第三方进行内部和外部的秘密管理。
- en: Easy to use as the UI is easy to understand.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用起来很简单，因为界面易于理解。
- en: All plugins are containers meaning if you want to write your own, just create
    a Docker image to do whichever task you want.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有插件都是容器，这意味着如果你想编写自己的插件，只需创建一个 Docker 镜像来执行你想要的任何任务。
- en: The cloud and on-premise software are the same, so migration between the two
    is effortless.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云和本地软件是相同的，因此在两者之间迁移毫不费力。
- en: Scalability is built-in because all the builds run as containers that can easily
    be scaled out thanks to Kubernetes.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性是内建的，因为所有构建都作为容器运行，可以轻松地通过 Kubernetes 扩展。
- en: Drone was built to be on the public internet because many open source projects
    use Drone. Because of this and the fact that Drone is based on containers, it
    is safe and normal to have a Drone server publicly exposed, allowing better transparency
    with the public.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone 是为了在公共互联网中运行而构建的，因为许多开源项目使用 Drone。由于这一点，以及 Drone 基于容器的架构，公开暴露 Drone 服务器是安全且正常的，这也让公众能够更好地看到透明性。
- en: The Drone CLI has built-in support for local builds, which allows you to trigger
    a build locally on your machine without connecting to the Drone server. Because
    every task is a container, the Drone CLI just makes the same API calls to Docker
    as the runner would.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone CLI 内置了对本地构建的支持，允许你在本地机器上触发构建，而无需连接到 Drone 服务器。由于每个任务都是一个容器，Drone CLI
    仅通过与运行器相同的 API 调用与 Docker 交互。
- en: 'The **cons** are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**如下：'
- en: Build caching is not a thing with Drone. Because every build is a new container/pod,
    items from the previous builds are not available, meaning if you need to download
    a set of dependencies to run your build, you'll be downloading the same dependencies
    every time. Plugins such as drone-cache can help with this, but they are not the
    most reliable solutions and can force you to limit how you run builds.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone 不支持构建缓存。因为每次构建都是一个新的容器/Pod，前一次构建的内容无法使用，这意味着如果你需要下载一组依赖项来运行构建，你每次都会重新下载这些依赖项。像
    drone-cache 这样的插件可以帮助解决这一问题，但它们并不是最可靠的解决方案，而且可能迫使你限制构建运行的方式。
- en: It suffers from the big empty box problem because Drone is built to support
    almost any language/application stack. Everything is empty when you first get
    started with little to no framework guiding you. Some examples can be found in
    the Drone documentation, but you'll mostly be starting from zero.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它存在一个典型的“大空盒”问题，因为 Drone 被构建来支持几乎任何语言/应用堆栈。刚开始时，一切都是空的，几乎没有框架来指导你。可以在 Drone
    文档中找到一些示例，但你大多数时候都得从零开始。
- en: Drone has a reasonably active community but is still a newcomer to the CI/CD
    market, being created in 2014, but finding people with administrator knowledge
    can be difficult.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone 拥有一个相对活跃的社区，但它仍然是 CI/CD 市场的新人，创建于 2014 年，但找到具备管理员知识的人可能会很困难。
- en: There are no authentication providers outside your repository, meaning you can't
    point it to your Active Directory, LDAP, or SAML provider for authentication.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有可以用于身份验证的外部身份提供者，这意味着你不能将其指向 Active Directory、LDAP 或 SAML 提供者进行身份验证。
- en: Having a public Drone server instance is normal...but safety is relative. There
    are settings that can be used to restrict access to a specific GitHub organization,
    and also settings on access to secrets so that they can't be stolen by a malicious
    user via a rogue repository. These settings aren't configured out of the box.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个公共的 Drone 服务器实例是正常的……但安全性是相对的。可以使用一些设置来限制对特定 GitHub 组织的访问，也可以对机密的访问进行设置，以防止恶意用户通过恶意的仓库窃取这些机密。这些设置并不是开箱即用的。
- en: Drone has code maintenance issues as it takes quite a bit of patching and custom
    plugins to support specific workloads. For example, the default Kubernetes plugin
    is minimal, with users needing to create their custom plugins, such as [https://github.com/SupportTools/kube-builder](https://github.com/SupportTools/kube-builder).
    There is even a community fork of Drone called Woodpecker to address these issues.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone 存在代码维护问题，因为它需要大量的补丁和自定义插件来支持特定的工作负载。例如，默认的 Kubernetes 插件功能很简陋，用户需要创建自己的插件，例如
    [https://github.com/SupportTools/kube-builder](https://github.com/SupportTools/kube-builder)。甚至有一个社区分支的
    Drone 叫做 Woodpecker，旨在解决这些问题。
- en: There is no **High Availability** (**HA**) for the Drone server as the server
    uses an in-memory queue system. The Drone server will rely on Kubernetes to provide
    HA, that is, restarting and rescheduling a failed pod. As of writing, an HA feature
    is currently in beta, details of which can be found at [https://docs.drone.io/server/ha/overview/](https://docs.drone.io/server/ha/overview/).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone 服务器没有 **高可用性**（**HA**），因为服务器使用的是内存队列系统。Drone 服务器将依赖于 Kubernetes 提供 HA，即重新启动和重新调度失败的
    Pod。截至目前，HA 功能仍在测试版中，详细信息可以参考 [https://docs.drone.io/server/ha/overview/](https://docs.drone.io/server/ha/overview/)。
- en: Typically, I recommend Drone for cloud and Kubernetes native applications built
    with containers in mind from the start and a team that wants a GitOps workflow,
    as with open source projects that need public access.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我推荐将 Drone 用于那些从一开始就考虑容器的云原生和 Kubernetes 原生应用程序，以及希望实现 GitOps 工作流的团队，比如需要公开访问的开源项目。
- en: Jenkins
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins is a Java-based CI/CD tool that is built around automating the running
    of scripts and is sometimes called an automation platform that can support CI/CD.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个基于Java的CI/CD工具，旨在自动化运行脚本，有时被称为支持CI/CD的自动化平台。
- en: 'The **pros** are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: It has a deep history in DevOps and the CI/CD marketplace as it is the oldest
    tool in this list. It was created in 2011 under Oracle before being forked in
    2014 to become Jenkins.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins在DevOps和CI/CD市场中有着深厚的历史，它是此列表中最古老的工具。它最初由Oracle于2011年创建，2014年分叉后成为Jenkins。
- en: Because of the history of Jenkins, it has become the default when it comes to
    CI/CD, meaning a lot of software, plugins, and workflows are built around Jenkins
    first and then are adapted to other CI/CD tools.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Jenkins的发展历史，它已经成为CI/CD领域的默认工具，这意味着许多软件、插件和工作流都是围绕Jenkins构建的，然后才会适配到其他CI/CD工具。
- en: Jenkins has an extensive list of plugins (1,000+ at the time of writing) ranging
    from integrations into Nagios for monitoring, to Puppet for configuration management,
    to hooks into Jira for issue tracking.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins拥有丰富的插件列表（截至撰写时超过1000个），涵盖从Nagios集成监控，到Puppet进行配置管理，再到与Jira集成进行问题跟踪等功能。
- en: Because Jenkins is written in Java, it is portable, meaning the server can run
    on Windows or Linux, depending on your requirements.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为Jenkins是用Java编写的，它具有可移植性，这意味着服务器可以根据你的需求在Windows或Linux上运行。
- en: Jenkins has excellent plugins for test automation, such as `TestComplete Support`,
    which can simulate user actions such as opening a web page, running a desktop
    application, and so on. It is important to note that this is a third-party plugin.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins拥有优秀的测试自动化插件，例如`TestComplete Support`，它可以模拟用户行为，如打开网页、运行桌面应用程序等。需要注意的是，这是一个第三方插件。
- en: Jenkins has built-in support for some enterprise authentication providers, such
    as Active Directory, LDAP, SAML, and others.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins内置支持一些企业认证提供商，如Active Directory、LDAP、SAML等。
- en: Jenkins has built-in HA support using an active-standby setup.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins内置了高可用性（HA）支持，使用的是主动-备份设置。
- en: Enterprise/paid plugins typically come with excellent documentation and support.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业/付费插件通常附带优秀的文档和支持。
- en: 'The **cons** are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**如下：'
- en: Jenkins is built to be an enterprise product, meaning it assumes that it will
    have administrators to care for and feed it, that is, someone to kill stuck jobs,
    monitor resources, restart it when it gets stuck, and so on.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins是为企业产品构建的，这意味着它假设会有管理员来照顾和维护它，也就是说，需要有人来终止卡住的作业、监控资源、在出现问题时重新启动等。
- en: Community/free plugins typically come with little to no documentation and no
    option for paid support.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区/免费插件通常缺乏文档支持，并且没有付费支持选项。
- en: Jenkins has runners for Kubernetes to allow you to run tasks as pods in your
    cluster, but setting up and using this kind of runner can be challenging and requires
    the use of details that can be found at [https://plugins.jenkins.io/kubernetes/](https://plugins.jenkins.io/kubernetes/).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins为Kubernetes提供了运行器，可以让你将任务作为pods在集群中运行，但设置和使用这种类型的运行器可能具有挑战性，并且需要使用在[https://plugins.jenkins.io/kubernetes/](https://plugins.jenkins.io/kubernetes/)上可以找到的详细信息。
- en: Jenkins does have local builds, but you are running a local copy of the Jenkins
    server, meaning you have to go through all the work of setting it up and match
    your local configuration with your real Jenkins server.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins确实支持本地构建，但你实际上是在运行一个本地副本的Jenkins服务器，这意味着你需要完成所有的设置工作，并使本地配置与真实的Jenkins服务器相匹配。
- en: There's no SaaS/cloud-hosted option, meaning you'll need to install and manage
    the Jenkins server.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有SaaS/云托管选项，这意味着你需要安装和管理Jenkins服务器。
- en: The UI is clunky, not very user-friendly, and looks like a Java application
    from 10 years ago.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面较为笨重，使用起来不太友好，界面看起来像是十年前的Java应用程序。
- en: Typically, I recommend Jenkins for two reasons. The first reason is that it's
    already deployed and used in the customer's environment. This is because switching
    between pipelines can require a large amount of work, with the process being that
    you need to start over. The second reason is enterprise plugin support. Writing
    your own plugins can take time and resources that are better spent elsewhere.
    So, it's common for enterprise customers just to buy commercial plugins that work
    out of the box.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我推荐Jenkins有两个原因。第一个原因是它已经在客户的环境中部署并使用。这是因为在不同管道之间切换可能需要大量工作，过程就是需要重新开始。第二个原因是企业插件支持。编写自己的插件可能需要大量时间和资源，这些资源可以用于其他更有价值的事情。因此，企业客户通常直接购买开箱即用的商业插件。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Rancher did have its own pipeline solution called Rancher Pipelines, but as
    of Rancher v2.5, this feature has been deprecated and replaced by Fleet. Rancher
    Pipelines was built on top of Jenkins but integrated into Rancher. You can still
    enable it using the steps at [https://rancher.com/docs/rancher/v2.6/en/pipelines/example-repos/](https://rancher.com/docs/rancher/v2.6/en/pipelines/example-repos/),
    but it is highly recommended not to use it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Rancher did have its own pipeline solution called Rancher Pipelines, but as
    of Rancher v2.5, this feature has been deprecated and replaced by Fleet. Rancher
    Pipelines was built on top of Jenkins but integrated into Rancher. You can still
    enable it using the steps at [https://rancher.com/docs/rancher/v2.6/en/pipelines/example-repos/](https://rancher.com/docs/rancher/v2.6/en/pipelines/example-repos/),
    but it is highly recommended not to use it.
- en: GitHub Actions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: GitHub Actions was launched back in 2018 as a workflow automation tool that
    can also do CI/CD. It shares the core item of all tasks being containers like
    Drone does, but with the big difference that it's a cloud solution sold as an
    add-on to your GitHub subscription.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions was launched back in 2018 as a workflow automation tool that
    can also do CI/CD. It shares the core item of all tasks being containers like
    Drone does, but with the big difference that it's a cloud solution sold as an
    add-on to your GitHub subscription.
- en: 'The **pros** are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: It's easy to use for GitHub users as their repositories are just built into
    the platform, which just needs to be enabled.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: It's easy to use for GitHub users as their repositories are just built into
    the platform, which just needs to be enabled.
- en: You can use self-hosted runners to work around costs by providing your own hardware
    details, which can be found at [https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners](https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: You can use self-hosted runners to work around costs by providing your own hardware
    details, which can be found at [https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners](https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners).
- en: Nearly unlimited scale – as a cloud-based solution, you can run as many parallel
    builds as possible without needing to spin up additional servers/nodes, depending
    on your GitHub subscription, details of which can be found at [https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nearly unlimited scale – as a cloud-based solution, you can run as many parallel
    builds as possible without needing to spin up additional servers/nodes, depending
    on your GitHub subscription, details of which can be found at [https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions).
- en: Tight integration with GitHub events allows you to customize your pipelines
    based on the type of event. For example, you might run one workflow to create
    a new issue and another one to create a pull request.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tight integration with GitHub events allows you to customize your pipelines
    based on the type of event. For example, you might run one workflow to create
    a new issue and another one to create a pull request.
- en: Built-in caching for the GitHub repo means that if you have a large repository
    with lots of changes, you can assume that the clone will take little to no time.
    This is because everything is being done inside the GitHub network.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Built-in caching for the GitHub repo means that if you have a large repository
    with lots of changes, you can assume that the clone will take little to no time.
    This is because everything is being done inside the GitHub network.
- en: GitHub has a marketplace for Actions, meaning it's effortless to add plugins
    to your workflow. For example, if you need a K3s cluster to test, just go to [https://github.com/marketplace/actions/setup-k3d-k3s](https://github.com/marketplace/actions/setup-k3d-k3s)
    and click the **Use the latest version** button, then copy and paste the text
    into your flow.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub has a marketplace for Actions, meaning it's effortless to add plugins
    to your workflow. For example, if you need a K3s cluster to test, just go to [https://github.com/marketplace/actions/setup-k3d-k3s](https://github.com/marketplace/actions/setup-k3d-k3s)
    and click the **使用最新版本** button, then copy and paste the text into your flow.
- en: 'The **cons** are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**如下：'
- en: Actions are sold by the minute. For example, if your task runs for 5 mins, you
    are billed for 5 mins of usage. GitHub does provide some amount of free usage
    depending on your subscription and repository type (private versus public).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actions are sold by the minute. For example, if your task runs for 5 mins, you
    are billed for 5 mins of usage. GitHub does provide some amount of free usage
    depending on your subscription and repository type (private versus public).
- en: GitHub Actions has been a popular target for hackers and crypto miners to steal
    resources for public projects. For example, if you run a build on every pull request,
    what is to stop someone from running a bitcoin miner as part of the workflow?
    This, in turn, runs up your bill and has cost users thousands of dollars. You
    can read more about these kinds of attacks at [https://www.bleepingcomputer.com/news/security/github-actions-being-actively-abused-to-mine-cryptocurrency-on-github-servers/](https://www.bleepingcomputer.com/news/security/github-actions-being-actively-abused-to-mine-cryptocurrency-on-github-servers/).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions 一直是黑客和加密货币矿工的热门目标，他们利用公共项目窃取资源。例如，如果你在每个拉取请求上都运行构建，谁能阻止某人将比特币挖矿程序作为工作流的一部分运行呢？这会导致账单暴涨，并且已经让用户损失了成千上万美元。你可以在[https://www.bleepingcomputer.com/news/security/github-actions-being-actively-abused-to-mine-cryptocurrency-on-github-servers/](https://www.bleepingcomputer.com/news/security/github-actions-being-actively-abused-to-mine-cryptocurrency-on-github-servers/)阅读更多关于这些攻击的内容。
- en: GitHub has a lot of the same cons as Drone when it comes to commercial plugins,
    called Actions, as it simply hasn't been around for a long time.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在商业插件方面，GitHub 也存在与 Drone 相似的缺点，这些插件称为 Actions，因为它毕竟还没有存在很长时间。
- en: GitHub Actions mainly runs in the cloud, so accessing on-premise resources such
    as databases, servers, and Kubernetes clusters can be difficult without publishing
    them on the internet. You can work around this using local runners.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions 主要运行在云端，因此访问内部资源（如数据库、服务器和 Kubernetes 集群）可能会变得困难，除非将它们发布到互联网上。你可以通过使用本地运行器来解决这个问题。
- en: Running builds locally on your laptop is limited to third-party tools such as
    [https://github.com/nektos/act](https://github.com/nektos/act).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地笔记本电脑上运行构建仅限于使用第三方工具，如[https://github.com/nektos/act](https://github.com/nektos/act)。
- en: Limited build environments again, because GitHub hosts the VMs for you. You
    can only choose the OS and versions they tell you. For example, ARM is not available
    without self-hosted runners. You can find the current list of supported environments
    at [https://github.com/actions/virtual-environments](https://github.com/actions/virtual-environments).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建环境再次受到限制，因为 GitHub 为你托管虚拟机。你只能选择他们提供的操作系统和版本。例如，ARM 需要自托管的运行器才能使用。你可以在[https://github.com/actions/virtual-environments](https://github.com/actions/virtual-environments)查看当前支持的环境列表。
- en: Typically, I recommend GitHub Actions for small one-off projects that need a
    simple build script; just run the `make` command. Doing higher-level testing such
    as user simulation gets very difficult.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我推荐 GitHub Actions 用于需要简单构建脚本的小型一次性项目；只需运行 `make` 命令。进行更高级的测试，如用户模拟，会变得非常困难。
- en: Rancher does have a product called Fleet that kind of fits into this space as
    it is a CD-only tool and does not do CI. You can't do a Docker build, application
    testing, or anything like that as part of Fleet. It's only designed to push changes
    to your environment. Of course, you can use Fleet as part of publishing your applications
    to clusters. Still, it is not recommended as Fleet doesn't have a rollback or
    failback feature, meaning if you push out a change and it breaks your application,
    you need to update your Git repo and push out a new change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Rancher 确实有一款名为 Fleet 的产品，它在某种程度上适用于这个场景，因为它是一个仅用于持续交付（CD）的工具，不支持持续集成（CI）。你不能在
    Fleet 中执行 Docker 构建、应用测试等操作。它只设计用于将更改推送到你的环境。当然，你可以将 Fleet 用于将应用程序发布到集群，但不推荐这么做，因为
    Fleet 没有回滚或回退功能，这意味着如果你推送了更改并且它破坏了应用程序，你需要更新你的 Git 仓库并推送新的更改。
- en: For the rest of this chapter, we will assume that you have chosen Drone for
    your CI/CD pipeline, but most of these steps can easily be translated for other
    tools.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们假设你选择了 Drone 作为 CI/CD 管道工具，但大多数步骤也可以轻松迁移到其他工具。
- en: How to deploy Drone and its runners in Kubernetes with Rancher
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kubernetes 中通过 Rancher 部署 Drone 及其运行器
- en: 'This section will break the process into three parts: deploying the Drone server,
    standing up a Kubernetes runner, and connecting a pipeline to an external Rancher
    cluster.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将过程分为三部分：部署 Drone 服务器、启动 Kubernetes 运行器以及将管道连接到外部 Rancher 集群。
- en: Prerequisites
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'The following are the items that you''ll need to have set up before starting
    to install Drone and its runners:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在开始安装 Drone 和其运行器之前需要设置的项：
- en: A Kubernetes cluster with permissions to create cluster-level resources (cluster
    admin is preferred)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有创建集群级资源权限的 Kubernetes 集群（建议是集群管理员）
- en: Persistent storage (please see [*Chapter 11*](B18053_11_Epub.xhtml#_idTextAnchor184),
    *Bringing Storage to Kubernetes Using Longhorn*, for more details)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久存储（更多详情请参见 [*第 11 章*](B18053_11_Epub.xhtml#_idTextAnchor184)，*使用 Longhorn
    将存储带入 Kubernetes*）
- en: A hostname for publishing the Drone web UI
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发布 Drone Web UI 的主机名
- en: A publicly signed SSL certificate (internally or self-signed certs can cause
    issues)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公开签名的 SSL 证书（内部或自签名证书可能会导致问题）
- en: Permissions in GitHub to create an OAuth application
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GitHub 中创建 OAuth 应用程序的权限
- en: A publicly accessible URL from GitHub (for example, [https://drone.example.com](https://drone.example.com))
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 上的公开可访问 URL（例如，[https://drone.example.com](https://drone.example.com)）
- en: kubectl and Helm access to the cluster where the Drone server will be installed.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以访问集群的 kubectl 和 Helm，Drone 服务器将在此集群中安装。
- en: Installation steps
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装步骤
- en: In this section, we'll cover installing PostgreSQL before installing Drone.
    Then, finally, we'll install the runner.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在安装 Drone 之前如何安装 PostgreSQL。最后，我们将安装 runner。
- en: PostgreSQL
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: The Drone server needs a backend database to store its settings, configuration,
    and so on. For this, we'll be using PostgreSQL as it's the only supported database
    for self-hosted deployments. You can skip this step and use an externally managed
    database such as Amazon RDS for PostgreSQL if you so choose.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Drone 服务器需要一个后端数据库来存储其设置、配置等。为此，我们将使用 PostgreSQL，因为它是自托管部署唯一支持的数据库。如果您愿意，您可以跳过此步骤，使用外部管理的数据库，如
    Amazon RDS for PostgreSQL。
- en: 'To install PostgreSQL, you need to run the following commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 PostgreSQL，您需要运行以下命令：
- en: The first command is to create a namespace.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个命令是创建一个命名空间。
- en: It is then followed by a `helm` command to add the `bitnami` repo.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是一个 `helm` 命令，用于添加 `bitnami` 仓库。
- en: Then, finally, we run the `helm install` command to deploy the PostgreSQL server
    with additional options to set the username and password.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，我们运行 `helm install` 命令以部署 PostgreSQL 服务器，并通过附加选项设置用户名和密码。
- en: 'Here''s the result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '![Figure 16.2 – PostgreSQL install steps'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.2 – PostgreSQL 安装步骤'
- en: '](img/B18053_16_02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_02.jpg)'
- en: Figure 16.2 – PostgreSQL install steps
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – PostgreSQL 安装步骤
- en: You can find the complete commands at [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/postgresql/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/postgresql/install_commands.md).
    You can also find a full breakdown of the Helm chart options at [https://github.com/bitnami/charts/tree/master/bitnami/postgresql/](https://github.com/bitnami/charts/tree/master/bitnami/postgresql/).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/postgresql/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/postgresql/install_commands.md)
    找到完整的命令。您还可以在 [https://github.com/bitnami/charts/tree/master/bitnami/postgresql/](https://github.com/bitnami/charts/tree/master/bitnami/postgresql/)
    找到 Helm chart 选项的详细解析。
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are setting the password to `drone` for this example. This should be set
    to something more secure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将密码设置为 `drone`，作为示例。这应该设置为更安全的内容。
- en: The Drone server
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Drone 服务器
- en: 'In this section, we will install the Drone server. But before installing Drone,
    you should follow the steps located at [https://docs.drone.io/server/provider/github/](https://docs.drone.io/server/provider/github/)
    to create your OAuth2 app on GitHub. To install the Drone server, you need to
    follow these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装 Drone 服务器。但在安装 Drone 之前，您应该按照 [https://docs.drone.io/server/provider/github/](https://docs.drone.io/server/provider/github/)
    上的步骤在 GitHub 上创建 OAuth2 应用程序。要安装 Drone 服务器，您需要按照以下步骤进行：
- en: We create a new namespace and add the Drone `helm repo` using the commands listed
    in Figure 16.3.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的命名空间，并使用图 16.3 中列出的命令添加 Drone `helm 仓库`。
- en: We then create the SSL secret for the RPC secret which is used by Drone and
    its runners for authentication.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们为 RPC 密钥创建 SSL 秘密，Drone 及其 runner 会使用此密钥进行身份验证。
- en: Next, we make an RPC secret, which is used to authenticate runners.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 RPC 密钥，用于身份验证 runners。
- en: Finally, we use the `helm install` command with a number of settings.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用带有多个设置的 `helm install` 命令。
- en: The first section defines the ingress settings followed by storage, then we
    set up the database connection string. Then, the final section is for integrating
    into GitHub for our authentication.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分定义了入口设置，接下来是存储，然后我们设置数据库连接字符串。最后一部分是将 GitHub 集成用于身份验证。
- en: '![Figure 16.3 – Drone server install steps'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.3 – Drone 服务器安装步骤'
- en: '](img/B18053_16_03.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_03.jpg)'
- en: Figure 16.3 – Drone server install steps
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – Drone 服务器安装步骤
- en: You can find the full commands at [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/server/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/server/install_commands.md).
    You can also find a full breakdown of the Helm chart options at [https://github.com/drone/charts/blob/master/charts/drone/](https://github.com/drone/charts/blob/master/charts/drone/).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/server/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/server/install_commands.md)找到完整的命令。您还可以在[https://github.com/drone/charts/blob/master/charts/drone/](https://github.com/drone/charts/blob/master/charts/drone/)找到Helm图表选项的详细分解。
- en: At this point, you should be able to log in to your Drone server by visiting
    the web UI.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够通过访问Web UI来登录您的Drone服务器。
- en: The Drone Kubernetes runner
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Drone Kubernetes runner
- en: In this section, we will install the Drone Kubernetes runner. This can be installed
    on the same cluster as the Drone server if you so choose. Also, in the following
    example, we'll be using the default namespace for running our temporary pods.
    You can customize this if you so desire.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装Drone Kubernetes runner。如果您愿意，可以将其安装在与Drone服务器相同的集群中。此外，在以下示例中，我们将使用默认命名空间来运行我们的临时pod。如果需要，您可以进行自定义。
- en: 'To install the runner, you need to run the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装runner，您需要执行以下步骤：
- en: Create a new namespace.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的命名空间。
- en: Add the drone `helm repo`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Drone `helm repo`。
- en: Then, finally, install `drone-runner`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，安装`drone-runner`。
- en: It is important to note that we are pointing this runner to our Drone server
    and using the RPC secret to authenticate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们将此runner指向我们的Drone服务器，并使用RPC密钥进行身份验证。
- en: '![Figure 16.4 – Drone runner installation steps'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.4 – Drone runner安装步骤'
- en: '](img/B18053_16_04.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_04.jpg)'
- en: Figure 16.4 – Drone runner installation steps
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – Drone runner安装步骤
- en: You can find the full commands at [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/runner/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/runner/install_commands.md).
    You can also find a full breakdown of the Helm chart options at [https://github.com/drone/charts/tree/master/charts/drone-runner-kube](https://github.com/drone/charts/tree/master/charts/drone-runner-kube).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/runner/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/runner/install_commands.md)找到完整的命令。您还可以在[https://github.com/drone/charts/tree/master/charts/drone-runner-kube](https://github.com/drone/charts/tree/master/charts/drone-runner-kube)找到Helm图表选项的详细分解。
- en: At this point, you should be able to run builds in your Drone server. In the
    next section, we'll connect Drone to our Kubernetes cluster so we can deploy our
    apps.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够在您的Drone服务器中运行构建。在接下来的部分中，我们将连接Drone到我们的Kubernetes集群，以便部署我们的应用程序。
- en: Connecting to Rancher
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到Rancher
- en: In this section, we will create a service account in another Kubernetes cluster
    to add it as a secret to the Drone server. In this command, we create a service
    account, assign it cluster-admin permissions, and finally grab the token for this
    account.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在另一个Kubernetes集群中创建一个服务账号，并将其添加为Drone服务器的一个密钥。在这个命令中，我们创建了一个服务账号，并分配了cluster-admin权限，最后获取了该账号的token。
- en: '![Figure 16.5 – Create a Drone service account'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.5 – 创建一个Drone服务账号'
- en: '](img/B18053_16_05.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_05.jpg)'
- en: Figure 16.5 – Create a Drone service account
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – 创建一个Drone服务账号
- en: You can find the full commands at [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/external-cluster/rbac.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/external-cluster/rbac.md).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/external-cluster/rbac.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/drone/external-cluster/rbac.md)找到完整的命令。
- en: Next, we need to grab the cluster server URL by logging into the Rancher UI,
    browsing the cluster in question, and clicking the **Download KubeConfig** button.
    You should get a file that looks like the following example. We need the server
    value, which in this example is [https://rancher.example.com/k8s/clusters/c-m-abcdefgj](https://rancher.example.com/k8s/clusters/c-m-abcdefgj).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要登录Rancher UI，浏览相关集群，并点击**下载KubeConfig**按钮来获取集群服务器的URL。你将得到一个类似以下示例的文件。我们需要的是服务器值，在这个示例中是[https://rancher.example.com/k8s/clusters/c-m-abcdefgj](https://rancher.example.com/k8s/clusters/c-m-abcdefgj)。
- en: '![Figure 16.6 – KubeConfig example'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.6 – KubeConfig示例'
- en: '](img/B18053_16_06.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_06.jpg)'
- en: Figure 16.6 – KubeConfig example
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 – KubeConfig示例
- en: Now, we can add the credentials as a secret so it can be consumed by a pipeline,
    which we'll cover in the next section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将凭证作为密钥添加，以便管道可以使用它，这将在下一节中讲解。
- en: Injecting secrets into a pipeline
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向管道注入密钥
- en: In this section, we are going to cover adding a secret to a pipeline. In this
    example, we will use the Kubernetes credentials that we created in the last section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何向管道中添加密钥。在这个示例中，我们将使用上一节中创建的 Kubernetes 凭证。
- en: We will start by browsing a repository and clicking the **Activate repository**
    button. Then we need to go to the **Settings** tab and select **Secrets** from
    the side menu.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从浏览仓库并点击**激活仓库**按钮开始。然后，我们需要进入**设置**标签页，并从侧边菜单中选择**密钥**。
- en: '![Figure 16.7 – Creating a secret wizard'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.7 – 创建密钥向导'
- en: '](img/B18053_16_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_07.jpg)'
- en: Figure 16.7 – Creating a secret wizard
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 – 创建密钥向导
- en: We are going to create the following secrets and their values. It is important
    to note that if you are using a public repository, someone could access your secret
    if you check the **Allow Pull Requests** box.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下密钥及其值。需要注意的是，如果您使用的是公共仓库，其他人可能会访问您的密钥，特别是如果您勾选了**允许拉取请求**选项。
- en: Important Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Once a secret has been added to Drone, it can never be retrieved again. So,
    it is recommended that you have a copy stored somewhere outside Drone such as
    a password manager.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将密钥添加到 Drone 中，就无法再检索它。因此，建议您将副本存储在 Drone 之外的地方，例如密码管理器。
- en: '![Figure 16.8 – Example secrets'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.8 – 示例密钥'
- en: '](img/B18053_16_08.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_08.jpg)'
- en: Figure 16.8 – Example secrets
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.8 – 示例密钥
- en: Now that we have created our secrets, we can use them in a pipeline. The essential
    item in the example is the `from_secret` command, which ties the secret's value
    to a setting for the plugin, which is an environment variable inside the container.
    This pipeline uses the default Docker plugin to run the Docker build, then uses
    a custom plugin I created called `supporttools/kube-builder` for running kubectl
    and Helm commands. You must run the `bash /usr/local/bin/init-kubectl` command
    first as it handles setting up the `kubeconfig` file inside the container.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了密钥，可以在管道中使用它们。示例中的关键项目是`from_secret`命令，它将密钥的值与插件的设置绑定在一起，插件是容器内的一个环境变量。这个管道使用默认的
    Docker 插件来运行 Docker 构建，然后使用我创建的名为`supporttools/kube-builder`的自定义插件来运行 kubectl
    和 Helm 命令。您必须首先运行`bash /usr/local/bin/init-kubectl`命令，因为它负责在容器内部设置`kubeconfig`文件。
- en: '![Figure 16.9 – Example pipeline'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.9 – 示例管道'
- en: '](img/B18053_16_09.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_09.jpg)'
- en: Figure 16.9 – Example pipeline
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9 – 示例管道
- en: At this point, we have a pipeline up and running and should be able to build
    and deploy our applications. In the next section, we will dive into setting up
    a private image repository for storing our Docker images outside Docker Hub.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经启动并运行了一个管道，应该能够构建和部署我们的应用程序。在下一节中，我们将深入探讨如何设置一个私有镜像仓库，用于存储我们从 Docker
    Hub 之外的 Docker 镜像。
- en: What an image repository is and the rules for architecting a solution
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是镜像仓库以及架构解决方案的规则
- en: 'One of the critical things with containerization is the concept of images.
    An image is a read-only file that contains all the files, libraries, and executables
    that make up a container. Once you create a container image, you need to store
    it someplace where it will be available to download from your Kubernetes nodes.
    This place is called a registry, container registry, or image repository. For
    this chapter, we are going to call it an image repository. There are, of course,
    three main types of image repositories: Docker Hub, third-party, and self-hosted.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的一个关键概念是镜像。镜像是一个只读文件，包含构成容器的所有文件、库和可执行文件。一旦创建了容器镜像，就需要将其存储在一个地方，确保可以从 Kubernetes
    节点下载。这个地方称为注册表、容器注册表或镜像仓库。在本章中，我们将其称为镜像仓库。当然，镜像仓库有三种主要类型：Docker Hub、第三方和自托管。
- en: 'But before designing a solution, you should be able to answer the following
    questions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但在设计解决方案之前，您应该能够回答以下问题：
- en: Will this be an air-gapped environment, that is, do all images have to come
    from a registry we control?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个隔离环境吗？也就是说，所有镜像是否都必须来自我们控制的注册表？
- en: Are all your images public, or will you be using a private repo?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的所有镜像都是公开的吗，还是会使用私有仓库？
- en: What is your budget for both software and hardware?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在软件和硬件上的预算是多少？
- en: Will multiple data centers/sites need access to your registry?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个数据中心/站点需要访问您的注册表吗？
- en: Do you have any security/regulatory requirements for keeping data in a location,
    that is, on-premise only, in your country, and so on?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是否有任何安全/合规要求，比如需要将数据保存在特定地点（例如，仅限本地存储）或在您所在的国家等？
- en: Are you planning on scanning images and limiting what images are allowed in
    your environment?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是否计划扫描镜像并限制允许进入您环境的镜像？
- en: Once we have answers to most of these questions, we can evaluate solutions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解答了大部分这些问题，我们就可以评估解决方案。
- en: Docker Hub
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Hub
- en: This is the official/default image repository for most Kubernetes distributions,
    including Rancher. Because it is the default, most deployments, open source projects,
    and software vendors use Docker Hub.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数 Kubernetes 发行版的官方/默认镜像仓库，包括 Rancher。因为它是默认选项，所以大多数部署、开源项目和软件供应商都会使用 Docker
    Hub。
- en: 'The **pros** are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: It's the default and accessible for public images, with you only needing to
    pay for private images.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是默认的并且适用于公开镜像，您只需为私人镜像付费。
- en: '**Trust**: Pulling an image from a random third-party image repository can
    throw up red flags for an open source project as there is no telling who is hosting
    it. Are they injecting malicious software into the images? Docker Hub addresses
    this issue by doing security scans of all public images, including flagging images
    that contain viruses and other malicious code. It is important to note that this
    system is not perfect and does not catch everything.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信任**：从一个随机的第三方镜像仓库拉取镜像可能会给开源项目带来红旗，因为无法确定是谁在托管这些镜像。他们是否会在镜像中注入恶意软件？Docker
    Hub 通过对所有公开镜像进行安全扫描来解决这个问题，扫描内容包括标记包含病毒和其他恶意代码的镜像。需要注意的是，这个系统并不完美，并不能捕捉到所有问题。'
- en: '**Speed**: Docker Hub, of course, is the largest image repository, and it uses
    Cloudflare as its CDN along with AWS to provide the backend S3 storage. Pulling
    images from Docker Hub is very fast, with the limiting factor almost always being
    on your end, unless you are rate limited by Docker Hub. You can find out by querying
    their API details, which can be found at [https://www.docker.com/blog/checking-your-current-docker-pull-rate-limits-and-status/](https://www.docker.com/blog/checking-your-current-docker-pull-rate-limits-and-status/).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：Docker Hub 当然是最大的镜像仓库，它使用 Cloudflare 作为 CDN，并与 AWS 一起提供后端的 S3 存储。从 Docker
    Hub 拉取镜像非常快速，限制因素几乎总是出在你这端，除非你被 Docker Hub 限制了拉取速率。你可以通过查询他们的 API 详情来了解更多信息，相关链接可以在[https://www.docker.com/blog/checking-your-current-docker-pull-rate-limits-and-status/](https://www.docker.com/blog/checking-your-current-docker-pull-rate-limits-and-status/)找到。'
- en: '**Data redundancy / availablity**: Again, the images are stored in AWS S3 with
    Amazon''s official documentation stating that S3 object durability is 99.999999999
    (11 nines) for a year. So, the chance of losing your images due to data loss is
    almost zero.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据冗余/可用性**：同样，这些镜像存储在 AWS S3 中，亚马逊的官方文档表明 S3 对象的耐久性为 99.999999999（11个9），持续一年。因此，由于数据丢失而导致镜像丢失的几率几乎为零。'
- en: 'The **cons** are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**如下：'
- en: '**Security requirements**: Some organizations require that all source code
    and data stay on-premises. Docker Hub accounts have been attacked and private
    images have been leaked before.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全要求**：一些组织要求所有源代码和数据必须保持在本地。Docker Hub 账户曾被攻击，私人镜像也曾被泄露。'
- en: Docker images are stored as plain text and are not encrypted in Docker Hub,
    meaning someone with access to the repository would be able to download an image
    and extract data/source code from it. This includes Docker Hub itself as it does
    scans of images uploaded to its sites. An example is the Log4js issue where Docker
    Hub triggered a scan of all images hosted on its site. Details of which can be
    found at [https://docs.docker.com/security/#log4j-2-cve-2021-44228](https://docs.docker.com/security/#log4j-2-cve-2021-44228).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像在 Docker Hub 中以纯文本格式存储，并未加密，这意味着任何有权限访问仓库的人都能下载镜像并从中提取数据/源代码。这也包括 Docker
    Hub 自身，因为它会扫描上传到其网站的镜像。例如，Log4js 问题就是 Docker Hub 触发了对其网站上所有镜像的扫描。相关细节可以在[https://docs.docker.com/security/#log4j-2-cve-2021-44228](https://docs.docker.com/security/#log4j-2-cve-2021-44228)找到。
- en: '**Pull limits**: Docker Hub added rate limits to images in November 2021, details
    of which can be found in their official documentation located at [https://docs.docker.com/docker-hub/download-rate-limit/](https://docs.docker.com/docker-hub/download-rate-limit/).
    You can, of course, buy a Docker Hub subscription, which has no limits for your
    clusters. You can also read about this change in my Kubernetes Master Class –
    *Docker Hub Limits: Addressing the Amount of Pull Requests in Rancher*, which
    can be found at [https://github.com/mattmattox/Kubernetes-Master-Class/tree/main/docker-hub-limits](https://github.com/mattmattox/Kubernetes-Master-Class/tree/main/docker-hub-limits).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取限制**：Docker Hub在2021年11月对镜像增加了拉取速率限制，详细信息可以在其官方文档中找到，[https://docs.docker.com/docker-hub/download-rate-limit/](https://docs.docker.com/docker-hub/download-rate-limit/)。当然，你可以购买Docker
    Hub订阅服务，这样你的集群就没有限制。你也可以阅读我的Kubernetes大师课程——*Docker Hub限额：解决Rancher中的拉取请求数量问题*，该课程可以在[https://github.com/mattmattox/Kubernetes-Master-Class/tree/main/docker-hub-limits](https://github.com/mattmattox/Kubernetes-Master-Class/tree/main/docker-hub-limits)找到。'
- en: I usually recommend using Docker Hub for all public projects and paying a few
    dollars per month to host private images unless you store sensitive data inside
    your images or have a limited internet connection.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常建议使用Docker Hub来管理所有公共项目，并为托管私人镜像每月支付几美元，除非你在镜像中存储了敏感数据或你的网络连接有限。
- en: Image repositories managed by third parties
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方管理的镜像仓库
- en: These platforms act as a central point of access for your own container images,
    making it easier to store, manage, and secure them without the operational hassle
    of running your own registry on-premises. Several third-party registry offerings
    support Docker images, including Amazon ECR, Azure Container Registry, and Google
    Container Registry.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平台充当你自己容器镜像的访问中心，简化了存储、管理和保护镜像的过程，而无需在本地运行自己的镜像仓库。许多第三方仓库服务支持Docker镜像，包括Amazon
    ECR、Azure Container Registry和Google Container Registry。
- en: 'The **pros** are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: '**Control**: These image repositories are customarily hosted inside your current
    cloud environment – that is, AWS, Azure, GCP – and because of this, you have control
    over the data.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：这些镜像仓库通常托管在你当前的云环境中——也就是AWS、Azure、GCP——因此，你对数据拥有控制权。'
- en: '**Managed service**: Because the cloud provider manages all these image repositories,
    you don''t have to upgrade them, patch them, or back them up. You can get just
    let them handle it for you.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管服务**：由于云服务提供商管理所有这些镜像仓库，你不必进行升级、打补丁或备份。你只需要让他们为你处理这些工作。'
- en: '**Pricing**: Most of the cloud providers charge little to nothing for traffic
    going to and from the image repository. And storage costs usually are just passed
    through to the S3/object storage storing the data.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价**：大多数云服务提供商对进出镜像仓库的流量收费极少或不收费。存储费用通常只是转嫁给存储数据的S3/对象存储。'
- en: 'The **cons** are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**如下：'
- en: '**Not cost-effective for public images**: Because most cloud providers charge
    extra for traffic being egressed (going out to the public internet), hosting a
    public image can become very expensive.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于公共镜像来说并不具成本效益**：因为大多数云服务提供商对外部流量（传出到公共互联网的流量）收取额外费用，所以托管公共镜像可能会变得非常昂贵。'
- en: '**Authentication**: Most cloud providers use their own authentication sources
    to control access to the image repository. This causes problems as Docker is built
    around basic authentication (a static username and password), and services such
    as AWS ECR only provide a good password for 6 hours. This means that you need
    to use a tool such as [https://github.com/SupportTools/ecr-helper](https://github.com/SupportTools/ecr-helper)
    to handle updating that password on schedule.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：大多数云服务提供商使用他们自己的认证源来控制对镜像仓库的访问。这会引发问题，因为Docker是基于基本认证（静态用户名和密码）构建的，而像AWS
    ECR这样的服务只会提供有效6小时的密码。这意味着你需要使用像[https://github.com/SupportTools/ecr-helper](https://github.com/SupportTools/ecr-helper)这样的工具来定期更新密码。'
- en: I usually only recommend using a third-party image repository with hosted Kubernetes
    clusters where you need to store private images but don't want to manage the service.
    For example, if you deploy an EKS cluster on Amazon, you should use ECR.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常只推荐在托管Kubernetes集群的情况下使用第三方镜像仓库，特别是当你需要存储私人镜像但不想自己管理服务时。例如，如果你在亚马逊上部署了EKS集群，你应该使用ECR。
- en: Self-hosted repo
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自托管仓库
- en: An organization may prefer to host container images on their own on-premises
    infrastructure for various reasons, including security, compliance concerns, or
    low-latency requirements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 组织可能因各种原因（包括安全性、合规性问题或低延迟要求）更倾向于在自己的本地基础设施上托管容器镜像。
- en: 'The **pros** are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**如下：'
- en: '**Control**: You are in complete control because you are hosting the images.
    You can choose to have everything open to the world or all images locked down
    and everything in-between.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：你完全掌控，因为你托管了镜像。你可以选择将所有内容对外开放，或者将所有镜像锁定，介于两者之间。'
- en: '**Bandwidth**: Because the images are hosted in your data center, your nodes
    no longer need to reach out to the public internet to pull images. For example,
    if you have a 100-node cluster, each node needs to pull down a 1 GB image. You
    need to download 100 GB of data through your internet connection versus downloading
    that data for a local server.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带宽**：由于镜像托管在你的数据中心，因此你的节点不再需要访问公共互联网来拉取镜像。例如，如果你有一个 100 节点的集群，每个节点需要拉取一个
    1 GB 的镜像。你需要通过互联网连接下载 100 GB 数据，而不是为本地服务器下载这些数据。'
- en: '**Security**: Using tools such as Harbor, we can integrate image scanning into
    our registry and set up rules such as blocking the uploading of images with too
    many high/critical vulnerabilities.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：使用像 Harbor 这样的工具，我们可以将镜像扫描集成到我们的注册表中，并设置规则，如阻止上传具有过多高/关键漏洞的镜像。'
- en: '**Required in air-gap environments**: Private image repositories are required
    in air-gapped environments that cannot pull images for external image repositories.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在空气隔离环境中的要求**：在无法拉取外部镜像仓库镜像的空气隔离环境中，必须使用私有镜像仓库。'
- en: 'The **cons** are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**如下：'
- en: '**Management**: Because you are now hosting the registry, you are directly
    responsible for securing, patching, and upgrading tasks of that software.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理**：因为你现在托管了注册表，你直接负责该软件的安全、修补和升级任务。'
- en: '**Changes to your deployments**: Most deployments assume that you''ll use Docker
    Hub as your image repository. So, you''ll need to copy the images from the public
    repository into your private registry.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署变更**：大多数部署假设你会使用 Docker Hub 作为镜像仓库。因此，你需要将镜像从公共仓库复制到你的私有注册表中。'
- en: I normally only recommend self-hosted repositories in air-gapped environments
    and in cases where pulling large amounts of data over the internet can be an issue,
    that is, low-speed internet or large numbers of nodes sharing a connection.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常只在空气隔离的环境中推荐自托管仓库，或者在通过互联网拉取大量数据可能成为问题的情况下，即低速互联网或多个节点共享连接的情况。
- en: At this point, you should be able to pick which image repository works best
    for your environment. In the following sections, we will assume that you'll be
    going with the self-hosted option.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该能够选择哪个镜像仓库最适合你的环境。在接下来的章节中，我们将假设你选择了自托管选项。
- en: How to deploy Harbor in Kubernetes
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kubernetes 中部署 Harbor
- en: In this section, we will install Harbor in our Kubernetes cluster. It is important
    to note that this will only be a basic setup as Harbor can be installed in several
    different ways.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在我们的 Kubernetes 集群中安装 Harbor。需要注意的是，这将只是一个基本设置，因为 Harbor 可以通过多种方式安装。
- en: 'The following are the prerequisites:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前提条件：
- en: A Kubernetes cluster with permissions to create cluster-level resources (cluster
    admin is preferred)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有创建集群级资源权限的 Kubernetes 集群（建议是集群管理员）
- en: Persistent storage (please see [*Chapter 11*](B18053_11_Epub.xhtml#_idTextAnchor184),
    *Bringing Storage to Kubernetes Using Longhorn*, for more details)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化存储（更多细节请参见 [*第11章*](B18053_11_Epub.xhtml#_idTextAnchor184)，*使用 Longhorn 将存储带入
    Kubernetes*）
- en: Two hostnames for publishing the main Harbor URL and the notary service
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布主 Harbor URL 和公证服务的两个主机名
- en: A publicly signed SSL certificate (internally or self-signed certificates can
    cause issues)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共签名的 SSL 证书（内部证书或自签名证书可能会导致问题）
- en: kubectl and Helm access to the cluster where the Drone server will be installed
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对将安装 Drone 服务器的集群具有 kubectl 和 Helm 访问权限
- en: 'To install Harbor, we are going to run the following commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Harbor，我们将运行以下命令：
- en: First, add the Harbor `helm repo`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加 Harbor 的 `helm repo`。
- en: Next, create the Harbor `namespace`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 Harbor 的 `namespace`。
- en: Then, upload the `ssl certificate` secret for the ingress.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，上传用于 Ingress 的 `ssl certificate` 秘密。
- en: Then, finally, we run `helm install` for the Harbor chart.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，我们运行`helm install`来安装 Harbor chart。
- en: 'It is important to note that this includes some settings: the first part is
    to set up the ingress and the second half is to set up the storage class, which
    is Longhorn.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这包括一些设置：第一部分是设置 ingress，第二部分是设置存储类，即 Longhorn。
- en: '![Figure 16.10 – Harbor install commands'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.10 – Harbor 安装命令](img/B18053_16_10.jpg)'
- en: '](img/B18053_16_10.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18053_16_10.jpg)'
- en: Figure 16.10 – Harbor install commands
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.10 – Harbor 安装命令
- en: You can find the full commands at [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/harbor/server/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/harbor/server/install_commands.md).
    You can also find a full breakdown of the Helm chart options at [https://github.com/goharbor/harbor-helm](https://github.com/goharbor/harbor-helm).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/harbor/server/install_commands.md](https://github.com/PacktPublishing/Rancher-Deep-Dive/tree/main/ch16/harbor/server/install_commands.md)
    找到完整的命令。你也可以在 [https://github.com/goharbor/harbor-helm](https://github.com/goharbor/harbor-helm)
    找到 Helm chart 选项的详细解析。
- en: At this point, you should have Harbor up and running and be ready to start uploading
    images and use them in your environment. In the next section, we will configure
    Kubernetes to use a private registry.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该已经让 Harbor 启动并运行，准备好开始上传镜像并在环境中使用它们。在下一部分，我们将配置 Kubernetes 使用私有注册表。
- en: Integrating a private registry into a Kubernetes cluster
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将私有注册表集成到 Kubernetes 集群中
- en: Now that you have your own private registry, you now need to add it to your
    Rancher and Kubernetes clusters so you can start consuming it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经有了自己的私有注册表，现在需要将其添加到 Rancher 和 Kubernetes 集群中，以便你开始使用它。
- en: 'For this section, we will assume that you are using Harbor as your private
    registry, which will be an air-gapped setup, meaning our nodes cannot pull images
    from the public internet. We need to do three things for this task:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们假设你使用 Harbor 作为你的私有注册表，并且这是一个 air-gapped 配置，意味着我们的节点无法从公共互联网拉取镜像。我们需要做三件事来完成这个任务：
- en: Collect/publish images
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集/发布镜像
- en: Set the Rancher global registry
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Rancher 全局注册表
- en: Update RKE/RKE2
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 RKE/RKE2
- en: Collect/publish images
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集/发布镜像
- en: For this part, we need to collect all the images we will need for Rancher and
    its clusters. Luckily, Rancher supports an install type called air-gapped and
    has created a script published as part of the Rancher release that takes care
    of this process. You can find the details of this process in Rancher's documentation
    located at [https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/populate-private-registry/](https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/populate-private-registry/).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们需要收集 Rancher 和其集群所需的所有镜像。幸运的是，Rancher 支持一种名为 air-gapped 的安装类型，并已发布一个脚本作为
    Rancher 版本的一部分来处理这一过程。你可以在 Rancher 文档中找到关于此过程的详细信息，网址是 [https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/populate-private-registry/](https://rancher.com/docs/rancher/v2.6/en/installation/other-installation-methods/air-gap/populate-private-registry/)。
- en: But the short answer is Rancher has a file called `rancher-images.txt`, which
    contains a list of the images that Rancher might need. Rancher then has a script
    called `rancher-save-images.sh`, which will walk through that list, pulling down
    all the images using a workstation/server with internet access. It will output
    a `tar` file that can be physically copied to an air-gapped server. The last step
    is to run `rancher-load-images.sh`, which takes all those images and pushes them
    to your private registry.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但简而言之，Rancher 有一个名为 `rancher-images.txt` 的文件，其中包含 Rancher 可能需要的镜像列表。然后，Rancher
    有一个名为 `rancher-save-images.sh` 的脚本，它会遍历该列表，使用具有互联网访问权限的工作站/服务器拉取所有镜像。它将输出一个 `tar`
    文件，可以将该文件物理复制到一个 air-gapped 服务器。最后一步是运行 `rancher-load-images.sh`，它将所有镜像推送到你的私有注册表中。
- en: This list is updated as part of every Rancher release, and this process should
    be run every time you are going to upgrade Rancher to grab the new/updated images.
    Also, some customers have a server/workstation that sits between the internet
    and the air-gapped environment and have chosen to modify this process to do both
    steps on the same server. They do this by editing `rancher-save-images.sh` and
    commenting on the last line, `docker save`. This skips the creation of the `tar`
    file. Then, in `rancher-load-images.sh`, they remove `docker load` as the images
    are already on the server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表会在每次 Rancher 版本更新时进行更新，每次升级 Rancher 时都应运行此过程，以获取新的或更新的镜像。另外，一些客户有一台位于互联网和隔离环境之间的服务器/工作站，并选择修改此过程，在同一台服务器上同时执行这两个步骤。他们通过编辑`rancher-save-images.sh`并注释掉最后一行
    `docker save` 来跳过 `tar` 文件的创建。然后，在 `rancher-load-images.sh` 中，他们删除了 `docker load`，因为镜像已经在服务器上。
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that you keep the same registry structure, that is, `docker.io/rancher/rancher`
    should become `registry.example.com/rancher/rancher`. It is also recommended that
    the Rancher repos be set to public, which means that anyone can pull them without
    authenticating. This makes the process easier and replicates Docker Hub for these
    images.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您保持相同的注册表结构，即 `docker.io/rancher/rancher` 应变为 `registry.example.com/rancher/rancher`。还建议将
    Rancher 仓库设置为公开，这样任何人都可以在不进行身份验证的情况下拉取它们。这将使过程更加简单，并且能够模拟这些镜像的 Docker Hub。
- en: Rancher global registry
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rancher 全局注册表
- en: Now that we have all our images, we need to point Rancher to the private registry.
    For this process, we need to follow the steps located at [https://rancher.com/docs/rancher/v2.6/en/admin-settings/config-private-registry/](https://rancher.com/docs/rancher/v2.6/en/admin-settings/config-private-registry/).
    The basic idea is to go to the Rancher UI's `system-default-registry`, and update
    the value to your private registry. Suppose you have a private registry that needs
    credentials to pull images from the rancher repos. You would need to take additional
    steps by adding the credentials to each cluster.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有镜像，我们需要将 Rancher 指向私有注册表。对于此过程，我们需要遵循位于 [https://rancher.com/docs/rancher/v2.6/en/admin-settings/config-private-registry/](https://rancher.com/docs/rancher/v2.6/en/admin-settings/config-private-registry/)
    的步骤。基本思路是进入 Rancher UI 的 `system-default-registry`，并将值更新为您的私有注册表。假设您有一个需要凭证才能从
    Rancher 仓库拉取镜像的私有注册表，您需要通过为每个集群添加凭证来采取额外的步骤。
- en: Update RKE/RKE2
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 RKE/RKE2
- en: Now that you have Rancher using the new private registry, you now need to tell
    RKE and RKE2 to use that registry too. For RKE, it's as simple as updating the
    `cluster.yaml` file to include the `private_registries` section and running `rke
    up`. You can find the details of this change at [https://rancher.com/docs/rke/latest/en/config-options/private-registries/](https://rancher.com/docs/rke/latest/en/config-options/private-registries/).
    RKE2 is the same but with some additional settings if you need them. You can find
    details at [https://docs.rke2.io/install/containerd_registry_configuration/](https://docs.rke2.io/install/containerd_registry_configuration/).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经让 Rancher 使用新的私有注册表，接下来需要告诉 RKE 和 RKE2 也使用该注册表。对于 RKE，只需要更新 `cluster.yaml`
    文件，加入 `private_registries` 部分并运行 `rke up`。您可以在 [https://rancher.com/docs/rke/latest/en/config-options/private-registries/](https://rancher.com/docs/rke/latest/en/config-options/private-registries/)
    中找到该更改的详细信息。RKE2 也是一样，但如果需要，您还可以进行一些附加设置。您可以在 [https://docs.rke2.io/install/containerd_registry_configuration/](https://docs.rke2.io/install/containerd_registry_configuration/)
    中找到详细信息。
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For both RKE and RKE2 clusters, this can be set up after the cluster has already
    been created, but it is highly recommended that you test this process in a lab/sandbox
    cluster as you might run into issues with firewall rules, missing images, misconfigured
    deployments, and so on, which can break your cluster. So, we want to test this
    process and make sure it's rock-solid before applying it to a production cluster.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 RKE 和 RKE2 集群，这可以在集群创建后进行设置，但强烈建议您在实验室/沙箱集群中测试此过程，因为您可能会遇到防火墙规则、缺失镜像、配置错误的部署等问题，这些问题可能会破坏集群。因此，我们希望在将此过程应用到生产集群之前，先进行充分的测试，确保它非常稳定。
- en: At this point, we should have our clusters pulling images from our registry
    instead of from Docker Hub. We also went over how to force redirect all images
    at the host level and how to force a registry change at a deployment level as
    well.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该让集群从我们的注册表拉取镜像，而不是从 Docker Hub 拉取。我们还讨论了如何在主机级别强制重定向所有镜像，以及如何在部署级别强制更改注册表。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter went over what CI/CD is and how it works. We then dove into designing
    and installing Drone to become our CI/CD system. We then shifted gears and covered
    the topic of image repositories and the different types. At which point, we designed
    and installed Harbor to become our private registry. Finally, we closed out this
    chapter by covering how to configure Rancher, RKE, and RKE2 to consume this new
    private registry.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了什么是 CI/CD 以及它是如何工作的。然后，我们深入探讨了设计和安装 Drone 来作为我们的 CI/CD 系统。接着，我们转向讨论镜像仓库及其不同类型。在此基础上，我们设计并安装了
    Harbor 作为我们的私有注册表。最后，我们通过讲解如何配置 Rancher、RKE 和 RKE2 来使用这个新的私有注册表来结束本章内容。
- en: In the next chapter, we will build upon what we learned in this chapter to bring
    our deployment to the next level with Helm charts.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于本章所学的内容，利用 Helm charts 将我们的部署提升到一个新水平。
