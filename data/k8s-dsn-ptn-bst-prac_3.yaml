- en: Kubernetes Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 扩展
- en: Kubernetes is highly customizable and extensible so that any segment of the
    system can be configured comprehensively and extended with new features. Extension
    points of Kubernetes do not focus on low-level configuration of the built-in resources,
    such as pods or stateful sets. However, extending Kubernetes means extending the
    operations of Kubernetes itself. These extension points enable many practices,
    including creating new Kubernetes resources, automating Kubernetes and human interactions,
    and intervening with the creation or editing of resources and their scheduling
    mechanisms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是高度可定制和可扩展的，因此系统的任何部分都可以进行全面配置并扩展新功能。Kubernetes 的扩展点并不专注于内建资源的低级配置，如
    Pods 或 StatefulSets。然而，扩展 Kubernetes 意味着扩展 Kubernetes 本身的操作。这些扩展点使得许多实践成为可能，包括创建新的
    Kubernetes 资源、自动化 Kubernetes 和人类交互，以及干预资源的创建或编辑及其调度机制。
- en: In this chapter, extension points and patterns will be presented, and the most
    common and essential extension points will be covered. Firstly, the Kubernetes
    API will be enhanced, and human knowledge will be converted into the automation
    of Kubernetes operators. Secondly, the control access mechanisms of Kubernetes
    will be extended with webhooks and initializers. Finally, the default scheduler
    of Kubernetes will be configured with highly customizable options. How to develop
    and deploy a custom scheduler will also be demonstrated. Throughout these chapters,
    you should be able to implement and deploy extensions by creating applications
    that consume the Kubernetes API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍扩展点和模式，并涵盖最常见和最基本的扩展点。首先，将增强 Kubernetes API，并将人类知识转化为 Kubernetes 操作员的自动化。其次，将通过
    Webhooks 和 Initializers 扩展 Kubernetes 的访问控制机制。最后，将以高度可定制的选项配置 Kubernetes 的默认调度器，并演示如何开发和部署自定义调度器。在这些章节中，你将能够通过创建使用
    Kubernetes API 的应用程序来实现并部署扩展。
- en: Kubernetes Extension Points
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 扩展点
- en: Kubernetes itself and its built-in resources are highly configurable so that
    any modern cloud-native application can be configured to run on the cloud environment.
    When it comes to adding new capabilities, converting human knowledge into code
    and automating more, the Kubernetes extension comes to the rescue. Fortunately,
    to extend the capabilities of Kubernetes, users do not need to download the source
    code, make changes, build and deploy the complete system. With its modularity,
    the extension points of Kubernetes are already defined and ready to use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 本身及其内建资源是高度可配置的，因此任何现代云原生应用都可以配置在云环境中运行。在添加新功能、将人类知识转化为代码并实现更多自动化时，Kubernetes
    扩展提供了帮助。幸运的是，为了扩展 Kubernetes 的功能，用户无需下载源代码、进行修改、构建和部署完整的系统。凭借其模块化，Kubernetes 的扩展点已经定义并准备好使用。
- en: 'Kubernetes extension points focus on the current functionalities of Kubernetes
    and its environment. Built-in components and how to extend Kubernetes are summarized
    in the following categories:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 扩展点专注于当前 Kubernetes 及其环境的功能。内建组件及如何扩展 Kubernetes 总结如下几类：
- en: '**Kubernetes clients**: It is possible to extend client applications such as
    `kubectl` by writing `kubectl` plugins. These extensions will help you use `kubectl`
    with less human interaction, such as choosing a Kubernetes cluster context automatically.
    Likewise, generated clients with the OpenAPI specifications can extend client
    libraries such as `client-go`. With these generated clients, you can programmatically
    use the Kubernetes API in custom applications.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 客户端**：通过编写 `kubectl` 插件，可以扩展客户端应用程序，如 `kubectl`。这些扩展将帮助你减少与 `kubectl`
    的人工交互，例如自动选择 Kubernetes 集群上下文。同样，使用 OpenAPI 规范生成的客户端可以扩展客户端库，如 `client-go`。使用这些生成的客户端，你可以在自定义应用程序中以编程方式使用
    Kubernetes API。'
- en: '**Kubernetes API types**: Kubernetes API resources such as pods, deployments,
    and many more are highly configurable, but it is also possible to add new resources
    called custom resources.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes API 类型**：Kubernetes API 资源，如 Pods、Deployments 等，具有高度的可配置性，但也可以添加新的资源，称为自定义资源。'
- en: '**Kubernetes API controllers**: The control plane of Kubernetes, which includes
    the Kubernetes API server, handles all operations, such as automatic scaling or
    self-healing; however, it is also possible to develop custom controllers.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes API 控制器**：Kubernetes 的控制平面，包括 Kubernetes API 服务器，处理所有操作，如自动扩展或自我修复；但是，也可以开发自定义控制器。'
- en: '**Access controllers**: The access control mechanism that handles authentication,
    authorization, and admission controllers can be extended by connecting to webhook
    servers or intervening with initializers.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制器**：处理身份验证、授权和准入控制的访问控制机制可以通过连接到Webhook服务器或介入初始化程序来扩展。'
- en: '**Scheduling**: `kube-scheduler` already handles the scheduling of pods to
    the nodes; however, it is also possible to create custom schedulers and deploy
    them to the clusters.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度**：`kube-scheduler`已经处理了将pods调度到节点的任务；然而，也可以创建自定义调度器并将其部署到集群中。'
- en: '**Infrastructure**: The infrastructure part of Kubernetes is standardized,
    regarding the server, network, and storage with the **Container Runtime Interface**
    (**CRI**), **Container Network Interface** (**CNI**), and **Container Storage
    Interface** (**CSI**). The implementation, of these interfaces provide ways of
    extending the infrastructure of the underlying Kubernetes clusters.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施**：Kubernetes的基础设施部分是标准化的，包括服务器、网络和存储，使用**容器运行时接口**（**CRI**）、**容器网络接口**（**CNI**）和**容器存储接口**（**CSI**）。这些接口的实现提供了扩展底层Kubernetes集群基础设施的方法。'
- en: 'I have put the preceding categories into the following table for ease of use:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，我将前面提到的各个类别放入了以下表格中：
- en: '![](img/a8b93813-0e64-4bfb-8d31-b79e868e3b53.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8b93813-0e64-4bfb-8d31-b79e868e3b53.png)'
- en: Extending Kubernetes Clients
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Kubernetes客户端
- en: Kubernetes client applications and libraries are the main entry points for accessing
    the Kubernetes API. With these applications and libraries, it is possible to automate
    and extend Kubernetes operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes客户端应用程序和库是访问Kubernetes API的主要入口点。通过这些应用程序和库，可以自动化并扩展Kubernetes操作。
- en: 'For the official Kubernetes client applications, `kubectl` can be extended
    by writing plugin applications. Some of the most popular plugins enhance the capabilities
    of `kubectl`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于官方Kubernetes客户端应用程序，可以通过编写插件应用程序来扩展`kubectl`。一些最受欢迎的插件增强了`kubectl`的功能：
- en: It switches the Kubernetes cluster context automatically
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动切换Kubernetes集群上下文。
- en: It calculates and displays the uptime information of pods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它计算并显示pods的正常运行时间信息。
- en: It connects via SSH into a container with a specific user
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过SSH连接到具有特定用户的容器。
- en: Official Kubernetes code generators can generate official Kubernetes client
    libraries and Kubernetes server codes. These generators create the required source
    code for internal versioned types, clients informers, and protobuf codecs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Kubernetes代码生成器可以生成官方Kubernetes客户端库和Kubernetes服务器代码。这些生成器为内部版本化的类型、客户端信息器和protobuf编解码器创建所需的源代码。
- en: With the extension points on client applications and libraries, it is possible
    to enhance operations that interact with Kubernetes. If your custom requirements
    need more than the capabilities of `kubectl` or client libraries, Kubernetes provides
    extension points for customization.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过客户端应用程序和库的扩展点，可以增强与Kubernetes交互的操作。如果你的自定义需求超出了`kubectl`或客户端库的功能，Kubernetes提供了定制化的扩展点。
- en: Extending the Kubernetes API
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Kubernetes API
- en: 'Kubernetes already has a rich set of resources, starting from pods as building
    blocks to higher-level resources such as stateful sets and deployments. Modern
    cloud-native applications can be deployed in terms of Kubernetes resources and
    their high-level configuration options. However, they are not sufficient when
    human expertise and operations are required. Kubernetes enables extending its
    own API with new resources and operates them as Kubernetes-native objects with
    the following features:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes已经拥有丰富的资源，从pods作为构建块，到stateful sets和deployments等更高级别的资源。现代云原生应用可以通过Kubernetes资源及其高级配置选项进行部署。然而，当需要人工专业知识和操作时，这些资源并不充分。Kubernetes使得通过新资源扩展自己的API成为可能，并将其作为Kubernetes原生对象操作，具有以下特点：
- en: '**RESTful API**: New resources are directly included in the RESTful API so
    that they are accessible with their special endpoints.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESTful API**：新资源直接包含在RESTful API中，以便通过它们的特殊端点进行访问。'
- en: '**Authentication and authorization**: All requests for new resources go through
    the steps of authentication and authorization, like native requests.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证与授权**：所有新的资源请求都需要经过身份验证和授权步骤，就像本地请求一样。'
- en: '**OpenAPI discovery**: New resources can be discovered and integrated into
    OpenAPI specifications.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAPI发现**：可以发现新资源并将其集成到OpenAPI规范中。'
- en: '**Client libraries**: Client libraries such as `kubectl` or `client-go` can
    be used to interact with new resources.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端库**：如`kubectl`或`client-go`等客户端库可以用来与新资源进行交互。'
- en: 'Two major steps are involved when extending the Kubernetes API:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Kubernetes API时涉及两个主要步骤：
- en: Create a new Kubernetes resource to introduce the new API types
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Kubernetes资源来引入新的API类型
- en: Control and automate operations to implement custom logic as an additional API
    controller
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制和自动化操作，以实现作为附加API控制器的自定义逻辑。
- en: Custom Resource Definitions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义资源定义
- en: In Kubernetes, all of the resources have their REST endpoints in the Kubernetes
    API server. REST endpoints enable operations for specif c objects, such as pods,
    by using `/api/v1/namespaces/default/pods`. Custom resources are the extensions
    of the Kubernetes API that can be dynamically added or removed during runtime.
    They enable users of the cluster to operate on extended resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，所有资源都有自己的REST端点，这些端点位于Kubernetes API服务器中。REST端点通过使用`/api/v1/namespaces/default/pods`来执行特定对象（如Pods）的操作。自定义资源是Kubernetes
    API的扩展，可以在运行时动态地添加或移除。它们使集群的用户能够对扩展资源进行操作。
- en: Custom resources are defined in **Custom Resource Definition** (**CRD**) objects.
    Using the built-in Kubernetes resources, namely CRDs, it is possible to add new
    Kubernetes API endpoints by using the Kubernetes API itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源是在**自定义资源定义**（**CRD**）对象中定义的。通过使用内置的Kubernetes资源，即CRD，可以通过Kubernetes API本身来添加新的Kubernetes
    API端点。
- en: In the following section, a new custom resource will be created for the requirements
    that typically require human interaction inside Kubernetes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，将为那些通常需要人工交互的Kubernetes需求创建一个新的自定义资源。
- en: Creating and Deploying Custom Resource Definitions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和部署自定义资源定义
- en: Consider, a client wants to watch weather reports in a scalable cloud-native
    way in Kubernetes. We are expected to extend the Kubernetes API so that the client
    and further future applications natively use weather report resources. We want
    to create `CustomResourceDefinitions` and deploy them to the cluster to check
    their effects, and use newly defined resources to create extended objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个客户端希望以可扩展的云原生方式在Kubernetes中查看天气报告。我们需要扩展Kubernetes API，以便客户端和未来的应用程序能够本地使用天气报告资源。我们希望创建`CustomResourceDefinitions`并将其部署到集群中，以检查它们的效果，并使用新定义的资源来创建扩展对象。
- en: 'You can find the `crd.yaml` file at: [https://goo.gl/ovwFX1](https://goo.gl/ovwFX1).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到`crd.yaml`文件：[https://goo.gl/ovwFX1](https://goo.gl/ovwFX1)。
- en: 'Let''s begin by implementing the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始执行以下步骤：
- en: 'Deploy the custom resource definition with kubectl with the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用kubectl部署自定义资源定义，执行以下命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Custom resource definitions are Kubernetes resources that enable the dynamic
    registration of new custom resources. An example custom resource for `WeatherReport`
    can be defined as in the `k8s-operator-example/deploy/crd.yaml` file, which is
    shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源定义是Kubernetes资源，它们支持新自定义资源的动态注册。一个关于`WeatherReport`的示例自定义资源可以在`k8s-operator-example/deploy/crd.yaml`文件中定义，示例如下：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like all other Kubernetes resources, CRD has API version, kind, metadata, and
    specification groups. In addition, the specification of CRD includes the definition
    for the new custom resource. For `WeatherReport`, a REST endpoint will be created
    under `k8s.packt.com` with the version of `v1`, and their plural and singular
    forms will be used within clients.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有其他Kubernetes资源一样，CRD包含API版本、类型、元数据和规格组。此外，CRD的规格包括新自定义资源的定义。对于`WeatherReport`，将会在`k8s.packt.com`下创建一个版本为`v1`的REST端点，并且其复数和单数形式将在客户端中使用。
- en: 'Check the custom resources deployed to the cluster with the following command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查部署到集群中的自定义资源：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will get the following output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/d809bece-bc5c-405c-93af-4c635b5fa94d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d809bece-bc5c-405c-93af-4c635b5fa94d.png)'
- en: As shown in the preceding screenshot, the weather report CRD is defined with
    the plural name and group name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，天气报告的CRD已经定义了复数名称和组名称。
- en: 'Check the REST endpoints of the API server for new custom resources:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查API服务器中新自定义资源的REST端点：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will get the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/584d1b25-5143-458f-ab74-0e07afe88d5f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/584d1b25-5143-458f-ab74-0e07afe88d5f.png)'
- en: New endpoints are created, which shows that the Kubernetes API server is already
    extended to work with our new custom resource, `weatherreports`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了新的端点，这表明Kubernetes API服务器已经扩展，可以与我们的新自定义资源`weatherreports`一起工作。
- en: 'Check the weather report instances from Kubernetes clients such as `kubectl`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 客户端（如`kubectl`）检查天气报告实例：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will get the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/6a5cb085-f387-43b3-a1c3-1b2e08a15e85.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a5cb085-f387-43b3-a1c3-1b2e08a15e85.png)'
- en: Although the output of `No resources found` looks like an indication of an error,
    it shows us that there are no live instances of the `weatherreports` resource
    as expected. It shows us that, without any further configuration other than creating
    a `CustomResourceDefinition`, the Kubernetes API server is extended with new endpoints
    and clients are ready to work with the new custom resource.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`No resources found`的输出看起来像是错误的指示，但它告诉我们没有如预期那样的`weatherreports`资源的活动实例。这告诉我们，在没有任何额外配置的情况下，仅创建`CustomResourceDefinition`，Kubernetes
    API 服务器已通过新端点进行扩展，客户端已准备好与新的自定义资源进行交互。
- en: 'After defining the custom resource, it is now possible to create, update, and
    delete resources with the `WeatherReport`. An example of `WeatherReport` can be
    defined, as in the `k8s-operator-example/deploy/cr.yaml` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义自定义资源后，现在可以使用`WeatherReport`创建、更新和删除资源。`WeatherReport`的示例如下所示，可以在`k8s-operator-example/deploy/cr.yaml`文件中定义：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can find the `cr.yaml` file at: [https://goo.gl/4A3VD2](https://goo.gl/4A3VD2).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到`cr.yaml`文件：[https://goo.gl/4A3VD2](https://goo.gl/4A3VD2)。
- en: The `WeatherReport` resource has the same structure, with built-in resources
    and consists of API version, kind, metadata, and specification. In this example,
    the specif cation indicates that this resource is for the weather report for `Amsterdam`
    city and for the last 1 day.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherReport`资源具有相同的结构，包含内置资源，并由 API 版本、类型、元数据和规范组成。在此示例中，规范表示该资源是针对`阿姆斯特丹`城市过去1天的天气报告。'
- en: 'Deploy the weather report example with the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令部署天气报告示例：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Check for the newly created weather reports with the following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查新创建的天气报告：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You''ll see the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/47e6d784-6824-45f4-bc8e-eb0bd4e02938.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47e6d784-6824-45f4-bc8e-eb0bd4e02938.png)'
- en: 'Use the following commands for cleaning up:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进行清理：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Custom Controllers
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义控制器
- en: In the previous section and exercise, we were shown that custom resources enable
    us to extend the Kubernetes API. However, there is also a need for taking actions
    against custom resources and automating the tasks. In other words, who will create
    the weather report and collect the results when a new `weatherreport` resource
    is created? The answer to this question is a custom controller in Kubernetes,
    which are also known as **operators**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节和练习中，我们展示了自定义资源使我们能够扩展 Kubernetes API。然而，针对自定义资源采取行动和自动化任务也是必要的。换句话说，当创建一个新的`weatherreport`资源时，谁来生成天气报告并收集结果？这个问题的答案是
    Kubernetes 中的自定义控制器，也被称为**操作器**。
- en: With the built-in Kubernetes resources, it is possible to deploy, scale, and
    manage stateless web applications, mobile backends, and API services easily. When
    it comes to the stateful applications where additional operations are required,
    such
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 借助 Kubernetes 内置资源，可以轻松部署、扩展和管理无状态的 Web 应用程序、移动后端和 API 服务。当涉及到需要额外操作的有状态应用程序时，诸如初始化、存储、备份和监控等操作需要领域知识和人类专长。
- en: as initialization, storage, backup, and monitoring, domain knowledge and human
    expertise is needed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有状态应用程序，诸如初始化、存储、备份和监控等操作需要领域知识和人类专长。
- en: 'A custom controller, also known as an operator, is an application where domain
    knowledge and human expertise is converted into code. Operators work with custom
    resources and take the required actions when custom resources are created, updated,
    or deleted. The primary tasks of operators can be divided into three sections,
    **Observe**, **Analyze**, and **Act**, as shown in the following diagram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义控制器，也称为操作器，是一个将领域知识和人类专长转化为代码的应用程序。操作器与自定义资源一起工作，并在自定义资源被创建、更新或删除时采取所需的行动。操作器的主要任务可以分为三个部分，**观察**、**分析**和**行动**，如下图所示：
- en: '![](img/bbf6c67a-7609-43be-89aa-bf0600e6ed84.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbf6c67a-7609-43be-89aa-bf0600e6ed84.png)'
- en: 'The stages are explained as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 各个阶段解释如下：
- en: '**Observe**: Watches for changes on custom resources and related built-in resources
    such as pods.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察**：监视自定义资源和相关的内置资源（如 pods）的变化。'
- en: '**Analyze**: Makes an analysis of observed changes and decides on which actions
    to take.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：对观察到的变化进行分析，并决定采取哪些行动。'
- en: '**Act**: Takes actions based on the analysis and requirements and continues
    observing for changes.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动**：根据分析和需求采取行动，并继续观察变化。'
- en: 'For the weather report example, the operator pattern is expected to work as
    follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于天气报告示例，期望的操作模式如下：
- en: '**Observe**: Wait for weather report resource creation, update, and deletion.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察**：等待天气报告资源的创建、更新和删除。'
- en: '**Analyze**:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：'
- en: If a new report is requested, create a pod to gather weather report results
    and update weather report resources.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求新的报告，则创建一个 pod 以收集天气报告结果并更新天气报告资源。
- en: If the weather report is updated, update the pod to gather new weather report
    results.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果天气报告更新，则更新 pod 以收集新的天气报告结果。
- en: If the weather report is deleted, delete the corresponding pod.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果天气报告被删除，则删除相应的 pod。
- en: '**Act**: Take the actions from the **Analyze** step on the cluster and continue
    watching with **Observe**.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：对集群执行**分析**步骤中的操作，并继续使用**观察**进行监控。'
- en: Operators are already being utilized in the Kubernetes environment since they
    enable complex applications to run on the cloud with minimum human interaction.
    Storage providers (Rook), database applications (MySQL, CouchDB, PostgreSQL),
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '操作员已经在 Kubernetes 环境中得到应用，因为它们使复杂的应用程序能够在云端运行，且需要最小的人类干预。存储提供商（Rook）、数据库应用程序（MySQL、CouchDB、PostgreSQL）、 '
- en: big data solutions (Spark), distributed key/value stores (Consul, etcd), and
    many more modern cloud-native applications are installed on Kubernetes by their
    official operators.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大数据解决方案（Spark）、分布式键值存储（Consul、etcd）以及更多现代云原生应用程序，都通过其官方操作员在 Kubernetes 上安装。
- en: Operator Development
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作员开发
- en: Operators are native Kubernetes applications, and they extensively interact
    with the Kubernetes API. Therefore, being compliant with the Kubernetes API and
    converting domain expertise into software with a straightforward approach is critical
    for operator development. With these considerations, there are two paths for developing
    operators, as explained in the following sections.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员是原生 Kubernetes 应用程序，并且它们与 Kubernetes API 进行了广泛的交互。因此，符合 Kubernetes API 的要求，并通过简单明了的方式将领域知识转化为软件，对于操作员开发至关重要。考虑到这些因素，开发操作员有两条路径，具体内容将在以下章节中解释。
- en: Kubernetes Sample Controller
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 示例控制器
- en: In the official Kubernetes repository, a sample controller that implements watching
    custom resources is maintained. This repository demonstrates how to register new
    custom resources and how to perform basic operations on the new resource, such
    as creating, updating, or listing. In addition, controller logic is also implemented
    to show how to take actions. Repository and interaction with the Kubernetes API
    is a complete approach, which shows you how to create a Kubernetes like custom
    controller.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方 Kubernetes 仓库中，维护了一个示例控制器，用于实现自定义资源的监控。该仓库展示了如何注册新的自定义资源以及如何对新资源执行基本操作，如创建、更新或列出。此外，还实现了控制器逻辑，展示了如何执行操作。该仓库与
    Kubernetes API 的交互展示了如何创建类似 Kubernetes 的自定义控制器。
- en: Operator Framework
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Operator Framework
- en: The Operator Framework was announced at KubeCon 2018 as an open source toolkit
    for managing Kubernetes native applications. The Operator SDK is a part of this
    framework, and it simplifies operator development by providing higher level API
    abstractions and code generation. The Operator Framework and its environment toolset
    is open source and community maintained with the control of CoreOS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Operator Framework 于 2018 年 KubeCon 上宣布，是一个用于管理 Kubernetes 原生应用程序的开源工具包。Operator
    SDK 是该框架的一部分，它通过提供更高级的 API 抽象和代码生成来简化操作员开发。Operator Framework 及其环境工具集是开源的，由社区维护，控制权归
    CoreOS 所有。
- en: In this chapter, the Operator SDK from the Operator Framework has been selected
    to be used since SDK abstracts many low-level operations such as work queues,
    handler registrations, and informer management. With these abstractions, it is
    easier to handle **Observe** and **Act** parts with the packages from the SDK
    so that we can focus on the **Analyze** part.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中选择了 Operator Framework 中的 Operator SDK，因为 SDK 抽象了许多低级操作，如工作队列、处理程序注册和通知管理。通过这些抽象，使用
    SDK 包处理**观察**和**操作**部分变得更加简单，这样我们可以专注于**分析**部分。
- en: 'In the following section, the complete life cycle of operator development is
    covered with the following main steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，将涵盖操作员开发的完整生命周期，主要步骤如下：
- en: '**Create an operator project**: For the `WeatherReport` custom resource, an
    operator project in the Go language is created by using the Operator Framework
    SDK CLI.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建操作项目**：对于 `WeatherReport` 自定义资源，通过使用 Operator Framework SDK CLI 创建了一个 Go
    语言的操作项目。'
- en: '**Define custom resource specification**: The specification of the `WeatherReport`
    custom resource is defined in Go.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义自定义资源规范**：`WeatherReport` 自定义资源的规范在 Go 中定义。'
- en: '**Implement handler logic**: The manual operations needed for weather report
    collection are implemented in Go.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现处理程序逻辑**：手动操作所需的天气报告收集逻辑在 Go 中实现。'
- en: '**Build operator**: The operator project is built using the Operator Framework
    SDK CLI.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建操作符**：操作符项目使用 Operator Framework SDK CLI 构建。'
- en: '**Deploy operator**: The operator is deployed to the cluster, and it is tested
    by creating custom resources.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署操作符**：操作符被部署到集群中，并通过创建自定义资源进行测试。'
- en: Creating and Deploying the Kubernetes Operator
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和部署 Kubernetes 操作符
- en: A client wants to automate the operations of the weather report collection.
    They are currently connecting to third-party data providers and retrieving the
    results. In addition, they want to use cloud-native Kubernetes solutions in their
    clusters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个客户希望自动化天气报告收集的操作。他们目前正在连接第三方数据提供者并获取结果。此外，他们希望在集群中使用云原生的 Kubernetes 解决方案。
- en: We are expected to automate the operations of weather report data collection
    by implementing a Kubernetes operator.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计通过实现一个 Kubernetes 操作符来自动化天气报告数据收集的操作。
- en: 'We''ll create a Kubernetes operator by using the Operator Framework SDK and
    utilize it by creating a custom resource, custom controller logic, and finally,
    deploying into the cluster. Let''s begin by implementing the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 Operator Framework SDK 创建一个 Kubernetes 操作符，并通过创建自定义资源、自定义控制器逻辑，最终部署到集群中来使用它。让我们开始实现以下步骤：
- en: 'Create the operator project using the Operator Framework SDK tools with the
    following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令，利用 Operator Framework SDK 工具创建操作符项目：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command creates a completely new Kubernetes operator project with the name
    `k8s-operator-example` and watches for the changes of the `WeatherReport` custom
    resource, which is defined under `k8s.packt.com/v1`. The generated operator project
    is available under the `k8s-operator-example` folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建一个全新的 Kubernetes 操作符项目，名称为 `k8s-operator-example`，并监控 `WeatherReport` 自定义资源的变化，该资源在
    `k8s.packt.com/v1` 下定义。生成的操作符项目保存在 `k8s-operator-example` 文件夹中。
- en: 'A custom resource definition has already been generated in the `deploy/crd.yaml`
    file. However, the specification of the custom resource is left empty so that
    it can be filled by the developer. Specifications and statuses of the custom resources
    are coded in Go, as shown in `pkg/apis/k8s/v1/types.go`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个自定义资源定义已经在 `deploy/crd.yaml` 文件中生成。然而，自定义资源的规范被留空，供开发人员填写。自定义资源的规范和状态在 Go
    中编码，如 `pkg/apis/k8s/v1/types.go` 中所示：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can refer to the complete code at: [https://goo.gl/PSyf25](https://goo.gl/PSyf25).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考完整的代码，网址是：[https://goo.gl/PSyf25](https://goo.gl/PSyf25)。
- en: In the preceding code snippet, `WeatherReport` consists of `metadata`, `spec`,
    and `status`, just like any built-in Kubernetes resource. `WeatherReportSpec`
    includes the configuration, which is `City` and `Days` in our example.`WeatherReportStatus`
    includes State and Pod to keep track of the status and the created pod for the
    weather report collection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`WeatherReport` 由 `metadata`、`spec` 和 `status` 组成，就像任何内置的 Kubernetes
    资源一样。`WeatherReportSpec` 包括配置项，在我们的示例中是 `City` 和 `Days`。`WeatherReportStatus`
    包括状态和 Pod，用于跟踪状态以及为天气报告收集创建的 pod。
- en: 'One of the most critical parts of the operator is the handler logic, where
    domain expertise and knowledge is converted into code. In this example activity,
    when a new `WeatherReport` object is created, we will publish a pod that queries
    the weather service and writes the result to the console output. All of these
    steps are coded in the `pkg/stub/handler.go` file as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作符的一个最关键的部分是处理程序逻辑，在这里，领域知识和专业知识被转化为代码。在这个示例活动中，当创建一个新的 `WeatherReport` 对象时，我们将发布一个查询天气服务的
    pod，并将结果写入控制台输出。所有这些步骤都在 `pkg/stub/handler.go` 文件中编码，如下所示：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can refer the complete code at: [https://goo.gl/uxW4jv](https://goo.gl/uxW4jv).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考完整的代码，网址是：[https://goo.gl/uxW4jv](https://goo.gl/uxW4jv)。
- en: In the `Handle` function, events carrying objects are processed. This handler
    function is called from the informers watching for the changes on the registered
    objects. If the object is `WeatherReport` and its status is empty, a new weather
    report pod is created, and the status is updated with the results.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Handle` 函数中，处理携带对象的事件。此处理程序函数是从监视已注册对象变化的 informer 中调用的。如果对象是 `WeatherReport`
    且其状态为空，则会创建一个新的天气报告 pod，并使用结果更新状态。
- en: 'Build the complete project as a Docker container with the Operator SDK and
    toolset:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Operator SDK 和工具集构建完整的项目作为 Docker 容器：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The resulting Docker container is pushed to Docker Hub as `onuryilmaz/k8s-operator-example`
    for further usage in the cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结果 Docker 容器推送到 Docker Hub，命名为`onuryilmaz/k8s-operator-example`，以便在集群中进一步使用。
- en: 'Deploy the operator into the cluster with the following commands:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将操作符部署到集群中：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the successful deployment of the operator, logs could be checked as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 成功部署操作符后，可以按如下方式检查日志：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/733e017d-8bee-44a0-a0df-eec09e4d4536.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/733e017d-8bee-44a0-a0df-eec09e4d4536.png)'
- en: 'After deploying the custom resource definition and the custom controller, it
    is time to create some resources and collect the results. Create a new `WeatherReport`
    instance as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署自定义资源定义和自定义控制器后，接下来是创建一些资源并收集结果。按照以下方式创建一个新的`WeatherReport`实例：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With its successful creation, the status of the `WeatherReport` can be checked:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其成功创建，可以检查`WeatherReport`的状态：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will see the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/74d1bd80-9521-44f3-b5a0-f997ee310495.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74d1bd80-9521-44f3-b5a0-f997ee310495.png)'
- en: 'Since the operator created a pod for the new weather report, we should see
    it in action and collect the results:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于操作符为新的天气报告创建了一个 pod，我们应该看到它的运行并收集结果：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You''ll see the following result:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下结果：
- en: '![](img/cdbad87f-7b00-4343-ab32-8e3085d9777e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdbad87f-7b00-4343-ab32-8e3085d9777e.png)'
- en: 'Get the result of the weather report with the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取天气报告的结果：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You''ll see the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/6d04f366-a8bb-44ff-9b6c-d96126b5a19f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d04f366-a8bb-44ff-9b6c-d96126b5a19f.png)'
- en: 'Clean up with the following command:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令清理：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Kubernetes Dynamic Admission Control
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 动态准入控制
- en: The Kubernetes API server is responsible for every request. The extension point
    in the request life cycle in the API server is for dynamic admission control.
    The admission controller is one of the most important stages of the request life
    cycle, since it intercepts and checks whether a request should be approved or
    not.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器负责每个请求。API 服务器请求生命周期中的扩展点是用于动态准入控制。准入控制器是请求生命周期中最重要的阶段之一，因为它拦截并检查请求是否应该被批准。
- en: 'For every API request, first of all, the requester is checked by authentication
    and authorization. Afterward, admission controllers are run and decide to approve
    or reject the request. Finally, validation steps are carried out, and the resulting
    objects are stored:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个 API 请求，首先会通过身份验证和授权检查请求者。之后，准入控制器运行并决定是否批准或拒绝请求。最后，进行验证步骤，并将结果对象存储：
- en: '![](img/dfd8705f-19ba-434c-8e27-d94136059d13.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfd8705f-19ba-434c-8e27-d94136059d13.png)'
- en: Life cycle of a Kubernetes API request
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 请求的生命周期
- en: 'The *dynamic* part of admission control comes from the fact that they can be
    dynamically added, removed, or updated during the runtime of Kubernetes clusters.
    In addition to the built-in admission controllers, there are ways of extending
    admission controllers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制的*动态*部分源于它们可以在 Kubernetes 集群运行时动态添加、移除或更新。除了内置的准入控制器外，还有扩展准入控制器的方法：
- en: Image policy webhooks for restricting the images in the cluster
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于限制集群中镜像的镜像策略 webhook
- en: Admission webhooks for approving or rejecting the creation or updates
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于批准或拒绝创建或更新的准入 webhook
- en: Initializers for modifying objects prior to their creation
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于修改对象的初始化器，在对象创建之前进行更改
- en: Admission Webhooks
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入 Webhook
- en: 'Admission webhooks are extension points that can receive admission requests
    by the API server and then return accept or reject responses. As they are webhooks,
    HTTP requests and responses are expected by the API server. Two types of admission
    webhooks are supported:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 准入 webhook 是扩展点，API 服务器可以接收准入请求，然后返回接受或拒绝的响应。由于它们是 webhook，API 服务器期望收到 HTTP
    请求和响应。支持两种类型的准入 webhook：
- en: Validating admission webhooks for rejecting or accepting CRUD requests
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于拒绝或接受 CRUD 请求的验证准入 webhook
- en: Mutating admission webhooks for changing the requests to enforce custom default
    values
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于更改请求以强制执行自定义默认值的变更准入 webhook
- en: Dynamic admission webhook configurations are deployed to the cluster during
    runtime as `MutatingWebhookConfiguration` or `ValidatingWebhookConfiguration`
    objects. When an API request is received, the API server creates the necessary
    controls during the admission webhooks stage. If there are webhook configurations
    defined for the request, the admission controller sends a request to the specified
    servers and collect the responses. If all checks are approved, validation and
    persistence steps continue for handling the API request.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 动态准入Webhook配置在运行时作为`MutatingWebhookConfiguration`或`ValidatingWebhookConfiguration`对象部署到集群中。当收到API请求时，API服务器会在准入Webhook阶段创建必要的控制。如果为该请求定义了Webhook配置，准入控制器会向指定的服务器发送请求并收集响应。如果所有检查都通过，则继续进行验证和持久化步骤以处理API请求。
- en: Admission webhooks work on all request types, such as create, update, or delete,
    and they are robust and widely used. However, they cannot query the resources
    since webhooks are not part of the Kubernetes API server. In addition, admission
    webhooks are not generally available yet and are still in development.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Admission Webhook适用于所有请求类型，如创建、更新或删除，并且它们功能强大且广泛使用。然而，它们无法查询资源，因为Webhook不是Kubernetes
    API服务器的一部分。此外，Admission Webhook尚未完全可用，仍在开发中。
- en: Initializers
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化器
- en: Initializers are dynamic runtime elements of the Kubernetes workflow that enable
    the modification of the resources before their actual creation. In other words,
    initializers allow developers to interfere with and make any changes to the resources,
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器是Kubernetes工作流中的动态运行时元素，允许在资源实际创建之前对其进行修改。换句话说，初始化器允许开发人员干预并对资源进行任何更改，
- en: such as deployments or pods, and include custom modification logic for the Kubernetes
    resource life cycle.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如部署或Pod，并包括自定义修改逻辑，以便在Kubernetes资源生命周期中使用。
- en: 'Some possible use cases of initializers are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器的一些可能使用案例如下：
- en: Injecting a sidecar container
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入侧车容器
- en: Injecting a volume with certificates
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入带有证书的卷
- en: Preventing the creation of some resources that violate custom limitations
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止创建违反自定义限制的资源
- en: Initializers are dynamic controllers, and they are defined or removed during
    runtime with `InitializerConfiguration` resources. `InitializerConfiguration`
    combines a set of resources and initializers so that when a matching resource
    is created, the API server adds the corresponding initializer to the resource
    definition.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器是动态控制器，它们在运行时通过`InitializerConfiguration`资源进行定义或移除。`InitializerConfiguration`将一组资源和初始化器结合在一起，以便当创建匹配的资源时，API服务器将相应的初始化器添加到资源定义中。
- en: The list of initializers are maintained in the `metadata.initializers.pending`
    field. On the other hand, initializers are always watching for the new resources
    so that they can implement their custom logic on the objects. When *Initializer
    X* is in the first slot, namely `metadata.initializers.pending[0]` , *Initializer
    X* gets the resource and modifiers. Then, it removes itself, *Initializer X*,
    from the `metadata.initializers.pending` list so that the next initializer will
    work. When all of the initializers complete their operations, and the list is
    empty, the resource is released and continues the creation life cycle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器的列表保存在`metadata.initializers.pending`字段中。另一方面，初始化器始终在监视新的资源，以便它们可以对对象实现自定义逻辑。当*Initializer
    X*在第一个位置，即`metadata.initializers.pending[0]`时，*Initializer X*获取资源和修改器。然后，它将自己，*Initializer
    X*，从`metadata.initializers.pending`列表中移除，以便下一个初始化器可以工作。当所有初始化器完成其操作并且列表为空时，资源被释放并继续创建生命周期。
- en: Initializers are easy to develop, and they are an extremely flexible way of
    extending the admission control mechanism. However, the uptime of the initializers
    is critical since they will block the API server. In addition, initializers are
    not generally available and are still in development.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器易于开发，并且是扩展准入控制机制的极其灵活的方式。然而，初始化器的正常运行时间至关重要，因为它们会阻塞API服务器。此外，初始化器尚未完全可用，仍在开发中。
- en: Extending the Kubernetes Scheduler
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Kubernetes调度器
- en: 'Pods are the basic unit of work that are scheduled by Kubernetes to run on
    nodes. By default, Kubernetes has a built-in scheduler, and it tries to assign
    pods to the nodes evenly by ensuring that there are sufficient free resources.
    There are some use cases to configure and extend the scheduler behavior of Kubernetes
    considering the custom requirements of scalable and reliable cloud-native applications:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes调度运行在节点上的基本工作单元。默认情况下，Kubernetes具有内置调度器，它通过确保有足够的空闲资源来尽量均匀地将Pod分配到节点上。针对可扩展和可靠的云原生应用的自定义需求，有一些使用场景需要配置和扩展Kubernetes的调度器行为：
- en: Running certain pods on specialized hardware
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在专用硬件上运行特定的Pod。
- en: Co-locating some pods that include interacting services
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一些Pod与交互服务共同部署。
- en: Dedicating some nodes to some users
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一些节点专门分配给特定用户。
- en: 'Scheduler customization and extension patterns, starting from the basics to
    the complex, are listed as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器定制和扩展模式，从基础到复杂，列举如下：
- en: Assigning node labels and using node selectors
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配节点标签并使用节点选择器。
- en: Using affinity and anti-affinity rules
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用亲和性和反亲和性规则。
- en: Marking nodes with taints, and pods with tolerations
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为节点标记污点，并为Pod配置容忍度。
- en: Creating and deploying custom scheduler algorithms
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和部署自定义调度算法。
- en: Node Labels
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点标签。
- en: The fundamental underlying idea of scheduling is based on the labels of nodes
    in Kubernetes. The built-in scheduler and any custom schedulers are expected to
    check the specification of the nodes from their labels. With this idea, there
    are some
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 调度的基本概念是基于Kubernetes中节点的标签。内置调度器以及任何自定义调度器都需要根据节点的标签来检查节点的规格。基于这一概念，存在一些
- en: 'integrated node labels, such as the following ones:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 集成的节点标签，例如以下标签：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These labels and their values are assigned by the cloud providers, but do note
    that label values are not standardized yet. For Minikube, there is only one master
    node, and its labels can be checked with the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签及其值由云服务提供商分配，但请注意，标签值尚未标准化。对于Minikube，只有一个主节点，可以通过以下命令检查其标签：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As highlighted, the node with the hostname `minikube` has an architecture of
    amd64 with an operating system, `linux`, and its `node-role` is `master`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，主机名为`minikube`的节点，其架构为amd64，操作系统为`linux`，并且`node-role`为`master`。
- en: Node Selectors
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点选择器。
- en: Node selectors are the most straightforward constraints that can be used with
    the Kubernetes scheduler. Node selectors are part of pod specification, and they
    are key-value maps. The keys of the node selector are expected to match with node
    labels,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 节点选择器是可以与Kubernetes调度器一起使用的最简单的约束条件。节点选择器是Pod规格的一部分，它们是键值对映射。节点选择器的键需要与节点标签匹配。
- en: and the values are the constraints for the scheduler.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是调度器的约束条件。
- en: 'They are included in the pod specification as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它们包含在Pod规格中，如下所示：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With that pod definition, the Kubernetes scheduler is limited to assigning the
    pod `nginx` to a node with an architecture of `amd64`. If there are no nodes with
    the constraints, the pods will wait in a Pending state until a node that ensures
    the
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该Pod定义后，Kubernetes调度器会限制将Pod `nginx`分配给架构为`amd64`的节点。如果没有符合约束的节点，Pod将处于Pending状态，直到有满足条件的节点出现。
- en: limitations join the cluster.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 限制加入集群。
- en: Node Affinity
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点亲和性。
- en: 'Node affinity is a more expressive form of the nodeSelector specification,
    which includes two sets of constraints:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 节点亲和性是比`nodeSelector`更具表现力的节点选择器规范，它包含了两组约束条件：
- en: '`requiredDuringSchedulingIgnoredDuringExecution`: This set indicates the constraints
    that must be satisfied prior to scheduling a pod to a node. This set is similar
    to `nodeSelector`; however, it enables more flexible definitions.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requiredDuringSchedulingIgnoredDuringExecution`：这组约束表示在调度Pod到节点之前必须满足的条件。这组约束类似于`nodeSelector`，但是它支持更灵活的定义。'
- en: '`preferredDuringSchedulingIgnoredDuringExecution`: This set indicates the constraints
    that are preferred during scheduling, but not guaranteed.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preferredDuringSchedulingIgnoredDuringExecution`：这组约束表示在调度时优先考虑的条件，但不保证满足。'
- en: In short, the first set consists of the hard limits for the scheduler, whereas
    the second set consists of the soft limits. The `IgnoredDuringExecution` part
    indicates if labels change and constraints are not satisfied during runtime, no
    changes will be made by the scheduler.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，第一组包含了调度器的硬性限制，而第二组则包含了软性限制。`IgnoredDuringExecution`部分表示，如果标签在运行时发生变化且约束未满足，调度器将不做任何更改。
- en: 'With these node affinity rules, it is easy to define complex rules in order
    to limit the scheduler. For instance, in the following pod definition with the
    `requiredDuringSchedulingIgnoredDuringExecution` group, pods are restricted to
    run only in a PowerPC environment. In addition, with the `preferredDuringSchedulingIgnoredDuringExecution`
    group, pods attempt to run on the nodes in availability zone A if possible:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些节点亲和性规则，可以轻松定义复杂的规则以限制调度器。例如，在下面的 pod 定义中，使用 `requiredDuringSchedulingIgnoredDuringExecution`
    组，pods 被限制仅在 PowerPC 环境中运行。此外，使用 `preferredDuringSchedulingIgnoredDuringExecution`
    组时，pods 会尽可能尝试在可用区 A 的节点上运行：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Pod Affinity
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod 亲和性
- en: The node affinity rules from the last section define pod and node assignment
    relationships. They describe a set of restrictions for pods to run on a set of
    nodes. With the same approach, inter-pod affinity, and anti-affinity rules, define
    constraints based on other pods. For instance, with the pod affinity rules, pods
    can be scheduled together for a limited set of nodes. Likewise, with the pod anti-affinity
    rules, pods can repel each other for a specific topology key, for instance, a
    node. For pod affinities, hard and soft limits can be defined with `requiredDuringSchedulingIgnoredDuringExecution`
    and `preferredDuringSchedulingIgnoredDuringExecution`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的节点亲和性规则定义了 pod 和节点的分配关系。它们描述了一组限制条件，要求 pods 只能在一组节点上运行。采用相同的方法，Pod 间亲和性和反亲和性规则可以根据其他
    pods 定义约束。例如，使用 pod 亲和性规则时，pods 可以在有限的节点集上一起调度。同样，使用 pod 反亲和性规则时，pods 可以基于特定的拓扑键（例如，节点）相互排斥。对于
    pod 亲和性，可以使用 `requiredDuringSchedulingIgnoredDuringExecution` 和 `preferredDuringSchedulingIgnoredDuringExecution`
    定义硬性和软性限制。
- en: 'With the following pod definition, pod affinity ensures that pods will only
    run on the nodes in the same availability zone, that is, pods with the `service=backend`
    label. In other words, affinity rules will try and ensure that our pod will be
    scheduled into the same availability zone, with the backend services, considering
    they are interacting with each other. With the pod anti-affinity, the scheduler
    will try not to run on the nodes that already have pods running in the `service=backend`
    label. In other words, if possible, they will not be scheduled to the same nodes
    with the backend to avoid creating a single point of failure:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 pod 定义中，pod 亲和性确保 pods 仅在同一可用区的节点上运行，即具有 `service=backend` 标签的 pods。换句话说，亲和性规则会尽量确保我们的
    pod 被调度到同一可用区，与后端服务一起运行，因为它们正在相互交互。使用 pod 反亲和性时，调度器将尽量避免在已经运行 `service=backend`
    标签的节点上运行 pods。换句话说，若可能，它们将不会与后端服务调度到相同节点，以避免单点故障的出现：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Taints and Tolerations
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 污点和容忍
- en: Affinity rules define constraints for the scheduler so that they can assign
    pods on the nodes. On the other hand, Kubernetes provides a way of rejecting pods
    from the standpoint of nodes by taints and tolerations. Taints and tolerations
    work together so that a set of pods are not scheduled to a set of nodes. Taints
    are applied to the nodes to reject some pods, and tolerations allow the pod to
    be accepted on some nodes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 亲和性规则为调度器定义了约束条件，使其能够将 pods 调度到合适的节点上。另一方面，Kubernetes 提供了一种通过污点和容忍从节点的角度拒绝 pods
    的方式。污点和容忍协同工作，以确保一组 pods 不会被调度到一组节点上。污点应用于节点，用于拒绝某些 pods，而容忍则允许 pod 在某些节点上接受调度。
- en: 'Taints tag the nodes with pod labels for "not scheduling". For instance, with
    the following command, no pods will be scheduled to `nodeA` unless matching tolerations
    are defined for key and value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 污点为节点打上标签，标记为“不可调度”。例如，使用以下命令，除非为键和值定义了匹配的容忍，否则不会将任何 pods 调度到 `nodeA`：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Tolerations tags the pods so that the taints are not applied to these pods.
    For example, with the following toleration in the pod specification, the preceding
    taint will not be applied:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 容忍为 pods 打上标签，以确保污点不会应用到这些 pods。例如，在 pod 规范中使用以下容忍，前面的污点将不会被应用：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Tolerations and taints work together so that nodes can be tainted with some
    user groups or specific labels, and tolerations can be defined in the pod definition
    for the following use cases:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 容忍和污点协同工作，使节点可以带有某些用户组或特定标签，容忍则可以在 pod 定义中为以下使用场景定义：
- en: Dedicated nodes
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用节点
- en: Nodes with special hardware
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有特殊硬件的节点
- en: Taint-based evictions for the behavior in the case of node problems
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于污点的驱逐行为，以应对节点故障
- en: Custom Scheduler Development
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义调度器开发
- en: The Kubernetes scheduler can be highly configured with node selectors, node
    affinity, pod affinity, taints, and toleration rules. In the case of custom scheduling
    requirements, it is also possible to develop and deploy custom schedulers in a
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 调度器可以通过节点选择器、节点亲和性、pod 亲和性、污点和容忍规则进行高度配置。在有自定义调度需求的情况下，也可以开发并部署自定义调度器。
- en: Kubernetes cluster. Kubernetes supports running multiple schedulers out-of-the-box.
    A custom scheduler in Kubernetes can be developed with any programming language.
    However, since it will interact extensively with the Kubernetes API, it is
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群。Kubernetes 默认支持运行多个调度器。Kubernetes 中的自定义调度器可以使用任何编程语言开发。然而，由于它将与
    Kubernetes API 广泛交互，通常使用具有 Kubernetes 客户端库的编程语言：
- en: 'customary to use a programming language that has a Kubernetes client library:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用具有 Kubernetes 客户端库的编程语言：
- en: '![](img/90772b5c-9a77-48d7-9d62-31183635039f.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90772b5c-9a77-48d7-9d62-31183635039f.png)'
- en: The basic workflow of the scheduler can be divided into three main consecutive
    stages. The scheduler waits for the pods with the specific scheduler name and
    no node assignment. When such a pod is found, the scheduler runs its custom algorithms
    to find a suitable node. Finally, the scheduler creates a binding, which is a
    built-in subresource of a pod in Kubernetes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器的基本工作流可以分为三个主要的连续阶段。调度器等待具有特定调度器名称且未分配节点的 pod。当找到这样的 pod 时，调度器运行其自定义算法以找到合适的节点。最后，调度器创建一个绑定，它是
    Kubernetes 中 pod 的内置子资源。
- en: 'A custom scheduler in Go is implemented in the `k8s-scheduler-example/main.
    go` file and the basic workflow of *Wait*, *Find a suitable node*, and the *Create
    pod binding* stages are combined together in the following code snippet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 实现的自定义调度器位于 `k8s-scheduler-example/main.go` 文件中，以下代码片段将 *等待*、*查找合适的节点*
    和 *创建 pod 绑定* 阶段组合在一起：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `schedule` function in the following code snippet is provided to create
    a binding between the pod and a node. The `Bind` method is called under the pod
    in `clientset` in the last line of the function since it is a subresource of a
    pod:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中的 `schedule` 函数用于在 pod 和节点之间创建绑定。`Bind` 方法在函数的最后一行调用，它位于 `clientset`
    中的 pod 下，因为它是 pod 的一个子资源：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This custom scheduler randomly assigns nodes to the pods with the custom scheduler
    named `packt-scheduler`. The build files and documentation are provided under
    the `k8s-scheduler-example` folder, and are ready to be deployed to the cluster.
    In the following section, the deployment and use of multiple schedulers in a Kubernetes
    cluster will be presented.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义调度器会将节点随机分配给名为 `packt-scheduler` 的 pod。构建文件和文档已在 `k8s-scheduler-example`
    文件夹下提供，并准备好部署到集群中。在接下来的部分中，将介绍在 Kubernetes 集群中部署和使用多个调度器。
- en: Deploying and using a Custom Kubernetes Scheduler
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署并使用自定义 Kubernetes 调度器
- en: 'Consider, a client has a Kubernetes cluster and requires an additional scheduler
    for the pods with predefined labels. The new scheduler should work side-by-side
    with the built-in scheduler, and it should be deployed to the cluster. We''ll
    deploy and use a custom Kubernetes scheduler and check how the schedulers work
    in the cluster. We need to ensure that the following steps are completed before
    deploying a Kubernetes scheduler:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个客户端拥有一个 Kubernetes 集群，并需要为带有预定义标签的 pod 配置一个额外的调度器。新的调度器应与内置调度器并行工作，并且需要部署到集群中。我们将部署并使用一个自定义的
    Kubernetes 调度器，并检查调度器在集群中的工作情况。在部署 Kubernetes 调度器之前，需要确保完成以下步骤：
- en: Use the random assignment scheduler from this exercise.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本练习中的随机分配调度器。
- en: 'The scheduler container is already in Docker hub: `onuryilmaz/k8sscheduler-example`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器容器已经存在于 Docker hub 上：`onuryilmaz/k8sscheduler-example`。
- en: Use `packt-scheduler` as the custom scheduler name.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `packt-scheduler` 作为自定义调度器名称。
- en: Show the status of the pods if the custom scheduler is not running.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果自定义调度器未运行，则显示 pod 的状态。
- en: 'You can find the `pod.yaml` file at: [https://goo.gl/aCRppt](https://goo.gl/aCRppt).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到 `pod.yaml` 文件：[https://goo.gl/aCRppt](https://goo.gl/aCRppt)。
- en: 'Let''s begin with the implementation:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现开始：
- en: 'Create a pod with the custom scheduler name, defined as `packt-scheduler`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用自定义调度器名称的 pod，名称定义为 `packt-scheduler`：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After deploying the pod, its status can be checked:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 pod 后，可以检查其状态：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/026e2563-a4ea-4c65-aa25-d050c3fba0b7.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/026e2563-a4ea-4c65-aa25-d050c3fba0b7.png)'
- en: Since there is no scheduler deployed to the cluster with the name `packt-scheduler`,
    its status will be stuck as `Pending` forever.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有名为 `packt-scheduler` 的调度器部署到集群中，因此其状态将永远停留在 `Pending`。
- en: 'Deploy the scheduler into the cluster with the following command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将调度器部署到集群中：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can find the `scheduler.yaml` file at: [https://goo.gl/AaSu8o](https://goo.gl/AaSu8o).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下地址找到 `scheduler.yaml` 文件：[https://goo.gl/AaSu8o](https://goo.gl/AaSu8o)。
- en: 'Check the pods with the following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查 Pods：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You''ll get the following output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '![](img/94b1c7d9-532e-497a-8db2-b66aa50ab0c9.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94b1c7d9-532e-497a-8db2-b66aa50ab0c9.png)'
- en: As shown previously, the scheduler runs in a pod and, in addition, the `nginx`
    pod, which was Pending before, now has the `Running` status.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，调度器在一个 Pod 中运行，并且此前处于 Pending 状态的 `nginx` Pod，现在已经显示为 `Running` 状态。
- en: 'In addition, check the logs of the scheduler:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，请检查调度器的日志：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You''ll get the following output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '![](img/3c3dabd6-40dd-42d6-bb97-e6cb68a099e6.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c3dabd6-40dd-42d6-bb97-e6cb68a099e6.png)'
- en: 'Run the following command for cleaning up:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进行清理：
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Extending Kubernetes Infrastructure
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes 基础设施
- en: 'Kubernetes clusters are run on actual bare-metal clusters and interact with
    the infrastructure systems running on the servers. Extension points for infrastructure
    are still in the design stage and not mature enough for standardization. However,
    they can be grouped as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群运行在实际的裸金属集群上，并与运行在服务器上的基础设施系统进行交互。基础设施的扩展点仍处于设计阶段，尚不成熟，无法进行标准化。然而，它们可以按如下方式分组：
- en: '**Server**: The Kubernetes node components interact with container runtimes
    such as Docker. Currently, Kubernetes is designed to work with any container runtime
    that implements the **Container Runtime Interface** (**CRI**) specification. CRI
    consists of libraries, protocol buffers, and the gRPC API to define the interaction
    between Kubernetes and the container environment.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：Kubernetes 节点组件与 Docker 等容器运行时进行交互。目前，Kubernetes 被设计为可以与任何实现 **容器运行时接口**
    (**CRI**) 规范的容器运行时一起工作。CRI 包括库、协议缓冲区和 gRPC API，用于定义 Kubernetes 与容器环境之间的交互。'
- en: '**Network**: Kubernetes and the container architecture requires high-performance
    networking, decoupled from container runtime. The connections between containers
    and network interfaces are defined with the abstraction of the **Container Network
    Interface** (**CNI**). The CNI consists of a set of interfaces for adding and
    removing containers from the Kubernetes network.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：Kubernetes 和容器架构需要高性能的网络，且与容器运行时解耦。容器与网络接口之间的连接通过 **容器网络接口** (**CNI**)
    的抽象进行定义。CNI 包含一组接口，用于将容器添加到或从 Kubernetes 网络中移除。'
- en: '**Storage**: Storage for Kubernetes resources is provided by the storage plugins
    that are communicating with cloud providers or the host system. For instance,
    a Kubernetes cluster running on AWS could easily get storage from AWS and attach
    to its stateful sets. Operations including storage provisioning and consuming
    in container runtimes are standardized under the **Container Storage Interface**
    (**CSI**). In Kubernetes, any storage plugin implementing CSI can be used as a
    storage provider.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：Kubernetes 资源的存储由与云提供商或主机系统通信的存储插件提供。例如，运行在 AWS 上的 Kubernetes 集群可以轻松地从
    AWS 获取存储并附加到其有状态集合。包括存储提供和在容器运行时中消费的操作在 **容器存储接口** (**CSI**) 下进行了标准化。在 Kubernetes
    中，任何实现 CSI 的存储插件都可以作为存储提供者使用。'
- en: The infrastructure of Kubernetes can be extended to work with servers implementing
    CRI, network providers compliant with CNI, and storage providers realizing CSI.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的基础设施可以扩展，以便与实现 CRI 的服务器、符合 CNI 的网络提供商和实现 CSI 的存储提供商一起工作。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, extending Kubernetes was covered, where we enabled converting
    domain expertise into automation and intervening Kubernetes operations. Firstly,
    the extension points in Kubernetes were presented to show its built-in extension
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了扩展 Kubernetes，我们启用了将领域知识转化为自动化并介入 Kubernetes 操作的能力。首先，介绍了 Kubernetes 中的扩展点，展示了其内置的扩展功能。
- en: capabilities. Throughout the chapter, new resources were added to the Kubernetes
    API, and their operations were automated so that Kubernetes can work for custom
    resources in addition to the built-in ones. Following this, resource creation
    logic was extended with dynamic admission controllers, and you were shown how
    to include operational requirements in the Kubernetes API resource life cycle.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 功能。在本章中，Kubernetes API 添加了新的资源，并自动化了它们的操作，以便 Kubernetes 除了支持内置资源外，还能为自定义资源提供服务。接着，资源创建逻辑通过动态准入控制器进行了扩展，展示了如何将操作要求纳入
    Kubernetes API 资源生命周期。
- en: Finally, configuring the scheduler of Kubernetes was presented to cover all
    extensive
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，展示了 Kubernetes 调度器的配置，涵盖了所有广泛的
- en: requirements for nodes and inter-pod relations. How to write, deploy, and use
    a custom scheduler was also shown. With the extension capabilities included in
    this chapter, it is possible to use Kubernetes, not only as a container orchestrator,
    but as a
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 节点和 Pod 之间关系的要求。如何编写、部署和使用自定义调度器也有展示。通过本章中包含的扩展功能，可以将 Kubernetes 用作容器编排器，不仅如此，还可以作为一个
- en: platform capable of handling all custom requirements of cloud-native applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 平台，能够处理云原生应用程序的所有自定义需求。
- en: In this book, Kubernetes design patterns and extensions were presented from
    their foundations to their implementations in a cloud-native microservice architecture.
    Firstly, in the first chapter, best practices for Kubernetes were covered. Design
    patterns and their reflections on the cloud-native architecture of Kubernetes
    were illustrated in order to create best practice knowledge. In the second chapter,
    how to connect to Kubernetes programmatically was presented. The hands-on activities
    on client libraries were aimed at being ready for the applications that communicate
    with Kubernetes. These Kubernetes API consuming applications will make a difference
    for utilizing Kubernetes and enable achieving more than a casual Kubernetes user.
    In the last chapter, Kubernetes extension points were covered. Kubernetes extension
    points enable converting domain expertise into automation and intervening Kubernetes
    operations. With the extension capabilities included in this last chapter, it
    is possible to use Kubernetes, not only as a container orchestrator, but as a
    platform capable of handling the complex requirements of cloud-native applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本书介绍了 Kubernetes 设计模式和扩展，从其基础到在云原生微服务架构中的实现。首先，在第一章中，涵盖了 Kubernetes 的最佳实践。设计模式及其在
    Kubernetes 云原生架构中的反映得到了说明，以便创建最佳实践知识。在第二章中，展示了如何以编程方式连接到 Kubernetes。关于客户端库的实操活动旨在为与
    Kubernetes 通信的应用程序做好准备。这些 Kubernetes API 消费应用程序将帮助你与 Kubernetes 深度互动，实现比普通 Kubernetes
    用户更多的功能。最后一章，讲解了 Kubernetes 的扩展点。Kubernetes 扩展点使得将领域专长转化为自动化并介入 Kubernetes 操作成为可能。通过本章中包含的扩展能力，可以将
    Kubernetes 用作容器编排器，不仅如此，还可以作为一个平台，能够处理云原生应用程序复杂的需求。
