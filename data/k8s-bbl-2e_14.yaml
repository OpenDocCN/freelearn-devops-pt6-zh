- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Working with Helm Charts and Operators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm Charts 和 Operators
- en: In the Kubernetes ecosystem, it is very important to manage application redistribution
    and dependency management in cases when you want your applications to be easily
    downloadable and installable for customers, or when you want to share them between
    teams. One of the big differences between Linux package managers like APT or YUM
    and Kubernetes tools, such as Helm, is that they work universally and don’t depend
    on a particular Kubernetes distribution. Helm enables the easily distributive
    creation of applications by means of packaging multiple resources into charts,
    supporting easy reuse and customization of applications across diverse environments.
    This relieves the struggle of managing a large number of YAML manifests in application
    deployments and therefore lightens the load on a developer or an operator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 生态系统中，当你希望让应用程序便于客户下载和安装，或者希望在团队之间共享时，管理应用程序的重新分配和依赖关系管理非常重要。与像
    APT 或 YUM 这样的 Linux 包管理器不同，Kubernetes 工具（如 Helm）有一个显著的区别，那就是它们是通用的，并且不依赖于特定的 Kubernetes
    发行版。Helm 通过将多个资源打包成 charts，使应用程序的分发创建变得简单，支持在不同环境中轻松地重用和定制应用程序。这减轻了在应用程序部署中管理大量
    YAML 清单的难题，从而减轻了开发者或运维人员的负担。
- en: 'Kubernetes Operators further complement Helm by adding the ability to manage
    an application’s life cycle in automated ways such as upgrades, failovers, and
    backups, and by maintaining consistent configurations. Together, Helm and the
    Operators help with some of the challenges of scaling and managing applications
    within Kubernetes. This chapter explores these tools in depth: Helm chart development,
    how to install popular components, and successful redistribution of Kubernetes
    applications.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Operators 通过增加自动化管理应用生命周期的能力（如升级、故障转移和备份），并维护一致的配置，从而进一步补充 Helm。Helm
    和 Operators 共同帮助解决在 Kubernetes 中扩展和管理应用程序的一些挑战。本章将深入探讨这些工具：Helm chart 开发，如何安装流行组件，以及
    Kubernetes 应用程序的成功重分发。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Helm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Helm
- en: Releasing software to Kubernetes using Helm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helm 向 Kubernetes 发布软件
- en: Installing Kubernetes Dashboard using Helm Charts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helm Charts 安装 Kubernetes Dashboard
- en: Introducing Kubernetes Operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes Operators
- en: Enabling Kubernetes monitoring using Prometheus and Grafana
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Prometheus 和 Grafana 启用 Kubernetes 监控
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需内容：
- en: A Kubernetes cluster deployed. We recommend using a *multi-node, or* cloud-based,
    Kubernetes cluster if possible. You need to ensure CPU, memory, and storage resources
    are allocated for the Kubernetes cluster to ensure multiple Pods can be scheduled
    (e.g., you can create a larger minikube cluster using the command `minikube start
    --kubernetes-version=1.31.0 --cpus=4 --memory=8g`).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的 Kubernetes 集群。如果可能的话，建议使用*多节点的或*基于云的 Kubernetes 集群。你需要确保为 Kubernetes 集群分配了
    CPU、内存和存储资源，以确保可以调度多个 Pods（例如，你可以使用命令 `minikube start --kubernetes-version=1.31.0
    --cpus=4 --memory=8g` 创建一个较大的 minikube 集群）。
- en: The Kubernetes **command-line interface** (**CLI**) (`kubectl`) installed on
    your local machine and configured to manage your Kubernetes cluster.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地机器上安装并配置的 Kubernetes **命令行接口**（**CLI**）（`kubectl`），用于管理你的 Kubernetes 集群。
- en: 'Basic Kubernetes cluster deployment (local and cloud-based) and `kubectl` installation
    have been covered in *Chapter 3*, *Installing Your First Kubernetes Cluster*.
    The upcoming chapters, *15*, *16*, and *17*, can give you an overview of how to
    deploy a fully functional Kubernetes cluster on different cloud platforms. You
    can download the latest code samples for this chapter from the official GitHub
    repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter14'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 Kubernetes 集群部署（本地和基于云的）和 `kubectl` 安装已经在*第 3 章*《安装你的第一个 Kubernetes 集群》中讲解。接下来的第*15*、*16*
    和 *17* 章将为你提供如何在不同云平台上部署一个功能完善的 Kubernetes 集群的概览。你可以从官方 GitHub 仓库下载本章的最新代码示例：[https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter14)
- en: )
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Understanding Helm
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Helm
- en: 'This approach is often used as a basic showcase of how you can run a given
    application as a container on Kubernetes. However, sharing raw YAML manifests
    has quite a few disadvantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常作为展示如何将给定应用程序作为容器运行在 Kubernetes 上的基本示例。然而，直接共享原始 YAML 清单有很多缺点：
- en: All values in YAML templates are *hardcoded*. This means that if you want to
    change the number of replicas of a Service object target or a value stored in
    the ConfigMap object, you need to go through the manifest files, find the values
    you want to configure, and then edit them. Similarly, if you want to deploy the
    manifests to a different namespace in the cluster than the creators intended,
    you need to edit all YAML files. On top of that, you do not really know which
    values in the YAML templates are intended to be configurable by the creator unless
    they document this.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML 模板中的所有值都是*硬编码*的。这意味着，如果你想更改 Service 对象目标的副本数或存储在 ConfigMap 对象中的值，你需要通过清单文件，找到你想要配置的值，然后进行编辑。同样，如果你想将清单部署到与创建者原意不同的集群命名空间，你也需要编辑所有的
    YAML 文件。此外，除非创建者有文档说明，否则你并不知道哪些 YAML 模板中的值是打算由创建者配置的。
- en: The deployment process can vary for each application. There is no standardized
    approach regarding which YAML manifests the creator provides and which components
    you are required to deploy manually.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署过程因应用程序而异。没有标准化的方法来定义创建者提供哪些 YAML 清单，以及你需要手动部署哪些组件。
- en: There is no *dependency management*. For example, if your application requires
    a **MySQL** server running as a StatefulSet in the cluster, you either need to
    deploy it yourself or rely on the creator of the application to provide YAML manifests
    for the MySQL server.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有*依赖管理*。例如，如果你的应用程序需要在集群中以 StatefulSet 形式运行的 **MySQL** 服务器，你要么需要自己部署它，要么依赖应用程序的创建者提供
    MySQL 服务器的 YAML 清单。
- en: This is a bit similar to what you see with the other applications if you do
    not use **Application Store** or a package manager such as **Chocolatey**, **APT**,
    **YUM**, **DNF**, and so on. Some applications that you download will come with
    an installer as a `setup.sh` script file, some with a `.exe` file, some as a `.msi`,
    and others will just be`.zip` files that you need to extract and configure yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用 **Application Store** 或类似 **Chocolatey**、**APT**、**YUM**、**DNF** 等包管理器，其他应用程序也有类似的情况。有些下载的应用程序会提供作为
    `setup.sh` 脚本文件的安装程序，有些提供 `.exe` 文件，有些是 `.msi` 文件，还有的只是 `.zip` 文件，需要你自行解压并配置。
- en: 'In Kubernetes, you can use **Helm** ([https://helm.sh](https://helm.sh)), which
    is one of the most popular package managers for Kubernetes applications and services.
    If you are familiar with popular package managers such as APT, yum, npm, or Chocolatey,
    you will find many concepts in Helm similar and easy to understand. The following
    are the three most important concepts in Helm:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，你可以使用**Helm**（[https://helm.sh](https://helm.sh)），它是最流行的 Kubernetes
    应用程序和服务包管理器之一。如果你熟悉流行的包管理器，如 APT、yum、npm 或 Chocolatey，你会发现 Helm 中的许多概念非常相似且易于理解。以下是
    Helm 中三个最重要的概念：
- en: A **chart** is a Helm *package*. This is what you *install* when you use the
    Helm **CLI**. A Helm chart contains all Kubernetes YAML manifests required to
    deploy the particular application on the cluster. Please note that these YAML
    manifests may be *parameterized*, so that you can easily inject configuration
    values provided by the user who installs the chart.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表**是 Helm *包*。当你使用 Helm **CLI** 时，安装的就是这个图表。一个 Helm 图表包含了所有需要部署特定应用程序到集群上的
    Kubernetes YAML 清单。请注意，这些 YAML 清单可能是*参数化*的，因此你可以轻松地注入由安装图表的用户提供的配置值。'
- en: A **repository** is a storage location for Helm charts, used to collect and
    share charts. They can be public or private – there are multiple public repositories
    that are available, which you can browse on Artifact Hub ([https://artifacthub.io](https://artifacthub.io)).
    Private repositories are usually used for distributing components running on Kubernetes
    between teams working on the same product.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**是 Helm 图表的存储位置，用于收集和共享图表。它们可以是公开的或私有的 – 有多个公共仓库可以浏览，你可以在 Artifact Hub
    上找到它们（[https://artifacthub.io](https://artifacthub.io)）。私有仓库通常用于在同一个产品的不同团队之间分发
    Kubernetes 上运行的组件。'
- en: A **release** is an *instance* of a Helm chart that was installed and is running
    in a Kubernetes cluster. This is what you manage with the Helm CLI, for example,
    by upgrading or uninstalling it. You can install one chart many times on the same
    cluster and have multiple releases of it that are identified uniquely by release
    names.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布** 是已安装并在 Kubernetes 集群中运行的 Helm chart 的*实例*。这是您通过 Helm CLI 管理的内容，例如通过升级或卸载它。您可以在同一集群上多次安装同一个
    chart，并拥有多个通过发布名称唯一标识的发布。'
- en: In short, Helm charts contain parameterizable YAML manifests that you store
    in a Helm repository for distribution. When you install a Helm chart, a Helm release
    is created in your cluster that you can further manage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Helm charts 包含可以参数化的 YAML 清单，您将其存储在 Helm 仓库中以供分发。当您安装 Helm chart 时，在您的集群中会创建一个
    Helm 发布，您可以进一步管理它。
- en: 'Let’s quickly summarize some of the common use cases for Helm:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一些 Helm 的常见使用场景：
- en: Deploying popular software to your Kubernetes cluster. This makes *development*
    on Kubernetes much easier – you can deploy third-party components to the cluster
    in a matter of seconds. The same approach may be used in *production* clusters.
    You do not need to rely on writing your own YAML manifest for such third-party
    components.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将流行的软件部署到您的 Kubernetes 集群。这使得在 Kubernetes 上进行*开发*变得更加容易——您可以在几秒钟内将第三方组件部署到集群中。相同的方法也可以用于*生产*集群。您无需依赖为这些第三方组件编写自己的
    YAML 清单。
- en: Helm charts provide *dependency management* capabilities. If chart A requires
    chart B to be installed first with specific parameters, Helm supports syntax for
    this out of the box.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm charts 提供*依赖管理*功能。如果 chart A 需要先安装 chart B，并带有特定参数，Helm 支持这种语法。
- en: Sharing your own applications as Helm charts. This can include packaging a product
    for consumption by the end users or using Helm as an internal package and dependency
    manager for microservices in your product.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享您自己的应用程序作为 Helm charts。这可以包括将产品打包供最终用户使用，或将 Helm 作为您产品中微服务的内部包和依赖管理器。
- en: Ensuring that the applications receive proper upgrades. Helm has its own process
    for upgrading Helm releases.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用程序获得适当的升级。Helm 有自己的一套升级 Helm 发布的流程。
- en: Configuring software deployments for your needs. Helm charts are basically generic
    YAML templates for Kubernetes object manifests that can be *parameterized*. Helm
    uses **Go** templates ([https://godoc.org/text/template](https://godoc.org/text/template))
    for parameterization.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的需求配置软件部署。Helm charts 基本上是 Kubernetes 对象清单的通用 YAML 模板，可以进行*参数化*。Helm 使用 **Go**
    模板（[https://godoc.org/text/template](https://godoc.org/text/template)）进行参数化。
- en: Currently, Helm is distributed as a binary client (library) that has a CLI similar
    to `kubectl`. All operations that you perform using Helm do not require any additional
    components to be installed on the Kubernetes cluster.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Helm 以二进制客户端（库）的形式分发，具有类似于 `kubectl` 的 CLI。您使用 Helm 执行的所有操作都不需要在 Kubernetes
    集群上安装任何额外组件。
- en: 'Please note that the Helm architecture was changed with the release of version
    3.0.0 of Helm. Previously, the architecture of Helm was different, and it required
    a special, dedicated service running on Kubernetes named Tiller. This was causing
    various problems, such as with security around **Role-Based Access Control** (**RBAC**)
    and elevated-privilege Pods running inside the cluster. You can read more about
    the differences between the latest major version of Helm and previous ones in
    the official FAQ:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Helm 的架构在 Helm 3.0.0 版本发布时发生了变化。以前，Helm 的架构是不同的，需要在 Kubernetes 上运行一个名为 Tiller
    的特殊专用服务。这造成了各种问题，例如与 **基于角色的访问控制** (**RBAC**) 和在集群内运行的具有提升权限的 Pods 相关的安全问题。您可以在官方
    FAQ 中阅读更多关于最新主要版本 Helm 与之前版本之间的区别：
- en: https://helm.sh/docs/faq/#changes-since-helm-2
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: https://helm.sh/docs/faq/#changes-since-helm-2
- en: This is useful to know if you find any online guides that still mention Tiller
    – they are most likely intended for older versions of Helm.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于您找到的任何仍然提到 Tiller 的在线指南非常有用——它们很可能是为 Helm 的旧版本编写的。
- en: Now that we have learned about Helm and its important concepts, we are going
    to install Helm and deploy a simple Helm chart from Artifact Hub to verify that
    it works correctly on your cluster.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Helm 及其重要概念，我们将安装 Helm 并从 Artifact Hub 部署一个简单的 Helm chart，以验证它在您的集群中是否正常工作。
- en: Releasing software to Kubernetes using Helm
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 向 Kubernetes 发布软件
- en: In this section, you will learn how to install Helm and how to test the installation
    by deploying an example Helm chart. Helm is provided as binary releases ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    available for multiple platforms. You can use them or refer to the following guides
    for installation using a package manager on your desired operating system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何安装 Helm，并通过部署示例 Helm 图表来测试安装。Helm 以二进制发布的形式提供（[https://github.com/helm/helm/releases](https://github.com/helm/helm/releases)），支持多个平台。你可以使用这些版本，或者参考以下指南通过包管理器在你所选的操作系统上安装。
- en: Installing Helm on Linux
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Helm
- en: 'To install Helm on Fedora, you need to ensure that the default Fedora repository
    is configured and working:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 上安装 Helm，你需要确保默认的 Fedora 仓库已配置并正常工作：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then install Helm as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按如下方式安装 Helm：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once installed, you can verify the version of the installed Helm package:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以验证已安装 Helm 包的版本：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is also possible to install Helm using the script (https://helm.sh/docs/intro/install/#from-script),
    which will automatically detect the platform, download the latest Helm, and install
    it on your machine.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用脚本安装 Helm（https://helm.sh/docs/intro/install/#from-script），该脚本会自动检测平台、下载最新的
    Helm，并将其安装到你的机器上。
- en: Once installed, you can move on to *Deploying an example chart – WordPress*
    in this section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以继续进行本节中的 *部署示例图表 – WordPress*。
- en: Installing Helm on Windows
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Helm
- en: To install Helm on Windows, the easiest way is to use the Chocolatey package
    manager. If you have not used Chocolatey before, you can find more details and
    the installation guide in the official documentation at [https://chocolatey.org/install](https://chocolatey.org/install).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Helm，最简单的方法是使用 Chocolatey 包管理器。如果你之前没有使用过 Chocolatey，可以在官方文档中找到更多详细信息和安装指南，网址是
    [https://chocolatey.org/install](https://chocolatey.org/install)。
- en: 'Execute the following command in PowerShell or Command shell to install Helm:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 或命令行中执行以下命令来安装 Helm：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once installed, you can move on to *Deploying an example chart – WordPress*,
    which is later in this section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以继续进行本节稍后的 *部署示例图表 – WordPress*。
- en: Installing Helm on macOS
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Helm
- en: 'To install Helm on macOS, you can use the standard **Homebrew** package manager.
    Use the following command to install the Helm formula:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Helm，你可以使用标准的 **Homebrew** 包管理器。使用以下命令来安装 Helm 配方：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Verify that the installation was successful by trying to get the Helm version
    from the command line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尝试从命令行获取 Helm 版本来验证安装是否成功：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once installed, we can deploy an example chart to verify that Helm works properly
    on your Kubernetes cluster.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以部署一个示例图表来验证 Helm 是否在你的 Kubernetes 集群上正常工作。
- en: Installing from the binary releases
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从二进制发布版安装
- en: 'It is also possible to install the latest Helm package from the binary itself.
    You need to find the latest or desired version of the binary from the release
    page ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    and download it for your operating system. In the following example, we will see
    how to install the latest Helm from the binary on the Fedora workstation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接从二进制文件安装最新的 Helm 包。你需要从发布页面（[https://github.com/helm/helm/releases](https://github.com/helm/helm/releases)）找到最新或所需版本的二进制文件，并根据你的操作系统下载它。在以下示例中，我们将展示如何在
    Fedora 工作站上从二进制文件安装最新版本的 Helm：
- en: 'Download and install Helm:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装 Helm：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we will test the Helm package by *Deploying an example chart - WordPress*
    in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在下一节中通过 *部署示例图表 – WordPress* 来测试 Helm 包。
- en: Deploying an example chart – WordPress
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署示例图表 – WordPress
- en: 'By default, Helm comes with no repositories configured. One possibility, which
    is no longer recommended, is to add the `stable` repository so that you can browse
    the most popular Helm charts:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Helm 没有配置任何仓库。一个不再推荐的做法是添加 `stable` 仓库，以便浏览最受欢迎的 Helm 图表：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding random Helm chart repositories for deployment can pose serious security
    risks. Security audits are a must to ensure that only trusted and secure payloads
    are deployed within your Kubernetes environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为部署添加随机的 Helm 图表仓库可能会带来严重的安全风险。必须进行安全审计，确保在 Kubernetes 环境中仅部署受信任且安全的负载。
- en: 'Please note that most charts are now in the process of deprecation as they
    are moved to different Helm repositories where they will be maintained by the
    original creators. You can see this if you try to search for available Helm charts
    using the `helm search repo` command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数图表现在正处于弃用过程中，因为它们被迁移到不同的Helm仓库，并由原始创建者维护。如果你尝试使用`helm search repo`命令搜索可用的Helm图表，你会看到这一点：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead, the new recommended way is to use the `helm search hub` command, which
    allows you to browse the Artifact Hub directly from the CLI:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，新的推荐方法是使用`helm search hub`命令，它允许你直接从CLI浏览Artifact Hub：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s try searching for some of the most popular Helm charts that we can
    use to test our installation. We would like to deploy **WordPress** on our Kubernetes
    cluster. We chose WordPress to demonstrate here because it is a typical three-tier
    application with a public access tier (The Service), a web tier (WordPress), and
    a database tier (MariaDB). First, let’s check what the available charts are for
    WordPress on Artifact Hub:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试搜索一些最受欢迎的Helm图表，以测试我们的安装。我们希望在我们的Kubernetes集群上部署**WordPress**。我们选择WordPress作为示范，因为它是一个典型的三层应用程序，包含公共访问层（服务）、网页层（WordPress）和数据库层（MariaDB）。首先，让我们查看Artifact
    Hub上关于WordPress的可用图表：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, you can directly use the Artifact Hub web UI and search for WordPress
    Helm charts as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以直接使用Artifact Hub的网页UI搜索WordPress Helm图表，如下所示：
- en: '![](img/B22019_14_01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_01.png)'
- en: 'Figure 14.1: Artifact Hub search results for WordPress Helm charts'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：Artifact Hub上WordPress Helm图表的搜索结果
- en: 'We will be using the Helm chart provided and maintained by **Bitnami**, a company
    specializing in distributing open-source software on various platforms, such as
    Kubernetes. If you navigate to the search result for WordPress charts by Bitnami,
    you will see the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Bitnami**提供并维护的Helm图表，Bitnami是一家专门在各种平台（如Kubernetes）上分发开源软件的公司。如果你导航到Bitnami提供的WordPress图表的搜索结果，你将看到以下内容：
- en: '![](img/B22019_14_02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_02.png)'
- en: 'Figure 14.2: Bitnami WordPress Helm chart on Artifact Hub with install instructions'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：Artifact Hub上Bitnami WordPress Helm图表的安装说明
- en: The page gives you detailed information about how you can add the `bitnami`
    repository and install the Helm chart for WordPress. Additionally, you will find
    a lot of details about available configurations, known limitations, and troubleshooting.
    You can also navigate to the home page of each of the charts in order to see the
    YAML templates that make up the chart ([https://github.com/bitnami/charts/tree/master/bitnami/wordpress](https://github.com/bitnami/charts/tree/master/bitnami/wordpress)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面提供了详细的信息，介绍了如何添加`bitnami`仓库并安装WordPress的Helm图表。此外，你还会找到有关可用配置、已知限制和故障排除的详细信息。你还可以导航到每个图表的主页，以查看组成该图表的YAML模板（[https://github.com/bitnami/charts/tree/master/bitnami/wordpress](https://github.com/bitnami/charts/tree/master/bitnami/wordpress)）。
- en: 'We can now do the installation by following the instructions on the web page.
    First, add the `bitnami` repository to your Helm installation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过遵循网页上的说明进行安装。首先，将`bitnami`仓库添加到你的Helm安装中：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a best practice, let us install WordPress inside a dedicated namespace called
    `wordpress`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我们将在名为`wordpress`的专用命名空间内安装WordPress：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the repository present, we can install the `bitnami/wordpress` Helm chart,
    but before that, we need to prepare some details for the deployment. Check the
    chart page in Artifact Hub ([https://artifacthub.io/packages/helm/bitnami/wordpress](https://artifacthub.io/packages/helm/bitnami/wordpress)).
    You will find a lot of parameters given here for you to configure and customize
    your WordPress deployment. If you do not provide any parameters, default values
    will be used for the Helm release deployment. For this demonstration, let us configure
    some of the parameters instead of using the default values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加仓库后，我们可以安装`bitnami/wordpress` Helm图表，但在此之前，我们需要为部署准备一些细节。请查看Artifact Hub上的图表页面（[https://artifacthub.io/packages/helm/bitnami/wordpress](https://artifacthub.io/packages/helm/bitnami/wordpress)）。你将看到很多参数供你配置和定制你的WordPress部署。如果你不提供任何参数，将使用默认值进行Helm发布部署。为了演示，让我们配置一些参数，而不是使用默认值。
- en: 'You can pass the individual parameters using the `--set` argument as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`--set`参数传递单独的参数，如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you have multiple parameters to configure, you can pass multiple `--set`
    arguments but it is recommended to use variables in files; you can use one or
    more files to pass the variables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个参数需要配置时，您可以传递多个`--set`参数，但建议使用文件中的变量；您可以使用一个或多个文件传递变量。
- en: 'Let us create a `wp-values.yaml` file to store the variables and values as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`wp-values.yaml`文件来存储变量和值如下：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we are passing some of the WordPress configurations to the Helm
    chart. Please note that we are changing the default WordPress type to `NodePort`
    as we are using a minikube cluster here. If you are using a different Kubernetes
    cluster – for example, cloud-based Kubernetes – then you may leave it as the default,
    which is `LoadBalancer`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们将一些WordPress配置传递给Helm图表。请注意，由于我们在使用minikube集群，我们正在将默认的WordPress类型更改为`NodePort`。如果您使用不同的Kubernetes集群（例如基于云的Kubernetes），那么您可以将其保留为默认值，即`LoadBalancer`。
- en: 'Now that we have the Helm repo configured, a dedicated namespace created, and
    parameters configured in a variable file, let us deploy WordPress using Helm;
    we will use the name `wp-demo` for this release:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Helm仓库，创建了一个专用命名空间，并在变量文件中配置了参数，让我们使用Helm部署WordPress；我们将为此发布使用名称`wp-demo`：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Helm will show the basic release information, as shown here. After a while,
    you will also see the deployment details, including the service name, how to access
    the WordPress website, and more:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Helm将显示基本的发布信息，如此处所示。过一会儿，您还将看到部署详细信息，包括服务名称，如何访问WordPress网站等：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the beauty of Helm – you have executed a single `helm install` command
    and you are presented with a detailed guide on how to use the deployed component
    on *your* cluster. Meanwhile, the WordPress instance deploys without any intervention
    from you!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Helm的美妙之处——您只需执行单个`helm install`命令，即可获得如何在*您的*集群上使用部署组件的详细指南。与此同时，WordPress实例部署无需任何干预！
- en: 'It is a good practice to first inspect what Kubernetes objects’ YAML manifests
    were produced by Helm. You can do that by running the `helm install` command with
    additional flags: `helm install wp-demo bitnami/wordpress --dry-run --debug`.
    The output will contain the joint output of YAML manifests, and they will not
    be applied to the cluster.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查由Helm生成的Kubernetes对象的YAML清单是一种良好的做法。您可以通过带有额外标志的`helm install`命令来执行此操作：`helm
    install wp-demo bitnami/wordpress --dry-run --debug`。输出将包含YAML清单的联合输出，它们将不会应用于集群。
- en: 'You can also mention the specific version of the Helm chart using the `--version`
    argument as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`--version`参数来指定Helm图表的特定版本，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s now follow the instructions from the Helm chart installation output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照Helm图表安装输出的说明进行操作：
- en: 'Wait for a while as the database needs to initialize and deploy the Pods. Check
    the Pod status:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待一会儿，因为数据库需要初始化并部署Pods。检查Pod状态：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice the database is deployed as a StatefulSet as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意数据库部署为StatefulSet如下：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Wait for the `wp-demo` Service object (of the NodePort type) to acquire port
    details:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待`wp-demo` Service对象（NodePort类型）获取端口详细信息：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In our case, the port will be `80:31979/TCP`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，端口将是`80:31979/TCP`。
- en: 'Since we are using minikube in this case, let us find the IP address and port
    details (if you are using the `LoadBalancer` type, then you can directly access
    the IP address to see the WordPress site):'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们正在使用minikube，请找到IP地址和端口详细信息（如果您使用`LoadBalancer`类型，则可以直接访问IP地址查看WordPress站点）：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now open your web browser and navigate to the WordPress URL, `http://192.168.59.150:30509`
    (the other port is for the HTTPS URL):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开您的Web浏览器并导航到WordPress URL，`http://192.168.59.150:30509`（另一个端口用于HTTPS URL）：
- en: '![](img/B22019_14_03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_03.png)'
- en: 'Figure 14.3: WordPress chart deployed on Kubernetes – main page'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：部署在Kubernetes上的WordPress图表——主页
- en: 'Now you can log in to the WordPress dashboard at `http://192.168.59.150:30509/wp-admin`.
    Please note that if you missed setting the WordPress parameters, including the
    password, you need to find the default values Helm has used. For example, to retrieve
    the WordPress login password, check the secret as follows. Use the following commands
    to obtain the credentials that are stored in a dedicated `wp-demo-wordpress` Secret
    object deployed as part of the chart:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以登录WordPress仪表板，网址为`http://192.168.59.150:30509/wp-admin`。请注意，如果您错过了设置WordPress参数（包括密码），您需要查找Helm使用的默认值。例如，要检索WordPress登录密码，请按以下方式检查秘密。使用以下命令获取存储在专用`wp-demo-wordpress`
    Secret对象中的凭据：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the credentials to log in as the WordPress admin:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用凭据登录为 WordPress 管理员：
- en: '![](img/B22019_14_04.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_04.png)'
- en: 'Figure 14.4: WordPress chart deployed on Kubernetes – admin dashboard'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：部署在 Kubernetes 上的 WordPress chart —— 管理员仪表盘
- en: You can enjoy your WordPress now, congratulations! If you are interested, you
    can inspect the Pods, Services, Deployments, and StatefulSets that were deployed
    as part of this Helm chart. This will give you a lot of insight into what the
    components of the chart are and how they interact.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以尽情享受你的 WordPress 了，恭喜！如果你感兴趣，可以检查作为该 Helm chart 一部分部署的 Pods、Services、Deployments
    和 StatefulSets。这将帮助你深入了解 chart 的组件以及它们是如何交互的。
- en: The Helm CLI offers *autocompletion* for various shells. You can run the `helm
    completion` command to learn more.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Helm CLI 提供了对各种 shell 的*自动补全*功能。你可以运行 `helm completion` 命令以了解更多信息。
- en: 'If you want to get information about all Helm releases that are deployed in
    your Kubernetes cluster, use the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取关于所有已部署的 Helm 发布的信息，可以使用以下命令：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next section, we will learn how to delete a deployed release using Helm.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何使用 Helm 删除一个已部署的发布。
- en: Deleting a Helm release
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除 Helm 发布
- en: 'As we learned in the previous sections, the Helm chart has deployed several
    resources, including Deployment, PVC, Services, Secrets, and so on. It is not
    practical to find and delete these items one by one. But Helm provides an easy
    method to remove the deployment using the `helm uninstall` command. When you are
    ready, you can clean up the release by uninstalling the Helm release using the
    following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所学到的，Helm chart 已经部署了多个资源，包括 Deployment、PVC、Services、Secrets 等。逐一查找并删除这些项目并不实际。但
    Helm 提供了一种简单的方法来使用 `helm uninstall` 命令删除部署。当你准备好时，可以通过以下命令卸载 Helm 发布，从而清理发布：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will delete all Kubernetes objects that the release has created. Please
    note though that PersistentVolumes and PersistentVolumeClaims, created by the
    Helm chart, will not be cleaned up – you need to clean them up manually. We will
    now take a closer look at how Helm charts are structured internally.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除该发布创建的所有 Kubernetes 对象。但请注意，Helm chart 创建的 PersistentVolumes 和 PersistentVolumeClaims
    将不会被清理——你需要手动清理它们。接下来，我们将更详细地了解 Helm charts 的内部结构。
- en: Helm chart anatomy
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm chart 结构
- en: 'As an example, we will take the WordPress Helm chart by Bitnami ([https://github.com/bitnami/charts/tree/master/bitnami/wordpress](https://github.com/bitnami/charts/tree/master/bitnami/wordpress))
    that we have just used to perform a test Deployment in the cluster. Helm charts
    are simply directories with a specific structure (convention) that can live either
    in your local filesystem or in a Git repository. The directory name is at the
    same time the name of the chart – in this case, `wordpress`. The structure of
    files in the chart directory is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，我们将使用 Bitnami 提供的 WordPress Helm chart（[https://github.com/bitnami/charts/tree/master/bitnami/wordpress](https://github.com/bitnami/charts/tree/master/bitnami/wordpress)），我们刚刚用它在集群中执行了测试部署。Helm
    charts 只是具有特定结构（约定）的目录，这些目录可以存在于本地文件系统或 Git 仓库中。目录名称同时也是 chart 的名称——在本例中为 `wordpress`。chart
    目录中文件的结构如下：
- en: '`Chart.yaml`: YAML file that contains metadata about the chart such as version,
    keywords, and references to dependent charts that must be installed.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chart.yaml`：包含关于 chart 的元数据的 YAML 文件，如版本、关键词以及必须安装的依赖 charts 的引用。'
- en: '`LICENSE`: Optional, plain-text file with license information.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LICENSE`：可选的纯文本文件，包含许可证信息。'
- en: '`README.md`: End user README file that will be visible on Artifact Hub.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：最终用户的 README 文件，将在 Artifact Hub 上可见。'
- en: '`values.yaml`: The default configuration values for the chart that will be
    used as YAML template parameters. These values can be overridden by the Helm user,
    either one by one in the CLI or as a separate YAML file with values. You have
    already used this method by passing the **-**`-values wp-values.yaml` argument.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values.yaml`：chart 的默认配置值，这些值将作为 YAML 模板参数使用。用户可以通过 Helm 覆盖这些值，方法是在 CLI 中逐个传递，或使用单独的
    YAML 文件传递值。你已经通过传递 **-**`-values wp-values.yaml` 参数使用了这种方法。'
- en: '`values.schema.json`: Optionally, you can provide a JSON schema that `values.yaml`
    must follow.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values.schema.json`：可选地，你可以提供一个 `values.yaml` 必须遵循的 JSON 模式。'
- en: '`charts/`: Optional directory with additional, dependent charts.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charts/`：可选目录，包含附加的依赖 charts。'
- en: '`crds/`: Optional Kubernetes custom resource definitions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crds/`：可选的 Kubernetes 自定义资源定义。'
- en: '`templates/`: The most important directory that contains all YAML *templates*
    for generating Kubernetes YAML manifest files. The YAML templates will be combined
    with the provided *values*. The resulting YAML manifest files will be applied
    to the cluster.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates/`：包含所有YAML*模板*的最重要目录，用于生成Kubernetes YAML清单文件。这些YAML模板将与提供的*值*结合，最终生成的YAML清单文件将被应用到集群中。'
- en: '`templates/NOTES.txt`: Optional file with short usage notes.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates/NOTES.txt`：包含简短使用说明的可选文件。'
- en: 'For example, if you inspect `Chart.yaml` in the WordPress Helm chart, you can
    see that it depends on the **MariaDB** chart by Bitnami, if an appropriate value
    of `mariadb.enabled` is set to `true` in the provided values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你检查WordPress Helm图表中的`Chart.yaml`，你会发现它依赖于Bitnami的**MariaDB**图表，前提是提供的值中`mariadb.enabled`被设置为`true`：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, if you take a look at the `values.yaml` file with the default values,
    which is quite verbose, you can see that by default MariaDB is enabled:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看`values.yaml`文件（它包含默认值并且内容较为冗长），你可以看到默认情况下启用了MariaDB：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And lastly, let’s check what one of the YAML templates looks like – open the
    `deployment.yaml` file ([https://github.com/bitnami/charts/blob/master/bitnami/wordpress/templates/deployment.yaml](https://github.com/bitnami/charts/blob/master/bitnami/wordpress/templates/deployment.yaml)),
    which is a template for the Kubernetes Deployment object for Pods with WordPress
    containers. For example, you can see how the number of `replicas` is referenced
    from the provided values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下其中一个YAML模板的样子——打开`deployment.yaml`文件（[https://github.com/bitnami/charts/blob/master/bitnami/wordpress/templates/deployment.yaml](https://github.com/bitnami/charts/blob/master/bitnami/wordpress/templates/deployment.yaml)），这是一个Kubernetes部署对象的模板，用于包含WordPress容器的Pod。例如，你可以看到`replicas`的数量是如何从提供的值中引用的：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will be replaced by the `replicaCount` value (for which the default value
    of `1` is found in the `values.yaml` file). The details about how to use Go templates
    can be found at [https://pkg.go.dev/text/template](https://pkg.go.dev/text/template).
    You can also learn by example by analyzing the existing Helm charts – most of
    them use similar patterns for processing provided values.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被`replicaCount`的值替换（`values.yaml`文件中的默认值为`1`）。关于如何使用Go模板的详细信息可以在[https://pkg.go.dev/text/template](https://pkg.go.dev/text/template)找到。你还可以通过分析现有的Helm图表来通过示例学习——大多数图表使用类似的模式来处理提供的值。
- en: The detailed documentation on Helm chart structure can be found at https://helm.sh/docs/topics/charts/.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Helm图表结构的详细文档可以在https://helm.sh/docs/topics/charts/找到。
- en: In most cases, you will need to override some of the default values from the
    `values.yaml` file during the installation of a chart, as we learned earlier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你在安装图表时需要覆盖`values.yaml`文件中的某些默认值，正如我们之前所学到的。
- en: Now, that you know the most important details about the Helm chart structure,
    in the next section, we can deploy Kubernetes Dashboard using Helm charts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了关于Helm图表结构的最重要细节，在接下来的章节中，我们将使用Helm图表部署Kubernetes仪表盘。
- en: Installing Kubernetes Dashboard using Helm Charts
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helm Charts安装Kubernetes仪表盘
- en: Kubernetes Dashboard is the official web UI for providing an overview of your
    cluster. The Helm chart for this component is officially maintained by the Kubernetes
    community ([https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard](https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard)).
    We are going to install it with the default parameters, as there is no need for
    any customizations at this point.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes仪表盘是官方的Web UI，用于提供集群概览。这个组件的Helm图表由Kubernetes社区官方维护（[https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard](https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard)）。我们将以默认参数安装它，因为此时没有必要进行任何自定义。
- en: 'For minikube clusters, you can enable the dashboard and access it using a single
    command: `minikube dashboard`. But our intention here is to learn how to deploy
    a dashboard for any type of Kubernetes cluster.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于minikube集群，你可以通过一个命令启用仪表盘并访问它：`minikube dashboard`。但我们此时的目的是学习如何为任何类型的Kubernetes集群部署仪表盘。
- en: 'First, add the `kubernetes-dashboard` repository to Helm:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`kubernetes-dashboard`仓库添加到Helm：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can install the Helm chart as a `kubernetes-dashboard` release in the
    cluster as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将Helm图表作为`kubernetes-dashboard`发布安装到集群中，方法如下：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Wait for the installation to finish and check the output messages. Notice the
    following message as we will use it later to access the dashboard WEBUI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 等待安装完成并查看输出信息。注意以下信息，因为我们稍后将用它来访问仪表盘WEBUI：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Also, ensure Pods have a `Running` status:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，确保 Pods 的状态为 `Running`：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You may ignore other Pods deployed by the Helm chart for now. We will learn
    how to access the dashboard UI in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前您可以忽略 Helm 图表部署的其他 Pods。我们将在下一部分学习如何访问 Dashboard UI。
- en: Secure access to the Kubernetes Dashboard
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保 Kubernetes Dashboard 的访问安全
- en: By default, the Kubernetes Dashboard prioritizes security by using a minimal
    RBAC configuration. This helps safeguard your cluster data. Currently, logging
    in to the dashboard requires a Bearer Token.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes Dashboard 优先考虑安全性，使用最小化的 RBAC 配置。这有助于保护您的集群数据。目前，登录 Dashboard
    需要使用 Bearer Token。
- en: This sample user creation guide will likely grant administrative privileges.
    Be sure to use it only for educational purposes and implement proper RBAC controls
    for production environments.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例用户创建指南可能会授予管理员权限。请务必仅将其用于教育目的，并为生产环境实施适当的 RBAC 控制。
- en: 'Follow these steps to create a token to access the Kubernetes Dashboard WEBUI:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个令牌以访问 Kubernetes Dashboard WEBUI：
- en: 'Create a ServiceAccount; prepare the YAML as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 ServiceAccount；准备以下 YAML 文件：
- en: '[PRE32]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the ServiceAccount as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式创建 ServiceAccount：
- en: '[PRE33]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create `ClusterRoleBinding` to allow the access. Prepare the YAML as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ClusterRoleBinding` 以允许访问。准备以下 YAML 文件：
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create `ClusterRoleBinding` by applying the YAML definition:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过应用 YAML 定义创建 `ClusterRoleBinding`：
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the token:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建令牌：
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Copy the long token string generated, and we will use it in the next section
    to log in to the cluster dashboard.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 复制生成的长令牌字符串，我们将在下一部分使用它登录集群 Dashboard。
- en: Accessing Dashboard WEBUI
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 Dashboard WEBUI
- en: The Kubernetes Dashboard offers various access methods. Here, we’ll focus on
    the default approach. This method assumes you haven’t altered the standard configuration
    during installation. If you’ve made modifications, the steps might differ.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Dashboard 提供了多种访问方式。在这里，我们将重点介绍默认方法。此方法假设在安装过程中您没有更改标准配置。如果您进行过修改，步骤可能会有所不同。
- en: 'Execute the following command (which you copied from the `helm install` output
    earlier) to get Dashboard access. The command will stay there with the status
    of `port-forward`; do not exit from the command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令（该命令是您从 `helm install` 输出中复制的），以获取 Dashboard 访问权限。该命令会保持在 `port-forward`
    状态；请不要退出该命令：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, access the URL `https://localhost:8443/` in a web browser. You can ignore
    the SSL certificate warning as the dashboard is using the self-signed SSL certificates.
    Enter the token you generated in *Step* *3*, of *Secure Access to the Kubernetes
    Dashboard*, and log in to Dashboard as shown in the following figure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中访问 `https://localhost:8443/`。您可以忽略 SSL 证书警告，因为 Dashboard 正在使用自签名的 SSL
    证书。输入在 *步骤* *3* 中生成的令牌，*确保访问 Kubernetes Dashboard 的安全性*，并按图示登录 Dashboard。
- en: '![](img/B22019_14_05.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_05.png)'
- en: 'Figure 14.5: Kubernetes Dashboard chart – login page'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：Kubernetes Dashboard 图表 – 登录页面
- en: 'At this point, you have access to the dashboard, and you can browse its functionalities:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已能够访问 Dashboard，并且可以浏览其功能：
- en: '![](img/B22019_14_06.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_06.png)'
- en: 'Figure 14.6: Kubernetes Dashboard chart – Deployments page'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：Kubernetes Dashboard 图表 – 部署页面
- en: The bearer token is for a user with the `cluster-admin` role, so be careful,
    as you can perform any operations, including deleting resources.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 承载令牌是为具有 `cluster-admin` 角色的用户准备的，因此请小心使用，因为您可以执行任何操作，包括删除资源。
- en: Congratulations; you have successfully deployed the Kubernetes Dashboard using
    Helm charts, and verified the access using the token. You can explore more deployments
    using Helm charts as we explain in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经成功通过 Helm 图表部署了 Kubernetes Dashboard，并使用令牌验证了访问权限。您可以根据我们在下一部分的讲解，探索更多通过
    Helm 图表的部署。
- en: Installing other popular solutions using Helm charts
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Helm 图表安装其他流行的解决方案
- en: To practice more with Helm charts, you can quickly install some of the other
    software for your Kubernetes cluster. It can be useful in your development scenarios
    or as building blocks of your cloud-native applications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 若要更多地练习 Helm 图表，您可以快速安装 Kubernetes 集群的其他软件。这在您的开发场景中可能非常有用，或者作为云原生应用程序的构建模块。
- en: Elasticsearch with Kibana
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Elasticsearch 与 Kibana
- en: 'Elasticsearch is a popular full-text search engine that is commonly used for
    log indexing and log analytics. Kibana, which is part of the Elasticsearch ecosystem,
    is a visualization UI for the Elasticsearch database. To install this stack, we
    will need to use two charts, both of which are maintained by Elasticsearch creators:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 是一个流行的全文搜索引擎，常用于日志索引和日志分析。Kibana 是 Elasticsearch 生态系统的一部分，是一个用于
    Elasticsearch 数据库的可视化 UI。为了安装这个堆栈，我们需要使用两个图表，这两个图表都由 Elasticsearch 的创建者维护：
- en: '**Elasticsearch chart** ([https://artifacthub.io/packages/helm/elastic/elasticsearch](https://artifacthub.io/packages/helm/elastic/elasticsearch))'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Elasticsearch 图表** ([https://artifacthub.io/packages/helm/elastic/elasticsearch](https://artifacthub.io/packages/helm/elastic/elasticsearch))'
- en: '**Kibana chart** ([https://artifacthub.io/packages/helm/elastic/kibana](https://artifacthub.io/packages/helm/elastic/kibana))'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kibana 图表** ([https://artifacthub.io/packages/helm/elastic/kibana](https://artifacthub.io/packages/helm/elastic/kibana))'
- en: Prometheus with Grafana
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Prometheus 与 Grafana
- en: 'Prometheus is a popular monitoring system with a time series database and Grafana
    is used as a visualization UI. Similar to the Elastic Stack, to install this Prometheus
    and Grafana stack, we will need to use two charts:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 是一个流行的监控系统，具有时间序列数据库，Grafana 用作可视化 UI。类似于 Elastic Stack，为了安装 Prometheus
    和 Grafana 堆栈，我们需要使用两个图表：
- en: '**Prometheus** ([https://artifacthub.io/packages/helm/prometheus-community/prometheus](https://artifacthub.io/packages/helm/prometheus-community/prometheus))'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prometheus** ([https://artifacthub.io/packages/helm/prometheus-community/prometheus](https://artifacthub.io/packages/helm/prometheus-community/prometheus))'
- en: '**Grafana** ([https://artifacthub.io/packages/helm/grafana/grafana](https://artifacthub.io/packages/helm/grafana/grafana))'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grafana** ([https://artifacthub.io/packages/helm/grafana/grafana](https://artifacthub.io/packages/helm/grafana/grafana))'
- en: Since we have already explained how to deploy Helm charts in the Kubernetes
    cluster, we will skip the step-by-step instructions for these. You may continue
    deploying the charts and exploring the functionalities.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经解释了如何在 Kubernetes 集群中部署 Helm 图表，因此我们将跳过这些步骤的详细说明。你可以继续部署这些图表并探索其功能。
- en: In this section, we will explore some of the key security considerations for
    Helm Charts.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些 Helm 图表的关键安全考虑因素。
- en: Security considerations for Helm Charts
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 图表的安全考虑
- en: 'Helm charts ease the deployment of applications into Kubernetes, but they can
    introduce several security vulnerabilities that need to be managed. Some of the
    most important things to bear in mind include the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表简化了应用程序在 Kubernetes 中的部署，但它们也可能引入一些需要管理的安全漏洞。需要牢记的一些重要事项包括以下几点：
- en: '**Source Verification:** Always check the source for Helm charts before deploying
    and never install charts originating from non-trusted or less reputed repositories.
    Malicious/insecure applications may be contained. Verify the origin of a chart,
    and try using official ones or well-maintained community repositories.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源验证**：在部署 Helm 图表之前，始终检查图表的来源，绝不要安装来自不信任或名声较差的仓库的图表。可能会包含恶意或不安全的应用程序。验证图表的来源，并尽量使用官方图表或维护良好的社区仓库。'
- en: '**Regular Audits**: Periodically run security audits of Helm charts and their
    dependencies. This process helps in identifying known vulnerabilities that, in
    turn, ensure applications deployed are secure enough to meet standards set by
    your organization. Perform vulnerability scanning within Helm charts using tools
    like Trivy or Anchore.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期审计**：定期对 Helm 图表及其依赖项进行安全审计。此过程有助于识别已知的漏洞，从而确保部署的应用程序足够安全，符合组织设定的标准。使用
    Trivy 或 Anchore 等工具进行 Helm 图表的漏洞扫描。'
- en: '**Chart Configuration**: Beware of the defaults that come in Helm charts. Most
    are shipped with configuration settings that are not appropriate to your production
    environment. Consider reviewing and adjusting the default settings as necessary,
    using your organizational security policy and best practices.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表配置**：注意 Helm 图表中的默认配置。大多数图表附带的配置设置并不适合你的生产环境。根据组织的安全政策和最佳实践，考虑必要时审查和调整默认设置。'
- en: '**Role-Based Access Control (RBAC)**: Implement this to restrict the deployment
    and management of Helm charts in your Kubernetes cluster. This will reduce unauthorized
    changes and also ensure that only trusted persons can deploy sensitive applications.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制 (RBAC)**：实现这一功能，以限制在 Kubernetes 集群中部署和管理 Helm 图表的权限。这将减少未经授权的更改，并确保只有受信任的人才能部署敏感应用程序。'
- en: '**Dependency Management:** Monitor and manage the list of dependencies shown
    within your Helm charts. Regularly update these to avoid security gaps in applications
    and make sure they receive the latest security patches and improvements.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理：** 监控和管理在 Helm charts 中显示的依赖项列表。定期更新这些依赖项，以避免应用程序中的安全漏洞，并确保它们接收到最新的安全补丁和改进。'
- en: '**Namespace Isolation:** Consider using Helm charts, each in their own separate
    namespace, as this will increase security. If something bad happens, the blast
    radius will be limited, thus giving better isolation for applications and their
    resources.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间隔离：** 考虑使用 Helm charts，并将每个 chart 放在各自独立的命名空间中，这样可以提高安全性。如果发生问题，爆炸范围将被限制，从而为应用程序及其资源提供更好的隔离。'
- en: By being proactive in these areas, you can go a long way toward improving the
    security posture of your Kubernetes deployments and ensuring that potential vulnerabilities
    do not bring down your applications and data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这些领域采取主动措施，你可以大大提高 Kubernetes 部署的安全性，确保潜在的漏洞不会摧毁你的应用程序和数据。
- en: Now, we have explored and practiced the Helm charts in the first half of this
    chapter. We also learned that the Helm chart is a great way to deploy and manage
    complex applications in Kubernetes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在本章的前半部分探讨并实践了 Helm charts。我们还了解到，Helm chart 是在 Kubernetes 中部署和管理复杂应用程序的一个极好的方式。
- en: As Kubernetes adoption increases, so does the complexity of the production environment
    for managing applications. While Helm and similar tools improve the process of
    deploying applications, they cannot independently address stateful applications’
    operational needs such as scaling, configuration management, and failure recovery
    at runtime. We need solutions that package application knowledge and best practices
    for operation to automate operational tasks at every stage of the applications’
    lives with health and high performance in mind. With these solutions, teams minimize
    human interaction as well as reducing human error, and focus on delivering value
    through the application and not managing the infrastructure. Kubernetes Operators
    were introduced to help with such requirements.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Kubernetes 的普及，管理应用程序的生产环境的复杂性也在增加。虽然 Helm 和类似的工具改进了应用程序部署的过程，但它们不能独立解决有状态应用程序在运行时的操作需求，如扩展、配置管理和故障恢复。我们需要能够将应用程序知识和最佳实践打包的解决方案，以便在应用程序生命周期的每个阶段自动化操作任务，同时确保健康和高性能。通过这些解决方案，团队可以最小化人工干预，减少人为错误，并专注于通过应用程序交付价值，而不是管理基础设施。Kubernetes
    操作员的引入正是为了满足这些需求。
- en: In the following section, we will learn what Kubernetes Operators are and how
    to install complex deployments with Kubernetes Operators.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将了解 Kubernetes 操作员是什么，以及如何使用 Kubernetes 操作员安装复杂的部署。
- en: Introducing Kubernetes Operators
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 Kubernetes 操作员
- en: We’ve explored the differences between Deployments and StatefulSets, with StatefulSets
    managing stateful applications that require persistent data storage. We also learned
    about the manual (and automated) operations needed for StatefulSets to function,
    such as data synchronization between Pod replicas and initialization tasks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 Deployment 和 StatefulSet 之间的差异，其中 StatefulSet 管理需要持久数据存储的有状态应用程序。我们还了解了
    StatefulSet 正常运行所需的手动（和自动）操作，例如 Pod 副本之间的数据同步和初始化任务。
- en: However, manual intervention goes against the core principles of Kubernetes,
    where automation and self-healing are paramount. This is where Kubernetes Operators
    step in.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，人工干预违背了 Kubernetes 的核心原则，即自动化和自愈至关重要。这时，Kubernetes 操作员发挥作用。
- en: From humans to software
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从人到软件
- en: Imagine replacing human Operators with software Operators. Kubernetes Operators
    are essentially software extensions that automate complex application management
    tasks, especially for stateful applications. Instead of relying on manual intervention
    to maintain application stacks, Operators leverage their built-in software components
    and intelligence to execute and manage these tasks effectively.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，将人类操作员替换为软件操作员。Kubernetes 操作员本质上是软件扩展，它们自动化了复杂的应用程序管理任务，尤其是有状态应用程序。操作员不再依赖人工干预来维护应用程序栈，而是利用其内建的软件组件和智能来有效地执行和管理这些任务。
- en: The following image shows the high-level relationship between the components
    in a Kubernetes cluster with Operators.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了 Kubernetes 集群中组件与操作员之间的高级关系。
- en: '![](img/B22019_14_07.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_07.png)'
- en: 'Figure 14.7: How Operators manage resources in Kubernetes'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：操作员如何在 Kubernetes 中管理资源
- en: In the following sections, we will discuss the advantages and benefits of Kubernetes
    Operators.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论 Kubernetes 操作员的优势和好处。
- en: Helm Charts versus Kubernetes Operators
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm Charts 与 Kubernetes 操作员
- en: While Helm charts are associated components related to Operators in application
    management on Kubernetes, they are different. With Helm, users can install applications
    much faster than with Operators because Helm is an effective package manager,
    using pre-designed charts that make the process easier.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Helm charts 是与 Kubernetes 上的应用程序管理相关的组件，它们与操作员不同。使用 Helm，用户可以比使用操作员更快地安装应用程序，因为
    Helm 是一个有效的包管理器，使用预设计的 chart，使得这一过程更加简单。
- en: It finds its best application in situations that demand speed and, therefore,
    it is ideal for a one-time installation or even for smaller applications. Yet
    Helm still focuses way more on the deployment phase rather than on the continued
    operational needs across an application’s runtime.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它在需要速度的情况下最为适用，因此非常适合一次性安装或较小的应用程序。然而，Helm 仍然更多地关注部署阶段，而不是在应用程序运行时的持续操作需求。
- en: Operators are software programs that intend to assume responsibility for the
    entire life cycle of complex and stateful applications. Using **Custom Resource
    Definitions** (**CRDs**), they encode knowledge about how an application operates
    and allow scaling, configuration management, automation of upgrades, and self-healing
    mechanisms. Operators are constantly observing the health of an application and
    taking corrective action to head it back toward the desired state. That’s why
    they become so valuable for applications that are very management- and observation-intensive.
    To put it succinctly, Helm charts make the deployment easy, but Operators extend
    Kubernetes into production operability, letting teams automate and simplify how
    they manage their apps in production.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员是旨在承担复杂和有状态应用程序整个生命周期管理责任的软件程序。通过**自定义资源定义**（**CRDs**），它们编码了应用程序如何运行的知识，并允许扩展、配置管理、自动化升级和自我修复机制。操作员不断观察应用程序的健康状况，并采取纠正措施使其恢复到期望的状态。这就是为什么它们在那些需要大量管理和监控的应用程序中变得非常宝贵。简而言之，Helm
    charts 简化了部署过程，但操作员扩展了 Kubernetes 到生产环境操作性，让团队能够自动化并简化如何管理生产环境中的应用程序。
- en: In the next section, let us explore some of the major features of Kubernetes
    Operators compared to Helm charts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨与 Helm charts 相比，Kubernetes 操作员的一些主要特点。
- en: How can the Operators help in the application deployment?
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作员如何帮助应用程序部署？
- en: 'Operators are created with the capabilities to manage and maintain the application
    with all possible operations, including the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员具备管理和维护应用程序的所有可能操作的能力，包括以下内容：
- en: '**Life Cycle Management**: Operators manage the life cycle of your application
    or application stack beyond mere initial deployment. They automate key operational
    tasks like upgrades, scaling, and recovery from failures to keep the application
    healthy and performing over time. Other approaches, like Helm charts, generally
    stop at deployment, whereas Operators constantly monitor the current application
    state and automatically reconcile it to the desired configuration in case changes
    or issues arise. This allows for automated upgrades, configuration changes, and
    status monitoring – all with no intervention required or even desired. For complex
    stateful applications with demanding life cycle management, Operators offer significant
    advantages over Helm and must be preferred for such applications that require
    continuous care and automated management.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期管理**：操作员管理应用程序或应用程序堆栈的生命周期，不仅仅限于初始部署。它们自动化关键的操作任务，如升级、扩展和故障恢复，以保持应用程序的健康和长期性能。其他方法，如
    Helm charts，通常仅停留在部署阶段，而操作员则不断监控当前应用程序状态，并在发生变化或问题时自动将其与期望配置进行对比。这允许自动化升级、配置更改和状态监控——所有这些都无需干预，甚至不希望干预。对于需要复杂生命周期管理的有状态应用程序，操作员相较于
    Helm 提供了显著的优势，对于那些需要持续维护和自动化管理的应用程序，应优先选择操作员。'
- en: '**Resource Orchestration**: Operators create essential resources like **ConfigMaps**,
    **Secrets**, and **PVCs** required by your application to function properly.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源编排**：操作员创建应用程序正常运行所需的基本资源，如 **ConfigMaps**、**Secrets** 和 **PVCs**。'
- en: '**Automated Deployment**: Operators can deploy your application stack based
    on either user-provided configurations or default values, streamlining the deployment
    process.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化部署**：操作员可以基于用户提供的配置或默认值来部署应用程序堆栈，从而简化部署过程。'
- en: '**Database Management**: Take PostgreSQL clusters, for example. Operators can
    leverage StatefulSets to deploy them and ensure data synchronization across replicas.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库管理**：以 PostgreSQL 集群为例，Operator 可以利用 StatefulSets 部署它们，并确保副本之间的数据同步。'
- en: '**Self-Healing Capabilities**: Operators can detect and react to application
    failures, triggering recovery or failover mechanisms to maintain service continuity.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自愈能力**：Operator 能够检测并响应应用程序故障，触发恢复或故障转移机制，以保持服务的连续性。'
- en: Reusability of the automation
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化的可重用性
- en: Operators promote reusability. The same Operator can be utilized across different
    projects or in multiple Kubernetes clusters, ensuring consistent and efficient
    application management throughout your infrastructure.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 促进了可重用性。相同的 Operator 可以在不同项目或多个 Kubernetes 集群中使用，确保在整个基础设施中一致且高效的应用程序管理。
- en: How Operators ensure the application state
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Operator 如何确保应用程序状态
- en: Kubernetes Operators function similarly to Kubernetes itself, utilizing a control
    loop to manage applications. This loop continuously monitors the desired state
    of your application, defined by a CRD, and compares it to the application’s actual
    state within the cluster. Any discrepancies trigger corrective actions from the
    Operator. These actions can involve scaling the application, updating configurations,
    or restarting Pods. The control loop’s continuous operation ensures your application
    remains aligned with the desired state, promoting self-healing and automated management.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Operator 的功能与 Kubernetes 本身类似，利用控制循环来管理应用程序。该循环不断监控由 CRD 定义的应用程序期望状态，并与集群中应用程序的实际状态进行比较。任何差异都会触发
    Operator 采取纠正措施。这些措施可能包括扩展应用程序、更新配置或重启 Pods。控制循环的持续运行确保你的应用程序始终与期望状态保持一致，从而促进自愈和自动化管理。
- en: Custom resource definitions – building blocks for Operators
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义资源定义——Operator 的构建模块
- en: Kubernetes Operators rely on CRDs. These are essentially extensions of the Kubernetes
    API that allow you to define custom resources specific to your application or
    its needs. Think of them as blueprints for your application’s desired configuration
    within the Kubernetes ecosystem.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Operator 依赖于 CRD。这些实际上是 Kubernetes API 的扩展，允许你为应用程序或其需求定义特定的自定义资源。可以把它们看作是
    Kubernetes 生态系统中应用程序期望配置的蓝图。
- en: 'CRDs essentially extend the Kubernetes API, allowing you to define custom resources
    specific to your application. These resources represent the building blocks of
    your application within the Kubernetes cluster. They can specify details like
    the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: CRD 本质上扩展了 Kubernetes API，允许你定义特定于应用程序的自定义资源。这些资源代表了你在 Kubernetes 集群中构建应用程序的基本模块。它们可以指定以下细节：
- en: The desired number of application replicas (Pods).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序副本（Pods）的期望数量。
- en: Resource requests and limits for memory and CPU.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存和 CPU 的资源请求与限制。
- en: Storage configurations for persistent data.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久数据的存储配置。
- en: Environment variables and configuration settings.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量和配置设置。
- en: Benefits of CRDs
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CRD 的优势
- en: 'There are multiple benefits of using CRDs to deploy applications, including
    the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CRD 部署应用程序有多个好处，包括以下几点：
- en: '**Declarative Management:** Instead of manually configuring individual resources
    like Deployments or Services, CRDs let you define the desired state of your application
    in a declarative manner. The Operator then takes care of translating that desired
    state into actual running resources within the cluster.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式管理**：与手动配置单独的资源（如部署或服务）不同，CRD 让你可以以声明式的方式定义应用程序的期望状态。然后，Operator 会负责将该期望状态转换为集群中实际运行的资源。'
- en: '**Application-Specific Configuration**: CRDs cater to the unique needs of your
    application. You can define custom fields specific to your application logic or
    configuration requirements.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序特定配置**：CRD 满足应用程序的独特需求。你可以定义特定于应用程序逻辑或配置要求的自定义字段。'
- en: '**Simplified Management:** CRDs provide a central point for managing your application’s
    configuration. This streamlines the process compared to scattered configurations
    across different resource types.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化管理**：CRD 提供了一个集中管理应用程序配置的点。与不同资源类型分散配置的方式相比，这简化了管理过程。'
- en: Operator distribution mechanism
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Operator 分发机制
- en: Operators are primarily created and distributed by application vendors who possess
    the expertise in deploying those specific application stacks. However, a vibrant
    community actively develops, distributes, and maintains a vast array of Operators.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Operators 主要由拥有特定应用堆栈部署经验的应用供应商创建和分发。然而，一个充满活力的社区积极开发、分发和维护着各种 Operators。
- en: OperatorHub ([https://operatorhub.io/](https://operatorhub.io/)) serves as a
    central repository where you can discover and install Operators for a wide range
    of applications and functionalities.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: OperatorHub ([https://operatorhub.io/](https://operatorhub.io/)) 作为一个中央仓库，供你发现和安装适用于各种应用和功能的
    Operators。
- en: '![](img/B22019_14_08.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_08.png)'
- en: 'Figure 14.8: OperatorHub main page'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：OperatorHub 主页面
- en: Building your own Operator
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建你自己的 Operator
- en: The **Operator Framework** provides a powerful toolkit known as the **Operator
    SDK**. This open-source gem empowers you to develop and build custom Operators,
    taking control of your application management within Kubernetes. The Operator
    SDK streamlines the often-complex process of crafting Operators. It offers pre-built
    components and functionalities that handle common tasks like interacting with
    the Kubernetes API, managing custom resources, and implementing the control loop.
    This allows you to focus on the unique logic and configuration needs of your specific
    application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**Operator 框架**提供了一个强大的工具包，称为 **Operator SDK**。这个开源宝石使你能够开发和构建自定义 Operators，从而掌控
    Kubernetes 中的应用管理。Operator SDK 简化了通常复杂的 Operator 创建过程。它提供了预构建的组件和功能，处理与 Kubernetes
    API 交互、管理自定义资源以及实现控制循环等常见任务。这使你能够专注于特定应用程序的独特逻辑和配置需求。'
- en: Building your own Operators unlocks several advantages. Firstly, you gain fine-grained
    control over application management. The Operator can be tailored to your application’s
    specific needs, handling configuration, deployment strategies, and scaling requirements
    perfectly. Secondly, Operators automate repetitive tasks associated with the application
    life cycle, leading to significant efficiency gains. Finally, custom Operators
    are reusable. Once built for a particular application, they can be applied across
    different deployments of the same application, saving you time and effort in managing
    your Kubernetes infrastructure.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你自己的 Operators 解锁了几个优势。首先，你获得了对应用管理的精细控制。Operator 可以根据应用程序的具体需求进行定制，完美地处理配置、部署策略和扩展要求。其次，Operators
    自动化了与应用生命周期相关的重复性任务，从而显著提高效率。最后，自定义的 Operators 是可重用的。一旦为特定应用程序构建，它们可以在同一应用的不同部署中应用，从而节省你在管理
    Kubernetes 基础设施上的时间和精力。
- en: You can learn more about the Operator SDK at [https://sdk.operatorframework.io/](https://sdk.operatorframework.io/).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://sdk.operatorframework.io/](https://sdk.operatorframework.io/)
    了解更多关于 Operator SDK 的信息。
- en: Before we do some hands-on with the Operator, let us learn a few details about
    **Operator Lifecycle Manager** (**OLM**) in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们动手操作 Operator 之前，让我们在下一节中了解一些关于**Operator 生命周期管理器**（**OLM**）的细节。
- en: Operator Lifecycle Manager (OLM)
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Operator 生命周期管理器（OLM）
- en: Operator Lifecycle Manager in Kubernetes simplifies the process of deploying
    and managing applications packaged as Operators. OLM uses a declarative way of
    specifying the resources using YAML files. In this, there is no need for complex
    multi-file deployments that rely on specific ordering. Installation and automatic
    upgrades also keep your Operators up to date with OLM. It also exposes a package
    discovery capability called Catalog Sources, which enables the use of Operators
    from, for example, OperatorHub, or from sources of your choosing. With OLM, you
    will gain several advantages. First, it reduces deployment complexity by managing
    dependencies and order. OLM can manage thousands of Operators over large clusters.
    What’s more, OLM enforces the desired configuration. This will ease rollouts and
    updates. Not to mention that OLM promotes standardization by providing a consistent
    way to package and deploy applications as Operators.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 Operator 生命周期管理器简化了将应用程序作为 Operator 打包并进行部署和管理的过程。OLM 使用声明式方法通过
    YAML 文件指定资源。在此过程中，无需依赖特定顺序的复杂多文件部署。安装和自动升级也确保你的 Operators 始终保持最新。它还提供了一个名为目录源（Catalog
    Sources）的包发现功能，使你能够使用来自例如 OperatorHub 或其他选择来源的 Operators。通过 OLM，你将获得几个优势。首先，它通过管理依赖关系和顺序，减少了部署的复杂性。OLM
    可以在大规模集群中管理成千上万的 Operators。更重要的是，OLM 强制执行所需的配置，这将简化发布和更新过程。更不用说，OLM 通过提供一种一致的方式来打包和部署应用程序作为
    Operators，推动了标准化。
- en: This is a question of your environment and personal preference. OLM is much
    more integrated and native to Kubernetes, while Helm, being familiar for other
    deployments, comes with a richer package ecosystem.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于环境和个人偏好的问题。OLM 与 Kubernetes 更加集成和原生，而 Helm 由于在其他部署中更为常见，具有更丰富的软件包生态系统。
- en: When we learn about Operators and OLM, it is also important to know about the
    **ClusterServiceVersion** (**CSV**). The ClusterServiceVersion will be the central
    point of an important part of Kubernetes’ Operator Lifecycle Manager, the core
    metadata processing and deploying information of the Operator. It goes on to define
    the name of the Operator and the version it holds, and gives a brief description.
    It also outlines the permissions or roles required by the Operator to operate
    correctly. It defines the CRDs that the Operator governs, installation strategy,
    and upgrade flows. Refer to the documentation ([https://olm.operatorframework.io/docs/concepts/crds/clusterserviceversion/](https://olm.operatorframework.io/docs/concepts/crds/clusterserviceversion/))
    to learn more about the CSV.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Operators 和 OLM 的过程中，了解 **ClusterServiceVersion**（**CSV**）同样很重要。ClusterServiceVersion
    是 Kubernetes Operator 生命周期管理器中的一个重要部分，它是 Operator 的核心元数据处理和部署信息。它定义了 Operator
    的名称及其所包含的版本，并给出了简短的描述。它还概述了 Operator 正常运行所需的权限或角色。它定义了 Operator 所管理的 CRD、安装策略以及升级流程。有关
    CSV 的更多信息，请参见文档（[https://olm.operatorframework.io/docs/concepts/crds/clusterserviceversion/](https://olm.operatorframework.io/docs/concepts/crds/clusterserviceversion/)）。
- en: In the following section, we’ll explore how to deploy Prometheus monitoring
    on Kubernetes using both OLM and the Prometheus Operator, showcasing the power
    of both approaches in application management.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨如何使用 OLM 和 Prometheus Operator 在 Kubernetes 上部署 Prometheus 监控，展示这两种方法在应用程序管理中的强大功能。
- en: Enabling Kubernetes monitoring using Prometheus and Grafana
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Prometheus 和 Grafana 启用 Kubernetes 监控
- en: Success in keeping your Kubernetes applications healthy and performant depends
    on different factors; one of those is having a robust, reliable environment. Here,
    monitoring tools like **Prometheus** and **Grafana** can help. Prometheus works
    behind the scenes; it gathers and stores valuable metrics about your Kubernetes
    cluster. Grafana visualizes this treasure trove of data, presenting it in an understandable
    format for you to gain deep insight into the health and behavior of your applications
    and infrastructure.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 Kubernetes 应用程序健康和高效运行的成功取决于多个因素，其中之一是拥有一个强大且可靠的环境。在这里，像 **Prometheus** 和
    **Grafana** 这样的监控工具可以提供帮助。Prometheus 在幕后工作，它收集并存储有关 Kubernetes 集群的宝贵指标。Grafana
    则将这些宝贵的数据以易于理解的格式进行可视化，帮助你深入了解应用程序和基础设施的健康状况和行为。
- en: The following figure shows the high-level architecture of Prometheus components.
    (It’s an official reference.)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Prometheus 组件的高层架构。（这是官方参考资料。）
- en: '![](img/B22019_14_09.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_09.png)'
- en: 'Figure 14.9: Architecture of Prometheus and some of its ecosystem components
    (Source: https://prometheus.io/docs/introduction/overview/)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：Prometheus 及其一些生态系统组件的架构（来源：[https://prometheus.io/docs/introduction/overview/](https://prometheus.io/docs/introduction/overview/)）
- en: Traditional deployments, say, of monitoring stacks comprising Prometheus and
    Grafana, are pretty cumbersome. Writing several YAML manifests by hand, with all
    the dependencies and the proper ordering of deployment, is rather laborious and
    prone to errors. The Prometheus and Grafana Operators offer an even more efficient
    and maintainable solution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的部署方式，例如部署包含 Prometheus 和 Grafana 的监控栈，往往非常繁琐。手动编写多个 YAML 清单，处理所有的依赖关系和正确的部署顺序，不仅繁琐，而且容易出错。Prometheus
    和 Grafana Operators 提供了一个更高效、更易维护的解决方案。
- en: It is possible to utilize Helm charts to deploy this entire monitoring stack
    – including Operators and instances – using projects such as `kube-prometheus-stack`
    (https://artifacthub.io/packages/helm/prometheus-community/kube-prometheus-stack).
    But in the next section, our intention is to set up the same monitoring stack
    using OLM.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以利用 Helm charts 部署整个监控栈——包括 Operators 和实例——使用如 `kube-prometheus-stack`（[https://artifacthub.io/packages/helm/prometheus-community/kube-prometheus-stack](https://artifacthub.io/packages/helm/prometheus-community/kube-prometheus-stack)）这样的项目。但在下一部分，我们的目的是使用
    OLM 设置相同的监控栈。
- en: In the following section, we’ll explore the process of deploying Prometheus
    and Grafana within your Kubernetes cluster, equipping you to effectively monitor
    your applications and ensure their smooth operation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探索在 Kubernetes 集群中部署 Prometheus 和 Grafana 的过程，帮助你有效地监控应用程序，确保它们的顺利运行。
- en: Installing Operator Lifecycle Manager
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Operator 生命周期管理器
- en: 'To utilize the OLM-based operator installation, we need to install OLM in the
    cluster. You can install OLM in the cluster using the `operator-sdk` utility,
    Helm charts, or even by applying the Kubernetes YAML manifests for OLM. For this
    exercise, let us use the `install.sh` script-based installation as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用基于OLM的操作员安装，我们需要在集群中安装OLM。 您可以使用`operator-sdk`实用程序，Helm图表甚至通过应用于OLM的Kubernetes
    YAML清单来在集群中安装OLM。 对于这个练习，让我们使用`install.sh`脚本为基础的安装。
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Wait for the script to complete and configure the Kubernetes cluster with OLM.
    Once finished, verify the Pods are running in the `olm` namespace as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 等待脚本完成并使用OLM配置Kubernetes集群。 完成后，请验证Pods是否在`olm`命名空间中运行：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, check the ClusterServiceVersion details using the `kubectl get csv` command
    as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 还要使用`kubectl get csv`命令检查ClusterServiceVersion详细信息如下：
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That has a success status – we can see the OLM is deployed and ready to manage
    the Operators. In the next section, we will deploy Prometheus and Grafana Operators
    using OLM.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 具有成功状态 - 我们可以看到OLM已部署并准备好管理操作员。 在下一部分中，我们将使用OLM部署Prometheus和Grafana操作员。
- en: Installing Prometheus and Grafana Operators using OLM
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OLM安装Prometheus和Grafana操作员
- en: Once you configure OLM, deploying Operators is pretty straightforward. Most
    of the time, you will find the operator installation command and instructions
    on the Operators page at `operatorhub.io`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置OLM，部署操作员就非常简单。 大多数情况下，您会在`operatorhub.io`的操作员页面上找到操作员安装命令和说明。
- en: 'To install the Prometheus operator ([https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus))
    using OLM, follow these steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用OLM安装Prometheus操作员（[https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus)），请按照以下步骤操作：
- en: 'Search for the Prometheus Operator in OperatorHub:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OperatorHub中搜索Prometheus Operator：
- en: '[PRE41]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Install the Prometheus operator using OLM:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用OLM安装Prometheus操作员：
- en: '[PRE42]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: https://operatorhub.io/install/prometheus.yaml provides a basic YAML definition
    to create a subscription. You can create local YAML files with all the customization
    required.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://operatorhub.io/install/prometheus.yaml](https://operatorhub.io/install/prometheus.yaml)提供了创建订阅的基本YAML定义。
    您可以创建带有所有所需自定义的本地YAML文件。'
- en: 'Wait for a few minutes and ensure the Prometheus operator is deployed properly:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几分钟并确保Prometheus操作员已正确部署：
- en: '[PRE43]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Verify the Prometheus operator Pods are running:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证Prometheus操作员Pods是否在运行：
- en: '[PRE44]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the same way, find and install the Grafana operator using OLM (follow the
    previous steps for references):'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同方式，使用OLM找到并安装Grafana操作员（按照先前的步骤进行参考）：
- en: '[PRE45]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, also verify the CRDs created in the backend as these entries are created
    as part of the Operator installation:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，还要验证在后端创建的CRDs，因为这些条目是作为操作员安装的一部分创建的：
- en: '[PRE46]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You will find multiple CRDs created in the Kubernetes cluster.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在Kubernetes集群中找到多个创建的CRD。
- en: Now that we have deployed the Operators, it is time to create the Prometheus
    and Grafana instances and configure the stack to monitor the Kubernetes cluster.
    We will learn about these operations in the next section.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了操作员，是时候创建Prometheus和Grafana实例并配置堆栈以监视Kubernetes集群了。 我们将在下一部分了解这些操作。
- en: Configuring Prometheus and Grafana instances using Operators
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用操作员配置Prometheus和Grafana实例
- en: To configure new instances, let us utilize standard YAML definitions with the
    CRD configuration. The instructions and the YAML definition files for this exercise
    are stored in the `Chapter 14` directory of the GitHub repository.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置新实例，让我们使用带有CRD配置的标准YAML定义。 此练习的说明和YAML定义文件存储在GitHub存储库的`第14章`目录中。
- en: 'Follow the steps to configure a monitoring stack in Kubernetes with Prometheus
    and Grafana:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 按照步骤配置使用Prometheus和Grafana在Kubernetes中的监控堆栈：
- en: 'As a best practice, let us create a namespace to deploy the monitoring solution
    (refer to `monitoring-ns.yaml`):'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最佳实践，让我们创建一个命名空间来部署监控解决方案（参考`monitoring-ns.yaml`）：
- en: '[PRE47]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Configure a ServiceAccount with the appropriate role and RBAC (refer to `monitoring-sa.yaml`
    in the repo):'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的角色和RBAC配置ServiceAccount（请参阅存储库中的`monitoring-sa.yaml`）：
- en: '[PRE48]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Prepare YAML for the new Prometheus instance (refer to `promethues-instance.yaml`):'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的Prometheus实例准备YAML（请参阅`promethues-instance.yaml`）：
- en: '[PRE49]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Notice the `kind: Prometheus` in the preceding YAML definition, as we are using
    a CRD here; the Prometheus operator will understand this CRD and take necessary
    actions to create the deployment.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '注意在前述YAML定义中的`kind: Prometheus`，因为我们在这里使用CRD； Prometheus操作员将理解此CRD并采取必要的操作以创建部署。'
- en: 'Create a new Prometheus instance by applying the configuration to the cluster:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将配置应用到集群，创建一个新的 Prometheus 实例：
- en: '[PRE50]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In a similar way, deploy the Grafana instance using the operator:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，使用 Operator 部署 Grafana 实例：
- en: '[PRE51]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We are using the configuration and passwords here in plain text directly inside
    the YAML definition. In a production environment, you should be using Kubernetes
    Secrets to store such sensitive data.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们直接在 YAML 定义中以明文方式使用了配置和密码。在生产环境中，你应该使用 Kubernetes Secrets 来存储这些敏感数据。
- en: 'Apply the YAML definition to create a Grafana instance:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用 YAML 定义以创建 Grafana 实例：
- en: '[PRE52]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Verify the objects created by Prometheus and Grafana Operators in the `monitoring`
    namespace:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 Prometheus 和 Grafana Operator 在 `monitoring` 命名空间中创建的对象：
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can see, in the preceding output, that the Operators have created appropriate
    Kubernetes resources based on the CRD. You can even see the Prometheus and Grafana
    Service created and will be able to access it. We will demonstrate it at a later
    stage of this exercise.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到，在前面的输出中，Operators 已根据 CRD 创建了适当的 Kubernetes 资源。你甚至可以看到 Prometheus 和 Grafana
    服务已创建，并且能够访问它。我们将在本练习的后续阶段演示这一过程。
- en: For demonstration purposes, let us enable Node Exporter in the cluster and visualize
    it using Grafana. Node Exporter is one of the Prometheus exporters, which exposes
    detailed metrics of a host machine, including hardware and OS details, such as
    CPU usage, memory usage, and other system-level metrics. It runs on each node
    in a Kubernetes cluster – or physical or virtual servers – as a separate service
    and exposes these metrics through an HTTP endpoint. By scraping this data, Prometheus
    can know the health and performance of a node, thereby enabling an administrator
    to understand resource utilization and point out problems in the infrastructure.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们在集群中启用 Node Exporter，并通过 Grafana 进行可视化。Node Exporter 是 Prometheus 的一种导出器，它暴露了主机机器的详细指标，包括硬件和操作系统信息，如
    CPU 使用率、内存使用率以及其他系统级别的指标。它作为一个独立服务在 Kubernetes 集群的每个节点上运行，或在物理/虚拟服务器上运行，并通过 HTTP
    端点暴露这些指标。通过抓取这些数据，Prometheus 可以了解节点的健康状况和性能，从而使管理员能够理解资源利用情况并指出基础设施中的问题。
- en: 'Running Node Exporter as a DaemonSet would imply that each node in the Kubernetes
    cluster is running an instance of the exporter. In that way, Prometheus would
    be able to consistently scrape the system metrics across all nodes for effective
    observation of the overall health and performance of the cluster. Create the Node
    Exporter using `node-exporter-daemonset.yaml` as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以 DaemonSet 方式运行 Node Exporter 意味着 Kubernetes 集群中的每个节点都会运行一个导出器实例。通过这种方式，Prometheus
    将能够持续抓取所有节点的系统指标，从而有效观察整个集群的健康状况和性能。使用 `node-exporter-daemonset.yaml` 创建 Node
    Exporter，配置如下：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A Node Exporter Service (`svc`) should be created to expose the metrics that
    the Node Exporter is collecting to Prometheus. The service provides a way for
    Prometheus to discover and scrape metrics from the Node Exporter pods running
    on each node, thus providing a capability of centralized monitoring of node performance
    across the Kubernetes cluster. Create a Service for Node Exporter as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 应该创建一个 Node Exporter 服务（`svc`）来暴露 Node Exporter 收集的指标，以便 Prometheus 抓取。这项服务为
    Prometheus 提供了一种方式，帮助它发现并抓取运行在每个节点上的 Node Exporter pods 的指标，从而实现对 Kubernetes 集群中节点性能的集中监控。创建
    Node Exporter 服务，配置如下：
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A Node Exporter serviceMonitor conventionally enables Prometheus to discover
    and scrape the Node Exporter service for metrics. This described configuration
    simplifies the whole process of monitoring by defining how and where Prometheus
    should scrape for metrics, like specifying the target service, interval, labels,
    and others serving to ensure consistency in the collection without an administrator’s
    intervention. Create a serviceMonitor CRD as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Node Exporter serviceMonitor 通常会启用 Prometheus 来发现并抓取 Node Exporter 服务的指标。这个配置简化了整个监控过程，通过定义
    Prometheus 应该如何以及在哪里抓取指标（例如，指定目标服务、间隔、标签等），确保在无需管理员干预的情况下收集的一致性。如下所示，创建一个 serviceMonitor
    CRD：
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let us verify the Prometheus portal to ensure the details are collected there.
    In one of your consoles, start a `kubectl port-forward` command to expose the
    Prometheus service as follows (you can end the `port-forward` using *Ctrl+C* later
    once you finish testing):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证 Prometheus 门户，确保那里收集了相关详细信息。在你的某个控制台中，启动 `kubectl port-forward` 命令以暴露
    Prometheus 服务，命令如下（测试完成后，你可以通过按 *Ctrl+C* 结束 `port-forward`）：
- en: '[PRE57]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Open a browser and access `http://localhost:9091/targets` to ensure `node-exporter`
    is visible to Prometheus.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问`http://localhost:9091/targets`，以确保`node-exporter`对Prometheus可见。
- en: '![](img/B22019_14_10.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_10.png)'
- en: 'Figure 14.10: Prometheus portal with node-exporter visible for Kubernetes node'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：Prometheus门户，Kubernetes节点上可见node-exporter
- en: You can confirm from the preceding screenshot that Prometheus is getting the
    node metrics successfully.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从上面的截图确认Prometheus正在成功获取节点指标。
- en: 'Now, let us visualize the metrics and monitoring data using our visualization
    tool, Grafana. Open a console and use the `kubectl port-foward` command to expose
    the Grafana service as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用可视化工具Grafana来可视化指标和监控数据。打开控制台，使用`kubectl port-forward`命令将Grafana服务暴露出来，如下所示：
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Open a browser and access the URL http://localhost:3000 to see the Grafana dashboard.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问`http://localhost:3000`查看Grafana仪表板。
- en: '![](img/B22019_14_11.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_11.png)'
- en: 'Figure 14.11: Grafana portal'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11：Grafana门户
- en: Use the login credential you have configured in the `grafana-instance.yaml`
    (or the secret if you used one) and log in to the Grafana dashboard.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在`grafana-instance.yaml`中配置的登录凭据（或者如果使用了密钥，则使用密钥），登录Grafana仪表板。
- en: You will only find a default dashboard there as we need to configure a new dashboard
    for our own purpose.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里你只会看到一个默认的仪表板，因为我们需要为自己的目的配置一个新的仪表板。
- en: From the left-side menu, go to **Connections | Data sources** as shown in the
    following figure.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧菜单中，转到**Connections | Data sources**，如下图所示。
- en: '![](img/B22019_14_12.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_12.png)'
- en: 'Figure 14.12: Adding a data source in Grafana'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：在Grafana中添加数据源
- en: In the next window, select **Prometheus** as the data source and enter the Prometheus
    URL as shown in the following figure. Remember to enter the FQDN (e.g., `http://prometheus-operated.monitoring.svc.cluster.local:9090`
    – r to *Chapter 8*, *Exposing Your Pods with Services*, to learn more about Services
    and FQDNs).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个窗口中，选择**Prometheus**作为数据源，并输入Prometheus URL，如下图所示。记得输入FQDN（例如`http://prometheus-operated.monitoring.svc.cluster.local:9090`
    – 参见*第8章*，*使用服务暴露你的Pods*，了解更多关于服务和FQDN的内容）。
- en: '![](img/B22019_14_13.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_13.png)'
- en: 'Figure 14.13: Configure Grafana data source'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：配置Grafana数据源
- en: Click on the **Save & test** button at the bottom of the page and you will receive
    a success message as shown in the following figure. (If you get any error messages,
    then please check the Prometheus URL you have used, including the FQDN and the
    port number.)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 点击页面底部的**保存并测试**按钮，你将收到成功消息，如下图所示。（如果出现任何错误消息，请检查你使用的Prometheus URL，包括FQDN和端口号。）
- en: '![](img/B22019_14_14.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_14.png)'
- en: 'Figure 14.14: Grafana data source configured successfully'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14：Grafana数据源配置成功
- en: Now that we have the data source, we need to create a dashboard to visualize
    the data. You can either create a dashboard from scratch or import the dashboard
    with predefined configurations. For that, visit `https://grafana.com/grafana/dashboards/`
    and find the **Node Exporter Full** dashboard. Click on the **Copy ID to clipboard**
    button as follows.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已有数据源，需要创建一个仪表板来可视化数据。你可以从头开始创建一个仪表板，也可以导入一个带有预定义配置的仪表板。为此，访问`https://grafana.com/grafana/dashboards/`并找到**Node
    Exporter Full**仪表板。点击**复制ID到剪贴板**按钮，如下所示。
- en: '![](img/B22019_14_15.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_15.png)'
- en: 'Figure 14.15: Copy the Grafana dashboard ID to import'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15：复制Grafana仪表板ID以导入
- en: Go back to the Grafana **WEBUI | Dashboards | New | Import**, as shown in the
    following figure.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到Grafana的**WEBUI | Dashboards | New | Import**，如下图所示。
- en: '![](img/B22019_14_16.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_16.png)'
- en: 'Figure 14.16: Importing a new dashboard to Grafana'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16：将新仪表板导入Grafana
- en: Enter the **Node** **Exporter Full** dashboard ID that you already copied in
    the previous step, as shown here, and click on the **Load** button.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你在前一步已经复制的**Node Exporter Full**仪表板ID，如下所示，然后点击**加载**按钮。
- en: '![](img/B22019_14_17.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_17.png)'
- en: 'Figure 14.17: Provide the dashboard ID to import in Grafana'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：提供仪表板ID以在Grafana中导入
- en: On the next screen, select **Prometheus** as the data source (which you configured
    earlier) and click the **Import** button as follows.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个页面中，选择**Prometheus**作为数据源（之前已配置过的），然后点击**导入**按钮，如下所示。
- en: '![](img/B22019_14_18.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_18.png)'
- en: 'Figure 14.18: Complete dashboard import in Grafana'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18：在Grafana中完成仪表板导入
- en: That’s it; you will see the nice dashboard with preconfigured widgets and graphs,
    as shown in the following figure. You can explore the dashboard and find the details
    about your cluster, such as CPU, memory, network traffic, and so on.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你将看到一个漂亮的仪表板，内置了预配置的部件和图表，如下图所示。你可以探索仪表板，查看关于集群的详细信息，如 CPU、内存、网络流量等。
- en: '![](img/B22019_14_19.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_14_19.png)'
- en: 'Figure 14.19: Node Exporter: full dashboard imported in Grafana'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19：Node Exporter：在 Grafana 中导入的完整仪表板
- en: Congratulations, you have successfully deployed the Prometheus and Grafana stack
    on your Kubernetes cluster with Node Exporter enabled!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，成功在 Kubernetes 集群上部署了 Prometheus 和 Grafana 堆栈，并启用了 Node Exporter！
- en: That is all for this chapter. As you can see, working with Helm charts and Operators,
    even for complex, multi-component solutions, is easy and can provide a lot of
    benefits for your development and production environments.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此为止。正如你所看到的，使用 Helm 图表和 Operators，即使是复杂的多组件解决方案，也非常简单，并且可以为你的开发和生产环境带来诸多好处。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered the details of working with Helm, Helm charts, and Kubernetes
    Operators. First, you learned what the purpose of package management is and how
    Helm works as a package manager for Kubernetes. We demonstrated how you can install
    Helm on your local machine, and how you can deploy a WordPress chart to test the
    installation. Then, we went through the structure of Helm charts, and we showed
    how the YAML templates in charts can be configured using user-provided values.
    Next, we showed the installation of popular solutions on a Kubernetes cluster
    using Helm. We installed Kubernetes Dashboard and explored the components. After
    that, we learned about Kubernetes Operators and other components, including customer
    resource definitions. We also deployed the Prometheus stack, including Grafana
    using Helm and Operators.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用 Helm、Helm 图表和 Kubernetes Operators。首先，你了解了软件包管理的目的以及 Helm 如何作为 Kubernetes
    的软件包管理器工作。我们演示了如何在本地计算机上安装 Helm，并如何部署一个 WordPress 图表来测试安装。接着，我们介绍了 Helm 图表的结构，并展示了如何使用用户提供的值来配置图表中的
    YAML 模板。随后，我们展示了如何使用 Helm 在 Kubernetes 集群上安装流行的解决方案。我们安装了 Kubernetes Dashboard
    并探索了其组件。之后，我们学习了 Kubernetes Operators 和其他组件，包括自定义资源定义（CRD）。我们还使用 Helm 和 Operators
    部署了 Prometheus 堆栈，包括 Grafana。
- en: In the next part, you will get all the details required to effectively deploy
    Kubernetes clusters in different cloud environments. We will first take a look
    at working with clusters deployed on Google Kubernetes Engine.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，你将获得在不同云环境中有效部署 Kubernetes 集群所需的所有细节。我们将首先介绍如何在 Google Kubernetes Engine
    上操作集群。
- en: Further reading
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Helm website**: [https://helm.sh/](https://helm.sh/'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm 网站**： [https://helm.sh/](https://helm.sh/)'
- en: )
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Kubernetes Dashboard**: [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 仪表板**： [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/)'
- en: )
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Accessing Dashboard**: [https://github.com/kubernetes/dashboard/blob/master/docs/user/accessing-dashboard/README.md](https://github.com/kubernetes/dashboard/blob/master/docs/user/accessing-dashboard/README.md'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问仪表板**： [https://github.com/kubernetes/dashboard/blob/master/docs/user/accessing-dashboard/README.md](https://github.com/kubernetes/dashboard/blob/master/docs/user/accessing-dashboard/README.md)'
- en: )
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Deploy and Access the Kubernetes Dashboard**: [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署和访问 Kubernetes 仪表板**： [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/)'
- en: )
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Creating a sample user for dashboard access**: [https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md](https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为仪表板访问创建一个示例用户**： [https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md](https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md)'
- en: )
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Build a Kubernetes Operator in six steps**: [https://developers.redhat.com/articles/2021/09/07/build-kubernetes-operator-six-steps](https://developers.redhat.com/articles/2021/09/07/build-kubernetes-operator-six-steps'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**六步构建一个 Kubernetes Operator**： [https://developers.redhat.com/articles/2021/09/07/build-kubernetes-operator-six-steps](https://developers.redhat.com/articles/2021/09/07/build-kubernetes-operator-six-steps)'
- en: )
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Custom resources**: [https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义资源**：[https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)'
- en: )
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'For more information regarding Helm and Helm charts, please refer to the following
    *Packt Publishing* book:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关Helm和Helm Charts的更多信息，请参考以下 *Packt Publishing* 的书籍：
- en: '*Learn Helm*, by *Andrew Block*, *Austin Dewey* ([https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295))'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Helm*，作者 *Andrew Block*，*Austin Dewey* ([https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295))'
- en: 'You can learn more about Elasticsearch and Prometheus in the following *Packt
    Publishing* books:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 *Packt Publishing* 的书籍中了解更多关于Elasticsearch和Prometheus的内容：
- en: '*Learning Elasticsearch*, by *Abhishek Andhavarapu* ([https://www.packtpub.com/product/learning-elasticsearch/9781787128453](https://www.packtpub.com/product/learning-elasticsearch/9781787128453))'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Elasticsearch*，作者 *Abhishek Andhavarapu* ([https://www.packtpub.com/product/learning-elasticsearch/9781787128453](https://www.packtpub.com/product/learning-elasticsearch/9781787128453))'
- en: '*Hands-On Infrastructure Monitoring with Prometheus*, by *Joel Bastos*, *Pedro
    Araujo* ([https://www.packtpub.com/product/hands-on-infrastructure-monitoring-with-prometheus/9781789612349](https://www.packtpub.com/product/hands-on-infrastructure-monitoring-with-prometheus/9781789612349))'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Prometheus进行基础设施监控*，作者 *Joel Bastos*，*Pedro Araujo* ([https://www.packtpub.com/product/hands-on-infrastructure-monitoring-with-prometheus/9781789612349](https://www.packtpub.com/product/hands-on-infrastructure-monitoring-with-prometheus/9781789612349))'
- en: Join our community on Discord
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区，进入Discord
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
- en: '![](img/QR_Code119001106479081656.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code119001106479081656.png)'
