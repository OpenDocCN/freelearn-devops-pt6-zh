- en: '*Chapter 8*: Deploying Seamless and Reliable Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：部署无缝且可靠的应用程序'
- en: In previous chapters, we learned how to prepare our platform and infrastructure
    components for production usage. We also learned Kubernetes data management considerations
    and storage best practices to deploy our first stateful application using the
    Operator Framework. One of the most underestimated topics in container orchestration
    is container image management. Although developing applications in Kubernetes
    is out of the scope of this book, we need to understand the critical components
    of our images. There are multiple sources, public container registries, and vendors
    where we can find ready-to-consume application images. Mishandling container images
    can not only cause overutilization of our cluster resources but, more importantly,
    can also impact the reliability and security of our services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何为生产使用准备平台和基础设施组件。我们还了解了 Kubernetes 数据管理的注意事项以及存储最佳实践，以使用 Operator
    Framework 部署我们的第一个有状态应用程序。容器编排中最被低估的话题之一是容器镜像管理。尽管在本书中不涉及在 Kubernetes 中开发应用程序，但我们需要了解镜像的关键组件。我们可以通过多个来源、公共容器注册表和供应商来找到现成的应用程序镜像。错误处理容器镜像不仅可能导致集群资源的过度使用，更重要的是，还可能影响我们服务的可靠性和安全性。
- en: In this chapter, we will discuss topics such as containers and image management.
    We will learn about the technical challenges when selecting or creating our application
    images that affect the Kubernetes cluster's stability and security. We will focus
    on application rollout best practices when deploying and creating our production
    services before hosting on our cluster to avoid creating instability or misuse
    of the cluster. This will help us to get the full benefits of using Kubernetes
    to orchestrate our services securely.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论容器和镜像管理等话题。我们将了解在选择或创建影响 Kubernetes 集群稳定性和安全性的应用程序镜像时遇到的技术挑战。我们将重点关注在将生产服务部署到集群之前，如何在应用程序发布中采用最佳实践，以避免集群不稳定或误用。这将帮助我们充分利用
    Kubernetes 安全地编排我们的服务。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Understanding the challenges with container images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器镜像面临的挑战
- en: Learning application deployment strategies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习应用程序部署策略
- en: Scaling applications and achieving higher availability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展应用程序并实现更高的可用性
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You should have the following tools installed from previous chapters:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了前几章中提到的以下工具：
- en: '`kubectl`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`'
- en: '`metrics-server`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metrics-server`'
- en: You need to have an up-and-running Kubernetes cluster as per the instructions
    in [*Chapter 3*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073), *Provisioning
    Kubernetes Clusters Using AWS and Terraform*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据 [*第3章*](B16192_03_Final_PG_ePub.xhtml#_idTextAnchor073)《使用 AWS 和 Terraform
    配置 Kubernetes 集群》中的说明，拥有一个正在运行的 Kubernetes 集群。
- en: The code for this chapter is located at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter08](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter08).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于 [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter08](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/tree/master/Chapter08)。
- en: 'Check out the following link to see the Code in Action video:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，观看“代码实战”视频：
- en: '[https://bit.ly/3rpWeRN](https://bit.ly/3rpWeRN)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3rpWeRN](https://bit.ly/3rpWeRN)'
- en: Understanding the challenges with container images
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器镜像面临的挑战
- en: In this section, we will learn about the considerations and best practices followed
    by industry experts when building or selecting the right container images. Before
    we discuss the challenges and get into our options, let's learn what goes into
    a container image.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将了解行业专家在构建或选择正确的容器镜像时的注意事项和最佳实践。在讨论挑战并深入探讨我们的选择之前，让我们了解容器镜像的组成。
- en: Exploring the components of container images
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索容器镜像的组成
- en: 'To understand the behavior of a container image, we need to have basic knowledge
    of the **Operating System** (**OS**) and hierarchical protection domains. For
    security segregation purposes, the OS handles virtual memory in two layers called
    **kernel space** and **user space**. Basically, the kernel runs in the most privileged
    protection ring, called **Ring 0**, and interacts directly with critical resources
    such as CPU and memory. The kernel needs to be stable since any problem or instability
    would cause instability in the overall system and bring everything to a panic
    state. As we can see in *Figure 8.1*, drivers, low-level system components, and
    all user applications run in the least privileged protection rings and in user
    space:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解容器镜像的行为，我们需要具备基本的**操作系统**（**OS**）和层级保护域的知识。为了安全隔离，操作系统将虚拟内存分为两层，称为**内核空间**和**用户空间**。基本上，内核运行在最特权的保护环中，叫做**环
    0**，并直接与诸如 CPU 和内存等关键资源进行交互。内核需要保持稳定，因为任何问题或不稳定都会导致整个系统的不稳定，进而使系统进入崩溃状态。正如我们在*图
    8.1*中看到的，驱动程序、低级系统组件以及所有用户应用程序都运行在最不特权的保护环和用户空间中：
- en: '![Figure 8.1 – Privilege rings, also called hierarchical protection domains'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 特权环，也称为层级保护域](img/B16192_08_001.jpg)'
- en: '](img/B16192_08_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_08_001.jpg)'
- en: Figure 8.1 – Privilege rings, also called hierarchical protection domains
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 特权环，也称为层级保护域
- en: 'To learn about the user space, please check out the detailed explanation here:
    [https://debian-handbook.info/browse/stable/sect.user-space.html](https://debian-handbook.info/browse/stable/sect.user-space.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解用户空间的详细信息，请查看这里的详细解释：[https://debian-handbook.info/browse/stable/sect.user-space.html](https://debian-handbook.info/browse/stable/sect.user-space.html)。
- en: Linux containers take the segregation of security one step further and allow
    us to manage application and OS dependencies separately in what is called the
    **container host** and **container image**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器在安全隔离方面更进一步，使我们能够在所谓的**容器主机**和**容器镜像**中分别管理应用程序和操作系统的依赖项。
- en: 'The container host is where the OS runs along with the **container runtime**
    (some of the popular container runtimes include **containerd**, **CRI-O**, **Firecracker**,
    and **Kata**) and **container engine** (some of the popular container engines
    include Docker and the **Linux Container Daemon** (**LXD**)). In this book, we
    will not discuss the differences between container runtimes and engines, since
    most of the time they are part of the platform, which is outside of our scope.
    In traditional monolithic architectures, we run applications on top of the OS
    along with OS dependencies and other applications, whereas in cloud-native microservices
    architectures, we run applications and their dependencies inside a container image
    (see *Figure 8.2*):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器主机是操作系统与**容器运行时**（一些流行的容器运行时包括**containerd**、**CRI-O**、**Firecracker** 和 **Kata**）以及**容器引擎**（一些流行的容器引擎包括
    Docker 和 **Linux 容器守护进程**（**LXD**））一起运行的地方。在本书中，我们不会讨论容器运行时和引擎之间的区别，因为它们大多数时候是平台的一部分，这不在我们的讨论范围内。在传统的单体架构中，我们在操作系统上运行应用程序及其操作系统依赖项和其他应用程序，而在云原生微服务架构中，我们将应用程序及其依赖项运行在容器镜像中（见*图
    8.2*）：
- en: '![Figure 8.2 – Comparison of monolithic and microservices architecture](img/B16192_08_002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 单体架构与微服务架构的比较](img/B16192_08_002.jpg)'
- en: Figure 8.2 – Comparison of monolithic and microservices architecture
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 单体架构与微服务架构的比较
- en: When we run an application in Kubernetes, such as NGINX, Cassandra, Kafka, MongoDB,
    and so on, our container engine pulls the container image from its container registry
    to the local registry, then it wraps one or more containers into an object called
    a **pod** and **schedules** it on an available worker node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Kubernetes 中运行应用程序时，例如 NGINX、Cassandra、Kafka、MongoDB 等，我们的容器引擎会从容器注册中心将容器镜像拉取到本地注册中心，然后将一个或多个容器封装成一个叫做**pod**的对象，并将其**调度**到可用的工作节点上。
- en: The container image (most of the time, this term is misused instead of *base
    image*) used in this process is a layered image consisting of the user application
    and the container base image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中使用的容器镜像（大多数时候，这个术语被误用为*基础镜像*）是一个分层镜像，包含了用户应用程序和容器基础镜像。
- en: The container base image contains the interchangeable user space components
    of the OS. The container image is packaged following the Docker image or **Open
    Container Initiative** (**OCI**) industry standards. This is where our options
    and challenges come in. Most container base images contain a root filesystem with
    the minimal user space applications of an OS distribution, some other external
    libraries, utilities, and files. Container images are typically used for software
    development and provide a functional application written in common programming
    languages. Programming languages, including both compiled and interpreted ones,
    depend on external drivers and libraries. These dependencies make the container
    base image selection critically important.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 容器基础镜像包含操作系统的可交换用户空间组件。容器镜像遵循 Docker 镜像或**开放容器倡议**（**OCI**）的行业标准进行打包。这就是我们面临的选择和挑战。大多数容器基础镜像包含具有操作系统分发版最小用户空间应用程序的根文件系统，以及其他一些外部库、实用工具和文件。容器镜像通常用于软件开发，并提供一个用常见编程语言编写的功能性应用程序。编程语言，包括编译型和解释型语言，依赖于外部驱动程序和库。这些依赖关系使得容器基础镜像的选择至关重要。
- en: Before we build our application or run an application based on an existing image
    in production, we need to understand the critical differences between the popular
    container base images. Now that you've learned what goes into container images,
    let's learn the differences between the common container base images and some
    of the best practices for choosing the right image type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建应用程序或在生产环境中运行基于现有镜像的应用程序之前，我们需要理解流行的容器基础镜像之间的关键区别。现在你已经了解了容器镜像的构成，让我们来学习常见的容器基础镜像之间的区别，以及选择正确镜像类型的一些最佳实践。
- en: Choosing the right container base image
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的容器基础镜像
- en: Choosing a container base image is not much different than choosing your container
    hosts' Linux distribution. Similar criteria such as security, performance, dependencies,
    core utilities, package managers, the size of its community and ecosystem, and
    the security response and support must be considered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选择容器基础镜像与选择容器主机的 Linux 发行版没有太大区别。需要考虑的类似标准包括安全性、性能、依赖性、核心实用工具、包管理器、社区和生态系统的规模，以及安全响应和支持等。
- en: 'I would like to highlight the five notable container image challenges that
    we will try to address in this chapter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我想重点介绍在本章中我们将尝试解决的五个显著的容器镜像挑战：
- en: '**Image size**: One of the important benefits of container images is portability.
    A smaller container image size reduces the build and rollout times since pulling
    the image itself will be faster. Smaller images are achieved by limiting extra
    binaries, which also bring a minimized attack surface and increased security benefits.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像大小**：容器镜像的一个重要优势是便携性。较小的容器镜像大小减少了构建和发布的时间，因为拉取镜像本身会更快。通过限制额外的二进制文件来实现更小的镜像，这也带来了最小化的攻击面和增强的安全性优势。'
- en: '**Stability**: Updating base images is not fun, but updating every container
    image is the worst. Container images that only include your application and its
    runtime dependencies, such as distroless images, may sound attractive. Still,
    when it comes to patching **Common Vulnerabilities and Exposures** (**CVEs**),
    you will need to update all your containers that can introduce stability issues.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定性**：更新基础镜像并不有趣，但更新每一个容器镜像则是最糟糕的。仅包含你的应用程序及其运行时依赖项的容器镜像，如 distroless 镜像，可能听起来很有吸引力。然而，在修补**常见漏洞和暴露**（**CVE**）时，你需要更新所有容器，这可能会引入稳定性问题。'
- en: Important note
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Distroless images are container images that don''t contain package managers
    or any other application. You can read more about distroless Docker images and
    watch a presentation here: [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless).'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Distroless 镜像是没有包管理器或任何其他应用程序的容器镜像。你可以在这里阅读更多关于 distroless Docker 镜像的内容并观看演讲：[https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)。
- en: '**Security**: Every binary that is added to our container images adds unpredictable
    risks to the overall platform security. When choosing base images, their update
    frequency, ecosystem and community size, and vulnerability tracking methods such
    as a CVE database and **Open Vulnerability and Assessment Language** (**OVAL**)
    data are important factors to consider. Check the properties of executables such
    as the **Position Independent Executable** (**PIE**), **Relocation Read-Only**
    (**RELRO**), **Patches for the Linux Kernel** (**PaX**), canaries, **Address Space
    Layout Randomization** (**ASLR**), FORTIFY_SOURCE, and the RPATH and RUNPATH runtime
    search paths.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**: 每添加到容器镜像中的二进制文件都会为整体平台安全性带来不可预测的风险。在选择基础镜像时，其更新频率、生态系统和社区规模以及漏洞跟踪方法（如
    CVE 数据库和 **开放漏洞评估语言** (**OVAL**) 数据）是需要考虑的重要因素。检查可执行文件的属性，如 **位置独立执行文件** (**PIE**)、**只读重定位**
    (**RELRO**)、**Linux 内核补丁** (**PaX**)、金丝雀、**地址空间布局随机化** (**ASLR**)、FORTIFY_SOURCE
    以及 RPATH 和 RUNPATH 运行时搜索路径。'
- en: Important note
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can find the Bash script to check the properties of the binary hardening
    tools at [https://github.com/slimm609/checksec.sh](https://github.com/slimm609/checksec.sh).
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到检查二进制硬化工具属性的 Bash 脚本：[https://github.com/slimm609/checksec.sh](https://github.com/slimm609/checksec.sh)。
- en: '**Speed/performance**: Popular container base images may not always be the
    fastest. Although Alpine is famous for its size and is recommended in some cases,
    it may cause serious build performance issues. Alpine might be acceptable if you
    are using the Go language. If you are using Python instead, you will quickly notice
    that Alpine images will sometimes get two to three times larger, are more than
    10 times slower to build, and might even cause build problems.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度/性能**: 流行的容器基础镜像不一定是最快的。虽然 Alpine 以其小巧著称，并且在某些情况下推荐使用，但它可能会导致严重的构建性能问题。如果你使用
    Go 语言，Alpine 可能是可以接受的。然而，如果使用 Python，你会很快注意到 Alpine 镜像有时会变得大两到三倍，构建速度比普通镜像慢 10
    倍以上，甚至可能导致构建问题。'
- en: Important note
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find the Kubernetes-related performance test tools here: [https://github.com/kubernetes/perf-tests](https://github.com/kubernetes/perf-tests).'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到与 Kubernetes 相关的性能测试工具：[https://github.com/kubernetes/perf-tests](https://github.com/kubernetes/perf-tests)。
- en: '`glibc`, Alpine includes `muslc` and can show implementation differences. Also,
    utilities included in the image for troubleshooting and support need to be considered.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glibc`，Alpine 包含 `muslc` 并可以显示实现差异。此外，镜像中包含的故障排除和支持工具也需要考虑。'
- en: 'The following are some of the common container base image options compared
    by their size, security, and support options:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见容器基础镜像选项，按其大小、安全性和支持选项进行比较：
- en: '`busybox` with a package manager. `glibc`/`musl` library differences are known
    to cause problems and performance issues that are hard to track down:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有包管理器的 `busybox`。已知 `glibc`/`musl` 库的差异会引起难以追踪的问题和性能问题：
- en: '- **Size**: 2.6 MB.'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **大小**: 2.6 MB。'
- en: '- **Security**: Community-updated; Alpine Linux bug tracker available at [https://bugs.alpinelinux.org/projects/alpine/issues](https://bugs.alpinelinux.org/projects/alpine/issues).'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **安全性**: 社区更新；Alpine Linux 错误跟踪器可以在 [https://bugs.alpinelinux.org/projects/alpine/issues](https://bugs.alpinelinux.org/projects/alpine/issues)
    访问。'
- en: '- **Support**: Support via community. 386, AMD64, ARMv6, ARMv7, ARM64v8, ppc64le,
    and S390x architectures supported.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **支持**: 通过社区提供支持。支持 386、AMD64、ARMv6、ARMv7、ARM64v8、ppc64le 和 S390x 架构。'
- en: '**Amazon Linux 2 (amazonlinux:2)**: A Linux image maintained by **Amazon Web
    Services** (**AWS**) to be used on Amazon EC2 instances. It is binary-compatible
    with RHEL and CentOS:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Linux 2 (amazonlinux:2)**: 由 **亚马逊 Web 服务** (**AWS**) 维护的 Linux 镜像，用于在
    Amazon EC2 实例上使用。与 RHEL 和 CentOS 二进制兼容：'
- en: '- **Size**: 59.14 MB.'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **大小**: 59.14 MB。'
- en: '- **Security**: Vendor-updated; Amazon Linux Security Center available at [https://alas.aws.amazon.com/alas2.html](https://alas.aws.amazon.com/alas2.html).'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **安全性**: 厂商更新；Amazon Linux 安全中心可以在 [https://alas.aws.amazon.com/alas2.html](https://alas.aws.amazon.com/alas2.html)
    访问。'
- en: '- **Support**: LTS support included with AWS EC2; AMD64 and ARM64v8 architectures
    supported.'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **支持**: 包括 AWS EC2 的 LTS 支持；支持 AMD64 和 ARM64v8 架构。'
- en: '**CentOS (centos:8)**: Community-driven container base image of the popular
    Linux distribution. Due to the rollout of CentOS Stream, its future is unknown.
    At this point, it is better to wait for the replacement Rocky Linux base images
    or use Amazon Linux 2:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CentOS (centos:8)**: 由社区驱动的流行 Linux 发行版的容器基础镜像。由于 CentOS Stream 的推出，其未来尚不明确。目前，最好等待替代的
    Rocky Linux 基础镜像，或使用 Amazon Linux 2：'
- en: '- **Size**: 71.7 MB.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **大小**: 71.7 MB。'
- en: '- **Security**: Community-updated; CentOS security alerts can be found here:
    [https://lwn.net/Alerts/CentOS/](https://lwn.net/Alerts/CentOS/).'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **安全性**：由社区更新；可以在这里找到CentOS的安全警报：[https://lwn.net/Alerts/CentOS/](https://lwn.net/Alerts/CentOS/)。'
- en: '- **Support**: Support via community only. AMD64, ARM64v8, and ppc64le architectures
    supported.'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **支持**：仅通过社区提供支持。支持AMD64、ARM64v8和ppc64le架构。'
- en: '`libc`) included in Debian images:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libc`）包含在Debian镜像中：'
- en: '- **Size**: 26.47 MB'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **大小**：26.47 MB'
- en: '- **Security**: Community-updated; Security Bug Tracker ([https://security-tracker.debian.org/tracker/](https://security-tracker.debian.org/tracker/))
    and OVAL at [https://www.debian.org/security/oval/](https://www.debian.org/security/oval/)'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **安全性**：由社区更新；安全漏洞跟踪器([https://security-tracker.debian.org/tracker/](https://security-tracker.debian.org/tracker/))和OVAL数据在[https://www.debian.org/security/oval/](https://www.debian.org/security/oval/)。'
- en: '- **Support**: Support via community only. 386, AMD64, and ARM64v5 architectures
    supported'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **支持**：仅通过社区提供支持。支持386、AMD64和ARM64v5架构。'
- en: '**Ubuntu (ubuntu:21.04)**: A Debian-based larger community and enterprise-supported
    Linux distribution base image:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ubuntu (ubuntu:21.04)**：基于Debian的大型社区和企业支持的Linux发行版基础镜像：'
- en: '- **Size**: 29.94 MB'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **大小**：29.94 MB'
- en: '- **Security**: Ubuntu CVE Tracker at [https://people.canonical.com/~ubuntu-security/cve/](https://people.canonical.com/~ubuntu-security/cve/)
    and cloud image bug tracker at [https://bugs.launchpad.net/cloud-images](https://bugs.launchpad.net/cloud-images)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **安全性**：Ubuntu CVE跟踪器在[https://people.canonical.com/~ubuntu-security/cve/](https://people.canonical.com/~ubuntu-security/cve/)和云镜像错误跟踪器在[https://bugs.launchpad.net/cloud-images](https://bugs.launchpad.net/cloud-images)。'
- en: '- **Support**: Community and commercial support. AMD64, ARMv7, and ARM64v8
    architectures supported'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **支持**：社区和商业支持。支持AMD64、ARMv7和ARM64v8架构。'
- en: '`microdnf` as a package manager. It is preferred when running applications
    on the `ubi-minimal`), standard (`ubi`), and multi-service (`ubi-init`), for different
    use cases:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microdnf`作为包管理器。它在运行`ubi-minimal`）、标准(`ubi`）和多服务(`ubi-init`)时被首选，用于不同的使用场景：'
- en: '- **Size**: 37.6 MB.'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **大小**：37.6 MB。'
- en: '- **Security**: The best container base image in terms of completeness of vulnerability
    checks. Errata provided at [https://access.redhat.com/errata](https://access.redhat.com/errata)
    and OVAL data provided at [https://www.redhat.com/security/data/oval/](https://www.redhat.com/security/data/oval/).'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **安全性**：在漏洞检查的完整性方面，是最好的容器基础镜像。在[https://access.redhat.com/errata](https://access.redhat.com/errata)提供Errata，并在[https://www.redhat.com/security/data/oval/](https://www.redhat.com/security/data/oval/)提供OVAL数据。'
- en: '- **Support**: Community and commercial support. AMD64, ARM64v8, ppc64le, and
    S390x architectures supported.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **支持**：社区和商业支持。支持AMD64、ARM64v8、ppc64le和S390x架构。'
- en: '**Distroless (gcr.io/distroless/base-debian10)**: Builds on the Debian distribution
    by Google. They don''t contain package managers or shells. Preferred for security
    and size. Additional builds can be found at [https://console.cloud.google.com/gcr/images/distroless/GLOBAL](https://console.cloud.google.com/gcr/images/distroless/GLOBAL):'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Distroless (gcr.io/distroless/base-debian10)**：由Google在Debian发行版基础上构建。它们不包含包管理器或shell。因其安全性和小巧性而受青睐。更多构建可以在[https://console.cloud.google.com/gcr/images/distroless/GLOBAL](https://console.cloud.google.com/gcr/images/distroless/GLOBAL)找到：'
- en: '- **Size**: 75.1 MB'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **大小**：75.1 MB'
- en: '- **Security**: Avoids image vulnerabilities, but introduces another challenge
    where dependent library updates need to be carefully tracked for every container
    image'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **安全性**：避免了镜像的漏洞，但引入了另一个挑战，即每个容器镜像的依赖库更新需要仔细跟踪。'
- en: '- **Support**: Support via community only. AMD64, ARM, ARM64, ppc64le, and
    S390x architectures supported'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **支持**：仅通过社区提供支持。支持AMD64、ARM、ARM64、ppc64le和S390x架构。'
- en: Now you have learned about the challenges we deal with when choosing the right
    container base image and how the most common popular base images compare. Let's
    find out some of the best practices for reducing your final image size and scanning
    your container images for vulnerabilities.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了选择正确的容器基础镜像时所面临的挑战，以及最常见的流行基础镜像的对比。接下来，让我们探讨一些减少最终镜像大小和扫描容器镜像漏洞的最佳实践。
- en: Reducing container image size
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少容器镜像大小
- en: An excellent way to achieve smaller container images would be by starting with
    small base images such as Alpine, `ubi-minimal`, or distroless base images.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实现更小容器镜像的一个优秀方法是从小型基础镜像开始，如Alpine、`ubi-minimal`或distroless基础镜像。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For reproducible builds and deployment, you can also use the Nix package manager
    and create slim builds. There is a lot of enthusiasm around Nix, but since there
    is a steep learning curve and custom expression language is involved, we will
    not discuss Nix in this book. You can learn about building container images using
    Nix here at the official NixOS documentation page: [https://nixos.org/guides/building-and-running-docker-images.html](https://nixos.org/guides/building-and-running-docker-images.html).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现可复现的构建和部署，你还可以使用 Nix 包管理器来创建精简的构建。Nix 受到很多热情的关注，但由于其陡峭的学习曲线和自定义表达语言的使用，我们在本书中不会讨论
    Nix。你可以在官方 NixOS 文档页面了解关于使用 Nix 构建容器镜像的内容：[https://nixos.org/guides/building-and-running-docker-images.html](https://nixos.org/guides/building-and-running-docker-images.html)。
- en: 'Excluding some of the unnecessary files, using a `.dockerignore` file can help
    us to reduce our image size. Here is an example of a `.dockerignore` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 排除一些不必要的文件，使用 `.dockerignore` 文件可以帮助我们减少镜像的大小。以下是一个 `.dockerignore` 文件的示例：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Size-optimized images can be achieved by utilizing multistage builds and avoiding
    extra layers. Multistage builds add a couple of new syntaxes and allow us to use
    a `FROM` section in our Dockerfile multiple times to start a new stage of the
    build and copy only the artifacts we want to take from previous stages. You can
    learn more about the multistage build on the official Docker documentation website
    at [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用多阶段构建并避免额外的层，可以实现优化大小的镜像。多阶段构建增加了一些新的语法，允许我们在 Dockerfile 中多次使用`FROM`部分来启动构建的新阶段，并且只复制我们希望从之前阶段获取的工件。你可以在官方
    Docker 文档网站上了解更多关于多阶段构建的信息：[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)。
- en: 'Here is an example of a Dockerfile with two stages:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含两个阶段的 Dockerfile 示例：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our preceding example, the first stage, `base`, starts with the `node:14.15`
    Node.js base image. We copy our application code to the `/app` directory and execute
    the `npm install` command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，第一个阶段 `base` 使用 `node:14.15` 的 Node.js 基础镜像。我们将应用程序代码复制到 `/app` 目录并执行
    `npm install` 命令。
- en: We move to the second stage, called `stage2`, this time using a `distroless/nodejs`
    base image. Then, we copy our application code and our `node_modules` from the
    first stage using the `COPY --from=base /app /app` syntax. This way, we are reducing
    our container image size as well as the attack surface since distroless images
    do not contain `bash` or other tools that can be maliciously executed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们进入第二阶段，称为 `stage2`，这次使用 `distroless/nodejs` 基础镜像。然后，我们使用 `COPY --from=base
    /app /app` 语法从第一个阶段复制应用程序代码和 `node_modules`。通过这种方式，我们既减少了容器镜像的大小，又减少了攻击面，因为 distroless
    镜像不包含 `bash` 或其他可能被恶意执行的工具。
- en: You can read about the best practices for writing Dockerfiles at [https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)阅读编写
    Dockerfile 的最佳实践。
- en: Now we have learned a few techniques for reducing our container image size.
    Let's look at how we can proactively scan our images against security vulnerabilities
    and patch them in a timely manner before running them in production.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了一些减少容器镜像大小的技巧。接下来，看看我们如何主动扫描镜像中的安全漏洞，并在将其投入生产环境之前及时修复。
- en: Scanning container images for vulnerabilities
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描容器镜像中的漏洞
- en: We've built our container images or pulled some of the vendor-provided images
    to our local registry and now we are ready to run in our production environment.
    How do we know they are safe to run? How do we know they have the latest security
    vulnerabilities patched? Most **Continuous Integration and** **Continuous Delivery**
    (**CI/CD**) solutions today have additional security scanning tools. It is one
    of the golden rules not to roll out any service into production before going through
    a quick image validation during our pipeline. For this purpose, we will now learn
    about a popular open source solution called **Trivy**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了容器镜像或从供应商提供的镜像中拉取了一些到本地注册表，现在我们准备在生产环境中运行它们。我们如何知道它们是安全的？我们如何知道它们已经修补了最新的安全漏洞？如今，大多数**持续集成（CI）**和**持续交付（CD）**解决方案都配有额外的安全扫描工具。一个黄金法则是在将任何服务投入生产之前，一定要通过管道中的快速镜像验证。为此，我们将学习一个流行的开源解决方案，叫做**Trivy**。
- en: Trivy is a comprehensive vulnerability scanner for container images. Trivy is
    capable of detecting vulnerabilities in most images based on popular base images,
    including Alpine, CentOS, and Red Hat UBI, and application package dependencies
    such as `npm`, `yarn`, `bundler`, and `composer`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Trivy 是一个全面的容器镜像漏洞扫描工具。Trivy 能够检测大多数基于流行基础镜像的漏洞，包括 Alpine、CentOS 和 Red Hat UBI，以及如
    `npm`、`yarn`、`bundler` 和 `composer` 等应用程序包的依赖关系。
- en: 'Here, we will manually install the `trivy` binaries and run a vulnerability
    analysis:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将手动安装 `trivy` 二进制文件并进行漏洞分析：
- en: 'Let''s get the latest release version tag of `trivy` and keep it in a variable
    called `TRIVYVERSION`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取 `trivy` 的最新版本标签，并将其保存在名为 `TRIVYVERSION` 的变量中：
- en: '[PRE2]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, download the latest `trivy` binary and install it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，下载最新的 `trivy` 二进制文件并进行安装：
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Confirm that the installation is successfully completed by executing the following
    command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令确认安装已成功完成：
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run `trivy` checks with a target image location and its tag. In our example,
    we scanned the `alpine:3.12` base image from its official Docker Hub repository:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `trivy` 检查时，需要指定目标镜像位置及其标签。在我们的示例中，我们扫描了来自官方 Docker Hub 仓库的 `alpine:3.12`
    基础镜像：
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding command should look as follows since no issues
    are found in the particular container image:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于在特定容器镜像中未发现任何问题，前述命令的输出应如下所示：
- en: '![Figure 8.3 – Trivy results of a container image with no known vulnerabilities'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.3 – 没有已知漏洞的容器镜像的 Trivy 扫描结果'
- en: '](img/B16192_08_003.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16192_08_003.jpg)'
- en: Figure 8.3 – Trivy results of a container image with no known vulnerabilities
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.3 – 没有已知漏洞的容器镜像的 Trivy 扫描结果
- en: 'Now, let''s scan a publicly available version of the popular MongoDB database
    container image. MongoDB is used by many modern cloud-native applications and
    services:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们扫描一个公开的流行 MongoDB 数据库容器镜像。MongoDB 被许多现代云原生应用和服务使用：
- en: '[PRE6]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will notice that Trivy returned `93` known vulnerabilities, including `2`
    high and `28` medium severity issues:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到，Trivy 返回了`93`个已知漏洞，其中包括`2`个高危和`28`个中危问题：
- en: '![Figure 8.4 – Trivy results showing vulnerabilities'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 显示漏洞的 Trivy 扫描结果'
- en: '](img/B16192_08_004.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16192_08_004.jpg)'
- en: Figure 8.4 – Trivy results showing vulnerabilities
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 显示漏洞的 Trivy 扫描结果
- en: In the long analysis returned by the Trivy scanner, you can find vulnerability
    IDs and severity URLs to learn more about the issues. You can also see that some
    issues come from the Ubuntu 18.04 base image used in the container image and can
    be resolved by just updating the base image of the container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Trivy 扫描器返回的详细分析中，你可以找到漏洞 ID 和严重性 URL，以便了解更多问题。你还可以看到一些问题源自容器镜像中使用的 Ubuntu
    18.04 基础镜像，并且可以通过仅更新容器的基础镜像来解决。
- en: Trivy supports most CI tools, including Travis CI, CircleCI, Jenkins, and GitLab
    CI. To learn more about Trivy and integration details, you can read the official
    documentation at [https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Trivy 支持大多数 CI 工具，包括 Travis CI、CircleCI、Jenkins 和 GitLab CI。如需了解更多关于 Trivy 及其集成的详细信息，可以阅读官方文档：[https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy)。
- en: Now we have learned how to test container images against known vulnerabilities.
    It is highly recommended to have test conditions in your build pipelines. Let's
    look into how we can test the impact of container image downloads from public
    repositories.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何测试容器镜像中的已知漏洞。强烈建议在构建流水线中设置测试条件。接下来，让我们看看如何测试从公共仓库下载容器镜像的影响。
- en: Testing the download speed of a container image
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试容器镜像的下载速度
- en: CI is a key component of automation, and the reduction of every second spent
    in the pipeline execution will be important. Download time also impacts the speed
    of the new container image rollout to the production environment. Therefore, we
    need to consider the download speeds of the container images used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是自动化的关键组成部分，减少流水线执行中的每一秒都至关重要。下载时间也会影响新容器镜像推送到生产环境的速度。因此，我们需要考虑所使用容器镜像的下载速度。
- en: 'Here, we will use the `time` command in Linux to execute `docker run` in a
    specified container base image and compare the summary of the real-time user CPU
    time and system CPU time spent during the process:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 Linux 中的 `time` 命令执行 `docker run`，并在指定的容器基础镜像中比较该过程中实际用户 CPU 时间和系统
    CPU 时间的总结：
- en: 'Install the `curl` utility in the `debian:buster-slim` Debian base image:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `debian:buster-slim` Debian 基础镜像中安装 `curl` 工具：
- en: '[PRE7]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For comparison, let''s now run the same command in the `alpine:3.12` image:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行比较时，现在线我们在`alpine:3.12`镜像中运行相同的命令：
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that both images were not available in the local registry and were pulled
    for the first time from the public Docker Hub location. As you can see, the Alpine
    image completed the task in close to 2 seconds, whereas the same request took
    more than 40 seconds longer to finish using the Debian image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个镜像在本地注册表中都不可用，首次从公共 Docker Hub 拉取。正如你所见，Alpine 镜像几乎在 2 秒内完成任务，而相同的请求使用
    Debian 镜像时则多花了超过 40 秒的时间才完成。
- en: Now we have learned about measuring the command execution speed in containers
    based on different base images. Let's summarize everything we have learned in
    this section into a short list of simple container image best practices.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基于不同基础镜像测量容器中命令执行速度的情况。让我们将本节所学的所有内容总结为一个简短的容器镜像最佳实践清单。
- en: Applying container base images best practices
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用容器基础镜像最佳实践
- en: 'Technically, most applications will run in containers layered on top of all
    the common and popular container base images. This may be acceptable for development
    and test purposes, but before rolling out any container images into production,
    there are a few common-sense best practices we should consider:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，大多数应用程序将运行在所有常见且流行的容器基础镜像之上的容器中。这可能适用于开发和测试目的，但在将任何容器镜像推向生产环境之前，我们应该考虑一些常识性的最佳实践：
- en: The size of the container image is important as long as the container base image
    does not introduce a performance tax and vulnerabilities. Using a stable, compatible,
    and supported base image is preferred over saving a few megabytes.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像的大小很重要，只要容器基础镜像不会引入性能损失和漏洞。相比节省几兆字节，使用稳定、兼容和支持的基础镜像是更优的选择。
- en: Never use the `latest` tag to pull base images when building your container
    images.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建容器镜像时，切勿使用`latest`标签来拉取基础镜像。
- en: Make sure to use container images with the exact tested and validated version
    of the image. You can also specify its digest by replacing `<image-name>:<tag>`
    with `<image-name>@<digest>` to generate stable reproducible builds.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用经过测试和验证的容器镜像的确切版本。你也可以通过将`<image-name>:<tag>`替换为`<image-name>@<digest>`来指定其摘要，从而生成稳定且可重复的构建。
- en: Check `imagePullPolicy` in your application manifests. Unless required otherwise,
    it is suggested to use `IfNotPresent`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序清单中的`imagePullPolicy`。除非另有要求，建议使用`IfNotPresent`。
- en: When possible, use the same base OS in your container host and container images.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量在容器主机和容器镜像中使用相同的基础操作系统。
- en: Integrate image vulnerability scanners into your CI pipelines and make sure
    to clear at least high and critical severity vulnerabilities before rolling your
    images into production.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像漏洞扫描工具集成到 CI 流水线中，确保在将镜像部署到生产环境之前，清除至少高危和严重漏洞。
- en: Monitor container image size changes over time and notify maintainers of sudden
    large size changes.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控容器镜像大小随时间的变化，并在发现突发的大幅度变化时通知维护人员。
- en: When using public container registries, store your container images in multiple
    registries. Some public registries include Docker Hub, GitLab Container Registry,
    Red Hat Quay, Amazon ECR, Azure Container Registry, and Google Cloud Container
    Registry.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公共容器注册表时，建议将容器镜像存储在多个注册表中。一些公共注册表包括 Docker Hub、GitLab Container Registry、Red
    Hat Quay、Amazon ECR、Azure Container Registry 和 Google Cloud Container Registry。
- en: For increased security, use a private container registry and monitor public
    container registry pulls into the production environment.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高安全性，使用私有容器注册表，并监控公共容器注册表拉取到生产环境的情况。
- en: Now we have learned about the challenges of choosing container images and production
    best practices. Let's look at different deployment strategies and their use cases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了选择容器镜像和生产最佳实践的挑战。接下来，我们将看看不同的部署策略及其应用场景。
- en: Learning application deployment strategies
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习应用程序部署策略
- en: Organizations without the expertise to design an application deployment strategy
    before getting their services to production users can face great operational complexity
    when managing their application life cycle. Many users still face container and
    microservices adoption issues later in their digital transformation journey and
    end up going back to the more expensive **Database as a Service** (**DbaaS**)
    model or even using traditional deployment methods in VMs. To avoid common mistakes
    and production anti-patterns, we need to be aware of some of the common strategies
    that will ensure our success in deploying and managing applications on Kubernetes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 没有应用程序部署策略设计专业知识的组织，在将其服务投入生产用户之前，可能会在管理应用生命周期时面临巨大的操作复杂性。许多用户在数字化转型过程中仍然面临容器和微服务采用问题，最终不得不回退到更昂贵的**数据库即服务**（**DbaaS**）模型，甚至使用传统的虚拟机部署方法。为了避免常见的错误和生产中的反模式，我们需要意识到一些常见的策略，这些策略将确保我们在
    Kubernetes 上成功部署和管理应用程序。
- en: We learned about the differences between different Kubernetes controllers such
    as Deployments, ReplicaSets, and StatefulSets in the *Deploying stateful applications*
    section in [*Chapter 7*](B16192_07_Final_PG_ePub.xhtml#_idTextAnchor157), *Managing
    Storage and Stateful Applications*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 7 章*](B16192_07_Final_PG_ePub.xhtml#_idTextAnchor157)中的*部署有状态应用程序*部分学习了不同
    Kubernetes 控制器之间的区别，如 Deployments、ReplicaSets 和 StatefulSets，*管理存储和有状态应用程序*。
- en: 'In this section, we will learn about the following containerized application
    deployment best practices:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习以下容器化应用部署最佳实践：
- en: Choosing the deployment model
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择部署模型
- en: Monitoring deployments
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控部署
- en: Using readiness and liveness probes
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用就绪探针和存活探针
- en: Let's discuss each of them in the following sections.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分中讨论每个策略。
- en: Choosing the deployment model
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择部署模型
- en: 'In Kubernetes, applications can be rolled out following various deployment
    procedures. Choosing the right strategy is not always easy since it really depends
    on your services and how your applications are accessed by users. Now, we will
    review the most common models:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，应用程序可以按照不同的部署流程进行发布。选择正确的策略并不总是容易的，因为它实际上取决于你的服务以及应用程序如何被用户访问。现在，我们将回顾最常见的模型：
- en: A/B testing
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A/B 测试
- en: Blue/green
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: Canary release
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: Clean deployment
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁部署
- en: Incremental deployment
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量部署
- en: Let's learn about the advantages of each of them in the following sections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分中了解每种方法的优点。
- en: A/B testing
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A/B 测试
- en: A/B testing deployments allow routing groups of users to a new deployment based
    on conditions such as HTTP headers, location, browser cookies, or other user metadata.
    A/B testing deployments are preferred when a specific feature of the application
    needs to be tested on a certain group of users and rollout needs to continue based
    on the conversation rate. Price and UX testing are also done using A/B testing.
    Other than the complexity of the parameters that need to be managed, it is the
    most flexible model with low cloud cost, minimum impact on users, and quick rollback
    times.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: A/B 测试部署允许根据 HTTP 头、位置、浏览器 Cookie 或其他用户元数据等条件将一组用户路由到新的部署。A/B 测试部署适用于需要在特定用户群体中测试应用程序的某个功能，并且根据转化率继续推广的情况。价格和用户体验测试也使用
    A/B 测试。除了需要管理的参数的复杂性外，这是最灵活的模型，具有低云成本、对用户的最小影响和快速回滚时间。
- en: Blue/green
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: In the blue/green deployment model, an equal amount of instances of each application
    is deployed on your cluster. This model can be executed either by traffic switching
    or by traffic mirroring when a service mesh such as Istio is used. It is preferred
    when service changes need to be tested for load and compliance with no impact
    on actual users. When the metrics return successful data, a new deployment (green)
    gets promoted. This model cannot be used to target a specific group of users and
    can be expensive in terms of cloud resource consumption cost due to its full deployment
    model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝绿部署模型中，集群中每个应用程序的实例数量相等。该模型可以通过流量切换或当使用像 Istio 这样的服务网格时通过流量镜像来执行。它适用于在没有实际用户影响的情况下测试服务变更的负载和合规性。当指标返回成功数据时，新部署（绿色）将被推广。该模型不能用于针对特定用户群体，并且由于其完全部署模型，在云资源消耗方面可能会很昂贵。
- en: Canary release
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: Canary deployments gradually shift traffic from one deployment to another based
    on percentage, sometimes triggered by metrics such as success rate or health.
    Canary releases are preferred when confidence in the new releases is not high
    or when deploying releases on a completely new platform. Groups of users cannot
    be targeted. This method doesn't increase public cloud costs and rollback times
    can be rather quick.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀部署基于百分比逐渐将流量从一个部署切换到另一个部署，有时会根据成功率或健康状况等指标触发。当对新版本的信心不高或在完全新平台上部署版本时，金丝雀发布是首选。无法针对特定用户组进行部署。此方法不会增加公共云成本，并且回滚时间可能非常快。
- en: Clean deployment
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清洁部署
- en: In this method, one version of the application is destroyed and a new version
    is deployed. It is preferred in deployment since it is the simplest method, although
    this method should not be used in production unless the service is not in use.
    If the deployment fails compared to the other methods, the rollback time would
    be the highest, and the service downtime would be the longest.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，一个版本的应用程序被销毁，新的版本被部署。由于这是最简单的方法，因此在部署时首选此方法，尽管除非服务未使用，否则不应在生产环境中使用。如果部署失败，相比其他方法，回滚时间将是最高的，服务停机时间也将是最长的。
- en: Incremental deployment
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量部署
- en: In this method, a new version of the application is deployed in a rolling update
    fashion and slowly migrated. The only advantage of this model compared to a clean
    deployment is that incremental deployment does not introduce downtime.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，应用程序的新版本以滚动更新的方式部署并逐步迁移。与全新部署相比，这种模型唯一的优点是增量部署不会引入停机时间。
- en: Some of the methods can only be implemented with the help of **service mesh**
    solutions, such as Istio, Linkerd, or AWS App Mesh, and ingress controllers, including
    Contour, Gloo, NGINX, or Traefik.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法只能通过 **服务网格** 解决方案来实现，例如 Istio、Linkerd 或 AWS App Mesh，以及包括 Contour、Gloo、NGINX
    或 Traefik 在内的入口控制器。
- en: Orchestration of multiple deployment strategies can turn into a complex configuration
    puzzle. In this case, the usage of an application delivery operator can be very
    useful. **Flagger** is one of the most complete progressive delivery Kubernetes
    operators in the Kubernetes ecosystem. Flagger can automate complex rollover scenarios
    using Istio, Linkerd, App Mesh, NGINX, Skipper, Contour, Gloo, or Traefik based
    on the metrics analysis from the metrics collected by Prometheus. To learn more
    about Flagger operators and a tutorial covering the models discussed here, you
    can read the official documentation at [https://docs.flagger.app/](https://docs.flagger.app/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 多种部署策略的编排可能变成一个复杂的配置难题。在这种情况下，应用程序交付操作符的使用会非常有帮助。**Flagger** 是 Kubernetes 生态系统中最完整的渐进交付
    Kubernetes 操作符之一。Flagger 可以使用 Istio、Linkerd、App Mesh、NGINX、Skipper、Contour、Gloo
    或 Traefik 基于 Prometheus 收集的指标分析自动化复杂的滚动场景。要了解更多有关 Flagger 操作符以及涵盖这里讨论的模型的教程，你可以阅读官方文档，网址是
    [https://docs.flagger.app/](https://docs.flagger.app/)。
- en: Monitoring deployments
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控部署
- en: Smooth, production-ready application deployment and canary analysis cannot be
    achieved without monitoring the application usage metrics. We can monitor our
    applications using tools such as Prometheus, Datadog, or Splunk.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 平稳、生产就绪的应用程序部署和金丝雀分析无法在没有监控应用程序使用指标的情况下实现。我们可以使用诸如 Prometheus、Datadog 或 Splunk
    等工具来监控我们的应用程序。
- en: We will cover monitoring, visualizations, logging, tracing solutions, and how
    to make visualization dashboards relevant to serve our production needs in [*Chapter
    9*](B16192_09_Final_PG_ePub.xhtml#_idTextAnchor200), *Monitoring, Logging, and
    Observability*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B16192_09_Final_PG_ePub.xhtml#_idTextAnchor200)《监控、日志记录与可观测性》中介绍监控、可视化、日志记录、追踪解决方案，以及如何制作与生产需求相关的可视化仪表板。
- en: Using readiness and liveness container probes
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用就绪性和存活性容器探针
- en: When a new pod is scheduled in our Kubernetes cluster, its phase is represented
    by the `PodStatus` object. These phases reported as `Pending`, `Running`, `Succeeded`,
    `Failed`, or `Unknown` do not represent or guarantee our application's intended
    function. You can read more about the pod life cycle and its phases on the official
    Kubernetes documentation site at [https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的 Pod 在我们的 Kubernetes 集群中被调度时，其阶段由 `PodStatus` 对象表示。这些阶段报告为 `Pending`、`Running`、`Succeeded`、`Failed`
    或 `Unknown`，它们并不代表或保证我们的应用程序的预期功能。你可以在 Kubernetes 官方文档网站上阅读有关 Pod 生命周期及其各阶段的更多信息，网址是
    [https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/)。
- en: 'To monitor our application''s real health status inside the container, a regular
    diagnostic task can be executed. These diagnostic tests performed periodically
    are called `kubelet` can perform three types of container probes, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控容器内应用程序的真实健康状态，可以执行定期的诊断任务。这些周期性执行的诊断测试被称为 `kubelet`，可以执行三种类型的容器探针，具体如下：
- en: '`livenessProbe`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`livenessProbe`'
- en: '`readinessProbe`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readinessProbe`'
- en: '`startupProbe`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startupProbe`'
- en: It is highly recommended to use at minimum the readiness and liveness probes
    to control your application's health when starting and periodically after it is
    scheduled in your Kubernetes cluster. When enabled, `kubelet` can call three different
    handlers, `ExecAction`, `TCPSocketAction`, and `HTTPGetAction`, inside or against
    the pod's IP and validate your application's health.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议至少使用就绪探针和存活探针，在 Kubernetes 集群中调度应用程序时，控制应用程序的健康状况，并定期检查其状态。当启用时，`kubelet`
    可以调用三种不同的处理程序，`ExecAction`、`TCPSocketAction` 和 `HTTPGetAction`，以验证应用程序的健康状态。
- en: Important note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/probes/liveness/busybox.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/probes/liveness/busybox.yaml).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/probes/liveness/busybox.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/probes/liveness/busybox.yaml)
    找到完整的源代码。
- en: In the next code snippet, we will create a `busybox` pod example that will use
    `livenessProbe` to execute a command inside the container image to check our pod's
    liveness.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码片段中，我们将创建一个使用 `livenessProbe` 的 `busybox` Pod 示例，以执行容器镜像中的命令来检查 Pod 的存活状态。
- en: 'Create the template for the `busybox` pod in this `probes/liveness/busybox.yaml`
    path:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `probes/liveness/busybox.yaml` 路径下创建 `busybox` Pod 的模板：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the container starts, it executes the command specified under the `args`
    section. This command first creates a file under `/tmp/alive`, and then waits
    30 seconds and removes it. `livenessProbe`, as specified in the same file, first
    waits 10 seconds, as defined by the `initialDelaySeconds` parameter, and then
    periodically, every 10 seconds, as defined by the `periodSeconds` parameter, executes
    the `cat` `/tmp/alive` command. In the first 30 seconds, our command will be successful
    and once the file is removed, `livenessProbe` will fail, and our pod will be restarted
    for losing its liveness state. Make sure you allow enough time for the pod to
    start by setting a reasonable `initialDelaySeconds` value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，它会执行 `args` 部分指定的命令。该命令首先在 `/tmp/alive` 下创建一个文件，然后等待 30 秒并将其删除。`livenessProbe`
    如同在同一文件中指定的那样，首先等待 10 秒（由 `initialDelaySeconds` 参数定义），然后每 10 秒（由 `periodSeconds`
    参数定义）定期执行 `cat /tmp/alive` 命令。在前 30 秒，命令将成功执行；一旦文件被删除，`livenessProbe` 将失败，Pod
    将因丧失存活状态而被重启。确保通过设置合理的 `initialDelaySeconds` 值来为 Pod 启动留出足够的时间。
- en: Similarly, we can add `readinessProbe` by replacing the `livenessProbe` field
    with `readinessProbe`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过将 `livenessProbe` 字段替换为 `readinessProbe` 来添加 `readinessProbe`。
- en: Now we have learned about the production deployment best practices on Kubernetes.
    We have also learned about common deployment strategies for rolling production
    applications and using container probes for verifying the health of our application.
    Next, we will learn how to scale our applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了 Kubernetes 上生产部署的最佳实践，也了解了滚动生产应用程序的常见部署策略，以及如何使用容器探针验证应用程序的健康状况。接下来，我们将学习如何扩展应用程序。
- en: Scaling applications and achieving higher availability
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序并实现更高的可用性
- en: The Kubernetes container orchestration platform provides a wide range of functionality
    to help us deploy our applications in a scalable and highly available way. When
    designing architecture that will support horizontally scalable services and applications,
    we need to be aware of some common strategies that will help to successfully scale
    our applications on Kubernetes clusters.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 容器编排平台提供了广泛的功能，帮助我们以可扩展和高可用的方式部署应用程序。在设计支持水平扩展服务和应用程序的架构时，我们需要了解一些常见的策略，这些策略有助于我们在
    Kubernetes 集群上成功地扩展应用程序。
- en: In the previous section, *Learning application deployment strategies*, we covered
    some strategies that would help us to scale our applications, including deployment
    strategies and implementing health checks using container probes. In this section,
    we will learn about scaling applications using the **Horizontal Pod Autoscaler**
    (**HPA**).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，*学习应用程序部署策略*，我们介绍了一些有助于扩展应用程序的策略，包括部署策略和通过容器探针实现健康检查。在本节中，我们将学习如何使用**水平
    Pod 自动缩放器**（**HPA**）来扩展应用程序。
- en: When we first deploy our application on Kubernetes clusters, applications will
    very likely not get accessed immediately and usage will gradually increase over
    time. In that case, rolling out a deployment with many replicas would result in
    wasting our infrastructure resources. HPA in Kubernetes helps us increase the
    necessary resources in different scenarios.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次在 Kubernetes 集群上部署应用程序时，应用程序很可能不会立即被访问，使用量会随着时间的推移逐渐增加。在这种情况下，推出多个副本的部署会浪费我们的基础设施资源。Kubernetes
    中的 HPA（水平 Pod 自动缩放）帮助我们在不同场景下增加必要的资源。
- en: Important note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: You can find the complete source code at [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/hpa/deployment-nginx.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/hpa/deployment-nginx.yaml).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/hpa/deployment-nginx.yaml](https://github.com/PacktPublishing/Kubernetes-in-Production-Best-Practices/blob/master/Chapter08/hpa/deployment-nginx.yaml)
    找到完整的源代码。
- en: 'Now, we will learn about configuring a basic HPA based on CPU utilization metrics.
    You can read more about HPA on the official Kubernetes documentation site at [https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何基于 CPU 利用率指标配置基础的 HPA。你可以在 Kubernetes 官方文档网站上阅读更多关于 HPA 的内容，网址为 [https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)：
- en: 'If you haven''t installed it before, make sure to install **Metrics Server**
    by executing the following command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前没有安装过，确保通过执行以下命令安装 **Metrics Server**：
- en: '[PRE10]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a deployment named `nginx-hpa` with a `replicas` count of `1` in the
    `hpa/deployment-nginx.yaml` path. Make sure to have `resources.request.cpu` set,
    otherwise HPA cannot function. In our example, we used an NGINX deployment. You
    can instead use any deployment you would like to apply HPA to:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `hpa/deployment-nginx.yaml` 路径下创建一个名为 `nginx-hpa` 的部署，并设置 `replicas` 数量为 `1`。确保设置
    `resources.request.cpu`，否则 HPA 将无法正常工作。在我们的示例中，我们使用了 NGINX 部署。你可以使用任何你想要应用 HPA
    的部署：
- en: '[PRE11]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Execute the following command to create the deployment:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以创建部署：
- en: '[PRE12]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Confirm that your deployment is successful by checking its state:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查状态确认部署是否成功：
- en: '[PRE13]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now create an HPA named `nginx-autoscale` with a `minReplicas` count of `1`,
    a `maxReplicas` count of `5`, and `targetCPUUtilizationPercentage` set to `50`
    in the `hpa/hpa-nginx.yaml` path:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 `hpa/hpa-nginx.yaml` 路径下创建一个名为 `nginx-autoscale` 的 HPA，设置 `minReplicas`
    数量为 `1`，`maxReplicas` 数量为 `5`，并将 `targetCPUUtilizationPercentage` 设置为 `50`：
- en: '[PRE14]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Execute the following command to create the deployment:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以创建部署：
- en: '[PRE15]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Confirm that our HPA is successfully created:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认我们的 HPA 是否成功创建：
- en: '[PRE16]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding command should look as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令的输出应如下所示：
- en: '![Figure 8.5 – HPA monitoring for CPU metrics to scale the application](img/B16192_08_005.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 使用 HPA 监控 CPU 指标以扩展应用程序](img/B16192_08_005.jpg)'
- en: Figure 8.5 – HPA monitoring for CPU metrics to scale the application
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 使用 HPA 监控 CPU 指标以扩展应用程序
- en: In the preceding example, we used CPU utilization as our metric. HPA can use
    multiple metrics, including CPU, memory, and other custom external metrics such
    as service latency and I/O load, using **custom metrics adapters**. In addition
    to HPA, we can use **Pod Disruption Budgets** (**PDBs**) to avoid voluntary and
    involuntary disruptions to provide higher availability. You can read more about
    specifying a PDB for your application at [https://kubernetes.io/docs/tasks/run-application/configure-pdb/](https://kubernetes.io/docs/tasks/run-application/configure-pdb/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 CPU 利用率作为指标。HPA 可以使用多个指标，包括 CPU、内存以及其他自定义的外部指标，如服务延迟和 I/O 负载，通过**自定义指标适配器**。除了
    HPA，我们还可以使用**Pod 中断预算**（**PDB**）来避免自愿和非自愿的中断，从而提供更高的可用性。你可以在 [https://kubernetes.io/docs/tasks/run-application/configure-pdb/](https://kubernetes.io/docs/tasks/run-application/configure-pdb/)
    上阅读更多关于为应用程序指定 PDB 的内容。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the components of container images, best practices
    for creating container images, and choosing the right base image type. We reduced
    our container image size by removing unnecessary files and using multistage builds.
    We learned how to scan our container images for vulnerabilities proactively. We
    learned about application deployment strategies to test and roll out new features
    and releases of our applications. We created an HPA to scale our applications.
    All the recommendations and best practices mentioned in this chapter help us reduce
    the attack surface and increase stability to improve efficiency in our production
    environment.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了容器镜像的组成部分，创建容器镜像的最佳实践以及选择正确的基础镜像类型。我们通过删除不必要的文件和使用多阶段构建来减小容器镜像的大小。我们学习了如何主动扫描容器镜像中的漏洞。我们学习了关于应用部署策略，测试和推出应用程序新功能和版本的方法。我们创建了一个
    HPA 来扩展我们的应用程序。本章提到的所有建议和最佳实践都帮助我们减少攻击面，增加稳定性，以提高生产环境中的效率。
- en: In the next chapter, we will learn about Kubernetes observability and key metrics
    to monitor in production. We will learn about the tools and stacks to use or build,
    compare the best tools in the ecosystem, and learn how to deal with observability
    from a site reliability perspective.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 Kubernetes 的可观察性以及在生产环境中监视的关键指标。我们将了解要使用或构建的工具和堆栈，比较生态系统中的最佳工具，并学习如何从站点可靠性的角度处理可观察性。
- en: Further reading
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接了解本章涵盖的主题的更多信息：
- en: '*A Practical Introduction to Container Terminology*: [https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/](https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器术语实用介绍*：[https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/](https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/)'
- en: 'Open Container Initiative: [https://opencontainers.org/](https://opencontainers.org/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放容器倡议：[https://opencontainers.org/](https://opencontainers.org/)
- en: '*Hardening ELF binaries using Relocation Read-Only (RELRO)*: [https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro](https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Relocation Read-Only（RELRO）加固 ELF 二进制文件*：[https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro](https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro)'
- en: '*A Comparison of Linux Container Images*:[http://crunchtools.com/comparison-linux-container-images/](http://crunchtools.com/comparison-linux-container-images/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux 容器镜像比较*：[http://crunchtools.com/comparison-linux-container-images/](http://crunchtools.com/comparison-linux-container-images/)'
- en: '*Alpine makes Python Docker builds way too (50×) slower, and images double
    (2×) larger*: [https://lih-verma.medium.com/alpine-makes-python-docker-builds-way-too-50-slower-and-images-double-2-larger-61d1d43cbc79](https://lih-verma.medium.com/alpine-makes-python-docker-builds-way-too-50-slower-and-images-double-2-larger-61d1d43cbc79)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Alpine 使得 Python Docker 构建速度慢了太多（50×），而且镜像变大了两倍（2×）*：[https://lih-verma.medium.com/alpine-makes-python-docker-builds-way-too-50-slower-and-images-double-2-larger-61d1d43cbc79](https://lih-verma.medium.com/alpine-makes-python-docker-builds-way-too-50-slower-and-images-double-2-larger-61d1d43cbc79)'
- en: '*Why Elastic moved from Alpine to CentOS base images*: [https://www.elastic.co/blog/docker-base-centos7](https://www.elastic.co/blog/docker-base-centos7)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么 Elastic 从 Alpine 转移到 CentOS 基础镜像*：[https://www.elastic.co/blog/docker-base-centos7](https://www.elastic.co/blog/docker-base-centos7)'
- en: '*Introducing multi-architecture container images for Amazon ECR*: [https://aws.amazon.com/blogs/containers/introducing-multi-architecture-container-images-for-amazon-ecr/](https://aws.amazon.com/blogs/containers/introducing-multi-architecture-container-images-for-amazon-ecr/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引入亚马逊 ECR 多架构容器镜像*：[https://aws.amazon.com/blogs/containers/introducing-multi-architecture-container-images-for-amazon-ecr/](https://aws.amazon.com/blogs/containers/introducing-multi-architecture-container-images-for-amazon-ecr/)'
- en: 'How to use distroless Docker images: [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 distroless Docker 镜像：[https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)
- en: '*Best practices for building containers*: [https://cloud.google.com/solutions/best-practices-for-building-containers](https://cloud.google.com/solutions/best-practices-for-building-containers)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建容器的最佳实践*：[https://cloud.google.com/solutions/best-practices-for-building-containers](https://cloud.google.com/solutions/best-practices-for-building-containers)'
- en: '*Automated rollback of Helm releases based on logs or metrics*: [https://blog.container-solutions.com/automated-rollback-helm-releases-based-logs-metrics](https://blog.container-solutions.com/automated-rollback-helm-releases-based-logs-metrics)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于日志或指标的 Helm 发布自动回滚*： [https://blog.container-solutions.com/automated-rollback-helm-releases-based-logs-metrics](https://blog.container-solutions.com/automated-rollback-helm-releases-based-logs-metrics)'
- en: '*Kubernetes – A Complete DevOps Cookbook* ([*Chapter 7*](B16192_07_Final_PG_ePub.xhtml#_idTextAnchor157),
    *Scaling and Upgrading Applications*): [https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042](https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes – 完整的 DevOps 手册* ([*第7章*](B16192_07_Final_PG_ePub.xhtml#_idTextAnchor157)，*应用的扩展与升级*):
    [https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042](https://www.packtpub.com/product/kubernetes-a-complete-devops-cookbook/9781838828042)'
