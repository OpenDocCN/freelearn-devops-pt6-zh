- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Orchestrating Containers with Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 编排容器
- en: In this and the following few chapters, we will cover the most important and
    perhaps the hardest part of the KCNA certification – *Kubernetes Fundamentals*.
    It makes up almost half (46%) of the total exam questions, so it’s crucial to
    understand all the details. We’ll take it one step at a time, and we’ll also get
    practical experience with Kubernetes that will help you to memorize everything
    you need to pass the exam.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及接下来的几章中，我们将介绍KCNA认证中最重要、也许是最难的部分——*Kubernetes基础知识*。它占据了总考试题目的近一半（46%），所以理解所有细节至关重要。我们将一步步进行，同时也会获得实际的Kubernetes经验，帮助你记住通过考试所需的所有内容。
- en: In this chapter, we’ll learn about the features and the basics of the K8s architecture,
    its API, components, and the smallest deployable unit called a **Pod**. We will
    install and run Kubernetes locally with the help of the **minikube** project to
    support us along the way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习K8s架构的特性和基础知识，它的API、组件，以及最小的可部署单元——**Pod**。我们将借助**minikube**项目，在本地安装并运行Kubernetes，帮助我们一步步完成学习。
- en: 'The topics we’re going to cover are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖以下主题：
- en: Kubernetes architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes架构
- en: Kubernetes API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes API
- en: K8s – the Swiss Army knife of container orchestration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K8s – 容器编排的瑞士军刀
- en: Installing and exploring Kubernetes with minikube
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用minikube安装并探索Kubernetes
- en: Let’s get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Kubernetes architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes架构
- en: As you already know, Kubernetes is used to orchestrate fleets of containers
    that run on multiple servers that make up a Kubernetes cluster. Those servers
    are often called *nodes*, and nodes can be virtual machines running on-premises,
    in the cloud, or bare-metal servers. You can even combine different nodes in one
    Kubernetes cluster (for example, several nodes represented by VMs plus a few others
    as bare-metal servers).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，Kubernetes用于编排运行在多个服务器上的容器，这些服务器组成了Kubernetes集群。那些服务器通常被称为*节点*，节点可以是运行在本地、云端的虚拟机，或者是裸金属服务器。你甚至可以将不同类型的节点组合在一个Kubernetes集群中（例如，几个由虚拟机表示的节点加上其他几个裸金属服务器节点）。
- en: 'There are two distinguished node types in Kubernetes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中有两种区别明显的节点类型：
- en: '*Control plane* nodes (sometimes also called *master* nodes)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制平面*节点（有时也称为*主节点*）'
- en: '*Worker* nodes'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*工作*节点'
- en: It is the *worker* nodes where the containerized applications run, and it is
    the *control plane* nodes where the K8s cluster management components run. We
    can see this in more detail in *Figure 5**.1.*
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的应用运行在*工作*节点上，而K8s集群管理组件运行在*控制平面*节点上。我们可以在*图 5.1*中看到更详细的说明。
- en: '![Figure 5.1 – Kubernetes components](img/B18970_05_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Kubernetes 组件](img/B18970_05_01.jpg)'
- en: Figure 5.1 – Kubernetes components
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Kubernetes 组件
- en: Control plane nodes run several specialized K8s services and make global decisions
    about the Kubernetes cluster, such as scheduling containerized applications. Control
    plane nodes are also responsible for managing worker nodes in the cluster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面节点运行多个专门的K8s服务，并对Kubernetes集群进行全局决策，如调度容器化应用。控制平面节点还负责管理集群中的工作节点。
- en: 'The following five services run on control plane nodes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下五个服务在控制平面节点上运行：
- en: '*API server* (**kube-apiserver**): The core service that exposes the Kubernetes
    HTTP API for internal and external cluster communication. All operations within
    the cluster are performed through an API server – for example, when you query
    the state of the cluster or a particular application or start a new container.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API服务器*（**kube-apiserver**）：一个核心服务，公开Kubernetes的HTTP API，用于内部和外部集群的通信。集群内的所有操作都通过API服务器进行——例如，当你查询集群或特定应用的状态，或者启动一个新的容器时。'
- en: '*Cluster data store* (**etcd**): A place where all information about the Kubernetes
    cluster state and configuration is kept. *etcd* is an open source, distributed
    key-value store used for this purpose and it is the only stateful component.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集群数据存储*（**etcd**）：存储所有Kubernetes集群状态和配置的地方。*etcd* 是一个开源的分布式键值存储系统，用于此目的，它是唯一的有状态组件。'
- en: '*Scheduler* (**kube-scheduler**): A component that picks where, and on which
    worker node, the application containers will run in the cluster. The factors that
    can affect scheduling decisions include individual application requirements, load
    on the nodes, hardware or policy constraints, and more.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调度器*（**kube-scheduler**）：一个决定应用容器将在集群中的哪个工作节点上运行的组件。影响调度决策的因素包括单个应用的需求、节点负载、硬件或策略限制等。'
- en: '*Controller manager* (**kube-controller-manager**): A component that runs various
    controller processes, such as *Node*, *Job*, or *Deployment* controllers. Those
    controllers watch the current state of respective resources in the cluster and
    take action if the current state differs from the desired state.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Controller manager* (**kube-controller-manager**)：这是一个运行各种控制器进程的组件，如 *Node*、*Job*
    或 *Deployment* 控制器。这些控制器监视集群中各资源的当前状态，并在当前状态与期望状态不一致时采取行动。'
- en: 'An optional *Cloud controller manager* (**cloud-controller-manager**): A component
    that lets you integrate the Kubernetes cluster with a cloud provider by running
    controller processes specific to your provider. For example, it allows you to
    create load balancers for containerized applications or determine if a worker
    node cloud instance has been deleted. *Cloud controller manager* is a component
    that you do not need when K8s is running on-premises.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的 *Cloud controller manager* (**cloud-controller-manager**)：这是一个让你通过运行特定于提供商的控制器进程，将
    Kubernetes 集群与云提供商集成的组件。例如，它允许你为容器化应用创建负载均衡器，或者判断一个工作节点的云实例是否已被删除。*Cloud controller
    manager* 是在 K8s 部署在本地时不需要的组件。
- en: 'Let’s move on to the components of worker nodes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论工作节点的组件：
- en: '**Kubelet**: An agent that ensures that containers assigned to the node are
    running and healthy. Kubelet also reports the status to the API server.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubelet**：一个代理，确保分配给节点的容器正在运行并保持健康。Kubelet 还会向 API 服务器报告状态。'
- en: '**Proxy** (**kube-proxy**): This is a network proxy that helps to implement
    Kubernetes *Service* functionality. Proxy maintains network rules on nodes to
    allow container communication from inside or outside of your K8s cluster.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Proxy** (**kube-proxy**)：这是一个网络代理，帮助实现 Kubernetes *Service* 功能。Proxy 在节点上维护网络规则，以允许容器从
    K8s 集群内外进行通信。'
- en: '**Container runtime**: This is a piece of software that’s responsible for basic
    container operations. Thanks to *CRI*, Kubernetes can use different container
    runtimes. One of the most popular runtimes today is *containerd*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Container runtime**：这是一个负责基本容器操作的软件。得益于 *CRI*，Kubernetes 可以使用不同的容器运行时。目前最流行的运行时之一是
    *containerd*。'
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Kubelet does not manage containers that were not created via the Kubernetes
    API. For example, containers created by other means on the worker nodes won’t
    be known to Kubernetes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubelet 不管理通过 Kubernetes API 以外的方式创建的容器。例如，通过其他方式在工作节点上创建的容器，Kubernetes 是无法识别的。
- en: Today, the worker node components **also run on the control plane nodes**. That’s
    right – on the Kubernetes control plane, you’ll have not just the *scheduler*,
    *kube-apiserver*, *etcd*, and *kube-controller-manager*, but also *kubelet*, *kube-proxy*,
    and a *runtime*. This means that worker components are run on all Kubernetes nodes
    in the cluster.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，工作节点组件**也运行在控制平面节点上**。没错——在 Kubernetes 控制平面中，你不仅会有 *scheduler*、*kube-apiserver*、*etcd*
    和 *kube-controller-manager*，还会有 *kubelet*、*kube-proxy* 和 *runtime*。这意味着工作组件会在集群中的所有
    Kubernetes 节点上运行。
- en: Why is that? The reason is that control plane components are deployed in containers
    themselves and therefore can be managed by Kubernetes with so-called static **pods**.
    Alternatively, control plane components can be started and managed with **systemd**,
    but this approach is becoming less popular today.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？原因是控制平面组件本身就部署在容器中，因此可以通过所谓的静态 **pods** 由 Kubernetes 管理。或者，控制平面组件可以通过
    **systemd** 启动和管理，但这种方法如今越来越不流行了。
- en: What is a pod?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 pod？
- en: A pod is the smallest deployable unit that can be created in Kubernetes. A pod
    is a group of one or multiple containers that share storage, network, and a specification
    of how to run containers within the pod.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是可以在 Kubernetes 中创建的最小可部署单元。Pod 是一组共享存储、网络和容器运行规范的一个或多个容器。
- en: You can think of a pod as a Kubernetes wrapper for containers, and you’ll always
    deal with pods when deploying any application in a K8s cluster. Even if you need
    to run a small simple application consisting of only one container, you’ll need
    to define a pod with that single container. In other words, **it is not possible
    to run containers on Kubernetes without a** **pod wrapper**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个 pod 看作是 Kubernetes 对容器的封装，在 K8s 集群中部署任何应用时，你总是会处理 pod。即使你只需要运行一个由单个容器组成的小型简单应用，你也需要定义一个包含该单一容器的
    pod。换句话说，**没有 pod 封装就无法在 Kubernetes 上运行容器**。
- en: 'It is also rather common to have two or more containers in one pod where the
    second or third container in the pod acts as a *helper* to the *main* container.
    This happens when multiple containers need to work together and share resources.
    Such *helper* containers are called *sidecars*. In the previous chapter, we learned
    about the *Service Mesh*, which utilizes sidecars to deploy a proxy together with
    the application containers. Another example where you might run multiple containers
    in one pod is to collect monitoring metrics from the application running in the
    main container. A sidecar container may also be used for log aggregation – for
    example, a sidecar container might collect and ship logs for long-term storage
    from the main application in the same pod, as shown in *Figure 5**.2*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Pod 中有两个或多个容器的情况也非常常见，其中 Pod 中的第二个或第三个容器作为*辅助*容器来帮助*主*容器。这种情况发生在多个容器需要协同工作并共享资源时。这种*辅助*容器被称为*边车*容器。在上一章中，我们学习了*服务网格*，它利用边车容器将代理与应用容器一起部署。另一个可能在同一个
    Pod 中运行多个容器的例子是从主容器中运行的应用程序收集监控指标。边车容器还可以用于日志聚合——例如，边车容器可能会收集并转发主应用容器的日志到长期存储中，如*图
    5.2*所示：
- en: '![Figure 5.2 – Pod example with two containers](img/B18970_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 包含两个容器的 Pod 示例](img/B18970_05_02.jpg)'
- en: Figure 5.2 – Pod example with two containers
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 包含两个容器的 Pod 示例
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Containers of one pod are always co-located and co-scheduled on the same node.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个 Pod 中的容器始终被共置并共同调度在同一个节点上。
- en: Other than the *sidecar*, there is yet another type called **Init Containers**.
    They are handy for running setup scripts and initialization utilities that are
    needed for the containerized application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*边车*容器，还有另一种类型的容器，称为**初始化容器（Init Containers）**。它们对于运行设置脚本和初始化工具非常有用，这些工具是容器化应用所需的。
- en: initContainers
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: initContainers
- en: These are containers that are executed in order before the other containers
    in the pod are started. Until all `initContainers` have finished, no other containers
    are going to start and initContainers will run every time a pod starts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些容器在 Pod 中的其他容器启动之前按顺序执行。直到所有`initContainers`完成，其他容器才会启动，initContainers 每次
    Pod 启动时都会运行。
- en: 'Besides allowing you to run co-located and individual containers on Kubernetes,
    pods have more features, including the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许你在 Kubernetes 上运行共置和独立的容器，Pods 还具有更多的功能，包括以下内容：
- en: '**Shared storage**: All the containers in a pod can access shared volumes,
    allowing containers to share data.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享存储**：Pod 中的所有容器都可以访问共享的卷，从而允许容器共享数据。'
- en: '**Shared networking**: All the containers in a Pod share the *network namespace*
    with an IP address and network ports. Containers don’t have individual IP addresses,
    but the pod does, and containers in one pod can communicate with each other simply
    via *localhost*. Also, because of shared networking, two containers in one pod
    cannot listen on the same network port.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享网络**：Pod 中的所有容器共享*网络命名空间*，并拥有一个 IP 地址和网络端口。容器没有独立的 IP 地址，但 Pod 有，且 Pod
    中的容器可以通过*localhost*简单地相互通信。此外，由于共享网络，Pod 中的两个容器不能监听相同的网络端口。'
- en: '**Shared memory**: Containers in a pod can use standard Linux inter-process
    communication such as **SystemV semaphores** or **POSIX** **shared memory**.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享内存**：Pod 中的容器可以使用标准的 Linux 进程间通信，如**SystemV 信号量**或**POSIX** **共享内存**。'
- en: Now, we’ve already mentioned Kubernetes *clusters* many times, meaning that
    we need at least two nodes. Technically, you could run Kubernetes on a single
    node while combining both the control plane and worker node functionality at the
    same time. **However, you should never do this for production environments. This
    is only acceptable for learning or** **development purposes**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经多次提到过 Kubernetes *集群*，这意味着我们需要至少两个节点。技术上，你可以在单个节点上运行 Kubernetes，同时结合控制平面和工作节点的功能。但是，**你绝不应该在生产环境中这样做。这仅适用于学习或**
    **开发用途**。
- en: In real-life scenarios, we would run at least three control plane nodes with
    several worker nodes. The nodes should be spread across multiple **failure domains**
    (typically called **availability zones** by cloud providers) that might be represented
    by individual data centers interconnected with high bandwidth networks. In the
    case of an outage of a single server or an availability zone, such a Kubernetes
    cluster will remain operational.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，我们至少会运行三个控制平面节点和多个工作节点。这些节点应该分布在多个**故障域**中（通常由云服务提供商称为**可用区**），这些故障域可能是由单独的数据中心组成，通过高速带宽网络互联。在单个服务器或可用区出现故障的情况下，这样的
    Kubernetes 集群仍然可以保持运行。
- en: Having just one control plane node in the cluster is not sufficient for production
    environments because, in the case of an outage, you won’t able to query the state
    of your cluster and applications, start new pods with containers, or make any
    changes. Also, you don’t want to lose your *etcd* data store, which keeps all
    the information about your cluster.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中只有一个控制平面节点不足以满足生产环境的需求，因为在出现故障时，你将无法查询集群和应用程序的状态，无法启动带有容器的新 pod，也无法进行任何更改。而且，你不希望丢失你的*etcd*
    数据存储，它保存着有关集群的所有信息。
- en: Therefore, like with many clustered systems, the best practice is **to run an
    odd number of control plane nodes**; for example, three or five. Having an odd
    number helps to prevent *split-brain* scenarios where, in the event of a network
    failure, two parts of the cluster won’t be able to establish a majority (for example,
    four nodes split into two parts can lead to inconsistencies or an inoperable state).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像许多集群系统一样，最佳实践是**运行奇数个控制平面节点**；例如三个或五个。拥有奇数个节点有助于防止*分脑*情境，在网络故障的情况下，集群的两个部分将无法建立多数（例如，四个节点分成两部分可能会导致不一致或无法正常工作）。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This practice does not apply to worker nodes, and it is fine to run two, four,
    seven, or even 200 worker nodes in a cluster.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法不适用于工作节点，在集群中运行两个、四个、七个甚至 200 个工作节点是可以的。
- en: I know this is a lot to digest, but when we get our hands on Kubernetes and
    deploy our first few pods, things will become much clearer and easier. Later in
    this chapter, we will have a closer look at the pod specification, but for now,
    let’s learn more about the Kubernetes API and how we can use it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这有很多内容需要消化，但当我们开始使用 Kubernetes 并部署我们的第一个几个 pod 时，事情会变得更加清晰和简单。稍后在本章中，我们将更详细地了解
    pod 规格，但现在，让我们先了解更多关于 Kubernetes API 以及如何使用它。
- en: The Kubernetes API
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes API
- en: As we learned previously, the Kubernetes API server is the main gateway for
    all cluster operations. When we want to know the state of the cluster, the number
    of nodes or pods or other resources, and their state, we need to use the Kubernetes
    API. The same is valid for all operations, such as creating new pods or making
    changes in the specifications of other resources. In a nutshell, the API server
    is the *brain* of K8s.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所学，Kubernetes API 服务器是所有集群操作的主要入口。当我们想了解集群的状态、节点或 pod 的数量或其他资源及其状态时，我们需要使用
    Kubernetes API。所有操作都是如此，例如创建新 pod 或修改其他资源的规格。简而言之，API 服务器是 K8s 的*大脑*。
- en: 'There are multiple ways to interact with the Kubernetes API:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes API 交互有多种方式：
- en: '`kubectl` to interact with K8s clusters and manage or debug applications running
    in Kubernetes.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 与 K8s 集群交互，并管理或调试在 Kubernetes 中运行的应用程序。
- en: '`dashboard`, however, does not support all functionality that `kubectl` does.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard`，然而并不支持`kubectl`所提供的所有功能。'
- en: '**Client libraries**: Available in many programming languages, including *Golang*,
    *Java*, *Python*, *JavaScript*, and more. They allow you to write software that
    uses the Kubernetes API and helps handle common tasks such as authentication.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端库**：支持多种编程语言，包括 *Golang*、*Java*、*Python*、*JavaScript* 等。它们允许你编写使用 Kubernetes
    API 的软件，并帮助处理常见的任务，如身份验证。'
- en: '`curl` or `wget`, you can directly access the Kubernetes API. This is not a
    very commonly used method but it can be helpful sometimes.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `curl` 或 `wget`，你可以直接访问 Kubernetes API。这种方式不常用，但有时还是有帮助的。
- en: This list is not exhaustive, and today, you can find many other tools (`kubectl`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不详尽，今天，你还可以找到许多其他工具（如 `kubectl`）。
- en: In the previous chapters, we mentioned that the Kubernetes API is **declarative**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们提到过 Kubernetes API 是**声明式**的。
- en: Declarative API
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式 API
- en: A declarative API means you declare the *desired state* of your Kubernetes resources
    and Kubernetes controllers, constantly ensuring that the current state of Kubernetes
    objects (for example, the number of pods for a certain app) is in sync with the
    declared desired state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式 API 意味着你声明 Kubernetes 资源和 Kubernetes 控制器的*期望状态*，并不断确保 Kubernetes 对象的当前状态（例如，某个应用的
    Pod 数量）与声明的期望状态保持一致。
- en: 'Thus, the Kubernetes API is different from an imperative approach where you
    instruct the server on what to do. After you have defined the desired state via
    the API, Kubernetes, using its *kube-controller-manager*, will instruct the controllers
    running in infinite control loops to check the resource state to be the same as
    the desired state and *reconcile* if not. For example, we have instructed K8s
    to run our application with three replicas and one of the replicas eventually
    crashed. Kubernetes will automatically detect that only two replicas are running
    and will spawn one new pod with our application:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Kubernetes 的 API 与命令式方法不同，在命令式方法中你会指示服务器该做什么。在通过 API 定义了期望状态后，Kubernetes
    会使用其 *kube-controller-manager*，指示运行在无限控制循环中的控制器检查资源状态是否与期望状态一致，并在不一致时进行*协调*。例如，我们已经指示
    K8s 运行我们的应用程序并保持三个副本，如果其中一个副本最终崩溃，Kubernetes 将自动检测到只剩两个副本在运行，并会生成一个新的 Pod 来运行我们的应用程序：
- en: '![Figure 5.3 – Kubernetes control loops](img/B18970_05_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – Kubernetes 控制循环](img/B18970_05_03.jpg)'
- en: Figure 5.3 – Kubernetes control loops
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – Kubernetes 控制循环
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The infinite control loops of controller managers are sometimes also called
    reconciliation loops.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器的无限控制循环有时也被称为协调循环。
- en: 'Because Kubernetes is developed at high velocity, its APIs are constantly evolving.
    New API resources can be added frequently, and old resources or fields are removed
    over several release cycles following Kubernetes’s depreciation policy. To make
    it easier to make such changes, K8s supports multiple API versions and API grouping
    and maintains compatibility with existing API clients for an extended period.
    For example, there can be two API versions for the same resource: `v1` and `v1beta1`.
    You may have first created a resource using its `v1beta1` version, but you’ll
    still be able to make changes to this resource using either the `v1` or `v1beta1`
    API version for a few releases.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kubernetes 的开发速度非常快，其 API 不断演进。新的 API 资源可以频繁添加，而旧的资源或字段会根据 Kubernetes 的弃用政策在多个发布周期后被移除。为了便于进行这些更改，K8s
    支持多个 API 版本和 API 分组，并在较长时间内与现有的 API 客户端保持兼容。例如，同一资源可以有两个 API 版本：`v1` 和 `v1beta1`。你可能最初使用
    `v1beta1` 版本创建了一个资源，但你仍然可以在几个版本发布期间，使用 `v1` 或 `v1beta1` API 版本对该资源进行更改。
- en: 'Each new feature of Kubernetes follows a defined life cycle and the respective
    API evolves from alpha to beta to the generally available state over several K8s
    releases, as shown in *Figure 5**.4*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的 Kubernetes 功能都有一个定义的生命周期，相关的 API 会在多个 K8s 版本中从 alpha 发展到 beta，再到正式发布的状态，如
    *图 5.4* 所示：
- en: '![Figure 5.4 – Kubernetes feature life cycle](img/B18970_05_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – Kubernetes 功能生命周期](img/B18970_05_04.jpg)'
- en: Figure 5.4 – Kubernetes feature life cycle
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – Kubernetes 功能生命周期
- en: It’s worth mentioning that the alpha features of Kubernetes are usually *disabled*.
    However, you can enable them by setting so-called **feature gates**. Beta and
    stable Kubernetes features are enabled by default.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Kubernetes 的 alpha 功能通常是*禁用*的。然而，你可以通过设置所谓的 **feature gates** 来启用这些功能。Beta
    和稳定版的 Kubernetes 功能默认是启用的。
- en: The implementation of new and major changes to existing features in Kubernetes
    typically starts with **Kubernetes Enhancement Proposal** (**KEP**). Those are
    detailed specification documents that outline the motivation, goals, and design
    of the changes. You can find existing KEPs in Kubernetes GitHub repositories ([https://github.com/kubernetes/enhancements/tree/master/keps](https://github.com/kubernetes/enhancements/tree/master/keps)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，对现有功能的新重大更改的实现通常从 **Kubernetes 增强提案** (**KEP**) 开始。这些是详细的规范文档，概述了更改的动机、目标和设计。你可以在
    Kubernetes GitHub 仓库中找到现有的 KEP（[https://github.com/kubernetes/enhancements/tree/master/keps](https://github.com/kubernetes/enhancements/tree/master/keps)）。
- en: Because Kubernetes is a complex project with many components, it has multiple
    operational areas, including storage, networking, scaling, and more. Those areas
    are typically covered by Kubernetes **Special Interest Groups** (**SIGs**). SIGs
    are smaller communities of developers that focus on particular parts of K8s. Since
    K8s is an open source project, anybody can become a part of SIG to fix issues,
    review code, and make enhancement proposals.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Kubernetes 是一个复杂的项目，包含许多组件，所以它有多个操作领域，包括存储、网络、扩展等。这些领域通常由 Kubernetes **特别兴趣小组**（**SIGs**）来覆盖。SIGs
    是专注于 Kubernetes 特定部分的小型开发者社区。由于 K8s 是一个开源项目，任何人都可以成为 SIG 的一员，修复问题、审查代码和提出改进建议。
- en: 'Last, but not least, the Kubernetes API is highly extensible in one of two
    ways:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Kubernetes API 是高度可扩展的，扩展方式有两种：
- en: 'With **Custom Resource Definitions** (**CRDs**): A method that does not require
    any programming'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **自定义资源定义**（**CRDs**）：一种不需要编程的方法
- en: 'With **aggregation layers**: A method that requires programming but allows
    you to have more control over the API behavior'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **聚合层**：一种需要编程的方法，但它允许你对 API 行为有更多控制
- en: Both methods allow you to add extra functionality to Kubernetes, beyond what
    is offered by the standard Kubernetes APIs. You don’t need to know many details
    for the scope of the KCNA exam, but as you gain more hands-on experience, you’ll
    see that the extensible API is a very powerful feature of Kubernetes that allows
    us to add unique features without the need to know or modify existing K8s source
    code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都允许你为 Kubernetes 添加额外的功能，超出标准 Kubernetes API 所提供的范围。对于 KCNA 考试的范围，你不需要了解太多细节，但随着你实践经验的积累，你会发现可扩展的
    API 是 Kubernetes 的一项非常强大的功能，它使我们能够在不需要了解或修改现有 K8s 源代码的情况下添加独特的功能。
- en: Now that we’ve learned about the Kubernetes API, let’s understand more about
    the features of Kubernetes that made it the number one orchestrator of containers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Kubernetes API，让我们进一步了解 Kubernetes 的一些功能，正是这些功能使其成为容器编排的第一选择。
- en: K8s – the Swiss Army knife of container orchestration
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K8s——容器编排的瑞士军刀
- en: We’ve mentioned a few times that Kubernetes is great for running cloud-native
    applications that consist of many microservices packaged in containers. But why
    exactly?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次提到 Kubernetes 非常适合运行由许多微服务组成的云原生应用，这些微服务打包在容器中。那到底是为什么呢？
- en: Kubernetes offers many features that enormously simplify the operation of large
    container fleets. We already know that it is possible to automatically scale the
    number of containers with Kubernetes or restart failing containers. What about
    the other features Kubernetes has to offer?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了许多功能，极大地简化了大规模容器集群的操作。我们已经知道，可以使用 Kubernetes 自动扩展容器的数量或重启故障的容器。那么，Kubernetes
    还有哪些其他功能呢？
- en: '**Automated rollouts and rollbacks**: Allows you to deploy new versions and
    changes of your application (or its configuration) in a controlled way, monitoring
    the application’s health status and ensuring it is always running. K8s also allows
    you to roll back to the previous versions of the application, its image, or its
    configuration if something goes wrong.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化滚动更新和回滚**：允许你以受控方式部署应用的新版本和配置更改，监控应用的健康状况并确保它始终运行。如果出现问题，K8s 还允许你回滚到应用的先前版本、镜像或配置。'
- en: '**Service discovery and load balancing**: Allows different microservices in
    a cluster to easily find each other. In a set of pods representing the same microservice,
    each pod will have an IP address, but the set will have a single DNS name, allowing
    simple service discovery and load distribution.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现与负载均衡**：允许集群中不同的微服务轻松找到彼此。在一组表示相同微服务的 Pod 中，每个 Pod 都会有一个 IP 地址，但整个集合会有一个单一的
    DNS 名称，从而简化服务发现和负载分配。'
- en: '**Secret and configuration management**: Allows you to handle microservice
    configuration and secrets without the need to rebuild container images or expose
    sensitive credentials – for example, when a service needs to access a database
    or has many configuration parameters that change.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密和配置管理**：允许你管理微服务配置和机密，而无需重新构建容器镜像或暴露敏感凭证——例如，当服务需要访问数据库或有许多配置参数需要变化时。'
- en: '**Self-healing**: Allows you to automatically restart containers that fail
    for any reason, automatically reschedule containers to another node if a worker
    node stops responding, restart containers that fail predefined health checks,
    and route requests to containers when only the applications inside are fully started
    and ready to serve.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自愈**：允许你自动重启由于任何原因失败的容器，如果工作节点停止响应，自动将容器重新调度到另一个节点，重启未通过预定义健康检查的容器，并且仅当应用程序完全启动并准备好服务时，才将请求路由到容器。'
- en: '**Horizontal scaling**: Allows you to scale a containerized application up
    or down by adding or reducing the number of pods running the application. This
    can be done manually or automatically, for example, based on CPU usage.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平扩展**：允许通过增加或减少运行应用程序的 Pod 数量来横向扩展容器化应用程序。这可以手动完成，也可以自动完成，例如，基于 CPU 使用率进行扩展。'
- en: '**Batch execution**: Allows you to schedule the execution of containers and
    flexibly manage batch processing or CI workloads.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理执行**：允许你调度容器的执行，并灵活管理批处理处理或 CI 工作负载。'
- en: '**Automatic bin packing**: Allows you to automatically determine the best worker
    node to start the container based on requested resources, current cluster utilization,
    or other requirements. It also allows you to define workload priorities to handle
    different critical and non-critical applications.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动垃圾回收**：允许根据请求的资源、当前集群利用率或其他需求，自动确定最佳的工作节点来启动容器。它还允许定义工作负载优先级，以处理不同的关键和非关键应用程序。'
- en: '**Storage orchestration**: Allows you to integrate and manage storage systems
    of your choice. Kubernetes can automatically provision and mount storage volumes
    when a pod is spawned and re-mount volumes to different nodes as needed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储编排**：允许你集成和管理自己选择的存储系统。当 Pod 启动时，Kubernetes 可以自动配置和挂载存储卷，并根据需要将卷重新挂载到不同的节点。'
- en: 'This is a long list and yet not 100% complete. In the previous section, we
    saw that it is possible to extend the Kubernetes API to add new features. Today,
    Kubernetes has a rich ecosystem with numerous projects that extend Kubernetes
    and even allow you to manage other workloads besides containers. That’s right
    – Kubernetes can be used to orchestrate not just containers. There are several
    projects we should mention:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一长串内容，但仍然不是 100% 完整的。在上一节中，我们看到可以扩展 Kubernetes API 来添加新功能。如今，Kubernetes 拥有一个丰富的生态系统，拥有众多扩展
    Kubernetes 的项目，甚至可以让你管理除容器之外的其他工作负载。没错，Kubernetes 不仅可以用来编排容器。我们应该提到几个项目：
- en: '**KubeVirt**: A project that’s used to provision and manage virtual machines
    with Kubernetes alongside containers. This is used for cases when a workload cannot
    be easily containerized or for an ongoing process of application containerization
    where some applications still run in VMs.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KubeVirt**：一个用于通过 Kubernetes 编排虚拟机与容器一起使用的项目。这通常用于当工作负载无法轻松容器化的情况，或在进行应用程序容器化的过程中，有些应用程序仍然运行在虚拟机中。'
- en: '**Kubeless**: A serverless computing framework that runs on top of Kubernetes.
    It adds FaaS capabilities to your K8s cluster and can serve as an alternative
    to cloud provider FaaS offerings.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubeless**：一个运行在 Kubernetes 上的无服务器计算框架。它为你的 K8s 集群增加了 FaaS 能力，并可以作为云提供商 FaaS
    服务的替代方案。'
- en: '**Knative**: Another serverless computing framework for Kubernetes that has
    recently been accepted to the CNCF. It was originally founded by Google and has
    been actively developed since 2018.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Knative**：另一个 Kubernetes 的无服务器计算框架，最近被 CNCF 接受。它最初由 Google 创建，自 2018 年以来一直在积极开发。'
- en: '**OpenFaas**: Another serverless framework that can be used with Kubernetes
    or without in a standalone mode. Like the other two serverless frameworks, it
    supports many programming languages that can be used to write functions, including
    *Golang*, *Java*, *Python*, *Ruby*, *C#*, and others.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenFaas**：另一个可以与 Kubernetes 一起使用或独立使用的无服务器框架。与其他两个无服务器框架类似，它支持多种编程语言来编写函数，包括*Golang*、*Java*、*Python*、*Ruby*、*C#*
    等。'
- en: You don’t need to know further details about those projects for the KCNA exam
    or any other Kubernetes certification from CNCF. Just remember that it is possible
    to orchestrate VMs with the help of KubeVirt and offer FaaS on top of Kubernetes
    with projects such as Knative. If you’d like to learn more about these projects,
    you’ll find links in the *Further reading* section at the end of this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 KCNA 考试或 CNCF 认证的其他 Kubernetes 认证，你不需要了解这些项目的进一步细节。只需记住，借助 KubeVirt，能够编排虚拟机，并且可以通过如
    Knative 等项目在 Kubernetes 上提供 FaaS。如果你想了解更多这些项目的信息，可以参考本章末尾的*进一步阅读*部分中的链接。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though it is possible to manage VMs with the help of Kubernetes, it is
    still primarily used to orchestrate containers most of the time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了 Kubernetes 的帮助，也可以管理虚拟机，但它仍然主要用于协调容器。
- en: 'Before we jump into installing Kubernetes and trying its numerous features
    out, let’s look at an example of how K8s can be a part of the development workflow,
    as shown in *Figure 5**.5*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始安装 Kubernetes 并尝试其众多功能之前，让我们先看看一个例子，展示 K8s 如何成为开发工作流的一部分，如 *图 5.5* 所示：
- en: '![Figure 5.5 – Simple development workflow example with Kubernetes](img/B18970_05_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 使用 Kubernetes 的简单开发工作流示例](img/B18970_05_05.jpg)'
- en: Figure 5.5 – Simple development workflow example with Kubernetes
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 使用 Kubernetes 的简单开发工作流示例
- en: 'The simplified workflow may look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的工作流程可能如下所示：
- en: A developer writes code for a new microservice and commits it to a GitHub repository.
    As you may recall, developers don’t need to learn a new programming language to
    run applications in containers.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者编写一个新微服务的代码，并将其提交到 GitHub 仓库。正如你可能记得的那样，开发者无需学习新的编程语言即可在容器中运行应用程序。
- en: There should be a `Dockerfile` that defines the steps needed to package the
    application into a container image. Before the container image is built, automated
    tests are executed in the CI pipeline. If the tests are successful, a Docker image
    is built and pushed into the image registry.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该有一个 `Dockerfile`，定义将应用程序打包为容器镜像所需的步骤。在构建容器镜像之前，CI 管道中会执行自动化测试。如果测试成功，将构建 Docker
    镜像并推送到镜像仓库。
- en: Next, the deployment of the container is triggered in the Kubernetes cluster.
    To run containers on Kubernetes, we need a pod spec definition in either `kubectl`
    tool, which must be configured to work with our K8s cluster.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，容器的部署会在 Kubernetes 集群中触发。要在 Kubernetes 上运行容器，我们需要在 `kubectl` 工具中定义一个 pod
    规格，并确保其已配置为与我们的 K8s 集群协同工作。
- en: As the spec is applied, Kubernetes will take care of finding a suitable worker
    node to download the container image from the registry and start the pod with
    our containerized application. We can define it to run multiple replicas of applications
    for high availability requirements and to balance the load.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当规格应用时，Kubernetes 会负责找到合适的工作节点，从镜像仓库下载容器镜像，并启动我们的容器化应用程序的 pod。我们可以定义它以运行多个副本，以满足高可用性要求并平衡负载。
- en: This process can be repeated many times and Kubernetes can handle deploying
    the new image with a new application version in a rolling update manner where,
    for instance, only one replica will be replaced at a time.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程可以重复多次，Kubernetes 可以以滚动更新的方式处理新应用版本的镜像部署，例如，每次只会替换一个副本。
- en: A pod is just one example of a Kubernetes object, and it is the smallest deployable
    unit. In the next chapter, we’ll get to know other, more advanced resources that
    use Kubernetes controllers and provide more advanced features.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 pod 只是 Kubernetes 对象的一个例子，它是最小的可部署单元。在下一章，我们将了解其他使用 Kubernetes 控制器并提供更高级功能的资源。
- en: Kubernetes objects
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 对象
- en: Kubernetes objects are persistent entries that represent the state of the cluster,
    including information about which containerized applications run and on which
    nodes, resources available to these applications, and their associated policies
    (for example, restart policies, scheduling requirements, and so on).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 对象是持久化的条目，表示集群的状态，包括哪些容器化应用程序在运行，在哪些节点上运行，应用程序可用的资源及其相关策略（例如，重启策略、调度要求等）。
- en: Kubernetes objects are created the moment we apply a spec definition, and they
    are essentially a *record of intent*. Once the object has been created, Kubernetes
    will work to ensure that the object exists and is in the *desired state*. The
    time it might take to reach the desired state depends on many factors and might
    take as little as a second or as much as several minutes if, for instance, the
    container image that’s downloaded from the image registry is large and the network
    performance is poor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 对象在我们应用规格定义的那一刻就会被创建，它们本质上是一个 *意图记录*。一旦对象被创建，Kubernetes 会确保该对象存在，并处于
    *期望状态*。达到期望状态所需的时间取决于许多因素，可能只需要一秒钟，或者如果例如从镜像仓库下载的容器镜像很大且网络性能较差，则可能需要几分钟。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Kubernetes spec definition files are also known as Kubernetes manifests. It
    is a specification of API objects in JSON or YAML format.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 规格定义文件也称为 Kubernetes 清单。它是 API 对象的 JSON 或 YAML 格式的规范。
- en: Now that we are familiar with some of the basics, let’s try things out ourselves.
    In the next section, we are going to install a single node Kubernetes to gain
    hands-on experience.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了一些基础知识，让我们亲自尝试一下。在接下来的章节中，我们将安装一个单节点的 Kubernetes 来获得实践经验。
- en: Installing and exploring K8s with minikube
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装并探索使用 minikube 的 K8s
- en: Today, many projects allow you to quickly bootstrap a simple K8s cluster or
    a single node Kubernetes for learning or local development purposes. We will be
    using **minikube**, a project supported by an official Kubernetes SIG that focuses
    on cluster deployment and its life cycle. Other projects let you get similar results,
    such as **Kind** and **CRC**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多项目允许你快速启动一个简单的 K8s 集群或用于学习或本地开发的单节点 Kubernetes。我们将使用 **minikube**，这是一个由官方
    Kubernetes SIG 支持的项目，专注于集群部署及其生命周期管理。其他项目也能达到类似效果，比如 **Kind** 和 **CRC**。
- en: Important note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: miniKube, Kind, and some other projects are not designed to set up production-ready
    Kubernetes clusters. Do not use these setups to run important workloads!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: miniKube、Kind 和其他一些项目并非为生产就绪的 Kubernetes 集群而设计。请不要使用这些设置来运行重要的工作负载！
- en: 'Quickly make sure that your system meets *minikube’s* requirements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 快速确认你的系统满足 *minikube* 的要求：
- en: A recent version of Linux, macOS, or Windows
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新版本的 Linux、macOS 或 Windows
- en: 2+ CPU cores
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2+ 个 CPU 核心
- en: 2+ GB of free RAM
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2+ GB 的可用内存
- en: 20+ GB of free disk space
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20+ GB 的可用磁盘空间
- en: Internet connection
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络连接
- en: Administrator/superuser privileges
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员/超级用户权限
- en: Container or VM manager (our Docker Engine installation from previous chapters
    can be used)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器或虚拟机管理器（可以使用前面章节中的 Docker 引擎安装）
- en: First, open the minikube start documentation ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/))
    in your browser and select your operating system under the *Installation* section.
    Make sure that you select the *Stable* release type and the correct CPU architecture
    if you’re running on macOS or Linux.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在浏览器中打开 minikube 启动文档（[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)），然后在
    *安装* 部分选择你的操作系统。确保选择 *稳定* 版本，并在运行 macOS 或 Linux 时选择正确的 CPU 架构。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t have the `curl` tool installed, you can also simply copy the URL
    from the documentation, paste it into a new browser tab, and save it to your computer,
    just like any other downloadable. In such a case, the `installation` command should
    be executed in the same path where the `minikube` binary was saved.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装 `curl` 工具，也可以直接复制文档中的 URL，粘贴到新的浏览器标签页并保存到计算机，就像下载其他文件一样。在这种情况下，`installation`
    命令应该在保存 `minikube` 二进制文件的同一目录下执行。
- en: 'Open your Terminal and execute the command for your OS, and enter the password
    if requested. For example, on macOS with an x86-64 CPU, the output might look
    like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并执行适合你操作系统的命令，如果需要，输入密码。例如，在 macOS 上使用 x86-64 CPU 时，输出可能如下所示：
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, we are ready to start our local Kubernetes with the help of
    the `minikube` `start` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们准备好借助 `minikube` 的 `start` 命令启动本地 Kubernetes：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might have a newer version of Kubernetes and a slightly different output
    from `minikube start`. If you encounter an error, there likely will be a link
    to a related issue in the output that should help you to resolve the problem.
    If you are using another system than in the previous chapters, you’ll need to
    install Docker Engine first. Refer to [*Chapter 3*](B18970_03.xhtml#_idTextAnchor038),
    *Getting Started with Containers*, for details and the drivers’ documentation
    page of minikube ([https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/)).
    For other problems, check the minikube troubleshooting guide linked in the *Further
    reading* section of this chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一个较新的 Kubernetes 版本，`minikube start` 的输出也会有所不同。如果遇到错误，输出中很可能会有指向相关问题的链接，帮助你解决问题。如果你使用的是与前面章节中不同的系统，你需要先安装
    Docker 引擎。有关详细信息，请参考 [*第 3 章*](B18970_03.xhtml#_idTextAnchor038)，*容器入门*，以及 minikube
    的驱动程序文档页面（[https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/)）。对于其他问题，请查看本章
    *进一步阅读* 部分中的 minikube 故障排除指南。
- en: 'Now that we have Kubernetes up and running, we should be able to access its
    API using the `kubectl` CLI tool. You can go and download `kubectl` yourself,
    but minikube can do this for you. It is recommended to let `minikube` do this
    as it will automatically pick the correct version. All you need to do is run any
    command with `kubectl` for the first time – for example, a command to list all
    Kubernetes nodes in the cluster:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了 Kubernetes，应该能够使用`kubectl` CLI 工具访问其 API。你可以自己下载`kubectl`，但 minikube
    可以为你完成这项工作。推荐让`minikube`来做这件事，因为它会自动选择正确的版本。你只需第一次运行任何带有`kubectl`的命令——例如列出集群中所有
    Kubernetes 节点的命令：
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Minikube has downloaded the K8s CLI for us and ran the command. At no surprise,
    we only have one node that is called `minikube` and has roles of `control-plane`
    and `master`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 已经为我们下载了 K8s CLI 并执行了命令。不出所料，我们只有一个名为`minikube`的节点，它的角色是`control-plane`和`master`。
- en: 'Let’s see what is currently running in Kubernetes. You can list the pods using
    the `kubectl get` `pods` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前在 Kubernetes 中运行的内容。你可以使用`kubectl get` `pods`命令列出 Pods：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, nothing is running at the moment because we’ve just bootstrapped
    a new cluster. Let’s run the same command with an extra option – that is, `--all-namespaces`
    (mind the two extra dashes between `kubectl` and `get`; they are needed to separate
    the `kubectl` from `minikube` arguments since both have their own sets of arguments):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，目前没有任何内容在运行，因为我们刚刚启动了一个新的集群。让我们使用一个额外的选项重新运行相同的命令——也就是`--all-namespaces`（注意`kubectl`和`get`之间的两个额外破折号；它们用于将`kubectl`与`minikube`的参数分开，因为这两个命令各自有不同的参数集）：
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output has changed quite a bit and we can now see all those components
    of Kubernetes that we learned about at the beginning of this chapter: `kube-apiserver`,
    `kube-controller-manager`, `kube-proxy`, `kube-scheduler`, `etcd`, and a couple
    of other running in individual pods in the `kube-system` namespace.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已经发生了很大变化，现在我们可以看到在本章开头学习的所有 Kubernetes 组件：`kube-apiserver`、`kube-controller-manager`、`kube-proxy`、`kube-scheduler`、`etcd`以及其他几个在`kube-system`命名空间中的独立
    Pods 中运行的组件。
- en: Kubernetes namespaces
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 命名空间
- en: Kubernetes namespaces provide a grouping mechanism to separate Kubernetes objects
    within a cluster. It is common to use Kubernetes namespaces to group workloads
    per team, project, or application. The `kube-system` namespace is reserved for
    Kubernetes’s components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 命名空间提供了一种分组机制，用于在集群内区分 Kubernetes 对象。通常，Kubernetes 命名空间用于按团队、项目或应用程序分组工作负载。`kube-system`命名空间是为
    Kubernetes 的组件保留的。
- en: 'Now, let’s see which namespaces we have in our new shiny Kubernetes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在我们全新的 Kubernetes 中有哪些命名空间：
- en: '[PRE5]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `default` namespace, as its name suggests, is simply a standard namespace
    where container workloads will be created by default. `kube-node-lease` is another
    reserved Kubernetes namespace for node heartbeats (checks that determine that
    the node is running) and `kube-public` is an automatically created namespace for
    public resources such as those required for cluster discovery.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`命名空间，顾名思义，实际上就是一个标准的命名空间，容器工作负载将在该命名空间中默认创建。`kube-node-lease`是另一个为节点心跳（检查节点是否运行）的
    Kubernetes 保留命名空间，`kube-public`是一个自动创建的命名空间，用于公共资源，例如集群发现所需的资源。'
- en: 'Normal practice is to create new namespaces either per application, group of
    microservices working together, or per team. Let’s create a new namespace and
    call it `kcna` by executing `kubectl -- create` `namespace kcna`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一般做法是为每个应用程序、合作工作的微服务组或每个团队创建新的命名空间。让我们创建一个新的命名空间并命名为`kcna`，通过执行`kubectl --
    create` `namespace kcna`：
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also set up an alias for `minikube kubectl`, as suggested in the minikube
    documentation (`$ alias kubectl="minikube kubectl --"`) to skip writing `minikube`
    every time. (Make sure that you remove it when you’re not using `minikube` anymore.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置一个别名来代替`minikube kubectl`，正如 minikube 文档中建议的那样（`$ alias kubectl="minikube
    kubectl --"`），以便省去每次都写`minikube`的麻烦。（确保在不再使用`minikube`时删除它。）
- en: 'Now, let’s deploy a containerized *Nginx* web server into our new `kcna` namespace.
    We can always set the namespace where we want to execute the `kubectl` command
    by adding the `--``namespace` argument:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将一个容器化的*Nginx* Web 服务器部署到我们新的`kcna`命名空间中。我们可以通过添加`--namespace`参数来始终设置我们想要执行`kubectl`命令的命名空间：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we provided a pod spec file that is located in the examples shown on
    the [https://k8s.io/](https://k8s.io/) web page. The Kubernetes CLI is smart enough
    to download the file, validate the spec, and apply it to create the objects it
    defines – in this case, a single pod with Nginx. If we were to write this simple
    pod specification ourselves in YAML format, it would look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们提供了一个 Pod 规范文件，该文件位于 [https://k8s.io/](https://k8s.io/) 网页上显示的示例中。Kubernetes
    CLI 足够智能，可以下载文件，验证规范并应用它，创建它所定义的对象——在本例中，是一个包含 Nginx 的单一 Pod。如果我们自己编写这个简单的 Pod
    规范文件并以 YAML 格式保存，它会像这样：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s see what each line of this spec file means.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看该规范文件的每一行代表什么。
- en: '`apiVersion: v1` defines which version of the Kubernetes API we are using to
    create this object. As you know, Kubernetes APIs evolve from alpha to beta to
    stable versions. `v1` is the stable version in this example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1` 定义了我们用于创建该对象的 Kubernetes API 版本。如你所知，Kubernetes 的 API 会从 alpha
    发展到 beta，再到稳定版本。`v1` 是本示例中的稳定版本：'
- en: '`kind: Pod` – Defines the kind of object we are describing.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind: Pod` – 定义了我们描述的对象类型。'
- en: '`metadata:` – Defines metadata for the object, such as `name` or further annotations.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata:` – 定义对象的元数据，如 `name` 或其他注解。'
- en: '`name: nginx` – Defines the name of the pod.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name: nginx` – 定义 Pod 的名称。'
- en: '`spec:` – Defines the block where we describe the desired state of the object.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec:` – 定义了我们描述对象期望状态的块。'
- en: '`containers:` – Defines the list of containers that are part of this pod.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers:` – 定义了作为该 Pod 一部分的容器列表。'
- en: '`-` `name:` `nginx` – The name of the first container in the Pod. Multiple
    containers can run together in one pod.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` `name:` `nginx` – Pod 中第一个容器的名称。多个容器可以在一个 Pod 中一起运行。'
- en: '`image: nginx:1.14.2` – The name of the image (`nginx`) that can be optionally
    preceded by the image registry URL and followed by the image tag (`1.14.2`). If
    you run multiple containers in one pod, you’ll need to define the image and name
    for each one.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image: nginx:1.14.2` – 镜像的名称（`nginx`），可以选择在前面加上镜像仓库 URL，后面跟上镜像标签（`1.14.2`）。如果在一个
    Pod 中运行多个容器，您需要为每个容器定义镜像和名称。'
- en: '`ports:` – This is an optional informational block that tells us about which
    ports are to be exposed. Those are the ports where the process in the container
    is listening on. However, not specifying this block does not prevent ports from
    being exposed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports:` – 这是一个可选的信息块，用于告知我们哪些端口将被暴露。这些端口是容器中进程正在监听的端口。然而，不指定此块并不会阻止端口暴露。'
- en: '`- containerPort: 80` – This is port `80` in this example.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- containerPort: 80` – 这是本示例中的端口`80`。'
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: The indentation is very important in YAML format and one missing space or an
    extra space can make it invalid. `kubectl` will complain if there are parsing
    errors when applying a specification. It is recommended to copy example files
    from this book’s GitHub repository to avoid typos and formatting mistakes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 格式中缩进非常重要，缺少一个空格或多出一个空格都会导致格式错误。如果应用规范时存在解析错误，`kubectl` 会报错。建议从本书的 GitHub
    仓库复制示例文件，以避免拼写和格式错误。
- en: Alright, so, what happened with our Nginx pod?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么，我们的 Nginx Pod 出了什么问题？
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is in a `Running` status and `1/1` (one out of one) containers in the pod
    are ready. There are several statuses the pod might be in:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它处于 `Running` 状态，并且 Pod 中的 `1/1`（一个中的一个）容器已就绪。Pod 可能处于多种状态：
- en: '`Pending`: The specification has been accepted by Kubernetes and, currently,
    the pod is waiting to be scheduled or for a requested container image to be downloaded
    from the image registry.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pending`: 规范已被 Kubernetes 接受，当前 Pod 正在等待调度，或等待从镜像仓库下载所请求的容器镜像。'
- en: '`Running`: The pod is assigned to a certain node and all containers in the
    pod have been created. At least one container is running.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Running`: Pod 已被分配到某个节点，并且 Pod 中的所有容器都已创建。至少有一个容器正在运行。'
- en: '`Succeeded`: All the containers in the pod have successfully finished/exited
    with a *good* exit code (for example zero). This happens when, for example, an
    application in a container has gracefully shut down.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Succeeded`: Pod 中的所有容器已成功完成/退出，且以 *良好* 的退出代码（例如零）退出。当容器中的应用程序正常关闭时，会发生这种情况。'
- en: '`Failed`: All the containers in the pod terminated and at least one has failed;
    for example, it has exited with a non-zero exit code.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Failed`: Pod 中的所有容器都已终止，并且至少有一个容器失败；例如，容器以非零退出代码退出。'
- en: '`Unknown`: The state of the pod cannot be obtained. This might happen when
    a node where the pod should be running is unreachable, for example, due to network
    issues.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unknown`：无法获取 pod 的状态。这可能发生在 Pod 应该运行的节点无法访问时，例如，由于网络问题。'
- en: '`ErrImagePull` : The image specified in the manifest cannot be retrieved (pulled).
    This might be due to a wrong image name or wrong tag that does not exist in the
    registry.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrImagePull` ：清单中指定的镜像无法获取（拉取）。这可能是由于镜像名称错误或标签错误，导致镜像在镜像库中不存在。'
- en: Additionally, you might encounter a `ContainerCreating` or `Terminating` status
    describing the startup or termination phase of pod containers, respectively.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能会遇到 `ContainerCreating` 或 `Terminating` 状态，分别描述 Pod 容器的启动或终止阶段。
- en: 'Currently, our Nginx pod does nothing; it does not serve any applications or
    content except for its default static page. In the next chapter, we will learn
    how to expose and access applications in Kubernetes with the `nginx` pod using
    the `kubectl` `describe` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 Nginx pod 什么也不做；除了它的默认静态页面外，不提供任何应用程序或内容。在下一章中，我们将学习如何使用 `kubectl describe`
    命令在 Kubernetes 中暴露和访问 `nginx` pod 中的应用程序。
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You’ll find a lot of information about the pod, such as the node where it runs,
    its start time, IP address, environment variables, recent events, and much more.
    This information is very helpful for cases when we need to debug failing pods
    or applications.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现关于 pod 的大量信息，例如运行它的节点、启动时间、IP 地址、环境变量、最近的事件等。此信息对于我们调试失败的 pod 或应用程序非常有帮助。
- en: 'Now that we have used `kubectl` a bit, let’s try the Kubernetes dashboard as
    well. Minikube offers a convenient one-command dashboard installation with `minikube
    dashboard`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经稍微使用过 `kubectl`，现在也来试试 Kubernetes 仪表板。Minikube 提供了一个便捷的单命令仪表板安装，使用 `minikube
    dashboard`：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, the dashboard will be installed into a new `kubernetes-dashboard`
    namespace and your browser should automatically open it in a new tab (in case
    it did not, try executing `minikube dashboard --url` to get the URL of the dashboard).
    You’ll need to switch to another namespace in the top-left corner drop-down menu
    as there is nothing currently running in the `default` namespace. If you switch
    to the `kcna` namespace, you’ll be able to see our `nginx` pod, whereas if you
    switch to `kube-system`, you’ll see the Kubernetes control plane components that
    we described previously in this chapter. You may notice that, besides pods, there
    are **Deployment**, **Daemon Set** and **Replica Set** workloads. Those will be
    the topic of the next chapter, where we will see how these can be used to create
    pods and learn about the features of those K8s resources.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，仪表板将被安装到新的 `kubernetes-dashboard` 命名空间中，浏览器应会自动在新标签页中打开它（如果没有自动打开，请尝试执行 `minikube
    dashboard --url` 以获取仪表板的 URL）。你需要在左上角的下拉菜单中切换到另一个命名空间，因为 `default` 命名空间中当前没有任何内容。如果你切换到
    `kcna` 命名空间，你将看到我们的 `nginx` pod，而如果切换到 `kube-system`，你将看到我们在本章中描述的 Kubernetes
    控制平面组件。你可能会注意到，除了 pod，还有 **Deployment**、**Daemon Set** 和 **Replica Set** 工作负载。它们将在下一章中讨论，届时我们将看到如何使用它们来创建
    pod，并了解这些 K8s 资源的特点。
- en: 'Feel free to explore the dashboard a little more by yourself; when you’re done,
    delete our Nginx pod using the dashboard or via the `kubectl delete` command.
    To interrupt `minikube dashboard`, you can use *Ctrl* + *C* shortcut:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以自己探索更多的仪表板；当你完成后，可以使用仪表板或通过 `kubectl delete` 命令删除我们的 Nginx pod。要中断 `minikube
    dashboard`，你可以使用 *Ctrl* + *C* 快捷键：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`kubectl` is a user-friendly tool that allows you to type `pod`, `pods`, or
    simply `po`, all of which mean the same thing. It also has a lot of convenient
    short names, such as `ns`, for namespaces. To list all short names, run `minikube`
    `kubectl api-resources`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是一个用户友好的工具，允许你输入 `pod`、`pods` 或简单地输入 `po`，它们的意思是一样的。它还拥有很多便捷的简短名称，例如
    `ns`，代表命名空间。要列出所有简短名称，请运行 `minikube` `kubectl api-resources`。'
- en: 'If you are about to shut down your workstation before moving on to the next
    chapter, you can also temporarily stop your Kubernetes node by executing the `minikube`
    `stop` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在进入下一章之前准备关闭工作站，你也可以通过执行 `minikube` `stop` 命令临时停止你的 Kubernetes 节点：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This has been a long and very intense chapter, so congrats on making it this
    far! Take a break before moving on to the next chapter and make sure you answer
    the questions provided.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章内容较长且非常密集，恭喜你已经走到了这一部分！在进入下一章之前，先休息一下，并确保回答提供的问题。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we finally got our hands on Kubernetes. We learned a lot about
    its architecture, components, and API. Kubernetes clusters consist of control
    plane (also known as the master) and worker nodes, where control plane nodes run
    K8s management components and worker nodes run the actual containerized applications
    with the help of *kubelet*, *container runtime*, and *kube-proxy*. Among the master
    node components, there’s *kube-apiserver*, *etcd*, *kube-scheduler*, *kube-controller-manager*,
    and, optionally, *cloud-controller-manager*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于接触到了 Kubernetes。我们了解了很多关于它的架构、组件和 API。Kubernetes 集群由控制平面（也称为主节点）和工作节点组成，其中控制平面节点运行
    K8s 管理组件，工作节点在 *kubelet*、*容器运行时* 和 *kube-proxy* 的帮助下运行实际的容器化应用程序。在主节点组件中，有 *kube-apiserver*、*etcd*、*kube-scheduler*、*kube-controller-manager*，以及可选的
    *cloud-controller-manager*。
- en: We saw that a *pod* is the smallest deployable unit of Kubernetes and that it
    allows us to run individual containers as well as multiple containers together
    on K8s. Containers inside one pod are coupled and can share storage, network,
    and memory. The secondary container in the pod is typically called the *sidecar*
    and can help the container run the main application by doing log aggregation,
    for example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 *pod* 是 Kubernetes 中最小的可部署单元，它允许我们在 K8s 上运行单独的容器，也可以将多个容器一起运行。一个 pod 内的容器是耦合的，可以共享存储、网络和内存。pod
    中的辅助容器通常被称为 *sidecar*，它可以通过做日志聚合等任务来帮助主容器运行主应用程序。
- en: The Kubernetes API is *declarative*. When we work with K8s, we describe the
    desired state of resources in the cluster; Kubernetes ensures that the current
    state reaches the desired state after object creation. Due to rapid development,
    Kubernetes APIs are grouped and multi-versioned, and by default only enable *beta*
    and *stable* (GA) features. There are several ways to access the Kubernetes API,
    with the *kubectl* CLI and *dashboard* being the most popular ones. One of the
    specialties of K8s is its ability to extend its APIs through CRDs and aggregation
    layers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 是 *声明式* 的。当我们使用 K8s 时，我们描述集群中资源的期望状态；Kubernetes 确保在对象创建后，当前状态会达到期望状态。由于开发的快速发展，Kubernetes
    API 被分组并多版本化，默认情况下仅启用 *beta* 和 *稳定*（GA）特性。有多种方式可以访问 Kubernetes API，其中 *kubectl*
    CLI 和 *仪表板* 是最常用的方式。K8s 的一个特色是它能够通过 CRD 和聚合层扩展其 API。
- en: When it comes to features, Kubernetes has a lot to offer, ranging from automatic
    rollouts, service discovery, and secret management to auto-scaling, self-healing,
    and even storage orchestration. We will try many of those features in practice
    in the next few chapters. It is also possible to use Kubernetes to manage virtual
    machines or provide FaaS with the help of separate projects such as *KubeVirt*
    and *Knative*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 说到功能，Kubernetes 提供了很多强大功能，从自动滚动发布、服务发现、和密钥管理，到自动扩展、自我修复，甚至存储编排。我们将在接下来的章节中实践其中许多功能。还可以借助
    *KubeVirt* 和 *Knative* 等独立项目，使用 Kubernetes 来管理虚拟机或提供 FaaS。
- en: In the last section, we installed a simple one-node Kubernetes deployment using
    the *minikube* project and learned about the concept of Kubernetes *namespaces*
    for resource separation and grouping. We also created a pod with a single Nginx
    container and explored the minimal pod spec definition in YAML format.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们使用 *minikube* 项目安装了一个简单的单节点 Kubernetes 部署，并了解了 Kubernetes *命名空间* 的概念，用于资源的隔离和分组。我们还创建了一个包含单个
    Nginx 容器的 pod，并探索了 YAML 格式的最简 pod 规格定义。
- en: In the next chapter, we will learn about other Kubernetes resources and their
    usage. We will learn how to configure and scale multi-container applications with
    Kubernetes, how to run stateful workloads with Kubernetes, and learn about exposing
    applications running in K8s.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习其他 Kubernetes 资源及其使用方法。我们将学习如何使用 Kubernetes 配置和扩展多容器应用程序，如何使用 Kubernetes
    运行有状态工作负载，以及了解如何暴露在 K8s 上运行的应用程序。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结时，这里有一系列问题供您测试有关本章内容的知识。您可以在*附录*的*评估*部分找到答案：
- en: Which of the following is the smallest schedulable unit in Kubernetes?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是 Kubernetes 中最小的可调度单元？
- en: Container
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器
- en: Sidecar
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边车
- en: Pod
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pod
- en: Deployment
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署
- en: Containers running in one pod share which of the following options (pick multiple)?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 pod 中运行的容器共享以下哪些选项（可选择多个）？
- en: Name
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称
- en: Storage
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储
- en: Networking
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络
- en: Memory
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存
- en: Which of the following types of nodes does Kubernetes have (pick multiple)?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 Kubernetes 节点类型有哪些（选择多个）？
- en: Secondary
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Secondary
- en: Master
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主节点
- en: Worker
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作节点
- en: Primary
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Primary
- en: Which of the following are components of control plane nodes (pick multiple)?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是控制平面节点的组件（选择多个）？
- en: Docker, kube-scheduler, cloud-controller-manager
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker, kube-scheduler, cloud-controller-manager
- en: kube-master-server, kubelet, kube-proxy
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-master-server, kubelet, kube-proxy
- en: kube-scheduler, kube-controller-manager
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-scheduler, kube-controller-manager
- en: kube-api-server, etcd
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-api-server, etcd
- en: Which of the following K8s cluster configuration can be recommended?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个 K8s 集群配置可以推荐？
- en: 1 master node, 5 worker nodes
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1 个主节点，5 个工作节点
- en: 2 master nodes, 3 worker nodes
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 个主节点，3 个工作节点
- en: 2 master nodes, 20 worker nodes
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 个主节点，20 个工作节点
- en: 3 master nodes, 10 worker nodes
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 个主节点，10 个工作节点
- en: Which of the following components are used to store cluster state in Kubernetes?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些组件用于存储 Kubernetes 集群状态？
- en: kube-api-server
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-api-server
- en: kube-volume
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-volume
- en: kubelet
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kubelet
- en: etcd
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: etcd
- en: Which of the following components is used by Kubernetes to download images and
    start containers?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个组件是 Kubernetes 用来下载镜像并启动容器的？
- en: Kubelet
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubelet
- en: Container runtime
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器运行时
- en: etcd
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: etcd
- en: kube-proxy
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-proxy
- en: Which of the following components is responsible for Kubernetes controller processes?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个组件负责 Kubernetes 控制器流程？
- en: kube-api-server
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-api-server
- en: kube-proxy
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-proxy
- en: kube-controller-manager
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: kube-scheduler
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: What can be used to access the Kubernetes API (pick multiple)?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些可以用来访问 Kubernetes API（选择多个）？
- en: kubeadmin
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kubeadmin
- en: kubectl
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kubectl
- en: kubelet
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kubelet
- en: dashboard
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: dashboard
- en: Kubernetes has a declarative API. What does this mean?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 有一个声明式 API，这意味着什么？
- en: We always need to declare a YAML spec file to use the K8s API
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们总是需要声明一个 YAML 规格文件来使用 K8s API
- en: We declare the desired state and K8s will reach it once
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明期望的状态，K8s 将会在某个时刻达到这个状态
- en: We tell Kubernetes exactly what to do with which resource
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉 Kubernetes 如何处理哪些资源
- en: We declare the desired state and K8s will constantly try to reach it
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明期望的状态，K8s 将会不断努力达成这个状态
- en: Which of the following Kubernetes API versions are enabled by default (pick
    multiple)?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些 Kubernetes API 版本默认启用（选择多个）？
- en: Alpha
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alpha
- en: Beta
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Beta
- en: Gamma
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gamma
- en: Stable
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稳定
- en: How can you extend the Kubernetes API with new features (pick multiple)?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何扩展 Kubernetes API 添加新功能（选择多个）？
- en: Code Resource Definitions
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码资源定义
- en: Aggregation layers
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合层
- en: Extension layers
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展层
- en: Custom Resource Definitions
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义资源定义
- en: Which of the following projects allows you to extend Kubernetes beyond container
    orchestration (pick multiple)?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个项目允许你将 Kubernetes 扩展到容器编排之外（选择多个）？
- en: Knative for FaaS
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Knative 用于 FaaS
- en: Linkerd for IPAM
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linkerd 用于 IPAM
- en: Kvirt for VM orchestration
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kvirt 用于虚拟机编排
- en: KubeVirt for VM orchestration
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: KubeVirt 用于虚拟机编排
- en: What helps detect the difference between the current and desired state of Kubernetes
    resources?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么有助于检测 Kubernetes 资源当前状态与期望状态之间的差异？
- en: Container runtime
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器运行时
- en: Kubernetes scheduler
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 调度器
- en: Custom Resource Definition
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义资源定义
- en: Reconciliation loop
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协调循环
- en: What are secondary containers running in pod called?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是运行在 pod 中的次要容器？
- en: Flatcars
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flatcars
- en: Sidecars
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sidecars
- en: Podcars
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Podcars
- en: Helpcars
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helpcars
- en: Which of the following formats is used to write Kubernetes spec files?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个格式用于编写 Kubernetes 规格文件？
- en: CSV
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSV
- en: Protobuf
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Protobuf
- en: YAML
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: YAML
- en: Marshal
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Marshal
- en: Which of the following Kubernetes components is responsible for allocating new
    pods to nodes?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个 Kubernetes 组件负责将新 pod 分配到节点上？
- en: kube-api
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-api
- en: kube-proxy
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-proxy
- en: kube-scheduler
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: kube-controller-manager
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: Which of the following K8s CLI commands can be used to list pods in the `development`
    namespace?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个 K8s CLI 命令可以用来列出 `development` 命名空间中的 pods？
- en: '`kubectl list pods -``n development`'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl list pods -``n development`'
- en: '`kubectl get pods --``namespace development`'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl get pods --``namespace development`'
- en: '`kubectl show pods --``namespace development`'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl show pods --``namespace development`'
- en: '`kubectl get` `pods --all-namespaces`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl get` `pods --all-namespaces`'
- en: Which of the following K8s CLI commands can be used to list all the namespaces
    in the cluster?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个 K8s CLI 命令可以用来列出集群中的所有命名空间？
- en: '`kubectl list` `namespaces --all-namespaces`'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl list` `namespaces --all-namespaces`'
- en: '`kubectl` `show namespaces`'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl` `show namespaces`'
- en: '`kubectl` `get namespaces`'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl` `get namespaces`'
- en: '`kubectl` `get all`'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl` `get all`'
- en: Which of the following pod statuses means its container(s) are currently executing?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个 pod 状态表示其容器正在执行？
- en: Executing
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行中
- en: Succeeded
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功
- en: Running
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行中
- en: ContainerCreated
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ContainerCreated
- en: Which of the following pod statuses means all its containers are running (pick
    multiple)?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些 Pod 状态表示其所有容器都在运行（可多选）？
- en: 100%
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 100%
- en: 1/2
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1/2
- en: 2/2
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2/2
- en: 1/1
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1/1
- en: Further reading
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解本章中涵盖的更多内容，请查看以下资源：
- en: 'Minikube troubleshooting guide: [https://minikube.sigs.k8s.io/docs/handbook/troubleshooting/](https://minikube.sigs.k8s.io/docs/handbook/troubleshooting/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Minikube 故障排除指南: [https://minikube.sigs.k8s.io/docs/handbook/troubleshooting/](https://minikube.sigs.k8s.io/docs/handbook/troubleshooting/)'
- en: 'Commonly used `kubectl` commands: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '常用的 `kubectl` 命令: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)'
- en: 'K8s pods concept: [https://kubernetes.io/docs/concepts/workloads/pods/](https://kubernetes.io/docs/concepts/workloads/pods/)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'K8s Pod 概念: [https://kubernetes.io/docs/concepts/workloads/pods/](https://kubernetes.io/docs/concepts/workloads/pods/)'
- en: 'K8s namespace concept: [https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'K8s 命名空间概念: [https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/)'
