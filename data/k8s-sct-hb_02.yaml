- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Walking through Kubernetes Secrets Management Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步了解 Kubernetes Secrets 管理概念
- en: In the previous chapter, we had a good overview of Kubernetes, the components
    that Kubernetes consists of, and how configurations are applied and stored. Also,
    we built a Golang application and managed to run this application on Kubernetes.
    As expected, Secrets had to be added to our application’s configuration. Secrets
    management comes with various concerns. From creation to modification to deletion,
    we need to tackle security concerns as well as scalability and resiliency.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对 Kubernetes 及其组成组件进行了全面概述，并了解了配置是如何应用和存储的。此外，我们构建了一个 Golang 应用，并成功地在
    Kubernetes 上运行了该应用。正如预期的那样，Secrets 需要被添加到我们的应用配置中。Secrets 管理涉及多种问题。从创建、修改到删除，我们需要解决安全性、可扩展性和弹性等方面的挑战。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What are Kubernetes Secrets, and how do they differ from other Kubernetes objects?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes Secrets，它与其他 Kubernetes 对象有何不同？
- en: Different types of Secrets and their usage scenarios
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的 Secrets 及其使用场景
- en: Creating, modifying, and deleting Secrets in Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中创建、修改和删除 Secrets
- en: Kubernetes Secrets configuration in different deployment scenarios
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同部署场景中的 Kubernetes Secrets 配置
- en: Requirement for managing Secrets, including secure storage and access control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理机密的要求，包括安全存储和访问控制
- en: Securing access to Secrets with RBAC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RBAC 保护对 Secrets 的访问
- en: Auditing and monitoring Secret usage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计和监控 Secret 使用情况
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To link concepts to hands-on examples, we will leverage a series of tools and
    platforms commonly used to interact with containers, Kubernetes, and Secrets management.
    For this chapter, we will ramp up with a friendly desktop graphical solution:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将概念与实践示例结合，我们将利用一系列常用的工具和平台，这些工具和平台通常用于与容器、Kubernetes 和 Secrets 管理进行交互。本章中，我们将使用一个友好的桌面图形解决方案：
- en: '**Podman Desktop** ([https://podman-desktop.io](https://podman-desktop.io))
    is an **open source software** (**OSS**) that interacts with containers, runs
    local Kubernetes instances, and even connects with remote platforms such as Red
    Hat OpenShift, **Azure Kubernetes Service** (**AKS**), and more. We will use the
    Go programming language in this chapter. To install Go on your system, you can
    follow the instructions from the official documentation ([https://go.dev/doc/install](https://go.dev/doc/install)).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Podman Desktop** ([https://podman-desktop.io](https://podman-desktop.io))
    是一个**开源软件**（**OSS**），它与容器进行交互，运行本地 Kubernetes 实例，甚至连接远程平台，如 Red Hat OpenShift、**Azure
    Kubernetes Service**（**AKS**）等。在本章中，我们将使用 Go 编程语言。要在系统中安装 Go，可以参考官方文档中的安装说明（[https://go.dev/doc/install](https://go.dev/doc/install)）。'
- en: In this chapter, **minikube** will also be used. To install minikube on your
    system, you can follow the instructions from the official documentation ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，还将使用 **minikube**。要在系统中安装 minikube，可以参考官方文档中的安装说明（[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)）。
- en: All of the code examples in the book are available on our dedicated GitHub repository
    with a clear structure and instruction set, with corresponding folders for each
    chapter ([https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中的所有代码示例都可以在我们的专用 GitHub 仓库中找到，仓库结构清晰，并且为每一章提供了相应的文件夹和说明（[https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook](https://github.com/PacktPublishing/Kubernetes-Secrets-Handbook)）。
- en: What are Kubernetes Secrets, and how do they differ from other Kubernetes objects?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes Secrets，它与其他 Kubernetes 对象有何不同？
- en: One of the fundamental building blocks of Kubernetes is Kubernetes objects.
    Through Kubernetes objects, we can represent the state of the system. An application
    running on Kubernetes consists of the actual program, the resources the application
    uses, and the configurations of the application such as health checks. With regard
    to other cross-cutting concerns such as security, there are configurations for
    **role-based access control** (**RBAC**); these include cluster-wide roles, namespace
    roles, and the role bindings to a user or entity. Furthermore, Kubernetes objects
    include namespaces, which act as logical containers, and network policies, which
    are cluster-wide traffic rules. By creating Kubernetes objects, we declare the
    desired state of the cluster. Kubernetes is responsible for and will work toward
    ensuring that the actual state of the system matches the state defined by the
    objects we create.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的一个基本构建模块是 Kubernetes 对象。通过 Kubernetes 对象，我们可以表示系统的状态。运行在 Kubernetes
    上的应用程序包括实际的程序、应用程序使用的资源和应用程序的配置（如健康检查）。关于其他横向关注点，如安全性，存在 **基于角色的访问控制**（**RBAC**）配置；这些配置包括集群范围的角色、命名空间角色以及与用户或实体绑定的角色。此外，Kubernetes
    对象还包括命名空间，它们充当逻辑容器，以及网络策略，它们是集群范围的流量规则。通过创建 Kubernetes 对象，我们声明了集群的期望状态。Kubernetes
    负责并将致力于确保系统的实际状态与我们创建的对象所定义的状态匹配。
- en: 'A typical Kubernetes object has certain mandatory fields: `apiVersion`, `kind`,
    `metadata`, and `spec`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 Kubernetes 对象有一些必填字段：`apiVersion`、`kind`、`metadata` 和 `spec`。
- en: 'We can see its YAML representation as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它的 YAML 表示如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The most common Kubernetes objects that a Kubernetes user will stumble upon
    are the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 用户最常接触到的 Kubernetes 对象如下：
- en: '`Pod`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pod`'
- en: '`Deployment`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deployment`'
- en: '`StatefulSet`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StatefulSet`'
- en: '`Cronjob`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cronjob`'
- en: '`Service`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`'
- en: '`Ingress`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ingress`'
- en: '`NetworkPolicy`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkPolicy`'
- en: '`ConfigMap`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigMap`'
- en: '`Secret`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Secret`'
- en: The preceding objects can be logically grouped into objects representing workloads.
    Objects such as `Pod`, `Deployment`, `StatefulSet`, and `Cronjob` are used to
    define computing resources that will execute certain tasks; those can be running
    a server, executing a cronjob, or even setting up a distributed memory grid. Objects
    such as `Service`, `Ingress`, and `NetworkPolicy` specify networking aspects of
    our application; this can be load balancing traffic internally, exposing Kubernetes
    services to the internet, as well as blocking traffic internally between applications.
    So far, the Kubernetes objects mentioned are targeted toward application deployments
    to compute resources and traffic routing between applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的对象可以逻辑上归为表示工作负载的对象。像 `Pod`、`Deployment`、`StatefulSet` 和 `Cronjob` 这样的对象用于定义执行特定任务的计算资源；这些任务可能是运行服务器、执行定时任务，甚至设置分布式内存网格。像
    `Service`、`Ingress` 和 `NetworkPolicy` 这样的对象指定了应用程序的网络方面；这可以是负载均衡内部流量、将 Kubernetes
    服务暴露到互联网，或在应用程序之间阻止内部流量。到目前为止，提到的 Kubernetes 对象都针对应用程序的计算资源部署和应用程序之间的流量路由。
- en: '`ConfigMap` and `Secret` are different in their usage since they are targeted
    toward configuration storage. `ConfigMap` and `Secret` are objects consumed by
    applications running on Kubernetes. `ConfigMap` can be used for storing configurations.
    Common examples of configurations can be an `nginx` configuration stored in `nginx.conf`,
    a JSON-based configuration, or an application configuration based on YAML. `Secret`
    objects are for sensitive data. Take, for example, a `nginx` configuration; we
    need a TLS key stored in a `.key` file and a certificate stored in a `.pem` file.
    Both are sensitive files and need to be handled securely. This secure handling
    should also apply to credentials such as usernames and passwords or access tokens.
    Essentially, Kubernetes Secrets are Kubernetes objects used in order to store
    sensitive configuration data, thus access should be restricted and the information
    stored in Secrets should be handled securely.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMap` 和 `Secret` 在使用上有所不同，因为它们分别用于配置存储。`ConfigMap` 和 `Secret` 是由在 Kubernetes
    上运行的应用程序使用的对象。`ConfigMap` 可以用来存储配置，常见的配置示例包括存储在 `nginx.conf` 中的 `nginx` 配置、基于
    JSON 的配置，或基于 YAML 的应用程序配置。`Secret` 对象用于存储敏感数据。例如，在 `nginx` 配置中，我们需要存储在 `.key`
    文件中的 TLS 密钥和存储在 `.pem` 文件中的证书。这两者都是敏感文件，需要安全处理。此安全处理还应适用于用户名和密码、访问令牌等凭证。实际上，Kubernetes
    Secrets 是用于存储敏感配置数据的 Kubernetes 对象，因此应该限制访问，并确保以安全的方式处理 Secrets 中存储的信息。'
- en: Different types of Secrets and their usage scenarios
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的 Secrets 及其使用场景
- en: Kubernetes provides us with various types of Secrets. Behind the scenes, it
    uses the same storage mechanism that we saw in [*Chapter 1*](B20970_01.xhtml#_idTextAnchor015),
    *Understanding Kubernetes Secrets Management*; Secrets, once created, will be
    serialized and stored on `etcd`. What differs is how those Secrets are handled
    when used. There are various types of Secrets; let us examine them one by one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 为我们提供了多种类型的 Secrets。在幕后，它使用我们在 [*第 1 章*](B20970_01.xhtml#_idTextAnchor015)
    中看到的相同存储机制，*理解 Kubernetes Secrets 管理*；一旦创建，Secrets 将被序列化并存储在 `etcd` 中。不同之处在于这些
    Secrets 在使用时的处理方式。Secrets 有多种类型，让我们逐一查看。
- en: Opaque
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Opaque
- en: An Opaque secret is the default secret type. Whenever we want to add a sensitive
    configuration, whether it is a file or a variable, it will be created as an Opaque
    secret.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Opaque secret 是默认的 secret 类型。每当我们需要添加敏感配置时，无论是文件还是变量，它都会作为 Opaque secret 创建。
- en: 'Opaque Secrets can be used by providing key values:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Opaque Secrets 可以通过提供键值对来使用：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Opaque Secrets can also be executed by applying a YAML file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Opaque Secrets 也可以通过应用 YAML 文件来执行：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The examples for Opaque Secrets are available in the `ch02/secret-types/opaque`
    folder. The `opaque.sh` script will run the Bash commands needed to achieve the
    end result.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Opaque Secrets 的示例可以在 `ch02/secret-types/opaque` 文件夹中找到。`opaque.sh` 脚本将运行所需的
    Bash 命令以实现最终结果。
- en: Kubernetes service account token
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 服务账户令牌
- en: A Pod is a unit of work on Kubernetes; a Pod that needs to interact with the
    Kubernetes API is in need of an identity. A service account is an identity that
    can be mapped to Pods directly or transitively through a deployment. A Pod can
    interact with the Kubernetes API, provided it has a service account attached.
    The service account attached is authorized to access resources of interest. On
    startup, the Pod with a service account configured has a service account token
    attached to its filesystem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是 Kubernetes 中的一个工作单元；需要与 Kubernetes API 进行交互的 Pod 需要一个身份。服务账户是可以直接或通过部署间接映射到
    Pod 的身份。只要 Pod 配置了服务账户，它就可以与 Kubernetes API 进行交互。附加的服务账户被授权访问感兴趣的资源。在启动时，配置了服务账户的
    Pod 会将服务账户令牌附加到其文件系统上。
- en: Long-lived access token
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长期有效的访问令牌
- en: On Kubernetes, prior to version v1.27, a service account token would be accessible
    as a Kubernetes secret managed by Kubernetes. This is called a long-lived access
    token.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，在 v1.27 版本之前，服务账户令牌会作为 Kubernetes 管理的 Kubernetes secret 进行访问。这被称为长期有效的访问令牌。
- en: 'It’s still possible to create a long-lived access token in the latest versions.
    This can be achieved by creating an empty secret and putting an annotation with
    the name of the service account:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本中，仍然可以创建长期有效的访问令牌。可以通过创建一个空的 secret 并在其中添加一个带有服务账户名称的注解来实现：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, we note the service account in the `annotations` section. By
    running the `apply` command, we should see that a token has been generated:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们注意到在 `annotations` 部分中有服务账户。通过运行 `apply` 命令，我们应该能够看到生成了一个令牌：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instructions to create long-lived access tokens are available in the following
    script: `ch02/secret-types/service-account/long-live-access-token.sh`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建长期有效访问令牌的步骤可以参考以下脚本：`ch02/secret-types/service-account/long-live-access-token.sh`
- en: Service account token mounted on Pod
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务账户令牌已挂载到 Pod
- en: We’ve seen a service account as a secret; let us see how a service account token
    is mounted to a Pod.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过服务账户作为 secret 的情况；现在让我们看看如何将服务账户令牌挂载到 Pod 上。
- en: 'A Pod with a service account should look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有服务账户的 Pod 应该是这样的：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we apply the preceding YAML manifest, we can run a command within the
    Pod we just scheduled. We will print the service account token mounted as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了前面的 YAML 清单，我们可以在刚刚调度的 Pod 中运行一个命令。我们将按如下方式打印挂载的服务账户令牌：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, it is a **JSON Web Token** (**JWT**) token.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个 **JSON Web Token** (**JWT**) 令牌。
- en: 'Instructions to create a Pod with a service account are available in the following
    script: `ch02/secret-types/service-account/service-account-with-pod.sh`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有服务账户的 Pod 的步骤可以参考以下脚本：`ch02/secret-types/service-account/service-account-with-pod.sh`
- en: Docker config
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 配置
- en: By using an image on a Pod, we might want to pull images from an alternative
    container registry. For this purpose, we want to mount the Docker configuration
    so that it is possible to communicate with the registry of our choice. One of
    the ways we can test this is by just using our local Docker configuration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 上使用镜像时，我们可能希望从替代的容器注册中心拉取镜像。为此，我们需要挂载 Docker 配置，以便能够与我们选择的注册中心进行通信。我们可以通过仅使用本地
    Docker 配置来测试这一点。
- en: 'We will use the following template to generate a YAML manifest:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下模板生成一个YAML清单：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see the `REPLACE_WITH_BASE64` string; this would be replaced with the
    Docker config from Docker Hub.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`REPLACE_WITH_BASE64`字符串；它将被Docker Hub的Docker配置替换。
- en: 'In the `docker-credentials` folder, there is already a Docker config file for
    that purpose at `ch02/secret-types/docker-credentials/config.json` without any
    actual credentials:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-credentials`文件夹中，已经存在一个用于此目的的Docker配置文件，位于`ch02/secret-types/docker-credentials/config.json`，其中没有实际凭证：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will issue a login and use our Docker Hub credentials:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发起登录并使用我们的Docker Hub凭证：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The file will contain the basic authentication needed to connect with Docker
    Hub:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文件将包含连接到Docker Hub所需的基本认证：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will use this config to mount it as a Kubernetes secret:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个配置将其挂载为Kubernetes机密：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our next steps, we will upload the credentials to Kubernetes by applying
    the YAML manifest we created:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将通过应用我们创建的YAML清单将凭证上传到Kubernetes：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we will create a Pod that pulls from the registry:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个Pod，从注册表拉取：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The image will be pulled using the credentials specified.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像将使用指定的凭证进行拉取。
- en: 'The preceding instructions have been orchestrated in the following script:
    `ch02/secret-types/ docker-credentials/docker-credentials.sh`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令已经通过以下脚本进行编排：`ch02/secret-types/docker-credentials/docker-credentials.sh`
- en: Basic authentication
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证
- en: Basic authentication consists of a key secret combination for the username and
    password. It gives us the option to be more declarative when specifying a basic
    authentication secret.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证由用户名和密码的密钥组合组成。它使我们能够在指定基本认证机密时提供更具声明性的方式。
- en: 'The YAML manifest should contain a value for the `username` and `password`
    keys:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: YAML清单应包含`username`和`password`键的值：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once we apply the preceding YAML manifest, the result will be very similar to
    the Opaque Secrets.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用前面的YAML清单，结果将与不透明机密非常相似。
- en: 'The preceding instructions have been orchestrated in the following script:
    `ch02/secret-types/ basic-authentication/basic-auth-secret.sh`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的指令已经通过以下脚本进行编排：`ch02/secret-types/basic-authentication/basic-auth-secret.sh`
- en: TLS client or server
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TLS客户端或服务器
- en: TLS Secrets are used to store SSL/TLS certificates. TLS Secrets can be used
    in order to be more declarative when it comes to mounting TLS certificates. However,
    a TLS secret can have direct usage when it comes to specifying an Ιngress.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TLS机密用于存储SSL/TLS证书。TLS机密可以在挂载TLS证书时提供更具声明性的方式。然而，TLS机密在指定Ingress时可以直接使用。
- en: An Ingress acts as an external load balancer to your system, serving HTTP/HTTPS
    traffic. Traffic needs to be secured using SSL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress充当系统的外部负载均衡器，处理HTTP/HTTPS流量。流量需要使用SSL进行加密。
- en: 'An SSL secret has the following format:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SSL机密具有以下格式：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By using the `ch02/secret-types/ssh/tls.sh` script, we will create a certificate
    and key that can be used on an HTTP server. The secret created will be named `ingress-tls`.
    The script used as a certificate will have a `webpage.your.hostname` host.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ch02/secret-types/ssh/tls.sh`脚本，我们将创建一个证书和密钥，可以在HTTP服务器上使用。创建的机密将命名为`ingress-tls`。作为证书使用的脚本将具有`webpage.your.hostname`主机。
- en: 'Let’s create an Ingress using TLS certificates we created previously:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前创建的TLS证书来创建Ingress：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By using the Ingress, we can define hosts and the SSL for the hosts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Ingress，我们可以为主机定义SSL配置。
- en: Note on minikube users
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于minikube用户的说明
- en: 'If you used minikube throughout the `minikube.sh` script, you should enable
    Ingress on your workstation as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在整个`minikube.sh`脚本中使用了minikube，你应该按照以下方式在工作站上启用Ingress：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now test the Ingress. Be aware that the Ingress needs to get an IP assigned:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试Ingress。请注意，Ingress需要获得一个IP地址：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since this IP might belong to an internal VM, we need to issue a `minikube
    tunnel` command, which will forward the traffic to our Ingress:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此IP可能属于内部虚拟机，我们需要执行`minikube tunnel`命令，将流量转发到我们的Ingress：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By navigating to [https://localhost/](https://localhost/), we can see the certificate:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问[https://localhost/](https://localhost/)，我们可以查看证书：
- en: '![Figure 2.1 – SSL certificate](img/B20970_02_01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – SSL证书](img/B20970_02_01.jpg)'
- en: Figure 2.1 – SSL certificate
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – SSL证书
- en: Also, if we want to validate the Ingress routing, we can change `/etc/hosts`
    and map the `webpage.your.hostname` DNS to `localhost`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想验证Ingress路由，我们可以更改`/etc/hosts`并将`webpage.your.hostname`的DNS映射到`localhost`。
- en: Token data
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Token数据
- en: This type of secret is a bootstrap token. It looks like the usual bearer token
    that we use on REST APIs; in the case of Kubernetes, it is used specifically for
    the bootstrap process of a Kubernetes cluster. When initializing a Kubernetes
    cluster, a bootstrap token is created and can then be used to join new nodes to
    the cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的 Secret 是一个引导令牌。它看起来像我们在 REST API 中使用的常规持有令牌；在 Kubernetes 中，它专门用于 Kubernetes
    集群的引导过程。在初始化 Kubernetes 集群时，会创建一个引导令牌，之后可以用它将新节点加入到集群中。
- en: Conclusion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: We had a deep dive into Kubernetes Secrets. We identified different types of
    Secrets and ran examples of each secret type, depicting their usage and peculiarities.
    For the latest developments in Secrets, you can always refer to the official documentation
    ([https://kubernetes.io/docs/concepts/configuration/secret/#secret-types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)).
    Throughout this section, the provisioning of the Secrets was done through the
    `kubectl` command line. In the next section, we will explore our options for managing
    Secrets, creating them, deleting them, and modifying them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了 Kubernetes Secrets，识别了不同类型的 Secrets，并运行了每种类型的示例，展示了它们的使用和特点。有关 Secrets
    的最新发展，您可以随时参考官方文档（[https://kubernetes.io/docs/concepts/configuration/secret/#secret-types](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types)）。在本节中，Secrets
    的配置是通过 `kubectl` 命令行完成的。在接下来的部分，我们将探索管理 Secrets 的选项，创建、删除和修改它们。
- en: Creating, modifying, and deleting Secrets in Kubernetes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中创建、修改和删除 Secrets
- en: Previously, we focused on creating Secrets and displaying their usage. We will
    proceed further on administrating Secrets and identify the available commands
    and options for provisioning Kubernetes Secrets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们专注于创建 Secrets 并展示它们的用法。接下来，我们将继续管理 Secrets，并识别可用的命令和选项来配置 Kubernetes Secrets。
- en: data and stringData
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: data 和 stringData
- en: We applied plaintext Secrets either by using a YAML file or through the command
    line. Behind the scenes, the Secrets that we applied in plaintext were converted
    to a `base64` format. We can either apply Secrets in plaintext or apply them using
    `base64`; eventually, they will end up residing on Kubernetes in a `base64` format.
    When we apply a secret using plaintext values, we use the `stringData` field.
    Kubernetes will handle the encoding and decoding of the values we provided.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 YAML 文件或命令行应用明文 Secrets。在幕后，我们应用的明文 Secrets 会被转换为 `base64` 格式。我们可以选择应用明文
    Secrets 或使用 `base64` 格式应用它们；最终，它们会以 `base64` 格式存储在 Kubernetes 中。当我们使用明文值应用一个 Secret
    时，我们使用 `stringData` 字段。Kubernetes 会处理我们提供的值的编码和解码。
- en: 'Take, for example, the following secret:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下 Secret 为例：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we create the secret, we will retrieve it. It should be in `base64`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了 Secret，我们将检索它。它应该是 `base64` 格式的：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value was stored in a `base64` format. This is a convention that Kubernetes
    follows for storing Secrets. This is especially useful if we consider the different
    variations a secret can have. A secret can have a complex value; for example,
    a large YAML file or even a binary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该值以 `base64` 格式存储。这是 Kubernetes 存储 Secrets 时遵循的一种约定。如果我们考虑到 Secret 可能具有的不同变体，这尤其有用。一个
    Secret 可能有一个复杂的值；例如，一个大型 YAML 文件或甚至是二进制文件。
- en: 'For the complex situations described previously, we have the option of the
    `data` field. When we apply Kubernetes Secrets using a `base64` format, we use
    the `data` field:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前描述的复杂情况，我们可以选择使用 `data` 字段。当我们以 `base64` 格式应用 Kubernetes Secrets 时，我们使用
    `data` 字段：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have acquired knowledge on creating Secrets, we will proceed with
    other operations such as `update` and `delete`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了创建 Secrets 的知识，我们将继续进行其他操作，比如 `update` 和 `delete`。
- en: Updating Secrets
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 Secrets
- en: When it comes to Kubernetes objects, there are some basic commands that we can
    use to manage them. Those commands apply also to Secrets since they are Kubernetes
    objects too.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 对象中，有一些基本命令可以帮助我们管理它们。这些命令同样适用于 Secrets，因为它们也是 Kubernetes 对象。
- en: Editing Secrets
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑 Secrets
- en: 'Editing a secret is done by using the `edit` command of `kubectl`. `kubectl`
    comes with a preconfigured editor. By default, the editor is Vim:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑一个 Secret 是通过使用 `kubectl` 的 `edit` 命令完成的。`kubectl` 自带一个预配置的编辑器。默认情况下，编辑器是
    Vim：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, the secret when editing will be presented in a `base64` format.
    If we try to change the secret using plaintext, we will fail. When we edit a secret,
    we must provide a `base64` value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在编辑 Secret 时，它将以 `base64` 格式呈现。如果我们尝试使用明文更改 Secret，将会失败。当我们编辑 Secret 时，必须提供一个
    `base64` 值。
- en: 'An option when editing a secret using `kubectl` is to record the command that
    causes the change using the `—``record=true` argument:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 编辑 secret 时的一个选项是通过 `—``record=true` 参数记录导致更改的命令：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, the `edit` command that we issued is recorded.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们发出的 `edit` 命令已被记录下来。
- en: 'For backup purposes as well as for keeping track of the previous state, when
    editing we can use the `—``save-config=true` argument:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 出于备份目的以及跟踪先前状态的需求，在编辑时我们可以使用 `—``save-config=true` 参数：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `last-applied-configuration` field, we will back up the previous configuration.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `last-applied-configuration` 字段中，我们将备份先前的配置。
- en: So far, we have edited Secrets and managed to keep track of the commands that
    caused the Secrets to change but also keep track of the last applied configuration.
    This is not always the case; sometimes, we might want Secrets to be immutable,
    which is something we will achieve in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编辑了 Secrets，并且成功跟踪了导致 Secrets 变化的命令，同时还记录了最后应用的配置。这并不总是如此；有时，我们可能希望
    Secrets 是不可变的，这是我们将在下一节实现的目标。
- en: Immutable Secrets
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变的 Secrets
- en: 'In certain cases, we might want our Secrets to remain unchanged; for example,
    we want to prevent accidental editing. Here’s how we can achieve that:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望我们的 Secrets 保持不变；例如，我们希望防止意外的编辑。以下是我们如何实现这一点：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we try to edit the following secret, once we try to save, we will face the
    following error message:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编辑以下 secret，一旦我们尝试保存，就会遇到以下错误消息：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Also, if we make an existing secret immutable, then it is not possible to edit
    it; the secret becomes permanently immutable. To change an immutable secret, the
    only way is to delete the secret and re-apply it. Next, we will learn how to delete
    Kubernetes Secrets.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们将现有的 secret 设置为不可变，那么它将无法被编辑；该 secret 将变得永久不可变。要修改不可变的 secret，唯一的方式是删除该
    secret 并重新应用它。接下来，我们将学习如何删除 Kubernetes Secrets。
- en: An example of showcasing immutable Secrets is provided at `ch02/secret-types/secret-management/immutable/immutable-secret.sh`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 展示不可变 Secrets 的示例可在 `ch02/secret-types/secret-management/immutable/immutable-secret.sh`
    中找到。
- en: Deleting Secrets
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除 Secrets
- en: The command for deleting a Kubernetes object also applies to Secrets.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 Kubernetes 对象的命令同样适用于 Secrets。
- en: 'The following example will delete a Kubernetes secret if it exists:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将删除一个 Kubernetes secret（如果它存在的话）：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By deleting a secret, it is permanently removed from our system. The only way
    to be able to retrieve it is either by restoring an `etcd` backup, provided it
    contains the secret, or applying a manual backup that was taken using the following
    command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除一个 secret，它将被永久从我们的系统中移除。唯一能够恢复它的方式是恢复一个包含该 secret 的 `etcd` 备份，或者应用一个通过以下命令手动备份的文件：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Conclusion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this section, we went one step further on managing Kubernetes Secrets. We
    updated Secrets, kept track of our changes, and also took a backup of the previously
    existing configuration. Furthermore, we created immutable Secrets in order to
    prevent accidental editing, and last but not least, we deleted Secrets we did
    not need anymore. In the following section, we will focus on concerns surrounding
    secret usage in different environments.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们更进一步地管理了 Kubernetes Secrets。我们更新了 Secrets，跟踪了我们的更改，并且还备份了先前的配置。此外，我们创建了不可变的
    Secrets，以防止意外编辑，最后但同样重要的是，我们删除了不再需要的 Secrets。在接下来的章节中，我们将重点讨论在不同环境中使用 secret 的相关问题。
- en: Kubernetes Secrets configuration in different deployment scenarios
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同部署场景中的 Kubernetes Secrets 配置
- en: Throughout the **software development life cycle** (**SDLC**), a team might
    use different environments to test their increments before releasing them to production.
    Just as with a production deployment, any other deployment on another environment
    will have certain configuration requirements, including Secrets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在**软件开发生命周期**（**SDLC**）中，一个团队可能会使用不同的环境来测试他们的增量更新，然后再将其发布到生产环境中。就像生产部署一样，其他任何环境中的部署也会有一定的配置要求，包括
    Secrets。
- en: Secret usage among environments
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境间的 Secret 使用
- en: When it comes to Secrets, we need to ensure their durability and integrity regardless
    of the environment. Having different handling of Secrets in different environments
    can cause issues in the long term, and the team will not be able to fully validate
    the security implications of choices on secret handling.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Secrets 时，我们需要确保它们在任何环境下的持久性和完整性。在不同环境中对 Secrets 的处理不同可能会导致长期问题，并且团队将无法完全验证对
    secret 处理选择的安全影响。
- en: Provided the environments have differences due to cost-saving requirements or
    because a full installation brings more overhead, Secrets need to be securely
    stored. There might be cases where Secrets might be shared. An example can be
    a proprietary key of an external SaaS service that needs to be shared between
    environments. Another example is when multitenant cloud accounts host multiple
    environments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于环境之间可能存在成本节约要求或完整安装带来更多开销的差异，Secrets需要被安全存储。可能会出现Secrets需要共享的情况。例如，某个外部SaaS服务的专有密钥需要在不同环境之间共享。另一个例子是，当多租户云账户托管多个环境时。
- en: From development to deployment
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从开发到部署
- en: To deploy a secret, sensitive information needs to reside somewhere. This information
    at some point will be inserted by an individual to a system and applied to Kubernetes.
    Companies nowadays store their sensitive information on various systems designed
    specifically to host this type of information. Briefly, secure storage is required
    to host Secrets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署一个secret，敏感信息需要存放在某个地方。这些信息最终会由某个个人插入系统并应用到Kubernetes。如今，公司将敏感信息存储在专门为此类信息设计的各种系统中。简而言之，安全存储是托管Secrets的必要条件。
- en: The life cycle of deploying something as sensitive as a Kubernetes secret starts
    from retrieving the certificate from the secure storage, creating the YAML file
    needed for the secret, and applying it to Kubernetes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Kubernetes secret这类敏感内容的生命周期，从从安全存储中获取证书开始，创建所需的YAML文件并应用到Kubernetes。
- en: In the case of CI/CD jobs, most CI/CD providers provide us with the option to
    use secret values on our jobs. This can assist us in providing credentials to
    our CI/CD jobs to interact with the secret storage.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CI/CD任务，大多数CI/CD提供商为我们提供了在任务中使用秘密值的选项。这可以帮助我们为CI/CD任务提供凭证，以便与秘密存储进行交互。
- en: Another paradigm is GitOps. Argo CD is an extremely popular tool that can have
    a secret deployment customized to be able to apply a secret after it has been
    decrypted.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种范式是GitOps。Argo CD是一个极受欢迎的工具，可以自定义秘密部署，以便在解密后应用secret。
- en: Conclusion
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: When it comes to different environments, our handling of Secrets should be treated
    the same regardless of the environment. This helps with automation as well as
    consistency.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同环境下，我们对Secrets的处理应该保持一致，无论环境如何。这有助于自动化以及一致性。
- en: Requirement for managing Secrets, including secure storage and access control
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Secrets的要求，包括安全存储和访问控制
- en: In terms of responsibilities, a Kubernetes cluster has a responsibility to securely
    contain Secrets and prevent unauthorized access. Every secret that is hosted on
    Kubernetes has been stored by an individual or an automated process. At some point
    in time, this secret that now resides on Kubernetes was in another system. This
    makes it important to store Secrets securely before they reach Kubernetes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在责任方面，Kubernetes集群有责任安全地容纳Secrets并防止未经授权的访问。每个托管在Kubernetes上的秘密都是由个人或自动化过程存储的。某个时间点，当前存储在Kubernetes上的这个秘密曾经存在于另一个系统中。因此，在Secrets到达Kubernetes之前，确保它们被安全存储非常重要。
- en: Secure storage
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全存储
- en: There are various tools dedicated to the purpose of secure storage. Take, for
    example, HashiCorp Vault, **Google Cloud Platform** (**GCP**) Secret Manager,
    and **Amazon Web Services** (**AWS**) Secrets Manager. These are external Secrets
    management solutions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多专门用于安全存储的工具。例如，HashiCorp Vault、**Google Cloud Platform**（**GCP**）Secret Manager和**Amazon
    Web Services**（**AWS**）Secrets Manager。这些是外部的Secrets管理解决方案。
- en: The benefit of those solutions is that they can be used as a standalone Secrets
    management system but can also be used directly from Kubernetes. It is feasible
    to use secure storage during development or even on CI/CD jobs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案的好处是，它们既可以作为独立的Secrets管理系统使用，也可以直接从Kubernetes中使用。在开发过程中，甚至在CI/CD任务中使用安全存储也是可行的。
- en: A thing these types of solutions have in common is that they tackle cross-cutting
    concerns such as management, versioning, encryption, and access-control capabilities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案的共同点是它们处理了跨切关注点，如管理、版本控制、加密和访问控制功能。
- en: Access control
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制
- en: Access control is essential to have our secret storage secured. Durability,
    encryption at rest, and encryption in transit make our interactions with a secure
    storage system secure, but it is not enough. We need to have fine-grained control
    when it comes to accessing Secrets.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制对确保我们的秘密存储安全至关重要。持久性、静态加密和传输加密使得我们与安全存储系统的交互更加安全，但这还不够。当涉及到访问 Secrets 时，我们需要具有精细的访问控制。
- en: We need to distinguish between users and their role in an organization. Also,
    permissions might differ per environment. Another aspect is auditing and identifying
    whether there was an incident of unauthorized access.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分用户和他们在组织中的角色。此外，权限可能会因环境而异。另一个方面是审计和识别是否发生了未授权访问事件。
- en: Git and encryption
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 和加密
- en: 'Apart from using a secure storage system, another popular option is to store
    Secrets in an encrypted form. By storing Secrets encrypted on a Git repository,
    various aspects are feasible through Git’s capabilities. For example, versioning
    is by default enabled through commit history, access control is satisfied through
    the access control rules of Git, and the resiliency and durability of storage
    are based on the provider’s guarantees. As for encryption, this can be as good
    as the solution chosen. Data can be encrypted in various forms, from a **Pretty
    Good Privacy** (**PGP**) key ([https://www.openpgp.org/](https://www.openpgp.org/))
    to a hardware security module to a modern **cloud key management service** (**cloud
    KMS**) solution. An extremely popular tool based on this is **Mozilla Secrets
    OPerationS** (**SOPS**): [https://github.com/mozilla/sops](https://github.com/mozilla/sops).
    Mozilla SOPS utilizes KMSs provided by cloud providers as well as PGP.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '除了使用安全存储系统外，另一种流行的选择是将 Secrets 存储为加密形式。通过将加密后的 Secrets 存储在 Git 仓库中，Git 的功能使得多个方面变得可行。例如，版本控制通过提交历史默认启用，访问控制通过
    Git 的访问控制规则得到满足，存储的韧性和持久性依赖于提供商的保障。至于加密，解决方案的优劣取决于所选择的加密方式。数据可以以各种形式加密，从 **Pretty
    Good Privacy** (**PGP**) 密钥（[https://www.openpgp.org/](https://www.openpgp.org/)）到硬件安全模块，再到现代
    **云密钥管理服务** (**cloud KMS**) 解决方案。基于此的一个非常流行的工具是 **Mozilla Secrets OPerationS**
    (**SOPS**): [https://github.com/mozilla/sops](https://github.com/mozilla/sops)。Mozilla
    SOPS 使用云提供商提供的 KMS 以及 PGP。'
- en: Conclusion
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Just as with every secret, their access should be limited, and they should not
    be available to be accessed to unauthorized personnel in any circumstances. For
    these reasons, apart from where we keep Secrets, we need to provide proper access
    control.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个机密一样，它们的访问应该受到限制，并且在任何情况下都不应允许未授权人员访问。因此，除了存储 Secrets 的位置外，我们还需要提供适当的访问控制。
- en: Securing access to Secrets with RBAC
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RBAC 确保对 Secrets 的访问
- en: A cross-cutting concern when it comes to Kubernetes objects is authorized access.
    Overall, the state of a system is something sensitive. You should have authorized
    access for operations such as changing the number of replicas for a deployment
    or changing the autoscaling rules for a deployment. The security mechanism that
    Kubernetes provides us with is RBAC.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 对象中，一个跨切面的问题是授权访问。总体而言，系统的状态是敏感的。您应当对某些操作有授权访问，例如更改部署的副本数或更改部署的自动扩展规则。Kubernetes
    为我们提供的安全机制是 RBAC。
- en: RBAC introduction
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC 介绍
- en: 'RBAC consists of the following Kubernetes objects:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 由以下 Kubernetes 对象组成：
- en: Roles
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色
- en: Role bindings
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色绑定
- en: Cluster roles
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群角色
- en: Cluster role bindings
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群角色绑定
- en: We will check each component separately and see how they are combined with Kubernetes
    Secrets.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别检查每个组件，看看它们如何与 Kubernetes Secrets 结合使用。
- en: Roles
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色
- en: 'Roles are a set of permissions that take effect only on the namespace where
    the role resides. By specifying a role, we define operations that can be executed
    upon a Kubernetes resource. Roles have the following format:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是一组仅在角色所在命名空间内生效的权限。通过指定一个角色，我们定义了可以对 Kubernetes 资源执行的操作。角色的格式如下：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`verbs` are the actions that we should be able to execute, and `resources`
    are the targets for those actions. `apiGroups` points to the API group of the
    resources we will interact with; by setting an empty value, it indicates the core
    API group.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`verbs` 是我们应该能够执行的操作，`resources` 是这些操作的目标。`apiGroups` 指向我们将与之交互的资源的 API 组；通过设置空值，它表示核心
    API 组。'
- en: The preceding `Role` object enables the actor with that role to get, list, and
    watch Secrets for the default namespaces. Let us proceed and bind that role to
    an actor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Role` 对象使得拥有该角色的操作员能够获取、列出并观察默认命名空间中的 Secrets。让我们继续并将该角色绑定给一个操作员。
- en: Role bindings
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色绑定
- en: 'By checking how a `Role` object is represented using YAML, we identify the
    action and the target. Role bindings help us to define the actor. An actor can
    be a user (individual or a group) or a service account. Role bindings have the
    following YAML manifest:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查如何使用 YAML 表示 `Role` 对象，我们可以识别出动作和目标。角色绑定帮助我们定义行为者。行为者可以是一个用户（个人或群组）或一个服务账户。角色绑定有以下
    YAML 表现：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A namespace is present when defining a role binding. This is because role bindings
    take effect only on the namespace in which they reside. On `roleRef`, we define
    a role that should be on the same namespace. On `subjects`, we define a list of
    actors that will have access to that role. Take note that the subjects can come
    from different namespaces.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义角色绑定时，命名空间是必须存在的。这是因为角色绑定只在它们所在的命名空间内生效。在`roleRef`中，我们定义一个应该位于同一命名空间中的角色。在`subjects`中，我们定义一个访问该角色的行为者列表。请注意，行为者可以来自不同的命名空间。
- en: Cluster roles
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集群角色
- en: 'Cluster roles are close to roles: they do define a set of permissions; however,
    they take effect cluster-wide and are not limited to one namespace. They have
    the following YAML representation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 集群角色与角色非常相似：它们定义了一组权限；然而，它们是集群范围内生效的，而不是仅限于某一个命名空间。它们有以下 YAML 表现：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is almost identical to the `Role` object except for the namespace not being
    present since those rules apply cluster-wide. The preceding `ClusterRole` role
    enables the actor with that role to administer Secrets from all namespaces we
    have on the Kubernetes clusters. We can now proceed with binding that `ClusterRole`
    object to an actor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `Role` 对象几乎完全相同，唯一的不同是没有命名空间，因为这些规则适用于整个集群。前面的 `ClusterRole` 角色使得具有该角色的行为者能够管理
    Kubernetes 集群中所有命名空间的 Secrets。我们现在可以继续将该 `ClusterRole` 对象绑定到一个行为者。
- en: Cluster role bindings
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集群角色绑定
- en: 'By using cluster role bindings, we bind a cluster role to a list of users and
    service accounts. A cluster role binding has the following YAML representation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用集群角色绑定，我们将一个集群角色绑定到一组用户和服务账户。集群角色绑定有以下 YAML 表现：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we have been introduced to RBAC and how we can utilize it to secure
    Secrets, we can proceed to an end-to-end example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 RBAC 以及如何使用它来保护 Secrets，我们可以开始一个端到端的示例。
- en: RBAC and Secrets
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC 和 Secrets
- en: In the previous example, we created roles and cluster roles for our cluster’s
    secret resources. We focused on a viewer role and an administrator role for Secrets,
    but it is worth seeing if there are more options.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们为集群的秘密资源创建了角色和集群角色。我们集中讨论了一个用于查看权限的角色和一个用于管理 Secrets 的管理员角色，但值得看看是否还有其他选项。
- en: 'We can identify which verbs are related to Secrets by using an `api-resources`
    call:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `api-resources` 调用来识别与 Secrets 相关的操作：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we know what our options are, we will create our own RBAC configuration
    for our Secrets.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了有哪些选项，我们将为我们的 Secrets 创建自己的 RBAC 配置。
- en: ClusterRole
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClusterRole
- en: 'We will create a cluster role for administering Secrets using the `ClusterRole`
    specification in the YAML file we created earlier:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们之前创建的 YAML 文件中的 `ClusterRole` 规范创建一个集群角色，以管理 Secrets：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This should create a cluster role able to administer Secrets cluster-wide.
    We will use a Pod with the `ClusterRole` object attached and check the secret
    creation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该创建一个能够在整个集群范围内管理 Secrets 的集群角色。我们将使用一个附加了 `ClusterRole` 对象的 Pod，并检查秘密的创建：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By checking the logs, we should see the following message:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查日志，我们应该看到以下消息：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Pod was configured with the service account, and the service account has
    a cluster binding to a `ClusterRole` object with admin permissions upon Secrets.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该 Pod 被配置为使用服务账户，而服务账户有一个集群绑定到 `ClusterRole` 对象，该对象具有对 Secrets 的管理员权限。
- en: Role
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色
- en: 'We will use the role we created earlier that provides viewer permissions over
    Secrets:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前创建的角色，该角色提供查看 Secrets 的权限：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We should now have a viewer role for Secrets on the default namespace. We will
    run a Pod to retrieve the Secrets:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该在默认命名空间中有一个用于查看 Secrets 的角色。我们将运行一个 Pod 来检索 Secrets：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Conclusion
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this section, we introduced RBAC for Secrets. We identified available actions
    for Secrets within a cluster and the distinction between `ClusterRole` and `Role`
    objects. We then proceeded to secure secret usage within our cluster and provided
    fine-grained authorized access to Secrets, whether access was limited to a namespace
    by using a role or access was granted throughout the cluster. Since we have fulfilled
    the requirement for authorized access, another requirement that we should pay
    attention to is monitoring our secret usage.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 RBAC 以管理 Secrets。我们确定了集群内对 Secrets 可执行的操作，并区分了 `ClusterRole` 和 `Role`
    对象。接着，我们着手保障集群内 Secret 的安全使用，并提供了细粒度的授权访问，无论是通过角色限制访问某个命名空间，还是在整个集群中授予访问权限。由于我们已完成授权访问的需求，接下来需要关注的是监控我们的
    Secret 使用情况。
- en: Auditing and monitoring secret usage
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计和监控 Secret 使用情况
- en: To record and monitor ongoing activities on a Kubernetes cluster, we have the
    option of auditing. Events that happen in a Kubernetes cluster are sent to the
    output stream or saved as logs; this makes it feasible to identify what happened
    in our system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录和监控 Kubernetes 集群中的持续活动，我们可以选择进行审计。Kubernetes 集群中的事件会发送到输出流或保存为日志；这使得我们可以识别系统中发生了什么。
- en: In our case, we want to monitor our secret usage. To avoid the overhead of other
    activities, we will focus only on audits generated for Secrets.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望监控 Secret 的使用情况。为了避免其他活动的开销，我们将仅专注于为 Secrets 生成的审计日志。
- en: 'The audit configuration to enable audits on Secrets should be the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 启用审计功能以监控 Secrets 的配置应如下所示：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On a Kubernetes installation, this can be achieved by using the `--audit-policy-file`
    flag and passing it when running `kube-apiserver`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 安装中，可以通过使用 `--audit-policy-file` 标志，并在运行 `kube-apiserver` 时传递它来实现：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: minikube note
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: minikube note
- en: In the case of minikube, we need to pass the audit configuration when starting
    minikube.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 minikube 的情况下，我们需要在启动 minikube 时传递审计配置。
- en: 'We have summed up those actions in the `minikube-script.sh` script:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `minikube-script.sh` 脚本中总结了这些操作：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since we enabled auditing, let’s check the logs:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经启用了审计功能，接下来检查日志：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To trigger an audit event, we can issue a secret operation:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发审计事件，我们可以执行一个 Secret 操作：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Eventually, we will receive the following log:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将收到以下日志：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We managed to track and monitor changes in our Secrets thanks to enabling the
    auditing feature of Kubernetes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用 Kubernetes 的审计功能，我们成功地跟踪和监控了 Secret 的变化。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a deeper dive into Kubernetes Secrets. We learned about
    the different types of Kubernetes Secrets and for which occasions they are used,
    and we went through executing code snippets highlighting those use cases. Also,
    since Secrets contain sensitive information, we went further into securing access
    to those Secrets by applying RBAC rules. This helped us to limit access to Secrets
    but also provide authorized access to our Pods. Another aspect that we covered
    is auditing. Auditing is a very important aspect since we want to have full control
    over access to Secrets as well as other operations. In the next chapter, we will
    focus on encrypting Secrets in transit and at rest.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Kubernetes Secrets。我们了解了不同类型的 Kubernetes Secrets 及其使用场景，并通过执行代码片段来展示这些用例。此外，由于
    Secrets 包含敏感信息，我们进一步探讨了通过应用 RBAC 规则来确保对 Secrets 的访问安全。这帮助我们限制了对 Secrets 的访问，但也为我们的
    Pods 提供了授权访问。我们还涵盖了审计这一方面。审计是一个非常重要的环节，因为我们希望能够全面控制对 Secrets 的访问以及其他操作。在下一章中，我们将重点讨论传输中的和静态存储中的
    Secrets 加密。
