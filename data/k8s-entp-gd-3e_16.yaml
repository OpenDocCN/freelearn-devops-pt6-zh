- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: An Introduction to Istio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio简介
- en: “If it makes it easier for users to use on the frontend, it’s probably complex
    on the backend.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “如果前端用户使用起来很容易，那可能意味着后端很复杂。”
- en: This chapter will introduce you to Istio, a Service mesh add-on for Kubernetes.
    A Service mesh is a tool for Kubernetes that improves the management, security,
    and visibility of microservices in a cluster. It simplifies complex networking
    tasks by handling service-to-service communication, load balancing, and traffic
    routing outside the application code. Istio also enhances security with features
    like encryption, authentication, and authorization. It provides detailed metrics
    and monitoring, allowing developers to understand how their services are performing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Istio，它是Kubernetes的一个服务网格插件。服务网格是一个工具，用于提升Kubernetes集群中微服务的管理、安全性和可视化。它通过处理服务间通信、负载均衡和流量路由，简化了复杂的网络任务，而无需在应用代码中实现这些功能。Istio还通过加密、认证和授权等功能增强了安全性。它提供了详细的指标和监控，帮助开发者了解他们的服务性能。
- en: Istio is a large, complex system that provides benefits to your workloads by
    offering enhanced security, discovery, observability, traffic management, and
    more – all without requiring application developers to write modules or applications
    to handle each task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Istio是一个庞大而复杂的系统，它通过提供增强的安全性、发现、可观察性、流量管理等功能，给你的工作负载带来好处——而无需应用开发者为每个任务编写模块或应用。
- en: 'While Istio presents a steep learning curve, mastering it unlocks the potential
    to offer developers advanced functionalities, enabling intricate Service mesh
    deployments and a broad spectrum of capabilities, including the ability to do
    the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Istio有陡峭的学习曲线，但掌握它能够为开发者提供高级功能，使得复杂的服务网格部署和广泛的功能成为可能，包括以下能力：
- en: Route traffic based on various requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据不同需求路由流量
- en: Secure service-to-service communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全的服务间通信
- en: Traffic shaping
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量整形
- en: Circuit breaking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路
- en: Service observability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可观察性
- en: 'The future: Ambient mesh'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来：环境网格
- en: Developers can use these tools with minimal or no changes to their code. When
    something is easy for users, it often means there’s a lot of complexity behind
    the scenes, and Istio is a good example of this. This chapter will show you how
    to set up Istio and Kiali, a tool for monitoring. We’ll also discuss Istio’s key
    features that help manage traffic, enhance security, and reveal workloads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在最少或无需修改代码的情况下使用这些工具。当某些功能对用户来说很容易使用时，往往意味着背后有很多复杂的工作，Istio就是一个很好的例子。本章将展示如何设置Istio和Kiali，一个用于监控的工具。我们还将讨论Istio的关键功能，这些功能有助于流量管理、增强安全性和揭示工作负载。
- en: To fully explain Istio, we’d need a whole other book focused just on its custom
    resources and ways to use them. Our aim in this chapter and the next is to give
    you the basic knowledge you need to start using Istio confidently. We can’t go
    into every detail about each component, so we recommend visiting the Istio website
    at [https://istio.io](https://istio.io) for additional information to build on
    what you will learn in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面解释Istio，我们需要一本专门介绍其自定义资源及使用方法的书籍。本章及下一章的目标是让你掌握使用Istio的基本知识，以便你可以自信地开始使用它。我们不能涵盖每个组件的所有细节，因此建议你访问Istio官网
    [https://istio.io](https://istio.io)，以获得更多信息，进一步扩展你在本章所学的内容。
- en: 'This chapter will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the control plane and data plane
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解控制平面和数据平面
- en: Why should you care about a Service mesh?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该关心服务网格？
- en: Introduction to Istio concepts
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio概念介绍
- en: Understanding Istio components
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Istio组件
- en: Installing Istio
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Istio
- en: Introducing Istio resources
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Istio资源
- en: Deploying add-on components to provide observability
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署附加组件以提供可观察性
- en: Deploying an application into the Service mesh
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用部署到服务网格中
- en: 'The future: Ambient mesh'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来：环境网格
- en: Before we dive into the chapter, let’s set the scene for what you’re about to
    learn. This chapter is designed to introduce you to deploying Istio and the main
    features it provides. It gives you the key details to understand how Istio functions
    and what its various parts are. By the end of this chapter and the next chapter,
    where you’ll add an application to the mesh, you should have a good grasp of how
    to set up and use a basic Istio Service mesh.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入本章内容之前，先为你即将学习的内容定个基调。本章旨在介绍如何部署 Istio 以及它提供的主要功能。它提供了了解 Istio 功能和各部分的关键细节。在本章以及下一章中（你将把应用程序添加到服务网格中），你应该能够很好地掌握如何设置和使用基本的
    Istio 服务网格。
- en: We will close out the chapter with a look at the future of the Service mesh,
    known as the ambient mesh. As of the publishing of this book, the ambient mesh
    is still in beta, and since a lot of things can change between beta and a GA release,
    we will only provide an overview of what the ambient mesh will bring when it’s
    released.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章结束时，展望服务网格的未来，即所谓的环境网格（ambient mesh）。截至本书发布时，环境网格仍处于测试阶段，由于从测试版到正式版的过程中可能会有许多变化，我们将仅概述环境网格发布时将带来的新特性。
- en: 'To wrap up this introduction, here’s a fun fact about Kubernetes: like many
    things in Kubernetes, Istio is named after something related to the sea. In Greek,
    “Istio” means “sail.”'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章介绍的结尾，这里有一个关于 Kubernetes 的趣味事实：像 Kubernetes 中的许多东西一样，Istio 的名字来源于与海洋相关的事物。在希腊语中，“Istio”意味着“帆”。
- en: Technical requirements
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下技术要求：
- en: A Docker host installed using the steps from *Chapter 1*, *Docker and Container
    Essentials*, with a minimum of 8 GB of RAM, although 16 GB is recommended
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照*第 1 章*《Docker 和容器基础》中的步骤安装的 Docker 主机，至少需要 8 GB 的 RAM，推荐 16 GB。
- en: A KinD cluster configured using the initial scripts from *Chapter 2*, *Deploying
    Kubernetes Using KinD*
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照*第 2 章*《使用 KinD 部署 Kubernetes》中的初始脚本配置的 KinD 集群
- en: Installation scripts from this book’s GitHub repository
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的安装脚本
- en: 'You can access the code for this chapter by going to this book’s GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问本书的 GitHub 仓库来获取本章的代码：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter16)。
- en: To use Istio to expose workloads, we will remove NGINX from the KinD cluster,
    which will allow Istio to utilize ports `80` and `443` on the host.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Istio 来暴露工作负载，我们将从 KinD 集群中移除 NGINX，这样可以让 Istio 使用主机上的端口 `80` 和 `443`。
- en: Understanding the Control Plane and Data Plane
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解控制平面和数据平面
- en: 'The Service mesh framework enhances how microservices communicate, making these
    interactions more secure, faster, and more reliable. It is separated into two
    main components: the control plane and the data plane, each playing a specific
    role in providing service-to-service communication in Kubernetes. These two layers
    are what make up the Service mesh as a whole and a basic understanding of each
    is key to understanding Istio.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格框架增强了微服务之间的通信，使这些交互更加安全、快速和可靠。它分为两个主要组件：控制平面和数据平面，每个组件在提供 Kubernetes 中的服务间通信中扮演着特定角色。这两个层次构成了服务网格的整体，了解每个层次的基本概念对于理解
    Istio 非常关键。
- en: The Control Plane
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制平面
- en: Let’s start with the Istio control plane.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Istio 控制平面开始。
- en: The control plane in Istio is the central authority that controls and directs
    how services in the mesh communicate with each other. A common analogy is to think
    of a city’s traffic control, managing roads and traffic signals to ensure safe
    and efficient traffic flow and order. It plays an important role in the orchestration
    of service-to-service communication, security, and observability across the entire
    mesh. We will discuss the different features that are controlled by the control
    plane when we discuss the main control plane daemon, `istiod`, in the *Understanding
    the Istio components* section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 中的控制平面是中央权威，控制并指挥服务网格中各服务之间的通信方式。一个常见的类比是将它比作城市的交通管理，管理道路和交通信号灯，确保交通流畅和有序。它在服务间通信、服务安全以及整个网格的可观察性方面起着重要作用。我们将在*理解
    Istio 组件*部分讨论控制平面中的主要守护进程 `istiod` 时，详细介绍控制平面所管理的不同功能。
- en: The Data Plane
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据平面
- en: The second component is the data plane, which is the worker layer that contains
    a set of proxies, known as Envoy proxies, deployed alongside your services. These
    proxies intercept and manage the network traffic between microservices without
    the need for you or your developers to do any additional work or recoding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件是数据平面，它是包含一组代理（称为 Envoy 代理）的工作层，这些代理与您的服务一起部署。它们拦截并管理微服务之间的网络流量，而无需您或您的开发人员做任何额外的工作或重新编码。
- en: To build on the previous analogy we used for the control plane, think of the
    data plane as the roads in a city. Each service in the mesh receives a dedicated
    road where traffic is directed to the service by a traffic controller – in our
    case, the Istio control plane (istiod).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立我们之前提到的控制平面的类比，可以将数据平面比作城市中的道路。网格中的每个服务都有一条专用的道路，流量通过交通控制器指向该服务——在我们的例子中，交通控制器就是
    Istio 控制平面（istiod）。
- en: Up until now, you may have been using Kubernetes without a Service mesh. So,
    you may be wondering why you should care about the features that Istio brings
    to your cluster. In the next section, we will go over Istio’s features so you
    will be able to explain to your developers and businesses why a Service mesh is
    an important add-on to clusters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能一直在使用 Kubernetes，而没有服务网格。那么，您可能会想，为什么要关心 Istio 为您的集群带来的功能？在接下来的部分中，我们将介绍
    Istio 的特点，以便您能够向开发人员和企业解释为什么服务网格是集群的重要附加组件。
- en: Why should you care about a Service mesh?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要关心服务网格？
- en: Service meshes, like Istio, provide several features that developers would typically
    need to develop on their own, necessitating changes to their existing code. Without
    Istio, if developers require specific capabilities, such as secure communication
    between services coded in various programming languages like Java, Python, or
    Node.js, they would need to implement the necessary code, or libraries, for each
    language individually. This adds complexity to the code and can often lead to
    inefficient coding, causing performance issues with the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格（如 Istio）提供了多个功能，通常开发人员需要自己开发这些功能，这会迫使他们修改现有的代码。如果没有 Istio，当开发人员需要特定功能时，比如在多种编程语言（如
    Java、Python 或 Node.js）编写的服务之间实现安全通信，他们需要为每种语言单独实现必要的代码或库。这会增加代码的复杂性，通常还会导致效率低下，进而引发应用性能问题。
- en: Adding security, like encryption, is just one example of what a developer may
    require to create an application. What about other features, like controlling
    data flow, testing how the application will react to failures, or how network
    delays may cause the application to behave in an unexpected way? These, and many
    other features, are all included with Istio – allowing developers to focus on
    their own business code, rather than writing additional code to control traffic
    or to simulate errors or delays.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 添加安全性，比如加密，仅仅是开发人员在创建应用时可能需要的一个例子。那么其他功能呢，比如控制数据流、测试应用如何应对故障，或者网络延迟如何导致应用行为异常？这些以及许多其他功能，Istio
    都包含其中——它允许开发人员专注于他们自己的业务代码，而不是编写额外的代码来控制流量或模拟错误或延迟。
- en: Let’s take a look at some of the advantages that Istio offers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 Istio 提供的一些优势。
- en: Workload observability
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作负载可观察性
- en: Downtime or slowdowns in an application may impact your organization’s reputation
    and potentially cause lost revenue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的停机时间或变慢可能会影响您组织的声誉，并可能导致收入损失。
- en: Have you ever found it challenging to pinpoint the underlying issue in an application
    with many active services? Imagine the ability to quickly identify and resolve
    problems by monitoring the interactions and status of services in real time, or
    by replaying events from the past to discover where things went wrong hours or
    days before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经在一个有许多活跃服务的应用中，难以找到根本问题？想象一下，通过实时监控服务之间的交互和状态，或者回放过去的事件，快速识别和解决问题，发现几小时或几天前出了什么问题。
- en: Managing complex applications and multiple services can feel overwhelming. The
    features offered by Istio make this task far less intimidating. If only there
    was a way to make this easier for developers! Thanks to Istio and its ecosystem,
    this isn’t just wishful thinking. With powerful features like Prometheus for storing
    metrics, Kiali for deep insights, and Jaeger for detailed tracing, you’re equipped
    with a powerful toolkit for troubleshooting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 管理复杂的应用程序和多个服务可能会让人感到不知所措。Istio 提供的功能使这项任务变得不那么令人生畏。如果开发者能有一种更简单的方法该多好！幸好有了
    Istio 及其生态系统，这不仅仅是空想。凭借 Prometheus 用于存储度量数据、Kiali 用于深入洞察以及 Jaeger 用于详细追踪等强大功能，你可以拥有一套强大的故障排除工具。
- en: In this chapter, we’re going to set up all three add-ons, with a focus on using
    Kiali, which lets you observe communications between your services like never
    before.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置所有三个插件，重点使用 Kiali，它让你以前所未有的方式观察服务之间的通信。
- en: Traffic management
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量管理
- en: Istio provides you with powerful traffic management capabilities for your workloads,
    offering the flexibility to adopt any deployment model you need, without the hassle
    of altering your network infrastructure. This control is entirely in your and
    your developers’ hands. Istio also includes tools that enable you to simulate
    various unpredictable scenarios that your application might encounter, such as
    HTTP errors, delays, timeouts, and retries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 为你的工作负载提供了强大的流量管理能力，提供了灵活性，可以采用任何你需要的部署模型，而无需修改网络基础设施。这种控制完全掌握在你和开发者手中。Istio
    还包括一些工具，使你能够模拟应用程序可能遇到的各种不可预见的情况，如 HTTP 错误、延迟、超时和重试。
- en: We recognize that some of our readers might be new to the concept of deployment
    models. Grasping the different types available is crucial for understanding, and
    appreciating, the benefits that Istio brings to the table. With Istio, developers
    can effectively utilize deployment strategies like blue/green and canary deployments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认识到，一些读者可能对部署模型的概念还不熟悉。掌握可用的不同类型对于理解和欣赏 Istio 带来的好处至关重要。通过 Istio，开发者可以有效地利用蓝绿部署和金丝雀部署等部署策略。
- en: Blue/green deployments
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: In this model, you deploy two versions to production, directing a certain percentage
    of traffic to each version of the application, usually sending a low amount of
    traffic to the “new” (green) release. As you verify that the new deployment is
    working as expected, you can cut over all of the traffic to the green deployment,
    or you use blue/green combined with a canary deployment to the new version until
    you are eventually sending 100% of the traffic to the new deployment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模型中，你将两个版本部署到生产环境，按比例将流量分配到每个版本的应用程序，通常会将少量流量引导到“新”的（绿色）版本。当你验证新部署按预期工作时，可以将所有流量切换到绿色部署，或者将蓝绿部署与金丝雀部署结合使用，直到最终将
    100% 的流量切换到新部署。
- en: Canary deployments
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: This term comes from the mining days when miners would put a canary in the mining
    shaft to verify it was safe to work in the environment. In the case of a deployment,
    it allows you to deploy an early test version of the application before graduating
    the release to a new version. Essentially, this is similar to the blue/green deployment,
    but in a canary deployment, you would direct a very small percentage of traffic
    to the canary version of the application. Using a small percentage of traffic
    will minimize any impact that the canary deployment may introduce. As you become
    more confident that the “canary” version of the application is stable, you will
    move over additional traffic until you are 100% on the new version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语源自矿业时代，当时矿工会将金丝雀放入矿井中，以验证工作环境是否安全。在部署的情况下，它允许你在将发布版本升级为新版本之前，先部署一个早期的测试版本。实质上，这类似于蓝绿部署，但在金丝雀部署中，你会将非常小比例的流量引导到金丝雀版本的应用程序上。使用少量的流量将最大限度地减少金丝雀部署可能引入的影响。当你越来越确信“金丝雀”版本的应用程序是稳定的时，你会逐步增加流量，直到所有流量都切换到新版本。
- en: Finding issues before they happen
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在问题发生之前发现问题
- en: We can go a step further from deployment models; Istio also provides tools for
    you to develop resilience and testing for your workloads before you deploy them
    and learn about issues from customers or end-users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步深化部署模型；Istio 还为你提供了开发弹性和测试工具，在部署工作负载之前，帮助你发现问题，而不是等客户或终端用户反馈。
- en: Have you ever worried about how an application will react to certain unseen
    events?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你曾经担心过应用程序如何应对某些未知事件吗？
- en: 'Developers need to worry about events that they have little control over, including:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要担心他们几乎无法控制的事件，包括：
- en: Application timeouts
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序超时
- en: Delays in communication
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信延迟
- en: HTTP error codes
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 错误代码
- en: Retries
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试
- en: Istio provides objects to assist in dealing with these by allowing you to create
    an issue with the workload before you move to production. This allows developers
    to capture and resolve issues in their applications before releasing them to production,
    creating a better user experience.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 提供了对象来帮助处理这些问题，允许你在迁移到生产环境之前与工作负载创建问题。这使得开发者能够在将应用发布到生产环境之前捕捉并解决应用中的问题，从而提供更好的用户体验。
- en: Security
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: In today’s world, security is an issue we should all be concerned about. Many
    of the methods to secure a workload are complex and may require a skillset that
    many developers do not have. This is truly where Istio shines, providing the tools
    to easily deploy security and minimize its impact on development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界中，安全性是我们每个人都应该关注的问题。许多保护工作负载的方法都很复杂，并可能需要很多开发者没有的技能。这正是 Istio 大显身手的地方，它提供了工具，使得安全部署变得简单，并且尽可能减少对开发的影响。
- en: The first, and most popular, security feature in Istio is the ability to provide
    **mutual Transport Layer Security** (**mTLS**) between workloads. Using mTLS,
    Istio provides not only encryption for communication but workload identity too.
    When you visit a website that has an expired certificate or a self-signed certificate,
    your browser will warn you that the site can’t be trusted. That’s because your
    browser performs server authentication when establishing a TLS connection by verifying
    that the certificate presented by the server is trusted by the browser. mTLS verifies
    trust from the client to the server, but also from the server to the client. That’s
    the mutual part. The server validates that the certificate presented by the client
    is trusted as well as the client validating the server. When you first start a
    cluster and use the initial certificate created for you, you’re using mTLS. Istio
    makes this much easier because it will create all of the certificates and identities
    for you using its built-in sidecar.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 中第一个也是最受欢迎的安全功能是能够在工作负载之间提供**相互传输层安全性**（**mTLS**）。通过使用 mTLS，Istio 不仅为通信提供加密，还提供工作负载身份。当你访问一个证书过期或自签名证书的网站时，浏览器会警告你该站点无法被信任。这是因为浏览器在建立
    TLS 连接时会进行服务器认证，通过验证服务器提供的证书是否被浏览器信任。mTLS 不仅验证客户端到服务器的信任，还验证服务器到客户端的信任。这就是“相互”的部分。服务器验证客户端提供的证书是否被信任，客户端也验证服务器的证书。当你首次启动集群并使用为你创建的初始证书时，你就在使用
    mTLS。Istio 让这一过程变得更加简单，因为它会使用内置的 sidecar 为你创建所有证书和身份。
- en: You can configure mTLS as a requirement (STRICT), or as an option (PERMISSIVE),
    for the entire mesh or individual namespaces. If you set either option to STRICT,
    any communication to the service will require mTLS and if a request fails to provide
    an identity, the connection will be denied. However, if you set the PERMISSIVE
    option, traffic that has an identity and requests mTLS will be encrypted, while
    any request that does not provide an identity or encryption request will still
    be allowed to communicate.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 mTLS 配置为整个网格或单个命名空间的要求（STRICT），或选项（PERMISSIVE）。如果你将选项设置为 STRICT，任何与服务的通信都需要
    mTLS，如果请求未能提供身份，则连接将被拒绝。然而，如果你设置 PERMISSIVE 选项，具有身份并请求 mTLS 的流量将会被加密，而任何未提供身份或加密请求的请求仍然会被允许进行通信。
- en: Another feature provided will give you the ability to secure what communication
    is allowed to a workload, similar to a firewall, but in a much simpler implementation.
    Using Istio, you can decide to only allow HTTP GET requests, or only HTTP POST
    requests, or both – from only defined sources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提供的功能将使你能够控制允许哪些通信访问工作负载，类似于防火墙，但实现方式更简单。通过 Istio，你可以决定只允许 HTTP GET 请求，或只允许
    HTTP POST 请求，或者两者都允许——且仅限于特定来源。
- en: Finally, you can use **JSON Web Tokens** (**JWTs**) for initial user authentication
    to limit who is authorized to communicate with a workload. This allows you to
    secure the initial communication attempt by only accepting JWTs that come from
    an approved token provider.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用**JSON Web 令牌**（**JWTs**）进行初始用户认证，以限制哪些人有权限与工作负载通信。这使得你能够通过只接受来自批准的令牌提供者的
    JWT 来保护初始通信尝试。
- en: Now that we have discussed some of the reasons you would want to deploy Istio,
    let’s introduce you to some Istio concepts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些你可能想要部署 Istio 的原因，让我们来介绍一些 Istio 的概念。
- en: Introduction to Istio concepts
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio概念介绍
- en: 'The principles of Istio can be divided into four main areas: traffic management,
    security, observability, and extensibility. For each of these areas, we’ll introduce
    the components and custom resources that developers can utilize to tap into the
    benefits of using Istio.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Istio的原则可以分为四个主要领域：流量管理、安全性、可观察性和可扩展性。对于这些领域，我们将介绍开发人员可以利用的组件和自定义资源，以便充分利用Istio带来的好处。
- en: Understanding the Istio components
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Istio组件
- en: Similar to a standard Kubernetes cluster, Istio refers to two separate planes,
    the control plane and the data plane. Historically, the data plane included four
    different services, Pilot, Galley, Citadel, and Mixer – all broken out in a true
    microservices design. This design was used for multiple reasons, including the
    flexibility to break out the responsibilities to multiple teams, the ability to
    use different programming languages, and the ability to scale each service independently
    of the others.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于标准Kubernetes集群，Istio指代两个独立的平面：控制平面和数据平面。历史上，数据平面包括四个不同的服务，Pilot、Galley、Citadel和Mixer——所有这些服务都采用真正的微服务设计。这种设计有多种原因，包括将职责分配给多个团队的灵活性、使用不同编程语言的能力，以及独立扩展每个服务的能力。
- en: Istio has evolved quickly since its initial release. The team made the decision
    that breaking out the core services had little benefit and, in the end, made Istio
    more complex. This led the team to redesign Istio and starting with Istio 1.5,
    Istio includes the components that we will discuss in this section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自Istio首次发布以来，Istio发展迅速。团队决定，拆分核心服务几乎没有好处，反而让Istio变得更复杂。这促使团队重新设计Istio，并且从Istio
    1.5开始，Istio包含了我们将在本节中讨论的组件。
- en: Making the Control Plane simple with istiod
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用istiod简化控制平面
- en: Just as Kubernetes bundles multiple controllers into a single executable, kube-controller-manager,
    the Istio team decided to bundle the control plane components into a single daemon
    called istiod. This single daemon grouped all of the control plane components
    into a single pod that can be easily scaled as performance is required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Kubernetes将多个控制器打包成一个可执行文件kube-controller-manager一样，Istio团队决定将控制平面组件打包成一个名为istiod的单一守护进程。这个单一守护进程将所有控制平面组件组合成一个单一的Pod，可以根据需要轻松扩展性能。
- en: 'The main advantages to the single daemon are listed in an Istio blog at [https://istio.io/latest/blog/2020/istiod/](https://istio.io/latest/blog/2020/istiod/).
    To summarize the team’s reasoning, the single process provides:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 单一守护进程的主要优势列在Istio的博客中，地址为[https://istio.io/latest/blog/2020/istiod/](https://istio.io/latest/blog/2020/istiod/)。总结团队的理由，单一进程提供了：
- en: Easier and quicker control plane installations
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简便快捷的控制平面安装
- en: Easier configuration
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单的配置
- en: Integration of virtual machines into the Service mesh more easily, requiring
    a single agent and Istio’s certificates
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易将虚拟机集成到服务网格中，只需要一个代理和Istio的证书
- en: Easier scaling
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易进行扩展
- en: Reduced control plan startup time
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少控制平面的启动时间
- en: A reduced amount of overall required resources
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少所需的整体资源量
- en: The control plane is responsible for controlling your Service mesh. It has a
    number of important features that are required to create and manage the components
    of Istio, and in the next section, we will explain the features that istiod provides.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面负责控制你的服务网格。它具有创建和管理Istio组件所需的多个重要特性，下一节我们将解释istiod所提供的特性。
- en: Breaking down the istiod pod
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 拆解istiod Pod
- en: 'Moving to a single binary didn’t reduce Istio’s functionality or features;
    it still provides all of the features that the separate components provided, they
    are all just in a single binary now. Each piece provides a key feature to the
    Service mesh, and in this section, we will explain these features:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到单一二进制文件并没有减少Istio的功能或特性；它仍然提供了各个独立组件所提供的所有功能，只不过现在它们都集中在一个单一的二进制文件中。每个部分都为服务网格提供了一个关键特性，接下来我们将解释这些特性：
- en: '**Service Discovery**: Ensures that Envoy proxies, deployed alongside a Service
    in the same pod, have up-to-date information about the network locations, including
    the IP address and ports of services in the mesh. Service Discovery provides efficient
    service-to-service communication across the mesh.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：确保与服务一起部署在同一Pod中的Envoy代理，能够获取最新的网络位置信息，包括服务网格中服务的IP地址和端口。服务发现提供了跨服务网格的高效服务间通信。'
- en: Services can frequently scale up or down, and pods may be terminated or launched
    as part of rolling updates or auto-scaling activities. Each change can potentially
    alter the endpoints. Service discovery automates the process of tracking these
    changes by watching for updates to services and their associated pods. When a
    change has occurred, the Service discovery component updates the internal registry
    of Service endpoints and pushes these updates to the Envoy sidecars.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可能频繁地进行扩展或缩减，pod 可能作为滚动更新或自动扩展活动的一部分被终止或启动。每次变化可能会改变端点。服务发现通过监控服务及其相关 pod
    的更新来自动跟踪这些变化。当发生变化时，服务发现组件会更新内部服务端点注册表，并将这些更新推送到 Envoy sidecar。
- en: Service Discovery is essential for maintaining the responsiveness and efficiency
    of the Service mesh, dynamically adapting to the ever-changing landscape of containerized
    application environments in real time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现对于保持服务网格的响应性和效率至关重要，能够实时动态适应容器化应用环境不断变化的格局。
- en: '**Configuration Distribution**: Handles the configuration of traffic routing,
    security protocols, and policy enforcement across the data plane’s sidecars. Configuration
    distribution centralizes functions that used to be performed by a component called
    Galley, including the authorization of configuration changes in the Service mesh.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置分发**：处理数据平面 sidecar 代理的流量路由、安全协议和策略执行的配置。配置分发集中管理以前由名为 Galley 的组件执行的功能，包括在服务网格中授权配置变更。'
- en: '**Certificate Lifecycle Management**: Manages the issuing, renewal, and revocation
    of digital certificates, which are used for secure service-to-service communication
    using mutual Transport Layer Security (mTLS) guaranteeing that was previously
    handled by a component called Citadel, which provided identity verification and
    management of certificates, guaranteeing that all services within the mesh can
    trust connections, without requiring any additional components or configuration.
    mTLS reduces security threats by encrypting the transferring of data between services,
    providing the confidentiality and integrity of communication within the Service
    mesh.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书生命周期管理**：管理数字证书的颁发、续期和撤销，这些证书用于通过相互传输层安全（mTLS）保证的安全服务间通信，之前由一个名为 Citadel
    的组件处理，该组件提供身份验证和证书管理，确保网格内的所有服务都能信任连接，无需任何额外的组件或配置。mTLS 通过加密服务之间的数据传输，减少了安全威胁，提供了服务网格内通信的机密性和完整性。'
- en: '**Automated Envoy Proxy Deployment**: Streamlines the deployment process by
    automatically deploying Envoy sidecar proxies within Kubernetes pods. This seamless
    integration optimizes the management of both `Egress` and `Ingress` traffic through
    the pods, serving as an invisible mediator that oversees network traffic.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化 Envoy 代理部署**：通过在 Kubernetes pod 内自动部署 Envoy sidecar 代理，简化了部署过程。这种无缝集成优化了通过
    pod 管理`Egress`和`Ingress`流量的方式，充当了一个无形的中介，监督网络流量。'
- en: This automated process ensures that each pod in the Service mesh receives its
    own Envoy proxy, providing advanced traffic capabilities including routing, load
    distribution, and security measures. The automation of Envoy proxy deployment
    removes the complexities involved in establishing and upkeeping the Service mesh,
    allowing developers and operators to spend time on their primary responsibilities.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动化过程确保服务网格中的每个 pod 都接收到自己的 Envoy 代理，提供先进的流量能力，包括路由、负载分配和安全措施。Envoy 代理部署的自动化消除了建立和维护服务网格时的复杂性，使开发者和运维人员能够将精力集中在主要职责上。
- en: '**Traffic Routing and Control**: Responsible for creating and sharing the rules
    for managing traffic to Envoy proxies, providing a pivotal role in executing advanced
    network operations, and providing a way for precise control over often complex
    network traffic flows.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量路由与控制**：负责创建并共享管理流量到 Envoy 代理的规则，在执行高级网络操作中扮演关键角色，并提供精确控制通常复杂的网络流量流向的方式。'
- en: 'The functionalities provided by traffic routing and control, include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 流量路由和控制提供的功能包括：
- en: Determining the path(s) for directing traffic
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定流量的路径
- en: Strategic retry mechanisms
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略性重试机制
- en: Failover schemes to ensure continuity
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障转移机制以确保持续性
- en: The introduction of faults for the purpose of creating realistic testing environments
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了创建现实的测试环境，引入故障
- en: Traffic routing and controls provide a number of advantages, including streamlining
    the management of network traffic, testing the network’s stability and response
    under certain conditions, and increasing workload resilience by simulating disruptions
    and how the application reacts before they occur in production.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 流量路由和控制提供了多项优势，包括简化网络流量管理、测试网络在特定条件下的稳定性和响应，以及通过模拟中断和应用程序反应来提高工作负载的弹性，以便在生产环境中发生之前解决潜在问题。
- en: '**Security Policy Enforcement**: Uses security rules to make sure only authorized
    users or services have access and can interact within the network securely.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全策略执行**：使用安全规则确保只有授权用户或服务能够安全地访问并在网络中进行交互。'
- en: '**Observability Data Collection**: In a Service mesh, it’s essential to keep
    an eye on how things are running and to quickly identify and solve any problems.
    This is where observability data collection comes into play, gathering and analyzing
    telemetry information, including metrics, logs, and traces from the data plane,
    enhancing the mesh’s monitoring and operational insight capabilities.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性数据收集**：在服务网格中，跟踪系统运行情况并快速识别和解决问题至关重要。这就是可观察性数据收集的作用，通过收集和分析遥测信息（包括指标、日志和来自数据平面的跟踪），增强网格的监控和运营洞察能力。'
- en: Now that we have discussed what istiod provides, we will move on to how incoming
    traffic is managed in the Service mesh using the `istio-ingressgateway` component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了 istiod 提供的功能，接下来我们将讨论如何使用 `istio-ingressgateway` 组件在服务网格中管理传入流量。
- en: Understanding istio-ingressgateway
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解 istio-ingressgateway
- en: Moving on from the base istiod pod, we come to one of the most important components
    of Istio, `istio-ingressgateway`. This gateway facilitates external clients’ and
    services’ access to the Service mesh, acting as the entry point into the Kubernetes
    cluster. It’s standard for every Istio-enabled cluster to be equipped with at
    least one instance of `istio-ingressgateway`. However, Istio’s design does not
    confine you to just one; depending on your specific needs, it’s possible to deploy
    multiple ingress gateways to serve various purposes or handle different traffic
    patterns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础的 istiod pod 转到 Istio 的一个重要组成部分——`istio-ingressgateway`。这个网关使外部客户端和服务能够访问服务网格，充当进入
    Kubernetes 集群的入口点。每个启用 Istio 的集群通常至少配备一个 `istio-ingressgateway` 实例。然而，Istio 的设计并不限于此；根据具体需求，可以部署多个
    ingress 网关来服务不同的目的或处理不同的流量模式。
- en: 'The `istio-ingressgateway` provides access to applications using two methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`istio-ingressgateway` 提供了两种方式来访问应用程序：'
- en: Standard Kubernetes Ingress object support
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准 Kubernetes Ingress 对象支持
- en: Istio Gateway and VirtualService objects
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio 网关和虚拟服务对象
- en: Since we have already discussed and deployed NGINX as an Ingress controller,
    we will not cover using Envoy as a standard Ingress controller; instead, we will
    focus on the second method of using Gateways and Virtual Services for incoming
    requests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经讨论并部署了 NGINX 作为 Ingress 控制器，因此不会再讨论使用 Envoy 作为标准 Ingress 控制器；相反，我们将重点介绍使用网关和虚拟服务来处理传入请求的第二种方法。
- en: Using Gateways to expose our services provides more flexibility, customization,
    and security over a standard Ingress object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网关暴露我们的服务比标准的 Ingress 对象提供了更多的灵活性、定制性和安全性。
- en: Understanding istio-egressgateway
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解 istio-egressgateway
- en: The `istio-egressgateway` is designed to direct traffic from sidecars to either
    a single pod or a collection of pods, thereby centralizing the exiting (egress)
    traffic from the Service mesh. Normally, Istio sidecars manage both incoming and
    outgoing traffic for services within the mesh. While `istio-ingressgateway` is
    utilized for managing incoming traffic to the mesh, implementing `istio-egressgateway`
    allows for the regulation of outgoing traffic as well. The functionalities and
    details of both `ingressgateway` and `egressgateway` will be explored thoroughly
    in the *Introducing Istio resources* section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`istio-egressgateway` 旨在将流量从 sidecar 定向到单个 pod 或一组 pod，从而集中管理服务网格中的外发（egress）流量。通常，Istio
    sidecar 同时管理网格内服务的传入和传出流量。虽然 `istio-ingressgateway` 用于管理传入流量，但实现 `istio-egressgateway`
    也可以对传出流量进行管理。`ingressgateway` 和 `egressgateway` 的功能和细节将在 *介绍 Istio 资源* 部分中进行详细探讨。'
- en: Now, let’s jump into how you install Istio in a cluster.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解如何在集群中安装 Istio。
- en: Installing Istio
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Istio
- en: There are multiple methods to deploy Istio. The most common methods today are
    to use either `istioctl` or Helm, but there are additional options depending on
    your organization. You may elect to use one of the alternative installation methods
    of creating manifests via `istoctl` or Helm.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 Istio 有多种方法。目前最常见的方法是使用 `istioctl` 或 Helm，但根据你的组织需求，还可以选择其他选项。你可以选择通过 `istioctl`
    或 Helm 创建清单来使用替代的安装方法。
- en: 'A brief list of advantages and disadvantages for each method is detailed in
    *Table 16.1*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法的优缺点简要列在*表 16.1*中：
- en: '| **Deployment method** | **Advantages** | **Disadvantages** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **部署方法** | **优点** | **缺点** |'
- en: '| `istioctl` | Configuration validation and health checksDoes not require any
    privileged pods, increasing cluster securityMultiple configuration options | Each
    Istio version requires a new binary |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `istioctl` | 配置验证与健康检查不需要特权 Pod，增强了集群安全性多个配置选项 | 每个 Istio 版本都需要新的二进制文件 |'
- en: '| Istio operator | Configuration validation and healthDoes not require multiple
    binaries for each Istio versionMultiple configuration options | Requires a privileged
    pod running in the cluster |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| Istio 操作员 | 配置验证和健康检查不需要为每个 Istio 版本准备多个二进制文件多个配置选项 | 需要在集群中运行特权 Pod |'
- en: '| Manifests (via `istioctl`) | Generates manifests that can be customized before
    deploying using `kubectl`Multiple configuration options | Not all checks are performed,
    which could lead to deployment errorsError checks and reporting are limited when
    compared to using `istioctl` or the Istio operator |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| Manifests（通过 `istioctl`） | 生成可定制的清单，在使用 `kubectl` 部署前可以进行调整多个配置选项 | 并未执行所有检查，这可能导致部署错误与使用
    `istioctl` 或 Istio 操作员相比，错误检查和报告功能受限 |'
- en: '| Helm | Helm and charts are well known to most Kubernetes usersLeverages Helm
    standards, which allow for easy management of deployments | Offers the least validation
    checks of all deployment optionsMost tasks will require additional work and complexity
    versus the other deployment models |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Helm | Helm 和 Helm Charts 对大多数 Kubernetes 用户都很熟悉利用 Helm 标准，简化了部署管理 | 提供的验证检查是所有部署选项中最少的，执行大多数任务时需要额外工作和复杂度
    |'
- en: 'Table 16.1: Istio deployment methods'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.1：Istio 部署方法
- en: For this chapter, we will focus on using the `istioctl` binary for installation,
    and in the next section, we will deploy Istio using `istioctl`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍使用 `istioctl` 二进制文件进行安装，在接下来的章节中，我们将使用 `istioctl` 部署 Istio。
- en: Downloading Istio
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载 Istio
- en: We have included a script that will deploy Istio, output the verification of
    the installation, remove NGINX Ingress, and expose `istio-ingressgateway` as the
    Ingress to our KinD cluster. The manual process is provided below if you prefer
    to install it manually using `istioctl`. The script, `install-istio.sh`, is provided
    for readers who may use it in automation for their own testing and is located
    in the `chapter16` directory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个脚本来部署 Istio，输出安装验证，移除 NGINX Ingress，并将 `istio-ingressgateway` 暴露为我们 KinD
    集群的 Ingress。如果你更喜欢手动使用 `istioctl` 安装，也提供了手动过程。脚本 `install-istio.sh` 已经包括在内，供读者在自动化测试时使用，位于
    `chapter16` 目录中。
- en: 'The first thing that we need is to define the version of Istio we want to deploy.
    We can do this by setting an environment variable, and in our example, we want
    to deploy Istio 1.20.3\. First, make sure you are in the `chapter16` directory
    where you cloned the repo and execute the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是定义我们想要部署的 Istio 版本。我们可以通过设置环境变量来完成，在我们的示例中，我们希望部署 Istio 1.20.3。首先，确保你在克隆仓库后的
    `chapter16` 目录中，然后执行以下命令：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will download the installation script and execute it using the `ISTIO_VERSION`
    that we defined before executing the `curl` command. After executing, you will
    have an `istio-1.20.3` directory in your current working directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载安装脚本，并使用我们之前定义的 `ISTIO_VERSION` 执行该脚本。执行后，你的当前工作目录中会有一个 `istio-1.20.3` 目录。
- en: 'Finally, since we will be using executables from the `istio-1.12.3` directory,
    you should add it to your `path` statement. To make this easier, you should be
    in the `chapter16` directory from the book repository before setting the `path`
    variable:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们将使用 `istio-1.12.3` 目录中的可执行文件，因此应将其添加到 `path` 环境变量中。为了简化操作，建议在设置 `path`
    变量之前，先进入书本仓库中的 `chapter16` 目录：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing Istio using a profile
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置文件安装 Istio
- en: To make deploying Istio easier, the team has included a number of pre-defined
    profiles. Each profile defines which components are deployed and the default configuration.
    There are seven profiles included, but only five profiles are used for most deployments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Istio 的部署，团队包含了多个预定义的配置文件。每个配置文件定义了哪些组件被部署以及默认配置。共包含七个配置文件，但大多数部署只使用五个配置文件。
- en: '| **Profile** | **Installed Components** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **配置文件** | **已安装组件** |'
- en: '| Default | `istio-ingressgateway` and `istiod` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | `istio-ingressgateway` 和 `istiod` |'
- en: '| Demo | `istio-egressgateway`, `istio-ingressgateway`, and `istiod` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 演示 | `istio-egressgateway`、`istio-ingressgateway` 和 `istiod` |'
- en: '| Minimal | `istiod` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 精简 | `istiod` |'
- en: '| Preview | `istio-ingressgateway` and `istiod` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 预览 | `istio-ingressgateway` 和 `istiod` |'
- en: '| Ambient | `istiod`, CNI, and ZtunnelNote: In the 1.20.3 Istio release, ambient
    mesh is an alpha feature |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 环境 | `istiod`、CNI 和 Ztunnel 注：在 Istio 1.20.3 版本中，环境网格是一个 Alpha 特性 |'
- en: 'Table 16.2: Istio profiles'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.2：Istio 配置文件
- en: 'If none of the included profiles fit your deployment requirements, you can
    create a customized deployment. This is beyond the scope of this chapter since
    we will be using the included demo profile – however, you can read more about
    customizing the configuration on Istio’s site: [https://istio.io/latest/docs/setup/additional-setup/customize-installation/](https://istio.io/latest/docs/setup/additional-setup/customize-installation/).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何包含的配置文件适合你的部署需求，你可以创建一个定制的部署。由于我们将使用包含的演示配置文件，因此这超出了本章的范围——但是，你可以在 Istio
    的网站上阅读更多有关定制配置的信息：[https://istio.io/latest/docs/setup/additional-setup/customize-installation/](https://istio.io/latest/docs/setup/additional-setup/customize-installation/)。
- en: 'To deploy Istio using the demo profile using `istioctl`, we simply need to
    execute a single command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `istioctl` 部署使用演示配置文件的 Istio，我们只需执行一条命令：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The installer will ask you to verify that you want to deploy Istio using the
    default profile, which will deploy all of the Istio components:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序将询问你是否确认使用默认配置文件部署 Istio，该配置文件将部署所有 Istio 组件：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Press the *y* key to say yes to proceed with the deployment. If you want to
    bypass the confirmation, you can add an option to the `istioctl` command line,
    `--skip-confirmation`, which tells `istioctl` to bypass the confirmation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *y* 键表示同意继续部署。如果你想跳过确认，可以在 `istioctl` 命令行中添加一个选项 `--skip-confirmation`，该选项告诉
    `istioctl` 跳过确认。
- en: If everything went well, you should see a confirmation that each component was
    installed, and a completion message that thanks you for installing Istio.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到每个组件已安装的确认信息，并显示感谢你安装 Istio 的完成信息。
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `istioctl` executable can be used to verify the installation. To verify
    the installation, you require a manifest. Since we used `istioctl` to deploy Istio
    directly, we do not have a manifest, so we need to create one to check our installation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`istioctl` 可执行文件可用于验证安装。要验证安装，你需要一个清单。由于我们使用 `istioctl` 直接部署 Istio，因此没有清单，因此需要创建一个来检查我们的安装。'
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then run the `istioctl verify-install` command.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行 `istioctl verify-install` 命令。
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will verify each component, and once verified, it will provide a summary
    similar to the output below:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将验证每个组件，并在验证完成后，提供类似于下面输出的摘要：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have verified the installation, let’s look at what `istioctl` created:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了安装，让我们看看 `istioctl` 创建了什么：
- en: A new namespace called `istio-system`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `istio-system` 的新命名空间。
- en: 'Three deployments were created, and a corresponding service for each:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了三个部署，并为每个部署创建了相应的服务：
- en: '`istio-ingressgateway`'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istio-ingressgateway`'
- en: '`istio-egressgateway`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istio-egressgateway`'
- en: '`istiod`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istiod`'
- en: '15 **CustomResourceDefinitions** (**CRDs**) to provide the Istio resources,
    including:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15 个 **自定义资源定义** (**CRDs**) 用于提供 Istio 资源，包括：
- en: '`destinationrules.networking.istio.io`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destinationrules.networking.istio.io`'
- en: '`envoyfilters.networking.istio.io`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`envoyfilters.networking.istio.io`'
- en: '`gateways.networking.istio.io`'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gateways.networking.istio.io`'
- en: '`istiooperators.install.istio.io`'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istiooperators.install.istio.io`'
- en: '`peerauthentications.security.istio.io`'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peerauthentications.security.istio.io`'
- en: '`proxyconfigs.networking.istio.io`'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyconfigs.networking.istio.io`'
- en: '`requestauthentications.security.istio.io`'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestauthentications.security.istio.io`'
- en: '`serviceentries.networking.istio.io`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serviceentries.networking.istio.io`'
- en: '`sidecars.networking.istio.io`'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sidecars.networking.istio.io`'
- en: '`telemetries.telemetry.istio.io`'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`telemetries.telemetry.istio.io`'
- en: '`virtualservices.networking.istio.io`'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtualservices.networking.istio.io`'
- en: '`wasmplugins.extensions.istio.io`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wasmplugins.extensions.istio.io`'
- en: '`workloadentries.networking.istio.io`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workloadentries.networking.istio.io`'
- en: '`workloadgroups.networking.istio.io`'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workloadgroups.networking.istio.io`'
- en: At this stage, there’s no need to be concerned with the details of the Custom
    Resources (CRs). As we progress through this chapter, we’ll delve into the specifics
    of the most commonly used resources. Following that, in the next chapter, we’ll
    cover how to deploy an application into the mesh, which will make use of several
    of the CRs that have been deployed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，您无需关心自定义资源（CR）的细节。随着我们在本章中的进展，我们将深入探讨最常用资源的具体细节。接下来，在下一章中，我们将讲解如何将应用程序部署到网格中，这将涉及几个已部署的
    CR。
- en: 'For any CRs that are not covered in this chapter or the next chapter, you can
    reference the documentation on the istio.io site, located here: [istio.io/latest/docs](http://istio.io/latest/docs)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章或下一章中未涉及的任何 CR，您可以参考 istio.io 网站上的文档，地址如下：[istio.io/latest/docs](http://istio.io/latest/docs)
- en: Exposing Istio in a KinD cluster
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 KinD 集群中暴露 Istio
- en: With Istio deployed, our next step is to expose it to our network so we can
    access the applications we’ll build. Since we’re running on KinD, this can be
    tricky. Docker is forwarding all traffic from port `80` (HTTP) and `443` (HTTPS)
    on our KinD server to the worker node. The worker node is in turn running the
    NGINX Ingress controller on ports `443` and `80` to receive that traffic. In a
    real-world scenario, we’d use an external load balancer, like MetalLB, to expose
    the individual services via a LoadBalancer. For our labs though, we’re going to
    instead focus on simplicity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署 Istio 后，我们的下一步是将其暴露给我们的网络，以便我们可以访问我们将构建的应用程序。由于我们是在 KinD 上运行，这可能有些棘手。Docker
    会将所有来自端口`80`（HTTP）和`443`（HTTPS）的流量转发到我们的 KinD 服务器上的工作节点。工作节点则在端口`443`和`80`上运行
    NGINX Ingress 控制器来接收这些流量。在实际场景中，我们会使用外部负载均衡器，例如 MetalLB，通过 LoadBalancer 来暴露各个服务。然而，针对我们的实验环境，我们将重点关注简化操作。
- en: When you executed the previous script to install Istio, the last step ran a
    separate script called `expose_istio.sh` that does two things. First, it will
    delete the `ingress-nginx` namespace, removing NGINX and freeing up ports `80`
    and `443` on the Docker host. Second, it will patch the `istio-ingressgateway`
    Deployment in the `istio-system` namespace so that it runs on ports `80` and `443`
    on the worker node.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行先前的脚本来安装 Istio 时，最后一步运行了一个名为`expose_istio.sh`的独立脚本，做了两件事。首先，它会删除`ingress-nginx`命名空间，移除
    NGINX 并释放 Docker 主机上的端口`80`和`443`。其次，它会修补`istio-system`命名空间中的`istio-ingressgateway`部署，使其在工作节点上的端口`80`和`443`上运行。
- en: Since the script was executed as part of the installation, you do not need to
    execute it again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该脚本作为安装的一部分执行，因此您无需再次执行它。
- en: Now that we have Istio fully deployed in our cluster and we know the custom
    resources that Istio includes, let’s move on to the next section, which will explain
    each resource and its use-cases.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在集群中完全部署了 Istio，并了解了 Istio 包含的自定义资源，接下来我们将进入下一部分，解释每个资源及其用例。
- en: Introducing Istio resources
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Istio 资源
- en: Istio’s custom resources provide powerful features to your cluster and each
    one could take up a chapter by itself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 的自定义资源为您的集群提供了强大的功能，每个资源都可能成为一个章节的内容。
- en: In this section, we want to provide enough details so you will have a strong
    understanding of each object. After the object overview, we will deploy a basic
    application that will demonstrate many of the objects in a real-world application
    example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供足够的细节，以帮助您充分了解每个对象。概述过后，我们将部署一个基础应用程序，该应用程序将在真实的应用示例中演示许多对象。
- en: Authorization policies
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权策略
- en: Authorization policies are optional; however, if you do not create any, all
    requests to resources will be allowed access to your cluster workloads. This may
    be the desired default action for some organizations, but most enterprises should
    deploy workloads based on the least required privileges. This means that you should
    only allow what access is required for accessing the application – nothing more
    and nothing less. Least privilege access is often overlooked by organizations
    since it adds some complexity to access and if not configured correctly, it may
    deny access to valid requests. While this is true, it is not a valid argument
    to leave your systems wide open to all access requests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 授权策略是可选的；然而，如果您没有创建任何策略，所有请求都将允许访问您的集群工作负载。这可能是一些组织期望的默认行为，但大多数企业应该根据最小所需权限来部署工作负载。这意味着您应仅允许访问应用程序所需的权限——没有更多，也没有更少。最小权限访问常常被组织忽视，因为它增加了访问的复杂性，如果配置不当，可能会拒绝有效请求的访问。虽然这种情况确实存在，但这并不是让系统对所有访问请求敞开大门的合理理由。
- en: Istio’s authorization policies offer detailed access management for services
    within your mesh, allowing you to define access rights based on the identities
    of the callers and their permissions. They provide developers with the ability
    to control access to workloads based on actions including deny, allow, and custom.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Istio的授权策略提供了针对网格内服务的详细访问管理，允许你根据调用者的身份和权限定义访问权限。它们为开发人员提供了根据拒绝、允许和自定义操作控制工作负载访问的能力。
- en: Before explaining policies in more depth, we need to start with a concept called
    **implicit enablement**. This means that when **any** authorization policy matches
    a request, Istio will change the default allow all to a deny for any request that
    doesn’t have a match in the policy.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入解释策略之前，我们需要先了解一个名为**隐式启用**的概念。这意味着当**任何**授权策略与请求匹配时，Istio会将默认的“允许所有”策略转换为对任何不匹配该策略的请求的拒绝。
- en: Let’s use an example to explain this in more detail. We have an NGINX server
    running in a namespace where Istio has been enabled and we have a standard that
    access to port `80` must be denied.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来详细解释这个问题。我们在一个启用了Istio的命名空间中运行着一个NGINX服务器，并且我们有一个标准，要求拒绝访问端口`80`。
- en: At a quick glance, this looks like it should be an easy policy, we would simply
    create a deny policy that contains port `80`. So, we create the policy and deploy
    it to our cluster – and to verify the policy, we try to access the website on
    port `80`. We open a browser and, as expected, we cannot access the site. Great!
    Now let’s verify that we can access the site on port `443`. We change the URL
    to access the site using port `443`, and to our surprise, it is also *denied*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是一个简单的策略，我们只需创建一个拒绝策略，包含端口`80`。于是，我们创建了策略并将其部署到集群中——为了验证该策略，我们尝试访问端口`80`上的网站。我们打开浏览器，正如预期的那样，无法访问该站点。太好了！现在让我们验证是否能访问端口`443`上的网站。我们更改URL以使用端口`443`访问该站点，结果令我们惊讶的是，它也被*拒绝*了。
- en: Wait, what!?!? The deny policy only denies port `80` – why is port `443` also
    being denied?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么!?!? 拒绝策略仅仅拒绝端口`80`——为什么端口`443`也被拒绝了？
- en: This is **implicit enablement** in action and it can be confusing at first for
    anyone who is new to Istio. As discussed at the beginning of this section, when
    a policy is created and a request matches that policy, Istio will change from
    an *allow all* security posture, to a *deny all* security posture. Even though
    we intended to deny access to only port `80`, without an allow policy for port
    `443`, access will also be denied.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**隐式启用**的体现，对于任何刚接触Istio的人来说，可能会感到困惑。正如本节开头所讨论的，当创建一个策略并且请求匹配该策略时，Istio会从*允许所有*的安全策略转换为*拒绝所有*的安全策略。即使我们只打算拒绝访问端口`80`，如果没有为端口`443`创建允许策略，访问也会被拒绝。
- en: To complete the requirement, and allow access to our NGINX site on port `443`,
    we would need to create an allow policy that allows all incoming traffic to port
    `443`. We will explain this in more depth in a minute.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足要求并允许访问端口`443`上的NGINX站点，我们需要创建一个允许策略，允许所有传入端口`443`的流量。稍后我们将详细解释这一点。
- en: Understanding how a policy’s actions are evaluated is very important, since
    a misconfigured policy may not provide the expected results. The high-level flow
    for policy evaluation is shown in *Figure 16.1*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 理解策略如何评估操作非常重要，因为配置错误的策略可能无法提供预期的结果。策略评估的高级流程如*图16.1*所示。
- en: '![](img/B21165_16_01.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_01.png)'
- en: 'Figure 16.1: Istio policy evaluation flow'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：Istio策略评估流程
- en: If the evaluation of a **CUSTOM** action defines a **DENY** to the request,
    the access is denied, and the evaluation process stops.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**CUSTOM**操作的评估定义了对请求的**DENY**，则访问将被拒绝，评估过程将停止。
- en: Next, if a **DENY** policy matches the request, the request is denied access
    to the resource, and the evaluation process stops.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果**DENY**策略匹配请求，则该请求被拒绝访问该资源，评估过程停止。
- en: If there are no **ALLOW** policies that match the request, access will be denied
    to the request.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有与请求匹配的**ALLOW**策略，则该请求将被拒绝访问。
- en: If an **ALLOW** policy matches the request, access to the resource is granted.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**ALLOW**策略匹配请求，则授予访问该资源的权限。
- en: Along with understanding the flow of policies, you need to understand how conflicting
    policies will be implemented. If a policy has any conflicting rules, like denying
    and allowing the same request, the deny policy will be evaluated first and the
    request will be denied since the deny policy is evaluated before the allow policy.
    It’s also very important to note that if you allow a certain action, like an HTTP
    GET, the GET request would be allowed, but any other operation would be denied
    since it has not been allowed by the policy.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理解策略的流程，你还需要了解冲突的策略如何执行。如果一个策略有任何冲突的规则，比如既拒绝又允许同一个请求，则会优先评估拒绝策略，请求将被拒绝，因为拒绝策略的优先级高于允许策略。还需要特别注意的是，如果你允许某个特定操作，比如HTTP
    GET，那么GET请求会被允许，但任何其他操作都会被拒绝，因为它没有被策略允许。
- en: Authorization policies can get very complex. The Istio team has created a page
    with multiple examples on the Istio site at [https://istio.io/latest/docs/reference/config/security/authorization-policy/](https://istio.io/latest/docs/reference/config/security/authorization-policy/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 授权策略可能会变得非常复杂。Istio团队在Istio网站上创建了一个页面，提供了多个示例，地址是[https://istio.io/latest/docs/reference/config/security/authorization-policy/](https://istio.io/latest/docs/reference/config/security/authorization-policy/)。
- en: 'Policies can be broken down into scope, action, and rules:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 策略可以被拆解为范围、操作和规则：
- en: '**Scope**: The scope defines what object(s) will be enforced by the policy.
    You can scope a policy to the entire mesh, a namespace, or any Kubernetes object
    label like a pod.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：范围定义了哪些对象会受到策略的强制执行。你可以将策略作用范围限定到整个网格、一个命名空间，或任何Kubernetes对象标签，如Pod。'
- en: '**Actions**: There can be one of three actions defined, CUSTOM, ALLOW, or DENIED
    – each either denying or allowing a request based on the defined rules. ALLOW
    and DENY are the most commonly used actions, but CUSTOM actions are beneficial
    when you require complex logic that ALLOW or DENY cannot handle, using an external
    system for additional decision making.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：可以定义三种操作之一：CUSTOM、ALLOW或DENY——每种操作基于定义的规则拒绝或允许请求。ALLOW和DENY是最常用的操作，但CUSTOM操作在需要复杂逻辑的场景中非常有用，当ALLOW或DENY无法处理时，可以使用外部系统进行附加决策。'
- en: '**Rules**: Define what actions will be allowed or denied by the request. Rules
    can become very complex, allowing you to define actions based on source and destination,
    different operations, keys, and more.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则**：定义哪些操作会被请求允许或拒绝。规则可以变得非常复杂，允许你根据源和目标、不同的操作、密钥等定义动作。'
- en: To help understand the flow, let’s look at a few example authorization policies
    and what access will be applied when the policy is evaluated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解流程，让我们看几个示例授权策略，以及当策略被评估时将应用哪些访问控制。
- en: We will deploy a larger application later in the chapter. If you want to see
    how the example policies work in this section, you can deploy an NGINX web server
    using the script in the `chapter16/testapp` directory called `deploy-testapp.sh`.
    This will create all of the required Kubernetes and Istio objects to test the
    policies in a real cluster.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将在本章中部署一个更大的应用。如果你想查看本节中的示例策略如何工作，可以使用`chapter16/testapp`目录中的`deploy-testapp.sh`脚本来部署一个NGINX
    Web服务器。此脚本将创建所有必要的Kubernetes和Istio对象，以便在真实集群中测试这些策略。
- en: Once you have executed the script and the objects have been created, test that
    NGINX is working by curling to the `nip.io` VirtualService that was created. On
    our server, it created `testapp.10.3.1.248.nip.io`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本并创建了对象后，通过curl测试NGINX是否正常工作，访问刚刚创建的`nip.io`虚拟服务。在我们的服务器上，它创建了`testapp.10.3.1.248.nip.io`。
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should display the NGINX welcome page. Now, we can create some example
    policies to show how authorization policies work. Each of the three examples is
    in the `chapter16/testapp` directory named `exampleX-policy.yaml`, where `X` is
    equal to `1`, `2`, or `3` – each can be deployed using the `kubectl apply <policyname>
    -n testapp` command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示NGINX欢迎页面。现在，我们可以创建一些示例策略，展示授权策略是如何工作的。每个示例都位于`chapter16/testapp`目录下，文件名为`exampleX-policy.yaml`，其中`X`可以是`1`、`2`或`3`——每个示例都可以使用命令`kubectl
    apply <policyname> -n testapp`进行部署。
- en: 'Example 1: Denying and allowing all access'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例1：拒绝和允许所有访问
- en: 'For our first example, we will create a policy that will deny all requests
    to the resources in the namespace `testapp`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将创建一个策略，拒绝对命名空间`testapp`中的资源的所有请求：
- en: '[PRE9]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After deploying the policy, attempt to `curl` to the `nip.io` address again.
    You will notice that this time, you will be denied access and Istio will return
    an RBAC error:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 部署策略后，再次尝试`curl`访问`nip.io`地址。你会发现这次会被拒绝访问，并且Istio会返回一个RBAC错误：
- en: '[PRE10]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can take a few seconds for Istio to enable new policies. If you did not
    receive the `RBAC: access denied` error, wait a few seconds and try again.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'Istio 启用新策略可能需要几秒钟。如果你没有收到 `RBAC: access denied` 错误，请等待几秒钟再试。'
- en: 'This is a very simple policy that does not include a `selector` and defines
    nothing in the `spec` section. By omitting the `selector` section, Istio will
    apply the policy to all workloads in the namespace, and by not including anything
    in the `spec` section, Istio will deny all traffic. If we refer back to the policy
    flow diagram in *Figure 16.1*, this would flow down the bottom and evaluate as
    circle #3 – there is a `selector` match, which is *all* workloads in the namespace,
    and there hasn’t been an ALLOW policy defined. This will lead to the request being
    denied.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个非常简单的策略，它没有包含 `selector`，并且在 `spec` 部分没有定义任何内容。通过省略 `selector` 部分，Istio
    会将策略应用于命名空间中的所有工作负载，而由于 `spec` 部分没有任何内容，Istio 将拒绝所有流量。如果我们回顾 *图 16.1* 中的策略流图，它将沿底部流动，并在圆圈
    #3 处进行评估——存在一个 `selector` 匹配，即命名空间中的 *所有* 工作负载，并且没有定义 ALLOW 策略。这将导致请求被拒绝。'
- en: We won’t deploy the next example; we are showing it to reinforce the example
    provided above. By adding a single entry to the policy, we can change it from
    denying all requests to allowing all requests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会部署下一个示例；我们展示它是为了加强上面提供的示例。通过向策略添加一个条目，我们可以将其从拒绝所有请求更改为允许所有请求。
- en: '[PRE11]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we add the `rules` section to the policy definition, with a {}, we are
    creating a rule that means all traffic. Similar to the previous example, we have
    not added a `selector`, which means the policy will apply to all deployments in
    the namespace. Since this rule is for all workloads and the rule includes all
    traffic, access would be allowed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向策略定义中添加 `rules` 部分（使用 `{}`）时，我们创建了一个规则，意味着所有流量。与前面的示例类似，我们没有添加 `selector`，这意味着策略将应用于命名空间中的所有部署。由于此规则适用于所有工作负载，并且该规则包含所有流量，因此访问将被允许。
- en: You might be starting to see why we mentioned how not understanding how policies
    are evaluated in the flow may lead to unexpected access results. This is a prime
    example of how a single entry, `rules`, changes the policy from denying all requests
    to allowing all requests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经开始理解为什么我们提到不了解策略在流程中如何评估可能会导致意外的访问结果。这是一个典型的例子，展示了如何通过添加一个条目 `rules`，将策略从拒绝所有请求更改为允许所有请求。
- en: 'Before moving on, delete the policy by executing:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，通过执行以下命令删除策略：
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Example 2: Allowing only GET methods to a workload'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 2：只允许 GET 方法访问工作负载
- en: 'Policies can get very granular, allowing only certain operations like GET from
    an HTTP request. This example will allow GET requests while denying all other
    request types for pods that are labeled with `app=nginx-web` in the `marketing`
    namespace. For this example, we will use the same NGINX deployment from the first
    example. Create the policy using the manifest in the `chapter16/testapp` directory
    called `exampe2-policy.yaml` using `kubectl`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 策略可以非常细化，只允许某些操作，例如允许 HTTP 请求中的 GET 方法。这个例子将允许 GET 请求，同时拒绝所有其他请求类型，应用于在 `marketing`
    命名空间中标记为 `app=nginx-web` 的 pod。在这个示例中，我们将使用第一个示例中的相同 NGINX 部署。使用位于 `chapter16/testapp`
    目录下的 `exampe2-policy.yaml` 清单，通过 `kubectl` 创建策略：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you attempt to `curl` to the same `nip.io` address as we used in example
    1, you will see the NGINX welcome page. This is using an HTTP GET command. To
    prove that HTTP PUT commands will be blocked, we can use a `curl` command to send
    a request to NGINX:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试 `curl` 访问与示例 1 中相同的 `nip.io` 地址，你将看到 NGINX 欢迎页面。这是使用 HTTP GET 命令进行的。为了证明
    HTTP PUT 命令会被阻止，我们可以使用 `curl` 命令向 NGINX 发送请求：
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will cause Istio to deny the request with an RBAC error:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 Istio 拒绝请求，并出现 RBAC 错误：
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the example, the policy accepts the GET request from any source, since we
    have only defined an action without a specific `from` object. Since we have not
    added the PUT action in our policy, any attempt to send an HTTP PUT request will
    be denied by the policy.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，策略接受来自任何来源的 GET 请求，因为我们只定义了一个操作而没有指定具体的 `from` 对象。由于我们没有在策略中添加 PUT 操作，任何尝试发送
    HTTP PUT 请求的行为将被策略拒绝。
- en: Policies can get even more granular, accepting (or denying) a request based
    on the source of the request. In the next example, we will show another example
    of a policy but we will limit the source to a single IP address.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 策略甚至可以更细化，根据请求的来源来接受（或拒绝）请求。在下一个示例中，我们将展示另一个策略示例，但我们将把来源限制为单一的 IP 地址。
- en: 'Before moving on, delete the example policy using `kubectl`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，使用`kubectl`删除示例策略：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Example 3: Allowing requests from a specific source'
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例3：允许来自特定来源的请求
- en: In our last policy example, we will limit what source will be allowed access
    to a workload using a GET or POST method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后的策略示例中，我们将限制哪些来源可以使用GET或POST方法访问工作负载。
- en: This will increase security by denying any request from a source that is not
    in the policy source list. We will not create this policy since many readers may
    be limited in the number of machines they have to use for testing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拒绝任何来自不在策略源列表中的来源的请求，这将增强安全性。我们不会创建这个策略，因为许多读者可能在测试时受限于可用的机器数量。
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unlike the previous examples, this policy has a `source:` section, which allows
    you to limit access based on different sources, like an IP address. This policy
    will allow the source IP `192.168.10.100` access to all operations on the NGINX
    server, and all other sources will be denied access.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例不同，这个策略包含一个`source:`部分，允许你根据不同的来源（如IP地址）限制访问。这个策略将允许源IP `192.168.10.100`访问NGINX服务器上的所有操作，其他所有来源的访问将被拒绝。
- en: Moving on from authorization policies, we will introduce our next custom resource,
    destination gateways.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从授权策略转向，我们将介绍下一个自定义资源——目标网关。
- en: Gateways
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网关
- en: Earlier, we mentioned that traffic will come into a central point, `istio-ingressgateway`.
    We didn’t explain how the traffic flows from the `ingressgateway` to a namespace
    and workloads – this is where gateways come in.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到过流量将进入一个中央点`istio-ingressgateway`。我们没有解释流量如何从`ingressgateway`流向命名空间和工作负载——这就是网关的作用。
- en: A gateway can be configured at the namespace, so you can delegate the creation
    and configuration to a team. It is a load balancer that receives incoming and
    outgoing traffic that can be customized with options like accepted ciphers, TLS
    versions, certificate handling, and more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 网关可以在命名空间级别进行配置，因此你可以将创建和配置的任务委托给一个团队。它是一个负载均衡器，接收传入和传出的流量，可以通过诸如接受的加密套件、TLS版本、证书处理等选项进行自定义。
- en: Gateways work along with Virtual Services, which we will discuss in the next
    section, but until then, the following figure shows the interaction between the
    `Gateway` and `VirtualService` objects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 网关与虚拟服务一起工作，我们将在下一节中讨论虚拟服务，但在此之前，以下图示展示了`Gateway`和`VirtualService`对象之间的交互。
- en: '![](img/B21165_16_02.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_02.png)'
- en: 'Figure 16.2: Gateway to Virtual Service communication flow'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：网关到虚拟服务的通信流
- en: 'The list below explains the communication shown in *Figure 16.2* in more detail:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表更详细地解释了*图16.2*中所示的通信：
- en: An incoming request is sent to the Istio `ingress-gateway` controller, located
    in the `istio-system` namespace.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个传入请求被发送到Istio的`ingress-gateway`控制器，该控制器位于`istio-system`命名空间中。
- en: The `sales` namespace has a gateway configured that is set to use the `ingressgateway`
    with a host of `entry.foowidgets.com`. This tells the `ingressgateway` to send
    the request to the gateway object in the `sales` namespace.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sales`命名空间有一个配置了`ingressgateway`的网关，主机名为`entry.foowidgets.com`。这告诉`ingressgateway`将请求发送到`sales`命名空间中的网关对象。'
- en: Finally, the traffic is routed to the service using a Virtual Service object
    that has been created using the gateway in the `sales` namespace.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，流量通过一个已使用网关在`sales`命名空间中创建的虚拟服务对象路由到服务。
- en: To show an example `Gateway` configuration, we have a namespace called `sales`
    that has Istio enabled, running an application that can be accessed using the
    URL `entry.foowidgets.com`, and we need to expose it for external access. To accomplish
    this, we would create a gateway using the example manifest below. (The example
    below is just for discussion; you do not need to deploy it on your KinD cluster.)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示一个`Gateway`配置示例，我们有一个启用了Istio的名为`sales`的命名空间，运行着一个可以通过URL`entry.foowidgets.com`访问的应用程序，我们需要将其暴露以供外部访问。为此，我们将创建一个网关，使用以下示例清单。（下面的示例仅供讨论；你不需要在你的KinD集群上部署它。）
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This gateway configuration will tell the ingress gateway to listen on port `443`
    for requests that are incoming for `sales.foowidgets.com`. It also defines the
    certificates that will be used to secure the communication for incoming web requests.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网关配置将告诉入口网关在端口`443`上监听来自`sales.foowidgets.com`的传入请求。它还定义了将用于保护传入Web请求的通信的证书。
- en: You may be wondering, “How does it know to use the ingress gateway that we have
    running in our cluster?” If you look at the `spec` section, and then the selector,
    we have configured the `selector` to use an ingress gateway that has the label
    `istio=ingressgateway`. This `selector` and label tell the gateway object which
    ingress gateway will create our new gateway for incoming connections. When we
    deployed Istio earlier, the ingress gateways were labeled with the default label
    `istio=ingressgateway`, as shown highlighted below, from a `kubectl get pods --show-labels
    -n istio-system`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“它怎么知道使用我们在集群中运行的入口网关？”如果你查看`spec`部分，然后查看选择器，我们已经配置了`selector`，使用带有`istio=ingressgateway`标签的入口网关。这个`selector`和标签告诉网关对象哪个入口网关将为我们的新网关创建传入连接。当我们之前部署
    Istio 时，入口网关被标记为默认标签`istio=ingressgateway`，如下所示，来自`kubectl get pods --show-labels
    -n istio-system`的输出。
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may be wondering how the gateway will be used to direct traffic to a particular
    workload since there are no configuration options in the gateway telling it where
    to direct traffic. That’s because the gateway just configures the ingress gateways
    to accept traffic for a destination URL and the required ports – it does not control
    how the traffic will flow to a service; that’s the job of the next object, the
    `Virtual Service` object.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，既然网关中没有配置选项告诉它将流量引导到哪里，那么网关将如何被用来指引流量到特定的工作负载呢？这是因为网关只是配置了入口网关来接受指向目标
    URL 的流量以及所需的端口——它并不控制流量如何流向服务；这是下一个对象，`虚拟服务`对象的工作。
- en: Virtual services
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟服务
- en: Gateways and virtual services combine to provide the correct traffic route to
    a service, or services. Once you have a gateway deployed, you need to create a
    virtual service object to tell the gateway how to route traffic to your service(s).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 网关和虚拟服务结合在一起，为服务或服务提供正确的流量路由。一旦您部署了网关，您需要创建一个虚拟服务对象来告诉网关如何将流量路由到您的服务。
- en: Building on the gateway example, we need to tell the gateway how to route traffic
    to our web server running on port `443`. The server has been deployed using NGINX
    in the `marketing` namespace and it has a label of `app-nginx` and a service named
    `frontend`. To route traffic to the NGINX service, we would deploy the manifest
    below. (The example below is just for discussion; you do not need to deploy it
    on your KinD cluster.)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网关示例，我们需要告诉网关如何将流量路由到运行在端口`443`上的 Web 服务器。该服务器已使用 NGINX 在`marketing`命名空间中部署，并具有`app-nginx`标签和一个名为`frontend`的服务。为了将流量路由到
    NGINX 服务，我们将部署以下清单。（下面的示例仅供讨论；您无需在 KinD 集群上部署它。）
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Breaking down the manifest, we specify the host(s) that this `VirtualService`
    object will route; in our example, we only have one host, `entry.foowidgets.com`.
    The next field defines which gateway will be used for the traffic; in the previous
    section, we defined a gateway called `marketing-gateway`, which was configured
    to listen on port `443`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 分解清单时，我们指定了这个`VirtualService`对象将路由的主机；在我们的示例中，我们只有一个主机，`entry.foowidgets.com`。下一个字段定义了将用于流量的网关；在上一节中，我们定义了一个名为`marketing-gateway`的网关，并配置它监听端口`443`。
- en: 'Finally, the last section defines which service the traffic will be routed
    to. The route, destination, and port are all fairly straightforward to understand,
    but the `host` section can be misleading. This field actually defines the service
    that you will route the traffic to. In the example, we are going to route the
    traffic to a service called `entry`, so our field is defined with `host: entry`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，最后一部分定义了流量将路由到哪个服务。路由、目标和端口都很容易理解，但`host`部分可能会让人误解。该字段实际上定义了您将路由流量到的服务。在这个示例中，我们将流量路由到一个名为`entry`的服务，因此我们的字段被定义为`host:
    entry`。'
- en: With this knowledge of using gateways and virtual services to route traffic
    in the Service mesh, we can move on to the next topic, destination rules.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解如何使用网关和虚拟服务在服务网格中路由流量，我们可以继续讨论下一个主题：目标规则。
- en: Destination rules
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标规则
- en: Virtual services provide a basic method to direct traffic to a service, but
    Istio offers an additional object to create complex traffic direction by using
    `Destination` rules. `Destination` rules are applied after Virtual Services. Traffic
    is initially routed using a Virtual Service and, if defined, a `Destination` rule
    can be used to route the request to its final destination.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟服务提供了一种基本的方法来将流量导向服务，但 Istio 提供了一个额外的对象，通过使用 `Destination` 规则来创建复杂的流量导向。`Destination`
    规则在虚拟服务之后应用。流量最初使用虚拟服务路由，如果定义了 `Destination` 规则，可以使用该规则将请求路由到最终目的地。
- en: This may be confusing at first, but it becomes easier when you see an example,
    so let’s dive into an example that can route traffic to different versions of
    a deployment.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始有点混淆，但当你看到一个示例时会变得容易理解，所以让我们通过一个示例来深入了解，它可以将流量路由到不同版本的部署。
- en: As we learned, incoming requests will use the Virtual Service initially, and
    then a destination rule, if defined, will route the request to the destination.
    In this example, we have already created a Virtual Service but we actually have
    two versions of the application labeled `v1` and `v2` and we want to direct traffic
    between both versions of the application using round-robin. To accomplish this,
    we would create a `DestinationRule` using the manifest below. (The example below
    is just for discussion; you do not need to deploy it on your KinD cluster.)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所学，传入的请求最初会使用虚拟服务，然后，如果定义了目标规则，它将路由请求到目标。在这个示例中，我们已经创建了一个虚拟服务，但实际上我们有两个版本的应用程序，分别标记为
    `v1` 和 `v2`，我们想要使用轮询方式在这两个版本之间进行流量导向。为了实现这一点，我们将使用下面的清单创建一个 `DestinationRule`。（下面的示例仅用于讨论；你不需要在你的
    KinD 集群上部署它。）
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using this example, incoming requests to the NGINX server will be split between
    the two versions of the application equally since we defined the `loadBalancer`
    policy as `ROUND_ROBIN`. But what if we wanted to route traffic to the version
    that had the least number of connections? Destination rules have other options
    for `loadBalancer`, and to route connections to the version with the least connections,
    we would set the `LEAST_CONN` `loadBalancer` policy.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个示例，传入 NGINX 服务器的请求将平分到应用程序的两个版本中，因为我们将 `loadBalancer` 策略定义为 `ROUND_ROBIN`。但如果我们想要将流量路由到连接数最少的版本呢？目标规则对于
    `loadBalancer` 还有其他选项，如果要将连接路由到连接数最少的版本，我们将设置 `LEAST_CONN` 的 `loadBalancer` 策略。
- en: Next, we will discuss some of the security features Istio provides, starting
    with an object called Peer Authentication.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 Istio 提供的一些安全功能，首先是一个名为 Peer Authentication 的对象。
- en: Peer authentication
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对等认证
- en: Istio’s peer authentication object controls how the Service mesh controls the
    mutual TLS settings for workloads, either for the entire Service mesh or just
    a namespace. Each policy can be configured with a value that will either allow
    both encrypted communication and non-encrypted communication between pods or require
    encryption between pods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 的对等认证对象控制了服务网格如何控制工作负载的互相 TLS 设置，这些设置可以应用于整个服务网格或仅仅是某个命名空间。每个策略都可以配置一个值，这个值要么允许
    pod 之间进行加密和非加密通信，要么要求 pod 之间进行加密通信。
- en: '| **mTLS mode** | **Pod communication** | **Description** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **mTLS 模式** | **Pod 通信** | **描述** |'
- en: '| `STRICT` | mTLS required | Any non-encrypted traffic sent to a pod will be
    denied |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `STRICT` | mTLS 必须 | 任何发送到 Pod 的非加密流量将被拒绝 |'
- en: '| `PERMISSIVE` | mTLS optional | Both encrypted and non-encrypted traffic will
    be accepted by the pod |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `PERMISSIVE` | mTLS 可选 | Pod 会接受加密和非加密流量 |'
- en: 'Table 16.3: PeerAuthentication options'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.3：PeerAuthentication 选项
- en: 'If you wanted to set `PeerAuthentication` for the entire mesh, you would create
    a `PeerAuthentication` in the `istio-system` namespace. For example, to require
    mTLS between all pods, you would create the policy shown below:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为整个服务网格设置 `PeerAuthentication`，你需要在 `istio-system` 命名空间中创建一个 `PeerAuthentication`。例如，要要求所有
    pod 之间使用 mTLS，你需要创建如下所示的策略：
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To allow both encrypted and non-encrypted traffic, the policy mode just needs
    to be set to `PERMISSIVE`, by changing the mode to `mode: PERMISSIVE`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '要允许加密和非加密流量，策略模式只需设置为 `PERMISSIVE`，通过将模式更改为 `mode: PERMISSIVE` 即可。'
- en: Rather than setting the mode for the entire mesh, many enterprises only set
    the mode to `STRICT` for namespaces that require additional security. In the example
    below, we set the mode to `STRICT` for the `sales` namespace.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为整个服务网格设置模式，许多企业只为需要额外安全性的命名空间将模式设置为 `STRICT`。在下面的示例中，我们为 `sales` 命名空间将模式设置为
    `STRICT`。
- en: '[PRE24]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since this policy is configured for the `sales` namespace, rather than the `istio-system`
    namespace, Istio will only enforce a strict mTLS policy for the namespace rather
    than the entire Service mesh.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此策略是为 `sales` 命名空间配置的，而不是为 `istio-system` 命名空间配置的，Istio 将仅对该命名空间强制执行严格的 mTLS
    策略，而不是对整个服务网格执行。
- en: This is a great security feature provided by the mesh, but encryption won’t
    stop a request from hitting our workload; it simply encrypts it. The next object
    we will discuss will add a level of security to a workload by requiring authentication
    before being allowed access.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网格提供的一个很好的安全功能，但加密并不会阻止请求访问我们的工作负载；它只是对请求进行加密。接下来我们将讨论的对象将通过要求认证才能允许访问，进一步增强工作负载的安全性。
- en: Request authentication and authorization policies
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求认证和授权策略
- en: Security requires two pieces. First, the authentication piece, which is “who
    you are.” The second piece is authorization, which is the actions that are allowed
    once authentication has been provided, or “what you can do.”
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性需要两部分。首先是认证部分，告诉我们“你是谁”。第二部分是授权，即提供认证后，允许的操作或“你可以做什么”。
- en: '`RequestAuthentication` objects are only one part required to secure a workload.
    To fully secure the workload, you need to create the `RequestAuthentication` object
    and an `AuthorizationPolicy`. The `RequestAuthentication` policy will determine
    what identities are allowed access to the workload, and the `AuthorizationPolicy`
    will determine what permissions are allowed.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestAuthentication` 对象只是确保工作负载安全的一个部分。要完全保障工作负载的安全，你需要创建 `RequestAuthentication`
    对象和 `AuthorizationPolicy`。`RequestAuthentication` 策略将决定哪些身份被允许访问工作负载，而 `AuthorizationPolicy`
    策略将决定哪些权限被允许。'
- en: A `RequestAuthorization` policy without an `AuthorizationPolicy` can lead to
    unintentionally allowing access to the resource. If you only create a `RequestAuthorization`
    policy, the access in *Table 16.4* shows who would be allowed access.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `AuthorizationPolicy`，`RequestAuthorization` 策略可能会无意中允许访问资源。如果你只创建了一个 `RequestAuthorization`
    策略，*表 16.4* 显示了哪些人会被允许访问。
- en: '| **Token action** | **Access provided** |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **令牌操作** | **提供的访问权限** |'
- en: '| Invalid token provided | Access will be denied |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 提供无效令牌 | 访问将被拒绝 |'
- en: '| No token provided | Access will be granted |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 未提供令牌 | 将允许访问 |'
- en: '| Valid token provided | Access will be granted |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 提供有效令牌 | 将允许访问 |'
- en: 'Table 16.4: RequestAuthentication access'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.4：RequestAuthentication 访问
- en: As you can see, once we create a policy, any invalid JWT will be denied access
    to the workload, and any valid token will be allowed access to the workload. However,
    when no token is provided, many people think that access would be denied, but
    in reality, access would be allowed. A `RequestAuthentication` policy only verifies
    the tokens, and if no token is present, the `RequestAuthentication` rule will
    not deny the request.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一旦我们创建了策略，任何无效的 JWT 都会被拒绝访问工作负载，而任何有效的令牌将被允许访问工作负载。然而，当没有提供令牌时，许多人认为访问会被拒绝，但实际上，访问将被允许。`RequestAuthentication`
    策略仅验证令牌，如果没有令牌，`RequestAuthentication` 规则将不会拒绝请求。
- en: An example manifest is shown below. We will use this manifest in the examples
    section of the chapter, but we wanted to show it in this section to explain the
    fields.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例清单。我们将在本章的示例部分使用这个清单，但在本节中先展示它以解释各个字段。
- en: '[PRE25]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This manifest will create a policy that configures a workload with the label
    `matching app=frontend` in the `demo` namespace to accept JWTs from the issuer
    `testing@secure.istio.io` with a URL to confirm the tokens at [https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json](https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单将创建一个策略，该策略配置位于 `demo` 命名空间中、标签为 `matching app=frontend` 的工作负载，接受来自 `testing@secure.istio.io`
    的 JWT，并且使用 [https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json](https://raw.githubusercontent.com/istio/istio/release-1.11/security/tools/jwt/samples/jwks.json)
    这个 URL 来确认令牌。
- en: 'This URL contains the key used to validate the tokens:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此 URL 包含用于验证令牌的密钥：
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When a token is presented, it will be verified that it came from the issuer
    defined in the `jwtRules` section of the `RequestAuthenctication` object.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当令牌被提供时，将验证它是否来自 `RequestAuthentication` 对象中 `jwtRules` 部分定义的颁发者。
- en: We’ll walk through an example of how token authentication works in depth in
    the next chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章详细介绍令牌身份验证是如何工作的。
- en: Service entries
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务条目
- en: Once a workload is part of a Service mesh, its sidecar proxy will handle all
    outbound communication to services within the mesh. If the workload attempts to
    communicate with an external service that is not part of the mesh, this communication
    may fail if not properly configured. Fortunately, Istio provides mechanisms to
    define and manage external services, allowing workloads to communicate with services
    outside the mesh. One such mechanism is the `ServiceEntry` object, which allows
    you to define services that are external to the mesh and configure how these services
    should be accessed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作负载成为服务网格的一部分，它的边车代理将处理所有与网格内服务的出站通信。如果工作负载试图与网格外的外部服务进行通信，而未正确配置，则这种通信可能会失败。幸运的是，Istio
    提供了定义和管理外部服务的机制，使工作负载能够与网格外的服务进行通信。其中一种机制是`ServiceEntry`对象，它允许你定义外部网格的服务，并配置这些服务的访问方式。
- en: If you have a requirement for a workload in your Service mesh to communicate
    with a service outside of the Service mesh, you need to create an entry in the
    mesh for the external resource. This can be done in two ways, and the first method
    leads us to our next custom resource, the `ServiceEntry` object, which allows
    you to add external entries to the Service mesh. When you create a `ServiceEntry`
    for an external service, it will appear as if it was part of the actual Service
    mesh. This allows traffic to be routed to manually specified services from inside
    the Service mesh. Without a `ServiceEntry`, any attempt to communicate with the
    external resource would fail since Istio would attempt to look up the service
    in the Service mesh entries and it would fail to find the resource (since it is
    not part of the mesh).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个要求，要求你的工作负载在服务网格内与服务网格外的服务通信，那么你需要为外部资源在网格中创建一个条目。这可以通过两种方式来完成，第一种方法引出了我们下一个自定义资源——`ServiceEntry`对象，它允许你将外部条目添加到服务网格中。当你为外部服务创建`ServiceEntry`时，它将表现得像是实际服务网格的一部分。这允许流量从服务网格内路由到手动指定的服务。如果没有`ServiceEntry`，任何尝试与外部资源通信的行为都会失败，因为
    Istio 会试图在服务网格条目中查找该服务，但无法找到该资源（因为它不是网格的一部分）。
- en: To create a `ServiceEntry`, you need to create a new object that contains the
    hosts and ports for the external service. The example below will create a new
    entry that adds the host `api.foowidgets.com` on port `80`, using HTTP, to the
    Service mesh.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`ServiceEntry`，你需要创建一个新对象，其中包含外部服务的主机和端口。下面的示例将创建一个新条目，将主机`api.foowidgets.com`（端口`80`）通过
    HTTP 协议添加到服务网格中。
- en: '[PRE27]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ServiceEntries are a great resource to explicitly add external resources to
    a Service mesh. We mentioned that there are two ways to add external resources
    to the Service mesh, Service entries being one – and the other being the `Sidecars`
    object. The choice of which object to use is very specific to your own use-cases
    and organizational standards. Service entries are very specific and you must create
    an entry for each external resource you need to communicate with. Sidecars are
    different, and instead of defining what is external to the Service mesh, you define
    what is in the Service mesh.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceEntry`是将外部资源显式添加到服务网格中的绝佳资源。我们提到过有两种方法可以将外部资源添加到服务网格中，其中一种是服务条目，另一种是`Sidecars`对象。选择使用哪种对象非常具体，取决于你自己的使用案例和组织标准。服务条目是非常具体的，你必须为每个需要通信的外部资源创建一个条目。边车则不同，它不是定义什么是服务网格外的资源，而是定义什么在服务网格内。'
- en: Sidecars
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边车
- en: First, we know this can be confusing – this object is not the sidecar itself;
    it is an object that allows you to define what items your sidecar considers to
    be “in the mesh.” Depending on the size of your cluster, you may have thousands
    of services in the mesh and if you do not create a sidecar object, your Envoy
    sidecar will assume that your service needs to communicate with every other service.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们知道这可能会让人感到困惑——这个对象不是边车本身；它是一个允许你定义边车认为“在网格中”的项目的对象。根据集群的大小，你的网格中可能有成千上万的服务，如果你没有创建边车对象，Envoy
    边车将假定你的服务需要与所有其他服务通信。
- en: Typically, you may only need your namespace to communicate with services in
    the same namespace or a small number of other namespaces. Since tracking every
    service in the mesh requires resources, it’s considered good practice to create
    a sidecar object to reduce the required memory in each Envoy sidecar.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能只需要你的命名空间与同一命名空间内的服务或少数其他命名空间的服务进行通信。由于追踪网格中的每个服务需要资源，因此最好创建一个边车对象，以减少每个
    Envoy 边车所需的内存。
- en: 'To create a sidecar object that limits the services in your Envoy proxy, you
    would deploy the manifest shown below:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个限制 Envoy 代理中服务的边车对象，你需要部署下面显示的清单：
- en: '[PRE28]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `spec` in this manifest contains a list of hosts for the mesh, the `./*`
    references the namespace where the object was created, and all sidecars should
    contain the namespace where Istio was deployed, which would be `istio-system`,
    by default.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单中的 `spec` 包含了网格中主机的列表，`./*` 引用的是创建该对象的命名空间，所有的边车应该包含部署 Istio 的命名空间，默认情况下为
    `istio-system`。
- en: 'If we had three namespaces that needed to communicate across the mesh, we would
    simply need to add the additional namespaces to the hosts’ entries:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有三个命名空间需要在网格中进行通信，我们只需将额外的命名空间添加到主机的条目中：
- en: '[PRE29]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Failing to limit the mesh objects may result in your Envoy sidecar crashloops
    due to resources. You may experience an **out of memory** (**OOM**) event, or
    simply crashloops that do not show any details of the root cause. If you experience
    these scenarios, deploying a sidecar object may resolve the issue.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 未能限制网格对象可能导致你的 Envoy 边车发生崩溃循环，这可能是由于资源不足引起的。你可能会遇到 **内存不足**（**OOM**）事件，或者只是出现不显示任何根本原因的崩溃循环。如果你遇到这些情况，部署一个边车对象可能会解决问题。
- en: Envoy filters
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Envoy 过滤器
- en: Envoy filters provide you with the ability to create custom configurations that
    are generated by Istio. Remember that Pilot (part of istiod) is responsible for
    sidecar management. When any configuration is sent to Istio, Pilot will convert
    the configuration for Envoy to utilize. Since you are “limited” by the options
    in the Istio custom resource, you may not have all of the potential configuration
    options that are required for a workload, and that’s where Envoy filters come
    in.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 过滤器使你能够创建由 Istio 生成的自定义配置。记住，Pilot（Istiod 的一部分）负责边车的管理。当任何配置发送到 Istio
    时，Pilot 会将配置转换为 Envoy 可用的格式。由于你受限于 Istio 自定义资源中的选项，你可能无法拥有某些工作负载所需的所有潜在配置选项，这时候
    Envoy 过滤器就派上用场了。
- en: Filters are very powerful, and potentially dangerous, configuration objects.
    They allow you to customize values that you cannot customize from a standard Istio
    object, allowing you to add filters, listeners, fields, and more. This brings
    a quote used in Spider-Man from the late Stan Lee to mind, “With great power comes
    great responsibility.” Envoy filters provide you with extended configuration options,
    but if a filter is misused, it could bring down the entire Service mesh.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是非常强大且潜在危险的配置对象。它们允许你自定义标准 Istio 对象无法自定义的值，允许你添加过滤器、监听器、字段等。这让我想起了已故斯坦·李在《蜘蛛侠》中的一句话：“能力越大，责任越大。”
    Envoy 过滤器为你提供了扩展的配置选项，但如果过滤器被滥用，可能会导致整个服务网格崩溃。
- en: Envoy filters are complex and, for the purposes of this book, are not a topic
    that needs deep understanding to understand Istio in general. You can read more
    about Envoy filters on the Istio site at [https://istio.io/latest/docs/reference/config/networking/envoy-filter/](https://istio.io/latest/docs/reference/config/networking/envoy-filter/).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 过滤器很复杂，对于本书的目的来说，并不是理解 Istio 所需深入了解的主题。你可以在 Istio 网站上阅读更多关于 Envoy 过滤器的内容，网址是
    [https://istio.io/latest/docs/reference/config/networking/envoy-filter/](https://istio.io/latest/docs/reference/config/networking/envoy-filter/)。
- en: WASM plugins
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WASM 插件
- en: Similar to Envoy filters, the `WasmPlugins` object is used to extend the capabilities
    of the Envoy sidecar. While they are similar in what they provide, they each provide
    different degrees of customization.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Envoy 过滤器类似，`WasmPlugins` 对象用于扩展 Envoy 边车的功能。虽然它们在提供的功能上类似，但它们提供的自定义程度各不相同。
- en: Typically, `WasmPlugins` are regarded as more straightforward to develop and
    implement, making them less complex and dangerous compared to Envoy filters. This
    simplicity, however, comes at the cost of reduced functionality relative to what
    Envoy filters can offer.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`WasmPlugins` 被认为更易于开发和实现，使它们比 Envoy 过滤器更简单，也更不危险。然而，这种简化带来了功能的减少，相对于 Envoy
    过滤器提供的功能，`WasmPlugins` 功能较少。
- en: Envoy filters provide detailed, fine-grained control over the proxy settings,
    enabling the creation of more sophisticated operations than is possible with `WasmPlugins`.
    This level of control contributes to their complexity and the potential risk they
    pose if improperly configured or used, which could lead to disruptions within
    your Service mesh.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 过滤器提供了对代理设置的详细、精细控制，使得能够创建比 `WasmPlugins` 更复杂的操作。这种控制程度增加了它们的复杂性，如果配置或使用不当，可能会带来风险，从而导致服务网格中的中断。
- en: The choice between `EnvoyFilters` and `WasmPlugins` ultimately depends on your
    specific needs and preferences. It’s important to consider various factors when
    deciding which option to adopt, weighing the trade-offs between ease of use, functionality,
    and the potential impact on your Service mesh.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `EnvoyFilters` 还是 `WasmPlugins` 最终取决于你的具体需求和偏好。决定采用哪种方案时，重要的是考虑各种因素，权衡易用性、功能性以及对服务网格的潜在影响。
- en: Deploying add-on components to provide observability
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署插件组件以提供可观察性
- en: By now, you know how to deploy Istio and understand some of the most used objects,
    but you haven’t seen one of the most useful features yet – observability. At the
    beginning of the chapter, we mentioned that observability is one of our favorite
    features provided by Istio, and in this chapter, we will explain how to deploy
    a popular Istio add-on called Kiali.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经知道如何部署 Istio，并理解了一些最常用的对象，但你还没有看到其中一个最有用的功能——可观察性。在本章开始时，我们提到过可观察性是
    Istio 提供的我们最喜欢的功能之一，本章将解释如何部署一个叫做 Kiali 的流行 Istio 插件。
- en: Installing Istio add-ons
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Istio 插件
- en: 'When you deploy Istio, you provide a Service mesh and all of the features to
    your developers. While this is powerful by itself, you need to add a few extra
    components to truly provide a complete solution. There are four add-ons that you
    should add to your Service mesh – while there are alternatives to some of the
    solutions, we are using the most commonly used add-ons, specifically:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署 Istio 时，你为开发人员提供了一个服务网格及其所有功能。虽然这本身很强大，但你需要添加一些额外的组件才能真正提供一个完整的解决方案。你应该为你的服务网格添加四个插件——虽然有些解决方案有替代方案，但我们使用的是最常用的插件，具体如下：
- en: Prometheus
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus
- en: Grafana
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana
- en: Jaeger
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaeger
- en: Kiali (which we will cover in the next section)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kiali（我们将在下一节中介绍）
- en: We have discussed Prometheus and Grafana in previous chapters, but Jaeger is
    a new component that we have not mentioned before.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中讨论了 Prometheus 和 Grafana，但 Jaeger 是一个我们之前没有提到的新组件。
- en: Jaeger is an open-source offering that provides tracing between services in
    Istio. Tracing may be a new term to some readers. At a high level, traces are
    a representation of the execution path to a service. These allow us to view the
    actual path of the communication between services, providing an easy-to-understand
    view that provides metrics about performance and latency, allowing you to resolve
    issues quickly.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger 是一个开源工具，提供 Istio 中服务之间的追踪。追踪对一些读者来说可能是一个新词。从高层次看，追踪是对服务执行路径的表示。它们让我们能够查看服务之间实际的通信路径，提供一个易于理解的视图，并提供关于性能和延迟的度量，帮助你快速解决问题。
- en: To deploy all of the add-ons, we have included a script to deploy Prometheus
    in the `chapter16/add-ons` directory, called `deploy-add-ons.sh`. Execute the
    script to deploy the add-ons in your cluster.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署所有插件，我们在 `chapter16/add-ons` 目录下包含了一个脚本，名为 `deploy-add-ons.sh`，用来在集群中部署插件。执行该脚本即可部署插件。
- en: Many add-on example deployments do not maintain state, so for our deployment
    we have added persistency, leveraging the provisioner built into KinD, by adding
    persistent disks to each deployment.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 许多插件示例部署不维持状态，因此我们在部署中添加了持久性，利用 KinD 内置的配置器，通过为每个部署添加持久磁盘来实现。
- en: 'The script executes the steps outlined below:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行以下步骤：
- en: Deploys each add-on using standard Kubernetes manifests in the `istio-system`
    namespace.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准 Kubernetes 清单在 `istio-system` 命名空间中部署每个插件。
- en: Each deployment creates a PVC and mounts it as the data location to maintain
    persistency across reboots.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个部署都会创建一个 PVC，并将其挂载为数据位置，以保持重启后的持久性。
- en: Finds your host’s IP address to create new Gateway and VirtualService entries
    for each add-on.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找主机的 IP 地址，为每个插件创建新的 Gateway 和 VirtualService 条目。
- en: Creates a shared Istio Gateway that will be used by each of the add-ons.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个共享的 Istio Gateway，供每个插件使用。
- en: 'Creates VirtualServices that contain your `nip.io` URLs. The three URLs that
    will be created are:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含 `nip.io` URL 的 VirtualServices。将创建的三个 URL 是：
- en: '`prom.<Host IP>.nip.io`'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`prom.<Host IP>.nip.io`'
- en: '`grafana.<Host IP>.nip.io`'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grafana.<Host IP>.nip.io`'
- en: '`kiali.<Host IP>.nip`.`io`'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kiali.<Host IP>.nip.io`'
- en: The final output from the script will contain the URLs that were created for
    you.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最终输出将包含为你创建的 URL。
- en: With the add-ons deployed, we can move on to the next section, which will cover
    the main tool for observability, Kiali.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 插件部署完成后，我们可以继续进入下一节，这一节将介绍主要的可观察性工具，Kiali。
- en: Installing Kiali
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Kiali
- en: Kiali provides a powerful management console for our Service mesh. It provides
    graphical views of our services, pods, traffic security, and more. Since it’s
    a very useful tool for both developers and operators, the remainder of this chapter
    will focus on deploying and using Kiali.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Kiali 提供了一个强大的管理控制台，用于管理我们的服务网格。它提供了服务、Pod、流量安全等的图形化视图。由于它是开发人员和运维人员都非常有用的工具，本章剩余的内容将集中于部署和使用
    Kiali。
- en: There are a few options to deploy Kiali, but we will use the most common installation
    method, using a Helm chart. To deploy the chart and create the required objects
    to access the Kiali UI, we have provided a script in the `chapter16/kiali` directory
    called `deploy-kiali.sh`. Execute the script to deploy Kiali.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以部署 Kiali，但我们将使用最常见的安装方法，即使用 Helm chart。为了部署该 chart 并创建访问 Kiali UI 所需的对象，我们在
    `chapter16/kiali` 目录中提供了一个名为 `deploy-kiali.sh` 的脚本。执行该脚本来部署 Kiali。
- en: The script will deploy Kiali into your cluster, in the `istio-system` namespace,
    pre-configured to integrate with the add-ons we deployed in the previous section.
    It will also expose Kiali’s UI using a `nip.io` URL, which will be provided at
    the end of the script execution.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将把 Kiali 部署到你的集群中的 `istio-system` 命名空间，并预配置与我们在上一部分部署的附加组件进行集成。它还将使用 `nip.io`
    URL 暴露 Kiali 的 UI，URL 会在脚本执行结束时提供。
- en: This deploys an anonymous access dashboard; however, Kiali can accept other
    authentication mechanisms to secure the dashboard. In the next chapter, we will
    modify the Kiali deployment to accept JWTs, using OpenUnison as the provider.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这会部署一个匿名访问的仪表盘；然而，Kiali 可以接受其他身份验证机制来保护仪表盘。在下一章，我们将修改 Kiali 部署以接受 JWT，并使用 OpenUnison
    作为提供者。
- en: Deploying an application into the Service mesh
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序部署到服务网格中
- en: We could define the components and objects of Istio all day, but if you are
    like us, you will find examples and use-cases more beneficial to understanding
    advanced concepts like the features provided by Istio. In this section, we will
    explain many of the custom resources in detail, providing examples that you can
    deploy in your KinD cluster.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以整天定义 Istio 的组件和对象，但如果你像我们一样，你会发现通过示例和用例来理解像 Istio 提供的功能等高级概念更为有益。在这一部分，我们将详细解释许多自定义资源，并提供你可以在
    KinD 集群中部署的示例。
- en: Deploying your first application into the mesh
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将你的第一个应用程序部署到网格中
- en: Finally! We have Istio and the add-on components installed and we can move on
    to installing a real application in the Service mesh to verify everything is working.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最终！我们已经安装了 Istio 和附加组件，现在可以继续在服务网格中安装一个真实的应用程序，以验证一切是否正常工作。
- en: For this section, we will deploy an example application from Google called the
    Boutique app. In the next chapter, we will deploy a different application and
    explain all of the details and communication between the services, but the Boutique
    app is a great application to test out the mesh before we get into that level
    of information.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将部署一个来自 Google 的示例应用程序——Boutique 应用。在下一章，我们将部署另一个应用程序，并解释所有的细节和服务之间的通信，但在我们深入到那个层次的信息之前，Boutique
    应用是一个很好的测试网格的应用程序。
- en: 'In the `chaper16/example-app` directory, there is an installation script called
    `deploy-example.sh` that will deploy the application to the cluster. It will install
    the base application and the required Istio objects to make the application accessible
    to the outside world. The script execution is detailed below:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chaper16/example-app` 目录中，有一个名为 `deploy-example.sh` 的安装脚本，它将应用程序部署到集群中。该脚本会安装基础应用程序和所需的
    Istio 对象，以便将应用程序暴露给外部世界。脚本执行的详细信息如下：
- en: A new namespace named `demo` is created with a label containing `istio-injection=enabled`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个名为 `demo` 的新命名空间，并为其添加 `istio-injection=enabled` 标签。
- en: Using the `kubernetes-objects.yaml` manifest, the base application will be deployed.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubernetes-objects.yaml` 清单，将部署基础应用程序。
- en: The Istio objects will be created using templates to create the names in the
    `nip.io` domain for easy access to the application. The objects created in Istio
    include the `Gateway` and `VirtualService` objects.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio 对象将使用模板创建，以便在 `nip.io` 域中创建名称，从而方便访问应用程序。创建的 Istio 对象包括 `Gateway` 和 `VirtualService`
    对象。
- en: The created `nip.io` domain will be output to the screen. On our server, it
    was `kiali.10.3.1.248.nip.io`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建的 `nip.io` 域名将在屏幕上输出。在我们的服务器上，它是 `kiali.10.3.1.248.nip.io`。
- en: Once executed, you will have a working demo application in the `demo` namespace.
    We will use this application to demonstrate the observability features of Istio
    and Kiali.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您将在`demo`命名空间中拥有一个正在运行的示例应用程序。我们将使用这个应用程序来演示Istio和Kiali的可观察性功能。
- en: Quickly verify that the application and Istio objects have been deployed correctly
    by the script by using a browser to open the `nip.io` URL. You should see the
    Kiali home screen, which we will discuss in the next section.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用浏览器打开`nip.io` URL，快速验证应用程序和Istio对象是否已通过脚本正确部署。您应该能够看到Kiali首页，我们将在下一节中讨论它。
- en: Using Kiali to observe mesh workloads
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kiali观察网格工作负载
- en: Kiali provides observability in your Service mesh. It provides a number of advantages
    to you and your developers, including a visual map of the traffic flow between
    objects, verifying mTLS between the services, logs, and detailed metrics.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Kiali提供了服务网格中的可观察性。它为您和您的开发人员提供了许多优势，包括对象之间流量流动的可视化地图、验证服务之间的mTLS、日志和详细的度量数据。
- en: The Kiali overview screen
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kiali概览屏幕
- en: If you navigate to the homepage of Kiali, by using the URL provided when you
    executed the `create-ingress` script, this will open the Kiali overview page where
    you will see a list of namespaces in the cluster.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用执行`create-ingress`脚本时提供的URL导航到Kiali首页，这将打开Kiali概览页面，在这里您将看到集群中所有命名空间的列表。
- en: '![](img/B21165_16_03.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_03.png)'
- en: 'Figure 16.3: The Kiali homepage'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：Kiali主页
- en: Kiali will show all namespaces in the cluster, even if they do not have Istio
    enabled. In our current deployment, it will show all namespaces, regardless of
    any RBAC that has been implemented since it’s running without any authentication.
    As mentioned in the *Installing Kiali* section, we will secure Kiali with JWTs
    in the next chapter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Kiali会显示集群中的所有命名空间，即使它们没有启用Istio。在我们当前的部署中，它会显示所有命名空间，不受任何已实施的RBAC限制，因为它是在没有身份验证的情况下运行的。如*安装Kiali*章节中所述，我们将在下一章使用JWTs来保护Kiali。
- en: Using the Graph view
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图表视图
- en: The first part of the dashboard that we will visit is the **Graph** view, which
    provides a graphical view of our application. Initially, it may look like a simple
    static graphical representation of the objects that make up the workload, but
    this is simply the default view when you open the **Graph** view; it isn’t limited
    to a simple static view, as you will see in this section.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问的仪表板的第一部分是**图表**视图，它提供了应用程序的图形视图。最初，它看起来可能像是工作负载构成对象的一个简单静态图形表示，但这只是打开**图表**视图时的默认视图；它不仅限于一个简单的静态视图，正如您在本节中将看到的那样。
- en: 'Since we deployed the example application into the `demo` namespace, scroll
    down a bit and look for the block that contains the `demo` namespace, click the
    three dots on the tile, and then select **Graph**:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将示例应用程序部署到`demo`命名空间，稍微向下滚动并查找包含`demo`命名空间的块，点击瓷砖上的三个点，然后选择**图表**：
- en: '![](img/B21165_16_04.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_04.png)'
- en: 'Figure 16.4: Using Kiali to show a graph of a namespace'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：使用Kiali显示命名空间的图表
- en: 'This will take you to a new dashboard view that shows the demo application
    objects:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您到一个新的仪表板视图，显示示例应用程序对象：
- en: '![](img/B21165_16_05.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_05.png)'
- en: 'Figure 16.5: Kiali graph example'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：Kiali图表示例
- en: There are a lot of objects on the graph, and if you are new to Kiali, you may
    be wondering what each of the icons represents. Kiali provides a legend to help
    you identify what role each icon plays.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图表上有很多对象，如果您是Kiali新手，可能会想知道每个图标代表什么。Kiali提供了一个图例，帮助您识别每个图标的角色。
- en: 'If you click on the icon in the lower left-hand section of the **graph** pane,
    you will see the legend icon. Click it to see an explanation of each icon – an
    abbreviated legend list is shown below:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击**图表**面板左下角的图标，您将看到图例图标。点击它即可查看每个图标的解释——下面显示了一个简略的图例列表：
- en: '![](img/B21165_16_06.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_06.png)'
- en: 'Figure 16.6: Kiali graph legend example'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：Kiali图例示例
- en: By default, this view only shows the paths between the application objects in
    a static view. However, you are not limited only to the static view – this is
    where Kiali starts to shine. We can actually enable a live traffic view, enabling
    us to watch the traffic flow for all requests.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个视图只显示应用程序对象之间的静态路径视图。然而，您不仅限于静态视图——这正是Kiali的亮点所在。我们实际上可以启用实时流量视图，使我们能够观察所有请求的流量流动。
- en: To enable this option, click the **Display** option that is just above the Graph
    view, and in the list of options, enable traffic animation by checking the box,
    as shown in *Figure 16.7*.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此选项，点击图表视图上方的**显示**选项，在选项列表中勾选流量动画框，如*图 16.7*所示。
- en: '![](img/B21165_16_07.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_07.png)'
- en: 'Figure 16.7: Enabling traffic animation'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7：启用流量动画
- en: It’s difficult to display in a static image, but once you have enabled the **Traffic
    Animation** option, you will see the flow of all requests in real time.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这在静态图像中很难展示，但一旦启用了**流量动画**选项，你将实时看到所有请求的流量。
- en: You are not limited to only traffic flow animations; you can use the **Display**
    option to enable a number of other options in the **Graph** view, including items
    like response time, throughput, traffic rate, and security.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于流量动画；你可以使用**显示**选项在**图表**视图中启用许多其他选项，包括响应时间、吞吐量、流量速率和安全性等项目。
- en: 'In *Figure 16.8*, we have enabled throughput, traffic distribution, traffic
    rate, and security:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 16.8*中，我们启用了吞吐量、流量分布、流量速率和安全性：
- en: '![](img/B21165_16_08.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_08.png)'
- en: 'Figure 16.8: Kiali graph display options'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.8：Kiali 图表显示选项
- en: 'As you can see in the image, the lines between objects now include additional
    information, including:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，图像中对象之间的线条现在包含了额外的信息，包括：
- en: A lock, which confirms that the communication is encrypted via the sidecar and
    mTLS
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个锁，表示通信通过 sidecar 和 mTLS 加密
- en: RPS, which is the requests per second
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPS，即每秒请求数
- en: As you can see, the Kiali **Graph** view is a powerful tool for observing the
    end-to-end communication for your workload. This is just one of the additional
    benefits of using a Service mesh. The observability that a mesh provides is an
    incredibly valuable tool for finding issues that would have been very difficult
    to uncover in the past.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Kiali 的**图表**视图是一个强大的工具，可以观察工作负载的端到端通信。这只是使用服务网格的额外好处之一。服务网格提供的可观察性是一个极其宝贵的工具，用于发现过去很难揭示的问题。
- en: We are not limited to only the **Graph** view; we also have three additional
    views that offer additional insight into the application. On the left-hand side
    of the Kiali dashboard, you will see the other three views, **Applications**,
    **Workloads**, and **Services**. You will also notice that there is one other
    option, **Istio Config**, which allows you to view the objects in the namespace
    that control the Istio features for the namespace.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于**图表**视图；我们还有三个额外的视图，提供更多关于应用程序的见解。在 Kiali 仪表板的左侧，你会看到另外三个视图，**应用**、**工作负载**和**服务**。你还会注意到有一个其他选项，**Istio
    配置**，允许你查看控制命名空间中 Istio 功能的对象。
- en: Using the Applications view
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用应用视图
- en: The Applications view shows you the details for the workloads that have the
    same labeling, allowing you to break down the view into smaller sections.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 应用视图显示了具有相同标签的工作负载的详细信息，让你可以将视图细分为更小的部分。
- en: Using the Boutique Applications view that we have opened in Kiali, click on
    the **Applications** link in the left-hand options. This will take you to the
    overview page for the applications, broken down by labels.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在 Kiali 中打开的精品应用视图，点击左侧选项中的**应用**链接。这将带你进入按标签划分的应用概览页面。
- en: '![](img/B21165_16_09.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_09.png)'
- en: 'Figure 16.9: Kiali Applications view'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9：Kiali 应用视图
- en: Each of the applications can provide additional information by clicking the
    name of the service. If we were to click the **adservice** application, Kiali
    would open a page providing an overview of what the **adservice** application
    interacts with. For each application, you can also look at the overview, traffic,
    inbound and outbound metrics, and traces.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都可以通过点击服务名称提供更多信息。如果我们点击**adservice**应用程序，Kiali 将打开一个页面，提供有关**adservice**应用程序交互对象的概览。对于每个应用程序，你还可以查看概览、流量、进出流量指标和跟踪。
- en: The overview page presents you with a dedicated view of the objects that communicate
    with **adservice**. We saw a similar communications view in the **Graph** view,
    but we also saw every other object – including objects that have nothing to do
    with **adservice**.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 概览页面为你提供了一个专门展示与**adservice**通信的对象的视图。我们在**图表**视图中看到了类似的通信视图，但我们也看到了其他所有对象——包括与**adservice**无关的对象。
- en: The Applications view will streamline what we can see, making it easier to navigate
    the application.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 应用视图将简化我们所看到的内容，使我们能够更轻松地浏览应用程序。
- en: '![](img/B21165_16_10.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_10.png)'
- en: 'Figure 16.10: Simplified communication view using the Applications view'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：使用应用程序视图的简化通信视图
- en: As you can see, the Applications view contains the components from the Graph
    view. The communications path that involves **adservice** starts with the frontend
    pod, which targets the **adservice** service, which ultimately routes the traffic
    to the **adservice** pod.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，应用程序视图包含来自图形视图的组件。涉及**adservice**的通信路径从前端pod开始，目标是**adservice**服务，最终将流量路由到**adservice**
    pod。
- en: We can see additional details in the application by clicking on one of the tabs
    at the top of the **Applications** view. The first tab next to the overview is
    the **Traffic** tab, which provides you with a view of the traffic for the application.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击**应用程序**视图顶部的一个标签来查看应用程序的更多细节。概览旁边的第一个标签是**流量**标签，它为您提供应用程序的流量视图。
- en: '![](img/B21165_16_11.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_11.png)'
- en: 'Figure 16.11: Viewing application traffic'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：查看应用程序流量
- en: The **Traffic** tab will show inbound and outbound traffic to the application.
    In the **adservice** example from the Boutique store, we can see that **adservice**
    has received inbound requests from the frontend. Below the inbound traffic, we
    can see the outbound traffic and, in our example, Kiali is telling us that there
    is no outbound traffic. As we can see in the overview in *Figure 16.10*, the **adservice**
    pod does not have any object that it connects to; therefore, we would not have
    any traffic to view. To get additional details on the traffic, you can click on
    the **View Metrics** link under **Actions** – this action is the same as if you
    were to click the **Inbound Metrics** tab.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**流量**标签将显示应用程序的入站和出站流量。在精品店的**adservice**示例中，我们可以看到**adservice**接收到了来自前端的入站请求。在入站流量下方，我们可以看到出站流量，在我们的示例中，Kiali告诉我们没有出站流量。如在*图16.10*的概览中所示，**adservice**
    pod没有连接到任何对象，因此我们无法查看任何流量。要获取流量的更多细节，您可以点击**操作**下的**查看指标**链接——此操作与点击**入站指标**标签相同。'
- en: The **Inbound Metrics** tab will provide you with additional details about the
    incoming traffic. *Figure 16.12* shows an abbreviated example for the **adservice**
    traffic.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**入站指标**标签将为您提供有关传入流量的更多细节。*图16.12*显示了**adservice**流量的简化示例。'
- en: '![](img/B21165_16_12.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_12.png)'
- en: 'Figure 16.12: Viewing inbound metrics'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：查看入站指标
- en: The inbound metrics will display a number of different metrics, including request
    volume, request duration, request and response size, request and response throughput,
    gRPC received and sent, TCP opened and closed, and TCP received and sent. This
    page will update in real time, allowing you to view the metrics as they are captured.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 入站指标将显示许多不同的指标，包括请求量、请求持续时间、请求和响应大小、请求和响应吞吐量、gRPC接收和发送、TCP连接的打开和关闭、以及TCP的接收和发送。此页面将实时更新，使您能够查看实时捕获的指标。
- en: Finally, the last tab will allow you to look at the traces for the **adservice**
    application. This is why we deployed Jaeger in our cluster when we installed Istio.
    Tracing is a fairly complex topic and is outside the scope of this chapter. To
    learn more about tracing using Jaeger, head over to the Jaeger site at [https://www.jaegertracing.io/](https://www.jaegertracing.io/).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个标签将允许您查看**adservice**应用程序的追踪。这就是我们在安装Istio时在集群中部署Jaeger的原因。追踪是一个相对复杂的话题，超出了本章的范围。如需了解更多有关使用Jaeger进行追踪的信息，请访问Jaeger官网
    [https://www.jaegertracing.io/](https://www.jaegertracing.io/)。
- en: Using the Workloads view
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用工作负载视图
- en: The next view we will discuss is the **Workloads** view, which breaks down the
    views to the workload type, like deployments. If you click on the **Workloads**
    link in Kiali, you will be taken to a breakdown of the Boutique workloads.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论**工作负载**视图，该视图将展示按工作负载类型（如部署）分类的视图。如果您点击Kiali中的**工作负载**链接，您将进入精品店工作负载的详细信息。
- en: '![](img/B21165_16_13.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_13.png)'
- en: 'Figure 16.13: The Workloads view'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：工作负载视图
- en: You may notice that there is a warning under the **Details** column that tells
    us we are missing a version of the deployments. This is one of the features of
    this view. It will offer details like a workload not being assigned a version,
    which is not an issue for standard functionality in the mesh, but it will limit
    the use of certain features, like routing and some telemetry. It’s a best practice
    to always version your application, but for the example, Boutique from Google,
    they do not include a version in the deployments.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，在**Details**栏下有一个警告，告知我们缺少部署的版本。这是该视图的一个特点。它会提供诸如工作负载未分配版本的信息，这对网格中的标准功能没有影响，但会限制某些功能的使用，例如路由和一些遥测。最佳实践是始终为您的应用程序指定版本，但在本示例中，Google的Boutique应用程序没有在部署中包含版本。
- en: The **Workloads** view offers some of the same details as the **Applications**
    view, including traffic, inbound metrics, outbound metrics, and tracing – however,
    in addition to these details, we can now view the logs and details about Envoy.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**Workloads**视图提供了一些与**Applications**视图相同的详细信息，包括流量、入站指标、出站指标和追踪——然而，除了这些细节，我们现在还可以查看日志和关于Envoy的详细信息。'
- en: If you click on the **Logs** tab, you will see the logs for the **adservice**
    container.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击**Logs**标签，您将看到**adservice**容器的日志。
- en: '![](img/B21165_16_14.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_14.png)'
- en: 'Figure 16.14: Viewing the container logs'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：查看容器日志
- en: This is a real-time view of the logs that are being generated by the **adservice**
    container. In this view, you can create a filter to show or hide certain keywords,
    scroll back to previous events, change the default buffer size from 100 lines,
    copy the logs to your clipboard, or enter a fullscreen log view. Many users find
    this tab very useful since it doesn’t require them to use `kubectl` to look at
    the logs; they can simply open up Kiali in a browser and quickly view the logs
    in the GUI.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**adservice**容器生成的日志的实时视图。在此视图中，您可以创建一个过滤器来显示或隐藏特定的关键字，回滚到先前的事件，将默认缓冲区大小从100行更改，复制日志到剪贴板，或者进入全屏日志视图。许多用户发现这个标签非常有用，因为它不需要他们使用`kubectl`查看日志；他们只需在浏览器中打开Kiali，便可快速在GUI中查看日志。
- en: The last tab we will discuss is the **Envoy** tab, which provides additional
    details about the Envoy sidecar. The details in this tab are extensive – it contains
    all of the mesh objects that you have included in the namespace (recall that we
    created a sidecar object to limit the objects to only the namespace and the `istio-system`
    namespace), all of the listeners, routes, the bootstrap configuration, config,
    and metrics.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一个标签是**Envoy**标签，它提供有关Envoy sidecar的附加详细信息。此标签中的详细信息非常广泛——它包含了您在命名空间中包含的所有网格对象（请记住，我们创建了一个sidecar对象，将对象限制为仅命名空间和`istio-system`命名空间），所有监听器、路由、引导配置、配置和指标。
- en: By this point in the chapter, you can probably see how Istio would require its
    own book to cover all of the base components. All of the tabs in the **Envoy**
    tab provide a wealth of information, but it gets very detailed and we can’t fit
    them all in this chapter, so for the purposes of this chapter, we will only discuss
    the **Metrics** tab.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章这一部分，您大概可以看到，Istio确实需要一本独立的书来涵盖所有基本组件。**Envoy**标签中的所有标签都提供了丰富的信息，但非常详细，我们无法在本章中涵盖所有内容，因此在本章中，我们将只讨论**Metrics**标签。
- en: Clicking on the **Metrics** tab, you will see metrics pertaining to the uptime
    of Envoy, the allocated memory, heap size, active upstream connections, upstream
    total requests, downstream active connections, and downstream HTTP requests.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Metrics**标签，您将看到与Envoy的正常运行时间、分配的内存、堆大小、活动的上游连接、上游总请求、下游活动连接和下游HTTP请求相关的指标。
- en: '![](img/B21165_16_15.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_15.png)'
- en: 'Figure 16.15: Envoy metrics'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：Envoy指标
- en: Like most metrics, these will be beneficial if you experience issues with the
    Envoy proxy container. The uptime will let you know how long the pod has been
    running, the allocated memory tells you how much memory has been allocated to
    the pod, which may help to identify why an OOM condition occurred, and active
    connections will identify if the service has issues if the connection count is
    lower than expected, or at zero.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数指标一样，如果您遇到Envoy代理容器的问题，这些指标将非常有帮助。正常运行时间将告诉您Pod已经运行了多长时间，分配的内存告诉您分配给Pod的内存量，这可能有助于确定为什么发生OOM情况，而活动连接则会告知如果连接数低于预期或为零时，服务是否存在问题。
- en: Using the Services view
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用服务视图
- en: Finally, we will discuss the last view for the application, the Services view.
    Just as the name implies, this will provide a view of the services that are part
    of the workload. You can open the Services view by clicking on the **Services**
    option in Kiali.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论应用程序的最后一个视图——服务视图。顾名思义，这将提供工作负载中包含的服务视图。你可以通过点击Kiali中的**Services**选项来打开服务视图。
- en: '![](img/B21165_16_16.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_16.png)'
- en: 'Figure 16.16: The Services view'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：服务视图
- en: Similar to the other views, this will provide the names of the services and
    the health of each of the services. If you click on any individual service, you
    will be taken to the details of the service. If you were to click **adservice**,
    you would be taken to the overview for the service.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他视图类似，这将提供服务的名称和每个服务的健康状况。如果你点击任何单个服务，你将进入该服务的详细信息。如果你点击**adservice**，你将进入该服务的概览页面。
- en: '![](img/B21165_16_17.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_17.png)'
- en: 'Figure 16.17: The services overview'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：服务概览
- en: The **Overview** page should have some objects familiar to you. Just like the
    other views, it provides a view of just the objects that communicate with **adservice**,
    and it has tabs for traffic, inbound metrics, and traces – however, in addition
    to these, it also shows the network information for the service. In our example,
    the service has been configured to use a `ClusterIP` type, the service IP assigned
    is `10.110.47.79`, it has an endpoint of `10.240.189.149`, and it has the gRPC
    TCP port exposed on port `9555`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**Overview**页面应该包含一些你熟悉的对象。与其他视图一样，它仅显示与**adservice**通信的对象，并且有流量、入站指标和跟踪的标签页——然而，除了这些，它还显示了服务的网络信息。在我们的示例中，服务已配置为使用`ClusterIP`类型，分配的服务IP是`10.110.47.79`，它有一个端点`10.240.189.149`，并且在端口`9555`上暴露了gRPC
    TCP端口。'
- en: This is information you could retrieve using `kubectl`, but for many people,
    it’s quicker to grab the details from the Kiali dashboard.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息你可以通过`kubectl`获取，但对于很多人来说，从Kiali仪表盘获取这些细节更为快捷。
- en: The Istio Config view
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio配置视图
- en: The last view we have is not related to the workload in particular. Instead,
    it’s a view for the Istio config for the namespace. This view will contain the
    Istio objects you have created. In our example, we have two objects, the gateway
    and the virtual service.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的最后一个视图与工作负载并没有直接关系。相反，它是一个用于命名空间的Istio配置视图。这个视图将包含你所创建的Istio对象。在我们的示例中，我们有两个对象：网关和虚拟服务。
- en: '![](img/B21165_16_18.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_18.png)'
- en: 'Figure 16.18: The Istio Config view'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18：Istio配置视图
- en: You can view the YAML for each object by clicking the name. This allows you
    to directly edit the object in the Kiali dashboard. Any changes that are saved
    will edit the object in the cluster, so be careful if you are using this method
    to modify the object.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击每个对象的名称来查看该对象的YAML。这允许你直接在Kiali仪表盘中编辑对象。任何保存的更改将会编辑集群中的对象，因此如果你使用这种方法修改对象时，请小心。
- en: This view offers one addition that the other views do not – the ability to create
    a new Istio object using a wizard. To create a new object, click the **Actions**
    dropdown in the upper right-hand corner of the Istio config view. This will bring
    up a list of objects that you can create, as shown in *Figure 16.19*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图提供了其他视图没有的一个附加功能——使用向导创建新的Istio对象。要创建新对象，点击Istio配置视图右上角的**Actions**下拉菜单。这样会弹出一个你可以创建的对象列表，如*图16.19*所示。
- en: '![](img/B21165_16_19.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_19.png)'
- en: 'Figure 16.19: Istio object creation wizard'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19：Istio对象创建向导
- en: As you can see in the figure, Kiali provides a wizard to create 6 Istio objects
    including **AuthorizationPolicies**, **Gateways**, **PeerAuthentication**, **RequestAuthentication**,
    **ServiceEntries**, and **Sidecars**.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Kiali提供了一个向导，用于创建6个Istio对象，包括**AuthorizationPolicies**、**Gateways**、**PeerAuthentication**、**RequestAuthentication**、**ServiceEntries**和**Sidecars**。
- en: Each option has a wizard to guide you through the specific requirements for
    that object. For example, we could create a sidecar using the wizard, as shown
    in *Figure 16.20*.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都有一个向导，引导你完成该对象的具体要求。例如，我们可以使用向导创建一个sidecar，如*图16.20*所示。
- en: '![](img/B21165_16_20.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_20.png)'
- en: 'Figure 16.20: Using the Istio object wizard'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20：使用Istio对象向导
- en: Once all fields have been entered correctly, you can click **Preview**, which
    will take you to the next screen, where you will see the object YAML source, as
    shown in *Figure 16.21*.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有字段都正确输入，你可以点击**Preview**，这将带你到下一个屏幕，你将在那里看到对象的YAML源代码，如*图16.21*所示。
- en: '![](img/B21165_16_21.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21165_16_21.png)'
- en: 'Figure 16.21: Wizard source YAML'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21：向导源YAML
- en: If it looks good, click **Create** to create the new object.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看起来不错，点击**创建**来创建新对象。
- en: The wizards are a good tool for people who are new to Istio, but be careful
    not to rely on them too much. You should always understand how to create a manifest
    for all of your objects. Creating objects using wizards like these can lead to
    problems down the road without the knowledge of how the object works or is created.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 向导是新接触Istio的用户一个很好的工具，但要小心不要过度依赖它们。你应该始终理解如何为你的所有对象创建清单。像这样的向导创建对象可能会导致问题，因为你不懂对象是如何工作的或如何创建的。
- en: In the next section, we will introduce where Istio is heading in the future.
    As powerful as the sidecar is, it has its limitations, and it requires additional
    resources for each pod in the mesh. In 2023, Istio introduced a new concept called
    ambient mesh as an early access feature, which removed the requirement for the
    Istio sidecar.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将介绍Istio未来的发展方向。尽管sidecar非常强大，但它也有其局限性，并且每个网格中的pod都需要额外的资源。在2023年，Istio推出了一个名为环境网格（ambient
    mesh）的新概念，作为一个早期访问功能，移除了对Istio sidecar的需求。
- en: 'The future: Ambient mesh'
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来：环境网格
- en: Today, Service meshes, such as Istio, depend on sidecar proxies connected to
    every service instance to handle traffic, security measures, and metric collection.
    Although this approach works well, it leads to extra resource usage and complexity,
    particularly in deployments in larger clusters.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，像Istio这样的服务网格依赖于连接到每个服务实例的sidecar代理来处理流量、安全措施和度量数据收集。虽然这种方法效果良好，但它会导致额外的资源使用和复杂性，特别是在较大集群中的部署。
- en: In this chapter, we mentioned sidecars a lot – they’re the heart of the mesh,
    providing the layer that removes all of the complexities of using mesh features
    without requiring code changes to our applications.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提到过很多次sidecar——它们是网格的核心，提供了一个层次，去除了使用网格功能的所有复杂性，而不需要对我们的应用程序进行代码更改。
- en: Ambient mesh marks a significant change in the Service mesh design, attempting
    to make it easier to add Service mesh features to an already complicated system
    without the need for sidecar proxies for every service. Its goal is to cut down
    on the extra work and complexity while keeping the main advantages of a Service
    mesh, including monitoring, security, and traffic management.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 环境网格标志着服务网格设计的一个重要变化，试图在不需要每个服务都附带sidecar代理的情况下，使将服务网格功能添加到已有复杂系统中变得更加容易。其目标是减少额外的工作和复杂性，同时保持服务网格的主要优势，包括监控、安全性和流量管理。
- en: 'As of Istio 1.20, the ambient mesh has the **Alpha** status. The main reason
    that we haven’t added a chapter on using an ambient mesh is due to potential changes
    that will likely occur between the current alpha stage and when it goes to **general
    availability** (**GA**). However, since it is a giant leap forward and a major
    change in design, we wanted to bring it to your attention. You can read more about
    getting started with ambient mesh on Istio’s site here: [https://istio.io/latest/docs/ops/ambient/getting-started/](https://istio.io/latest/docs/ops/ambient/getting-started/).'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 从Istio 1.20开始，环境网格处于**Alpha**阶段。我们尚未为环境网格单独添加章节的主要原因是因为从当前的Alpha阶段到它正式进入**正式发布**（**GA**）阶段期间，可能会发生一些变化。然而，由于它是一次巨大的飞跃和设计上的重大改变，我们希望引起你的注意。你可以在Istio官网上阅读更多关于如何开始使用环境网格的内容：[https://istio.io/latest/docs/ops/ambient/getting-started/](https://istio.io/latest/docs/ops/ambient/getting-started/)。
- en: Reading the docs on Istio’s site will provide some great examples of how the
    ambient mesh deploys and works. Since many readers will be new to Istio, jumping
    into the docs for an overview may be a little much, so we wanted to provide our
    view on the key points of what the ambient mesh means to us.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读Istio官网的文档将提供一些很好的示例，展示环境网格是如何部署和工作的。由于许多读者对Istio是新手，因此直接跳入文档进行概览可能会有些困难，所以我们想要提供我们对环境网格对我们意义的关键点的看法。
- en: 'As we mentioned, ambient mesh addresses a number of issues by removing the
    tasks that are usually managed by sidecar proxies. Rather than attaching a proxy
    to each service instance, the ambient mesh will integrate these functions directly
    into the network or in a common proxy layer. This design seeks to simplify processes
    and lessen the resources needed compared to the traditional sidecar method. This
    provides a number of advantages, including:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，环境网格通过去除通常由sidecar代理管理的任务，解决了许多问题。与将代理附加到每个服务实例不同，环境网格会将这些功能直接集成到网络中，或者集成到一个公共的代理层中。这一设计旨在简化流程，并减少与传统sidecar方法相比所需的资源。这带来了许多优势，包括：
- en: '**Preservation of Essential Features**: Despite its unique architecture, the
    ambient mesh will continue to deliver the base capabilities found in current Service
    meshes, including secure communications between services, traffic control, and
    the ability to monitor components.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保留基本特性**：尽管其架构独特，环境网格仍将继续提供当前服务网格中所包含的基本功能，包括服务之间的安全通信、流量控制和监控组件的能力。'
- en: '**Streamlined, Efficient Deployments**: The ambient mesh eliminates the necessity
    for individual sidecar proxies, streamlining the setup and management of Service
    meshes. This will facilitate easier adoption and maintenance, especially for organizations
    with complex microservices structures.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化、高效的部署**：环境网格消除了对单独 sidecar 代理的需求，从而简化了服务网格的设置和管理。这将促进更易于采纳和维护，特别是对于具有复杂微服务结构的组织。'
- en: '**Improved Resource** **Utilization**: By minimizing the CPU and memory demands
    for service-to-service interactions, the ambient mesh allows the efficient use
    of resources.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的资源利用率**：通过减少服务间交互对 CPU 和内存的需求，环境网格能够高效地利用资源。'
- en: '**Performance Enhancement**: The ambient mesh enhances system performance by
    optimizing the routes used for service communication, reducing delays and boosting
    efficiency.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能增强**：环境网格通过优化服务通信所用的路由，减少延迟并提高效率，从而提升系统性能。'
- en: Imagine the resource and complexity savings in a large cluster where you may
    have thousands, or tens of thousands, of services running. Currently, that would
    require as many proxy instances running, each adding an extra layer in the communication
    and using its own resources – using extra CPU and RAM that are not actually “required”
    for the base applications. The ambient mesh will save you money by reducing the
    required resources, and by simplifying the architecture, it should be easier to
    find issues when an application is not behaving as expected.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在一个大型集群中，可能有成千上万，甚至几十万个服务正在运行时，资源和复杂性的节省。目前，这将需要相应数量的代理实例来运行，每个代理都增加了通信中的额外层，并使用自己的资源——使用额外的
    CPU 和 RAM，这些资源对于基础应用程序来说并非“必需”。环境网格将通过减少所需资源来为您节省成本，并通过简化架构，当应用程序行为异常时，问题的排查将变得更加容易。
- en: We hope that this chapter has provided a useful introduction to Istio and what’s
    in store for Istio’s future. In the next chapter, we will dive deeper into running
    applications in an enterprise using Istio.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望本章提供了关于 Istio 以及 Istio 未来发展方向的有用介绍。在下一章中，我们将深入探讨如何在企业环境中使用 Istio 运行应用程序。
- en: Summary
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to the Service mesh world, using the popular
    open-source project Istio. In the first section of the chapter, we explained some
    of the advantages of using a Service mesh, which included security and observability
    for mesh services.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用流行的开源项目 Istio 进入服务网格的世界。在本章的第一部分，我们解释了使用服务网格的一些优势，其中包括为网格服务提供的安全性和可观测性。
- en: The second section of the chapter detailed the installation of Istio and the
    different installation profiles that are available. We deployed Istio into our
    KinD clusters and we also removed NGNIX to free up ports `80` and `443` to be
    used by Istio’s ingress gateway. This section also included the objects that are
    added to a cluster once you deploy Istio. We covered the most common objects using
    example manifests that reinforce how to use each object in your own deployments.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分详细介绍了 Istio 的安装以及可用的不同安装配置文件。我们将 Istio 部署到 KinD 集群中，并移除了 NGNIX，以腾出端口`80`和`443`，供
    Istio 的入口网关使用。本节还介绍了部署 Istio 后，集群中添加的对象。我们通过使用示例清单，覆盖了最常见的对象，帮助加深理解如何在自己的部署中使用每个对象。
- en: To close out the chapter, we detailed how to install Kiali, Prometheus, and
    Jaeger to provide powerful observability in our Service mesh. We also explained
    how to use Kiali to look into an application in the mesh to view the application
    metrics and logs.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们详细介绍了如何安装 Kiali、Prometheus 和 Jaeger，以便在我们的服务网格中提供强大的可观测性。我们还解释了如何使用
    Kiali 查看网格中应用程序的度量和日志。
- en: In the next chapter, we will deploy a new application and bind it to the Service
    mesh, building on many of the concepts that were presented in this chapter.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将部署一个新应用，并将其绑定到服务网格，基于本章介绍的许多概念进行构建。
- en: Questions
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What Istio object(s) is used to route traffic between multiple versions of an
    application?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 Istio 对象用于在多个版本的应用程序之间路由流量？
- en: Ingress rule
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ingress 规则
- en: VirtualService
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: VirtualService
- en: DestinationRule
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: DestinationRule
- en: You can’t route traffic between multiple versions, only a single instance
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能在多个版本之间路由流量，只能在单个实例之间路由。
- en: What tool(s) are required to provide observability in the Service mesh?
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供服务网格可观察性需要哪些工具？
- en: Prometheus
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus
- en: Jaeger
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jaeger
- en: Kiali
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kiali
- en: Kubernetes Dashboard
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes Dashboard
- en: 'True or false: Istio features require developers to change their code to leverage
    features like mutual TLS and authorization.'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对错：Istio 的特性要求开发人员修改代码以利用诸如互相 TLS 和授权等功能。
- en: 'True'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对
- en: 'False'
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错
- en: 'Istio made the control plane easier to deploy and configure by merging multiple
    components into a single executable called:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio 通过将多个组件合并成一个可执行文件，简化了控制平面的部署和配置，称为：
- en: Istio
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio
- en: IstioC
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: IstioC
- en: istiod
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: istiod
- en: Pilot
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pilot
- en: Answers
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b - VirtualService and c - DestinationRule
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b - VirtualService 和 c - DestinationRule
- en: a Prometheus and c - Kiali
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a Prometheus 和 c - Kiali
- en: b - False
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b - 错
- en: c - Pilot
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c - Pilot
