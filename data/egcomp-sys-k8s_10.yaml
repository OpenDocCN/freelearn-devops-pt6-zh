- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: SQL and NoSQL Databases at the Edge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘系统中的 SQL 和 NoSQL 数据库
- en: 'When you have to create an edge system, a critical task is storing your data.
    For this, you have to take into consideration the resources that you have, the
    processor that your devices are using, and the type of data that you want to store.
    CAP theorem states that distributed data stores only provide two of the following
    guarantees: consistency, availability, and partition tolerance. So, this theorem
    can help you to decide which type of database is best according to your system
    needs. In this chapter, we are going to learn how to deploy different database
    types to run on edge systems using K3s and ARM devices. These examples include
    different techniques such as using ConfigMaps and Secrets to deploy your databases.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建边缘系统时，一个关键任务是存储数据。为此，您需要考虑您拥有的资源、设备使用的处理器以及您要存储的数据类型。CAP 定理指出，分布式数据存储只能提供以下三项保证中的两项：一致性、可用性和分区容错性。因此，这个定理可以帮助您根据系统需求决定哪种类型的数据库最为合适。在本章中，我们将学习如何使用
    K3s 和 ARM 设备部署不同类型的数据库，以便在边缘系统上运行。这些示例包括使用 ConfigMaps 和 Secrets 部署数据库等不同技术。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: CAP theorem for SQL and NoSQL databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 和 NoSQL 数据库的 CAP 定理
- en: Creating a volume to persist your data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个卷以持久化您的数据
- en: Using MySQL and MariaDB SQL databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MySQL 和 MariaDB SQL 数据库
- en: Using a Redis key-value NoSQL database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 键值对 NoSQL 数据库
- en: Using a MongoDB document-oriented NoSQL database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoDB 文档导向的 NoSQL 数据库
- en: Using a PostgreSQL object-relational SQL database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL 对象关系型 SQL 数据库
- en: Using a Neo4j graph NoSQL database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Neo4j 图形 NoSQL 数据库
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To deploy the databases in this chapter, you need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中部署数据库，您需要以下内容：
- en: A single- or multi-node K3s cluster using ARM devices with MetalLB, and Longhorn
    storage installed. If you are using Raspberry Pi devices, you will need at least
    4 GB of RAM and at least the 4B model. Each node must have the Ubuntu ARM64 operating
    system in order to support the ARMv8 architecture, necessary for some deployments
    in this chapter.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单节点或多节点的 K3s 集群，使用 ARM 设备并安装了 MetalLB 和 Longhorn 存储。如果您使用的是 Raspberry Pi 设备，至少需要
    4 GB 的 RAM 和 4B 型号。每个节点必须安装 Ubuntu ARM64 操作系统，以支持 ARMv8 架构，这对于本章中的某些部署是必要的。
- en: '`kubectl` configured to be used on your local machine, to avoid using the `--kubeconfig`
    parameter.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` 已配置为在本地机器上使用，以避免使用 `--kubeconfig` 参数。'
- en: Clone the repository at [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10)
    if you want to run the YAML configuration by using `kubectl apply` instead of
    copying the code from the book. Take a look at the directory `yaml` for the YAML
    examples inside the `ch10` directory.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望使用 `kubectl apply` 运行 YAML 配置，而不是从书中复制代码，可以克隆 [https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10](https://github.com/PacktPublishing/Edge-Computing-Systems-with-Kubernetes/tree/main/ch10)
    仓库。查看 `ch10` 目录中的 `yaml` 目录，了解其中的 YAML 示例。
- en: With this, you can deploy the databases explained in this chapter. So, let’s
    get started learning about CAP theorem first, to choose the right database for
    your specific use case.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，您可以部署本章中解释的数据库。因此，让我们首先学习 CAP 定理，以选择适合您特定用例的正确数据库。
- en: CAP theorem for SQL and NoSQL databases
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 和 NoSQL 数据库的 CAP 定理
- en: 'CAP theorem was defined by Eric Brewer in 1999 and presented at the 19th Annual
    ACM Symposium on **Principles of Distributed Computing** (**PODC**) in 2000\.
    This theorem states that a distributed data store can only provide two of the
    following guarantees:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CAP 定理由 Eric Brewer 于 1999 年定义，并于 2000 年在第十九届 ACM 分布式计算原理年会（**PODC**）上提出。该定理指出，分布式数据存储只能提供以下两项保证：
- en: '**Consistency**: This means when reading information, the data store returns
    the most recent written data or returns an error if it fails. This refers to regular
    SQL databases that use atomic operations to guarantee that data is written. If
    not, the system automatically rolls back to a previous data state.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这意味着在读取信息时，数据存储返回的是最新写入的数据，或者在失败时返回错误。这指的是常规的 SQL 数据库，它们使用原子操作来保证数据的写入。如果没有，系统会自动回滚到先前的数据状态。'
- en: '**Availability**: This means that all reads contain data, but it might not
    be the most recent.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这意味着所有的读取操作都包含数据，但可能不是最新的数据。'
- en: '**Partition tolerance**: This is the most desired feature in a distributed
    system. It means that data is distributed in several nodes, helping to reduce
    downtime for the database. This means that if a node is down, just a small portion
    of data will be inaccessible:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容错性**：这是分布式系统中最理想的特性。它意味着数据被分布在多个节点中，有助于减少数据库的停机时间。这意味着，如果一个节点宕机，只有一小部分数据会无法访问：'
- en: '![Figure 10.1 – CAP theorem diagram'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – CAP 定理图示'
- en: '](img/B16945_10_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_10_01.jpg)'
- en: Figure 10.1 – CAP theorem diagram
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – CAP 定理图示
- en: 'This theorem is commonly used as a point of reference to design strong distributed
    systems in the context of data. Now, in the CAP theorem diagram (*Figure 10.1*),
    represented as a triangle, you can see the different sides, and how each side
    has a relationship with the other sides. Let’s explore these sides and give examples
    of databases:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该定理通常作为设计强大的分布式系统时的数据参考点。在 CAP 定理图示（*图 10.1*）中，以三角形形式展示，你可以看到不同的侧面，以及每个侧面如何与其他侧面相互关联。让我们探索这些侧面并举例说明数据库：
- en: '**CA**: On this side, we can classify databases that have consistency and availability.
    Here, we can find SQLite, which is a very simple database. MySQL and PostgreSQL
    are very popular open source databases. SQL Server is a proprietary database from
    Microsoft and Neo4j is a graph database. Each of these databases tries to guarantee
    consistency and availability. These guarantees can be found on **relational database
    management system** (**RDBMS**)-based databases. But as we have mentioned, Neo4j
    is classified on this side of the triangle. Something important on this side is
    that the database will fail if the network is down.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CA**：在这一侧，我们可以分类具有一致性和可用性的数据库。这里，我们可以找到 SQLite，它是一个非常简单的数据库。MySQL 和 PostgreSQL
    是非常流行的开源数据库。SQL Server 是微软的专有数据库，Neo4j 是一个图数据库。每一个这些数据库都试图保证一致性和可用性。这些保证可以在**关系数据库管理系统**（**RDBMS**）为基础的数据库中找到。但正如我们所提到的，Neo4j
    被归类在三角形的这一侧。这个侧面的一个重要特性是，如果网络宕机，数据库将会失败。'
- en: '**CP**: On this side, you can find databases that provide consistency and partition
    tolerance. This means that databases such as Mongo and Redis use algorithms to
    write information that guarantee the consistency of data. For example, MongoDB
    uses the reader-writer algorithm to write in the database. Redis uses a similar
    algorithm to write data. Talking about partition tolerance, MongoDB can distribute
    information across nodes. This gives MongoDB the ability to partition the data.
    This is sharding, which provides the partition tolerance feature to MongoDB. Other
    databases based on Bigtable work similarly. Those Bigtable-based databases usually
    read data from distributed buckets of information across the cloud. The problem
    in CP is the risk that some data will become unavailable when a node or source
    of data is down.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CP**：在这一侧，你可以找到提供一致性和分区容错性的数据库。这意味着像 Mongo 和 Redis 这样的数据库使用算法来写入数据，以保证数据的一致性。例如，MongoDB
    使用读写算法来写入数据库。Redis 使用类似的算法来写入数据。说到分区容错性，MongoDB 可以将信息分布到多个节点，这赋予了 MongoDB 分区数据的能力。这就是分片，提供了分区容错性特性给
    MongoDB。其他基于 Bigtable 的数据库工作原理类似。这些基于 Bigtable 的数据库通常从云端的分布式信息桶中读取数据。CP 中的问题是，当一个节点或数据源宕机时，一些数据可能会变得不可用。'
- en: '**AP**: On this side, databases look for availability and partition tolerance.
    Here, we can find databases such as Cassandra, CouchDB, Riak, DynamoDB, and databases
    based on Cassandra. For example, Cassandra has high availability, using its masterless
    technique to scale servers, but it doesn’t guarantee the consistency of data.
    That’s a common issue in some NoSQL databases.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AP**：在这一侧，数据库寻求可用性和分区容错性。这里，我们可以找到像 Cassandra、CouchDB、Riak、DynamoDB 和基于 Cassandra
    的数据库。例如，Cassandra 具有高可用性，使用无主技术来扩展服务器，但它不保证数据的一致性。这是一些 NoSQL 数据库常见的问题。'
- en: Before deciding which database is right for you, let’s explore what a relational
    and no-relational database is. A **relational database** is a database where the
    data is structured. This means that data is organized in tables, rows, and columns.
    These tables have relationships and dependencies. These databases use **Structured
    Query Language** (**SQL**) to manage the information. Relational databases are
    also called **SQL databases**. They also use ACID operations. This stands for
    atomicity, consistency, isolation, and durability; these properties in data guarantee
    data integrity when errors and failures happen. Some examples are MySQL, PostgreSQL,
    and SQL Server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定哪个数据库适合你之前，让我们先了解一下什么是关系型数据库和非关系型数据库。**关系型数据库**是结构化数据的数据库。这意味着数据被组织成表格、行和列。这些表格之间有关系和依赖。关系型数据库使用**结构化查询语言**（**SQL**）来管理信息。关系型数据库也叫做**SQL
    数据库**，它们还使用 ACID 操作。ACID 代表原子性、一致性、隔离性和持久性；这些数据特性保证了在错误和故障发生时数据的完整性。一些示例包括 MySQL、PostgreSQL
    和 SQL Server。
- en: 'A **non-relational database** is not structured. It doesn’t use a table, row,
    and column data schema. Instead, it uses a storage model optimized for specific
    requirements of the type of data being stored. Some of these types of data could
    be JSON documents, key values, and so on. These databases are also called **NoSQL
    databases**. These databases don’t use ACID operations. They look for availability
    and partition tolerance for data. Some examples are MongoDB, Redis, Neo4j, and
    Cassandra. When choosing the right database, you can evaluate some of these questions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**非关系型数据库**是没有结构化的。它不使用表格、行和列的数据模式，而是使用针对存储数据类型特定需求优化的存储模型。这些数据类型可能是 JSON 文档、键值对等。这些数据库也被称为**NoSQL
    数据库**。这些数据库不使用 ACID 操作，它们更关注数据的可用性和分区容忍性。一些示例包括 MongoDB、Redis、Neo4j 和 Cassandra。在选择合适的数据库时，你可以考虑以下几个问题：'
- en: Which of the guarantees of consistency, partition tolerance, and availability
    does my system need? According to this, which database fits my system needs best?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的系统需要哪种一致性、分区容忍性和可用性的保障？根据这些，哪种数据库最适合我的系统需求？
- en: Does my database need to support the SQL language to query information?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据库是否需要支持 SQL 语言来查询信息？
- en: Do I need a database that supports the SQL language?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要一个支持 SQL 语言的数据库吗？
- en: Is my data not structured as JSON documents or do I need something structured
    as tables?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据是没有结构的 JSON 文档，还是需要一些像表格那样结构化的数据？
- en: What type of data am I storing? Do I need a SQL or NoSQL database?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我存储的数据类型是什么？我需要 SQL 数据库还是 NoSQL 数据库？
- en: Do I need consistency, availability, or partition tolerance? Which of these
    components is important for my system?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要一致性、可用性还是分区容忍性？这些组件中，哪一个对我的系统最重要？
- en: How many resources is my database going to use? How many simultaneous connections
    is my system expected to handle?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据库将使用多少资源？我的系统预期能够处理多少个并发连接？
- en: Do I need to replicate information, implement rate limits, or have any other
    specific features in my database?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要复制信息、实现速率限制或在数据库中实现其他特定功能？
- en: How fast is my database at writing and reading data?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据库在写入和读取数据时速度有多快？
- en: How can I do replication or scaling on my database?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何在数据库上进行复制或扩展？
- en: These and other questions could be important when choosing the right database.
    So, this chapter focuses on giving you a quick start when choosing the right database,
    using CAP theorem and some examples of how to deploy some SQL and NoSQL databases
    mentioned in the CAP theorem description. These SQL and NoSQL databases will be
    deployed at the edge in a K3s cluster using containers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些和其他问题在选择合适的数据库时可能非常重要。因此，本章将重点介绍如何通过 CAP 定理快速入门，并给出一些如何部署 SQL 和 NoSQL 数据库的示例，这些数据库在
    CAP 定理的描述中有所提及。这些 SQL 和 NoSQL 数据库将使用容器在 K3s 集群的边缘进行部署。
- en: Important Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can find in the *Further reading* section some links to learn more about
    SQL and NoSQL databases, the official web links for the databases explained in
    this chapter, and complementary links to evaluate which database is best for your
    use case. A complementary theorem that you can use is the PACELC theorem. This
    looks for the trade-offs between latency and consistency when data is replicated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在*进一步阅读*部分，你可以找到一些链接，了解更多关于 SQL 和 NoSQL 数据库的内容、章中提到的数据库的官方网页链接以及评估哪个数据库最适合你的用例的补充链接。你可以使用的一个补充定理是
    PACELC 定理，它关注的是在数据复制时，延迟和一致性之间的权衡。
- en: Now let’s move on to create a volume to persist your data before performing
    the deployment of your selected database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在部署你选择的数据库之前，让我们继续创建一个持久化数据的存储卷。
- en: Creating a volume to persist your data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个持久化数据的存储卷
- en: 'Before we start deploying our databases, let’s create a volume to store data
    first. For this, we have two options. One is to use a directory inside the server.
    This means that in order to not lose data, your Pods have to be provisioned in
    the same node as where your volume was created the first time. If you don’t want
    to depend on which node your pods are running, you have to choose a second option,
    which is to use a storage driver. If that’s your case, we are going to use Longhorn
    as our storage driver option. Now, let’s create our storage first, using a local
    directory. For this, follow the next steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始部署数据库之前，让我们先创建一个存储数据的卷。为此，我们有两个选择。一个是使用服务器内部的目录。这意味着为了避免数据丢失，Pods 必须部署在与卷第一次创建的节点相同的节点上。如果你不想依赖
    Pods 所运行的节点，可以选择第二个选项，即使用存储驱动程序。如果你选择这个方案，我们将使用 Longhorn 作为存储驱动。现在，让我们先使用本地目录创建存储。为此，请按照以下步骤操作：
- en: 'Create a `/mnt/data` directory in the node to store data:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点上创建 `/mnt/data` 目录以存储数据：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a **PersistentVolumeClaim** using 5 GB of storage:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用 5 GB 存储空间的 **PersistentVolumeClaim**：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to use Longhorn as your storage, follow the next steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Longhorn 作为存储，请按照以下步骤进行操作：
- en: 'Create a PersistentVolumeClaim with 5 GB of storage, this time, using Longhorn:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Longhorn 创建一个 5 GB 存储空间的 PersistentVolumeClaim：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a critical step to persist and avoid losing your data. In the next sections,
    we are going to start deploying our databases, starting with basic configuration
    and adding more complex configurations such as using **ConfigMaps** and **Secrets**
    to perform more production-ready deployments. But first, let’s start with MySQL
    and MariaDB, very popular databases used across the internet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键步骤，用于持久化数据并避免数据丢失。在接下来的章节中，我们将开始部署我们的数据库，首先是基本配置，然后加入更复杂的配置，例如使用 **ConfigMaps**
    和 **Secrets** 来进行更接近生产环境的部署。但首先，让我们从 MySQL 和 MariaDB 开始，它们是互联网上非常流行的数据库。
- en: Using MySQL and MariaDB SQL databases
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MySQL 和 MariaDB SQL 数据库
- en: 'MySQL is a relational database that uses the SQL language to read and write
    information. It’s one of the most used databases on the internet. MariaDB is a
    fork of MySQL and the version used in this example is fully compatible with MySQL.
    It’s a very fast SQL database and it’s simple to use. After this brief introduction
    to MySQL, let’s get started deploying this database by following the next steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个关系型数据库，使用 SQL 语言读取和写入信息。它是互联网上最常用的数据库之一。MariaDB 是 MySQL 的一个分支，本示例中使用的版本与
    MySQL 完全兼容。它是一个非常快速的 SQL 数据库，且易于使用。在简要介绍了 MySQL 后，让我们按照以下步骤开始部署该数据库：
- en: 'Create the MySQL deployment creating a PersistentVolumeClaim called `db-pv-claim`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 MySQL 部署时，创建一个名为 `db-pv-claim` 的 PersistentVolumeClaim：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Instead of using MySQL, you can use MariaDB, which is fully compatible with
    MySQL version 5.6\. To do this, change the `mysql:8.0.28-oracle` image to `arm64v8/mariadb:latest`
    and the `MYSQL_ROOT_PASSWORD` variable to `MARIADB_ROOT_PASSWORD`. You can also
    check for other image versions in [https://hub.docker.com](https://hub.docker.com)
    for MySQL and MariaDB images. For this deployment, the password is `password`.
    The images used for the deployment are both designed to run on ARM devices. In
    the case of MySQL reinstallation using local storage, you have to delete the content
    inside the `/mnt/data` directory using the `rm -R /mnt/data` command to avoid
    errors.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用 MySQL，你可以选择使用 MariaDB，它与 MySQL 5.6 版本完全兼容。为此，将 `mysql:8.0.28-oracle` 镜像改为
    `arm64v8/mariadb:latest`，并将 `MYSQL_ROOT_PASSWORD` 变量改为 `MARIADB_ROOT_PASSWORD`。你还可以在
    [https://hub.docker.com](https://hub.docker.com) 上查找其他 MySQL 和 MariaDB 镜像版本。对于此部署，密码为
    `password`。部署使用的镜像都是为 ARM 设备设计的。如果你选择重新安装 MySQL 并使用本地存储，你需要使用 `rm -R /mnt/data`
    命令删除 `/mnt/data` 目录中的内容，以避免错误。
- en: 'Now let’s create our service to access MySQL using a service:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个服务来通过服务访问 MySQL：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To test whether your MySQL deployment works, you can access your deployment
    pod by running this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试你的 MySQL 部署是否有效，你可以通过运行以下命令来访问部署的 Pod：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the pod, run the following command to connect to your database:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 内运行以下命令以连接到数据库：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, the prompt will change to `mysql>`. Let’s create a simple database, `EXAMPLE`,
    with the `VALUE_TABLE` table, and insert and list some records. To do this, run
    the following commands and you will see output like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，提示符将更改为 `mysql>`。让我们创建一个简单的数据库 `EXAMPLE`，其中包含 `VALUE_TABLE` 表，并插入和列出一些记录。为此，运行以下命令，你将看到类似这样的输出：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, delete the table and database with the following commands:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令删除表和数据库：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you have learned how to use MySQL with this basic deployment and example.
    Now let’s move on to learn how Redis works.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用 MySQL 进行基本部署和示例。接下来让我们学习 Redis 的工作原理。
- en: Using a Redis key-value NoSQL database
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 键值 NoSQL 数据库
- en: 'Now it’s time to use Redis as our key-value database. Redis is a nice key-value
    database that doesn’t consume many resources. All its data is stored in memory.
    It has very interesting types of data such as hash keys, lists, and sets. It also
    implements publisher-subscriber and streaming features to implement channels of
    communication and simple broker functionalities. For our Redis deployment, we
    are going to use a custom configuration to set the password for Redis, and a storage
    volume to prevent losing data. To use Redis in your cluster, follow the next steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用 Redis 作为我们的键值数据库了。Redis 是一个很好的键值数据库，它不会消耗太多资源。所有数据都存储在内存中。它有一些非常有趣的数据类型，如哈希键、列表和集合。它还实现了发布-订阅和流功能，用来实现通信通道和简单的代理功能。对于我们的
    Redis 部署，我们将使用自定义配置来设置 Redis 的密码，并使用存储卷来防止数据丢失。要在集群中使用 Redis，请按照以下步骤操作：
- en: 'Create the `K3s123-` and the `/data` directory to store Redis data:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `K3s123-` 和 `/data` 目录来存储 Redis 数据：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the deployment for Redis using the previous ConfigMap called `redis-configmap`
    and mounted as the `redis.conf` file. We also use the PersistentVolumeClaim called
    `db-pv-claim`, and some resource limits for the deployment, setting the CPU and
    memory. Let’s create the deployment by running the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的 ConfigMap `redis-configmap` 创建 Redis 部署，并将其挂载为 `redis.conf` 文件。我们还使用名为
    `db-pv-claim` 的 PersistentVolumeClaim，并为部署设置一些资源限制，设置 CPU 和内存。我们通过运行以下命令来创建部署：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now create the `redis`, which points to port `6379` in our `redis` deployment:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建 `redis`，指向我们 `redis` 部署中的端口 `6379`：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This service creates a DNS record inside the cluster called `redis` that points
    to our `redis` deployment. This DNS record is accessible to other deployments
    in the cluster.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务在集群内部创建了一个名为 `redis` 的 DNS 记录，指向我们的 `redis` 部署。其他集群中的部署可以访问该 DNS 记录。
- en: 'Let’s access our Redis pods to test some basic commands to store a value in
    our database. To do this, run the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们访问 Redis pod，测试一些基本命令来存储值到我们的数据库。为此，运行以下命令：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The prompt will look like this: `127.0.0.1:6379>`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提示符将如下所示：`127.0.0.1:6379>`。
- en: 'Now, authenticate to the Redis database using the `AUTH` command, and then
    use `set` and `get` to create the `a` key with the value `1`. Finally, exit using
    the `exit` command. This simple test will look like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `AUTH` 命令认证 Redis 数据库，然后使用 `set` 和 `get` 命令创建 `a` 键并赋值为 `1`。最后，使用 `exit`
    命令退出。这个简单的测试将如下所示：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this, you stored the `a` key with the value `1`. Now you have used Redis
    to store simple values. After running `exit`, you will exit to the Redis pod.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就把 `a` 键存储了值 `1`。现在你已经使用 Redis 存储了简单的值。运行 `exit` 后，你将退出 Redis pod。
- en: Now you have learned how to deploy a simple Redis deployment, it’s time to deploy
    MongoDB in the next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何部署一个简单的 Redis 部署，接下来是时候在下一节部署 MongoDB 了。
- en: Using a MongoDB document-oriented NoSQL database
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 文档导向的 NoSQL 数据库
- en: 'MongoDB is a document-oriented NoSQL database. It stores its data as JSON documents.
    It also implements sharding techniques to distribute data across its nodes and
    uses the MapReduce technique for data aggregation. It’s easy to use and uses low
    resources for single node scenarios. For our MongoDB deployment, we are going
    to use a ConfigMap to store custom configurations. In this case, our MongoDB configuration
    is set to expose its port across the network, but for the moment we are not using
    Secrets to simplify the deployment. In the *Using a PostgreSQL object-relational
    and SQL database* section, we are going to explore the use of secrets, but before
    that, let’s follow the next steps to deploy MongoDB:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个面向文档的 NoSQL 数据库。它将数据存储为 JSON 文档，并实现了分片技术以将数据分布到各个节点，同时使用 MapReduce
    技术进行数据聚合。它易于使用，并且在单节点场景下占用较少的资源。对于我们的 MongoDB 部署，我们将使用 ConfigMap 来存储自定义配置。在这个案例中，我们的
    MongoDB 配置设置为在网络上暴露其端口，但为了简化部署，我们暂时没有使用 Secrets。在 *使用 PostgreSQL 对象关系型 SQL 数据库*
    部分，我们将探讨使用 Secrets，但在此之前，让我们按照接下来的步骤部署 MongoDB：
- en: 'Deploy your custom configuration to enable clients to connect to MongoDB:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署你的自定义配置以允许客户端连接到 MongoDB：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This exposes MongoDB to listen on port `27017` across the network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这会让 MongoDB 在网络上监听 `27017` 端口。
- en: 'Create the deployment using the ConfigMap called `mongo-configmap`, the PersistentVolumeClaim,
    and the `MONGO_INITDB_ROOT_USERNAME`, `MONGO_INITDB_ROOT_PASSWORD`, and `MONGO_INITDB_DATABASE`
    variables, which set the initial root, user, and the password to connect to MongoDB
    as root or with your defined user:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名为 `mongo-configmap` 的 ConfigMap、PersistentVolumeClaim 以及设置初始 root 用户、用户和连接
    MongoDB 所需密码的 `MONGO_INITDB_ROOT_USERNAME`、`MONGO_INITDB_ROOT_PASSWORD` 和 `MONGO_INITDB_DATABASE`
    变量来创建部署：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be aware that if you want to use a version of MongoDB greater than 5.0, you
    need a device with ARMv8.2-A or higher in order to use it. That’s the reason to
    use MongoDB 4.4 for this example. MongoDB 4.4 is supported to run on ARMv8 processors
    such as a Raspberry Pi.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你想使用 MongoDB 版本大于 5.0，你需要一台支持 ARMv8.2-A 或更高版本的设备。这个原因使得我们在这个示例中使用了 MongoDB
    4.4。MongoDB 4.4 支持在 ARMv8 处理器（如 Raspberry Pi）上运行。
- en: 'Now create the service that exposes your MongoDB deployment as a service accessible
    inside the cluster (MongoDB uses port `27017` to connect):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个服务，将你的 MongoDB 部署暴露为一个在集群内可访问的服务（MongoDB 使用 `27017` 端口连接）：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Access the pod that contains MongoDB to test whether you are able to write
    some data:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问包含 MongoDB 的 pod 来测试你是否能够写入一些数据：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once you are inside the pod, change into `mydatabase` and insert the `{"a":1}`
    document in the `mycollection` collection using `db.mycolletion.insert`. Then,
    list the inserted document using `db.mycollection.find`. Finally, execute `exit`
    to finish the Mongo session. The commands and output of this execution will look
    like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入 pod，切换到 `mydatabase`，并使用 `db.mycollection.insert` 向 `mycollection` 集合中插入
    `{"a":1}` 文档。然后，使用 `db.mycollection.find` 列出插入的文档。最后，执行 `exit` 来结束 Mongo 会话。此操作的命令和输出将如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These are some basic commands to use MongoDB, to have a quick start with Mongo.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些用于快速开始使用 MongoDB 的基本命令。
- en: Now you know how to deploy a simple MongoDB database in K3s, let’s move on to
    learn how to use Postgres in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在 K3s 中部署一个简单的 MongoDB 数据库，接下来让我们进入下一部分，学习如何使用 Postgres。
- en: Using a PostgreSQL object-relational and SQL database
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL 对象关系型 SQL 数据库
- en: 'PostgreSQL is an object-relational database, used because of its strong reputation
    for reliability, feature robustness, and performance. It uses SQL to query its
    data. It’s also commonly used for storing files or to store data used to create
    machine learning models. So, let’s learn how to deploy PostgreSQL in a very simple
    way. To do this, follow the next steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 是一种对象关系型数据库，以其可靠性、功能强大性和性能出名。它使用 SQL 来查询数据。它还常用于存储文件或存储用于创建机器学习模型的数据。因此，让我们学习如何以一种非常简单的方式部署
    PostgreSQL。为此，请按照以下步骤操作：
- en: 'For this example, let’s use Kubernetes Secrets, and let’s create the password
    as `YOUR_PASSWORD` to give an example of how to hide sensible information as passwords.
    For this, let’s generate a Base64 encoding for your password with the following
    command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，让我们使用 Kubernetes Secrets，并将密码设置为 `YOUR_PASSWORD`，以展示如何隐藏敏感信息如密码。为此，让我们使用以下命令生成密码的
    Base64 编码：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output will look like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use the previous output to create your Secret object using a YAML file. You
    can create the `db-password` Secret with this value using the following command:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的输出，通过 YAML 文件创建您的 Secret 对象。您可以使用以下命令创建具有此值的 `db-password` Secret：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now create the Postgres deployment with the following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用以下命令创建 Postgres 部署：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now create the `postgres` service by running the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过运行以下命令创建 `postgres` 服务：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Access the pod that contains Postgres to test whether you can write some data.
    To do this, run the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问包含 Postgres 的 pod，测试是否能够写入一些数据。为此，请运行以下命令：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The prompt will look like `postgres=#`. Next, you will find some example commands
    and their output. This commands will be used to test whether our database works.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示符将显示为 `postgres=#`。接下来，您将看到一些示例命令及其输出。这些命令将用于测试我们的数据库是否正常工作。
- en: 'First, create the `VALUE_TABLE` table with the `ID` and `VALUE` fields:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建包含 `ID` 和 `VALUE` 字段的 `VALUE_TABLE` 表：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then insert a record with `ID`=`1` and `VALUE`=`123`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后插入一条记录，`ID`=`1` 和 `VALUE`=`123`：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Show the values:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 显示这些值：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Delete the table:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 删除表：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Exit from Postgres:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 退出 Postgres：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you’ve learned how to install and run basic commands with Postgres to store
    your data in this database, let’s move on to learn about Neo4j, a graph NoSQL
    database, in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经学会了如何安装并运行基本命令，通过 Postgres 存储您的数据，让我们继续学习 Neo4j 这款图形 NoSQL 数据库，下一节将介绍它。
- en: Using a Neo4j graph NoSQL database
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Neo4j 图形 NoSQL 数据库
- en: 'Neo4j is a graph database that can be used to store relationships between objects.
    Neo4j uses **Cypher Query Language** (**CQL**), which is the equivalent of SQL
    for relational databases. Neo4j also represents data using nodes, relationships,
    properties, and labels in a visual way. It supports ACID operations and native
    graph storage and processing. It has great scalability and enterprise support.
    Because of the way it stores data, it can be used for IoT applications to query
    relationships between data. So now, let’s install Neo4j by following the next
    steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 是一款图形数据库，可用于存储对象之间的关系。Neo4j 使用 **Cypher 查询语言**（**CQL**），它相当于关系数据库中的 SQL。Neo4j
    还通过节点、关系、属性和标签以可视化方式表示数据。它支持 ACID 操作和原生图形存储与处理，具有出色的可扩展性和企业支持。由于其存储数据的方式，它可以用于
    IoT 应用程序，以查询数据之间的关系。现在，让我们按照以下步骤安装 Neo4j：
- en: 'Create the deployment for Neo4j:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Neo4j 的部署：
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this deployment, we are using the `NEO4J_AUTH` variable with its value set
    to `none`, to use the non-authentication method, just to simplify this example.
    You can also explore how to use secrets and other options by modifying this configuration.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此部署中，我们使用了 `NEO4J_AUTH` 变量，并将其值设置为 `none`，以使用非认证方法，只是为了简化此示例。您还可以通过修改此配置，探索如何使用密钥和其他选项。
- en: Important Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you delete the `NEO4J_AUTH` variable, Neo4j by default sets the user name
    and password to `neo4j`. Then, after logging in, a dialog box will ask you to
    change this password.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除 `NEO4J_AUTH` 变量，Neo4j 默认将用户名和密码设置为 `neo4j`。然后，登录后会弹出对话框要求您更改此密码。
- en: 'Create the service to expose the `bolt`, `http`, and `https` ports that Neo4j
    uses:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务以暴露 Neo4j 使用的 `bolt`、`http` 和 `https` 端口：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Expose the `http` and `bolt` ports, before connecting to Neo4j with the browser.
    To do this, run the following commands in different terminals:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接到 Neo4j 浏览器之前，暴露 `http` 和 `bolt` 端口。为此，请在不同的终端中运行以下命令：
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open your browser at the page `http://localhost:7474`, choose **Authentication
    type**: **No authentication**, then click on the **Connect** button:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://localhost:7474` 页面，选择 **认证类型**：**无认证**，然后点击 **连接** 按钮：
- en: '![Figure 10.2 – Neo4j login page'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – Neo4j 登录页面'
- en: '](img/B16945_10_02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_10_02.jpg)'
- en: Figure 10.2 – Neo4j login page
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Neo4j 登录页面
- en: 'Then you will see the Neo4j UI:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到 Neo4j 用户界面：
- en: '![Figure 10.3 – Neo4j main page'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – Neo4j 主页'
- en: '](img/B16945_10_03.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_10_03.jpg)'
- en: Figure 10.3 – Neo4j main page
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Neo4j 主页
- en: 'Run a simple example in the Neo4j terminal located at the top of the browser
    as `neo4j$`. To do this, add the next commands and run them by clicking on the
    blue triangle button:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器顶部的 Neo4j 终端（显示为 `neo4j$`）中运行一个简单示例。为此，添加接下来的命令并通过点击蓝色三角按钮运行：
- en: '[PRE33]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will see that Neo4j visualizes the relationship between the Marvel characters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到 Neo4j 如何可视化 Marvel 角色之间的关系：
- en: '![Figure 10.4 – Neo4j graph visualization'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – Neo4j 图形可视化'
- en: '](img/B16945_10_04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16945_10_04.jpg)'
- en: Figure 10.4 – Neo4j graph visualization
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – Neo4j 图形可视化
- en: Now you have learned how to use Neo4j with this basic example, let’s move on
    to the summary of this chapter, about what we have learned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经通过这个基本示例了解了如何使用Neo4j，接下来让我们回顾一下本章的总结，看看我们学到了什么。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use CAP theorem to choose the right database
    to store data. This theorem helped us to take into consideration important guarantees
    when designing distributed data storage in a distributed system at the edge. In
    this chapter, we also learned about different relational and non-relational databases.
    We gained practical knowledge on how to set up and deploy various database paradigms
    such as relational, key-value, document-oriented, and graph databases. In the
    next chapter, we are going to focus on the time series database Prometheus, which
    stores data in the form of values and time and can be used to implement useful
    monitoring dashboards for devices at the edge.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用CAP定理来选择合适的数据库来存储数据。这个定理帮助我们在设计边缘分布式系统中的分布式数据存储时，考虑到一些重要的保证。在本章中，我们还学习了不同的关系型和非关系型数据库。我们获得了有关如何设置和部署各种数据库范式（如关系型数据库、键值数据库、文档导向数据库和图数据库）的实践知识。在下一章中，我们将重点介绍时间序列数据库Prometheus，它以值和时间的形式存储数据，并可用于实现边缘设备的有用监控仪表板。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are a few questions to validate your new knowledge:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些问题，帮助您验证新获得的知识：
- en: How can CAP theorem help you to decide which database to use according to your
    use case?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过CAP定理根据您的使用案例决定使用哪种数据库？
- en: How can you deploy MySQL in K3s?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在K3s中部署MySQL？
- en: How can you deploy Redis in K3s?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在K3s中部署Redis？
- en: How can you deploy MongoDB in K3s?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在K3s中部署MongoDB？
- en: How can you deploy PostgreSQL on K3s?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在K3s中部署PostgreSQL？
- en: How can you deploy Neo4j on K3s?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在K3s中部署Neo4j？
- en: How can you use PersistentVolumeClaims to deploy a database on K3s?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用PersistentVolumeClaims在K3s中部署数据库？
- en: How can you use ConfigMaps and Secrets to deploy a database on K3s?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用ConfigMaps和Secrets在K3s中部署数据库？
- en: Further reading
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following references for more information on the topics
    covered in this chapter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下资料，了解本章涵盖的更多主题：
- en: '*Databases and Quick Overview of SQLite*: [https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174](https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库与SQLite快速概述*：[https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174](https://medium.com/aiadventures/databases-and-quick-overview-of-sqlite-5b7d4f8f6174)'
- en: '*CAP Theorem for Databases: Consistency, Availability & Partition Tolerance*:
    [https://www.bmc.com/blogs/cap-theorem](https://www.bmc.com/blogs/cap-theorem)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库的CAP定理：一致性、可用性与分区容错性*：[https://www.bmc.com/blogs/cap-theorem](https://www.bmc.com/blogs/cap-theorem)'
- en: 'Non-relational data and NoSQL: [https://aloa.co/blog/relational-vs-non-relational-database-pros-cons](https://aloa.co/blog/relational-vs-non-relational-database-pros-cons)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非关系数据与NoSQL：[https://aloa.co/blog/relational-vs-non-relational-database-pros-cons](https://aloa.co/blog/relational-vs-non-relational-database-pros-cons)
- en: 'CAP theorem: [https://devopedia.org/cap-theorem](https://devopedia.org/cap-theorem)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CAP定理：[https://devopedia.org/cap-theorem](https://devopedia.org/cap-theorem)
- en: '*System design fundamentals: What is the CAP theorem?*: [https://www.educative.io/blog/what-is-cap-theorem](https://www.educative.io/blog/what-is-cap-theorem)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统设计基础：什么是CAP定理？*：[https://www.educative.io/blog/what-is-cap-theorem](https://www.educative.io/blog/what-is-cap-theorem)'
- en: '*What are the ACID properties of transactions and why do they matter in data
    engineering?*: [https://www.keboola.com/blog/acid-transactions](https://www.keboola.com/blog/acid-transactions)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事务的ACID属性是什么？它们在数据工程中为何如此重要？*：[https://www.keboola.com/blog/acid-transactions](https://www.keboola.com/blog/acid-transactions)'
- en: '*SQL vs NoSQL Databases: What’s The Difference?*: [https://www.bmc.com/blogs/sql-vs-nosql](https://www.bmc.com/blogs/sql-vs-nosql)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQL与NoSQL数据库：有什么区别？*：[https://www.bmc.com/blogs/sql-vs-nosql](https://www.bmc.com/blogs/sql-vs-nosql)'
- en: '*Traditional RDBMS to NoSQL database: New era of databases for big data*: [https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA](https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从传统关系数据库到NoSQL数据库：大数据时代的数据库新纪元*：[https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA](https://www.researchgate.net/publication/324922396_TRADITIONAL_RDBMS_TO_NOSQL_DATABASE_NEW_ERA_OF_DATABASES_FOR_BIG_DATA)'
- en: 'MySQL client K8s: [https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078](https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MySQL 客户端 K8s: [https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078](https://gist.github.com/vishnuhd/b8686197f855c00fa734bc5f1fedf078)'
- en: '*Run a Single-Instance Stateful Application*: [https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application](https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行单实例有状态应用程序*: [https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application](https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application)'
- en: '*MySQL 8 Administrator’s Guide*: [https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199](https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MySQL 8 管理员指南*: [https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199](https://www.packtpub.com/product/mysql-8-administrator-s-guide/9781788395199)'
- en: '*Configuring Redis using a ConfigMap*: [https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap](https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 ConfigMap 配置 Redis*: [https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap](https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap)'
- en: '*Redis Essentials*: [https://www.packtpub.com/product/redis-essentials/9781784392451](https://www.packtpub.com/product/redis-essentials/9781784392451)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Redis Essentials*: [https://www.packtpub.com/product/redis-essentials/9781784392451](https://www.packtpub.com/product/redis-essentials/9781784392451)'
- en: 'Kubernetes secrets: [https://kubernetes.io/fr/docs/concepts/configuration/secret](https://kubernetes.io/fr/docs/concepts/configuration/secret)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubernetes secrets: [https://kubernetes.io/fr/docs/concepts/configuration/secret](https://kubernetes.io/fr/docs/concepts/configuration/secret)'
- en: '*Seven NoSQL Databases in a Week*: [https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867](https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*七天内掌握七种 NoSQL 数据库*: [https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867](https://www.packtpub.com/product/seven-nosql-databases-in-a-week/9781787288867)'
- en: '*How to use Kubernetes to deploy Postgres*: [https://www.sumologic.com/blog/kubernetes-deploy-postgres](https://www.sumologic.com/blog/kubernetes-deploy-postgres)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何使用 Kubernetes 部署 PostgreSQL*: [https://www.sumologic.com/blog/kubernetes-deploy-postgres](https://www.sumologic.com/blog/kubernetes-deploy-postgres)'
- en: '*PostgreSQL 14 Administration Cookbook*: [https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974](https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PostgreSQL 14 管理手册*: [https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974](https://www.packtpub.com/product/postgresql-14-administration-cookbook/9781803248974)'
- en: '*Internet of Things and Data: A Powerful Connection*: [https://neo4j.com/news/internet-things-data-powerful-connection](https://neo4j.com/news/internet-things-data-powerful-connection)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*物联网和数据：强大的连接*: [https://neo4j.com/news/internet-things-data-powerful-connection](https://neo4j.com/news/internet-things-data-powerful-connection)'
- en: 'Why not SQLite: [https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod](https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为什么不使用 SQLite: [https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod](https://stackoverflow.com/questions/66950385/how-to-use-sqlite3-database-with-django-on-kuberenets-pod)'
- en: '*Creating a Graph Application with Python, Neo4j, Gephi, and Linkurious.js*:
    [https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js](https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Python、Neo4j、Gephi 和 Linkurious.js 创建图形应用程序*: [https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js](https://linkurious.com/blog/creating-a-graph-application-with-python-neo4j-gephi-and-linkurious-js)'
- en: 'Part 3: Edge Computing Use Cases in Practice'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：实际边缘计算使用案例
- en: In this part, you will learn how to use k3s and k3OS for different use cases,
    exploring complementary software and best practices for building an edge computing
    system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将学习如何在不同的使用情景下使用 k3s 和 k3OS，探索构建边缘计算系统的互补软件和最佳实践。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '本书的这一部分包括以下章节:'
- en: '[*Chapter 11*](B16945_11_Final_PG.xhtml#_idTextAnchor213), *Monitoring the
    Edge with Prometheus and Grafana*'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B16945_11_Final_PG.xhtml#_idTextAnchor213)，*使用 Prometheus 和 Grafana
    监控边缘*'
- en: '[*Chapter 12*](B16945_12_Final_PG.xhtml#_idTextAnchor227), *Communicating with
    Edge Devices across Long Distances Using LoRa*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B16945_12_Final_PG.xhtml#_idTextAnchor227)，*使用 LoRa 远程通信边缘设备*'
- en: '[*Chapter 13*](B16945_13_Final_PG.xhtml#_idTextAnchor246), *Geolocalization
    Applications Using GPS, NoSQL, and K3s Clusters*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B16945_13_Final_PG.xhtml#_idTextAnchor246)，*使用 GPS、NoSQL 和 K3s 集群的地理定位应用*'
- en: '[*Chapter 14*](B16945_14_Final_PG.xhtml#_idTextAnchor267), *Computer Vision
    with Python and K3s Clusters*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B16945_14_Final_PG.xhtml#_idTextAnchor267)，*使用Python和K3s集群进行计算机视觉*'
- en: '[*Chapter 15*](B16945_15_Final_PG.xhtml#_idTextAnchor285), *Designing Your
    Own Edge Computing System*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B16945_15_Final_PG.xhtml#_idTextAnchor285)，*设计你自己的边缘计算系统*'
