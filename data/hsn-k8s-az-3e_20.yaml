- en: 14\. Serverless functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 无服务器函数
- en: Serverless computing and serverless functions have gained tremendous traction
    over the past few years due to scalability and reduced management overhead. Cloud
    services such as Azure Functions, AWS Lambda, and GCP Cloud Run have made it very
    easy for users to run their code as serverless functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可扩展性和减少管理开销，近年来无服务器计算和无服务器函数获得了巨大关注。Azure Functions、AWS Lambda 和 GCP Cloud
    Run 等云服务使用户可以轻松地将代码作为无服务器函数运行。
- en: The word **serverless** refers to any solution where you don't need to manage
    servers. Serverless functions refer to a subset of serverless computing where
    you can run your code as a function on-demand. This means that your code in the
    function will only run and be executed when there is a demand. This architectural
    style is called event-driven architecture. In an event-driven architecture, the
    event consumers are triggered when there is an event. In the case of serverless
    functions, the event consumers will be these serverless functions. An event can
    be anything from a message in a queue to a new object uploaded to storage, or
    even an HTTP call.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**无服务器**一词指的是任何不需要管理服务器的解决方案。无服务器函数是无服务器计算的一个子集，允许你按需运行代码作为函数。这意味着当有需求时，函数中的代码才会运行和执行。这种架构风格称为事件驱动架构。在事件驱动架构中，当发生事件时，事件消费者会被触发。在无服务器函数的情况下，事件消费者就是这些无服务器函数。事件可以是从队列中的一条消息到上传到存储的新对象，甚至是一个
    HTTP 调用。'
- en: Serverless functions are frequently used for backend processing. A common example
    of serverless functions is creating thumbnails of a picture that is uploaded to
    storage, as shown in *Figure 14.1*. Since you cannot predict how many pictures
    will be uploaded and when they will be uploaded, it is hard to plan traditional
    infrastructure and how many servers you should have available for this process.
    If you implement the creation of that thumbnail as a serverless function, this
    function will be called on each picture that is uploaded. You don't have to plan
    the number of functions since each new picture will trigger a new function to
    be executed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数通常用于后台处理。一个常见的无服务器函数示例是创建上传到存储的图片的缩略图，如*图 14.1*所示。由于你无法预测会有多少图片被上传以及何时上传，因此很难规划传统基础设施以及需要多少服务器来处理这个过程。如果你将生成缩略图的过程实现为无服务器函数，那么每上传一张图片，该函数就会被调用。你无需规划函数的数量，因为每张新图片都会触发一个新的函数执行。
- en: '![Example architecture of a serverless function to generate thumbnails of images](img/B17338_14_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![生成图片缩略图的无服务器函数示例架构](img/B17338_14_01.jpg)'
- en: 'Figure 14.1: Example architecture of a serverless function to generate thumbnails
    of images'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：生成图片缩略图的无服务器函数示例架构
- en: As you saw in the previous example, functions will automatically scale to meet
    increased or decreased demand. Additionally, each function can scale independently
    from other functions. However, this automatic scaling is just one benefit of using
    serverless functions. Another benefit of serverless functions is the ease of development.
    Using serverless functions, you can focus on writing the code and don't have to
    deal with the underlying infrastructure. Serverless functions allow code to be
    deployed without worrying about managing servers and middleware. Finally, in public
    cloud serverless functions, you pay per execution of the function. This means
    that you pay each time your functions are run, and you are charged nothing for
    the idle time when your functions are not run.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在之前的示例中看到的，函数会自动扩展以应对增加或减少的需求。此外，每个函数可以独立于其他函数进行扩展。然而，这种自动扩展只是使用无服务器函数的一个好处。无服务器函数的另一个好处是开发的简便性。使用无服务器函数，你可以专注于编写代码，而无需处理底层基础设施。无服务器函数允许代码在无需担心管理服务器和中间件的情况下进行部署。最后，在公共云无服务器函数中，你按每次执行函数计费。这意味着你每次函数运行时都需要付费，而在函数未运行时，你不会为闲置时间收费。
- en: 'The popularity of public cloud serverless function platforms has caused multiple
    open-source frameworks to be created to enable users to create serverless functions
    on top of Kubernetes. In this chapter, you will learn how to deploy serverless
    functions on **Azure Kubernetes Service** (**AKS**) directly using the open-source
    version of Azure Functions. You will start by running a simple function that is
    triggered based on an HTTP message. Afterward, you will install a function **autoscaler**
    feature on your cluster. You will also integrate AKS-deployed applications with
    Azure storage queues. We will be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 公有云无服务器函数平台的流行促使了多个开源框架的出现，这些框架使用户能够在 Kubernetes 上创建无服务器函数。在本章中，你将学习如何直接使用 Azure
    Functions 的开源版本在 **Azure Kubernetes Service** (**AKS**) 上部署无服务器函数。你将从运行一个基于 HTTP
    消息触发的简单函数开始。之后，你将安装一个 **autoscaler** 功能到你的集群中。你还将把 AKS 部署的应用程序与 Azure 存储队列集成。我们将涵盖以下主题：
- en: Overview of different functions platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同函数平台概览
- en: Deploying an HTTP-triggered function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个 HTTP 触发的函数
- en: Deploying a queue-triggered function
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署队列触发的函数
- en: Let's start this chapter by exploring the various functions platforms that are
    available for Kubernetes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从探索 Kubernetes 上可用的各种函数平台开始。
- en: Various functions platforms
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 各种函数平台
- en: Functions platforms, such as Azure Functions, AWS Lambda, and Google Cloud Functions,
    have gained tremendous popularity. The ability to run code without the need to
    manage servers and having virtually limitless scale is very popular. The downside
    of using the functions implementation of a cloud provider is that you are locked
    into the cloud provider's infrastructure and their programming model. Also, you
    can only run your functions in the public cloud and not in your own datacenter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数平台，如 Azure Functions、AWS Lambda 和 Google Cloud Functions，已经获得了巨大的普及。能够在无需管理服务器的情况下运行代码，并且几乎可以实现无限扩展，非常受欢迎。使用云服务商的函数实现的缺点是，你被锁定在该云服务商的基础设施和编程模型中。此外，你只能在公有云中运行函数，不能在自己的数据中心运行。
- en: 'A number of open-source functions frameworks have been launched to solve these
    downsides. There are a number of popular frameworks that can be run on Kubernetes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些缺点，推出了多个开源的函数框架。现在有多个受欢迎的框架可以在 Kubernetes 上运行：
- en: '**Knative** (https://cloud.google.com/knative/): Knative is a serverless platform
    written in the Go language and developed by Google. You can run Knative functions
    either fully managed on Google Cloud or on your own Kubernetes cluster.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Knative** (https://cloud.google.com/knative/): Knative 是一个由 Google 开发的、使用
    Go 语言编写的无服务器平台。你可以将 Knative 函数完全托管在 Google Cloud 上运行，或者在你自己的 Kubernetes 集群上运行。'
- en: '`OpenFaaSCloud`. The platform is written in the Go language.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenFaaSCloud`。该平台使用 Go 语言编写。'
- en: '`Kubeless`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kubeless`。'
- en: '**Fission.io** (https://fission.io/): Fission is a serverless framework backed
    by the company Platform9\. It is written in the Go language and is Kubernetes-native.
    It can run on any Kubernetes cluster.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fission.io** (https://fission.io/): Fission 是一个由 Platform9 公司支持的无服务器框架。它使用
    Go 语言编写，并且是 Kubernetes 原生的。它可以在任何 Kubernetes 集群上运行。'
- en: '**Apache OpenWhisk** (https://openwhisk.apache.org/): OpenWhisk is an open-source,
    distributed serverless platform maintained by the Apache organization. It can
    be run on Kubernetes, Mesos, or Docker Compose. It is primarily written in the
    Scala language.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache OpenWhisk** (https://openwhisk.apache.org/): OpenWhisk 是由 Apache 组织维护的开源分布式无服务器平台。它可以在
    Kubernetes、Mesos 或 Docker Compose 上运行。主要使用 Scala 语言编写。'
- en: Microsoft has taken an interesting strategy with its functions platform. Microsoft
    operates Azure Functions as a managed service on Azure and has open-sourced the
    complete solution and made it available to run on any system (https://github.com/Azure/azure-functions-host).
    This also makes the Azure Functions programming model available on top of Kubernetes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在其函数平台上采取了一种有趣的策略。微软将 Azure Functions 作为 Azure 上的托管服务进行运营，并且已将完整的解决方案开源，允许在任何系统上运行（https://github.com/Azure/azure-functions-host）。这也使得
    Azure Functions 编程模型能够在 Kubernetes 上运行。
- en: Microsoft has also released an additional open-source project in partnership
    with Red Hat called **Kubernetes Event-driven Autoscaling** (**KEDA**) to make
    scaling functions on top of Kubernetes easier. KEDA is a custom autoscaler that
    can allow deployments on Kubernetes to scale down to and up from zero pods, which
    is not possible using the default **Horizontal Pod Autoscaler** (**HPA**) in Kubernetes.
    The ability to scale from zero to one pod is important so that your application
    can start processing events, but scaling down to zero instances is useful for
    preserving resources in your cluster. KEDA also makes additional metrics available
    to the Kubernetes HPA to make scaling decisions based on metrics from outside
    the cluster (for example, the number of messages in a queue).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微软还与 Red Hat 合作发布了一个额外的开源项目，名为 **Kubernetes 事件驱动自动扩展** (**KEDA**)，旨在简化 Kubernetes
    上函数的扩展操作。KEDA 是一个自定义的自动扩展器，允许 Kubernetes 上的部署从零个 Pod 扩展到任意数量的 Pod，这在 Kubernetes
    的默认 **水平 Pod 自动扩展器** (**HPA**) 中是无法实现的。从零扩展到一个 Pod 是非常重要的，因为这样应用程序可以开始处理事件，而扩展到零实例对于在集群中节省资源也非常有用。KEDA
    还为 Kubernetes HPA 提供了额外的度量标准，以便基于来自集群外部的度量（例如队列中的消息数）做出扩展决策。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We introduced and explained the HPA in *Chapter 4*, *Building scalable applications*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第 4 章*，*构建可扩展应用程序* 中介绍并解释了 HPA。
- en: 'In this chapter, you will deploy Azure Functions to Kubernetes with two examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过两个示例将 Azure Functions 部署到 Kubernetes 上：
- en: An HTTP-triggered function (without KEDA)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 HTTP 触发的函数（不使用 KEDA）
- en: A queue-triggered function (with KEDA)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个队列触发的函数（使用 KEDA）
- en: Before starting with these functions, the next section will consider the necessary
    prerequisites for these deployments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这些函数之前，下一节将考虑这些部署所需的必要前提条件。
- en: Setting up the prerequisites
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置前提条件
- en: In this section, you will set up the prerequisites needed to build and run functions
    on your Kubernetes cluster. You need to set up an **Azure container registry**
    (**ACR**) and a **virtual machine** (**VM**) in Azure that will be used to develop
    the functions. The ACR will be used to store custom container images that contain
    the functions you will develop. You will also use a VM to build the functions
    and create Docker images, since you cannot do this from Azure Cloud Shell.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将设置在 Kubernetes 集群上构建和运行函数所需的前提条件。你需要在 Azure 中设置一个 **Azure 容器注册表** (**ACR**)
    和一个用于开发函数的 **虚拟机** (**VM**)。ACR 将用于存储包含你将要开发的函数的自定义容器镜像。你还将使用虚拟机来构建这些函数并创建 Docker
    镜像，因为你不能通过 Azure Cloud Shell 来执行此操作。
- en: Container images and a container registry were introduced in *Chapter 1*, *Introduction
    to containers and Kubernetes*, in the section on *Container images*. A container
    image contains all the software required to start an actual running container.
    In this chapter, you will build custom container images that contain your functions.
    You need a place to store these images so that Kubernetes can pull them and run
    the containers at scale. You will use ACR for this. ACR is a private container
    registry that is fully managed by Azure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像和容器注册表在 *第 1 章*，*容器与 Kubernetes 简介* 中的 *容器镜像* 部分介绍过。容器镜像包含启动实际运行容器所需的所有软件。在本章中，你将构建包含函数的自定义容器镜像。你需要一个存储这些镜像的地方，以便
    Kubernetes 可以拉取它们并按需扩展运行容器。你将使用 ACR 来实现这一点。ACR 是一个由 Azure 完全管理的私有容器注册表。
- en: Up to now in this book, you have run all the examples on Azure Cloud Shell.
    For the example in this chapter, you will need a separate VM because Azure Cloud
    Shell doesn't allow you to build container images. You will create a new VM in
    Azure to do these tasks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的所有示例都在 Azure Cloud Shell 上运行。对于本章的示例，你需要一个单独的虚拟机，因为 Azure Cloud Shell
    不允许你构建容器镜像。你将需要在 Azure 中创建一个新的虚拟机来执行这些任务。
- en: Let's begin by creating an ACR.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个 ACR 开始。
- en: Azure Container Registry
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure 容器注册表
- en: 'Azure Functions on Kubernetes needs an image registry to store its container
    images. In this section, you will create an ACR and configure your Kubernetes
    cluster to have access to this cluster:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 在 Kubernetes 上需要一个镜像注册表来存储其容器镜像。在本节中，你将创建一个 ACR，并配置 Kubernetes
    集群以访问该注册表：
- en: In the Azure search bar, search for `container registry` and click on Container
    registries, as shown in *Figure 14.2*:![Navigating to Container registries through
    the Azure portal](img/B17338_14_02.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 搜索栏中，搜索 `container registry`，然后点击容器注册表，如 *图 14.2* 所示：![通过 Azure 门户导航到容器注册表](img/B17338_14_02.jpg)
- en: 'Figure 14.2: Navigating to Container registry services through the Azure portal'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.2：通过 Azure 门户导航到容器注册表服务
- en: Click the Add button at the top to create a new registry. To organize the resources
    in this chapter together, create a new resource group. To do this, click on Create
    new under the Resource group field to create a new resource group, and call it
    `Functions-KEDA`, as shown in *Figure 14.3*:![Creating a new resource group to
    create the registry](img/B17338_14_03.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的“添加”按钮以创建新的注册表。为了将本章中的资源组织在一起，创建一个新的资源组。为此，在资源组字段下点击“创建新资源组”以创建一个新的资源组，并将其命名为
    `Functions-KEDA`，如 *图 14.3* 所示：![创建新的资源组以创建注册表](img/B17338_14_03.jpg)
- en: 'Figure 14.3: Creating a new resource group'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.3：创建新的资源组
- en: 'Provide the details to create the registry. The registry name needs to be globally
    unique, so consider adding your initials to the registry name. It is recommended
    to create the registry in the same location as your cluster. To reduce spending
    for the demo, you can change SKU to Basic. Select the Review + create button at
    the bottom to create the registry, as shown in *Figure 14.4*:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供创建注册表的详细信息。注册表名称需要全局唯一，因此可以考虑在注册表名称中添加你的首字母。建议在与集群相同的位置创建注册表。为了减少演示成本，可以将
    SKU 更改为 Basic。选择底部的“审核 + 创建”按钮以创建注册表，如 *图 14.4* 所示：
- en: '![Review the details provided and hit Review + create to create the registry](img/B17338_14_04.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![审核提供的详细信息并点击审核 + 创建以创建注册表](img/B17338_14_04.jpg)'
- en: 'Figure 14.4: Providing details to create the registry'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.4：提供创建注册表的详细信息
- en: In the resulting pane, click the Create button to create the registry.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在结果窗格中，点击“创建”按钮以创建注册表。
- en: 'Once your registry is created, open Cloud Shell so that you can configure your
    AKS cluster to get access to your container registry. Use the following command
    to give AKS permissions to your registry:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册表创建完成后，打开 Cloud Shell，这样你就可以配置 AKS 集群以访问容器注册表。使用以下命令为 AKS 提供访问注册表的权限：
- en: '[PRE0]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will return an output similar to *Figure 14.5*. The figure has been cropped
    to show only the top part of the output:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回类似于 *图 14.5* 的输出。图像已被裁剪，仅显示输出的顶部部分：
- en: '![Giving AKS permissions on your registry](img/B17338_14_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![为 AKS 提供注册表权限](img/B17338_14_05.jpg)'
- en: 'Figure 14.5: Allowing AKS cluster to access the container registry'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：允许 AKS 集群访问容器注册表
- en: You now have an ACR that is integrated with AKS. In the next section, you will
    create a VM that will be used to build the Azure functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了与 AKS 集成的 ACR。在下一部分，你将创建一个虚拟机，用于构建 Azure 函数。
- en: Creating a VM
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟机
- en: 'In this section, you will create a VM and install the tools necessary to run
    Azure Functions on this machine:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建虚拟机并安装在该机器上运行 Azure 函数所需的工具：
- en: The Docker runtime
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 运行时
- en: The Azure CLI
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CLI
- en: Azure Functions
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 函数
- en: Kubectl
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubectl
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To ensure a consistent experience, you will be creating a VM on Azure that will
    be used for development. If you prefer to run the sample on your local machine,
    you can install all the required tools locally.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为确保一致的体验，你将在 Azure 上创建一个虚拟机，用于开发。如果你更喜欢在本地机器上运行示例，可以在本地安装所有必需的工具。
- en: 'Let''s get started with creating the VM:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建虚拟机：
- en: 'To ensure this example works with the Azure trial subscription, you will need
    to scale down your cluster to one node. You can do this using the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保这个示例能在 Azure 试用订阅中运行，你需要将集群缩放到一个节点。你可以使用以下命令来做到这一点：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To authenticate to the VM you are going to create, you''ll need a set of SSH
    keys. If you followed the example in *Chapter 9*, *Azure Active Directory pod-managed
    identities in AKS* in the *Setting up a new cluster with AAD pod-managed identity*
    section, you will already have a set of SSH keys. To verify that you have SSH
    keys, run the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要对你将创建的虚拟机进行身份验证，你需要一组 SSH 密钥。如果你按照 *第 9 章* 中的示例操作，在 *使用 AAD Pod 管理身份设置新集群*
    部分的 *Azure Active Directory Pod 管理身份* 中，你已经拥有了一组 SSH 密钥。要验证你是否拥有 SSH 密钥，运行以下命令：
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should show you the presence of an SSH private key (`id_rsa`) and a public
    key (`id_rsa.pub`), as shown in *Figure 14.6*:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会显示 SSH 私钥（`id_rsa`）和公钥（`id_rsa.pub`）的存在，如 *图 14.6* 所示：
- en: '![Verifying the SSH keys that are present](img/B17338_14_06.jpg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![验证存在的 SSH 密钥](img/B17338_14_06.jpg)'
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will be prompted for a location and a passphrase. Keep the default location
    and input an empty passphrase.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 系统会提示你输入位置和密码短语。保留默认位置，并输入一个空的密码短语。
- en: 'You will now create the VM. You will create an Ubuntu VM using the following
    command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将创建虚拟机。使用以下命令创建一个 Ubuntu 虚拟机：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will take a couple of minutes to complete. Once the VM is created, Cloud
    Shell should show you its public IP, as displayed in *Figure 14.7*:![Running the
    az vm create command and getting the public ip of the VM from the command](img/B17338_14_07.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这需要几分钟时间完成。一旦虚拟机创建完成，Cloud Shell 应该会显示其公共 IP 地址，如 *图 14.7* 中所示：![运行 az vm create
    命令并获取虚拟机的公共 IP 地址](img/B17338_14_07.jpg)
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will be prompted about whether you trust the machine's identity. Type `yes`
    to confirm.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 系统将提示您是否信任该机器的身份。键入 `yes` 以确认。
- en: 'You''re now connected to a new VM on Azure. On this machine, we will begin
    by installing Docker:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在已连接到 Azure 上的新虚拟机。在这台机器上，我们将首先安装 Docker：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To make the operation smoother, add the user to the Docker group. This will
    ensure you can run Docker commands without `sudo`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使操作更加顺畅，将用户添加到 Docker 组。这将确保您能够在不使用 `sudo` 的情况下运行 Docker 命令：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should now be able to run the `hello-world` command:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您应该能够运行 `hello-world` 命令：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will show you an output similar to *Figure 14.8*:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示与 *图 14.8* 类似的输出：
- en: '![Verifying that Docker runs on the virtual machine](img/B17338_14_08.jpg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![验证 Docker 在虚拟机上运行](img/B17338_14_08.jpg)'
- en: 'Figure 14.8: Verifying Docker runs on the VM'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.8：验证 Docker 是否在虚拟机上运行
- en: 'Next, you will install the Azure CLI on this VM. You can install the CLI using
    the following command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将在此虚拟机上安装 Azure CLI。您可以使用以下命令安装 CLI：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Verify that the CLI was installed successfully by signing in:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过登录来验证 CLI 是否成功安装：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will display a login code that you need to enter at https://microsoft.com/devicelogin:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示一个登录代码，您需要在 https://microsoft.com/devicelogin 输入该代码：
- en: '![Logging in to the Azure CLI](img/B17338_14_09.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![登录到 Azure CLI](img/B17338_14_09.jpg)'
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The credentials to ACR expire after 3 hours. If you run into the following
    error during this demonstration, you can sign in to ACR again using the following
    command:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ACR 的凭证在 3 小时后过期。如果在演示过程中遇到以下错误，您可以使用以下命令重新登录 ACR：
- en: '![Potential error that you might get while authenticating your machine to ACR](img/B17338_14_10.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![在身份验证机器时可能出现的错误](img/B17338_14_10.jpg)'
- en: 'Figure 14.10: Potential authentication error in the future'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.10：未来可能出现的身份验证错误
- en: 'Next, you''ll install `kubectl` on your machine. The Azure CLI has a shortcut
    to install the CLI, which you can use to install it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将在您的机器上安装 `kubectl`。Azure CLI 提供了一个安装 CLI 的快捷方式，您可以使用它来安装：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s verify that `kubectl` can connect to our cluster. For this, we''ll first
    get the credentials and then execute a `kubectl` command:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们验证 `kubectl` 是否能连接到我们的集群。为此，我们首先获取凭证，然后执行 `kubectl` 命令：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you can install the Azure Functions tools on this machine. To do this,
    run the following commands:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在此机器上安装 Azure Functions 工具。为此，请运行以下命令：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will return an output similar to *Figure 14.11*:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回类似于 *图 14.11* 的输出：
- en: '![Installing Azure Functions Core Tools](img/B17338_14_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Azure Functions 核心工具](img/B17338_14_11.jpg)'
- en: 'Figure 14.11: Installing Functions core tools'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11：安装 Functions 核心工具
- en: Note
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you are running a newer version of Ubuntu than 18.04, please make sure that
    you download the correct `dpkg` package by changing the URL in the first line
    to reflect your Ubuntu version.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是比 18.04 更新的 Ubuntu 版本，请确保通过更改第一行中的 URL 以匹配您的 Ubuntu 版本，来下载正确的 `dpkg`
    包。
- en: You now have the prerequisites to start working with functions on Kubernetes.
    You created an ACR to store custom container images, and you have a VM that will
    be used to create and build Azure functions. In the next section, you will build
    your first function, which is HTTP-triggered.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已具备开始在 Kubernetes 上使用函数的先决条件。您已经创建了一个 ACR 用于存储自定义容器镜像，并且拥有一台将用于创建和构建 Azure
    函数的虚拟机。在下一部分，您将构建第一个函数，它是 HTTP 触发的。
- en: Creating an HTTP-triggered Azure function
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 HTTP 触发的 Azure 函数
- en: 'In this first example, you will create an HTTP-triggered Azure function. This
    means that you can browse to the page hosting the actual function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，您将创建一个 HTTP 触发的 Azure 函数。这意味着您可以浏览到托管实际函数的页面：
- en: 'To begin, create a new directory and navigate to that directory:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新目录并导航到该目录：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you will initialize a function using the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将使用以下命令初始化一个函数：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `––docker` parameter specifies that you will build the function as a Docker
    container. This will result in a Dockerfile being created. Select the Python language,
    which is option 3 in the following screenshot:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`––docker` 参数指定您将把函数构建为 Docker 容器。这将导致生成一个 Dockerfile。选择 Python 语言，这是下图中的选项
    3：'
- en: '![Creating a Python function](img/B17338_14_12.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建 Python 函数](img/B17338_14_12.jpg)'
- en: 'Figure 14.12: Creating a Python function'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.12：创建 Python 函数
- en: This will create the required files for your function to work.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建使函数能够工作的所需文件。
- en: 'Next, you will create the actual function. Enter the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将创建实际的函数。请输入以下命令：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should result in an output like the following. Select the eighth option,
    HTTP trigger, and name the function `python-http`:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生如下输出。选择第八个选项，HTTP 触发器，并将函数命名为`python-http`：
- en: '![Creating an HTTP-triggered function using the required option](img/B17338_14_13.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用所需选项创建 HTTP 触发的函数](img/B17338_14_13.jpg)'
- en: 'Figure 14.13: Creating an HTTP-triggered function'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.13：创建 HTTP 触发的函数
- en: 'The code of the function is stored in the directory called `python-http`. You
    are not going to make code changes to this function. If you want to check out
    the source code of the function, you can run the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的代码存储在名为`python-http`的目录中。你不需要对这个函数进行代码更改。如果你想查看该函数的源代码，可以运行以下命令：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will need to make one change to the function''s configuration file. By
    default, functions require an authenticated request. You will change this to `anonymous`
    for this demo. Make the change using the `vi` command by executing the following
    command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要对函数的配置文件进行一次修改。默认情况下，函数需要经过认证的请求。为了本次演示，你将此设置更改为`anonymous`。通过执行以下命令使用`vi`命令进行修改：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Replace `authLevel` on *line 5* with `anonymous`. To make that change, press
    *I* to go into insert mode, then remove `function` and replace it with `anonymous`:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*第 5 行*将`authLevel`替换为`anonymous`。要进行此更改，请按*I*进入插入模式，然后删除`function`并用`anonymous`替换：
- en: '![Modifying the configuration file by changing the authLevelfunction to anonymous](img/B17338_14_14.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![修改配置文件，将 authLevelfunction 更改为 anonymous](img/B17338_14_14.jpg)'
- en: 'Figure 14.14: Changing the authLevel function to anonymous'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.14：将 authLevel 函数更改为 anonymous
- en: Hit *Esc*, type `:wq!`, and then hit *Enter* to save and quit `vi`.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按下*Esc*键，输入`:wq!`，然后按*Enter*键保存并退出`vi`。
- en: Note
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You changed the authentication requirement for your function to `anonymous`.
    This will make the demo easier to execute. If you plan to release functions to
    production, you need to carefully consider this setting, since this controls who
    has access to your function.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已将函数的认证要求更改为`anonymous`。这样做会使演示更易于执行。如果你计划将函数发布到生产环境，需要仔细考虑此设置，因为它控制了谁可以访问你的函数。
- en: 'You are now ready to deploy your function to AKS. You can deploy the function
    using the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你已准备好将函数部署到 AKS。你可以使用以下命令部署该函数：
- en: '[PRE20]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will cause the functions runtime to do a couple of steps. First, it will
    build a container image, then it will push that image to the registry, and finally,
    it will deploy the function to Kubernetes:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致函数运行时执行几个步骤。首先，它会构建一个容器镜像，然后将该镜像推送到注册表，最后，它将函数部署到 Kubernetes：
- en: '![Using the func kubernetes deploy command for deploying the function to AKS](img/B17338_14_15.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 func kubernetes deploy 命令将函数部署到 AKS](img/B17338_14_15.jpg)'
- en: 'Figure 14.15: Deploying the function to AKS'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.15：将函数部署到 AKS
- en: You can click the Invoke url URL that is shown to get access to your function.
    Before doing so, however, let's explore what was created on the cluster.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以点击显示的 Invoke url URL 来访问你的函数。不过，在执行此操作之前，让我们先了解一下在集群上创建的内容。
- en: 'To create the function, a regular deployment on top of Kubernetes was used.
    To check the deployment, you can run the following command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建这个函数，使用了一个常规的 Kubernetes 部署。要检查部署状态，你可以运行以下命令：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will show you the deployment, as in *Figure 14.16*:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将展示你的部署，如*图 14.16*所示：
- en: '![Checking the deployment](img/B17338_14_16.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![检查部署情况](img/B17338_14_16.jpg)'
- en: 'Figure 14.16: Deployment details'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.16：部署详细信息
- en: 'This process also created a service on top of your Kubernetes cluster. You
    can get the public IP of the service that was deployed and connect to it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程还在 Kubernetes 集群上创建了一个服务。你可以获取已部署服务的公共 IP，并连接到它：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will show you the service and its public IP, as shown in *Figure 14.17*.
    Notice how this public IP is the same as the one shown in the output of *Step
    4*.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将展示服务及其公共 IP，如*图 14.17*所示。请注意，这个公共 IP 与*步骤 4*中输出的 IP 是相同的。
- en: '![Getting the service’s public IP](img/B17338_14_17.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![获取服务的公共 IP](img/B17338_14_17.jpg)'
- en: 'Figure 14.17: Getting the service''s public IP'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：获取服务的公共 IP
- en: 'Open a web browser and browse to `http://<external-ip>/api/python-http?name=handsonaks`.
    You should see a web page showing you Hello, handsonaks. This HTTP triggered function
    executed successfully. This is shown in *Figure 14.18*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问`http://<external-ip>/api/python-http?name=handsonaks`。您应该看到一个网页，显示“Hello,
    handsonaks. This HTTP triggered function executed successfully.” 这在*图 14.18*中展示：
- en: '![Navigating to the external IP will return the HTTP function output](img/B17338_14_18.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![导航到外部 IP 将返回 HTTP 函数输出](img/B17338_14_18.jpg)'
- en: 'Figure 14.18: Output of the HTTP triggered function'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18：HTTP 触发函数的输出
- en: 'You have now created a function with an HTTP trigger. Using an HTTP-triggered
    function is useful in scenarios where you are providing an HTTP API with unpredictable
    load patterns. Let''s clean up this deployment before moving on to the next section:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经创建了一个带有 HTTP 触发器的函数。使用 HTTP 触发的函数在负载模式不可预测的情况下提供 HTTP API 时非常有用。在进入下一节之前，让我们清理一下这个部署：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this section, you created a sample function using an HTTP trigger. Let's
    take that one step further and integrate a new function with storage queues and
    set up the KEDA autoscaler in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您使用 HTTP 触发器创建了一个示例函数。让我们进一步提升，将一个新函数与存储队列集成，并在下一节中设置 KEDA 自动扩缩容。
- en: Creating a queue-triggered function
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建队列触发的函数
- en: In the previous section, you created a sample HTTP function. In this section,
    you'll build another sample using a queue-triggered function. Queues are often
    used to pass messages between different components of an application. A function
    can be triggered based on messages in a queue to then perform additional processing
    on these messages.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您创建了一个示例 HTTP 函数。在本节中，您将构建另一个示例，使用队列触发的函数。队列常用于在应用程序的不同组件之间传递消息。可以根据队列中的消息触发函数，从而对这些消息执行额外的处理。
- en: In this section, you'll create a function that is integrated with Azure storage
    queues to consume events. You will also configure KEDA to allow scaling to/from
    zero pods in the case of low traffic.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建一个与 Azure 存储队列集成的函数，以处理事件。您还将配置 KEDA，以便在流量较低时允许自动扩缩容，达到零 Pods。
- en: Let's start by creating a queue in Azure.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在 Azure 中创建一个队列。
- en: Creating a queue
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建队列
- en: In this section, you will create a new storage account and a new queue in that
    storage account. You will connect functions to that queue in the next section,
    *Creating a queue-triggered function*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建一个新的存储帐户，并在该存储帐户中创建一个新队列。您将在下一节*创建队列触发的函数*中将函数连接到该队列。
- en: To begin, create a new storage account. Search for `storage accounts` in the
    Azure search bar and select Storage accounts:![Navigating to the storage account
    services through the Azure portal](img/B17338_14_19.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的存储帐户。在 Azure 搜索栏中搜索`storage accounts`并选择存储帐户：![通过 Azure 门户导航到存储帐户服务](img/B17338_14_19.jpg)
- en: 'Figure 14.19: Navigating to Storage accounts service through the Azure portal'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.19：通过 Azure 门户导航到存储帐户服务
- en: Click the + New button at the top to create a new storage account. Provide the
    details to create the storage account. The storage account name has to be globally
    unique, so consider adding your initials. It is recommended to create the storage
    account in the same region as your AKS cluster. Finally, to save on costs, you
    are recommended to downgrade the replication setting to Locally-redundant storage
    (LRS) as shown in *Figure 14.20*:![Providing resource group and storage account
    details to create the storage account ](img/B17338_14_20.jpg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的 + 新建按钮，创建一个新的存储帐户。提供创建存储帐户的详细信息。存储帐户名称必须是全局唯一的，因此可以考虑添加您的首字母。建议将存储帐户创建在与您的
    AKS 集群相同的区域。最后，为了节省成本，建议将复制设置降级为本地冗余存储（LRS），如*图 14.20*所示：![提供资源组和存储帐户详细信息以创建存储帐户](img/B17338_14_20.jpg)
- en: 'Figure 14.20: Providing the details to create the storage account'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.20：提供详细信息以创建存储帐户
- en: Once you're ready, click the Review + create button at the bottom. On the resulting
    screen, select Create to start the creation process.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 准备好后，点击底部的“审核 + 创建”按钮。在弹出的屏幕中，选择“创建”开始创建过程。
- en: It will take about a minute to create the storage account. Once it is created,
    open the account by clicking on the Go to resource button. In the Storage account
    pane, select Access keys in the left-hand navigation, click on Show keys, and
    copy the primary connection string, as shown in *Figure 14.21*. Note down this
    string for now:![Navigating to Access keys and copying the Connection string](img/B17338_14_21.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建存储账户大约需要一分钟。一旦创建完成，点击“转到资源”按钮打开该账户。在存储账户面板中，选择左侧导航栏中的“访问密钥”，点击“显示密钥”，并复制主连接字符串，如*图14.21*所示。暂时记下这个字符串：![访问密钥并复制连接字符串](img/B17338_14_21.jpg)
- en: 'Figure 14.21: Copying the primary connection string'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.21：复制主连接字符串
- en: Note
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For production use cases, it is not recommended to connect to Azure Storage
    using the access key. Any user with that access key has full access to the storage
    account and can read and delete all files on it. It is recommended to either generate
    a **shared access signatures** (**SAS**) token to connect to storage or to use
    Azure AD-integrated security. To learn more about SAS token authentication to
    storage, refer to https://docs.microsoft.com/rest/api/storageservices/delegate-access-with-shared-access-signature.
    To learn more about Azure AD authentication to Azure Storage, please refer to
    https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于生产用例，不建议使用访问密钥连接到Azure存储。任何拥有该访问密钥的用户都可以完全访问存储账户，并可以读取和删除其中的所有文件。建议生成**共享访问签名**（**SAS**）令牌来连接到存储，或使用Azure
    AD集成的安全性。要了解更多关于SAS令牌身份验证的信息，请参阅https://docs.microsoft.com/rest/api/storageservices/delegate-access-with-shared-access-signature。要了解更多关于Azure
    AD身份验证到Azure存储的信息，请参阅https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory。
- en: 'The final step is to create our queue in the storage account. Look for `queue`
    in the left-hand navigation, click the + Queue button to add a queue, and provide
    it with a name. To follow along with this demo, use `function` as the queue name:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是创建我们的队列存储账户。在左侧导航栏中查找`queue`，点击+ Queue按钮添加一个队列，并为其提供名称。为了跟随本演示，使用`function`作为队列名称：
- en: '![Creating a Queue service](img/B17338_14_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![创建队列服务](img/B17338_14_22.jpg)'
- en: 'Figure 14.22: Creating a new queue'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22：创建一个新队列
- en: You have now created a storage account in Azure and have its connection string.
    You created a queue in this storage account. In the next section, you will create
    a function that will consume messages from the queue.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在Azure中创建了一个存储账户，并且拥有了它的连接字符串。你还在该存储账户中创建了一个队列。在下一部分，你将创建一个函数来消费队列中的消息。
- en: Creating a queue-triggered function
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个队列触发的函数
- en: 'In the previous section, you created a queue in Azure. In this section, you
    will create a new function that will monitor this queue and remove messages from
    the queue. You will need to configure this function with the connection string
    to this queue:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，你已经在Azure中创建了一个队列。在本节中，你将创建一个新的函数来监视此队列并从队列中删除消息。你需要使用该队列的连接字符串来配置此函数：
- en: 'From within the VM, begin by creating a new directory and navigating to it:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟机中，首先创建一个新目录并导航到该目录：
- en: '[PRE24]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we can create the function. We will start with the initialization:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建函数了。我们将从初始化开始：
- en: '[PRE25]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will ask you two questions now. For the runtime, select node (option 2),
    and for the language, select JavaScript (option 1). This should result in the
    output shown in *Figure 14.23*:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，它将询问你两个问题。对于运行时，选择node（选项2），对于语言，选择JavaScript（选项1）。这应该会显示在*图14.23*中所示的输出：
- en: '![Creating a new javaScript function of type javaScript](img/B17338_14_23.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建一个新的JavaScript类型函数](img/B17338_14_23.jpg)'
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will ask you for a trigger. Select Azure Queue Storage trigger (option
    10). Give the name `js-queue` to the new function. This should result in the output
    shown in *Figure 14.24*:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将要求你选择一个触发器。选择Azure队列存储触发器（选项10）。为新的函数命名为`js-queue`。这应该会显示在*图14.24*中所示的输出：
- en: '![Creating a new function using the Azure Queue Storage trigger](img/B17338_14_24.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建一个使用Azure队列存储触发器的新函数](img/B17338_14_24.jpg)'
- en: 'Figure 14.24: Creating a queue-triggered function'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.24：创建一个队列触发的函数
- en: 'You will now need to make a couple of configuration changes. You need to provide
    the function you created the connection string on to Azure Storage and provide
    the queue name. First, open the `local.settings.json` file to configure the connection
    strings for storage:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要进行一些配置更改。你需要为你创建的函数提供连接字符串到Azure存储，并提供队列名称。首先，打开`local.settings.json`文件来配置存储的连接字符串：
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To make the changes, follow these instructions:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下步骤进行更改：
- en: Hit *I* to go into insert mode.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 *I* 进入插入模式。
- en: Replace the connection string for `AzureWebJobsStorage` with the connection
    string you copied earlier. Add a comma to the end of this line.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `AzureWebJobsStorage` 的连接字符串替换为您之前复制的连接字符串，并在该行末尾添加逗号。
- en: 'Add a new line and then add the following text on that line:'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一行并在该行中添加以下文本：
- en: '[PRE28]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result should look like *Figure 14.25*:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果应类似于 *图 14.25*：
- en: '![Editing the Queue connection string in the local.settings.json file ](img/B17338_14_25.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![编辑 local.settings.json 文件中的队列连接字符串](img/B17338_14_25.jpg)'
- en: 'Figure 14.25: Editing the local.settings.json file'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.25：编辑 local.settings.json 文件
- en: Save and close the file by hitting the *Esc* key, type `:wq!`, and then press
    *Enter*.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 *Esc* 键保存并关闭文件，输入 `:wq!`，然后按 *Enter*。
- en: 'The next file you need to edit is the function configuration itself. Here,
    you will refer to the connection string from earlier, and provide the queue name
    we chose in the *Creating a queue* section. To do that, use the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来需要编辑的文件是函数的配置文件。在此，您将引用之前的连接字符串，并提供我们在 *创建队列* 部分中选择的队列名称。为此，请使用以下命令：
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make the changes, follow these instructions:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下步骤进行更改：
- en: Hit *I* to go into insert mode.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 *I* 进入插入模式。
- en: Change the queue name to the name of the queue you created (`function`).
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将队列名称更改为您创建的队列的名称（`function`）。
- en: Next, add `QueueConnString` to the `connection` field.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将 `QueueConnString` 添加到 `connection` 字段中。
- en: 'Your configuration should now look like *Figure 14.26*:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的配置现在应该类似于 *图 14.26*：
- en: '![Editing the js-queue/function.json file](img/B17338_14_26.jpg)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![编辑 js-queue/function.json 文件](img/B17338_14_26.jpg)'
- en: 'Figure 14.26: Editing the js-queue/function.json file'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.26：编辑 js-queue/function.json 文件
- en: Save and close the file by hitting the *Esc* key, type `:wq!`, and then press *Enter*.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 *Esc* 键保存并关闭文件，输入 `:wq!`，然后按 *Enter*。
- en: 'You are now ready to publish your function to Kubernetes. You will start by
    setting up KEDA on your Kubernetes cluster:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已准备好将函数发布到 Kubernetes。首先，您需要在 Kubernetes 集群上设置 KEDA：
- en: '[PRE30]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should return an output similar to *Figure 14.27*:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应返回类似于 *图 14.27* 的输出：
- en: '![Setting up KEDA on your Kubernetes cluster](img/B17338_14_27.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![在 Kubernetes 集群上设置 KEDA](img/B17338_14_27.jpg)'
- en: '[PRE31]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This should return an output similar to *Figure 14.28*:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应返回类似于 *图 14.28* 的输出：
- en: '![Ensuring that the KEDA pod is running in the keda namespace](img/B17338_14_28.jpg)'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![确保 KEDA Pod 正在 keda 命名空间中运行](img/B17338_14_28.jpg)'
- en: 'Figure 14.28: Verifying the KEDA installation succeeded'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.28：验证 KEDA 安装是否成功
- en: 'You can now deploy the function to Kubernetes. You will configure KEDA to look
    at the number of queue messages every 5 seconds (`polling-interval=5`) to have
    a maximum of 15 replicas (`max-replicas=15`), and to wait 15 seconds before removing
    pods (`cooldown-period=15`). To deploy and configure KEDA in this way, use the
    following command:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以将函数部署到 Kubernetes。您将配置 KEDA 每 5 秒查看一次队列消息的数量（`polling-interval=5`），最多允许
    15 个副本（`max-replicas=15`），并在移除 Pod 前等待 15 秒（`cooldown-period=15`）。要以这种方式部署和配置
    KEDA，请使用以下命令：
- en: '[PRE32]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will return an output similar to *Figure 14.29*:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回类似于 *图 14.29* 的输出：
- en: '![Deploying the queue-triggered function](img/B17338_14_29.jpg)'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![部署队列触发的函数](img/B17338_14_29.jpg)'
- en: '[PRE33]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will show you all the resources that were deployed. As you can see in
    *Figure 14.30*, this setup created a deployment, ReplicaSet, and an HPA. In the
    HPA, you should see that there are no replicas currently running:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将展示您已部署的所有资源。如 *图 14.30* 所示，设置过程中创建了部署、ReplicaSet 和 HPA。在 HPA 中，您应该看到当前没有副本在运行：
- en: '![Verifying that the setup created a deployment, a ReplicaSet, and an HPA](img/B17338_14_30.jpg)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![验证设置是否已创建部署、ReplicaSet 和 HPA](img/B17338_14_30.jpg)'
- en: 'Figure 14.30: Verifying the objects created by the setup'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.30：验证设置创建的对象
- en: 'Now you will create a message in the queue to trigger KEDA and create a pod.
    To see the scaling event, run the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将创建一条消息以触发 KEDA 并创建一个 Pod。要查看扩展事件，运行以下命令：
- en: '[PRE34]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To create a message in the queue, we are going to use the Azure portal. To
    create a new message, open the queue in the storage that you created earlier.
    Click on the + Add message button at the top of your screen, create a test message,
    and click on OK. This is shown in *Figure 14.31*:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在队列中创建一条消息，我们将使用 Azure 门户。打开您之前创建的存储中的队列，点击屏幕顶部的 + 添加消息按钮，创建一条测试消息，然后点击 OK。如
    *图 14.31* 所示：
- en: '![Adding a message to the queue](img/B17338_14_31.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![向队列添加消息](img/B17338_14_31.jpg)'
- en: 'Figure 14.31: Adding a message to the queue'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.31：向队列添加消息
- en: 'After creating this message, have a look at the output of the previous command
    you issued. It might take a couple of seconds, but soon enough, your HPA should
    scale to one replica. Afterward, it should also scale back down to zero replicas:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完这条消息后，查看你之前执行的命令的输出。可能需要几秒钟，但很快，你的HPA应该会扩展到一个副本。之后，它还应该会缩减回零副本：
- en: '![KEDA scaling from 0 to 1 and back to 0 replicas](img/B17338_14_32.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![KEDA从0扩展到1，再缩减回0副本](img/B17338_14_32.jpg)'
- en: 'Figure 14.32: KEDA scaling from 0 to 1 and back to 0 replicas'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.32：KEDA从0扩展到1，再缩减回0副本
- en: This has shown you that KEDA enabled the Kubernetes HPA to scale from zero to
    one pod when there are messages in the queue, and also from one to zero pods when
    those messages are processed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这向你展示了KEDA如何使Kubernetes HPA在队列中有消息时从零扩展到一个Pod，当这些消息被处理后，又从一个Pod缩减到零Pod。
- en: You have now created a function that is triggered by messages being added to
    a queue. You were able to verify that KEDA scaled the pods from 0 to 1 when you
    created a message in the queue, and back down to 0 when there were no messages
    left. In the next section, you will execute a scale test, and you will create
    multiple messages in the queue and see how the functions react.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经创建了一个由队列中添加的消息触发的函数。你已经验证了，当你在队列中创建消息时，KEDA将Pod从0扩展到1，而当队列中没有消息时，它又会缩减回0。在下一部分，你将执行扩展测试，创建多个消息到队列中，观察函数如何反应。
- en: Scale testing functions
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展测试功能
- en: 'In the previous section, you saw how functions reacted when there was a single
    message in the queue. In this example, you are going to send 1,000 messages into
    the queue and see how KEDA will first scale out the function, and then scale back
    in, and eventually scale back down to zero:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，你看到了当队列中有一条消息时，函数是如何反应的。在这个示例中，你将向队列发送1,000条消息，看看KEDA是如何首先扩展函数，然后再缩减，并最终缩减回零的：
- en: 'In the current Cloud Shell, watch the HPA using the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前的Cloud Shell中，使用以下命令观察HPA：
- en: '[PRE35]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To start pushing the messages, you are going to open a new Cloud Shell session.
    To open a new session, select the Open new session button in Cloud Shell:![Opening
    a new Cloud Shell instance](img/B17338_14_33.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始推送消息，你需要打开一个新的Cloud Shell会话。要打开新会话，在Cloud Shell中选择“Open new session”按钮：![打开一个新的Cloud
    Shell实例](img/B17338_14_33.jpg)
- en: '[PRE36]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once that is installed, you will need to provide this script with your storage
    account connection string. To do this, open the file using:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完毕后，你需要为这个脚本提供你的存储帐户连接字符串。为此，使用以下命令打开文件：
- en: '[PRE37]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Edit the storage connection string on *line 8* to your connection string:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑*第8行*中的存储连接字符串为你的连接字符串：
- en: '![Pasting in your connection string for your storage account on line 8](img/B17338_14_34.jpg)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![在第8行粘贴你的存储帐户连接字符串](img/B17338_14_34.jpg)'
- en: 'Figure 14.34: Pasting in your connection string for your storage account on
    line 8'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.34：在第8行粘贴你的存储帐户连接字符串
- en: 'Once you have pasted in your connection string, you can execute the Python
    script and send 1,000 messages to your queue:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你粘贴了连接字符串，你可以执行Python脚本并向队列发送1,000条消息：
- en: '[PRE38]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While the messages are being sent, switch back to the previous Cloud Shell instance
    and watch KEDA scale from 0 to 1, and then watch the HPA scale to the number of
    replicas. The HPA uses metrics provided by KEDA to make scaling decisions. Kubernetes,
    by default, doesn't know about the number of messages in an Azure storage queue
    that KEDA provides to the HPA.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在消息发送的过程中，切换回之前的Cloud Shell实例，观察KEDA从0扩展到1，然后观察HPA扩展到副本数。HPA使用KEDA提供的度量数据来做出扩展决策。Kubernetes默认情况下不知道KEDA提供给HPA的Azure存储队列中消息的数量。
- en: Note
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on how quickly KEDA in your cluster scales up the application, your
    deployment might not scale to the 15 replicas that are shown in *Figure 14.29*.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你集群中KEDA扩展应用的速度，你的部署可能无法扩展到*图14.29*中显示的15个副本。
- en: 'Once the queue is empty, KEDA will scale back down to zero replicas:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦队列为空，KEDA将再次缩减回零副本：
- en: '![KEDA will scale from 0 to 1, and the HPA will scale to 15 pods . When the
    load has decreased, KEDA scaled down to 0 again](img/B17338_14_35.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![KEDA将从0扩展到1，而HPA将扩展到15个Pod。当负载减少时，KEDA将再次缩减到0](img/B17338_14_35.jpg)'
- en: 'Figure 14.35: KEDA will scale from 0 to 1, and the HPA will scale to 15 pods'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.35：KEDA将从0扩展到1，而HPA将扩展到15个Pod
- en: As you can see in the output of this command, the deployment was scaled first
    from zero to one replica, and then gradually got scaled out to a maximum of 15
    replicas. When there were no more messages in the queue, the deployment was scaled
    down again to zero replicas.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在该命令输出中所看到的，部署首先从零扩展到一个副本，然后逐渐扩展到最多 15 个副本。当队列中没有更多消息时，部署又缩减回零副本。
- en: 'This concludes the examples of running serverless functions on top of Kubernetes.
    Let''s make sure to clean up the objects that were created. Run the following
    command from within the VM you created (the final step will delete this VM; if
    you want to keep the VM, don''t run the final step):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了在 Kubernetes 上运行无服务器函数的示例。让我们确保清理已创建的对象。请在你创建的虚拟机中运行以下命令（最后一步会删除该虚拟机；如果你希望保留虚拟机，请不要运行最后一步）：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this section, you ran a function that was triggered by messages in a storage
    queue on top of Kubernetes. You used a component called KEDA to achieve scaling
    based on the number of queue messages. You saw how KEDA can scale from 0 to 1
    and back down to 0\. You also saw how the HPA can use metrics provided by KEDA
    to scale out a deployment.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你运行了一个由存储队列中的消息触发的函数，运行在 Kubernetes 上。你使用了一个名为 KEDA 的组件来根据队列消息的数量实现扩展。你看到了
    KEDA 如何从 0 扩展到 1，然后再缩减回 0。你还看到了 HPA 如何使用 KEDA 提供的指标来扩展部署。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you deployed serverless functions on top of your Kubernetes
    cluster. To achieve this, you first created a VM and an ACR.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你在 Kubernetes 集群上部署了无服务器函数。为此，你首先创建了一个虚拟机和一个 ACR。
- en: You started the functions deployments by deploying a function that used an HTTP
    trigger. The Azure Functions core tools were used to create that function and
    to deploy it to Kubernetes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过部署一个使用 HTTP 触发器的函数启动了函数部署。使用 Azure Functions 核心工具来创建该函数并将其部署到 Kubernetes。
- en: Afterward, you installed an additional component on your Kubernetes cluster
    called KEDA. KEDA allows serverless scaling in Kubernetes. It allows deployments
    to and from zero pods, and it also provides additional metrics to the HPA. You
    used a function that was triggered on messages in an Azure storage queue.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，你在 Kubernetes 集群上安装了一个名为 KEDA 的额外组件。KEDA 允许在 Kubernetes 中进行无服务器扩展。它允许部署从零个
    Pod 到任意数量的 Pod，并且还向 HPA 提供了额外的指标。你使用了一个在 Azure 存储队列中消息触发的函数。
- en: In the next – and final – chapter of this book, you'll learn how to integrate
    containers and Kubernetes in a **continuous integration and continuous delivery**
    (**CI/CD**) pipeline using GitHub Actions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一个也是最后一章中，你将学习如何使用 GitHub Actions 在 **持续集成和持续交付** (**CI/CD**) 流水线中集成容器和
    Kubernetes。
