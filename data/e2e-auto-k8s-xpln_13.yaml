- en: '*Chapter 10*: Onboarding Applications with Crossplane'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用Crossplane进行应用程序引导'
- en: This will be a fully hands-on chapter where we will look at the end-to-end automation
    of an application and all its dependencies. The dependencies will involve the
    setup of the project repository, creating the **Continuous Integration and Continuous
    Deployment** (**CI/CD**) pipelines, dependent infrastructure resources, and so
    on. You will see the real power of how Crossplane can automate every possible
    step, starting from the initial repository setup. We will go through the hands-on
    journey from the perspective of three different personas. The three personas are
    the platform developer creating the required XR/claim APIs, the application operator
    configuring the application deployment using the XR/claim, and the developer contributing
    to the application development. The platform developer persona is the key to the
    whole journey, so most of the content in this chapter will be from their perspective.
    Whenever required, we will explicitly mention the other personas. The hands-on
    journey will cover application, services, and infrastructure, all three aspects
    of automation with Crossplane.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将是一个完全动手实践的章节，我们将探讨一个应用程序及其所有依赖项的端到端自动化。依赖项将涉及项目仓库的设置、创建**持续集成与持续部署**（**CI/CD**）流水线、相关基础设施资源等。你将看到Crossplane如何在从初始仓库设置开始的每一个可能步骤中，展现出它的真正力量。我们将从三个不同角色的视角出发，进行这段动手实践的旅程。三种角色分别是：创建所需XR/claim
    API的**平台开发者**，使用XR/claim配置应用程序部署的应用程序运维人员，以及参与应用程序开发的开发者。平台开发者角色是整个过程的关键，因此本章的大部分内容将从他们的视角展开。每当需要时，我们会明确提到其他角色。整个动手实践旅程将涵盖应用程序、服务和基础设施，三方面的Crossplane自动化内容。
- en: 'The following are the topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主题：
- en: The automation requirements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化需求
- en: The solution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案
- en: Preparing the control plane
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备控制平面
- en: Automating the application deployment environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化应用程序部署环境
- en: The repository and CI setup
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库和CI设置
- en: The deployment dependencies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署依赖关系
- en: API boundary analysis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API边界分析
- en: We will start with the requirement from the product team to explore the ways
    to automate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从产品团队的需求开始，探索自动化的方式。
- en: The automation requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化需求
- en: 'We will start our high-level requirement story from the perspective of an imaginary
    organization, *X*. They are planning to develop a new e-commerce website named
    `product-a`. It has many modules, each functional at a different time in the customer
    journey, for example, cart, payment, and customer support. Each model requires
    independent release and scaling capabilities while sharing a standard website
    theme and a unified experience. The product architecture group has recommended
    micro-frontend architecture with separate deployment for each module in Kubernetes.
    They also suggested that an individual team will develop the website framework,
    shared UI components, and cross-cutting concerns in the form of a library. The
    independent module team can use these dependent libraries to build their features.
    The product team has recently heard about Crossplane and its ability to automate
    the applications from end to end. They wanted to use the opportunity of developing
    a greenfield product and experiment with Crossplane to set up a high-velocity,
    reliable product development practice. They have reached the platform team, requesting
    help to develop a **proof of concept** (**POC**). The POC project will be the
    scope of our hands-on journey in this chapter. The following diagram represents
    what the product development team wanted to achieve:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个假想组织*X*的角度，开始讲述我们的高层需求故事。他们计划开发一个名为`product-a`的新电子商务网站。该网站包含多个模块，每个模块在客户旅程中的不同时间点发挥作用，例如购物车、支付和客户支持。每个模块都需要独立发布和扩展的能力，同时共享一个标准的网站主题和统一的用户体验。产品架构小组推荐了微前端架构，并为每个模块在Kubernetes中进行独立部署。他们还建议由一个独立的团队开发网站框架、共享UI组件以及跨领域的关切点，形式为库。独立的模块团队可以使用这些依赖库来构建他们的功能。产品团队最近听说了Crossplane及其能够实现端到端自动化应用程序的能力。他们希望借着开发一个全新产品的机会，尝试使用Crossplane来设置一个高效、可靠的产品开发实践。他们已联系平台团队，请求帮助开发**概念验证**（**POC**）。POC项目将是我们本章动手实践旅程的范围。下图表示了产品开发团队希望实现的目标：
- en: '![Figure 10.1 – Product team requirements'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 产品团队需求'
- en: '](img/B17830_10_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_01.jpg)'
- en: Figure 10.1 – Product team requirements
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 产品团队需求
- en: Information
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Please note that both the requirements and solutions discussed in the chapter
    are not exhaustive. Our attempt here is to look for ways to approach automation
    from end to end, covering the entire application life cycle and its dependencies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章讨论的要求和解决方案并不全面。我们的尝试是寻找一种端到端自动化的方式，涵盖整个应用生命周期及其依赖项。
- en: The following section explores one possible solution option from the perspective
    of a platform engineer using Crossplane.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分从平台工程师使用 Crossplane 的角度探讨一种可能的解决方案选项。
- en: The solution
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We will approach the solution in three steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三步进行解决方案：
- en: First, we will completely automate the `product-a` deployment environment provisioning
    (Kubernetes) and cross-cutting concern setups to support all the micro-frontend
    deployment.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将完全自动化 `product-a` 部署环境的配置（Kubernetes）和跨切关注设置，以支持所有微前端的部署。
- en: Next will be the application onboarding, which covers steps such as new repository
    creation and setting up the CI pipeline for a specific micro-frontend.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是应用程序的引导过程，包括创建新仓库和为特定微前端设置 CI 流水线等步骤。
- en: The final step will be to set up the CD pipeline and dependent infrastructures
    (database) provisioning for the micro-frontend for which the repository is created.
    We will do this using a set of providers, such as Helm, GitLab, GCP, and Kubernetes.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的步骤是设置 CD 流水线并为微前端配置相关的基础设施（数据库）。我们将使用一组提供者，例如 Helm、GitLab、GCP 和 Kubernetes
    来完成此操作。
- en: Information
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: We will create a template GitLab project with the dependent library and kick-start
    the micro-frontend development using a repository cloned from the base template
    repository.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建一个模板 GitLab 项目，包含相关依赖库，并使用从基础模板库克隆的仓库启动微前端开发。
- en: 'The following diagram represents the complete solution:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示表示完整的解决方案：
- en: '![Figure 10.2 – High-level solution view'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 高级解决方案视图'
- en: '](img/B17830_10_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_02.jpg)'
- en: Figure 10.2 – High-level solution view
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 高级解决方案视图
- en: 'The following stages cover the high-level solution in the preceding diagram
    in a bit more detail:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下阶段将更加详细地描述前面图示中的高级解决方案：
- en: '**Stage 1**: The first stage will be to get the Crossplane control plane ready
    with the required providers (GCP, Helm, Kubernetes, and GitLab) and configurations.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段 1**：第一阶段将准备好 Crossplane 控制平面，配置所需的提供者（GCP、Helm、Kubernetes 和 GitLab）。'
- en: '`product-a` cluster. The Helm provider configuration helps to set up Argo CD
    in the `product-a` cluster. The Kubernetes provider configuration will help deploy
    micro-frontend applications into the `product-a` cluster.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-a` 集群。Helm 提供者配置有助于在 `product-a` 集群中设置 Argo CD。Kubernetes 提供者配置将有助于将微前端应用部署到
    `product-a` 集群中。'
- en: '**Stage 3**: The third stage is relevant to every micro-frontend application
    in the product. This step will create a new repository for the micro-frontend
    from the template repository. While creating the new repository, we will also
    clone the CI pipeline.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段 3**：第三阶段适用于产品中的每个微前端应用程序。此步骤将从模板仓库创建微前端的新仓库。在创建新仓库时，我们还将克隆 CI 流水线。'
- en: '**Stage 4**: The final stage will be to set the CD for the created repository
    using the Kubernetes provider. The Kubernetes provider configuration created in
    stage 2 will be used here. The stage will also create the cloud database instance
    required by the submodule/micro-frontend.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段 4**：最后阶段将使用 Kubernetes 提供者设置已创建仓库的 CD。第二阶段创建的 Kubernetes 提供者配置将在此处使用。此阶段还将创建子模块/微前端所需的云数据库实例。'
- en: The rest of the chapter will investigate details of how we configure Crossplane
    and implement the solution discussed. The following section will deep dive into
    the control plan setup required to implement the use case.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将探讨如何配置 Crossplane 并实施所讨论的解决方案。以下部分将深入分析实现用例所需的控制平面设置。
- en: Information
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The complete example is available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter10/Hands-on-example](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter10/Hands-on-example).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可以在 [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter10/Hands-on-example](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter10/Hands-on-example)
    查看。
- en: Preparing the control plane
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备控制平面
- en: This is the stage to install the required components into the Crossplane cluster.
    We will establish the necessary providers and respective configurations. The first
    step will be to install the GCP provider.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将所需组件安装到 Crossplane 集群中的阶段。我们将建立必要的提供者及其配置。第一步是安装 GCP 提供者。
- en: The GCP provider
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GCP 提供者
- en: 'This is the same step we took in [*Chapter 3*](B17830_03_ePub.xhtml#_idTextAnchor039),
    *Automating Infrastructure with Crossplane*, but slightly deviating from it. We
    will differ in how we create and use the GCP provider configuration. It is good
    to have an individual provider configuration for each product team to enhance
    security, auditing, policy compliance, governance, and so on in using the XR/claim
    APIs. Each product team and platform team should create a different provider configuration
    referring to a separate GCP service account secret. The provider configurations
    will be named against the product (`product-a`), and a new namespace will be created
    with the same name. The compositions will be developed in such a way to refer
    to the provider configuration based on the claim namespace dynamically. It is
    one of the multi-tenancy patterns we discussed in [*Chapter 7*](B17830_07_ePub.xhtml#_idTextAnchor109),
    *Extending and Scaling Crossplane*. To finish the GCP setup, do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在[*第 3 章*](B17830_03_ePub.xhtml#_idTextAnchor039)《*通过 Crossplane 自动化基础设施*》中采取的相同步骤，但有所偏差。我们将在创建和使用
    GCP 提供者配置的方式上有所不同。为每个产品团队创建独立的提供者配置有助于增强安全性、审计、政策合规性、治理等方面，特别是在使用 XR/claim API
    时。每个产品团队和平台团队都应该创建一个不同的提供者配置，引用一个单独的 GCP 服务账户 Secret。这些提供者配置将以产品名（`product-a`）命名，并且会创建一个同名的新命名空间。组合将以动态方式参考基于声明命名空间的提供者配置。这是我们在[*第
    7 章*](B17830_07_ePub.xhtml#_idTextAnchor109)《*扩展和扩展 Crossplane*》中讨论的多租户模式之一。要完成
    GCP 设置，执行以下操作：
- en: Execute `GCP-Provider.yaml` to install the provider. Wait until the provider
    pods are up and running.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `GCP-Provider.yaml` 来安装提供者，等待提供者 Pods 启动并运行。
- en: Meanwhile, ensure that the Kubernetes Secret with the `product-a` GCP service
    account is available in the cluster. This Secret will be referred to in the provider
    configuration. To remind yourself of the steps to make the Secret, refer to the
    *Configure the provider* section in [*Chapter 3*](B17830_03_ePub.xhtml#_idTextAnchor039).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，确保集群中有 `product-a` GCP 服务账户的 Kubernetes Secret。该 Secret 将在提供者配置中引用。提醒自己如何创建该
    Secret，请参阅[*第 3 章*](B17830_03_ePub.xhtml#_idTextAnchor039)中的《*配置提供者*》部分。
- en: Once you have the Secret available, execute `Provider-Config.yaml` to create
    the product-specific provider configuration. Note that the name of the provider
    configuration is `product-a`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你拥有 Secret，执行 `Provider-Config.yaml` 来创建产品特定的提供者配置。注意，提供者配置的名称为 `product-a`。
- en: Finally, apply `namespace.yaml` to create the `product-a` namespace. It is an
    additional step to hold `Claim` objects.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，应用 `namespace.yaml` 来创建 `product-a` 命名空间。这是一个额外步骤，用于保存 `Claim` 对象。
- en: The preceding steps will ensure that the GCP provider is fully set. In the following
    section, we will look at the GitLab provider.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤将确保 GCP 提供者已经完全设置。接下来的部分将介绍 GitLab 提供者。
- en: The GitLab provider
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab 提供者
- en: 'We will use the GitLab provider to manage the micro-frontend repository and
    CI pipeline. The free account provided by GitLab is good enough to continue with
    our experiment. The provider setup is done in three steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GitLab 提供者来管理微前端仓库和 CI 流水线。GitLab 提供的免费账户足以继续我们的实验。提供者设置分为三步：
- en: '**GitLab credentials**: We need to create the GitLab access token as a Kubernetes
    Secret. It will be referred to in the GitLab provider configuration. Generate
    a GitLab access token in the GitLab UI user setting. Use the following command
    to create the Secret:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GitLab 凭证**：我们需要将 GitLab 访问令牌创建为 Kubernetes Secret，并在 GitLab 提供者配置中引用它。你可以在
    GitLab UI 用户设置中生成 GitLab 访问令牌。使用以下命令来创建 Secret：'
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`provider-gitlab.yaml` to install the GitLab provider and wait until the pods
    are up and running.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `provider-gitlab.yaml` 安装 GitLab 提供者，并等待 Pods 启动并运行。
- en: '`provider-config.yaml` to create the provider configuration. Again, it will
    be specific to the product with the name `product-a`.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `provider-config.yaml` 创建提供者配置。再次强调，它将是特定于产品的，名称为 `product-a`。
- en: We are done with the GitLab provider setup. The following section will look
    at the Helm and Kubernetes provider setup.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 GitLab 提供者的设置。接下来将介绍 Helm 和 Kubernetes 提供者的设置。
- en: Helm and Kubernetes provider setup
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 和 Kubernetes 提供者设置
- en: 'Both the Helm and Kubernetes providers are helpful to configure a remote or
    the same Kubernetes cluster. It is the remote Kubernetes cluster created for `product-a`
    in our case. Both providers require credentials to access the remote cluster.
    The product-specific provider configuration will be created automatically for
    the remote cluster when we provision the cluster with our XR API. We will look
    at more details on this in the next section. We will only install the provider
    for now. Execute `Helm-Provider.yaml` and `k8s-Provider.yaml` to install the providers.
    Refer to the following screenshot showing the installation of all providers and
    respective configuration setup:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 和 Kubernetes 提供程序有助于配置远程或相同的 Kubernetes 集群。对于我们的案例，它是为 `product-a` 创建的远程
    Kubernetes 集群。这两个提供程序都需要凭证来访问远程集群。当我们使用 XR API 配置集群时，产品特定的提供程序配置将自动为远程集群创建。我们将在下一节中查看更多细节。现在我们只需要安装提供程序。执行
    `Helm-Provider.yaml` 和 `k8s-Provider.yaml` 来安装提供程序。请参阅以下截图，展示了所有提供程序及其相应的配置设置：
- en: '![Figure 10.3 – Provider setup'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 提供程序设置'
- en: '](img/B17830_10_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_03.jpg)'
- en: Figure 10.3 – Provider setup
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 提供程序设置
- en: 'To run the setup yourself, use the following commands:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要自己运行设置，请使用以下命令：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This takes us to the end of configuring the Crossplane control plane. All these
    activities are meant to be done by the platform team. In the following section,
    we will deep dive into setting up a remote Kubernetes cluster as a deployment
    environment for `product-a`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步骤完成了 Crossplane 控制平面的配置。所有这些活动都将由平台团队完成。在接下来的部分，我们将深入探讨如何将远程 Kubernetes 集群设置为
    `product-a` 的部署环境。
- en: Automating the application deployment environment
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化应用程序部署环境
- en: 'The complete Kubernetes cluster creation and configuring of the cross-cutting
    concerns will be automated using this step. We will develop an XR/claim API, which
    does the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Kubernetes 集群创建以及跨领域问题的配置将通过此步骤实现自动化。我们将开发一个 XR/claim API，它执行以下操作：
- en: Provisions a remote GKE cluster
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置一个远程 GKE 集群
- en: Sets up Helm and the Kubernetes provider configuration for the GKE cluster
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Helm 和 Kubernetes 提供程序配置以配置 GKE 集群
- en: Installs Argo CD using the Helm provider into the `product-a` GKE cluster
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Helm 提供程序将 Argo CD 安装到 `product-a` GKE 集群
- en: 'Let’s look at the XRD and composition to understand the API in detail (refer
    to the XRD and composition in the book’s GitHub repository). We will capture two
    mandatory parameters (node count and machine size). The `size` parameter takes
    either `BIG` or `SMALL` as an enum value. Inside the composition, we have composed
    five resources. The following is the list of resources and their purpose:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 XRD 和组合，详细了解 API（请参阅书籍 GitHub 仓库中的 XRD 和组合）。我们将捕获两个必需的参数（节点数量和机器大小）。`size`
    参数的枚举值为 `BIG` 或 `SMALL`。在组合内部，我们编排了五个资源。以下是资源列表及其用途：
- en: '**Cluster and NodePool**: Cluster and NodePool are two relevant resources responsible
    for GKE cluster provisioning. It is very similar to the way we provisioned GKE
    in [*Chapter 5*](B17830_05_ePub.xhtml#_idTextAnchor074), *Extending Providers*.
    The node count and the machine type will be patched into the node pool. The node
    pool is again referred to inside the cluster. Both resources will refer to the
    GCP provider configuration dynamically using the claim namespace. Also, the Secret
    required to connect to the GKE cluster is stored in the claim namespace. Refer
    to the following code snippet on the patching operation in the cluster resource:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群和节点池**：集群和节点池是负责 GKE 集群配置的两个相关资源。它们与我们在[*第 5 章*](B17830_05_ePub.xhtml#_idTextAnchor074)中配置
    GKE 的方式非常相似，*扩展提供程序*。节点数量和机器类型将被打补丁到节点池中。节点池再次在集群内被引用。两个资源都将动态引用 GCP 提供程序配置，使用声明命名空间。同时，连接到
    GKE 集群所需的密钥存储在声明命名空间中。请参阅以下代码片段，了解集群资源中的打补丁操作：'
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Helm and Kubernetes ProviderConfig**: As the cluster is ready, it’s time
    to create the Helm and Kubernetes provider configuration. The provider configuration
    will refer to the newly created cluster Secret. Another critical point is defining
    the readiness check as none, as ProviderConfig is not an external resource. Failing
    to do so will not allow the XR/claim to become ready. Refer to the following code
    snippet:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm 和 Kubernetes ProviderConfig**：集群准备好后，是时候创建 Helm 和 Kubernetes 提供程序配置了。提供程序配置将引用新创建的集群密钥。另一个关键点是将就绪检查定义为
    none，因为 ProviderConfig 不是外部资源。如果未执行此操作，XR/claim 将无法变为就绪状态。请参阅以下代码片段：'
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Install Argo CD**: We will install Argo CD into the cluster using the Helm
    provider. Again, the provider configuration will be referred to dynamically with
    a predictable naming strategy. Argo CD is designed to enable CD for the micro-frontend
    repositories.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 Argo CD**：我们将使用 Helm 提供者将 Argo CD 安装到集群中。同样，提供者配置将通过可预测的命名策略动态引用。Argo
    CD 旨在为微前端仓库提供持续交付（CD）支持。'
- en: Information
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: Note that the cluster creation XR/claim API example discussed here is not production
    ready. You should be installing other cross-cutting concerns using the Helm or
    Kubernetes provider. Also, we missed many fine-grained cluster configurations.
    Refer to [https://github.com/upbound/platform-ref-gcp](https://github.com/upbound/platform-ref-gcp)
    for a more detailed cluster configuration.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这里讨论的集群创建 XR/声明 API 示例并非生产就绪。你应该使用 Helm 或 Kubernetes 提供者安装其他横向关注点。此外，我们错过了许多细粒度的集群配置。欲了解更详细的集群配置，请参考
    [https://github.com/upbound/platform-ref-gcp](https://github.com/upbound/platform-ref-gcp)。
- en: 'To establish and validate our cluster API into the control plane, execute the
    following commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的集群 API 集成并验证到控制平面中，请执行以下命令：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The platform team that manages the control plane will do the preceding operations.
    Refer to the following screenshot where the APIs are established:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 管理控制平面的平台团队将执行上述操作。请参考以下截图，查看 API 的建立情况：
- en: '![Figure 10.4 – Cluster API'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – 集群 API'
- en: '](img/B17830_10_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_04.jpg)'
- en: Figure 10.4 – Cluster API
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 集群 API
- en: 'As a next step, the application operator close to the product team can create
    the cluster using a claim configuration. The application operator will create
    a GKE cluster with the name `product-a` using the following commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，接近产品团队的应用操作员可以使用声明配置创建集群。应用操作员将使用以下命令创建名为 `product-a` 的 GKE 集群：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Refer to the following screenshot where the GKE cluster and Helm releases are
    established:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图，其中展示了 GKE 集群和 Helm 发布的建立情况：
- en: '![Figure 10.5 – Cluster claim'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 集群声明'
- en: '](img/B17830_10_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_05.jpg)'
- en: Figure 10.5 – Cluster claim
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 集群声明
- en: We are all good with the cluster creation. We will discuss the next stage to
    onboard the micro-frontend repository in the following section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 集群创建一切正常。我们将在接下来的章节中讨论将微前端仓库接入的下一阶段。
- en: The repository and CI setup
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库和 CI 设置
- en: At this stage, an XR/claim is developed to clone the template repository to
    create the new micro-frontend repository and CI pipeline. We can do this in two
    steps. First, we will configure GitLab, and then we’ll develop an XR/claim API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们开发 XR/声明 API 来克隆模板仓库，创建新的微前端仓库和 CI 管道。我们可以分两步来完成。首先，我们将配置 GitLab，然后开发
    XR/声明 API。
- en: GitLab configuration
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab 配置
- en: 'We need to make the following one-time configurations in GitLab before we start
    the XR/claim API development:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 XR/声明 API 开发之前，我们需要在 GitLab 中进行以下一次性配置：
- en: '**Create the template project**: We need to have a template repository from
    which we will make a new micro-frontend repository. You can access the template
    repository I have created at [https://gitlab.com/unified.devops/react-template](https://gitlab.com/unified.devops/react-template).
    The repository has a GitLab pipeline set up to build and push the Docker image
    into the Docker Hub registry. You can also set up a private registry here. We
    will automatically get the template project structure and CI set up while we clone
    the template repository for a micro-frontend. The Docker image name will be chosen
    based on the micro-frontend repository name.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建模板项目**：我们需要一个模板仓库，从中创建一个新的微前端仓库。你可以访问我创建的模板仓库，链接为[https://gitlab.com/unified.devops/react-template](https://gitlab.com/unified.devops/react-template)。该仓库已设置
    GitLab 管道，用于构建并推送 Docker 镜像到 Docker Hub 注册表。你也可以在此处设置私有注册表。我们在克隆模板仓库创建微前端时，会自动获得模板项目结构和
    CI 设置。Docker 镜像名称将根据微前端仓库的名称来选择。'
- en: '**Group for product-a**: We will keep all micro-frontend repositories in a
    single GitLab group to keep it organized, manage user permissions, and maintain
    environment variables for a CI pipeline. You can access the group I have created
    at [https://gitlab.com/unified-devops-project-x](https://gitlab.com/unified-devops-project-x).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**product-a 的组**：我们将在一个 GitLab 组中管理所有微前端仓库，以保持组织结构，管理用户权限，并为 CI 管道维护环境变量。你可以访问我创建的该组，链接为
    [https://gitlab.com/unified-devops-project-x](https://gitlab.com/unified-devops-project-x)。'
- en: '`REG_USER` and `REG_PASSWORD` with your Docker Hub credentials, as shown in
    the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的 Docker Hub 凭证填写 `REG_USER` 和 `REG_PASSWORD`，如以下截图所示：
- en: '![Figure 10.6 – CI Docker Hub variables'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – CI Docker Hub 变量'
- en: '](img/B17830_10_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_06.jpg)'
- en: Figure 10.6 – CI Docker Hub variables
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – CI Docker Hub 变量
- en: Tip
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the group creation and user onboarding into the group can be automated.
    Considering doing that with Crossplane. An example of this is available at [https://github.com/crossplane-contrib/provider-gitlab/tree/master/examples/groups](https://github.com/crossplane-contrib/provider-gitlab/tree/master/examples/groups).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，组创建和用户引导到组的过程可以自动化。考虑使用 Crossplane 实现这一点。此操作的示例可在 [https://github.com/crossplane-contrib/provider-gitlab/tree/master/examples/groups](https://github.com/crossplane-contrib/provider-gitlab/tree/master/examples/groups)
    中找到。
- en: We have all the components to develop our project onboarding XR/claim API. The
    following section will look at the details of the onboarding API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有开发项目引导 XR/声明 API 所需的所有组件。接下来的部分将详细介绍引导 API 的内容。
- en: The onboarding XR/claim API
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导 XR/声明 API
- en: 'If we look at the XRD (`gitproject-xrd.yaml`), we take in two parameters as
    inputs. The template’s name refers to the template repository from which we should
    be cloning, and the group ID will determine the GitLab group under which the repository
    will be created. You can get the group ID from the GitLab group details page or
    group settings page. These two parameters make the API generic, so it can be used
    across the organization. The newly created micro-frontend repo URL and an access
    token to work with the repository will be stored as connection Secrets. We can
    use these with Argo CD to read the repo. Our example doesn’t require the access
    token as the repository is public. It will be a simple composition to map the
    template name with a template URL, clone the repository into the specified group,
    and copy back the repository details into the Secret. The repository’s name will
    be referred to from the name of the claim object. To establish and validate the
    onboarding API into the control plane, execute the following commands:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 XRD（`gitproject-xrd.yaml`），我们需要输入两个参数。模板的名称指的是我们应该克隆的模板仓库，组 ID 将决定在 GitLab
    中创建仓库的组。你可以从 GitLab 组详情页或组设置页面获取组 ID。这两个参数使得 API 更具通用性，因此可以在整个组织中使用。新创建的微前端仓库
    URL 和用于与仓库交互的访问令牌将作为连接机密存储。我们可以使用这些信息与 Argo CD 一起读取仓库。我们的示例不需要访问令牌，因为该仓库是公开的。这将是一个简单的组合：将模板名称与模板
    URL 映射，克隆仓库到指定的组中，并将仓库详情复制回机密。仓库的名称将通过声明对象的名称来引用。要在控制平面中建立并验证引导 API，请执行以下命令：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Refer to the following screenshot, where the APIs are established:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下截图，其中已建立 API：
- en: '![Figure 10.7 – Onboarding API'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – 引导 API'
- en: '](img/B17830_10_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_07.jpg)'
- en: Figure 10.7 – Onboarding API
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 引导 API
- en: 'As a final step in the onboarding stage, the application operator can onboard
    the repository and CI pipeline using a `Claim` configuration. The application
    operator will create a repository with the name `micro-frontend-one` using the
    following commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为引导阶段的最后一步，应用操作员可以使用 `Claim` 配置引导仓库和 CI 管道。应用操作员将使用以下命令创建名为 `micro-frontend-one`
    的仓库：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Refer to the following screenshot where the claims are created in GitLab:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下截图，其中在 GitLab 中创建了声明：
- en: '![Figure 10.8 – Onboarding the repository'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8 – 引导仓库'
- en: '](img/B17830_10_08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_08.jpg)'
- en: Figure 10.8 – Onboarding the repository
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 引导仓库
- en: You can go to the CI/CD section of the new repository to run the CI pipeline
    to see that the Docker images are created and pushed into Docker Hub. Developers
    can now make changes to the repository, and any new commit will automatically
    trigger the GitLab CI pipeline. In the following section, we can investigate the
    final stage to set up CD and provision other infrastructure dependencies.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进入新仓库的 CI/CD 部分，运行 CI 管道，查看 Docker 镜像是否已创建并推送到 Docker Hub。开发者现在可以对仓库进行更改，任何新的提交将自动触发
    GitLab CI 管道。在接下来的部分中，我们可以研究最终阶段，设置 CD 并提供其他基础设施依赖。
- en: The deployment dependencies
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署依赖
- en: 'The final stage is to automate the deployment dependencies for the micro-frontend.
    Automating the deployment dependencies means taking care of two aspects:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最终阶段是自动化微前端的部署依赖。自动化部署依赖意味着需要处理两个方面：
- en: '**Infrastructure dependencies**: The step involves provisioning the needed
    infrastructure dependencies for the micro-frontend. In our case, we will create
    a GCP MySQL database. There could be more dependencies for an application. We
    will settle with just a database to keep the example simple.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施依赖**：此步骤涉及为微前端配置所需的基础设施依赖。在我们的例子中，我们将创建一个 GCP MySQL 数据库。一个应用程序可能会有更多的依赖，我们将以数据库为例，保持示例的简洁。'
- en: '`template-helm` folder inside our template repository ([https://gitlab.com/unified.devops/react-template/-/tree/main/template-helm](https://gitlab.com/unified.devops/react-template/-/tree/main/template-helm)),
    it holds a Helm chart for deploying the application into Kubernetes. To deploy
    this Helm chart in a GitOps fashion, we must add an Argo CD configuration to the
    `product-a` Kubernetes cluster to sync the chart. We will construct an `Object`-type
    Kubernetes provider configuration, which can help apply any Kubernetes configuration
    to a target cluster. Our composition will compose an Argo CD configuration to
    deploy a Helm chart from a repository. Read more on how to use Argo CD for Helm
    deployment at [https://cloud.redhat.com/blog/continuous-delivery-with-helm-and-argo-cd](https://cloud.redhat.com/blog/continuous-delivery-with-helm-and-argo-cd).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template-helm` 文件夹位于我们的模板仓库内 ([https://gitlab.com/unified.devops/react-template/-/tree/main/template-helm](https://gitlab.com/unified.devops/react-template/-/tree/main/template-helm))，它包含一个
    Helm chart，用于将应用程序部署到 Kubernetes 中。为了以 GitOps 的方式部署该 Helm chart，我们必须在 `product-a`
    Kubernetes 集群中添加一个 Argo CD 配置，以同步该 chart。我们将构建一个 `Object` 类型的 Kubernetes 提供程序配置，帮助将任何
    Kubernetes 配置应用到目标集群。我们的组合将构建一个 Argo CD 配置，用于从仓库部署 Helm chart。有关如何使用 Argo CD 进行
    Helm 部署的更多信息，请参见 [https://cloud.redhat.com/blog/continuous-delivery-with-helm-and-argo-cd](https://cloud.redhat.com/blog/continuous-delivery-with-helm-and-argo-cd)。'
- en: 'We will build a nested XR to satisfy the preceding requirement. The XWebApplication
    will be the parent API, and XGCPdb will be the nested inner XR. The parent API
    captures the product Git group and database size as input. The micro-frontend
    name will be another input derived from the name of the claim. The parent composition
    will compose the Argo CD config and an XGCPdb resource (inner XR). Refer to our
    example repo’s application and database folder to go through the XRD and composition
    of both XRs. The following are a few code snippets that are key to understanding.
    In the Argo CD object, the following is the patch for the repository URL. We construct
    the GitLab URL from the group name and claim name (repository name). Look at the
    claim to see the actual input (`Claim-Application.yaml`). The following is the
    repository URL patch code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个嵌套的 XR 来满足前述要求。XWebApplication 将是父 API，XGCPdb 将是嵌套的内部 XR。父 API 捕获产品 Git
    组和数据库大小作为输入。微前端名称将是从声明名称衍生的另一个输入。父级组合将组合 Argo CD 配置和 XGCPdb 资源（内部 XR）。请参阅我们示例仓库中的应用程序和数据库文件夹，了解两个
    XR 的 XRD 和组合。以下是几个关键代码片段，有助于理解。在 Argo CD 对象中，以下是用于仓库 URL 的修补代码。我们根据组名和声明名（仓库名）构建
    GitLab URL。查看声明以查看实际输入（`Claim-Application.yaml`）。以下是仓库 URL 修补代码：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We dynamically patch the Kubernetes provider config name using a predictable
    naming strategy. The following is the code snippet for this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用可预测的命名策略动态修补 Kubernetes 提供程序配置名称。以下是相关的代码片段：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Another important patch is to bind the Docker image name dynamically. In our
    CI pipeline, we use the repository name as the Docker image name. As the claim
    name and the repository name are the same, we can use the claim name to dynamically
    construct the Docker image name. The following is the patch code snippet for this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的修补是动态绑定 Docker 镜像名称。在我们的 CI 管道中，我们使用仓库名称作为 Docker 镜像名称。由于声明名称和仓库名称相同，我们可以使用声明名称动态构建
    Docker 镜像名称。以下是相关的修补代码片段：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`source` and `destination` are two key sections under the Argo CD config. This
    configuration provides information about the source of the Helm chart and how
    to deploy this in the destination Kubernetes cluster. The following is the code
    snippet for this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 和 `destination` 是 Argo CD 配置中的两个关键部分。该配置提供有关 Helm chart 来源以及如何在目标
    Kubernetes 集群中部署的相关信息。以下是相关的代码片段：'
- en: '[PRE52]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To establish and validate our APIs in the control plane, execute the following
    commands:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要在控制平面中建立和验证我们的 API，请执行以下命令：
- en: '[PRE76]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Refer to the following screenshot, where the APIs are established and validated:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考下面的截图，其中展示了 API 的建立和验证过程：
- en: '![Figure 10.9 – Onboarding the application API'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – 应用程序 API 的入驻'
- en: '](img/B17830_10_09.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_09.jpg)'
- en: Figure 10.9 – Onboarding the application API
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 应用程序API的入驻
- en: Tip
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we did not configure any access token for Argo CD to access GitLab
    as it is a public repository. We will have private repositories in real life,
    and a token is required. Refer to [https://argo-cd.readthedocs.io/en/release-1.8/operator-manual/declarative-setup/#repositories](https://argo-cd.readthedocs.io/en/release-1.8/operator-manual/declarative-setup/#repositories)
    to see how to set up an access token. Again, this can be automated as a part of
    repository onboarding.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有为Argo CD配置任何访问令牌来访问GitLab，因为它是一个公共仓库。实际生活中，我们会有私有仓库，且需要访问令牌。请参考[https://argo-cd.readthedocs.io/en/release-1.8/operator-manual/declarative-setup/#repositories](https://argo-cd.readthedocs.io/en/release-1.8/operator-manual/declarative-setup/#repositories)查看如何设置访问令牌。再次强调，这可以作为仓库入驻的一部分进行自动化。
- en: 'As a final step in the application deployment automation stage, the application
    operator can provision the database as an infrastructure dependency and configure
    the CD setup using the following claim configuration:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序部署自动化阶段的最后一步，应用程序运维人员可以将数据库作为基础设施依赖项进行部署，并使用以下claim配置来配置CD设置：
- en: '[PRE80]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The application operator will use the following commands:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运维人员将使用以下命令：
- en: '[PRE93]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Refer to the following screenshot, where the application infrastructure dependencies
    and CD configurations are provisioned:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图，展示了应用程序基础设施依赖关系和CD配置的部署：
- en: '![Figure 10.10 – Onboarding the API'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 – API的入驻'
- en: '](img/B17830_10_10.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_10_10.jpg)'
- en: Figure 10.10 – Onboarding the API
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – API的入驻
- en: Tip
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We have used Argo CD and Helm chart deployment to handle application automation.
    We can replace Helm with KubeVela, combine Helm/KubeVela with Kustomize, or even
    use a plain Kubernetes object as required for your team. Even Argo CD can be replaced
    with other GitOps tools, such as Flex.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Argo CD和Helm chart部署来处理应用程序自动化。我们可以根据团队的需求，将Helm替换为KubeVela，将Helm/KubeVela与Kustomize结合使用，甚至使用普通的Kubernetes对象。甚至Argo
    CD也可以被其他GitOps工具替代，如Flex。
- en: This takes us to the end of the hands-on journey to automate the application
    from end to end. Our micro-frontend example and its dependent database are up
    and running now. In the following section of this chapter, we will discuss the
    reasoning behind our XR/claim API boundaries.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们走到了从头到尾自动化应用程序的实践之旅的终点。我们的微前端示例及其依赖的数据库现在已经启动并运行。在本章的下一部分，我们将讨论我们XR/claim
    API边界背后的推理。
- en: API boundary analysis
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API边界分析
- en: 'We divided the end-to-end automation into four stages. We can ignore stage
    one as it is about preparing the Crossplane control plane itself. It’s essential
    to understand why we split the remaining stages into three with four XR/claim
    APIs. The following are the ideas behind our API boundaries:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将端到端自动化分为四个阶段。我们可以忽略第一阶段，因为它是关于准备Crossplane控制平面的。理解为什么我们将其余阶段分为三个，并使用四个XR/claim
    API是非常重要的。以下是我们API边界背后的思路：
- en: '`product-a`. All modern workloads are generally deployed in Kubernetes, and
    the organization will have many such cluster setup activities in the future. Building
    a separate API to enable reusability and centralized policy management makes sense.
    Another critical reason to keep the API separate is that the cluster setup is
    a one-time activity and acts as cross-cutting for further application workload
    deployments.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-a`。所有现代工作负载通常都部署在Kubernetes上，组织未来将有许多类似的集群设置活动。构建一个单独的API以实现可重用性和集中管理策略是有意义的。保持API独立的另一个重要原因是集群设置是一次性活动，并且作为进一步应用程序工作负载部署的跨切面操作。'
- en: '**The onboarding API**: The XR/claim for the GitLab project onboarding is developed
    as a separate API. We don’t need to onboard the repository and CI pipeline for
    every environment (production, staging, and development). That’s why we decided
    to keep XGitProjectAPI/GitProject API separate.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入驻API**：GitLab项目入驻的XR/claim作为一个独立的API进行开发。我们不需要为每个环境（生产、预发布和开发）入驻仓库和CI流水线。这就是为什么我们决定将XGitProjectAPI/GitProject
    API分开的原因。'
- en: '**The application API**: This is the step where we onboard the application
    infrastructure dependencies and CI setup, which is done once per environment.
    That’s why we developed XWebApplication/WebApplication as a separate API. Note
    that there is an inner nested API for the database provisioning. The idea is to
    keep it separate as there are organization-wide policies in database provisioning.
    Note that the database API does not have a claim as it is designed to be used
    as only a nested API. The policy requirement is an assumption that may not be
    true for your case.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序 API**：这是我们将应用程序基础设施依赖项和 CI 设置进行入职的步骤，每个环境只需做一次。因此，我们将 XWebApplication/WebApplication
    作为一个独立的 API 来开发。需要注意的是，数据库配置有一个内部嵌套 API。这个设计的想法是将其独立出来，因为数据库配置在组织范围内有政策要求。注意，数据库
    API 没有声明，因为它仅作为嵌套 API 使用。该政策要求是一个假设，可能并不适用于你的情况。'
- en: Tip
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: The repository URL and access token created with the onboarding API is required
    in the application API to set up CI. The onboarding API is a one-time activity,
    and the application API is used in every environment. If we have a different Crossplane
    for every environment (production, staging, and development), sharing the credentials
    across in an automated way could be challenging. Consider using an external key
    vault to sync the repository details from the onboarding API. Other Crossplane
    environments can synchronize these Secrets using tools such as External Secrets
    ([https://external-secrets.io/v0.5.3/](https://external-secrets.io/v0.5.3/)).
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在应用程序 API 中设置 CI 时，需要提供通过入职 API 创建的仓库 URL 和访问令牌。入职 API 是一次性操作，而应用程序 API 在每个环境中都会使用。如果我们为每个环境（生产、预发布和开发）配置不同的
    Crossplane，那么以自动化方式共享凭证可能会变得具有挑战性。可以考虑使用外部密钥保管库来同步入职 API 中的仓库详情。其他 Crossplane
    环境可以通过诸如 External Secrets ([https://external-secrets.io/v0.5.3/](https://external-secrets.io/v0.5.3/))
    等工具来同步这些密钥。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter discussed one of the approaches to handling the end-to-end automation
    of applications, infrastructure, and services. There are multiple patterns to
    approach end-to-end control plane-based automation using the ways we learned throughout
    the book. I can’t wait to see what unique ways you come up with. This chapter
    takes us to the end of learning Crossplane concepts and patterns and our hands-on
    journey.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了处理应用程序、基础设施和服务端到端自动化的一种方法。利用我们在全书中学到的方式，实际上有多种方法可以实现基于控制平面的端到端自动化。我迫不及待地想看到你们提出的独特方式。本章将带领我们完成对
    Crossplane 概念和模式的学习，并结束我们的实操之旅。
- en: In the final chapter, we will look at some inspirations to run a platform as
    a product. You will learn essential engineering practices that make our Crossplane
    platform team successful.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们将探讨一些灵感，如何将平台作为产品来运行。你将学到使我们 Crossplane 平台团队成功的关键工程实践。
