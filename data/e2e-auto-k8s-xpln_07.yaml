- en: '*Chapter 5*: Exploring Infrastructure Platform Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 5 章*：探索基础设施平台模式'
- en: The success of running an infrastructure platform product with Crossplane depends
    on following a few principles and patterns as and when required. This chapter
    will explore some of these critical practices. We will also learn a few debugging
    skills while exploring the concepts. After learning the basics of the Crossplane
    in the last few chapters, this will be a place for learning advanced patterns
    that are key to building the state-of-the-art infrastructure platform for your
    organization. You will learn a few critical aspects of building robust XR APIs
    and debugging issues with ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Crossplane 运行基础设施平台产品的成功，依赖于在需要时遵循一些原则和模式。本章将探讨一些关键的实践，同时在探索概念的过程中，我们还将学习一些调试技巧。在过去几章学习了
    Crossplane 的基础知识之后，本章将是学习构建最先进的基础设施平台的关键模式的地方。你将学习构建健壮的 XR API 和轻松调试问题的几个关键方面。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的主题如下：
- en: Evolving the APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展 API
- en: Nested and multi-resource XRs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套和多资源 XR
- en: XRD detailed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XRD 详细信息
- en: Managing external software resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理外部软件资源
- en: Evolving the APIs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发展 API
- en: 'Crossplane is primarily an API-based infrastructure automation platform. Changes
    to the APIs are inevitable as the business requirements and technology landscape
    evolve. We can classify these changes into three different buckets:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Crossplane 主要是一个基于 API 的基础设施自动化平台。随着业务需求和技术环境的发展，API 的变更是不可避免的。我们可以将这些变更分为三类：
- en: API implementation change
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 实现变更
- en: Non-breaking API contract change
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非破坏性 API 合同变更
- en: Breaking API contract change
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏性 API 合同变更
- en: Let’s start with the API implementation change.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 API 实现变更开始。
- en: API implementation change
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 实现变更
- en: These changes are limited to the API implementation details without any changes
    to the contract. In other words, these are changes to Compositions YAML, a construct
    used by XR for API implementation. `CompositionRevision` is the Crossplane concept
    that will work with compositions to support such changes. If the `--enable-composition-revisions`
    flag is set while installing Crossplane, a `CompositionRevision` object is created
    with all the updates to composition. The name of the `CompositionRevision` object
    is autogenerated on every increment. The compositions are mutable objects that
    can change forever, but individual `CompositionRevision` is immutable. `Composition`
    and `CompositionRevision` are in one-to-many relationships. We will have only
    one `CompositionRevision` active at any given instance. The latest revision number
    will always be active, excluding the following scenario.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变更仅限于 API 实现的细节，而不涉及合同的更改。换句话说，这些是对组合 YAML 的更改，这是一种由 XR 用于 API 实现的构造。`CompositionRevision`
    是 Crossplane 的概念，它将与组合一起工作，以支持这些更改。如果在安装 Crossplane 时设置了 `--enable-composition-revisions`
    标志，那么会为所有组合更新创建一个 `CompositionRevision` 对象。`CompositionRevision` 对象的名称会在每次递增时自动生成。组合是可变对象，可以永远变化，但单个
    `CompositionRevision` 是不可变的。`Composition` 和 `CompositionRevision` 之间存在一对多关系。每次只能有一个
    `CompositionRevision` 处于活动状态。最新的版本号将始终处于活动状态，排除以下场景。
- en: Tip
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Each configuration state of the composition maps to a single `CompositionRevision`.
    Let’s say we are in revision 2 and changing the composition configuration the
    same as the first revision. A new revision is not created. Instead, revision 1
    becomes active, making revision 2 inactive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的每个配置状态都映射到一个单一的 `CompositionRevision`。假设我们在第 2 个版本，并且将组合配置更改为与第 1 个版本相同。这时不会创建新版本，而是第
    1 个版本变为活动版本，第 2 个版本变为非活动版本。
- en: 'In a Crossplane environment where the composition revision flag is enabled,
    we will have two attributes automatically added to every XR/Claim object by Crossplane.
    The following are attribute names and how they are used:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用组合修订标志的 Crossplane 环境中，Crossplane 会自动向每个 XR/Claim 对象添加两个属性。以下是属性名称及其用途：
- en: '`spec.compositionRevisionRef`: This will hold the name of `CompositionRevision`
    with which the resources are created.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.compositionRevisionRef`：这将包含与资源创建相关的 `CompositionRevision` 的名称。'
- en: '`spec.compositionUpdatePolicy`: This attribute will indicate whether the XR/Claim
    will automatically migrate to a new, available `CompositionRevision`. Manual and
    automatic are the two possible values, with automatic as the default value. If
    you would like to override the default behavior, add this attribute with a manual
    indicator in the XR/Claim configuration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.compositionUpdatePolicy`：此属性将指示 XR/Claim 是否会自动迁移到新的可用 `CompositionRevision`。手动和自动是两种可能的值，默认值为自动。如果您希望覆盖默认行为，请在
    XR/Claim 配置中添加此属性，并指明为手动。'
- en: 'The following diagram represents how `Composition` and `CompositionRevision`
    work together to evolve infrastructure API implementation continuously:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示 `Composition` 和 `CompositionRevision` 如何协同工作，持续推动基础设施 API 实现的演变：
- en: '![Figure 5.1 – Evolving compositions'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 演变中的组成'
- en: '](img/B17830_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_01.jpg)'
- en: Figure 5.1 – Evolving compositions
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 演变中的组成
- en: To manually migrate the composition, update the `spec.compositionRevisionRef`
    configuration in the XR/Claim with the latest revision name. This specific design
    enables the separation of concerns between the platform API creator and consumers.
    Infrastructure API creators will update the compositions, and API consumers can
    choose their revision upgrade strategy. If you want a specific revision of composition
    to be used while creating an XR/Claim, explicitly mention the revision name under
    `spec.compositionRevisionRef`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动迁移组成，请在 XR/Claim 中更新 `spec.compositionRevisionRef` 配置，并使用最新的修订名称。这个特定设计使平台
    API 创建者和消费者之间的职责分离。基础设施 API 创建者将更新组成，API 消费者可以选择其修订升级策略。如果在创建 XR/Claim 时想使用特定的组成修订，请在
    `spec.compositionRevisionRef` 下明确提及修订名称。
- en: 'Let’s look at some examples of such changes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些这样的更改示例：
- en: '**Bugfix**: Let''s say we mapped an incorrect attribute to the XRD status field.
    The scope of the correct mapping is limited to changes in the respective Composition
    patch section.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误修复**：假设我们将一个错误的属性映射到 XRD 状态字段。正确映射的范围仅限于相应组成修补部分的更改。'
- en: '**Policy changes without contract change**: Adding a new infrastructure compliance
    policy to provide all new resources in a specific region.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**政策更改而不更改合同**：添加一个新的基础设施合规政策，以便在特定区域提供所有新资源。'
- en: '**Shared infrastructure**: Moving toward a shared **Virtual Private Cloud**
    (**VPC**) instead of dynamically provisioning a new VPC for all new XR/Claim requests.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享基础设施**：朝着共享**虚拟私有云**（**VPC**）的方向发展，而不是为所有新的 XR/Claim 请求动态创建新的 VPC。'
- en: 'The composition revision flag is not enabled by default. Use the `--enable-composition-revisions`
    argument with a Crossplane pod to enable composition revision. The following Helm
    command will set up/update the Crossplane environment with composition revision:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 组成修订标志默认情况下未启用。使用 `--enable-composition-revisions` 参数与 Crossplane pod 一起启用组成修订。以下
    Helm 命令将设置/更新带有组成修订的 Crossplane 环境：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following section will look at composition revision with an example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将通过一个示例查看组成修订。
- en: Hands-on journey with composition revision
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手体验组成修订
- en: 'Let’s go through a hands-on journey to experience composition revision. The
    objectives of the exercise will be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个动手实践来体验组成修订。此练习的目标如下：
- en: Building an XR API for GCP MySQL provisioning in a composition revision-enabled
    Crossplane environment
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启用组成修订的 Crossplane 环境中为 GCP MySQL 提供一个 XR API
- en: Creating two MySQL instances with automated and manual composition revision
    policies
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个 MySQL 实例，采用自动化和手动组成修订策略
- en: Updating the Composition to change the calculation for database disk size
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新组成，以更改数据库磁盘大小的计算方式
- en: Validating if the MySQL instance with automated revision policy automatically
    migrates to the latest composition revision
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证采用自动修订策略的 MySQL 实例是否会自动迁移到最新的组成修订版本
- en: Seeing that the MySQL instance with the manual revision policy does not migrate
    to the latest composition revision
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现采用手动修订策略的 MySQL 实例无法迁移到最新的组成修订版本
- en: Finally, migrating the second MySQL instance manually to the latest composition
    revision
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将第二个 MySQL 实例手动迁移到最新的组成修订版本
- en: 'Let’s use a simple XRD and composition to explore composition revision. The
    following is the XRD with just one parameter that takes the MySQL disk size:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个简单的 XRD 和组成来探索组成修订。以下是 XRD，其中仅包含一个参数，该参数用于设置 MySQL 磁盘大小：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The composition for the preceding XRD is as follows, which patches the `size`
    attribute from XR into the GCP CloudSQLInstance MR:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前述XRD的组成如下所示，它将`size`属性从XR补丁到GCP CloudSQLInstance MR中：
- en: '[PRE36]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Apply both the YAML to a target Crossplane cluster with composition revision
    enabled. You will see that `CompositionRevision` is created for the composition.
    Execute the following command to view all `CompositionRevision` for the given
    composition:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个YAML应用到启用了组成修订的目标Crossplane集群。你将看到为该组成创建了`CompositionRevision`。执行以下命令查看给定组成的所有`CompositionRevision`：
- en: '[PRE62]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Refer to the following screenshot with one revision object created for the
    `gcp-mysql` composition. Note that the `current` attribute is true for revision
    1\. It will change if we update the composition:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下屏幕截图，其中为`gcp-mysql`组成创建了一个修订对象。请注意，修订1的`current`属性为true。如果我们更新组成，这将发生变化：
- en: '![Figure 5.2 – Composition Revision list'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 组成修订列表'
- en: '](img/B17830_05_02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_02.jpg)'
- en: Figure 5.2 – Composition Revision list
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 组成修订列表
- en: 'Now, let’s provision two MySQL instances with the Claim API. An example of
    manual revision update policy configuration is as follows. The automated revision
    version of the YAML will be the same without the `compositionUpdatePolicy` parameter,
    which defaults to an automatic revision update:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过Claim API配置两个MySQL实例。手动修订更新策略配置的示例如下所示。YAML的自动修订版本与没有`compositionUpdatePolicy`参数的版本相同，后者默认进行自动修订更新：
- en: '[PRE64]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can refer to the following screenshot with two MySQL instances onboarded:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下屏幕截图，其中包含了两个已引导的MySQL实例：
- en: '![Figure 5.3 – MySQL claims'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – MySQL声明'
- en: '](img/B17830_05_03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_03.jpg)'
- en: Figure 5.3 – MySQL claims
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – MySQL声明
- en: 'Now, update the composition patch with a transform function to multiply the
    disk size by four before patching. The patches section of the updated composition
    will look like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新组成补丁，使用转换函数在补丁之前将磁盘大小乘以四。更新组成的补丁部分将如下所示：
- en: '[PRE75]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'After updating the composition, you will see two revisions. Only the latest
    revision will have the `current` flag of `true`. Also, we can notice that the
    MySQL provisioned with an automated revision update policy would have increased
    the storage. The following screenshot summarizes the output after applying the
    updated composition:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 更新组成后，你将看到两个修订版本。只有最新的修订版本会将`current`标志设为`true`。另外，我们可以注意到，通过自动修订更新策略配置的MySQL会增加存储空间。以下屏幕截图总结了应用更新组成后的输出：
- en: '![Figure 5.4 – New Composition Revision'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 新的组成修订'
- en: '](img/B17830_05_04.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_04.jpg)'
- en: Figure 5.4 – New Composition Revision
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 新的组成修订
- en: Finally, we can manually upgrade the second MySQL instance by adding the `spec.compositionRevisionRef`
    attribute to the XR/Claim configuration. The field will hold the autogenerated
    composition revision name. The composition revision hands-on journey example is
    available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision).
    In the following section, we will explore the ways to change the XR API contract.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过在XR/Claim配置中添加`spec.compositionRevisionRef`属性来手动升级第二个MySQL实例。该字段将保存自动生成的组成修订名称。组成修订的实践示例可以在[https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Composition-Revision)找到。在接下来的部分中，我们将探索更改XR
    API契约的方法。
- en: API contract changes
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API契约更改
- en: 'API implementation details are just one direction in which XR changes can evolve.
    The highly interoperable API contract between the XR creating and consuming teams
    also needs to change over time. Contract change can fall under two categories:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: API实现细节只是XR更改可能演变的一个方向。XR创建团队与消费团队之间高度互操作的API契约也需要随着时间的推移进行更改。契约的更改可以分为两类：
- en: '**Non-breaking changes**: The XR API will be backward-compatible, meaning that
    consumers are either not impacted by the change or can choose to adopt the new
    changes at their phase.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非破坏性更改**：XR API将向后兼容，这意味着消费者要么不受更改影响，要么可以选择在其阶段采纳新的更改。'
- en: '**Breaking changes**: The XR API will not be backward-compatible. A new API
    version must be introduced, and the old API version must be deprecated at an appropriate
    time. All old API users should be safely migrating to the new API version.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏性变更**：XR API将不兼容旧版本。必须引入新API版本，并在适当的时候弃用旧API版本。所有旧的API用户应安全地迁移到新API版本。'
- en: Let’s delve into non-breaking changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨非破坏性变更。
- en: Non-breaking changes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非破坏性变更
- en: 'Adding one or more optional parameters to the XRD contract can be considered
    a non-breaking change. It is non-breaking because the old external resources provisioned
    can co-exist with the new schema as the new parameters are optional. Note that
    removing an existing optional parameter in the XRD is a breaking change as Crossplane
    upfront does not know how to reconcile existing provisioned resources. A simple
    way to think about this is that if Composition/CompositionRevision can handle
    the co-existence of old and newly provisioned resources, then the XRD contract
    change is non-breaking. A new optional parameter in the MySQL XR to choose the
    disk size is an example of a non-breaking change. The change will involve both
    a contract change and a composition revision. Let’s go through a hands-on journey
    to make the previous XR example. All the configuration YAML required for this
    journey is available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking).
    Refer to the following screenshot of our hands-on journey:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向XRD合同中添加一个或多个可选参数可以视为非破坏性变更。这是非破坏性的，因为旧的外部资源可以与新模式共存，因为新参数是可选的。请注意，移除XRD中现有的可选参数是破坏性变更，因为Crossplane在前端无法知道如何调和现有的已配置资源。一个简单的思考方式是，如果Composition/CompositionRevision能够处理旧资源和新配置资源的共存，那么XRD合同变更就是非破坏性的。选择磁盘大小的MySQL
    XR中的新可选参数就是一个非破坏性变更的例子。此变更将涉及合同变更和组合修订。让我们通过一个动手实践过程来完成前面的XR示例。此过程所需的所有配置YAML文件可以在[https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Non-Breaking)查看。参考以下动手过程的截图：
- en: '![Figure 5.5 – Non-breaking contract change'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 非破坏性合同变更'
- en: '](img/B17830_05_05.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_05.jpg)'
- en: Figure 5.5 – Non-breaking contract change
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 非破坏性合同变更
- en: 'The following are the steps to be performed throughout the hands-on journey
    to experiment with the non-breaking contract change:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是整个动手实践过程中实验非破坏性合同变更时需要执行的步骤：
- en: Create the first version of the XRD in the target cluster (`xrd-v1.yaml`). The
    schema has `vm` as a mandatory parameter.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标集群中创建XRD的第一个版本（`xrd-v1.yaml`）。该模式将`vm`作为必需参数。
- en: Create the first revision of the composition (`Composition-V1.yaml`). It will
    patch the `vm` value back into the `MR-CloudSQLInstance` tier attribute.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组合的第一个修订版（`Composition-V1.yaml`）。它将把`vm`值补丁回`MR-CloudSQLInstance`层属性。
- en: Now, the MySQL resource can be provisioned with `db-n1-standard-1` as the tire
    in GCP (`Claim-v1.yaml`).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，MySQL资源可以通过`db-n1-standard-1`作为GCP中的配置选择来配置（`Claim-v1.yaml`）。
- en: Update and apply the XRD with an additional optional parameter, `size`, to specify
    the database disk size (`xrd-v2.yaml`).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并应用XRD，增加一个可选参数`size`来指定数据库磁盘大小（`xrd-v2.yaml`）。
- en: Update and apply the new composition (`Composition-V2.yaml`). It will patch
    the additional size parameter into the MR.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并应用新的组合（`Composition-V2.yaml`）。它将把额外的大小参数补丁到MR中。
- en: Finally, create the second MySQL instance with a specific disk size and tire
    (`Claim-v2.yaml`).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建第二个具有特定磁盘大小和配置的MySQL实例（`Claim-v2.yaml`）。
- en: To validate whether the first MySQL instance can be sill updated, change the
    tier with an update YAML (`Claim-v1-validate.yaml`).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证第一个MySQL实例是否仍然可以更新，请使用更新的YAML（`Claim-v1-validate.yaml`）更改配置。
- en: We did not upgrade the API version when updating the contract. We will discuss
    this more in the upcoming section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新合同时，我们没有升级API版本。我们将在接下来的部分讨论这个问题。
- en: Version upgrade
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本升级
- en: In the previous section, we did not change the XRD version number from v1\.
    Crossplane does not currently support XR version upgrades once a contract changes.
    API versioning without a contract change will be helpful in indicating API stability
    (alpha, beta, v1, and so on). We can just move from alpha to beta to a more stable
    version without changing the contract. The version upgrade is currently achieved
    by listing the old and new version definitions in the XRD. The `versions` array
    is the construct used for listing multiple versions. The two critical Boolean
    attributes under each version are `served` and `referenceable`. The `referenceable`
    flag will determine whether we can define a composition implementation for the
    given version. Only one version can have the referenceable flag set to `true`.
    This will be the version used by any new XR create/update event. A create/update
    event triggered by the old API version will still use the composition from the
    latest version, marked as referenceable. The `served` flag will indicate whether
    the given XR API version is in use. Some teams may still use the old version to
    consume the API. Switching off the `served` flag means that the given version
    is no longer available for clients. It will be the last step before removing the
    old version from the XR.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们并未将 XRD 的版本号从 v1 更改。Crossplane 当前不支持在合同变更后进行 XR 版本升级。没有合同变更的 API 版本化有助于指示
    API 的稳定性（如 alpha、beta、v1 等）。我们可以在不更改合同的情况下从 alpha 升级到 beta，再到更稳定的版本。当前，版本升级是通过在
    XRD 中列出旧版本和新版本定义来实现的。`versions` 数组用于列出多个版本。每个版本下的两个关键布尔属性是 `served` 和 `referenceable`。`referenceable`
    标志将决定是否可以为给定版本定义组合实现。只有一个版本可以将 referenceable 标志设置为 `true`，该版本将用于任何新的 XR 创建/更新事件。由旧
    API 版本触发的创建/更新事件仍将使用最新版本的组合，并将其标记为可引用。`served` 标志表示给定的 XR API 版本是否正在使用。一些团队可能仍会使用旧版本来访问
    API。关闭 `served` 标志意味着该版本不再对客户端可用。这将是从 XR 中移除旧版本之前的最后一步。
- en: Look at a sample XRD with three versions, alpha, beta, and v1, at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml).
    This XRD has three versions. Version alpha will no longer be served, and beta
    will be served but cannot be referred for resource creation or update. The latest
    version, v1, will be the preferred version for any resource creation or updates.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看一个包含三个版本（alpha、beta 和 v1）的 XRD 示例，网址为 [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/blob/main/Chapter05/Samples/XRD-Versions/xrd-multiple-version.yaml)。这个
    XRD 包含三个版本。alpha 版本将不再提供服务，beta 版本将提供服务，但不能用于资源的创建或更新。最新版本 v1 将是进行资源创建或更新时的首选版本。
- en: Kubernetes CRDs support multiple API versions both with and without an API contract
    change. When there is an API contract change, a conversion webhook is configured
    by the CRD author to support conversion between the versions. Conversions are
    required as CR objects will be stored in the etcd with both old and new contracts.
    XRD, the Crossplane equivalent to CRDs, does not take this approach. A conversion
    webhook involves programming. Taking that route will violate the no-code agenda
    of Crossplane when composing APIs. It’s important to note that the Crossplane
    community is actively working to build a configuration-based solution to support
    conversion and migration between versions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CRD 支持多个 API 版本，包括有和没有 API 合同更改的版本。当存在 API 合同更改时，CRD 作者会配置一个转换 webhook
    来支持版本间的转换。由于 CR 对象将以旧合同和新合同的形式存储在 etcd 中，因此需要进行转换。Crossplane 中与 CRD 等效的 XRD 不采用这种方法。转换
    webhook 涉及编程，选择这种方法会违反 Crossplane 在构建 API 时不编写代码的目标。需要注意的是，Crossplane 社区正在积极努力构建一个基于配置的解决方案，以支持不同版本之间的转换和迁移。
- en: Version upgrade with breaking changes
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本升级与破坏性变更
- en: 'An alternative approach supports breaking contracts by introducing a new XR
    API parallel. This approach uses an external naming technique and deletion policy
    to handle breaking changes. With this pattern, we will migrate the resources to
    a new XR API and remove the old API once the migration is finished in its entirety.
    The steps to achieve such a version upgrade are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法通过引入新的XR API并行支持破坏性契约。这种方法使用外部命名技术和删除策略来处理破坏性变化。采用这种模式时，我们将把资源迁移到新的XR API，并在迁移完全完成后删除旧的API。完成版本升级的步骤如下：
- en: Create the v1 version of XRD. In the composition, define a standard nomenclature
    for naming the external resources (MRs). We should be able to reconstruct the
    names again in the new API. Generally, we can concatenate the XR and the composition
    name (`<XR>+'-'+<Composition>`). You can come up with a resource naming strategy
    that suits your environment. Maybe we can even use the namespace name to represent
    the product owner of the resource.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建v1版本的XRD。在组成中，定义一个标准的命名法来命名外部资源（MRs）。我们应该能够在新的API中重新构建名称。通常，我们可以将XR和组成名称连接起来（`<XR>+'-'+<Composition>`）。你可以根据你的环境制定适合的资源命名策略。也许我们可以使用命名空间名称来表示资源的产品所有者。
- en: Ensure that all the MRs in the composition have `spec.deletionPolicy` defined
    as `Orphan`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有组成中的MRs的`spec.deletionPolicy`定义为`Orphan`。
- en: Let’s say we have a couple of consumers for the XR, and they have created a
    few external resources. Assume that we have a policy requirement that requires
    breaking changes to the API contract.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有几个XR的消费者，并且他们已经创建了一些外部资源。假设我们有一个策略要求，必须对API契约进行破坏性修改。
- en: To support the breaking change, delete all v1 versions of the XR. It will just
    delete the Crossplane references. The external resources are not deleted on account
    of the orphan deletion policy.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了支持破坏性修改，删除所有v1版本的XR。这将仅删除Crossplane引用。由于孤立删除策略，外部资源不会被删除。
- en: Then, delete the v1 version of XRD and Composition.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，删除v1版本的XRD和Composition。
- en: Finally, create the new v2 version of XRD with the same XR name. Update the
    composition to handle the recent breaking changes. Ensure that the new composition
    follows the same external resource name creation logic and maps to the new XRD
    version.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建新的v2版本的XRD，使用相同的XR名称。更新组成以处理最近的破坏性变化。确保新的组成遵循相同的外部资源名称创建逻辑，并映射到新的XRD版本。
- en: Create the deleted XR objects again, pointing to the v2 version of the API.
    The new XR objects will reference the old orphaned external resources. Crossplane
    controllers will reconcile any attribute value change.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建已删除的XR对象，指向v2版本的API。新的XR对象将引用旧的孤立外部资源。Crossplane控制器将协调任何属性值的变化。
- en: 'Note that this type of migration to a new API version must be coordinated with
    all the XR-consuming teams. Once the migration is completed, the old API version
    will no longer be available. The following figure represents the migration process:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种迁移到新API版本的操作必须与所有XR消费者团队协调。一旦迁移完成，旧的API版本将不再可用。下图表示迁移过程：
- en: '![Figure 5.6 – Version migration'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 版本迁移'
- en: '](img/B17830_05_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_06.jpg)'
- en: Figure 5.6 – Version migration
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 版本迁移
- en: Tip
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is always good to have a standard way of generating external resource names.
    In addition to version migration, a reproducible naming pattern can afford several
    other advantages. Using pre-provisioned resources for a shared or cached infrastructure
    is an example of using the standard external resource naming pattern. Migrating
    resources to a new Crossplane environment can be another example.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 总是采用一种标准化的方式来生成外部资源名称是很好的。除了版本迁移，具有可重复的命名模式还可以带来其他几个优势。使用预配置的资源来支持共享或缓存的基础设施就是使用标准外部资源命名模式的一个例子。将资源迁移到新的Crossplane环境也是一个例子。
- en: 'It’s recommended to go through a hands-on journey of breaking API contract,
    with the sample configuration provided at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking).
    Perform the following steps to go through the hands-on journey to handle breaking
    contract changes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐通过实践操作了解 API 合同破坏，使用在 [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/XRD-Contract-Change-Breaking)
    提供的示例配置。执行以下步骤进行实践操作以处理合同变更：
- en: First, execute `xrd-v1.yaml`, `Composition-V1.yaml`, and `Claim.yaml`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，执行 `xrd-v1.yaml`、`Composition-V1.yaml` 和 `Claim.yaml`。
- en: It will create an XRD and a Composition with the database size as optional parameter
    and the VM as a mandatory parameter. The Claim will provision the database wih
    the specified size and VM. The provisioned resource will get a standard external
    resource name.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将创建一个 XRD 和一个 Composition，其中数据库大小为可选参数，虚拟机为必选参数。Claim 将根据指定的大小和虚拟机配置数据库。配置的资源将获得标准的外部资源名称。
- en: Note that the `claim.name` label in `Claim.yaml` is used for constructing the
    external resource name in the composition section. It should be unique for every
    XR/Claim object to generate unique external resource names.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`Claim.yaml` 中的 `claim.name` 标签用于在 Composition 部分构造外部资源名称。它应该对于每个 XR/Claim
    对象唯一，以生成唯一的外部资源名称。
- en: Let’s now delete the v1 version of Claim, Composition, and XRD. When we delete
    the v1 claim, the external resource will not be deleted because the deletion policy
    is configured as an orphan.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们删除 v1 版本的 Claim、Composition 和 XRD。当我们删除 v1 claim 时，外部资源不会被删除，因为删除策略被配置为孤立资源。
- en: Finally, apply the v2 version of Claim, Composition, and XRD. In the v2 XRD,
    we have broken the contract by removing the mandatory parameter, `vm`. The new
    v2 claim (`Claim-migrate.yaml`) will not have the `vm` parameter. Note that both
    Composition and Claim will point to the v2 version XRD.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，应用 v2 版本的 Claim、Composition 和 XRD。在 v2 XRD 中，我们通过移除必选参数 `vm` 来破坏合同。新的 v2
    claim（`Claim-migrate.yaml`）将不包含 `vm` 参数。请注意，Composition 和 Claim 都将指向 v2 版本的 XRD。
- en: Notice that the Crossplane will reclaim the orphaned resource and reconcile
    the virtual machine with the new default value provided in the Composition. We
    can validate that by looking into the GCP console or the Claim resource description.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，Crossplane 将回收孤立的资源，并使用 Composition 中提供的新默认值来协调虚拟机。我们可以通过查看 GCP 控制台或 Claim
    资源描述来验证这一点。
- en: 'Refer to the following screenshot where the preceding example is tested:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下截图，其中测试了前面的示例：
- en: '![Figure 5.7 – XRD breaking changes'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – XRD 破坏性变更'
- en: '](img/B17830_05_07.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_07.jpg)'
- en: Figure 5.7 – XRD breaking changes
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – XRD 破坏性变更
- en: 'Following is the code snippet relating to external resource name patching from
    the preceding Composition example. This must be present in both composition versions,
    and the name generated should be the same for both versions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与前述 Composition 示例中外部资源名称修补相关的代码片段。它必须出现在两个 Composition 版本中，且生成的名称在两个版本中应相同：
- en: '[PRE83]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that we have used a new transform type to format the string before we patch.
    With this, we conclude the different ways of evolving the XR APIs. We will dive
    into an interesting case in the following section to build one XR composing another
    XR.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了新的转换类型来格式化字符串，然后再进行修补。通过这种方式，我们总结了不同的 XR API 演变方法。接下来我们将深入探讨一个有趣的案例，构建一个
    XR 组合另一个 XR。
- en: Nested and multi-resource XRs
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套和多资源 XR
- en: 'Every software product depends on more than one infrastructure resource. It
    is essential to build single infrastructure recipes in order for the product teams
    to consume with a unified experience. The orchestration of infrastructure dependencies
    should remain abstracted. Such recipes require multiple resources to be composed
    into a single XR. In all the examples hitherto, we have always composed a single
    GCP resource inside an XR. Let’s look at an XR sample where multiple GCP resources
    are composed into a single XR API. The following figure represents the resources
    and XR APIs that we are going to work with in the example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件产品都依赖于多个基础设施资源。为了让产品团队能够以统一的体验使用这些资源，构建单一的基础设施配方是至关重要的。基础设施依赖的编排应该保持抽象。这些配方要求多个资源被组合成一个单一的XR。在此前所有的示例中，我们始终将单一的GCP资源组合进一个XR。现在让我们看一个示例，其中多个GCP资源被组合成一个单一的XR
    API。下图展示了我们将在示例中使用的资源和XR API：
- en: '![Figure 5.8 – Multi-resource nested XR'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 多资源嵌套XR'
- en: '](img/B17830_05_08.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_08.jpg)'
- en: Figure 5.8 – Multi-resource nested XR
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 多资源嵌套XR
- en: 'In addition to multiple resource provisioning in a single XR, we also have
    a nested XR pattern in *Figure 5.8*. We are composing three resources within two
    XRs. The first XR composes two resources, and the second XR composes the first
    XR and a database resource. Let’s look at the details of each XR:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在单个XR中提供多个资源外，我们在*图5.8*中还展示了一个嵌套的XR模式。我们在两个XR中组合了三种资源。第一个XR组合了两种资源，第二个XR组合了第一个XR和一个数据库资源。让我们看一下每个XR的细节：
- en: '**XR 1**: We will compose a Google Kubernetes Engine cluster and a Google Cloud
    storage resource with this XR. The idea is to provide cloud storage to hold the
    application logs for future analysis. Note that this XR will not have a claim
    name in the XRD definition. It will be of a cluster scope and a private API for
    the platform team. Product teams with access only to a namespace will not use
    this API directly. This XR will expose the region and the autopilot configuration
    as parameters. The region will be propagated back into both the resources and
    the autopilot configuration is used for the Kubernetes provisioning.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XR 1**：我们将通过这个XR组合一个Google Kubernetes Engine集群和一个Google Cloud存储资源。目的是提供云存储来保存应用日志，以供未来分析。请注意，这个XR在XRD定义中不会包含声明名称。它将是集群范围的，并且是平台团队的私有API。只有拥有命名空间访问权限的产品团队才不会直接使用这个API。这个XR将把区域和自动驾驶配置作为参数暴露出来。区域将传递回两个资源，而自动驾驶配置用于Kubernetes的资源配置。'
- en: '**XR/Claim 2**: The second XR will compose the MySQL database, an MR, and the
    first XR to create a nested API. We will patch region parameters to the MySQL
    MR and propagate the same into the inner XR.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XR/声明 2**：第二个XR将组合MySQL数据库、一个MR和第一个XR，以创建一个嵌套的API。我们将把区域参数补丁应用到MySQL MR，并将其传递到内部的XR。'
- en: All examples in this hands-on journey are available at [https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本次实践旅程中的所有示例都可以在[https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR](https://github.com/PacktPublishing/End-to-End-Automation-with-Kubernetes-and-Crossplane/tree/main/Chapter05/Hand-on-examples/Nested-Multi-Resource-XR)找到。
- en: 'Let’s first create the XRD and Composition for both the XRs. Apply `xrd k8s.yaml`,
    `Composition k8s.yaml`, `xrd Application.yaml`, and `Composition Application.yaml`
    to the Crossplane cluster. You will see that the `ESTABLISHED` flag is `True`
    for both the XRDs. This indicates that the Crossplane has started a new controller
    to reconcile the established XR. The `OFFERED` flag will be `True` for the application
    XR and `False` for the Kubernetes XR. This indicates that the Crossplane has started
    a new controller to reconcile the established Claim only for the application XR.
    It is false for the Kubernetes XR because we don’t have the respective claim.
    Refer to the following screenshot regarding XRD creation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建这两个XR的XRD和Composition。将`xrd k8s.yaml`、`Composition k8s.yaml`、`xrd Application.yaml`和`Composition
    Application.yaml`应用到Crossplane集群中。你会看到两个XRD的`ESTABLISHED`标志都是`True`，这表示Crossplane已启动新的控制器来协调已建立的XR。`OFFERED`标志在应用XR中为`True`，在Kubernetes
    XR中为`False`，这表示Crossplane仅为应用XR启动了新的控制器来协调已建立的声明。而对于Kubernetes XR，由于我们没有相应的声明，`OFFERED`标志为`False`。请参阅以下截图，了解XRD的创建过程：
- en: '![Figure 5.9 – Nested XR-XRD and Composition'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 – 嵌套XR-XRD与组合'
- en: '](img/B17830_05_09.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_09.jpg)'
- en: Figure 5.9 – Nested XR-XRD and Composition
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 嵌套XR-XRD和组合
- en: Tip
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Similar to creating an XR API with multiple resources from a single cloud provider,
    we can also mix and match resources from multiple clouds. We just have to add
    the resources concerned with respective ProviderConfig clouds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用来自单一云提供商的多个资源创建XR API，我们还可以混合使用来自多个云的资源。我们只需添加与相应ProviderConfig云相关的资源。
- en: 'It’s now time to create an application Claim resource. Apply Claim `Application.yaml`
    to the Crossplane cluster. You will see that a `CloudSQLInstance` instance, a
    cluster, and a bucket resource have been provisioned. Refer to the following screenshot
    where the resources are provisioned successfully:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建应用程序声明资源了。将声明`Application.yaml`应用到Crossplane集群中。你将看到`CloudSQLInstance`实例、集群和存储桶资源已经被配置。请参考下面的截图，查看资源是否已成功配置：
- en: '![Figure 5.10 – Resource provisioning'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 资源配置'
- en: '](img/B17830_05_10.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_10.jpg)'
- en: Figure 5.10 – Resource provisioning
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 资源配置
- en: 'If you would like to explore each resource in detail, use the Resource references.
    Execute `kubectl describe application my-application -n alpha` to see the details
    of the claim. It will refer to the `XApplication` XR object. If we look at the
    details of the `XApplication` object, it will hold the reference to the `CloudSQLInstance`
    MR and `XGCPCluster` XR. Similarly, we can go on till you reach the last MR. This
    is beneficial for debugging activities. Sometimes you may see that the resources
    are not getting ready. In those instances, explore each nested resource and refer
    to the events section to ascertain what is happening. An example of referring
    nested resources from the resource description is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想详细查看每个资源，可以使用资源引用。执行`kubectl describe application my-application -n alpha`来查看声明的详细信息。它将引用`XApplication`
    XR对象。如果我们查看`XApplication`对象的详细信息，它将持有对`CloudSQLInstance` MR和`XGCPCluster` XR的引用。类似地，我们可以继续查看，直到到达最后的MR。这对于调试活动非常有用。有时你可能会发现资源没有准备好。在这种情况下，检查每个嵌套资源，并查看事件部分以确认发生了什么。以下是从资源描述中引用嵌套资源的示例：
- en: '![Figure 5.11 – Nested resource reference example 1'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – 嵌套资源引用示例 1'
- en: '](img/B17830_05_11.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_11.jpg)'
- en: Figure 5.11 – Nested resource reference example 1
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 嵌套资源引用示例 1
- en: 'The preceding screenshot represented the Application claim description referring
    to the `XApplication` XR resource. The following screenshot represents the `XApplication`
    XR description referring to the `XGCPCluster` XR instance and `CloudSQLInstance`
    MR:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图展示了应用程序声明描述，它引用了`XApplication` XR资源。下面的截图展示了`XApplication` XR描述，它引用了`XGCPCluster`
    XR实例和`CloudSQLInstance` MR：
- en: '![Figure 5.12 – Nested resource reference example 2'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 嵌套资源引用示例 2'
- en: '](img/B17830_05_12.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_12.jpg)'
- en: Figure 5.12 – Nested resource reference example 2
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 嵌套资源引用示例 2
- en: 'The following is an example event that tells us that we have provided the wrong
    region as a parameter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个事件示例，告诉我们提供了错误的区域参数：
- en: '![Figure 5.13 – Resource description with an error'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13 – 资源描述存在错误'
- en: '](img/B17830_05_13.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_13.jpg)'
- en: Figure 5.13 – Resource description with an error
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 资源描述存在错误
- en: Important
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: We need to follow many more patterns when we compose multiple resources to give
    a unified experience for product teams. The preceding example is a simple example
    to start the topic. We will see more on this in the upcoming chapters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们组合多个资源以为产品团队提供统一体验时，需要遵循更多的模式。前面的示例是一个简单的示例，用来引入这一话题。在接下来的章节中，我们将看到更多内容。
- en: PatchSets
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PatchSets
- en: 'If you look at the composition in the preceding example, you can see that we
    have used a new pattern called `patchSets` function definition to patch a region:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的示例中的组成部分，你会看到我们使用了一种新模式，称为`patchSets`函数定义，用于修补一个区域：
- en: '[PRE90]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can define multiple `patchSet` functions. To include a specific patch set
    function within a given resource, use the following code snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义多个`patchSet`函数。要在特定资源中包含某个补丁集函数，请使用以下代码片段：
- en: '[PRE96]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We will see more nested and multi-resource XR examples in the upcoming chapters.
    In the following section, we will look at detailed configuration options for defining
    the XRD schema.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到更多嵌套和多资源XR的示例。在接下来的部分中，我们将详细查看定义XRD架构的配置选项。
- en: XRD detailed
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XRD详细
- en: 'While looking at **Composite Resource Definition** (**XRD**) in the previous
    chapter, we touched on limited configuration options required to learn the basics
    of XR. It’s now time to look at more detailed configuration options to build clean
    and robust XR APIs. A significant part of the details we will look at are about
    openAPIV3Schema, which is used to define the input and output of the XR API. The
    following are the topics we will cover in this section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章节查看 **复合资源定义**（**XRD**）时，我们探讨了学习 XR 基础所需的有限配置选项。现在是时候查看更详细的配置选项，以构建干净且稳健的
    XR API。我们将深入探讨的一个重要部分是 openAPIV3Schema，它用于定义 XR API 的输入和输出。以下是我们将在本节中覆盖的主题：
- en: Naming the versions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名版本
- en: The openAPIV3Schema structure
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: openAPIV3Schema 结构
- en: The additional parameter of an attribute
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的附加参数
- en: Printer columns
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印列
- en: Let’s start with the *Naming the versions section*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 *命名版本部分* 开始。
- en: Naming the versions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名版本
- en: The version name of our XRD cannot have any random string. It has a specific
    validation inherited from the CRDs and standard Kubernetes APIs. The string can
    contain only lowercase alphanumeric characters and `-`. Also, it must always start
    with an alphabetic character and end with an alphanumeric character, which means
    that `-` cannot be the start or ending character. Also, a number cannot be the
    starting character. Some valid versions are `my-version`, `version-1`, `abc-version1`,
    and `v1`. While we can have many permutations and combinations for naming a version,
    some standard practices are followed across CRDs. Following the same with XRDs
    will enable API consumers to understand the stability of the API. The version
    string starts with `v` followed by a number with these standards (v1, v2). This
    is then optionally followed by either `alpha` or `beta`, depending on the API’s
    stability. Generally, the `alpha` string represents the lowest stability (`v5alpha`),
    while `beta` is the next stability level (`v3beta`). If both texts are missing,
    the XR is ready for production use. An optional number can follow the optional
    `alpha`/`beta` text representing the incremental releases (`v2alpha1`, `v2alpha2`,
    and so on).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 XRD 的版本名称不能包含任何随机字符串。它必须遵循从 CRD 和标准 Kubernetes API 继承的特定验证规则。该字符串只能包含小写字母数字字符和
    `-`。此外，版本名称必须始终以字母字符开头，以字母数字字符结尾，这意味着 `-` 不能是起始或结尾字符。同时，数字不能作为起始字符。一些有效的版本名称有
    `my-version`、`version-1`、`abc-version1` 和 `v1`。虽然我们可以为版本命名提供许多排列组合，但在 CRD 中遵循一些标准做法。遵循这些做法来命名
    XRD 可以帮助 API 使用者了解 API 的稳定性。版本字符串以 `v` 开头，后跟一个数字（例如 v1、v2）。然后可以选择性地跟随 `alpha`
    或 `beta`，以表示 API 的稳定性。通常，`alpha` 表示最低稳定性（`v5alpha`），而 `beta` 是下一个稳定性级别（`v3beta`）。如果这两者都缺失，表示
    XR 已准备好投入生产使用。可选的数字可以跟随在 `alpha`/`beta` 后面，表示增量发布（例如 `v2alpha1`、`v2alpha2` 等）。
- en: 'If you have an invalid version string provided with the XRD, you will see that
    the XRD will not get configured properly. The `ESTABLISHED` flag will not be set
    to `True`. You apply the `– xrd\ invalid\ version\ test.yaml` file from the `samples`
    folder to see what happens when you have an incorrect version number. Refer to
    the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的版本字符串无效，您会发现 XRD 无法正确配置。`ESTABLISHED` 标志不会被设置为 `True`。您可以使用来自 `samples`
    文件夹的 `– xrd\ invalid\ version\ test.yaml` 文件，查看在版本号不正确时会发生什么。请参阅以下截图：
- en: '![Figure 5.14 – Invalid version XRD'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14 – 无效版本 XRD'
- en: '](img/B17830_05_14.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_14.jpg)'
- en: Figure 5.14 – Invalid version XRD
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 无效版本 XRD
- en: 'Also, you will be able to see the following error logs in the Crossplane pod
    in the crossplane-system namespace:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以在 crossplane-system 命名空间中的 Crossplane pod 中看到以下错误日志：
- en: '[PRE99]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Tip
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When we troubleshoot an issue with Crossplane, logs from the Crossplane pod
    can help. Enable debugging mode by adding an argument, `--debug`, to the Crossplane
    pod. Similarly, we can even look at the provider’s container logs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们排查 Crossplane 问题时，来自 Crossplane pod 的日志可以提供帮助。通过向 Crossplane pod 添加参数`--debug`，可以启用调试模式。同样，我们也可以查看提供者容器的日志。
- en: The openAPIV3Schema structure
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: openAPIV3Schema 结构
- en: 'The specification of the XR API is defined using `openAPIV3Schema`. Every configuration
    element in the XRD under this section represents the input and output of the XR
    API:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: XR API 的规范是通过 `openAPIV3Schema` 定义的。XRD 中该部分的每个配置元素都表示 XR API 的输入和输出：
- en: '[PRE100]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Generally, we configure the `openAPIV3Schema` section with two objects, `spec`
    and `status`. The `spec` object represents the API input, while the `status` object
    represents the response. We can skip defining the `status` section in XRD if we
    don’t have any custom requirements. Crossplane would inject the standard status
    fields into the XR/Claim. Refer to the following code snippet representing the
    `openAPIV3Schema` configuration template for the XR API input and output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将`openAPIV3Schema`部分配置为两个对象，`spec`和`status`。`spec`对象代表API输入，而`status`对象代表响应。如果没有任何自定义要求，我们可以跳过在XRD中定义`status`部分。Crossplane会将标准的状态字段注入到XR/Claim中。参考以下代码片段，表示XR
    API输入输出的`openAPIV3Schema`配置模板：
- en: '[PRE105]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The schema configuration is all about a mix of `-` attributes, their types,
    and properties. An `attribute` type of `object` will hold a list of properties.
    For example, the root attribute `openAPIV3Schema:` is of the `object` type followed
    by a list of properties (`spec` and `status`). A list of properties is nothing
    but a list of attributes. Suppose the attribute type is primitive, such as `string`
    or `integer`. Such an attribute will be the end node. The object-properties recursion
    can continue in as much depth as we require. Refer to the following code snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 模式配置完全是由`-`属性、它们的类型和属性组成。`object`类型的`attribute`将包含一个属性列表。例如，根属性`openAPIV3Schema:`就是`object`类型，后面跟着一个属性列表（`spec`和`status`）。属性列表其实就是属性的列表。假设属性类型是原始类型，例如`string`或`integer`，那么这个属性就是终结节点。对象-属性递归可以根据需要继续深入。参考以下代码片段：
- en: '[PRE118]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: In the following section, we can look at a few additional valuable configuration
    options along with the basic `openAPIV3Schema` configuration.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将查看一些额外的有价值的配置选项，以及基本的`openAPIV3Schema`配置。
- en: The additional parameter of an attribute
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性的附加参数
- en: 'The attribute node can configure a few other critical configurations that API
    developers will use daily. Following are some of the frequently used configurations:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 属性节点可以配置一些API开发人员日常使用的其他关键配置。以下是一些常用的配置：
- en: '**Description** is a string that will help us provide valuable information
    for the API consumers about the attribute. It can hold information about the use
    of the parameter, possible values we can configure, and validation requirements.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**是一个字符串，可以帮助我们为API消费者提供有关该属性的有价值的信息。它可以包含关于参数使用的说明、我们可以配置的可能值以及验证要求。'
- en: '**Required** is an attribute representing the list of mandatory inputs that
    are required from the user for the API.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必需**是一个属性，表示用户在API中需要提供的必填输入列表。'
- en: '**Default** is an attribute that provides a default value if the user does
    not input a value.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认值**是一个属性，如果用户未输入值，则提供默认值。'
- en: '**Enum** can configure the list of possible values for a given attribute.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枚举**可以配置给定属性的可能值列表。'
- en: 'In addition to these fields, there is a list of validation-related configurations
    including `minimum`, `maximum`, `pattern`, `maxLength`, and `minLength`. Refer
    to the following sample configuration:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些字段外，还有一系列与验证相关的配置，包括`minimum`、`maximum`、`pattern`、`maxLength`和`minLength`。参考以下示例配置：
- en: '[PRE143]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: To explore more detailed possibilities, visit [https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索更多详细的可能性，请访问[https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject)。
- en: Tip
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We can use the description field to announce the parameter deprecation information.
    This technique can be helpful in delaying breaking changes to a contract by making
    a mandatory field optional with a deprecation message.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用描述字段来宣布参数的废弃信息。此技术有助于通过将必填字段变为可选字段并附上废弃消息，延迟对契约的破坏性更改。
- en: Printer columns
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印机列
- en: 'We can use the printer columns to add what `kubectl` will display when we get
    the resource list. We should provide a name, data type, and JSON path mapping
    to the attribute we wish to display for each column. Optionally, we may also provide
    a description. Refer to the following sample configuration:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用打印机列来添加`kubectl`在获取资源列表时显示的内容。我们应为每一列提供名称、数据类型和映射到我们希望显示的属性的JSON路径。可选地，我们还可以提供描述。参考以下示例配置：
- en: '[PRE168]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The printer column configuration remains parallel to the schema configuration.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 打印机列配置与模式配置保持平行。
- en: This concludes our discussion of detailed XRD configuration. We have covered
    most of the configuration required for day-to-day work, but there are endless
    possibilities. It will add value by reading up on CRD at [https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了详细的 XRD 配置，涵盖了日常工作所需的大部分配置，但仍有无限的可能性。通过阅读 [https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/)
    上的 CRD 相关内容，您将能进一步获得价值。
- en: Managing external software resources
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理外部软件资源
- en: 'We have always talked about managing external infrastructure resources using
    Crossplane from the beginning of this book. However, it does not always have to
    be just an infrastructure resource. We could even manage external software applications
    from Crossplane. For a software application to be able to work best with the Crossplane
    ecosystem, it must have the following qualities:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书一开始，我们就讨论了使用 Crossplane 管理外部基础设施资源。然而，这不一定仅仅是基础设施资源。我们甚至可以从 Crossplane 管理外部软件应用程序。为了让一个软件应用与
    Crossplane 生态系统兼容，它必须具备以下特点：
- en: We should have well-defined and stable APIs to perform CRUD operations.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该有明确定义且稳定的 API 来执行 CRUD 操作。
- en: The API should have a high-fidelity design with filters to control granular
    application configuration.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 应该具有高保真度的设计，并且需要过滤器来控制细粒度的应用配置。
- en: It’s time to look at an example. Think about deploying an application in Kubernetes
    using Helm. Helm can package any application and provide a well-defined CRUD API
    to deploy, read, update, and uninstall. Above all, we can create granular control
    over the application configuration with parameters. We have a helm Crossplane
    provider already available and used extensively by the community. The idea of
    managing external applications from a Crossplane control plane can enable a new
    world of unifying application and infrastructure automation. The following section
    will cover the unifying aspect in more detail.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候来看一个例子了。想象一下，在 Kubernetes 中使用 Helm 部署一个应用。Helm 可以打包任何应用，并提供一个定义明确的 CRUD
    API 用于部署、读取、更新和卸载。最重要的是，我们可以通过参数来实现对应用配置的细粒度控制。我们已经有一个 Helm Crossplane 提供程序，并且被社区广泛使用。通过
    Crossplane 控制平面管理外部应用程序的概念，可以开启一个统一应用和基础设施自动化的新世界。接下来的部分将详细介绍这一统一性方面。
- en: Unifying the automation
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一自动化
- en: 'Managing external software resources with Crossplane is the crossroad for unifying
    infrastructure and application DevOps. We could package software and infrastructure
    dependencies into a single XRs. Such a complete package of applications and infrastructure
    introduces numerous advantages, some of which are listed here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Crossplane 管理外部软件资源是统一基础设施和应用 DevOps 的关键。我们可以将软件和基础设施依赖打包成一个单一的 XR。这样完整的应用和基础设施包带来了许多优势，部分优势列举如下：
- en: The approach will unify the tooling and skills required for application and
    infrastructure automation.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法将统一应用和基础设施自动化所需的工具和技能。
- en: More importantly, the entire stack will enjoy the advantages of the Kubernetes
    operating model.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更重要的是，整个堆栈将享有 Kubernetes 操作模型的所有优势。
- en: Integrating vendor software into an enterprise ecosystem will become quicker
    and more standardized. Software vendors can quickly build packages that fit into
    different ecosystems. Currently, software vendors must custom-build for the individual
    cloud provider marketplace. This approach can assist in building a universal vendor
    software marketplace.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将供应商软件集成到企业生态系统中将变得更加迅速和标准化。软件供应商可以快速构建适配不同生态系统的包。目前，软件供应商必须为各个云服务提供商市场进行定制开发。这种方法可以帮助构建一个通用的供应商软件市场。
- en: We can easily apply the audit process to comply with any compliance standards.
    Previously, this would have been complicated as software and its infrastructure
    dependencies are spread about.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松地应用审计过程以遵守任何合规标准。之前，由于软件及其基础设施依赖分散，遵守合规要求会更加复杂。
- en: 'The following figure represents a unified XR API:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个统一的 XR API：
- en: '![Figure 5.15 – Unified XR'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15 – 统一的 XR'
- en: '](img/B17830_05_15.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_05_15.jpg)'
- en: Figure 5.15 – Unified XR
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 统一的 XR
- en: Important
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: In a later chapter, we can go through a hands-on journey to experience building
    an XR API covering both applications and infrastructure dependencies.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们可以通过实践体验，构建一个涵盖应用和基础设施依赖的 XR API。
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope it’s been fun to read this chapter and go through the hands-on journey.
    It covered different patterns that are useful in our day-to-day work when adopting
    Crossplane. We covered different ways to evolve our XR APIs, detailed XR configurations,
    how to manage application resources, and nested and multi-resource XRs. There
    are more patterns to be covered.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在阅读这一章并完成实践旅程时感到有趣。它介绍了在采用Crossplane时，我们日常工作中有用的不同模式。我们讨论了如何演化我们的XR API、详细的XR配置、如何管理应用资源以及嵌套和多资源XR。还有更多的模式需要涵盖。
- en: The next chapter will discuss more advanced Crossplane methods and their respective
    hands-on journeys.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论更高级的Crossplane方法及其相应的实践旅程。
