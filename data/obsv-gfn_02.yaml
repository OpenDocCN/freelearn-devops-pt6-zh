- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Instrumenting Applications and Infrastructure
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具化应用程序和基础设施
- en: The previous chapter introduced observability, with examples outside of the
    computing world to give you a generic understanding of the subject. In this chapter,
    we’ll build on those examples by providing a high-level overview of both application
    and infrastructure instrumentation. We will look at the data created by systems
    and how that fits into the different telemetry types and common protocols in use.
    We will also explore widely used libraries for popular programming languages that
    simplify instrumenting applications. To finish, we will cover more traditional
    telemetry collection from infrastructure components, operating systems, and network
    devices. This will give you insight into the components that are still in operation
    today that run applications and Kubernetes workloads. This chapter is aimed at
    readers of all technical abilities and no specific technologies are needed. An
    understanding of observability terminology (for example, logs, metrics, traces,
    and instrumentation) is helpful. It aims to provide an overview of the technology
    space and act as a valuable resource that you can quickly reference when you are
    working with your observability solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了可观察性，并通过计算机领域外的示例帮助你对该主题有了一个通用的理解。在本章中，我们将在这些示例的基础上，提供应用程序和基础设施工具化的高级概述。我们将查看系统生成的数据，并了解这些数据如何与不同的遥测类型和常用协议相适应。我们还将探索用于流行编程语言的广泛使用的库，这些库简化了应用程序的工具化过程。最后，我们将涵盖来自基础设施组件、操作系统和网络设备的更传统的遥测收集。这将使你了解今天仍在运行的应用程序和Kubernetes工作负载的组成部分。本章面向各类技术能力的读者，且不需要特定的技术背景。了解可观察性术语（例如：日志、指标、跟踪和工具化）将有所帮助。其目的是提供技术领域的概述，并作为一个有价值的资源，当你在使用可观察性解决方案时，可以快速查阅。
- en: 'In this chapter, we explore the following introductory sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下介绍性内容：
- en: Common log formats
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见日志格式
- en: Metrics protocols and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标协议和最佳实践
- en: Tracing protocols and best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪协议和最佳实践
- en: Using libraries to instrument efficiently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库进行高效的工具化
- en: Infrastructure data technologies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施数据技术
- en: Common log formats
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见日志格式
- en: Log files are a standard component of computer systems and an essential tool
    for software developers and operators – in our example, Diego and Ophelia, respectively.
    Logs support performance and capacity monitoring in infrastructure, bug detection
    in software, root cause analysis, user behavior tracking, and more. There is no
    perfect recipe for logs and as such, it does not matter what your logs look like,
    though following certain guidelines will help your future self when you need to
    analyze logs. In this section, we will learn about different log formats and how
    the data can be used. Log formats are the definition of what a log file looks
    like and should explain how the data can be interpreted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件是计算机系统的标准组件，是软件开发人员和运维人员（在我们的例子中分别是Diego和Ophelia）必不可少的工具。日志支持基础设施的性能和容量监控、软件中的错误检测、根本原因分析、用户行为追踪等功能。没有完美的日志格式，因此日志的外观并不重要，但遵循某些指南会在你需要分析日志时为未来的自己带来帮助。在本节中，我们将了解不同的日志格式以及如何使用数据。日志格式定义了日志文件的外观，并应解释如何解读数据。
- en: Log formats usually identify if they are structured or unstructured, the data
    types used in them, and if any encoding or delimitation is being used. We’ll explore
    structure first and then look at example log formats in more detail in the following
    sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 日志格式通常会标明它们是结构化还是非结构化，所使用的数据类型，以及是否使用了任何编码或分隔符。我们将首先探索结构化日志格式，然后在接下来的章节中更详细地查看示例日志格式。
- en: Structured, semi-structured, and unstructured logging
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化、半结构化和非结构化日志
- en: As mentioned previously, it does not matter what your logs look like and they
    can come in structured, semi-structured, or unstructured formats. However, when
    designing and building observability solutions, it’s important to understand the
    log formats you are working with. This ensures that you can ingest, parse, and
    store the data in a way that it can be used effectively. If you familiarized yourself
    with the personas in [*Chapter 1*](B18277_01.xhtml#_idTextAnchor018), you have
    an awareness of who they will be used by and for what purpose.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，日志的格式并不重要，您可以使用结构化、半结构化或非结构化的格式。但是，在设计和构建可观察性解决方案时，理解您正在使用的日志格式非常重要。这确保了您可以有效地导入、解析和存储数据。如果您已经熟悉[*第1章*](B18277_01.xhtml#_idTextAnchor018)中的角色，您会知道这些日志将由谁使用以及用途是什么。
- en: Structured logging
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构化日志
- en: '`name=Diego` or `city=Berlin`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`name=Diego` 或 `city=Berlin`。'
- en: 'Here is an example of a structured log format:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是结构化日志格式的一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An additional benefit of structured logging is that you can validate the conformation
    of the data to a schema with tools such as JSON schema. This opens up the possibility
    of making version control changes to the schema, which is where logs and event
    bus technology overlap.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化日志的一个额外好处是，您可以使用诸如 JSON schema 等工具验证数据与架构的一致性。这为对架构进行版本控制更改提供了可能性，而这正是日志和事件总线技术交集的地方。
- en: Semi-structured logging
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 半结构化日志
- en: '**Semi-structured logs** aim to bridge the gap between unstructured and structured
    and, as a result, can be quite complicated. They are designed to be easy for humans
    to read but also have a schema that makes it possible for machines to process
    them too. They have complex field and event separators and usually come with a
    defined pattern to aid with ingesting and parsing. Parsing is usually done using
    regular expressions or other code.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**半结构化日志**旨在弥合非结构化和结构化之间的差距，因此可能会相当复杂。它们设计上易于人类阅读，同时也有架构使机器能够处理它们。它们具有复杂的字段和事件分隔符，并且通常带有定义的模式以帮助导入和解析。解析通常使用正则表达式或其他代码完成。'
- en: Unstructured logging
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非结构化日志
- en: '**Unstructured logging** typically refers to log entries that are presented
    in a textual format that can easily be read by humans but is difficult for machines
    to process. They are often color-coded with blank spaces to improve presentation
    and readability. It is this presentation that creates issues for machines to process
    the logs. Parsing and splitting the data correctly creates a disassociation between
    events and their identifying metadata. An unstructured log will require some custom
    parsing, requiring intimate knowledge of the data and often creating additional
    work for the engineer (*Ophelia*) when ingesting data. This also creates technical
    liability; the dependency on the log remaining the same restricts developers from
    changing logs or runs the risk of parsing and reporting on unstructured logs prone
    to breaking.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**非结构化日志**通常指的是以文本格式呈现的日志条目，这种格式易于人类阅读，但对机器处理来说较为困难。它们通常通过颜色编码和空格来改善展示和可读性。正是这种展示方式使得机器难以处理这些日志。正确解析和拆分数据会导致事件与其标识元数据之间的断裂。非结构化日志需要一些定制的解析，这通常需要对数据有深入的了解，并且在导入数据时常常会给工程师（*Ophelia*）带来额外的工作。这也带来了技术上的责任；对日志保持一致性的依赖限制了开发者对日志的修改，或者有可能导致解析和报告非结构化日志时容易出现故障。'
- en: To aid the ability of machines to process unstructured logs, encapsulation prevents
    entries such as stack traces from splitting at an inappropriate location.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助机器处理非结构化日志，封装防止像堆栈跟踪这样的条目在不适当的位置被拆分。
- en: 'The following is an example of a multiline log, with a naive encapsulation
    that looks for line breaks; this will appear in logging systems as four distinct
    events:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个多行日志的示例，采用了寻找换行符的简单封装；这将在日志系统中显示为四个独立的事件：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With encapsulation based on the timestamp at the start of the event, this will
    be stored correctly for searching.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件开始时时间戳的封装，将确保日志正确存储以便检索。
- en: In the following section, we will explore common log formats found in today’s
    systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨今天系统中常见的日志格式。
- en: Sample log formats
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例日志格式
- en: 'Many log formats have been used in computer systems. All of these formats have
    a common goal of presenting a standard structure or set of fields for recording
    important information about the activity of a computer system. The following table
    aims to provide easy reference for some of the more notable ones:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多日志格式已在计算机系统中使用。所有这些格式的共同目标是呈现一个标准结构或字段集，用于记录计算机系统活动的关键信息。下表旨在提供一些更为显著的日志格式的简便参考：
- en: '| **Format** | **Overview** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **格式** | **概述** |'
- en: '| **Common Event** **Format** (**CEF**) | CEF is an open logging and auditing
    format from ArcSight that aims to provide a simple interface to record security-related
    events. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **通用事件** **格式**（**CEF**）| CEF 是 ArcSight 提供的一种开放式日志和审计格式，旨在提供一个简单的接口来记录与安全相关的事件。
    |'
- en: '| **NCSA** **Common Log** **Format** (**CLF**) | The NCSA CLF is historically
    used on web servers to record information about requests made to the server. This
    format has been extended by the CLF to include additional information about the
    browser (user-agent) and the referer. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **NCSA** **通用日志** **格式**（**CLF**） | NCSA CLF 历史上用于 Web 服务器记录对服务器的请求信息。该格式通过
    CLF 扩展，包含有关浏览器（用户代理）和来源的额外信息。 |'
- en: '| **W3C Extended Log** **File Format** | W3C Extended Log File Format is a
    log format commonly used by Windows Internet Information Services servers (web
    servers). |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **W3C 扩展日志** **文件格式** | W3C 扩展日志文件格式是 Windows Internet Information Services
    服务器（Web 服务器）常用的日志格式。 |'
- en: '| **Windows** **Event Log** | Windows Event Log is the standard log format
    used by the Windows operating system. These logs record events that occur on the
    system and are categorized System, Application, Security, Setup, and Forwarded
    events. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **Windows** **事件日志** | Windows 事件日志是 Windows 操作系统使用的标准日志格式。这些日志记录系统上发生的事件，并按系统、应用程序、安全、设置和转发事件进行分类。
    |'
- en: '| **JavaScript Object** **Notation** (**JSON**) | JSON is an open standard
    file format that is very useful for easily parsing structured log events. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **JavaScript 对象** **表示法**（**JSON**） | JSON 是一种开放标准文件格式，非常适合轻松解析结构化日志事件。 |'
- en: '| **Syslog** | Syslog is a standard that’s used across many hardware devices
    such as networking, compute, and storage, and is used by the Linux kernel for
    logging. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **Syslog** | Syslog 是一种标准，广泛用于许多硬件设备，如网络、计算和存储设备，也被 Linux 内核用于日志记录。 |'
- en: '| **Logfmt** | Logfmt does not have a defined standard but is a widely used
    form of human-readable structured logging. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **Logfmt** | Logfmt 没有定义的标准，但它是一种广泛使用的易于阅读的结构化日志格式。 |'
- en: Table 2.1 – Log format overview
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 日志格式概述
- en: Let’s look at these formats in greater detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这些格式。
- en: CEF
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CEF
- en: Developed by ArcSight to fulfill the **Security Information and Event Management**
    (**SIEM**) use case, the CEF is a structured text-based log format. Using UTF-8
    encoding, the format contains a prefix, a CEF header, and a body containing additional
    enrichment data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由 ArcSight 开发，旨在满足 **安全信息和事件管理**（**SIEM**）用例，CEF 是一种结构化的基于文本的日志格式。使用 UTF-8 编码，该格式包含前缀、CEF
    头部以及包含额外丰富数据的正文。
- en: 'The following table shows the log sections of the CEF format:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了 CEF 格式的日志部分：
- en: '| **Log Section** | **Description** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **日志部分** | **描述** |'
- en: '| Prefix | It combines the event timestamp and source hostname. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 它结合了事件时间戳和源主机名。 |'
- en: '| CEF header | It combines the following pieces of metadata:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '| CEF 头部 | 它结合了以下几项元数据：  '
- en: Software version
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件版本
- en: Vendor name
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 厂商名称
- en: Product name
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品名称
- en: Product version
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品版本
- en: Product event class identification code
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品事件类别标识码
- en: Event name
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件名称
- en: Event severity
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件严重性
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Body | It contains a list of key-value pairs |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 正文 | 它包含一个键值对列表 |'
- en: Table 2.2 – CEF format
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 – CEF 格式
- en: 'Here is an example CEF log event:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 CEF 日志事件的示例：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: NCSA CLF
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NCSA CLF
- en: As one of the oldest log formats used by web servers, the NCSA CLF has for a
    long time been the most common and well-known log formats. It has a fixed format
    text-based structure and therefore cannot be customized at all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Web 服务器使用的最古老的日志格式之一，NCSA CLF 长期以来一直是最常见和最知名的日志格式。它具有固定格式的文本结构，因此无法定制。
- en: 'Here is the NCSA CLF field list:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 NCSA CLF 字段列表：
- en: Remote host address
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机地址
- en: Remote log name
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程日志名称
- en: Username
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: Timestamp
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Request and protocol version
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和协议版本
- en: HTTP status code
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: Bytes sent
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的字节数
- en: Where data is missing from the log, a hyphen acts as a placeholder. Unsupported
    characters are replaced with the `+` symbol.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中缺失数据时，连字符充当占位符。无法支持的字符会被 `+` 符号替代。
- en: 'Here is an example NCSA CLF log:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 NCSA CLF 日志的示例：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: W3C Extended Log File Format
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: W3C扩展日志文件格式
- en: 'The Microsoft Internet Information Server log format known as W3C is a structured
    yet configurable format. Full control over the included fields ensures log files
    contain the most relevant data. Identification of the information or direction
    of flow is denoted using a string prefix: server (*S*), client (*C*), server to
    client (*SC*), and client to server (*CS*).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的互联网信息服务器日志格式W3C是一种结构化但可配置的格式。完全控制包含的字段，确保日志文件包含最相关的数据。信息或流向的标识通过字符串前缀表示：服务器（*S*）、客户端（*C*）、服务器到客户端（*SC*）和客户端到服务器（*CS*）。
- en: 'Here is the W3C Extended Log File Format field list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是W3C扩展日志文件格式字段列表：
- en: Timestamp
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Client IP
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端IP
- en: Server IP
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器IP
- en: URI-stem
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI主体
- en: HTTP status code
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: Bytes sent
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的字节数
- en: Bytes received
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收的字节数
- en: Time taken
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耗时
- en: Version
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本
- en: 'Here is an example W3C log:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个W3C日志示例：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Microsoft Windows Event Log
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微软Windows事件日志
- en: The Microsoft Windows operating system comes with a built-in complex structured
    logging system that captures data related to specific events on the operating
    system. There are four common Windows event log categories – system, application,
    security, and setup – and an additional special category for forwarded events.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Windows操作系统自带一个复杂的结构化日志系统，用于捕获与操作系统中特定事件相关的数据。Windows事件日志有四个常见的类别——系统、应用程序、安全性和设置——以及一个用于转发事件的特殊类别。
- en: 'Each event log is also one of five different types: information, warning, error,
    success audit, and failure audit. Windows Event Log is one of the most verbose
    log formats in use. It usually includes details such as timestamp, event ID, username,
    hostname, message, and category, making it invaluable in diagnosing problems.
    Windows event IDs are documented and searchable, so you can easily get detailed
    information regarding the log event; they are grouped into categories, narrowing
    down the area where the event occurred, which makes debugging very accurate.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件日志也有五种不同的类型：信息、警告、错误、成功审计和失败审计。Windows事件日志是使用中最详细的日志格式之一。它通常包括时间戳、事件ID、用户名、主机名、消息和类别等详细信息，这些信息在诊断问题时非常有价值。Windows事件ID有文档记录并可搜索，因此你可以轻松获取关于日志事件的详细信息；它们被分为不同的类别，缩小了事件发生的范围，这使得调试非常精确。
- en: 'Here is a trimmed example of Microsoft Windows Event Log:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个修剪过的微软Windows事件日志示例：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JSON
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON
- en: As one of the newer yet most commonly used log formats today, JSON is a structured
    format constructed from multiple key-value pairs. Using JSON, data can be nested
    into different layers while keeping the format easy to read. Additionally, different
    data types can be represented, such as string, number, Boolean, null, object,
    and array.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为今天新兴但最常用的日志格式之一，JSON是一种由多个键值对构成的结构化格式。使用JSON，数据可以嵌套成不同的层次，同时保持格式易于阅读。此外，JSON可以表示不同的数据类型，如字符串、数字、布尔值、空值、对象和数组。
- en: 'Here is an example JSON log file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个JSON日志文件示例：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Syslog
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Syslog
- en: The go-to log format for many years and still widely used, Syslog is a defined
    standard for creating and transmitting logs. The `514` and `6514`, with the latter
    being used for encryption.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog作为许多年来的标准日志格式，并且至今仍被广泛使用，是一种定义好的标准，用于创建和传输日志。`514`和`6514`是常见的端口，后者用于加密。
- en: The Syslog message format combines a standardized header and message holding
    the body of the log.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog消息格式结合了标准化的头部和包含日志正文的消息。
- en: 'Here is an example Syslog log:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Syslog日志示例：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logfmt
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Logfmt
- en: Logfmt is a widely used log format that fits as human readable and structured
    so that computers and people can both read it. A Logfmt-formatted log line consists
    of any number of key-value pairs that can be easily parsed. As there are no standards,
    it is easy to extend and perfect for developers to simply add more key-value pairs
    to the output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Logfmt是一种广泛使用的日志格式，既适合人类阅读又具有结构化，计算机和人类都能读取。Logfmt格式的日志行由任意数量的键值对组成，便于解析。由于没有标准，它很容易扩展，开发人员可以简单地向输出中添加更多键值对。
- en: 'Here is an example Logfmt log:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Logfmt日志示例：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exploring metric types and best practices
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索度量类型和最佳实践
- en: Metrics, along with logs, are an essential tool for software developers (*Diego*)
    and operators (*Ophelia*), providing them with indicators regarding the state
    of applications and systems. Resource usage data is great for monitoring a metric
    that captures numerical data over time. There are many different types of resources
    but some good examples would be CPU or RAM usage, the number of messages in a
    queue, and the number of received HTTP requests. Metrics are frequently generated
    and easily enriched with labels, attributes, or dimensions, making them efficient
    to search and ideal in determining if something is wrong, or different from usual.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 指标和日志是软件开发人员（*Diego*）和运维人员（*Ophelia*）的基本工具，为他们提供应用程序和系统状态的指示器。资源使用数据非常适合监控捕捉数值数据的指标。资源类型有很多种，但一些好的例子包括
    CPU 或 RAM 使用率、队列中消息的数量以及接收到的 HTTP 请求数量。指标通常会生成，并且可以轻松地通过标签、属性或维度进行增强，使它们在搜索时非常高效，并且在判断某些情况是否异常或不同于平时时非常理想。
- en: 'A metric commonly has the following fields:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指标通常具有以下字段：
- en: '**Name**: This uniquely identifies the metric'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：唯一标识该指标'
- en: '**Data point value(s)**: The data that’s stored varies by metric type'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据点值**：存储的数据根据指标类型有所不同'
- en: '**Dimensions**: Additional enrichment labels or attributes that support analysis'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维度**：支持分析的附加增强标签或属性'
- en: Metrics capture the behavior of the data they represent. CPU usage would go
    up and down between 0% and 100% usage, whereas the number of received HTTP requests
    could increase indefinitely. In the following section, we will look at metric
    types, which allow us to capture the behavior of the metric being collected.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 指标捕捉它们所代表的数据的行为。例如，CPU 使用率将在 0% 到 100% 之间波动，而接收到的 HTTP 请求的数量可能会无限增加。在接下来的部分，我们将查看指标类型，它们允许我们捕捉收集到的指标的行为。
- en: Metric types
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标类型
- en: 'Metrics vary in characteristics and structure. There are four common types
    of metrics, from simple single values to more complex values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 指标在特性和结构上有所不同。常见的四种指标类型从简单的单值到更复杂的值：
- en: '**Counter**: This metric represents the last increment value. This could be
    the incremental change from the last recording or the total increment since the
    recording started.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：该指标表示上次增量值。它可能是上次记录的增量变化，也可能是自记录开始以来的总增量。'
- en: 'Here are some examples of this metric:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是该指标的一些示例：
- en: The number of requests served
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的请求数量
- en: Tasks completed
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成的任务
- en: Errors reported
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告的错误
- en: How the value is reset to zero depends on the protocol used to collect them,
    so it is important to factor this in for your use case. The StatsD implementation
    resets the counter every time the value is flushed, and Prometheus resets the
    counter when the application process restarts.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如何将值重置为零取决于用于收集它们的协议，因此在你的用例中考虑这一点非常重要。StatsD 实现会在每次刷新值时重置计数器，而 Prometheus 会在应用进程重启时重置计数器。
- en: '**Gauge**: A gauge metric is a snapshot of state and can be used to take a
    measure of something reporting continuously. As such, it is usually made more
    useful by aggregating with sum, average, minimum, or maximum over a certain period.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：仪表指标是状态的快照，可以用来测量某些持续报告的事物。因此，它通常通过在一定时间段内汇总求和、平均值、最小值或最大值来变得更有用。'
- en: 'Here are some examples of this metric:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是该指标的一些示例：
- en: Temperature
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度
- en: Items in queue
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列中的项目
- en: Disk space used
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘空间使用情况
- en: Number of concurrent requests
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发请求数量
- en: Like counter, the definitions for gauge vary in implementation, so be sure to
    verify how the protocol you select will report gauge metrics.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和计数器一样，仪表的定义在实现上有所不同，因此请确保验证你选择的协议将如何报告仪表指标。
- en: '`_count`), a sum of all the values of the measurements (`_sum`), and several
    buckets that have a count of events with a measure less than or equal (`le`) to
    a defined value.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_count`（表示所有测量值的总和）、`_sum`（表示所有值的总和），以及几个桶，它们记录的事件数小于或等于（`le`）定义值。'
- en: Definitions can vary in implementation – for example, Prometheus has a `histogram_quantile`
    function that can be used to calculate percentiles from histogram metrics.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义可能在实现上有所不同——例如，Prometheus 有一个 `histogram_quantile` 函数，可以用来从直方图指标计算百分位数。
- en: '`_count` and `_sum` metrics and several groupings. Unlike a histogram, these
    groupings are a quantile, and the value represents the value of that quantile
    at the point in time for the measurement. For example, a quantile of 0.99 and
    a value of 3.2148 would indicate that 99% of the sampled data was smaller than
    3.2148.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_count` 和 `_sum` 度量以及几个分组。与直方图不同，这些分组是分位数，值表示在该时间点上该分位数的值。例如，0.99 的分位数和 3.2148
    的值表示 99% 的采样数据小于 3.2148。'
- en: Again, definitions can vary in implementation, so work out what your goals are
    from your metrics to ensure the capabilities are supported by your choice of protocol.
    It’s useful to note that, in Prometheus, summary metrics have a significant drawback
    in modern systems as they cannot be aggregated over multiple sources.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，定义可能因实现而有所不同，因此从度量中明确你的目标，以确保所选择的协议支持这些功能。值得注意的是，在 Prometheus 中，总结性度量在现代系统中有一个显著的缺点，即不能跨多个来源进行聚合。
- en: There are some distinct differences between these metric types, as we will discuss
    in the following section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些度量类型之间有一些明显的区别，正如我们将在接下来的章节中讨论的那样。
- en: Comparing metric types
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较度量类型
- en: 'The following table describes each type in general terms. When querying them,
    this provides a useful reference when approaching metric adoption:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格一般性地描述了每种类型。在查询时，当你接近度量标准的采纳时，这提供了一个有用的参考：
- en: '| **Consideration** | **Counter** | **Gauge** | **Histogram** | **Summary**
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **考虑因素** | **计数器** | **仪表** | **直方图** | **总结** |'
- en: '| Structure | Simple | Simple | Complex | Complex |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 结构 | 简单 | 简单 | 复杂 | 复杂 |'
- en: '| Can increase and decrease | No | Yes | No | No |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 可以增加和减少 | 否 | 是 | 否 | 否 |'
- en: '| Is an approximation | No | No | Yes | Yes |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 是近似值 | 否 | 否 | 是 | 是 |'
- en: '| Can calculate percentiles | No | No | Yes | Yes |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 可以计算分位数 | 否 | 否 | 是 | 是 |'
- en: '| Can use a rate function | Yes | No | No | No |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 可以使用速率函数 | 是 | 否 | 否 | 否 |'
- en: '| Can be queried with the `prometheus` `histogram_quantile` function | No |
    No | Yes | No |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 可以使用 `prometheus` `histogram_quantile` 函数查询 | 否 | 否 | 是 | 否 |'
- en: '| Can be aggregated across multiple series | Yes | Yes | Yes | No |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 可以跨多个系列进行聚合 | 是 | 是 | 是 | 否 |'
- en: Table 2.3 – Comparison of metric types
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 – 度量类型比较
- en: 'The following table provides a few reference examples of the type and values
    expected:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了一些参考示例，列出了预期的类型和值：
- en: '| **Metric Type** | **Data Field** | **Value** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **度量类型** | **数据字段** | **值** |'
- en: '| **Counter** | Last increment | 15 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **计数器** | 最后增量 | 15 |'
- en: '| **Gauge** | Last value | 25.4 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **仪表** | 最后值 | 25.4 |'
- en: '| **Histogram** | Min | 0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **直方图** | 最小值 | 0 |'
- en: '| Max | 100 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 最大值 | 100 |'
- en: '| Count | 10 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 计数 | 10 |'
- en: '| **Interval** | 20 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **间隔** | 20 |'
- en: '| 0-20 | 1 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 0-20 | 1 |'
- en: '| 20-40 | 2 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 20-40 | 2 |'
- en: '| 40-60 | 4 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 40-60 | 4 |'
- en: '| 60-80 | 2 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 60-80 | 2 |'
- en: '| 80-100 | 1 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 80-100 | 1 |'
- en: '| **Summary** | Min | 1.2ms |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **总结** | 最小值 | 1.2ms |'
- en: '|  | Max | 4.23ms |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  | 最大值 | 4.23ms |'
- en: '|  | Count | 10 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  | 计数 | 10 |'
- en: '|  | Sum |  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  | 总和 |  |'
- en: '|  | **Percentiles/Quantiles** |  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  | **百分位数/分位数** |  |'
- en: '|  | P90 | 2.98ms |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  | P90 | 2.98ms |'
- en: '|  | P95 | 3.76ms |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  | P95 | 3.76ms |'
- en: '|  | P99 | 4.23ms |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  | P99 | 4.23ms |'
- en: Table 2.4 – Metric type example data
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.4 – 度量类型示例数据
- en: Now that we’ve looked at the different types of metrics, let’s look at the different
    technologies used to transmit metrics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了不同类型的度量标准，让我们来看一下用于传输度量标准的不同技术。
- en: Metric protocols
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 度量协议
- en: '**Metric protocols** are collections of tools and libraries for instrumenting
    applications, data formats to transmit, clients to collect data, and often storage
    and visualization tools. Some common protocols that are in use today are described
    in the following table:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**度量协议** 是一组用于对应用程序进行仪表化的工具和库，数据格式用于传输，客户端用于收集数据，通常还包括存储和可视化工具。以下表格描述了一些当前使用的常见协议：'
- en: '| **Metric Protocol** | **Features** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **度量协议** | **特性** |'
- en: '| **StatsD** | It supports the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '| **StatsD** | 它支持以下内容：'
- en: Counters
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器
- en: Gauges
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表
- en: Timers
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: Histograms
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图
- en: Meters
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 米
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **DogStatsD** | DogStatsD implements the StatsD protocol and adds a few Datadog-specific
    extensions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '| **DogStatsD** | DogStatsD 实现了 StatsD 协议，并添加了几个 Datadog 特有的扩展：'
- en: Histogram metric type
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图度量类型
- en: Service checks
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务检查
- en: Events
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Tagging
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **OpenTelemetry** **Protocol** (**OTLP**) | It supports the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '| **OpenTelemetry** **协议** (**OTLP**) | 它支持以下内容：'
- en: Counters
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器
- en: Gauges
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表
- en: Histograms
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图
- en: Summaries (legacy support)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结（遗留支持）
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Prometheus** | It supports the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Prometheus** | 它支持以下内容：'
- en: Counters
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器
- en: Gauges
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表
- en: Cumulative histograms
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积直方图
- en: Summaries
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 2.5 – Common metric protocols and their features
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.5 – 常见度量协议及其特性
- en: Metrics are very powerful, but some pitfalls can catch people out. Some of these
    can lead to expensive mistakes. To avoid these pitfalls, let’s discuss some best
    practices.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 指标非常强大，但一些陷阱可能会让人掉进误区。其中一些可能导致昂贵的错误。为了避免这些陷阱，让我们讨论一些最佳实践。
- en: Best practices for implementing metrics
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施指标的最佳实践
- en: 'Introducing metrics into your services is a very good way to gain a huge amount
    of visibility on how they behave in real situations. The following best practices
    are from our experience with metrics and will help you manage scope creep, cost,
    and linking metrics up with traces:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将指标引入你的服务是获取它们在实际情况下行为的大量可见性的一个非常好的方法。以下最佳实践来自我们在指标方面的经验，将帮助你管理范围膨胀、成本以及将指标与追踪连接起来：
- en: '**Set your objectives**: Work out what your objectives are from your metrics.
    We have already spoken about the variation in implementation between metric protocols
    – this can have a big impact if you are expecting to use a metric in a certain
    way and haven’t factored in nuances.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设定目标**：明确从指标中得到什么样的目标。我们已经讨论过指标协议之间的实现差异——如果你期望以某种方式使用指标，但没有考虑到细微差别，这会产生很大的影响。'
- en: This will also help you define **service-level indicators** (**SLIs**) and **service-level
    objectives** (**SLOs**), which will be useful in [*Chapter 9*](B18277_09.xhtml#_idTextAnchor183),
    *Managing Incidents* *Using Alerts*.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也将帮助你定义**服务级指标**（**SLIs**）和**服务级目标**（**SLOs**），它们将在[*第9章*](B18277_09.xhtml#_idTextAnchor183)中派上用场，*事件管理*
    *通过警报管理*。
- en: '**Manage cardinality**: Cardinality is generally defined as the number of unique
    elements in a set. High cardinality may provide richer, more useful data, but
    at the cost of monitoring performance impacts or increased storage costs. For
    example, if you dimension your metrics by server name, the sample could be small,
    maybe a few hundred metrics. If we compare this to dimensioning by user, which
    could be in the millions, the increase in the number of metrics produced is exponential.
    This increase has a direct impact on load and storage.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理基数**：基数通常被定义为集合中唯一元素的数量。高基数可能提供更丰富、更有用的数据，但也会带来对监控性能的影响或增加存储成本。例如，如果你按服务器名称来划分你的指标，样本可能很小，也许只有几百个指标。如果与按用户来划分进行比较，可能会达到数百万个，生产的指标数量呈指数增长。这种增加直接影响负载和存储。'
- en: Take time to understand the capabilities of the observability backend – things
    such as the billing framework, limitations, storage, and performance.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 花时间了解可观测性后端的能力——如计费框架、限制、存储和性能等方面。
- en: '**Add context**: The ability to correlate (establish a common identifier) metrics
    with traces has been introduced to Grafana and Open Telemetry recently with exemplars.
    They enable quick visualization and linking between a metric data point and a
    specific trace span, thus giving improved context and detail to your data.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加上下文**：最近，Grafana和Open Telemetry引入了通过示例来关联（建立共同标识符）指标与追踪的能力。它们能够快速可视化并将指标数据点与特定的追踪跨度关联，从而为你的数据提供更丰富的上下文和细节。'
- en: As we just discussed, metrics capture numerical data from a single service;
    however, the systems that operate today may consist of multiple services. Distributed
    tracing is a way to gain visibility of the communications between services. Let’s
    take a look at tracing protocols and some best practices regarding them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的那样，指标捕获来自单一服务的数值数据；然而，今天运作的系统可能由多个服务组成。分布式追踪是获取服务之间通信可见性的一种方式。让我们来看看追踪协议以及一些相关的最佳实践。
- en: Tracing protocols and best practices
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪协议和最佳实践
- en: '**Tracing**, or as it is more commonly referred to, **distributed tracing**,
    tracks application requests as they are made between services of a system. It
    allows you to follow a single request through an entire system or look at the
    aggregate data over requests to better understand distributed behavior.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**追踪**，或更常见的术语**分布式追踪**，跟踪应用程序请求在系统各服务之间的传递。它允许你跟踪单个请求穿越整个系统，或查看跨请求的聚合数据，从而更好地理解分布式行为。'
- en: This capability provides software developers (*Diego*), operators (*Ophelia*),
    and service managers (*Steven*) with valuable tools that enable an understanding
    of the flow of logic that is essential for troubleshooting. Instrumenting your
    code by adding traces helps you easily pinpoint almost any issue or at least have
    a clear indicator of where the problem could be. **Distributed tracing** uses
    the concepts of spans and traces to capture this data. Let’s examine these in
    more detail.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能为软件开发人员（*Diego*）、运维人员（*Ophelia*）和服务经理（*Steven*）提供了宝贵的工具，帮助理解对于故障排除至关重要的逻辑流。通过在代码中添加追踪来进行仪器化，能帮助你轻松定位几乎所有问题，或者至少能明确指出问题可能所在的位置。**分布式追踪**使用
    spans 和追踪的概念来捕获这些数据。让我们更详细地研究这些概念。
- en: Spans and traces
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spans 和追踪
- en: 'The **trace record** is the parent object that represents the data flow or
    execution path through the system being observed. Each **trace** will contain
    one or more **span** records that represent the logical operations. This relationship
    between traces and spans is illustrated in the following figure, in what can be
    thought of as a directed acyclic graph of spans:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**追踪记录**是表示通过被观察系统的数据流或执行路径的父对象。每个**追踪**将包含一个或多个**span**记录，代表逻辑操作。追踪和 span
    之间的关系如下图所示，可以将其视为 span 的有向无环图：'
- en: '![ Figure 2.1 – Traces and spans](img/B18277_02_1.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 追踪与 span](img/B18277_02_1.jpg)'
- en: Figure 2.1 – Traces and spans
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 追踪与 span
- en: 'A trace is pieced together from multiple spans and would usually report the
    following information:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个追踪是由多个 span 拼接而成，通常会报告以下信息：
- en: '**Identifier**: Uniquely identifies the trace'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**：唯一标识追踪'
- en: '**Name**: Describes the overall work being recorded'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：描述记录的总体工作'
- en: '**Timing details**: Provides the start and end timestamps for the complete
    trace'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间详细信息**：提供完整追踪的开始和结束时间戳'
- en: 'A span commonly has the following fields:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 span 通常包含以下字段：
- en: '**Trace identifier**: Establishes the trace relationship'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追踪标识符**：建立追踪关系'
- en: '**Identifier**: Uniquely identifies the span'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**：唯一标识 span'
- en: '**Parent span identifier**: Establishes a parent relationship'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父 span 标识符**：建立父关系'
- en: '**Name**: Describes the work being recorded'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：描述正在记录的工作'
- en: '**Timing details**: Provides the start and end timestamps'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间详细信息**：提供开始和结束时间戳'
- en: A trace identifier will be automatically generated if one has not been received
    by the calling operation; each application will pass the trace ID along to the
    next.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用操作未接收到追踪标识符，则将自动生成一个追踪标识符；每个应用程序将把追踪 ID 传递给下一个操作。
- en: The start and end timestamps for the operation help identify which stages are
    taking the most time. You can drill down to identify dependencies on other services
    and how they contribute to the overall trace timings.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的开始和结束时间戳有助于识别哪个阶段消耗了最多的时间。您可以深入分析，识别对其他服务的依赖关系，以及它们如何影响整体追踪时间。
- en: Spans can often have additional fields that are specific to the protocol implemented.
    Investigating the options against your use case will help provide the right diagnostics
    for your system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Span 通常可以有一些特定于实现协议的附加字段。根据您的使用案例进行调查，有助于为您的系统提供正确的诊断。
- en: Tracing protocols
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪协议
- en: 'As with all technology, standards have taken a while to be formalized for tracing,
    and a few protocols have been implemented. Some common protocols that are in use
    today are described in the following table:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有技术一样，追踪的标准化花了一些时间，目前已经实现了几种协议。当前使用的一些常见协议如下表所示：
- en: '| **Protocol Name** | **Features** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **协议名称** | **特性** |'
- en: '| OTLP | It supports the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '| OTLP | 它支持以下内容：'
- en: Additional fields
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外字段
- en: Span attributes (metadata about the operation)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 属性（关于操作的元数据）
- en: Context propagation
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文传播
- en: Span events (meaningful point-in-time annotation)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 事件（有意义的时间点注释）
- en: Span links (imply a causal relationship between spans)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 链接（表示 span 之间的因果关系）
- en: Span kind (additional details supporting the assembly of a trace)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 类型（支持构建追踪的附加详细信息）
- en: '|'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Zipkin | It supports the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '| Zipkin | 它支持以下内容：'
- en: Additional fields
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外字段
- en: Span tags (metadata about the operation)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 标签（关于操作的元数据）
- en: Context propagation
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文传播
- en: Span annotations (such as OTLP events and meaningful point-in-time annotation)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 注释（例如 OTLP 事件和有意义的时间点注释）
- en: Span kind (additional details supporting the assembly of a trace)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 类型（支持构建追踪的附加详细信息）
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Jaeger | It supports two formats – Jaeger Thrift and Jaeger Proto – with
    similar characteristics. Jaeger Proto has been discontinued in favor of OTLP.It
    supports the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '| Jaeger | 它支持两种格式 —— Jaeger Thrift 和 Jaeger Proto —— 特性相似。Jaeger Proto 已被弃用，转而支持
    OTLP。它支持以下内容：'
- en: Additional fields
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外字段
- en: Span tags (metadata about the operation)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 标签（关于操作的元数据）
- en: Context propagation (Thrift only; Proto does not support this)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文传播（仅 Thrift 支持；Proto 不支持）
- en: Span logs (meaningful point-in-time annotation)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 日志（有意义的时间点注解）
- en: Span references (imply a causal relationship between spans)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 引用（表示 span 之间的因果关系）
- en: Span kind (similar to OTLP, this is stored as a special type of span tag)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Span 类型（类似于 OTLP，这作为一种特殊类型的 span 标签存储）
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 2.6 – Distributed tracing protocols and features
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.6 – 分布式追踪协议和特性
- en: Implementing distributed tracing can be a daunting task, so let’s discuss some
    best practices that will help you avoid common mistakes and issues.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实施分布式追踪可能是一项艰巨的任务，接下来我们将讨论一些最佳实践，帮助你避免常见的错误和问题。
- en: Best practices for setting up distributed tracing
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置分布式追踪的最佳实践
- en: So far, we have described how traces will help you with problem resolution.
    However, when producing traces, it’s worth considering the additional system visibility
    against cost and performance impacts. Let’s discuss some of the best practices
    that should be considered when implementing tracing on any application or system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了追踪如何帮助你解决问题。然而，在生成追踪时，值得考虑额外的系统可见性与成本和性能影响之间的平衡。接下来让我们讨论一些在实施追踪时应考虑的最佳实践。
- en: Performance
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能
- en: The process of generating trace information can potentially incur a performance
    overhead at the application level. Mix this with the reduced level of control
    with auto-instrumentation and the problem can increase.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 生成追踪信息的过程可能会在应用层面产生性能开销。结合自动仪器监控减少的控制力，这个问题可能会加剧。
- en: 'Here are some of the possible impacts to consider:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的可能影响：
- en: Increased latency
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加的延迟
- en: Memory overhead
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存开销
- en: Slower startup time
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时间较慢
- en: Some of the more recent observability agents have addressed a lot of the issues
    with configurable options. For example, the OpenTelemetry Collector offers a sampling
    configuration that will submit 0% to 100% of spans to the collection tool. This
    sampling implementation will also notify any downstream services that the parent
    sampled its span so that the full trace will be collected.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较新的可观察性代理解决了许多问题，提供了可配置选项。例如，OpenTelemetry Collector 提供了一种采样配置，允许提交 0% 到 100%
    的 span 到收集工具。此采样实现还会通知任何下游服务，父级采样了它的 span，从而确保收集到完整的追踪。
- en: Cost
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成本
- en: Increased network and storage costs can become a factor and need factoring in
    as a limitation when designing your observability solution. However, this does
    depend on your observability backend and if you are doing additional processing
    or filtering when the data is being transmitted.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 增加的网络和存储成本可能成为一个因素，在设计你的可观察性解决方案时需要考虑作为限制条件。然而，这取决于你的可观察性后端以及你是否在数据传输过程中进行额外的处理或过滤。
- en: 'The mitigation practices are as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解措施如下：
- en: '**Sampling**: Only sends a percentage of traces'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样**：仅发送一定比例的追踪'
- en: '**Filtering**: Restricts which traces are transmitted and stored'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：限制哪些追踪被传输和存储'
- en: '**Retention**: Sets optimal data storage durations'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保留**：设置最佳的数据存储时长'
- en: Accuracy
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准确性
- en: To ensure one of the major benefits of tracing is implemented, it is important
    to ensure context propagation is working correctly. Without the relationships
    being established between the operations, spans will be broken across multiple
    traces. Validating and solving this problem will increase the usability and adoption
    of tracing for fast issue resolution.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保追踪的一个主要好处得以实现，必须确保上下文传播正常工作。如果操作之间没有建立关系，span 将会在多个追踪中断开。验证并解决这个问题将提高追踪的可用性和采用率，从而加速问题解决。
- en: With most code, libraries are used so that developers can focus on writing code
    that provides value to the organization. The modern libraries that are available
    will help you instrument quickly so that you can start using the data collected
    from your application. We’ll explore this next.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数代码，使用库是为了让开发人员能够专注于编写为组织创造价值的代码。现代库的使用将帮助你快速进行仪器监控，从而能够开始使用从应用程序收集的数据。接下来我们将探讨这一点。
- en: Using libraries to instrument efficiently
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库来高效地进行仪器监控
- en: 'Instrumenting your application code to emit the telemetry of logs, metrics,
    and traces can be complex, time-consuming, and difficult to maintain. There are
    two main approaches to solving this problem – automatic instrumentation and manual
    instrumentation – with a wide selection of SDKs and libraries available to support
    them. Here is a brief overview of them:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序代码进行仪器化，以发出日志、度量和追踪的遥测数据可能会很复杂、耗时，并且难以维护。解决这个问题的主要方法有两种——自动化仪器化和手动仪器化——并且有许多SDK和库可供支持。以下是它们的简要概述：
- en: '**Automatic instrumentation**: Automatic instrumentation is the simplest to
    implement but can lack the level of control that’s often required when building
    an observability platform. In a very short space of time, it will provide visibility
    into your application and help you start answering your observability questions.
    Without careful configuration and design, this will lead to other problems such
    as performance and cost issues, and, in the worst case, render the observability
    platform useless.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化仪器化**：自动化仪器化是最简单实现的方式，但在构建可观察性平台时，往往缺乏所需的控制级别。在非常短的时间内，它将为你的应用程序提供可视化，并帮助你开始回答可观察性相关的问题。如果没有仔细的配置和设计，这可能会导致性能和成本等问题，最坏的情况是让可观察性平台变得无用。'
- en: The approach varies depending on the programming language; for example, code
    manipulation (during compilation or at runtime) is often used with Java, whereas
    monkey patching (updating behavior dynamically at runtime) is often used with
    Python and JavaScript.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法取决于编程语言；例如，Java通常使用代码操作（在编译或运行时），而Python和JavaScript则通常使用猴子补丁（在运行时动态更新行为）。
- en: '**Manual instrumentation**: Manual instrumentation can be quite complex, depending
    on the systems being instrumented. It requires an intimate knowledge of the application
    code, with the benefit of allowing you to specify exactly what telemetry you want.
    Additionally, you need to understand the observability API you are working with.
    Though SDKs and libraries have simplified this, a lot of work must be done to
    understand the implementation.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动仪器化**：手动仪器化可能相当复杂，具体取决于被仪器化的系统。它需要对应用程序代码有深入的了解，优点是能够精确指定你需要的遥测数据。此外，你还需要了解你正在使用的可观察性API。尽管SDK和库简化了这一过程，但仍然需要做大量的工作来理解其实现。'
- en: If you are interested in further reading about application instrumentation,
    there is an excellent section dedicated to the subject in Alex Boten’s book *Cloud-Native
    Observability with OpenTelemetry*, by Packt Publishing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣进一步阅读应用程序仪器化的内容，Alex Boten的《Cloud-Native Observability with OpenTelemetry》一书中有一个关于该主题的精彩章节，出版商为Packt
    Publishing。
- en: Now that we’ve seen how various libraries approach instrumentation, let’s look
    at some of the common libraries that are used in different languages.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了各种库如何进行仪器化，接下来我们来看一下在不同语言中常用的一些库。
- en: Popular libraries for different programming languages
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同编程语言的流行库
- en: There have been many telemetry solutions, SDKs, and libraries over the years;
    however, in more recent history, there has been a concerted effort to align on
    supporting the OpenTelemetry standard. With its goal to provide a set of standardized
    vendor-agnostic SDKs, APIs, and tools for ingesting, transforming, and transporting
    data to an observability backend platform, there are obvious benefits. We will
    look at the OpenTelemetry libraries in this section to focus on where the most
    enhancements are currently. However, investigating what is appropriate for your
    use case is important. One drawback of this concerted development effort is that
    it creates a fast-changing landscape, so you have to pay attention to release
    stability and monitor for changes and improvements.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来已经有很多遥测解决方案、SDK和库；然而，近年来，大家共同努力致力于支持OpenTelemetry标准。其目标是提供一套标准化的供应商中立的SDK、API和工具，用于接收、转换和传输数据到可观察性后端平台，这带来了明显的好处。在本节中，我们将关注OpenTelemetry库，重点是目前的改进之处。然而，研究哪些适合你的用例是很重要的。这个集中的开发努力的一个缺点是它创造了一个快速变化的环境，因此你需要关注发布的稳定性并监控变化和改进。
- en: 'Here are some of the available instrumentation libraries:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用的仪器化库：
- en: '| **Language** | **SDKs** **and Libraries** | **Notes** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **语言** | **SDK和库** | **备注** |'
- en: '| JavaScript | OpenTelemetry JavaScript SDK | Multiple resources and examples
    are available that cover Node.js and browser implementations. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | OpenTelemetry JavaScript SDK | 提供了多个资源和示例，涵盖了 Node.js 和浏览器实现。
    |'
- en: '| JavaScript | OpenTelemetry JavaScript Contrib | An additional repository
    for OpenTelemetry JavaScript contributions that are not part of the core repository
    and core distribution of the API and the SDK. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | OpenTelemetry JavaScript Contrib | 这是一个额外的 OpenTelemetry JavaScript
    存储库，用于存放那些不属于核心存储库和核心 API、SDK 分发包的贡献。 |'
- en: '| Python | OpenTelemetry Python SDK | At the time of writing, both traces and
    metrics are stable, with logs in an experimental state. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| Python | OpenTelemetry Python SDK | 写作时，追踪和指标已经稳定，日志处于实验状态。 |'
- en: '| Python | OpenTelemetry Python Contrib | An additional repository for OpenTelemetry
    Python contributions. At the time of writing, Contrib libraries are in beta and
    active development. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| Python | OpenTelemetry Python Contrib | 这是一个额外的 OpenTelemetry Python 存储库。写作时，Contrib
    库处于 beta 阶段，并且在积极开发中。 |'
- en: '| Java | OpenTelemetry Java SDK | There is a long list of supported libraries
    and frameworks with good documentation to get you started. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| Java | OpenTelemetry Java SDK | 有一长串支持的库和框架，且提供了良好的文档，帮助你入门。 |'
- en: '| Java | Spring Boot/Micrometer | As of Spring Boot 3, the default exporter
    for Micrometer is OTLP. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| Java | Spring Boot/Micrometer | 从 Spring Boot 3 开始，Micrometer 的默认导出器是 OTLP。
    |'
- en: Table 2.7 – Common libraries and SDKs for telemetry
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.7 – 常见的遥测库和 SDK
- en: Applications are only one part of the computer systems we work with today. Our
    infrastructure components, such as switches, servers, Kubernetes clusters, and
    more, are just as important to observe. We’ll discuss how we can do this in the
    next section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序只是我们今天使用的计算机系统的一部分。我们的基础设施组件，例如交换机、服务器、Kubernetes 集群等，同样需要被观察。我们将在下一节讨论如何进行这些观察。
- en: Infrastructure data technologies
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施数据技术
- en: So far in this chapter, we have focused on implementations that work well for
    cloud technologies and containerized platforms. Underneath all of the abstraction
    are physical components, the servers running the workloads, the network and security
    devices handling communications, and the power and cooling components that keep
    things running. These have not dramatically changed over time and neither has
    the telemetry reported by the logs and metrics. Let’s take a look at the common
    infrastructure components and standards used in this area.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们集中讨论了适用于云技术和容器化平台的实现。所有这些抽象背后是物理组件，包括运行工作负载的服务器、处理通信的网络和安全设备、以及保持系统运行的电力和冷却组件。这些内容随着时间的推移并没有发生剧烈变化，日志和指标所报告的遥测数据也是如此。接下来我们将看看这一领域常见的基础设施组件和标准。
- en: Common infrastructure components
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的基础设施组件
- en: Infrastructure can largely be categorized into some broad categories, as we
    will discuss in the following sections. The types of data you can collect will
    differ on the category of the component.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施可以大致分为几个广泛的类别，正如我们将在接下来的章节中讨论的那样。你可以收集的数据类型会根据组件类别的不同而有所变化。
- en: Compute or bare metal
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算或裸金属
- en: Servers are often referred to as **bare metal** or compute; these are physical
    devices that are used for computation. Often, these systems would run virtualized
    operating systems that can collect server telemetry. Usually, you will run an
    agent on the operating system that scrapes metrics or reads log files and then
    transports them to a receiver. The data that’s obtained from server equipment
    can not only help in diagnosing and responding to issues but can help predict
    capacity problems that may arise in the future. Often, these devices can send
    data outside of any virtual operating system as well.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通常被称为 **裸金属** 或计算设备；它们是用于计算的物理设备。这些系统通常运行虚拟化的操作系统，这些操作系统可以收集服务器遥测数据。通常，你会在操作系统上运行一个代理，抓取指标或读取日志文件，然后将数据传输到接收器。通过服务器设备获得的数据不仅有助于诊断和响应问题，还能帮助预测可能出现的容量问题。这些设备通常也可以将数据发送到任何虚拟操作系统外部。
- en: 'For instance, here are a few telemetry examples that can indicate if a system
    is close to capacity in any area:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一些可以表明系统是否接近任何领域容量限制的遥测示例：
- en: System temperature
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统温度
- en: CPU utilization percent
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 利用率百分比
- en: Overall disk space used and remaining
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体磁盘空间使用和剩余空间
- en: Memory usage and free memory
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用和剩余内存
- en: Network devices
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络设备
- en: Network and security devices such as switches and firewalls come with the capability
    to send monitoring information via SNMP to a receiver. Firewalls can often send
    Syslog-formatted logs to a receiver. The telemetry provided helps diagnose issues
    with connectivity – for example, latency and throughput are difficult to investigate
    without information from the hardware.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和安全设备，如交换机和防火墙，通常具有通过 SNMP 向接收器发送监控信息的能力。防火墙通常可以将 Syslog 格式的日志发送到接收器。提供的遥测数据有助于诊断连接问题——例如，没有硬件提供的信息，延迟和吞吐量是很难调查的。
- en: 'Here are some telemetry examples:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些遥测示例：
- en: Latency
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟
- en: Throughput
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量
- en: Packet loss
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢包
- en: Bandwidth
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽
- en: Power components
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电源组件
- en: The components that provide power or cooling are often built with the capability
    to emit telemetry over SNMP to a receiver. Some older components will implement
    the Modbus protocol and expose registers that can be read to obtain metrics. The
    telemetry reported at this level is simplistic but essential when you are operating
    your data center. If, for example, you are running on backup power, you need to
    react fast to protect the systems or trigger other mitigation activities.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 提供电力或冷却功能的组件通常具有通过 SNMP 向接收器发送遥测数据的能力。一些较旧的组件会实现 Modbus 协议，并公开可以读取的寄存器，以获取度量信息。这个层级报告的遥测数据虽然简化，但在操作数据中心时是至关重要的。例如，如果你正在使用备用电源，你需要迅速做出反应，保护系统或触发其他缓解活动。
- en: 'Here are some telemetry examples:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些遥测示例：
- en: Power supply state
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源状态
- en: Backup power supply state
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备用电源状态
- en: Voltage
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电压
- en: Wattage
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功率
- en: Current
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电流
- en: As infrastructure components have been used for many years, there are some agreed-upon
    standards for data structures and transmission. Let’s look at those original standards
    now.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基础设施组件已经使用多年，因此对数据结构和传输存在一些公认的标准。现在让我们来看看这些原始标准。
- en: Common standards for infrastructure components
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施组件的常见标准
- en: 'There are a few well-established standards that are used by infrastructure
    components that you may need to monitor. These include the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些已经确立的标准被基础设施组件使用，这些组件可能是你需要监控的。包括以下内容：
- en: '**Syslog**: Syslog has been around since the 1980s and is very common in infrastructure
    components. Created as part of the **Sendmail project** by Eric Allman, it was
    quickly adopted and became the standard logging solution on Unix-like platforms.
    It is very popular because of its ease of use. To use Syslog, you need a client
    available to receive the data, and each device needs to be configured to send
    data there. Common clients include RSyslog and Syslog-ng, and the OpenTelemetry
    Collector also supports this protocol.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Syslog**：Syslog 自 1980 年代以来就存在，并在基础设施组件中非常常见。它由 Eric Allman 作为 **Sendmail
    项目**的一部分创建，很快就被采用并成为类 Unix 平台的标准日志记录解决方案。它因易于使用而广受欢迎。要使用 Syslog，您需要一个可接收数据的客户端，并且每个设备需要配置为将数据发送到该客户端。常见的客户端包括
    RSyslog 和 Syslog-ng，OpenTelemetry Collector 也支持该协议。'
- en: The Syslog message format provides a structured framework that has allowed organizations
    to provide vendor-specific extensions. Contributing to its success and longevity,
    most modern observability tooling providers still supply an interface to receive
    Syslog messages. The logs can then be accessed and analyzed alongside other system
    and application telemetry.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Syslog 消息格式提供了一个结构化框架，允许组织提供供应商特定的扩展。作为其成功和长期存在的贡献，大多数现代可观测性工具提供商仍然提供接收 Syslog
    消息的接口。然后，可以访问这些日志并与其他系统和应用程序的遥测数据一起分析。
- en: '**Simple Network Management Protocol** (**SNMP**): Forming part of the original
    Internet Protocol suite defined by the **Internet Engineering Task Force** (**IETF**),
    SNMP is commonly used in networking infrastructure. A lot of the protocol is not
    of interest for observability, but **SNMP Traps** allow devices to inform the
    manager about significant events.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单网络管理协议**（**SNMP**）：作为 **互联网工程任务组**（**IETF**）定义的原始互联网协议族的一部分，SNMP 通常用于网络基础设施。该协议的很多部分与可观测性无关，但
    **SNMP Trap** 允许设备将重要事件通知管理者。'
- en: 'SNMP provides a common mechanism for network devices to relay management and,
    specifically in the context of this chapter, monitoring information within single
    and multi-vendor LAN or WAN environments. It is different from other telemetry
    receivers as it requires more specific knowledge of the devices on the network,
    and specific configurations for the metrics to be collected. Here are some examples
    of data that can be collected from SNMP:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SNMP为网络设备提供了一种通用机制，以便在单一和多厂商的局域网或广域网环境中传递管理和特别是在本章背景下的监控信息。它与其他遥测接收器不同，因为它需要更多关于网络上设备的具体知识，并且需要针对指标收集进行特定的配置。以下是一些可以通过SNMP收集的数据示例：
- en: '| **Data Type** | **Example** **Metrics Collected** |'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| **数据类型** | **示例** **收集的指标** |'
- en: '| Network data | ProcessesUptimeThroughput |'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 网络数据 | 进程运行时间吞吐量 |'
- en: '| Device data | Memory usageCPU usageTemperature |'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 设备数据 | 内存使用率CPU使用率温度 |'
- en: Table 2.8 – Example SNMP Trap information
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.8 – 示例SNMP Trap信息
- en: You may encounter other formats out in the wide world of engineering. We have
    covered a lot of the common formats here and have hopefully given you an indication
    of the types of information you will need to help you work with telemetry in Grafana.
    Grafana will handle just about whatever you can throw at it. Knowing what’s important
    and preparing for that will help you when you’re building your visualizations
    and alerts on that data. Now, let’s quickly recap what we’ve covered in this chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在广泛的工程领域中遇到其他格式。我们在这里已经覆盖了许多常见的格式，并且希望能够为你提供有关在Grafana中使用遥测所需信息的指示。Grafana几乎可以处理你能提供的任何内容。了解什么是重要的并为此做好准备，将帮助你在构建数据的可视化和告警时更加得心应手。现在，让我们快速回顾一下本章的内容。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the foundations that modern observability is built
    on. This will serve as easy reference and support for future chapters in this
    book and your own projects. First, we looked at the common log formats and their
    examples, which will assist us in [*Chapter 4*](B18277_04.xhtml#_idTextAnchor092),
    *Looking at Logs with Grafana Loki*. Then, we took a closer look at metrics, their
    differing types, some example protocols, and best practices to consider when designing
    metric-based observability. What we covered here will help with [*Chapter 5*](B18277_05.xhtml#_idTextAnchor106),
    *Monitoring with Metrics Using Grafana Mimir and Prometheus*. We then moved on
    to traces and spans, where we looked at current protocols and some best practices
    to consider when building an efficient and effective trace-based observability
    platform. This section lays the groundwork for [*Chapter 6*](B18277_06.xhtml#_idTextAnchor134),
    *Tracing Technicalities with Grafana Tempo*. After looking at the telemetry of
    observability, we learned about application instrumentation, which we will see
    more of in [*Chapter 3*](B18277_03.xhtml#_idTextAnchor063), *Setting Up a Learning
    Environment with Demo Applications*, and later chapters where we go into specifics
    with logs, metrics, and traces. Lastly, we considered some of the more traditional
    infrastructure telemetry.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了现代可观测性构建的基础。这将作为本书后续章节和你自己项目的简便参考和支持。首先，我们查看了常见的日志格式及其示例，这将帮助我们在[*第4章*](B18277_04.xhtml#_idTextAnchor092)中进一步学习，*使用Grafana
    Loki查看日志*。接着，我们深入探讨了指标、它们的不同类型、一些示例协议，以及在设计基于指标的可观测性时需要考虑的最佳实践。本章所涵盖的内容将对[*第5章*](B18277_05.xhtml#_idTextAnchor106)，*使用Grafana
    Mimir和Prometheus进行指标监控*有所帮助。然后，我们转向了跟踪和跨度，研究了当前的协议以及在构建高效、有效的基于跟踪的可观测性平台时需要考虑的一些最佳实践。本节为[*第6章*](B18277_06.xhtml#_idTextAnchor134)，*使用Grafana
    Tempo进行跟踪技术探讨*奠定了基础。了解了可观测性的遥测后，我们学习了应用程序仪表化的内容，我们将在[*第3章*](B18277_03.xhtml#_idTextAnchor063)中更深入了解，*通过示例应用程序设置学习环境*，以及后续章节中关于日志、指标和跟踪的具体内容。最后，我们还考虑了一些更传统的基础设施遥测。
- en: With the overview of application and infrastructure instrumentation complete,
    we can now start playing with logs, metrics, and traces. In the next chapter,
    we will get our learning environment up and running.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了应用程序和基础设施仪表化的概述后，我们现在可以开始玩转日志、指标和跟踪了。在下一章中，我们将启动并运行我们的学习环境。
