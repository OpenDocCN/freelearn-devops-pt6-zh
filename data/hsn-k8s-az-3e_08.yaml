- en: 4\. Building scalable applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 构建可扩展的应用程序
- en: When running an application efficiently, the ability to scale and upgrade your
    application is critical. Scaling allows your application to handle additional
    load. While upgrading, scaling is needed to keep your application up to date and
    to introduce new functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在高效运行应用程序时，能够扩展和升级应用程序至关重要。扩展可以让你的应用程序处理额外的负载。而在升级过程中，扩展是保持应用程序最新并引入新功能的必要手段。
- en: Scaling on demand is one of the key benefits of using cloud-native applications.
    It also helps optimize resources for your application. If the front end component
    encounters heavy load, you can scale the front end alone, while keeping the same
    number of back end instances. You can increase or reduce the number of **virtual
    machines** (**VMs**) required depending on your workload and peak demand hours.
    This chapter will cover the scale dimensions of the application and its infrastructure
    in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 按需扩展是使用云原生应用程序的关键好处之一。它还可以帮助优化应用程序的资源。如果前端组件遇到高负载，你可以单独扩展前端，同时保持后端实例的数量不变。你可以根据工作负载和高峰时段调整所需的**虚拟机**（**VM**）数量。本章将详细介绍应用程序及其基础设施的扩展维度。
- en: In this chapter, you will learn how to scale the sample guestbook application
    that was introduced in *Chapter 3,* *Application deployment on AKS*. You will
    first scale this application using manual commands, and afterward you'll learn
    how to autoscale it using the `kubectl`, which is an important tool for managing
    applications running on top of **Azure Kubernetes** **Service** (**AKS**). After
    scaling the application, you will also scale the cluster. You will first scale
    the cluster manually, and then use the **cluster autoscaler** to automatically
    scale the cluster. In addition, you will get a brief introduction on how you can
    upgrade applications running on top of AKS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何扩展在*第3章*中介绍的示例访客簿应用程序，即*在AKS上部署应用程序*。你将首先使用手动命令扩展该应用程序，然后你将学习如何使用`kubectl`进行自动扩展，`kubectl`是管理运行在**Azure
    Kubernetes** **Service**（**AKS**）上的应用程序的重要工具。扩展应用程序后，你还将扩展集群。你将首先手动扩展集群，然后使用**集群自动扩展器**来自动扩展集群。此外，你还将简要了解如何升级在AKS上运行的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Scaling your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展你的应用程序
- en: Scaling your cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展你的集群
- en: Upgrading your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级你的应用程序
- en: Let's begin this chapter by discussing the different dimensions of scaling applications
    on top of AKS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的开始部分将讨论如何在AKS上扩展应用程序的不同维度。
- en: Scaling your application
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展你的应用程序
- en: There are two scale dimensions for applications running on top of AKS. The first
    scale dimension is the number of pods a deployment has, while the second scale
    dimension in AKS is the number of nodes in the cluster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在AKS上运行的应用程序有两个扩展维度。第一个扩展维度是部署中Pod的数量，而第二个扩展维度是集群中节点的数量。
- en: By adding new pods to a deployment, also known as scaling out, you can add additional
    compute power to the deployed application. You can either scale out your applications
    manually or have Kubernetes take care of this automatically via HPA. HPA can monitor
    metrics such as the CPU to determine whether pods need to be added to your deployment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向部署中添加新的Pod，也称为扩展，你可以为已部署的应用程序增加计算能力。你可以手动扩展应用程序，或者通过HPA让Kubernetes自动处理这一过程。HPA可以监控CPU等指标，以判断是否需要为你的部署添加Pod。
- en: The second scale dimension in AKS is the number of nodes in the cluster. The
    number of nodes in a cluster defines how much CPU and memory are available for
    all the applications running on that cluster. You can scale your cluster manually
    by changing the number of nodes, or you can use the cluster autoscaler to automatically
    scale out your cluster. The cluster autoscaler watches the cluster for pods that
    cannot be scheduled due to resource constraints. If pods cannot be scheduled,
    it will add nodes to the cluster to ensure that your applications can run.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: AKS中的第二个扩展维度是集群中节点的数量。集群中的节点数量定义了所有在该集群上运行的应用程序可以使用的CPU和内存资源。你可以通过更改节点数量手动扩展集群，或者使用集群自动扩展器自动扩展集群。集群自动扩展器会监视集群中的Pod，如果由于资源限制导致Pod无法调度，它会向集群添加节点，确保你的应用程序能够运行。
- en: Both scale dimensions will be covered in this chapter. In this section, you
    will learn how you can scale your application. First, you will scale your application
    manually, and then later, you will scale your application automatically.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖两个规模维度。在本节中，您将学习如何扩展您的应用程序。首先，您将手动扩展应用程序，然后，您将学习如何自动扩展应用程序。
- en: Manually scaling your application
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动扩展您的应用程序
- en: 'To demonstrate manual scaling, let''s use the guestbook example that we used
    in the previous chapter. Follow these steps to learn how to implement manual scaling:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示手动扩展，让我们使用上一章中使用的留言簿示例。按照以下步骤学习如何实现手动扩展：
- en: Note
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: 'In the previous chapter, we cloned the example files in Cloud Shell. If you
    didn''t do this back then, we recommend doing that now:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在 Cloud Shell 中克隆了示例文件。如果您当时没有执行此操作，我们建议现在进行操作：
- en: '`git clone https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure-third-edition`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure-third-edition`'
- en: 'For this chapter, navigate to the `Chapter04` directory:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，请导航到 `Chapter04` 目录：
- en: '`cd Chapter04`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd Chapter04`'
- en: 'Set up the guestbook by running the `kubectl create` command in the Azure command
    line:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Azure 命令行中运行 `kubectl create` 命令来设置留言簿：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you have entered the preceding command, you should see something similar
    to what is shown in *Figure 4.1* in your command-line output:![Setting up the
    guestbook application by running the kubectl create command](img/B17338_04_01.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入前面的命令后，您应该会在命令行输出中看到类似*图 4.1*所示的内容：[通过运行 kubectl create 命令设置留言簿应用程序](img/B17338_04_01.jpg)
- en: 'Figure 4.1: Launching the guestbook application'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.1：启动留言簿应用程序
- en: 'Right now, none of the services are publicly accessible. We can verify this
    by running the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，所有服务都不可公开访问。我们可以通过运行以下命令来验证这一点：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As seen in *Figure 4.2*, none of the services have an external IP:![Verifying
    to ensure none of the services are publicly accessible](img/B17338_04_02.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*图 4.2*所示，所有服务都没有外部 IP：[验证确保没有任何服务是公开可访问的](img/B17338_04_02.jpg)
- en: 'Figure 4.2: Output confirming that none of the services have a public IP'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.2：确认没有服务具有公共 IP 的输出
- en: 'To test the application, you will need to expose it publicly. For this, let''s
    introduce a new command that will allow you to edit the service in Kubernetes
    without having to change the file on your file system. To start the edit, execute
    the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试应用程序，您需要将其公开。为此，我们将介绍一个新命令，允许您在不修改文件系统中文件的情况下编辑 Kubernetes 中的服务。要开始编辑，请执行以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will open a `vi` environment. Use the down arrow key to navigate to the
    line that says `type:` `ClusterIP` and change that to `type: LoadBalancer`, as
    shown in *Figure 4.3*. To make that change, hit the *I* button, change `type`
    to `LoadBalancer`, hit the *Esc* button, type `:wq!`, and then hit *Enter* to
    save the changes:![Changing the type from ClusterIP to LoadBalancer](img/B17338_04_03.jpg)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将打开一个 `vi` 环境。使用下箭头键导航到显示 `type:` `ClusterIP` 的行，并将其更改为 `type: LoadBalancer`，如*图
    4.3*所示。要进行此更改，按下 *I* 键，将 `type` 改为 `LoadBalancer`，然后按 *Esc* 键，输入 `:wq!`，并按 *Enter*
    保存更改：[将类型从 ClusterIP 更改为 LoadBalancer](img/B17338_04_03.jpg)'
- en: 'Figure 4.3: Changing this line to type: LoadBalancer'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 4.3：将该行更改为 type: LoadBalancer'
- en: 'Once the changes are saved, you can watch the service object until the public
    IP becomes available. To do this, type the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦更改保存完毕，您可以观察服务对象，直到公共 IP 可用。为此，请输入以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It will take a couple of minutes to show you the updated IP. Once you see the
    correct public IP, you can exit the `watch` command by hitting *Ctrl* + *C*:![Output
    showing the front-end service getting a public IP](img/B17338_04_04.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新的 IP 地址将需要几分钟时间才能显示。一旦看到正确的公共 IP，您可以通过按 *Ctrl* + *C* 退出 `watch` 命令：[显示前端服务获取公共
    IP 的输出](img/B17338_04_04.jpg)
- en: 'Figure 4.4: Output showing the front-end service getting a public IP'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.4：显示前端服务获取公共 IP 的输出
- en: 'Type the IP address from the preceding output into your browser navigation
    bar as follows: `http://<EXTERNAL-IP>/`. The result of this is shown in *Figure 4.5*:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面输出的 IP 地址输入到浏览器导航栏中，如下所示：`http://<EXTERNAL-IP>/`。结果如*图 4.5*所示：
- en: '![Entering the IP address in the browser to view the guestbook sample](img/B17338_04_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '[在浏览器中输入 IP 地址查看留言簿示例](img/B17338_04_05.jpg)'
- en: 'Figure 4.5: Browse to the guestbook application'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：浏览到留言簿应用程序
- en: The familiar guestbook sample should be visible. This shows that you have successfully
    publicly accessed the guestbook.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的留言板示例应该可见。这表明你已成功公开访问了留言板。
- en: Now that you have the guestbook application deployed, you can start scaling
    the different components of the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经部署了留言板应用程序，可以开始扩展应用程序的不同组件。
- en: Scaling the guestbook front-end component
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展留言板前端组件
- en: 'Kubernetes gives us the ability to scale each component of an application dynamically.
    In this section, we will show you how to scale the front end of the guestbook
    application. Right now, the front-end deployment is deployed with three replicas.
    You can confirm by using the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 让我们能够动态地扩展应用的每个组件。在本节中，我们将展示如何扩展留言板应用的前端。目前，前端部署已部署了三个副本。你可以通过以下命令确认：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should return an output as shown in *Figure 4.6*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会返回如*图 4.6*所示的输出：
- en: '![Output confirming that we have three replicas in the front-end deployment](img/B17338_04_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![确认前端部署中有三个副本的输出](img/B17338_04_06.jpg)'
- en: 'Figure 4.6: Confirming the three replicas in the front-end deployment'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：确认前端部署中的三个副本
- en: 'To scale the front-end deployment, you can execute the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展前端部署，你可以执行以下命令：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will cause Kubernetes to add additional pods to the deployment. You can
    set the number of replicas you want, and Kubernetes takes care of the rest. You
    can even scale it down to zero (one of the tricks used to reload the configuration
    when the application doesn''t support the dynamic reload of configuration). To
    verify that the overall scaling worked correctly, you can use the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 Kubernetes 为部署添加额外的 pod。你可以设置所需的副本数量，Kubernetes 会处理剩余的工作。你甚至可以将副本数扩展到零（这是当应用程序不支持动态配置重新加载时，重新加载配置的一种技巧）。要验证整体扩展是否正确工作，你可以使用以下命令：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should give you the output shown in *Figure 4.7*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你与*图 4.7*中相同的输出：
- en: '![Output showing 6 pods running in the frontend deployment after scaling out
    ](img/B17338_04_07.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![扩展后前端部署中运行的 6 个 pod 的输出](img/B17338_04_07.jpg)'
- en: 'Figure 4.7: Different pods running in the guestbook application after scaling
    out'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：扩展后在留言板应用中运行的不同 pod
- en: 'As you can see, the front-end service scaled to six pods. Kubernetes also spread
    these pods across multiple nodes in the cluster. You can see the nodes that this
    is running on with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前端服务扩展到了六个 pod。Kubernetes 还将这些 pod 分布到集群中的多个节点上。你可以通过以下命令查看这些 pod 运行在哪些节点上：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will generate the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Output showing the nodes on which the pods are running](img/B17338_04_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![显示 pod 运行节点的输出](img/B17338_04_08.jpg)'
- en: 'Figure 4.8: Showing which nodes the pods are running on'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：显示 pod 运行在哪些节点上
- en: In this section, you have seen how easy it is to scale pods with Kubernetes.
    This capability provides a very powerful tool for you to not only dynamically
    adjust your application components but also provide resilient applications with
    failover capabilities enabled by running multiple instances of components at the
    same time. However, you won't always want to manually scale your application.
    In the next section, you will learn how you can automatically scale your application
    in and out by automatically adding and removing pods in a deployment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经看到如何使用 Kubernetes 扩展 pod 是多么简单。这个功能为你提供了一个强大的工具，不仅可以动态调整应用组件，还能通过同时运行多个组件实例提供具有故障转移能力的弹性应用。然而，你并不总是希望手动扩展你的应用程序。在下一节中，你将学习如何通过在部署中自动添加和删除
    pod 来自动扩展应用程序。
- en: Using the HPA
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 HPA
- en: Scaling manually is useful when you're working on your cluster. For example,
    if you know your load is going to increase, you can manually scale out your application.
    In most cases, however, you will want some sort of autoscaling to happen on your
    application. In Kubernetes, you can configure autoscaling of your deployment using
    an object called the **Horizontal Pod Autoscaler** (**HPA**).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 手动扩展在你操作集群时非常有用。例如，如果你知道负载将增加，你可以手动扩展应用程序。然而，在大多数情况下，你会希望应用程序能够进行某种形式的自动扩展。在
    Kubernetes 中，你可以使用一个叫做**水平 Pod 自动扩展器**（**HPA**）的对象来配置部署的自动扩展。
- en: HPA monitors Kubernetes metrics at regular intervals and, based on the rules
    you define, it automatically scales your deployment. For example, you can configure
    the HPA to add additional pods to your deployment once the CPU utilization of
    your application is above 50%.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HPA定期监控Kubernetes度量标准，并根据您定义的规则自动扩展部署。例如，您可以配置HPA，在应用程序的CPU利用率超过50%时，自动向部署中添加更多Pods。
- en: 'In this section, you will configure the HPA to scale the front-end of the application
    automatically:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将配置HPA以自动扩展应用程序的前端：
- en: 'To start the configuration, let''s first manually scale down our deployment
    to one instance:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始配置，首先让我们手动将部署规模缩小到一个实例：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next up, we''ll create an HPA. Open up the code editor in Cloud Shell by typing
    `code hpa.yaml` and enter the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个HPA。通过在Cloud Shell中输入`code hpa.yaml`来打开代码编辑器，并输入以下代码：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s investigate what is configured in this file:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看看这个文件中配置了什么内容：
- en: '`HorizontalPodAutoscaler`.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HorizontalPodAutoscaler`。'
- en: '**Lines 6-9**: These lines define the deployment that we want to autoscale.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6-9行**：这些行定义了我们希望自动扩展的部署。'
- en: '**Lines 10-11**: Here, we configure the minimum and maximum pods in our deployment.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10-11行**：在这里，我们配置了部署中的最小和最大Pods数量。'
- en: '**Lines 12**: Here, we define the target CPU utilization percentage for our
    deployment.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第12行**：在这里，我们定义了部署的目标CPU利用率百分比。'
- en: 'Save this file, and create the HPA using the following command:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此文件，并使用以下命令创建HPA：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will create our autoscaler. You can see your autoscaler with the following
    command:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建我们的自动扩展器。您可以使用以下命令查看您的自动扩展器：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will initially output something as shown in *Figure 4.9*:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这最初将输出类似于*图4.9*所示的内容：
- en: '![Output displaying target as unknown, which indicates that the HPA isn''t
    ready yet](img/B17338_04_09.jpg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示目标为未知，这表明HPA尚未准备好](img/B17338_04_09.jpg)'
- en: 'Figure 4.9: The target unknown shows that the HPA isn''t ready yet'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.9：目标未知表示HPA尚未准备好
- en: 'It takes a couple of seconds for the HPA to read the metrics. Wait for the
    return from the HPA to look something similar to the output shown in *Figure 4.10*:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HPA读取度量标准需要几秒钟的时间。等待HPA的返回，输出应类似于*图4.10*所示：
- en: '![Output showing the target with a percentage indicating that the HPA is ready](img/B17338_04_10.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示目标有一个百分比，表示HPA已准备好](img/B17338_04_10.jpg)'
- en: 'Figure 4.10: Once the target shows a percentage, the HPA is ready'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.10：当目标显示百分比时，HPA已准备好
- en: 'You will now go ahead and do two things: first, you will watch the pods to
    see whether new pods are created. Then, you will create a new shell, and create
    some load for the system. Let''s start with the first task—watching our pods:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在需要做两件事：首先，您将观察Pods，以查看是否创建了新Pods。然后，您将创建一个新的shell并为系统生成一些负载。让我们从第一个任务开始——观察我们的Pods：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will continuously monitor the pods that get created or terminated.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将持续监控创建或终止的Pods。
- en: 'Let''s now create some load in a new shell. In Cloud Shell, hit the **open
    new session** icon to open a new shell:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们在新的shell中创建一些负载。在Cloud Shell中，点击**打开新会话**图标以打开一个新的shell：
- en: '![Clicking the open new session icon to open a new Cloud Shell](img/B17338_04_11.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![点击打开新会话图标以打开新的Cloud Shell会话](img/B17338_04_11.jpg)'
- en: 'Figure 4.11: Use this button to open a new Cloud Shell'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.11：使用此按钮打开新的Cloud Shell会话
- en: This will open a new tab in your browser with a new session in Cloud Shell.
    You will generate load for the application from this tab.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打开浏览器中的新标签页，并在Cloud Shell中启动一个新的会话。您将从该标签页为应用程序生成负载。
- en: 'Next, you will use a program called `hey` to generate this load. `hey` is a
    tiny program that sends loads to a web application. You can install and run `hey`
    using the following commands:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将使用一个名为`hey`的程序来生成负载。`hey`是一个小型程序，用于向Web应用程序发送负载。您可以使用以下命令安装并运行`hey`：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `hey` program will now try to create up to 20 million connections to the
    front-end. This will generate CPU loads on the system, which will trigger the
    HPA to start scaling the deployment. It will take a couple of minutes for this
    to trigger a scale action, but at a certain point, you should see multiple pods
    being created to handle the additional load, as shown in *Figure 4.12*:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hey`程序现在将尝试创建多达2000万个连接到前端。这将产生系统的CPU负载，触发HPA开始扩展部署。触发扩展操作需要几分钟时间，但在某个时刻，您应该看到多个Pods被创建以处理额外的负载，如*图4.12*所示：'
- en: '![Output showing new pods being created by the HPA to handle the additional
    load](img/B17338_04_12.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示HPA正在创建新Pods以处理额外的负载](img/B17338_04_12.jpg)'
- en: 'Figure 4.12: New pods get started by the HPA'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.12：新Pod由HPA启动
- en: At this point, you can go ahead and kill the `hey` program by hitting *Ctrl*
    + *C*.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，您可以通过按*Ctrl* + *C*终止`hey`程序。
- en: 'Let''s have a closer look at what the HPA did by running the following command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来更仔细地查看HPA做了什么：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see a few interesting points in the `describe` operation, as shown in
    *Figure 4.13*:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在`describe`操作中看到一些有趣的点，如*图4.13*所示：
- en: '![Running the kubectl describe hpa command to get a detailed view of the HPA](img/B17338_04_13.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![运行kubectl describe hpa命令以获取HPA的详细视图](img/B17338_04_13.jpg)'
- en: 'Figure 4.13: Detailed view of the HPA'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.13：HPA的详细视图
- en: 'The annotations in *Figure 4.13* are explained as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图4.13*中的注释解释如下：'
- en: This shows you the current CPU utilization (`384%`) versus the desired (`50%`).
    The current CPU utilization will likely be different in your situation.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这显示了当前的CPU利用率（`384%`）与期望值（`50%`）的对比。当前的CPU利用率在您的环境中可能会有所不同。
- en: This shows you that the current desired replica count is higher than the actual
    maximum you had configured. This ensures that a single deployment doesn't consume
    all resources in the cluster.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这表明当前的期望副本数高于您配置的实际最大副本数。这确保了单个部署不会消耗集群中的所有资源。
- en: This shows you the scaling actions that the HPA took. It first scaled to 4,
    then to 8, and then to 10 pods in the deployment.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这显示了HPA所采取的扩展动作。它首先将副本数扩展到4，然后到8，最后扩展到10个Pod。
- en: 'If you wait for a couple of minutes, the HPA should start to scale down. You
    can track this scale-down operation using the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果等待几分钟，HPA应该会开始缩减。您可以使用以下命令跟踪这个缩减操作：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will track the HPA and show you the gradual scaling down of the deployment,
    as displayed in *Figure 4.14*:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将跟踪HPA并显示部署逐渐缩减的过程，如*图4.14*所示：
- en: '![Tracking the HPA scale down using the kubectl get hpa -w command](img/B17338_04_14.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用kubectl get hpa -w命令跟踪HPA缩减](img/B17338_04_14.jpg)'
- en: 'Figure 4.14: Watching the HPA scale down'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.14：观看HPA缩减
- en: 'Before we move on to the next section, let''s clean up the resources we created
    in this section:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进入下一节之前，让我们清理一下本节中创建的资源：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this section, you first manually and then automatically scaled an application.
    However, the infrastructure supporting the application was static; you ran this
    on a two-node cluster. In many cases, you might also run out of resources on the
    cluster. In the next section, you will deal with this issue and learn how you
    can scale the AKS cluster yourself.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您首先手动然后自动扩展了应用程序。然而，支撑该应用程序的基础设施是静态的；您在一个两节点的集群上运行它。在许多情况下，您可能还会遇到集群资源不足的情况。在下一节中，您将处理这个问题，并学习如何自己扩展AKS集群。
- en: Scaling your cluster
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展集群
- en: In the previous section, you dealt with scaling the application running on top
    of a cluster. In this section, you'll learn how you can scale the actual cluster
    you are running. First, you will manually scale your cluster to one node. Then,
    you'll configure the cluster autoscaler. The cluster autoscaler will monitor your
    cluster and scale out when there are pods that cannot be scheduled on the cluster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您处理了在集群上运行的应用程序的扩展问题。在本节中，您将学习如何扩展您运行的实际集群。首先，您将手动将集群缩放到一个节点。然后，您将配置集群自动扩展器。集群自动扩展器将监控您的集群，当集群中有无法调度的Pod时，它会进行扩展。
- en: Manually scaling your cluster
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动扩展集群
- en: You can manually scale your AKS cluster by setting a static number of nodes
    for the cluster. The scaling of your cluster can be done either via the Azure
    portal or the command line.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为集群设置静态节点数来手动扩展AKS集群。集群的扩展可以通过Azure门户或命令行进行。
- en: In this section, you'll learn how you can manually scale your cluster by scaling
    it down to one node. This will cause Azure to remove one of the nodes from your
    cluster. First, the workload on the node that is about to be removed will be rescheduled
    onto the other node. Once the workload is safely rescheduled, the node will be
    removed from your cluster, and then the VM will be deleted from Azure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何通过手动将集群缩减到一个节点来扩展集群。这将导致Azure从您的集群中移除一个节点。首先，即将移除的节点上的工作负载将被重新调度到另一个节点上。一旦工作负载安全地重新调度，节点将从集群中移除，然后虚拟机将从Azure中删除。
- en: 'To scale your cluster, follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展您的集群，请按照以下步骤操作：
- en: Open the Azure portal and go to your cluster. Once there, go to **Node pools**
    and click on the number below **Node count**, as shown in *Figure 4.15*:![Manually
    scaling the cluster using the Azure portal](img/B17338_04_15.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Azure 门户并进入您的集群。进入后，转到 **Node pools**，然后点击 **Node count** 下方的数字，如 *图 4.15*
    所示：![通过 Azure 门户手动扩展集群](img/B17338_04_15.jpg)
- en: 'Figure 4.15: Manually scaling the cluster'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.15：手动扩展集群
- en: This will open a pop-up window that will give the option to scale your cluster.
    For our example, we will scale down our cluster to one node, as shown in *Figure
    4.16*:![Pop-up window confirming the new cluster size](img/B17338_04_16.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个弹出窗口，提供扩展集群的选项。在我们的示例中，我们将把集群缩小到一个节点，如 *图 4.16* 所示：![确认新集群大小的弹出窗口](img/B17338_04_16.jpg)
- en: 'Figure 4.16: Pop-up window confirming the new cluster size'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.16：确认新集群大小的弹出窗口
- en: 'Hit the **Apply** button at the bottom of the screen to save these settings.
    This will cause Azure to remove a node from your cluster. This process will take
    about 5 minutes to complete. You can follow the progress by clicking on the notification
    icon at the top of the Azure portal as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕底部的 **Apply** 按钮以保存这些设置。这将导致 Azure 从您的集群中移除一个节点。此过程大约需要 5 分钟完成。您可以通过点击 Azure
    门户顶部的通知图标来跟踪进度，如下所示：
- en: '![Clicking the notification icon in the Azure portal to check the progress
    of the scale-down operation](img/B17338_04_17.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![点击 Azure 门户中的通知图标查看缩减操作的进度](img/B17338_04_17.jpg)'
- en: 'Figure 4.17: Cluster scaling can be followed using the notifications in the
    Azure portal'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：可以通过 Azure 门户中的通知跟踪集群扩展进度
- en: 'Once this scale-down operation has completed, relaunch the guestbook application
    on this small cluster:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当此缩减操作完成后，请在此小型集群上重新启动 guestbook 应用：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the next section, you will scale out the guestbook so that it can no longer
    run on this small cluster. You will then configure the cluster autoscaler to scale
    out the cluster.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将扩展 guestbook，以使其无法在这个小型集群上运行。然后，您将配置集群自动扩展器来扩展集群。
- en: Scaling your cluster using the cluster autoscaler
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集群自动扩展器扩展集群
- en: In this section, you will explore the cluster autoscaler. The cluster autoscaler
    will monitor the deployments in your cluster and scale your cluster to meet your
    application requirements. The cluster autoscaler watches the number of pods in
    your cluster that cannot be scheduled due to insufficient resources. You will
    first force your deployment to have pods that cannot be scheduled, and then configure
    the cluster autoscaler to automatically scale your cluster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索集群自动扩展器。集群自动扩展器将监视集群中的部署，并根据应用程序需求自动扩展集群。集群自动扩展器会监视由于资源不足而无法调度的 pod
    数量。您将首先强制部署中出现无法调度的 pod，然后配置集群自动扩展器以自动扩展集群。
- en: 'To force your cluster to be out of resources, you will—manually—scale out the
    `redis-replica`  deployment. To do this, use the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制集群资源不足，您将手动扩展 `redis-replica` 部署。为此，使用以下命令：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can verify that this command was successful by looking at the pods in our
    cluster:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看集群中的 pod 来验证该命令是否成功：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should show you something similar to the output shown in *Figure 4.18*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示类似于 *图 4.18* 所示的输出：
- en: '![Output displaying four out of five pods as pending due to the cluster being
    out of resources](img/B17338_04_18.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![输出显示由于集群资源不足，五个 pod 中有四个处于 Pending 状态](img/B17338_04_18.jpg)'
- en: 'Figure 4.18: Four out of five pods are pending, meaning they cannot be scheduled'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：五个 pod 中有四个处于 Pending 状态，表示它们无法调度
- en: As you can see, you now have two pods in a `Pending` state. The `Pending` state
    in Kubernetes means that that pod cannot be scheduled onto a node. In this case,
    this is due to the cluster being out of resources.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当前有两个 pod 处于 `Pending` 状态。在 Kubernetes 中，`Pending` 状态意味着该 pod 无法调度到节点上。在这种情况下，是由于集群资源不足导致的。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If your cluster is running on a larger VM size than the DS2v2, you might not
    notice pods in a `Pending` state now. In that case, increase the number of replicas
    to a higher number until you see pods in a pending state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的集群运行在比 DS2v2 更大的虚拟机上，现在可能不会看到处于 `Pending` 状态的 pod。在这种情况下，您可以增加副本数，直到看到 pod
    处于 Pending 状态。
- en: 'You will now configure the cluster autoscaler to automatically scale the cluster.
    Similar to manual scaling in the previous section, there are two ways you can
    configure the cluster autoscaler. You can configure it either via the Azure portal—similar
    to how we did the manual scaling—or you can configure it using the **command-line
    interface** **(CLI)**. In this example, you will use CLI to enable the cluster
    autoscaler. The following command will configure the cluster autoscaler for your
    cluster:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将配置集群自动缩放器以自动扩展集群。与前一部分的手动缩放类似，你可以通过两种方式配置集群自动缩放器。你可以通过 Azure 门户配置它，类似于我们之前手动缩放的方式，或者你可以使用命令行界面（CLI）配置它。在这个例子中，你将使用
    CLI 启用集群自动缩放器。以下命令将为你的集群配置集群自动缩放器：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command configures the cluster autoscaler on the node pool you have in
    the cluster. It configures it to have a minimum of one node and a maximum of two
    nodes. This will take a couple of minutes to configure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令配置了在你的集群中的节点池上的集群自动缩放器。它将其配置为具有一个节点的最小值和两个节点的最大值。这将需要几分钟来配置。
- en: 'Once the cluster autoscaler is configured, you can see it in action by using
    the following command to watch the number of nodes in the cluster:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了集群自动缩放器，你可以使用以下命令观察集群中节点的数量：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It will take about 5 minutes for the new node to show up and become `Ready`
    in the cluster. Once the new node is `Ready`, you can stop watching the nodes
    by hitting *Ctrl* + *C*. You should see an output similar to what you see in *Figure
    4.19*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点在集群中显示并变为`Ready`大约需要 5 分钟时间。一旦新节点状态为`Ready`，你可以通过按下 *Ctrl* + *C* 停止监视节点。你应该会看到类似
    *Figure 4.19* 的输出：
- en: '![Output showing a new node joining the cluster ](img/B17338_04_19.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![显示新节点加入集群的输出](img/B17338_04_19.jpg)'
- en: 'Figure 4.19: The new node joins the cluster'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19：新节点加入集群
- en: 'The new node should ensure that your cluster has sufficient resources to schedule
    the scaled-out `redis-` `replica` deployment. To verify this, run the following
    command to check the status of the pods:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点应确保你的集群有足够的资源来调度扩展的`redis-` `replica`部署。要验证这一点，请运行以下命令以检查 pod 的状态：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should show you all the pods in a `Running` state as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示所有处于`Running`状态的 pod，如下所示：
- en: '![Output displaying all pods in a Running state](img/B17338_04_20.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![显示所有处于运行状态的 pod 的输出](img/B17338_04_20.jpg)'
- en: 'Figure 4.20: All pods are now in a Running state'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20：所有 pod 现在处于 Running 状态
- en: 'Now clean up the resources you created, disable the cluster autoscaler, and
    ensure that your cluster has two nodes for the next example. To do this, use the
    following commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在清理你创建的资源，禁用集群自动缩放器，并确保你的集群有两个节点，以便进行下一个示例。要执行此操作，请使用以下命令：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The last command from the previous example will show you an error message, `The
    new node count is the same as the current node count.`, if the cluster already
    has two nodes. You can safely ignore this error.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例中的最后一个命令将显示一个错误消息，如果集群已经有两个节点，则会显示`The new node count is the same as the
    current node count.`。你可以安全地忽略此错误。
- en: In this section, you first manually scaled down your cluster and then used the
    cluster autoscaler to scale out your cluster. You used the Azure portal to scale
    down the cluster manually and then used the Azure CLI to configure the cluster
    autoscaler. In the next section, you will look into how you can upgrade applications
    running on AKS.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你首先手动缩减了集群，然后使用集群自动缩放器扩展了集群。你使用 Azure 门户手动缩减了集群，然后使用 Azure CLI 配置了集群自动缩放器。在接下来的部分，你将了解如何升级在
    AKS 上运行的应用程序。
- en: Upgrading your application
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级你的应用程序
- en: Using deployments in Kubernetes makes upgrading an application a straightforward
    operation. As with any upgrade, you should have good failbacks in case something
    goes wrong. Most of the issues you will run into will happen during upgrades.
    Cloud-native applications are supposed to make dealing with this relatively easy,
    which is possible if you have a very strong development team that embraces DevOps
    principles.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 中的部署（deployments）可以使升级应用程序变得简单明了。与任何升级一样，如果出现问题，应该有良好的回滚策略。你可能会在升级过程中遇到大部分问题。云原生应用程序应该能够相对轻松地处理这些问题，如果你有一个非常强大的开发团队，他们秉承
    DevOps 原则。
- en: The State of DevOps report ([https://puppet.com/resources/report/2020-state-of-devops-report/](https://puppet.com/resources/report/2020-state-of-devops-report/))
    has reported for multiple years that companies that have high software deployment
    frequency rates have higher availability and stability in their applications as
    well. This might seem counterintuitive, as doing software deployments heightens
    the risk of issues. However, by deploying more frequently and deploying using
    automated DevOps practices, you can limit the impact of software deployment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 状态报告（[https://puppet.com/resources/report/2020-state-of-devops-report/](https://puppet.com/resources/report/2020-state-of-devops-report/)）多年来报告称，软件部署频率较高的公司，其应用程序的可用性和稳定性也更高。这可能看起来有些反直觉，因为进行软件部署会增加问题的风险。然而，通过更频繁地部署，并采用自动化的
    DevOps 实践，你可以减少软件部署带来的影响。
- en: 'There are multiple ways you can make updates to applications running in a Kubernetes
    cluster. In this section, you will explore the following ways to update Kubernetes
    resources:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式更新在 Kubernetes 集群中运行的应用程序。在本节中，你将探索以下几种更新 Kubernetes 资源的方法：
- en: 'Upgrading by changing YAML files: This method is useful when you have access
    to the full YAML file required to make the update. This can be done either from
    your command line or from an automated system.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改 YAML 文件进行升级：当你有权限访问完整的 YAML 文件进行更新时，使用这种方法。这可以通过命令行或自动化系统来完成。
- en: 'Upgrading using `kubectl edit`: This method is mostly used for minor changes
    on a cluster. It is a quick way to update your configuration live on a cluster.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `kubectl edit` 升级：这种方法主要用于集群上的小规模变更。它是一种快速在集群上实时更新配置的方法。
- en: 'Upgrading using `kubectl patch`: This method is useful when you need to script
    a particular small update to a Kubernetes but don''t have access to the full YAML
    file. It can be done either from a command line or an automated system. If you
    have access to the original YAML files, it is typically better to edit the YAML
    file and use `kubectl apply` to apply the updates.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `kubectl patch` 升级：当你需要脚本化进行 Kubernetes 中某些小的更新，但没有访问完整 YAML 文件的权限时，可以使用这种方法。这可以通过命令行或自动化系统进行。如果你有原始的
    YAML 文件，通常更好的做法是编辑 YAML 文件并使用 `kubectl apply` 应用更新。
- en: 'Upgrading using Helm: This method is used when your application is deployed
    through Helm.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helm 升级：当你的应用程序通过 Helm 部署时，使用这种方法进行升级。
- en: The methods described in the following sections work great if you have stateless
    applications. If you have a state stored anywhere, make sure to back up that state
    before you try upgrading your application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述的方法非常适用于无状态应用程序。如果你有任何状态存储在某个地方，请确保在尝试升级应用程序之前备份该状态。
- en: Let's start this section by doing the first type of upgrade by changing YAML
    files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通过更改 YAML 文件进行的第一次升级开始这节内容。
- en: Upgrading by changing YAML files
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过更改 YAML 文件进行升级
- en: In order to upgrade a Kubernetes service or deployment, you can update the actual
    YAML definition file and apply that to the currently deployed application. Typically,
    we use `kubectl create` to create resources. Similarly, we can use `kubectl apply`
    to make changes to the resources.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了升级 Kubernetes 服务或部署，你可以更新实际的 YAML 定义文件，并将其应用到当前已部署的应用程序。通常，我们使用 `kubectl create`
    来创建资源。同样，我们可以使用 `kubectl apply` 来对资源进行更改。
- en: 'The deployment detects the changes (if any) and matches the running state to
    the desired state. Let''s see how this is done:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 部署会检测更改（如果有的话），并将运行状态与期望状态进行匹配。让我们看看这是如何实现的：
- en: 'Start with our guestbook application to explore this example:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的 guestbook 应用程序开始，探索这个例子：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After a few minutes, all the pods should be running. Let''s perform the first
    upgrade by changing the service from `ClusterIP` to `LoadBalancer`, as you did
    earlier in the chapter. However, now you will edit the YAML file rather than using
    `kubectl edit`. Edit the YAML file using the following command:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，所有的 Pods 应该都在运行。现在我们来进行第一次升级，将服务从 `ClusterIP` 改为 `LoadBalancer`，就像你在本章前面所做的那样。不同的是，现在你将编辑
    YAML 文件，而不是使用 `kubectl edit`。使用以下命令编辑 YAML 文件：
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Uncomment line 102 in this file to set the `type` to `LoadBalancer`, and save
    the file, as shown in *Figure 4.21*:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 取消注释该文件中的第 102 行，将 `type` 设置为 `LoadBalancer`，并保存文件，如 *图 4.21* 所示：
- en: '![Changing the service type from ClusterIP to LoadBalancer using the YAML file](img/B17338_04_21.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 YAML 文件将服务类型从 ClusterIP 改为 LoadBalancer](img/B17338_04_21.jpg)'
- en: 'Figure 4.21: Setting the type to LoadBalancer in the guestbook-all-in-one YAML
    file'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.21：在 guestbook-all-in-one YAML 文件中将类型设置为 LoadBalancer
- en: 'Apply the change as shown in the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码所示，应用更改：
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see an output similar to *Figure 4.22*:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到类似于*图4.22*的输出：
- en: '![Output confirming that the service’s frontend has been updated](img/B17338_04_22.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出确认服务的前端已更新](img/B17338_04_22.jpg)'
- en: 'Figure 4.22: The service''s front-end is updated'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.22：服务的前端已更新
- en: As you can see in *Figure 4.22*, only the object that was updated in the YAML
    file, which is the service in this case, was updated on Kubernetes, and the other
    objects remained unchanged.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如*图4.22*所示，只有在YAML文件中更新的对象（在此案例中是服务）在Kubernetes上被更新，其他对象保持不变。
- en: 'You can now get the public IP of the service using the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以使用以下命令获取服务的公共IP：
- en: '[PRE27]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Give it a few minutes, and you should be shown the IP, as displayed in *Figure 4.23*:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给它几分钟，您应该会看到显示的IP，如*图4.23*所示：
- en: '![Using the kubectl get service command to display the public IP of the service](img/B17338_04_23.jpg)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用kubectl get service命令显示服务的公共IP](img/B17338_04_23.jpg)'
- en: 'Figure 4.23: Output displaying a public IP'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.23：输出显示公共IP
- en: 'You will now make another change. You''ll downgrade the front-end image on
    line 127 from `image: gcr.io/google-samples/gb-frontend:v4` to the following:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在您将进行另一个更改。您将把第127行中的前端镜像`image: gcr.io/google-samples/gb-frontend:v4`降级为以下内容：'
- en: '[PRE28]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This change can be made by opening the guestbook application in the editor
    by using this familiar command:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过使用此熟悉的命令打开guestbook应用程序并进行更改：
- en: '[PRE29]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the following command to perform the update and watch the pods change:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令执行更新并观察Pod的变化：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will generate an output similar to *Figure 4.24*:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成类似于*图4.24*的输出：
- en: '![Output displaying new pods created from a new ReplicaSet](img/B17338_04_24.jpg)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示从新ReplicaSet创建的新Pods](img/B17338_04_24.jpg)'
- en: 'Figure 4.24: Pods from a new ReplicaSet are created'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.24：从新ReplicaSet创建的Pods
- en: What you can see here is that a new version of the pod gets created (based on
    a new ReplicaSet). Once the new pod is running and ready, one of the old pods
    is terminated. This create-terminate loop is repeated until only new pods are
    running. In *Chapter 5, Handling common failures in AKS,* you'll see an example
    of such an upgrade gone wrong and you'll see that Kubernetes will not continue
    with the upgrade process until the new pods are healthy.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，您可以看到一个新的Pod版本被创建（基于新的ReplicaSet）。一旦新Pod启动并准备好，旧的Pod之一将被终止。这个创建-终止循环将不断重复，直到只有新的Pods在运行。在*第五章，处理AKS中的常见故障*中，您将看到一个升级失败的示例，并且您会看到Kubernetes不会继续升级过程，直到新Pod健康运行。
- en: Running `kubectl get events | grep ReplicaSet` will show the rolling update
    strategy that the deployment uses to update the front-end images:![Monitoring
    Kubernetes events and filtering to only see ReplicaSet-related events](img/B17338_04_25.jpg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`kubectl get events | grep ReplicaSet`将显示部署使用的滚动更新策略，该策略用于更新前端镜像：![监控Kubernetes事件并过滤仅查看与ReplicaSet相关的事件](img/B17338_04_25.jpg)
- en: '[PRE31]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will display the output shown in *Figure 4.26*:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示*图4.26*所示的输出：
- en: '![Output showing two ReplicaSets are available for the frontend deployment,
    one with 0 pods, the other with 3 pods](img/B17338_04_26.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示前端部署有两个ReplicaSets，一个为0个Pods，另一个为3个Pods](img/B17338_04_26.jpg)'
- en: 'Figure 4.26: Two different ReplicaSets'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.26：两个不同的ReplicaSets
- en: 'Kubernetes will also keep a history of your rollout. You can see the rollout
    history using this command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes还会保留您的滚动更新历史记录。您可以使用此命令查看滚动更新历史：
- en: '[PRE32]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will generate the output shown in *Figure 4.27*:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成如*图4.27*所示的输出：
- en: '![Displaying the rollout history of the deployment](img/B17338_04_27.jpg)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![显示部署的滚动更新历史](img/B17338_04_27.jpg)'
- en: 'Figure 4.27: Deployment history of the application'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.27：应用程序的部署历史
- en: 'Since Kubernetes keeps a history of the rollout, this also enables rollback.
    Let''s do a rollback of your deployment:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Kubernetes会保留滚动更新的历史记录，这也启用了回滚功能。让我们对您的部署进行回滚：
- en: '[PRE33]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will trigger a rollback. This means that the new ReplicaSet will be scaled
    down to zero instances, and the old one will be scaled up to three instances again.
    You can verify this using the following command:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将触发回滚。这意味着新的ReplicaSet将被缩减为零实例，而旧的ReplicaSet将再次扩展为三个实例。您可以使用以下命令验证这一点：
- en: '[PRE34]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The resultant output is as shown in *Figure 4.28*:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果输出如*图4.28*所示：
- en: '![Output displaying the old ReplicaSet with three pods and the new ReplicaSet
    scaled down to zero](img/B17338_04_28.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示旧的ReplicaSet包含三个Pods，新ReplicaSet的Pod数量缩减至零](img/B17338_04_28.jpg)'
- en: 'Figure 4.28: The old ReplicaSet now has three pods, and the new one is scaled
    down to zero'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.28：旧的ReplicaSet现在有三个Pod，而新的ReplicaSet已缩减为零个Pod
- en: This shows you, as expected, that the old ReplicaSet is scaled back to three
    instances and the new one is scaled down to zero instances.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，旧的ReplicaSet被缩放回三实例，而新的ReplicaSet被缩放为零实例。
- en: 'Finally, let''s clean up again by running the `kubectl delete` command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行`kubectl delete`命令再次进行清理：
- en: '[PRE35]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Congratulations! You have completed the upgrade of an application and a rollback
    to a previous version.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了应用程序的升级以及回滚到先前的版本。
- en: In this example, you have used `kubectl apply` to make changes to your application.
    You can similarly also use `kubectl edit` to make changes, which will be explored
    in the next section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你使用了`kubectl apply`命令来修改应用程序。你也可以类似地使用`kubectl edit`来进行修改，下一节将进一步探讨这一方法。
- en: Upgrading an application using kubectl edit
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用kubectl edit升级应用程序
- en: You can also make changes to your application running on top of Kubernetes by
    using `kubectl edit`. You used this previously in this chapter, in the *Manually
    scaling your application* section. When running `kubectl edit`, the `vi` editor
    will be opened for you, which will allow you to make changes directly against
    the object in Kubernetes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用`kubectl edit`来修改运行在Kubernetes上的应用程序。你之前在本章的*手动扩展应用程序*部分使用过此命令。当运行`kubectl
    edit`时，会打开`vi`编辑器，允许你直接对Kubernetes中的对象进行修改。
- en: 'Let''s redeploy the guestbook application without a public load balancer and
    use `kubectl` to create the load balancer:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新部署guestbook应用程序，取消使用公共负载均衡器，并使用`kubectl`创建负载均衡器：
- en: 'Undo the changes you made in the previous step. You can do this by using the
    following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤销你在上一步所做的更改。你可以通过使用以下命令来实现：
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will then deploy the guestbook application:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你将部署guestbook应用程序：
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To start the edit, execute the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始编辑，执行以下命令：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will open a `vi` environment. Navigate to the line that now says `type:`
    `ClusterIP` (line 27) and change that to `type: LoadBalancer`, as shown in *Figure 4.29*.
    To make that change, hit the *I* button, type your changes, hit the *Esc* button,
    type `:wq!`, and then hit *Enter* to save the changes:![Displaying the rollout
    history of the deployment](img/B17338_04_29.jpg)'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将打开一个`vi`环境。导航到当前显示为`type:` `ClusterIP`（第27行）的行，并将其更改为`type: LoadBalancer`，如*图4.29*所示。要进行修改，按下*I*键，输入更改内容，按下*Esc*键，输入`:wq!`，然后按*Enter*保存更改：![显示部署的回滚历史](img/B17338_04_29.jpg)'
- en: 'Figure 4.29: Changing this line to type: LoadBalancer'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图4.29：将这一行更改为`type: LoadBalancer`'
- en: 'Once the changes are saved, you can watch the service object until the public
    IP becomes available. To do this, type the following:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦保存了更改，你可以通过观察服务对象，直到公网IP变为可用。为此，可以输入以下命令：
- en: '[PRE39]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It will take a couple of minutes to show you the updated IP. Once you see the
    right public IP, you can exit the `watch` command by hitting *Ctrl* + *C*.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示更新后的IP可能需要几分钟时间。一旦看到正确的公网IP，你可以通过按下*Ctrl* + *C*退出`watch`命令。
- en: This is an example of using `kubectl edit` to make changes to a Kubernetes object.
    This command will open up a text editor to interactively make changes. This means
    that you need to interact with the text editor to make the changes. This will
    not work in an automated environment. To make automated changes, you can use the
    `kubectl patch` command.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`kubectl edit`命令对Kubernetes对象进行修改的示例。该命令将打开一个文本编辑器，以交互的方式进行修改。这意味着你需要与文本编辑器进行交互来进行更改。这个方法不适用于自动化环境。要进行自动化修改，可以使用`kubectl
    patch`命令。
- en: Upgrading an application using kubectl patch
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用kubectl patch升级应用程序
- en: In the previous example, you used a text editor to make the changes to Kubernetes.
    In this example, you will use the `kubectl patch` command to make changes to resources
    on Kubernetes. The `patch` command is particularly useful in automated systems
    when you don't have access to the original YAML file that is deployed on a cluster.
    It can be used, for example, in a script or in a continuous integration/continuous
    deployment system.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你使用了文本编辑器来修改Kubernetes。在这个示例中，你将使用`kubectl patch`命令来对Kubernetes中的资源进行修改。`patch`命令在自动化系统中尤其有用，特别是当你无法访问集群中部署的原始YAML文件时。例如，在脚本或持续集成/持续部署系统中都可以使用此命令。
- en: 'There are two main ways in which to use `kubectl patch`: either by creating
    a file containing your changes (called a patch file) or by providing the changes
    inline. Both approaches will be explained here. First, in this example, you''ll
    change the image of the front-end from `v4` to `v3` using a patch file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl patch`有两种主要方式：一种是创建一个包含更改的文件（称为补丁文件），另一种是直接在命令行内提供更改。这里将解释这两种方法。首先，在这个示例中，你将使用补丁文件将前端的图像从`v4`更改为`v3`：
- en: 'Start this example by creating a file called `frontend-image-patch.yaml`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建一个名为`frontend-image-patch.yaml`的文件开始这个示例：
- en: '[PRE40]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the following text as a patch in that file:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下文本作为该文件中的补丁：
- en: '[PRE41]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This patch file uses the same YAML layout as a typical YAML file. The main thing
    about a patch file is that it only has to contain the changes and doesn't have
    to be capable of deploying the whole resource.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个补丁文件使用与典型YAML文件相同的YAML布局。补丁文件的关键之处在于，它只需包含更改，而不必具备部署整个资源的能力。
- en: 'To apply the patch, use the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要应用补丁，请使用以下命令：
- en: '[PRE42]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This command does two things: first, it reads the `frontend-image-patch.yaml`
    file using the `cat` command, and then it passes that to the `kubectl patch` command
    to execute the change.'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令执行两项操作：首先，它使用`cat`命令读取`frontend-image-patch.yaml`文件，然后将其传递给`kubectl patch`命令以执行更改。
- en: 'You can verify the changes by describing the front-end deployment and looking
    for the `Image` section:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过描述前端部署并查找`Image`部分来验证更改：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will display an output as follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示如下输出：
- en: '![Running the kubectl describe deployment frontend command to confirm if we’re
    running the old image](img/B17338_04_30.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![运行 kubectl describe deployment frontend 命令以确认我们是否正在运行旧图像](img/B17338_04_30.jpg)'
- en: 'Figure 4.30: After the patch, we are running the old image'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.30：补丁后，我们正在运行旧图像
- en: This was an example of using the `patch` command using a patch file. You can
    also apply a patch directly on the command line without creating a YAML file.
    In this case, you would describe the change in JSON rather than in YAML.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是使用补丁文件执行`patch`命令的一个示例。你也可以直接在命令行中应用补丁，而无需创建YAML文件。在这种情况下，你将以JSON格式描述更改，而不是YAML格式。
- en: 'Let''s run through an example in which we will revert the image change to `v4`:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们演示一个示例，在其中我们将图像更改恢复为`v4`：
- en: 'Run the following command to patch the image back to `v4`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将图像补丁回`v4`版本：
- en: '[PRE44]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can verify this change by describing the deployment and looking for the
    `Image` section:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过描述部署并查找`Image`部分来验证这一更改：
- en: '[PRE45]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will display the output shown in *Figure 4.31*:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示在*图 4.31*中所示的输出：
- en: '![Running the kubectl describe deployment frontend command to confirm if we’re
    running the new image](img/B17338_04_31.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![运行 kubectl describe deployment frontend 命令以确认我们是否正在运行新图像](img/B17338_04_31.jpg)'
- en: 'Figure 4.31: After another patch, we are running the new version again'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31：再次补丁后，我们正在运行新版本
- en: 'Before moving on to the next example, let''s remove the guestbook application
    from the cluster:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一个示例之前，让我们从集群中移除guestbook应用程序：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So far, you have explored three ways of upgrading Kubernetes applications. First,
    you made changes to the actual YAML file and applied them using `kubectl apply`.
    Afterward, you used `kubectl edit` and `kubectl patch` to make more changes. In
    the final section of this chapter, you will use Helm to upgrade an application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经探索了三种升级Kubernetes应用程序的方法。首先，你修改了实际的YAML文件，并使用`kubectl apply`应用了更改。随后，你使用了`kubectl
    edit`和`kubectl patch`进行更多的更改。在本章的最后一节中，你将使用Helm来升级应用程序。
- en: Upgrading applications using Helm
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm升级应用程序
- en: 'This section will explain how to perform upgrades using Helm operators:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释如何使用Helm运维进行升级：
- en: 'Run the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE47]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will force an update of the image of the MariaDB container. Let''s first
    check the version of the current image:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将强制更新MariaDB容器的图像。首先，我们检查当前图像的版本：
- en: '[PRE48]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At the time of writing, the image version is `10.5.8-debian-10-r46` as follows:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在写作时，图像版本为`10.5.8-debian-10-r46`，如下所示：
- en: '![Output displaying the current image version of the StatefulSet](img/B17338_04_32.jpg)'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![显示当前StatefulSet图像版本的输出](img/B17338_04_32.jpg)'
- en: '[PRE49]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will generate the output shown in *Figure 4.33*:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成在*图 4.33*中所示的输出：
- en: '![Output displaying encrypted secrets, that is, the MariaDB passwords](img/B17338_04_33.jpg)'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![显示加密的机密信息，即MariaDB密码的输出](img/B17338_04_33.jpg)'
- en: '[PRE50]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will show us the decoded root password and the decoded database password,
    as shown in *Figure 4.34*:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示解码后的根密码和解码后的数据库密码，如*图 4.34*所示：
- en: '![Output displaying the unencrypted version of the MariaDB passwords](img/B17338_04_34.jpg)'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示未加密的 MariaDB 密码版本](img/B17338_04_34.jpg)'
- en: '[PRE51]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can update the image tag with Helm and then watch the pods change using
    the following command:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 Helm 更新镜像标签，然后通过以下命令查看 Pod 的变化：
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will update the image of MariaDB and make a new pod start. You should
    see an output similar to *Figure 4.35*, where you can see the previous version
    of the database pod being terminated, and a new one start:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将更新 MariaDB 的镜像并启动一个新的 Pod。您应该会看到类似于*图 4.35*的输出，其中可以看到前一个版本的数据库 Pod 被终止，新 Pod
    启动：
- en: '![Output displaying the previous MariaDB pod beingterminated and a new one
    starting](img/B17338_04_35.jpg)'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示前一个 MariaDB Pod 被终止并且一个新的 Pod 启动](img/B17338_04_35.jpg)'
- en: '[PRE53]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will generate an output as shown in *Figure 4.36*:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成一个输出，如*图 4.36*所示：
- en: '![Output displaying the new image version](img/B17338_04_36.jpg)'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![输出显示新镜像版本](img/B17338_04_36.jpg)'
- en: 'Figure 4.36: Showing the new image'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.36：显示新镜像
- en: 'Finally, clean up by running the following command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过运行以下命令进行清理：
- en: '[PRE54]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You have now learned how to upgrade an application using Helm. As you have seen
    in this example, upgrading using Helm can be done by using the `--set` operator.
    This makes performing upgrades and multiple deployments using Helm efficient.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学会了如何使用 Helm 升级应用程序。正如您在这个例子中看到的，使用 Helm 升级可以通过使用 `--set` 操作符来完成。这使得使用
    Helm 执行升级和多次部署变得更加高效。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This a chapter covered a plethora of information on building scalable applications.
    The goal was to show you how to scale deployments with Kubernetes, which was achieved
    by creating multiple instances of your application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了关于构建可扩展应用程序的大量信息。目标是向您展示如何使用 Kubernetes 来扩展部署，方法是创建应用程序的多个实例。
- en: We started the chapter by looking at how to define the use of a load balancer
    and leverage the deployment scale feature in Kubernetes to achieve scalability.
    With this type of scalability, you can also achieve failover by using a load balancer
    and multiple instances of the software for stateless applications. We also looked
    into using the HPA to automatically scale your deployment based on load.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过研究如何定义负载均衡器的使用以及如何利用 Kubernetes 中的部署扩展功能来实现可扩展性，开始了本章内容。通过这种类型的可扩展性，您还可以通过使用负载均衡器和多个无状态应用程序的实例来实现故障转移。我们还研究了如何使用
    HPA 根据负载自动扩展您的部署。
- en: After that, we looked at how you can scale the cluster itself. First, we manually
    scaled the cluster, and afterward we used a cluster autoscaler to scale the cluster
    based on application demand.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们研究了如何扩展集群本身。首先，我们手动扩展了集群，随后我们使用集群自动扩展器根据应用程序需求扩展集群。
- en: 'We finished the chapter by looking into different ways to upgrade a deployed
    application: first, by exploring updating YAML files manually, and then by learning
    two additional `kubectl` commands (`edit` and `patch`) that can be used to make
    changes. Finally, we learned how Helm can be used to perform these upgrades.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过研究不同的方式来升级已部署的应用程序结束了本章内容：首先，通过手动更新 YAML 文件，然后学习了两个额外的 `kubectl` 命令（`edit`
    和 `patch`），这些命令可以用来进行更改。最后，我们了解了如何使用 Helm 来执行这些升级。
- en: In the next chapter, we will look at a couple of common failures that you may
    face while deploying applications to AKS and how to fix them.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在将应用程序部署到 AKS 时可能遇到的几种常见故障及其解决方法。
