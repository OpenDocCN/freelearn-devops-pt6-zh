- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Extending Security Using Open Policy Agent
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开放策略代理扩展安全性
- en: So far, we have covered Kubernetes’ built-in authentication and authorization
    capabilities, which help to secure a cluster. While this will cover most use cases,
    it doesn’t cover all of them. Some security best practices that Kubernetes can’t
    handle are pre-authorizing container registries and ensuring that Ingress objects
    don’t overlap (though most Ingress controllers do check, such as NGINX).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了Kubernetes的内置认证和授权功能，这有助于保护集群。虽然这将涵盖大多数用例，但并不涵盖所有用例。一些Kubernetes无法处理的安全最佳实践包括预授权容器注册表和确保Ingress对象不重叠（尽管大多数Ingress控制器都会检查，例如NGINX）。
- en: These tasks are left to outside systems and are called dynamic admission controllers.
    **Open Policy Agent** (**OPA**) and its Kubernetes native sub-project, **Gatekeeper**,
    is one of the most popular ways to handle these use cases. This chapter will detail
    the deployment of OPA and Gatekeeper, how OPA is architected, and how to develop
    policies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务由外部系统完成，并称为动态准入控制器。**开放策略代理**（**OPA**）及其Kubernetes本地子项目**Gatekeeper**是处理这些用例最流行的方式之一。本章将详细介绍OPA和Gatekeeper的部署方法，OPA的架构以及如何编写策略。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to dynamic admission controllers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态准入控制器简介
- en: What is OPA and how does it work?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OPA是什么以及它是如何工作的？
- en: Using Rego to write policies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rego编写策略
- en: Enforcing Ingress policies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行Ingress策略
- en: Mutating objects and default values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变对象和默认值
- en: Creating policies without Rego
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不使用Rego的策略
- en: Once you’ve completed this chapter, you’ll be on your way to developing and
    implementing important policies for your cluster and workloads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将开始为集群和工作负载开发和实施重要的策略。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the hands-on exercises in this chapter, you will require an Ubuntu
    22.04 server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的实践练习，您需要一台Ubuntu 22.04服务器。
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub存储库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11)。
- en: Introduction to dynamic admission controllers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态准入控制器简介
- en: An admission controller is a specialized webhook in Kubernetes that runs when
    an object is created, updated, or deleted. When one of these three events happens,
    the API server sends information about the object and operation to the webhook.
    Admission controllers can be used to either determine if an operation should happen
    or give the cluster operator a chance to change the object definition before it’s
    processed by the API server. We’re going to look at using this mechanism to both
    enforce security and extend the functionality of Kubernetes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制器是Kubernetes中的一种专用Webhook，当对象被创建、更新或删除时运行。当发生这三个事件之一时，API服务器将对象和操作的信息发送到Webhook。准入控制器可用于确定是否应执行操作，或者给集群操作员修改对象定义的机会，然后再由API服务器处理。我们将研究如何使用此机制来强制执行安全性并扩展Kubernetes的功能。
- en: 'There are two ways to extend Kubernetes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Kubernetes的两种方法：
- en: Build a custom resource definition so that you can define your own objects and
    APIs.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义资源定义，以便定义您自己的对象和API。
- en: Implement a webhook that listens for requests from the API server and responds
    with the necessary information. You may recall that in *Chapter 6*, *Integrating
    Authentication into Your Cluster*, we explained that a custom webhook could be
    used to validate tokens.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个Webhook，监听API服务器的请求并回复必要的信息。您可能还记得，在*第6章*，*将认证集成到您的集群中*中，我们解释了可以使用自定义Webhook来验证令牌。
- en: Starting in Kubernetes 1.9, a webhook can be defined as a dynamic admission
    controller, and in 1.16, the dynamic admission controller API became **Generally
    Available** (**GA**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.9开始，Webhook可以被定义为动态准入控制器，在1.16中，动态准入控制器API变为**普遍可用**（**GA**）。
- en: There are two types of dynamic admission controllers, validating and mutating.
    Validating admission controllers verify that a new object, update, or deletion
    can move forward. Mutation allows a webhook to change the payload of an object’s
    creation, deletion, or update. This section will focus on the details of admission
    controllers. We’ll talk more about mutation controllers in the next chapter, *Chapter
    12*, *Node Security with GateKeeper*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的动态准入控制器，验证型和变更型。验证型准入控制器验证新的对象、更新或删除是否可以继续进行。变更型准入控制器允许 Webhook 修改对象的创建、删除或更新的负载。本节将重点介绍准入控制器的细节。我们将在下一章中更详细地讨论变更控制器，*第12章*，*使用
    GateKeeper 的节点安全性*。
- en: The protocol is very straightforward. Once a dynamic admission controller is
    registered for a specific object type, the webhook is called with an HTTP POST
    every time an object of that type is created or edited. The webhook is then expected
    to return JSON, which represents whether it is allowed or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 协议非常简单。每当创建或编辑某种类型的对象时，只要为该类型的对象注册了动态准入控制器，Webhook 就会通过 HTTP POST 被调用。然后，Webhook
    预计返回 JSON，表示是否允许该操作。
- en: As of 1.16, `admission.k8s.io/v1` is at GA. All examples will use the GA version
    of the API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.16 版本开始，`admission.k8s.io/v1` 已进入 GA 阶段。所有示例将使用 GA 版本的 API。
- en: 'The request submitted to the webhook is made up of several sections. We’re
    not including an example here because of how large an `Admission` object can get,
    but we’ll use [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/example_admission_request.json](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/example_admission_request.json)
    as an example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提交到 Webhook 的请求由多个部分组成。由于 `Admission` 对象可能非常大，我们在此不提供示例，但我们将使用 [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/example_admission_request.json](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/example_admission_request.json)
    作为示例：
- en: '**Object identifiers**: The `resource` and `subResource` attributes identify
    the object, API, and group. If the version of the object is being upgraded, then
    `requestKind`, `requestResource`, and `requestSubResource` are specified. Additionally,
    `namespace` and `operation` are provided to provide the location of the object
    and whether it is a `CREATE`, `UPDATE`, `DELETE`, or `CONNECT` operation. In our
    example, a `Deployment` resource with a `subResource` of `Scale` is being created
    to scale our `Deployment` up in the `my-namespace` namespace.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象标识符**: `resource` 和 `subResource` 属性标识对象、API 和组。如果对象的版本正在升级，则会指定 `requestKind`、`requestResource`
    和 `requestSubResource`。此外，`namespace` 和 `operation` 用于提供对象的位置以及它是 `CREATE`、`UPDATE`、`DELETE`
    还是 `CONNECT` 操作。在我们的示例中，正在创建一个 `Deployment` 资源，并且其 `subResource` 是 `Scale`，用于在
    `my-namespace` 命名空间中扩展我们的 `Deployment`。'
- en: '**Submitter identifiers**: The `userInfo` object identifies the user and groups
    of the submitter. The submitter and the user who created the original request
    are not always the same. For instance, if a user creates a `Deployment`, then
    the `userInfo` object won’t be for the user who created the original `Deployment`;
    it will be for the `ReplicaSet` controller’s service account because the `Deployment`
    creates a `ReplicaSet` that creates the pod. In our example, a user with the `uid`
    of admin submitted the scaling request.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交者标识符**: `userInfo` 对象标识提交者的用户和组。提交者和创建原始请求的用户不总是相同的。例如，如果用户创建了一个 `Deployment`，则
    `userInfo` 对象不会是创建原始 `Deployment` 的用户；它将是 `ReplicaSet` 控制器的服务账户，因为 `Deployment`
    创建了一个 `ReplicaSet`，该 `ReplicaSet` 创建了 pod。在我们的示例中，`uid` 为 admin 的用户提交了扩展请求。'
- en: '**Object**: `object` represents the JSON of the object being submitted, whereas
    `oldObject` represents what is being replaced if this is an update. Finally, `options`
    specifies additional options for the request. In our example, the new pod with
    the new number of replicas after the scaling operation is submitted.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**: `object` 代表提交的对象的 JSON，而 `oldObject` 代表在更新操作中被替换的内容。最后，`options` 指定请求的其他选项。在我们的示例中，新的
    pod 在扩展操作后将提交，包含新的副本数。'
- en: 'The response from the webhook will simply have two attributes, the original
    `uid` from the request and `allowed`, which can be `true` or `false`. For instance,
    to allow our scaling operation to complete:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 的响应将简单地包含两个属性，即请求中的原始 `uid` 和 `allowed`，其值可以是 `true` 或 `false`。例如，为了允许我们的扩展操作完成：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `userInfo` object can create complications quickly. Since Kubernetes often
    uses multiple layers of controllers to create objects, it can be difficult to
    track usage creation based on a user who interacts with the API server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`userInfo` 对象可能会迅速引发复杂问题。由于 Kubernetes 通常使用多个层次的控制器来创建对象，因此根据与 API 服务器交互的用户来跟踪使用创建可能会变得很困难。'
- en: It’s much better to authorize based on objects in Kubernetes, such as namespace
    labels or other objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Kubernetes 中的对象进行授权会更加高效，例如命名空间标签或其他对象。
- en: A common use case is to allow developers to have a **sandbox** that they are
    administrators in, but that has very limited capacity. Instead of trying to validate
    the fact that a particular user doesn’t try to request too much memory, annotate
    a personal namespace with a limit so that the admission controller has something
    concrete to reference regardless of whether the user submits a pod or a Deployment.
    This way, the policy will check the annotation on the `namespace` instead of the
    individual user. To ensure that only the user who owns the namespace is able to
    create something in it, use RBAC to limit access.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是允许开发者拥有一个他们是管理员的 **沙箱**，但是该沙箱的容量非常有限。与其验证某个特定用户是否请求了过多的内存，不如在个人命名空间上添加一个限制注解，这样准入控制器就有了一个具体的参考依据，不管用户是提交了
    Pod 还是 Deployment。这样，策略就会检查 `namespace` 上的注解，而不是检查单独的用户。为了确保只有命名空间的所有者能够在其中创建资源，可以使用
    RBAC 来限制访问。
- en: 'One final point on generic validating webhooks: there is no way to specify
    a key or password. It’s an anonymous request. While, in theory, a validating webhook
    could be used to implement updates to your cluster, it is not recommended. For
    instance, you could use a validating webhook to create a `ClusterRoleBinding`
    when creating a `Namespace`, but that would mean that your policy check is not
    repeatable. It’s best to separate policy checking and workflow.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通用验证 Webhook 的最后一点：没有办法指定密钥或密码。这是一个匿名请求。虽然理论上，验证 Webhook 可以用于实现对集群的更新，但并不推荐这样做。例如，你可以使用验证
    Webhook 在创建 `Namespace` 时创建 `ClusterRoleBinding`，但这意味着你的策略检查就无法重复进行。最好将策略检查和工作流分开。
- en: Now that we’ve covered how Kubernetes implements dynamic access controllers,
    we’ll look at one of the most popular options in OPA.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了 Kubernetes 如何实现动态访问控制器，接下来我们将查看 OPA 中最受欢迎的一个选项。
- en: What is OPA and how does it work?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 OPA，它是如何工作的？
- en: OPA is a lightweight authorization engine that fits well in Kubernetes. It didn’t
    get its start in Kubernetes, but it’s certainly found a home there. There’s no
    requirement to build dynamic admission controllers in OPA, but it’s very good
    at it and there are extensive resources and existing policies that can be used
    to start your policy library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OPA 是一个轻量级的授权引擎，非常适合在 Kubernetes 中使用。它并非一开始就诞生于 Kubernetes，但无疑在这里找到了合适的定位。OPA
    并不要求构建动态准入控制器，但它在这方面非常出色，并且有大量资源和现成的策略可以用来开始构建你的策略库。
- en: This section provides a high-level overview of OPA and its components with the
    rest of the chapter getting into the details of an OPA implementation in Kubernetes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了 OPA 及其组件的高级概述，接下来的章节将详细介绍 OPA 在 Kubernetes 中的实现。
- en: OPA architecture
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OPA 架构
- en: 'OPA comprises three components – the HTTP listener, the policy engine, and
    the database:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OPA 由三个组件组成——HTTP 监听器、策略引擎和数据库：
- en: '![Figure 11.1 – OPA architecture ](img/B21165_11_01-01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – OPA 架构 ](img/B21165_11_01-01.png)'
- en: 'Figure 11.1: OPA architecture'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：OPA 架构
- en: 'The database used by OPA is in memory and ephemeral. It doesn’t persist information
    used to make policy decisions. On the one hand, this makes OPA very scalable since
    it is essentially an authorization microservice. On the other hand, this means
    that every instance of OPA must be maintained on its own and must be kept in sync
    with authoritative data:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: OPA 使用的数据库是内存中的，并且是短暂的。它不会持久化用于做出策略决策的信息。一方面，这使得 OPA 非常具备可扩展性，因为它本质上是一个授权微服务。另一方面，这意味着每个
    OPA 实例都必须独立维护，并且必须与权威数据保持同步：
- en: '![Figure 11.2 – OPA in Kubernetes ](img/B21165_11_02-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – Kubernetes 中的 OPA ](img/B21165_11_02-01.png)'
- en: 'Figure 11.2: OPA in Kubernetes'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：Kubernetes 中的 OPA
- en: When used in Kubernetes, OPA populates its database using a sidecar, called
    `kube-mgmt`, which sets up watches on the objects you want to import into OPA.
    As objects are created, deleted, or changed, `kube-mgmt` updates the data in its
    OPA instance. This means that OPA is “eventually consistent” with the API server,
    but it won’t necessarily be a real-time representation of the objects in the API
    server. Since the entire etcd database is essentially being replicated over and
    over again, great care needs to be taken in order to refrain from replicating
    sensitive data, such as `Secrets`, in the OPA database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当 OPA 用于 Kubernetes 时，它通过一个名为 `kube-mgmt` 的 sidecar 填充其数据库，该 sidecar 会对你想导入到
    OPA 中的对象设置监视。当对象被创建、删除或更改时，`kube-mgmt` 会更新其 OPA 实例中的数据。这意味着 OPA 与 API 服务器是“最终一致”的，但它不一定是
    API 服务器中对象的实时表示。由于整个 etcd 数据库基本上被一遍又一遍地复制，因此必须特别小心，避免将敏感数据（如 `Secrets`）复制到 OPA
    数据库中。
- en: Now, let’s get introduced to the OPA policy language, Rego.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍一下 OPA 策略语言——Rego。
- en: Rego, the OPA policy language
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rego，OPA 策略语言
- en: 'We’ll cover the details of Rego in the next section in detail. The main point
    to mention here is that **Rego** is a **policy evaluation language**, not a generic
    programming language. Rego can be difficult for developers who are used to languages
    such as Golang, Java, or JavaScript, which support complex logic such as iterators
    and loops. Rego is designed to evaluate policy and is streamlined as such. For
    instance, if you wanted to write code in Java to check that all the container
    images in a pod started with one of a list of registries, it would look something
    like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节详细介绍 Rego。这里要提到的关键点是，**Rego** 是一种**策略评估语言**，而不是通用编程语言。对于习惯使用 Golang、Java
    或 JavaScript 这类支持复杂逻辑（如迭代器和循环）的开发者来说，Rego 可能会显得有些困难。Rego 的设计目的是评估策略，因此它被精简成了一个专注于此的语言。例如，如果你想用
    Java 编写代码来检查一个 pod 中所有容器镜像是否以指定的注册表之一为开头，代码可能会是这样的：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code iterates over every container and every allowed registry to make
    sure that all of the images conform to the correct policy. The same code in Rego
    is much smaller:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历每一个容器和每一个允许的注册表，确保所有的镜像都符合正确的策略。Rego 中相同的代码要简洁得多：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding rule will evaluate to `true` if any of the images on the containers
    come from unauthorized registries. We’ll cover the details of how this code works
    later in the chapter. The key to understanding why this code is so much more compact
    is that much of the boilerplate of loops and tests is inferred in Rego. The first
    line generates a list of conforming images, and the second line makes sure that
    the number of conforming images matches the number of total images. If they don’t
    match, then one or more of the images must come from invalid registries. The ability
    to write compact policy code is what makes Rego so well suited to admission controllers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器中的任何镜像来自未授权的注册表，上述规则将评估为 `true`。我们将在本章稍后的部分详细讲解这段代码是如何工作的。理解这段代码为何如此简洁的关键在于，Rego
    推断了大部分循环和测试的样板代码。第一行生成了一个符合要求的镜像列表，第二行确保符合要求的镜像数量与镜像总数相匹配。如果它们不匹配，那么其中一个或多个镜像必定来自无效的注册表。能够编写简洁的策略代码是
    Rego 非常适合用作准入控制器的原因。
- en: So far, we’ve focused on generic OPA and Rego. In the early days, you would
    integrate Kubernetes directly into OPA using `ConfigMaps` to store policies; however,
    this proved to be really unwieldy. Microsoft developed a tool called GateKeeper,
    which is Kubernetes native and makes it easier to get the most out of OPA in Kubernetes.
    So, now, let’s get introduced to Gatekeeper.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要集中讨论了通用的 OPA 和 Rego。在早期，你需要使用 `ConfigMaps` 将 Kubernetes 直接集成到 OPA
    中以存储策略；然而，这证明是非常不方便的。微软开发了一个名为 GateKeeper 的工具，它是 Kubernetes 原生的，使得在 Kubernetes
    中更容易充分利用 OPA。现在，让我们介绍一下 Gatekeeper。
- en: Gatekeeper
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gatekeeper
- en: Thus far, everything discussed has been generic to OPA. It was mentioned at
    the beginning of the chapter that OPA didn’t get its start in Kubernetes. Early
    implementations had a sidecar that kept the OPA database in sync with the API
    server, but you had to manually create policies as `ConfigMap` objects and manually
    generate responses for webhooks. In 2018, Microsoft debuted Gatekeeper ([https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper))
    to provide a Kubernetes-native experience.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，讨论的内容都是关于OPA的通用性。章节开头提到，OPA并不是最早在Kubernetes中出现的。早期的实现有一个sidecar，它将OPA数据库与API服务器保持同步，但你需要手动创建作为`ConfigMap`对象的策略，并手动为webhook生成响应。2018年，微软推出了Gatekeeper（[https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)），提供了一个原生的Kubernetes体验。
- en: In addition to moving from `ConfigMap` objects to proper custom resources, Gatekeeper
    adds an audit function that lets you test policies against existing objects. If
    an object violates a policy, then a violation entry is created to track it. This
    way, you can get a snapshot of the existing policy violations in your cluster
    or know whether something was missed during Gatekeeper downtime due to an upgrade.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从`ConfigMap`对象迁移到适当的自定义资源之外，Gatekeeper还增加了审计功能，让你可以针对现有对象测试策略。如果某个对象违反了策略，就会创建一个违规条目来跟踪它。通过这种方式，你可以获得集群中现有策略违规的快照，或者知道在Gatekeeper因升级而停机时是否遗漏了某些内容。
- en: A major difference between Gatekeeper and generic OPA is that in Gatekeeper,
    OPA’s functionality is not exposed via an API anyone can call. OPA is embedded,
    with Gatekeeper calling OPA directly to execute policies and keep the database
    up to date. Decisions can only be made based on data in Kubernetes or by pulling
    data at evaluation time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Gatekeeper与通用OPA的一个主要区别在于，在Gatekeeper中，OPA的功能不是通过任何人都能调用的API暴露的。OPA是嵌入式的，Gatekeeper直接调用OPA来执行策略并保持数据库的最新状态。决策只能基于Kubernetes中的数据，或者在评估时提取数据。
- en: Deploying Gatekeeper
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署Gatekeeper
- en: The examples that will be used will assume the use of Gatekeeper instead of
    a generic OPA deployment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用的示例假设使用的是Gatekeeper，而不是通用的OPA部署。
- en: 'First, create a new cluster to deploy GateKeeper into:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的集群来部署GateKeeper：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the new cluster is running, based on the directions from the Gatekeeper
    project, use the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 新集群启动后，按照Gatekeeper项目的指示，使用以下命令：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This launches the Gatekeeper namespace pods and creates the validating webhook.
    Once deployed, move on to the next section. We’ll cover the details of using Gatekeeper
    throughout the rest of this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Gatekeeper命名空间的pod并创建验证webhook。部署完成后，继续下一节。我们将在本章剩余部分详细讲解如何使用Gatekeeper。
- en: Automated testing framework
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试框架
- en: OPA has a built-in automated testing framework for your policies. This is one
    of the most valuable aspects of OPA. Being able to test policies consistently
    before deployment can save you hours of debugging time. When writing policies,
    have a file with the same name as your policies file, but with `_test` in the
    name. For instance, to have test cases associated with `mypolicies.rego`, have
    the test cases in `mypolicies_test.rego` in the same directory. Running the `opa`
    `test` will then run your test cases. We’ll show how to use this to debug your
    code in the next section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: OPA为你的策略提供了一个内置的自动化测试框架。这是OPA最有价值的方面之一。在部署前能够持续测试策略，可以节省大量的调试时间。在编写策略时，创建一个与策略文件同名但在名称中带有`_test`的文件。例如，如果你的策略文件是`mypolicies.rego`，则测试用例应保存在同一目录下的`mypolicies_test.rego`文件中。运行`opa
    test`命令将执行你的测试用例。我们将在下一节展示如何使用它来调试代码。
- en: Having covered the basics of OPA and how it is constructed, the next step is
    to learn how to use Rego to write policies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了OPA的基础知识以及其构建方式后，下一步是学习如何使用Rego编写策略。
- en: Using Rego to write policies
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rego编写策略
- en: 'Rego is a language specifically designed for policy writing. It is different
    from most languages you have likely written code in. Typical authorization code
    will look something like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Rego是一种专门为编写策略而设计的语言。它不同于你可能编写过的大多数编程语言。典型的授权代码可能看起来像这样：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Authorization code will generally default to unauthorized, with a specific condition
    having to happen in order to allow the final action to be authorized. Rego takes
    a different approach. Rego is generally written to authorize everything unless
    a specific set of conditions happens.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 授权码通常默认为未授权状态，必须满足特定条件才能允许最终操作被授权。而Rego采取了不同的方法。Rego通常会授权所有操作，除非发生特定的一组条件。
- en: 'Another major difference between Rego and more general programming languages
    is that there are no explicit `if`/`then`/`else` control statements. When a line
    of Rego is going to make a decision, the code is interpreted as “If this line
    is false, stop execution.” For instance, the following code in Rego says “If the
    image starts with `myregistry.lan/`, then stop the execution of the policy and
    pass this check; otherwise, generate an error message”:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Rego与一般编程语言之间的另一个主要区别是，没有明确的`if`/`then`/`else`控制语句。当一行Rego代码需要做出决定时，该行代码的含义是“如果这行代码为假，则停止执行。”例如，以下Rego代码表示：“如果镜像以`myregistry.lan/`开头，则停止执行策略并通过此检查；否则，生成错误信息”：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same code in Java might look as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的代码在Java中可能如下所示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This difference between inferred control statements and explicit control statements
    is often the steepest part of the learning curve when learning Rego. While this
    can produce a steeper learning curve than other languages, Rego more than makes
    up for it by making it easy to test and build policies in an automated and manageable
    way. Another benefit of Rego is that it can be used for application-level authorizations.
    We’ll cover this more when we get to Istio later in the book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式控制语句和显式控制语句之间的这种差异通常是学习Rego时最陡峭的部分。虽然这可能比其他语言有更陡峭的学习曲线，但Rego通过使测试和构建策略变得简单、自动化和可管理，弥补了这一点。Rego的另一个优点是它可以用于应用级的授权。我们将在本书后面讲解Istio时详细讨论这一点。
- en: OPA can be used to automate the testing of policies. This is incredibly important
    when writing code that the security of your cluster relies upon. Automating your
    testing will help speed up your development and will increase your security by
    catching any bugs introduced into previously working code by means of new working
    code. Next, let’s work through the life cycle of writing an OPA policy, testing
    it, and deploying it to our cluster.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OPA可以用于自动化策略的测试。这在编写依赖于集群安全性的代码时非常重要。自动化测试有助于加快开发进程，并通过捕捉由新工作代码引入的bug，从而提高安全性。接下来，让我们一起走过编写OPA策略、测试它并将其部署到集群的生命周期。
- en: Developing an OPA policy
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发OPA策略
- en: 'A common example of using OPA is to limit which registries a pod can come from.
    This is a common security measure in clusters to help restrict which pods can
    run on a cluster. For instance, we’ve mentioned Bitcoin miners a few times. If
    the cluster won’t accept pods except from your own internal registry, then that’s
    one more step that needs to be taken for a bad actor to abuse your cluster. First,
    let’s write our policy, taken from the OPA documentation website ([https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/](https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/)):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OPA的一个常见示例是限制Pod可以来自哪些注册表。这是在集群中常见的安全措施，用于限制可以在集群中运行的Pod。例如，我们曾提到比特币矿工。如果集群只接受来自你自己内部注册表的Pod，那么这就是阻止恶意行为者滥用集群的一步。首先，让我们编写我们的策略，取自OPA文档网站
    ([https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/](https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/))：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line in this code declares the `package` our policy is in. Everything
    is stored in OPA in a package, both data and policies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一行声明了我们策略所在的`package`。OPA中的所有内容，包括数据和策略，都存储在一个包中。
- en: Packages in OPA are like directories on a filesystem. When you place a policy
    in a package, everything is relative to that package. In this case, our policy
    is in the `k8sallowedregistries` package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OPA中的包类似于文件系统中的目录。当你将策略放入一个包中时，所有内容都是相对于该包的。在本例中，我们的策略位于`k8sallowedregistries`包中。
- en: The next section defines a rule. This rule ultimately will be `undefined` if
    our pod has an image that comes from `quay.io`. If the pod doesn’t have an image
    from `quay.io`, the rule will return `true`, signifying that the registry is invalid.
    Gatekeeper will interpret this as a failure and return `false` to the API server
    when the pod is evaluated during a dynamic admission review.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节定义了一个规则。如果我们的 pod 使用来自`quay.io`的镜像，这个规则最终将是`undefined`。如果 pod 没有来自`quay.io`的镜像，则规则返回`true`，表示注册表无效。当在动态准入审核期间评估
    pod 时，Gatekeeper 会将其视为失败，并向 API 服务器返回`false`。
- en: The next two rules look very similar. The first of the `input_images` rules
    says “Evaluate the calling rule against every `container` in the object’s `spec.container`,”
    matching pod objects directly submitted to the API server and extracting all the
    `image` values for each `container`. The second `input_images` rule states “Evaluate
    the calling rule against every `container` in the object’s `spec.template.spec.containers`"
    to short circuit `Deployment` objects and `StatefulSets`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个规则非常相似。第一个`input_images`规则表示“对对象的`spec.container`中的每个`container`进行调用规则的评估”，直接匹配提交给
    API 服务器的 pod 对象，并提取每个`container`的所有`image`值。第二个`input_images`规则表示“对对象的`spec.template.spec.containers`中的每个`container`进行调用规则的评估”，以短路`Deployment`对象和`StatefulSets`。
- en: 'Finally, we add the rule that Gatekeeper requires to notify the API server
    of a failed evaluation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加 Gatekeeper 需要的规则，以便在评估失败时通知 API 服务器：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This rule will return an empty `msg` if the registry is valid. It’s a good idea
    to break up your code into code that makes policy decisions and code that responds
    with feedback. This makes it easier to test, which we’ll do next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册表有效，这个规则将返回一个空的`msg`。将代码拆分为做出策略决策的代码和响应反馈的代码是一个好主意。这使得测试更容易，接下来我们就来做这件事。
- en: Testing an OPA policy
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 OPA 策略
- en: 'Once we have written our policy, we want to set up an automated test. Just
    as with testing any other code, it’s important that your test cases cover both
    expected and unexpected input. It’s also important to test both positive and negative
    outcomes. It’s not enough to corroborate that our policy allowed a correct registry;
    we also need to make sure it stops an invalid one. Here are eight test cases for
    our code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写完策略，我们希望设置一个自动化测试。与测试任何其他代码一样，重要的是你的测试用例能够覆盖预期和意外的输入。同样，测试正面和负面的结果也很重要。仅仅验证我们的策略允许正确的注册表是不够的；我们还需要确保它能阻止无效的注册表。以下是我们代码的八个测试用例：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are eight tests in total: two tests to make sure that the proper error
    message is returned when there’s an issue, and six tests covering two use cases
    for three input types. We’re testing simple pod definitions, `Deployment`, and
    `CronJob`. To validate success or failure as expected, we have included definitions
    that have `image` attributes that include `docker.io` and `quay.io` for each input
    type. The code is abbreviated for print but can be downloaded from [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/simple-opa-policy/rego/](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/simple-opa-policy/rego/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有八个测试：两个测试确保在出现问题时返回正确的错误消息，六个测试涵盖三种输入类型的两种使用情况。我们正在测试简单的 pod 定义、`Deployment`
    和 `CronJob`。为了验证预期的成功或失败，我们为每种输入类型包括了具有`image`属性的定义，其中包含`docker.io`和`quay.io`。代码为了打印而做了简化，但可以从[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/simple-opa-policy/rego/](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/simple-opa-policy/rego/)下载。
- en: 'To run the tests, first, install the OPA command-line executable as per the
    OPA website: [https://www.openpolicyagent.org/docs/latest/#running-opa](https://www.openpolicyagent.org/docs/latest/#running-opa).
    Once it has been downloaded, go to the `simple-opa-policy/rego` directory and
    run the tests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，首先按照 OPA 网站上的说明安装 OPA 命令行可执行文件：[https://www.openpolicyagent.org/docs/latest/#running-opa](https://www.openpolicyagent.org/docs/latest/#running-opa)。下载后，进入`simple-opa-policy/rego`目录并运行测试：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Seven of the tests passed, but `test_cronjob_registry_not_allowed` failed. The
    `CronJob` submitted as `input` should not be allowed because its `image` uses
    `docker.io`. The reason it snuck through was that `CronJob` objects follow a different
    pattern to `Pods` and `Deployments`, so our two `input_image` rules won’t load
    any of the container objects from the `CronJob`. The good news is that when the
    `CronJob` ultimately submits the pod, Gatekeeper will not validate it, thereby
    preventing it from running. The bad news is that no one will know this until the
    pod is supposed to be run. Making sure we pick up `CronJob` objects in addition
    to our other objects with containers in them will make it much easier to debug
    because the `CronJob` won’t be accepted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 七个测试通过，但 `test_cronjob_registry_not_allowed` 测试失败了。提交为 `input` 的 `CronJob` 不应被允许，因为其
    `image` 使用了 `docker.io`。它之所以被漏掉，是因为 `CronJob` 对象遵循与 `Pods` 和 `Deployments` 不同的模式，因此我们的两个
    `input_image` 规则无法加载任何来自 `CronJob` 的容器对象。好消息是，当 `CronJob` 最终提交 pod 时，Gatekeeper
    不会验证它，从而防止它运行。坏消息是，直到 pod 应该被运行时，才会发现这个问题。确保我们在检查容器对象时，除了其他容器对象外，还能检查 `CronJob`
    对象，这样会使调试变得更加容易，因为 `CronJob` 不会被接受。
- en: 'To get all tests passing, add a new `input_container` rule to the `limitregistries.rego`
    file in the GitHub repo that will match the container used by a `CronJob`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让所有测试通过，在 GitHub 仓库中的 `limitregistries.rego` 文件中添加一个新的 `input_container` 规则，以匹配
    `CronJob` 使用的容器：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, running the tests will show that everything passes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试将显示一切通过：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With a policy that has been tested, the next step is to integrate the policy
    into Gatekeeper.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略经过测试后，下一步是将策略集成到 Gatekeeper 中。
- en: Deploying policies to Gatekeeper
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将策略部署到 Gatekeeper
- en: 'The policies we’ve created need to be deployed to Gatekeeper, which provides
    Kubernetes custom resources that policies need to be loaded into. The first custom
    resource is `ConstraintTemplate`, which is where the Rego code for our policy
    is stored. This object lets us specify parameters in relation to our policy enforcement,
    and we’ll cover this next. To keep things simple, create a template with no parameters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的策略需要部署到 Gatekeeper，Gatekeeper 提供 Kubernetes 自定义资源，策略需要加载到这些资源中。第一个自定义资源是
    `ConstraintTemplate`，它存储了我们策略的 Rego 代码。这个对象让我们能够指定与策略执行相关的参数，接下来我们将介绍这个。为了简单起见，创建一个没有参数的模板：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The entire source code for this template is available at [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/simple-opa-policy/yaml/gatekeeper-policy-template.yaml](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/simple-opa-policy/yaml/gatekeeper-policy-template.yaml).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板的完整源代码可以在 [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/simple-opa-policy/yaml/gatekeeper-policy-template.yaml](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/blob/main/chapter11/simple-opa-policy/yaml/gatekeeper-policy-template.yaml)
    查看。
- en: 'Once created, the next step is to apply the policy by creating a constraint
    based on the template. Constraints are objects in Kubernetes based on the configuration
    of `ConstraintTemplate`. Notice that our template defines a custom resource definition.
    This gets added to the `constraints.gatekeeper.sh` API group. If you look at the
    list of CRDs on your cluster, you’ll see `k8sallowedregistries` listed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，下一步是通过基于模板创建约束来应用策略。约束是 Kubernetes 中的对象，基于 `ConstraintTemplate` 的配置。请注意，我们的模板定义了一个自定义资源定义。它会被添加到
    `constraints.gatekeeper.sh` API 组中。如果查看集群中的 CRD 列表，你会看到 `k8sallowedregistries`
    被列出：
- en: '![Figure 11.3 – CRD created by ConstraintTemplate ](img/B21165_11_03.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 由 ConstraintTemplate 创建的 CRD](img/B21165_11_03.png)'
- en: 'Figure 11.3: CRD created by ConstraintTemplate'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：由 ConstraintTemplate 创建的 CRD
- en: Creating the constraint means creating an instance of the object defined in
    the template.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建约束意味着创建一个由模板定义的对象实例。
- en: 'To keep from causing too much havoc in our cluster, we’re going to restrict
    this policy to the `testpolicy` namespace:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在我们的集群中造成过多的混乱，我们将把此策略限制在 `testpolicy` 命名空间中：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The constraint limits the policy we wrote to just `Deployment`, `CronJob`,
    and `Pod` objects in the `testpolicy` namespace. Once our policy is created, if
    we try to create a pod in the `testpolicy` namespace that comes from `docker.io`,
    it will fail because the image comes from `docker.io`, not `quay.io`, not `quay.io`.
    First, let’s create our `testpolicy` namespace and an example `Deployment` that
    will violate this policy:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束限制了我们编写的策略，只允许在`testpolicy`命名空间中创建`Deployment`、`CronJob`和`Pod`对象。一旦我们的策略创建完成，如果我们尝试在`testpolicy`命名空间中创建一个来自`docker.io`的Pod，它会失败，因为镜像来自`docker.io`而不是`quay.io`。首先，让我们创建`testpolicy`命名空间并创建一个会违反此策略的示例`Deployment`：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last line tried to create a new `Deployment` that references `docker.io`
    instead of `quay.io`, which failed because our policy blocked it. But we also
    created a `Deployment` that violates this rule before deploying our policy, which
    means that our admission controller never received a create command. This is one
    feature of Gatekeeper over generic OPA that is very powerful: Gatekeeper audits
    your existing infrastructure against new policies. This way, you can find offending
    deployments quickly.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行尝试创建一个引用`docker.io`而不是`quay.io`的新`Deployment`，但由于我们的策略阻止了它，所以创建失败了。但我们也在部署策略之前创建了一个违反此规则的`Deployment`，这意味着我们的准入控制器从未收到过创建命令。这是Gatekeeper相比于通用OPA的一个非常强大的特性：Gatekeeper会根据新策略审计现有基础设施。通过这种方式，你可以迅速找到违规的部署。
- en: 'Next, look at the policy object. You will see that there are several violations
    in the `status` section of the object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看策略对象。你会看到在对象的`status`部分有几个违规项：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Having deployed your first Gatekeeper policy, you may quickly notice it has
    a few issues. The first is that the registry is hardcoded. This means that we’d
    need to replicate our code for every change of registry. It’s also not flexible
    for the namespace. As an example, Tremolo Security’s images are across multiple
    `github.io` registries, so instead of limiting a specific registry server, we
    may want flexibility for each namespace and to allow multiple registries. Next,
    we’ll update our policies to provide this flexibility.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了你的第一个Gatekeeper策略后，你可能很快会注意到它有一些问题。第一个问题是注册表是硬编码的。这意味着我们需要为每个注册表的变化复制代码。它对于命名空间来说也不够灵活。例如，Tremolo
    Security的镜像分布在多个`github.io`注册表中，所以我们可能不希望限制特定的注册表服务器，而是希望对每个命名空间提供灵活性并允许多个注册表。接下来，我们将更新我们的策略来提供这种灵活性。
- en: Building dynamic policies
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建动态策略
- en: Our current registry policy is limiting. It is static and only supports a single
    registry. Both Rego and Gatekeeper provide functionality to build a dynamic policy
    that can be reused in our cluster and configured based on individual namespace
    requirements. This gives us one code base to work from and debug instead of having
    to maintain repetitive code. The code we’re going to use is at [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/parameter-opa-policy](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/parameter-opa-policy).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的注册表策略是有限制的。它是静态的，只支持一个注册表。Rego和Gatekeeper都提供了构建动态策略的功能，这些策略可以在我们的集群中重复使用，并根据各个命名空间的要求进行配置。这使得我们只需要一个代码库来开发和调试，而不必维护重复的代码。我们将使用的代码在[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/parameter-opa-policy](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter11/parameter-opa-policy)。
- en: 'When inspecting `rego/limitregistries.rego`, the main difference between the
    code in `parameter-opa-policy` and `simple-opa-policy` comes down to the `invalidRegistry`
    rule:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查`rego/limitregistries.rego`时，`parameter-opa-policy`和`simple-opa-policy`之间的主要区别在于`invalidRegistry`规则：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The goal of the first line of the rule is to determine which images come from
    approved registries using a comprehension. Comprehensions provide a way to build
    out sets, arrays, and objects based on some logic. In this case, we want to only
    add images to the `ok_images` array that start with any of the allowed registries
    from `input.parameters.registries`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 规则第一行的目标是使用推理来确定哪些镜像来自经过批准的注册表。推理提供了一种基于某些逻辑构建集合、数组和对象的方式。在这种情况下，我们只想将来自`input.parameters.registries`中任何允许的注册表的镜像添加到`ok_images`数组中。
- en: To read a comprehension, start with the type of brace. Ours starts with a square
    bracket, so the result will be an array. Objects and sets can also be generated.
    The word between the open bracket and the pipe character (`|`) is called the head
    and this is the variable that will be added to our array if the right conditions
    are met. Everything to the right of the pipe character (`|`) is a set of rules
    used to determine what `image` should be and if it should have a value at all.
    If any of the statements in the rule resolve to `undefined` or `false`, the execution
    exits for that iteration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解一条 comprehension，从括号的类型开始。我们的从方括号开始，所以结果将是一个数组。对象和集合也可以被生成。开括号和管道符号（`|`）之间的单词叫做头部，这是如果满足条件，该变量将被添加到我们的数组中的变量。管道符号（`|`）右侧的内容是一组规则，用于确定
    `image` 应该是什么，并且是否应该有一个值。如果规则中的任何语句解析为 `undefined` 或 `false`，则该迭代将退出。
- en: The first rule of our comprehension is where most of the work is done. The `startswith`
    function is used to determine whether each of our images starts with the correct
    registry name. Instead of passing two strings to the function, we instead pass
    arrays. The first array has a variable we haven’t declared yet, `i`, and the other
    uses an underscore (`_`) where the index would usually be. The `i` is interpreted
    by Rego as “*Do this for each value in the array, incrementing by 1, and let it
    be referenced throughout the comprehension*.” The underscore is shorthand in Rego
    for “*Do this for all values*.” Since we specified two arrays, every combination
    of the two arrays will be used as input to the `startswith` function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解的第一个规则是大部分工作的所在。`startswith` 函数用于确定每个镜像是否以正确的注册表名称开头。我们没有将两个字符串传递给该函数，而是传递了数组。第一个数组包含一个我们尚未声明的变量
    `i`，另一个则使用下划线（`_`）代替通常会出现索引的位置。`i` 被 Rego 解释为“*对数组中的每个值执行此操作，递增 1，并让它在整个理解过程中被引用*。”
    下划线是 Rego 中的简写，表示“*对所有值执行此操作*。” 由于我们指定了两个数组，两个数组的每种组合都会作为输入传递给 `startswith` 函数。
- en: 'That means that if there are two containers and three potential pre-approved
    registries, then `startswith` will be called six times. When any of the combinations
    return `true` from `startswith`, the next rule is executed. That sets the `image`
    variable to `input_image` with index `i`, which then means that the image is added
    to `ok_images`. The same code in Java would look something like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果有两个容器和三个潜在的预批准注册表，那么 `startswith` 将被调用六次。当任何组合从 `startswith` 返回 `true`
    时，下一条规则将被执行。这样就将 `image` 变量设置为具有索引 `i` 的 `input_image`，这意味着该镜像会被添加到 `ok_images`。在
    Java 中，类似的代码大致如下：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One line of Rego eliminated seven lines of mostly boilerplate code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一行 Rego 代码消除了七行主要是模板代码的 Java 代码。
- en: The second line of the rule compares the number of entries in the `ok_images`
    array with the number of known container images. If they are equal, we know that
    every container contains a valid image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的第二行将 `ok_images` 数组中的条目数量与已知容器镜像的数量进行比较。如果它们相等，我们就知道每个容器都包含一个有效的镜像。
- en: 'With our updated Rego rules for supporting multiple registries, the next step
    is to deploy a new policy template (if you haven’t done so already, delete the
    old `k8sallowedregistries` `ConstraintTemplate` and `restrict-openunison-registries`
    `K8sAllowedRegistries`):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们更新了支持多个注册表的 Rego 规则，下一步是部署一个新的策略模板（如果你还没有这么做，请删除旧的 `k8sallowedregistries`
    `ConstraintTemplate` 和 `restrict-openunison-registries` `K8sAllowedRegistries`）：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s our updated `ConstraintTemplate`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们更新后的 `ConstraintTemplate`：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Beyond including our new rules, the highlighted section shows that we added
    a schema to our template. This will allow for the template to be reused with specific
    parameters. This schema goes into the `CustomResourceDefinition` that will be
    created and is used to validate input for the `K8sAllowedRegistries` objects we’ll
    create in order to enforce our pre-authorized registry lists. Create this new
    policy definition:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含我们的新规则外，突出显示的部分显示我们在模板中添加了一个 schema。这样可以使模板在具有特定参数的情况下重复使用。这个 schema 将进入将要创建的
    `CustomResourceDefinition` 中，并用于验证我们将创建的 `K8sAllowedRegistries` 对象的输入，以便执行我们的预授权注册表列表。创建这个新的策略定义：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, let’s create our policy for the `testpolicy` namespace. Since the
    only containers that are running in this namespace should come from NGINX’s `docker.io`
    registry, we’ll limit all pods to `docker.io/nginx/` using the following policy:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为 `testpolicy` 命名空间创建我们的策略。由于这个命名空间中运行的唯一容器应该来自 NGINX 的 `docker.io` 注册表，我们将使用以下策略将所有
    pod 限制为 `docker.io/nginx/`：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unlike our previous version, this policy specifies which registries are valid
    instead of embedding the policy data directly into our Rego. With our policies
    in place, let’s try to run the `BusyBox` container in the `testpolicy` namespace
    to get a shell:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的版本不同，这个策略指定了哪些注册表是有效的，而不是直接将策略数据嵌入到我们的 Rego 中。在我们的策略到位后，接下来让我们尝试在 `testpolicy`
    命名空间中运行 `BusyBox` 容器以获取一个 shell：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the above example, we were able to stop the BusyBox container from being
    deployed, but the NGINX `Deployment` was created because we were able to restrict
    the specific container registry on `docker.io`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们成功地阻止了 BusyBox 容器的部署，但 NGINX `Deployment` 仍然被创建，因为我们能够限制在 `docker.io`
    上的特定容器注册表。
- en: Using this generic policy template, we can restrict which registries the namespaces
    are able to pull from. As an example, in a multi-tenant environment, you may want
    to restrict all pods to the owner’s own registry. If a namespace is being used
    for a commercial product, you can stipulate that only that vendor’s containers
    can run in it. Before moving on to other use cases, it’s important to understand
    how to debug your code and handle Rego’s quirks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个通用的策略模板，我们可以限制命名空间能够拉取的注册表。例如，在多租户环境中，你可能希望限制所有的 pod 只从所有者自己的注册表中拉取。如果一个命名空间被用于商业产品，你可以规定只有该供应商的容器可以在其中运行。在进入其他使用场景之前，理解如何调试代码并处理
    Rego 的特性非常重要。
- en: Debugging Rego
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 Rego
- en: Debugging Rego can be challenging. Unlike more generic programming languages
    such as Java or Go, there’s no way to step through code in a debugger. Take the
    example of the generic policy we just wrote for checking registries. All the work
    was done in a single line of code. Stepping through it wouldn’t do much good.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Rego 可能具有挑战性。与 Java 或 Go 等通用编程语言不同，Rego 没有办法通过调试器逐步调试代码。以我们刚刚编写的检查注册表的通用策略为例，所有的工作都在一行代码中完成。逐步调试并不会有什么帮助。
- en: To make Rego easier to debug, the OPA project provides a trace of all failed
    tests when verbose output is set on the command line. This is another great reason
    to use OPA’s built-in testing tools.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Rego 更易于调试，OPA 项目提供了在命令行设置详细输出时，所有失败测试的追踪记录。这是使用 OPA 内建测试工具的另一个好理由。
- en: 'To make better use of this trace, Rego has a function called `trace` that accepts
    a string. Combining this function with `sprintf` lets you more easily track where
    your code is not working as expected. In the `chapter11/parameter-opa-policy-fail/rego`
    directory, there’s a test that will fail. There is also an `invalidRegistry` rule
    with multiple trace options added:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地利用这个追踪功能，Rego 提供了一个名为 `trace` 的函数，该函数接受一个字符串。将这个函数与 `sprintf` 结合使用，可以更轻松地跟踪代码中未按预期工作的地方。在
    `chapter11/parameter-opa-policy-fail/rego` 目录中，有一个会失败的测试。还添加了一个包含多个追踪选项的 `invalidRegistry`
    规则：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the test is run, OPA will output a detailed trace of every comparison and
    code path. Wherever it encounters the `trace` function, a “note” is added to the
    trace. This is the equivalent of adding `print` statements in your code to debug.
    The output of the OPA trace is very verbose, and far too much text to include
    in print. Running `opa test . -v` in this directory will give you the full trace
    you can use to debug your code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，OPA 会输出每个比较和代码路径的详细追踪记录。每当它遇到 `trace` 函数时，就会在追踪记录中添加一个“注释”。这相当于在代码中添加
    `print` 语句以进行调试。OPA 的追踪输出非常详细，包含的文本太多，无法在打印中全部列出。运行 `opa test . -v` 命令将在此目录中提供完整的追踪记录，你可以使用这些记录来调试代码。
- en: Using existing policies
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有策略
- en: Before moving into more advanced use cases for OPA and Gatekeeper, it’s important
    to understand the implications of how OPA is built and used. If you inspect the
    code we worked through in the previous section, you might notice that we aren’t
    checking for an `initContainer`. We’re only looking for the primary containers.
    An `initContainer` is a special container that is run before the containers listed
    in a pod are expected to end. They’re often used to prepare the filesystem of
    a volume mount and for other “initial” tasks that should be performed before the
    containers of a pod have run. If a bad actor tried to launch a pod with an `initContainer`
    that pulls in a Bitcoin miner (or worse), our policy wouldn’t stop it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 OPA 和 Gatekeeper 的高级使用场景之前，理解 OPA 的构建和使用方式非常重要。如果你检查我们在上一节中处理的代码，你可能会注意到我们没有检查
    `initContainer`。我们只关注主容器。`initContainer` 是在 pod 中列出的容器预期结束之前运行的特殊容器。它们通常用于准备挂载的文件系统或执行其他应该在
    pod 中的容器运行之前完成的“初始化”任务。如果有恶意用户试图启动一个带有拉取比特币挖矿工具（或更糟）的 `initContainer` 的 pod，我们的策略将无法阻止它。
- en: It’s important to be very detailed in the design and implementation of policies.
    One of the ways to make sure you’re not missing something when building policies
    is to use policies that already exist and have been tested. The Gatekeeper project
    maintains several libraries of pre-tested policies and how to use them in its
    GitHub repo at [https://github.com/open-policy-agent/gatekeeper-library](https://github.com/open-policy-agent/gatekeeper-library).
    Before attempting to build one of your own policies, see whether one already exists
    there first.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和实施策略时，重要的是要非常详细。确保在构建策略时没有遗漏某些东西的一种方法是使用那些已经存在并经过测试的策略。Gatekeeper项目在其GitHub仓库中维护了几种已测试的策略及其使用方法，地址为[https://github.com/open-policy-agent/gatekeeper-library](https://github.com/open-policy-agent/gatekeeper-library)。在尝试自己构建策略之前，先看看那里是否已经有现成的策略。
- en: This section provided an overview of Rego and how it works in policy evaluation.
    It didn’t cover everything, but should give you a good point of reference for
    working with Rego’s documentation. Next, we’ll learn how to build policies that
    rely on data from outside our request, such as other objects in our cluster.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了Rego及其在策略评估中的工作原理。虽然没有涵盖所有内容，但应该能为你使用Rego的文档提供一个很好的参考点。接下来，我们将学习如何构建依赖于请求之外数据的策略，例如集群中的其他对象。
- en: Enforcing Ingress policies
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制执行Ingress策略
- en: So far in this chapter, we’ve built policies that are self-contained. When checking
    whether an image is coming from a pre-authorized registry, the only data we needed
    was from the policy and the containers. This is often not enough information to
    make a policy decision. In this section, we’ll work on building a policy that
    relies on other objects in your cluster to make policy decisions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了自包含的策略。当检查镜像是否来自预授权的注册表时，我们所需的唯一数据来自策略和容器。但这通常不足以做出策略决策。在本节中，我们将构建一个依赖于集群中其他对象的策略，以便做出策略决策。
- en: 'Before diving into the implementation, let’s talk about the use case. It’s
    common to limit which namespaces can have `Ingress` objects. If a namespace hosts
    a workload that doesn’t require any inbound access, why allow an `Ingress` object
    at all? You may think you can enforce this using RBAC by limiting what tenants
    are allowed to deploy using a `Role` and `RoleBinding`, but this has some limitations:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，让我们先讨论一下使用案例。限制哪些命名空间可以拥有`Ingress`对象是很常见的做法。如果一个命名空间托管的工作负载不需要任何入站访问，为什么还要允许存在`Ingress`对象呢？你可能认为可以通过限制租户能够使用`Role`和`RoleBinding`来强制执行这一点，但这种方式有一些局限性：
- en: The `admin` and edit `ClusterRoles` are default aggregate `ClusterRoles`, so
    you would need to create a new `ClusterRole` that enumerates all objects except
    `Ingress` that you want your namespace admin to be able to create.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin`和编辑`ClusterRoles`是默认的聚合型`ClusterRoles`，因此你需要创建一个新的`ClusterRole`，列举出除了`Ingress`之外你希望命名空间管理员能够创建的所有对象。'
- en: If your new `ClusterRole` included `RoleBindings`, your namespace owner could
    just grant themselves `Ingress` creation.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的新`ClusterRole`包含了`RoleBindings`，命名空间的拥有者可以轻松授予自己创建`Ingress`的权限。
- en: Using an admission controller with an annotation or a label is a good approach
    to enforcing if the namespace can have an `Ingress` in it. The `Namespace` object
    is cluster-scoped, so an `admin` won’t be able to elevate their privileges in
    the namespace and add the label.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有注释或标签的准入控制器是一种强制执行命名空间是否可以拥有`Ingress`的好方法。`Namespace`对象是集群范围的，因此`admin`无法提升其在命名空间中的权限并添加标签。
- en: 'In our next example, we’ll write a policy that only allows `Ingress` objects
    in namespaces that have the correct label. The pseudo-code would look something
    like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将编写一个只允许在具有正确标签的命名空间中使用`Ingress`对象的策略。伪代码大致如下：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The hard part here is understanding if the namespace has a label. Kubernetes
    has an API, which you could query, but that would mean either embedding a secret
    into the policy so it can talk to the API server or allowing anonymous access.
    Neither of those options is a good idea. Another issue with querying the API server
    is that it’s difficult to automate testing since you are now reliant on an API
    server being available wherever you run your tests.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的难点是理解命名空间是否有标签。Kubernetes有一个API，你可以查询它，但这意味着要么将一个密钥嵌入策略中，以便它可以与API服务器通信，要么允许匿名访问。这两种选项都不是好主意。查询API服务器的另一个问题是，自动化测试变得困难，因为你现在依赖于API服务器在运行测试时的可用性。
- en: We discussed earlier that OPA can replicate data from the API server in its
    own database. Gatekeeper uses this functionality to create a **cache** of objects
    that can be tested against. Once this cache is populated, we can replicate it
    locally to provide test data for our policy testing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，OPA 可以将 API 服务器中的数据复制到它自己的数据库中。Gatekeeper 使用这个功能创建一个可以进行测试的**缓存**对象。一旦这个缓存被填充，我们可以将其复制到本地，为我们的策略测试提供数据。
- en: Enabling the Gatekeeper cache
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 Gatekeeper 缓存
- en: 'The Gatekeeper cache is enabled by creating a `Config` object in the `gatekeeper-system`
    namespace. Add this configuration to your cluster:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Gatekeeper 缓存通过在 `gatekeeper-system` 命名空间中创建 `Config` 对象来启用。将此配置添加到你的集群中：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will begin replicating `Namespace` objects in Gatekeeper’s internal OPA
    database. Let’s create a `Namespace` with a label allowing `Ingress` objects and
    without a label allowing `Ingress` objects:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始在 Gatekeeper 的内部 OPA 数据库中复制 `Namespace` 对象。让我们创建一个带有允许 `Ingress` 对象的标签和没有允许
    `Ingress` 对象的标签的 `Namespace`：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After a moment, the data should be in the OPA database and ready to query.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻，数据应该会被存储到 OPA 数据库中，并准备好查询。
- en: The Gatekeeper service account has read access to everything in your cluster
    with its default installation. This includes secret objects. Be careful what you
    replicate in Gatekeeper’s cache as there are no security controls from inside
    a Rego policy. Your policy could very easily log secret object data if you are
    not careful. Also, make sure to control who has access to the `gatekeeper-system`
    namespace. Anyone who gets hold of the service account’s token can use it to read
    any data in your cluster.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Gatekeeper 服务帐户在默认安装下对集群中的所有内容都有读取权限。这包括秘密对象。请小心你在 Gatekeeper 缓存中复制的数据，因为 Rego
    策略内部没有安全控制。如果不小心，策略可能会轻易地记录下秘密对象数据。同时，确保控制谁有权限访问 `gatekeeper-system` 命名空间。任何获取服务帐户令牌的人都可以用它来读取集群中的任何数据。
- en: Now that we have Gatekeeper set up and ready to start enforcing policies, how
    do we test policies? We could test them directly against a cluster, but that will
    slow down our development cycle. Next, we’ll see how to mock test data so that
    we can automate our testing outside of a Kubernetes cluster.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好 Gatekeeper 并准备开始执行策略，那么我们如何测试这些策略呢？我们可以直接在集群中测试它们，但那会减慢我们的开发周期。接下来，我们将看到如何模拟测试数据，以便我们可以在
    Kubernetes 集群外自动化测试。
- en: Mocking up test data
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟测试数据
- en: 'In order to automate the testing of our policy, we need to create test data.
    In the previous examples, we used data injected into the `input` variable. Cache
    data is stored in the `data` variable. Specifically, in order to access our namespace
    labels, we need to access `data.inventory.cluster["v1"].Namespace["ns-with-ingress"].metadata.labels`.
    This is the standard way for you to query cluster data from Rego in Gatekeeper.
    If you want to query objects inside of a namespace, it would instead look like
    `data.inventory.namespace["myns"]["v1"]["ConfigMaps"]["myconfigmap"]`. Just as
    we did with the input, we can inject a mocked-up version of this data by creating
    a data object. Here’s what our JSON will look like:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化测试我们的策略，我们需要创建测试数据。在之前的示例中，我们使用了注入到 `input` 变量中的数据。缓存数据存储在 `data` 变量中。具体来说，为了访问我们的命名空间标签，我们需要访问
    `data.inventory.cluster["v1"].Namespace["ns-with-ingress"].metadata.labels`。这是你从
    Gatekeeper 中使用 Rego 查询集群数据的标准方法。如果你想查询命名空间内部的对象，它看起来应该像 `data.inventory.namespace["myns"]["v1"]["ConfigMaps"]["myconfigmap"]`。就像我们处理输入一样，我们可以通过创建数据对象来注入一个模拟版本的数据。下面是我们
    JSON 数据的样子：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you look at `chapter11/enforce-ingress/rego/enforceingress_test.rego`,
    you’ll see the tests have `with input as {…} with data as {…}` with the preceding
    document as our control data. This lets us test our policies with data that would
    exist in GateKeeper without having to deploy our code in a cluster.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 `chapter11/enforce-ingress/rego/enforceingress_test.rego` 文件时，你会看到测试中使用了
    `with input as {…} with data as {…}`，前面的文档作为我们的控制数据。这让我们能够使用 GateKeeper 中存在的数据来测试策略，而无需在集群中部署我们的代码。
- en: Building and deploying our policy
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建并部署我们的策略
- en: 'Just as before, we’ve written test cases prior to writing our policy. Next,
    we’ll examine our policy:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们在编写策略之前已经编写了测试用例。接下来，我们将检查我们的策略：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code should look familiar. It follows a similar pattern as our earlier
    policies. The first rule, `violation`, is the standard reporting rule for Gatekeeper.
    The second and third rules have the same name but different logic. This is because
    Rego evaluates all of the statements in a rule as an AND, so for the rule to be
    true, all of the statements need to be true. If we only had the first `missingIngressLabel`
    rule, which checks if the `allowingress` label is true, then `Ingress` objects
    without this label at all would break the rule and so bypass our requirement.
    We could have a rule that requires that the label be set, but that would lead
    to a bad user experience. It would be better to set up our policy so that it will
    fail if the label isn’t true OR the label isn’t set at all.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来很熟悉。它遵循了与我们之前策略类似的模式。第一个规则`violation`是Gatekeeper的标准报告规则。第二个和第三个规则具有相同的名称，但逻辑不同。这是因为Rego会将规则中的所有语句视为AND操作，因此为了规则成立，所有语句必须为真。如果我们只有第一个`missingIngressLabel`规则，用来检查`allowingress`标签是否为真，那么没有此标签的`Ingress`对象将违反规则，从而绕过我们的要求。我们可以有一个要求标签必须设置的规则，但那会导致糟糕的用户体验。更好的做法是设置我们的策略，使其在标签不为真或标签根本未设置时失败。
- en: To set up the logic of “if the label’s value is not true or the label is not
    present,” we need to have two rules with the same name. One rule checks for the
    label’s value, and the other validates if the label is there at all. Rego will
    execute both `missingIngressLabel` rules and, as long as one passes, execution
    will continue. In our case, if the namespace the `Ingress` object is created in
    doesn’t have the correct value of `allowingress`, or doesn’t have the label `allowingress`
    at all, the violation rule will complete, returning an error to the user.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置“如果标签值不为真或标签不存在”的逻辑，我们需要有两个具有相同名称的规则。一个规则检查标签的值，另一个则验证标签是否存在。Rego将执行两个`missingIngressLabel`规则，只要其中一个通过，执行就会继续。在我们的例子中，如果`Ingress`对象所在的命名空间没有正确的`allowingress`值，或者根本没有`allowingress`标签，那么违规规则将完成，并返回错误给用户。
- en: This is a key difference between Rego and other languages. Rego isn’t executed
    in sequence the way Java, Go, or JavaScript is. It’s a policy language that’s
    evaluated, so the execution path is different. When writing Rego, it’s important
    to remember you’re not working with a typical programming language.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Rego与其他语言之间的一个关键区别。Rego不像Java、Go或JavaScript那样按顺序执行。它是一种评估的策略语言，因此执行路径不同。在编写Rego时，重要的是要记住，你并不是在使用典型的编程语言。
- en: To deploy, add `chapter11/enforce-ingress/yaml/gatekeeper-policy-template.yaml`
    and `chapter11/enforce-ingress/yaml/gatekeeper-policy.yaml` to your cluster.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署，请将`chapter11/enforce-ingress/yaml/gatekeeper-policy-template.yaml`和`chapter11/enforce-ingress/yaml/gatekeeper-policy.yaml`添加到你的集群中。
- en: 'To test, we’ll try creating an `Ingress` object in the `ns-without-ingress`
    namespace:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们将在`ns-without-ingress`命名空间中尝试创建一个`Ingress`对象：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can see that our policy blocked the `Ingress` object’s creation. Next,
    we’ll try to create the same `Ingress` object but in the `ns-with-ingress` namespace,
    which has the correct label:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的策略阻止了`Ingress`对象的创建。接下来，我们将在具有正确标签的`ns-with-ingress`命名空间中尝试创建相同的`Ingress`对象：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This time, our policy allowed the `Ingress` object to be created!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们的策略允许创建`Ingress`对象！
- en: Most of this chapter has been spent writing policies. Next, we’ll cover how
    to provide sane defaults to your objects using mutating webhooks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分内容都花在了编写策略上。接下来，我们将介绍如何通过变更Webhook为你的对象提供合理的默认值。
- en: Mutating objects and default values
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更对象和默认值
- en: Until this point, everything we have discussed has been about how to use Gatekeeper
    to enforce a policy. Kubernetes has another feature called mutating admission
    webhooks that allows a webhook to change, or mutate, an object before the API
    server processes it and runs validating admission controllers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 直到目前为止，我们讨论的所有内容都是如何使用Gatekeeper来强制执行策略。Kubernetes还有一个叫做变更准入Webhook的功能，允许在API服务器处理对象并运行验证准入控制器之前，通过Webhook来修改或变更对象。
- en: A common usage of a mutating webhook is to explicitly set security context information
    on pods that don’t have it set. For instance, if you create a pod with no `spec.securityContext.runAsUser`,
    then the pod will run as the user the Docker container was built to run using
    the `USER` directive (or root by default) when it was built. This is insecure
    since it means you could be running as root, especially if the container in question
    is from Docker Hub. While you can have a policy that blocks running as root, you
    could also have a mutating webhook that will set a default user ID if it’s not
    specified to make it a default. This makes for a better developer experience because,
    now, as a developer, I don’t have to worry about which user my container was built
    to run as so long as it was designed to work with any user.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 变更webhook的常见用法之一是显式设置没有设置安全上下文信息的pod。例如，如果你创建一个没有`spec.securityContext.runAsUser`的pod，那么该pod将以Docker容器构建时使用的`USER`指令（或者默认的root）作为用户身份运行。这是不安全的，因为这意味着你可能是以root用户身份运行，特别是当容器来自Docker
    Hub时。虽然你可以有一个策略来阻止以root身份运行，你也可以有一个变更webhook，如果没有指定用户，则会设置一个默认的用户ID。这为开发者提供了更好的体验，因为现在，作为开发者，我不必担心我的容器是以哪个用户身份构建的，只要它设计成可以与任何用户一起工作。
- en: This brings up a common question of defaults versus explicit configuration.
    There are two schools of thought. The first is that you should provide sane defaults
    wherever possible to minimize what developers have to know to get a typical workload
    running. This creates consistency and makes it easier to spot outliers. The other
    school of thought requires explicit configuration of security contexts so that
    it’s known looking at a glance what the workload expects. This can make auditing
    easier, especially if paired with GitOps to manage your manifests, but creates
    quite a bit of repetitive YAML.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个常见的问题：默认值与显式配置。存在两种不同的思路。第一种认为，在可能的情况下，应该提供合理的默认值，以减少开发者为使典型工作负载运行所需要知道的内容。这可以创造一致性，并使得识别异常更容易。另一种思路要求显式配置安全上下文，以便一眼就能看出工作负载的期望。这可以简化审计，特别是如果配合GitOps来管理清单，但会产生相当多的重复YAML。
- en: I’m personally a fan of sane defaults. The vast majority of workloads will not
    require any privilege and should be treated as such. It doesn’t mean you don’t
    still need enforcement, just that it’s a better experience for your developers.
    It also makes it easier to make global changes. Want to change the default user
    ID or security context? You make the change in your mutating webhook instead of
    across tens, hundreds, or even thousands of manifests. Most of Kubernetes is built
    this way. You don’t create pod objects directly; you create `Deployments` and
    `StatefulSets` with controllers that create pods. Going back to our discussions
    on RBAC, aggregate roles work this way too. Instead of creating a massive `ClusterRole`
    for namespace administrators, Kubernetes uses a controller to generate the `ClusterRole`
    dynamically based on label selectors, making it easier to maintain. In my experience,
    this example should be applied to security defaults as well.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人是理性默认值的支持者。绝大多数工作负载不需要任何特权，应该将其视为如此。这并不意味着你不需要执行策略，而是提供更好的开发者体验。它还使得进行全局更改变得更加容易。想要更改默认的用户ID或安全上下文？你只需要在变更webhook中进行更改，而不是在成千上万的清单中进行修改。Kubernetes的大多数部分就是这么构建的。你不直接创建pod对象；你创建`Deployments`和`StatefulSets`，然后通过控制器创建pod。回到我们关于RBAC的讨论，聚合角色也是这样工作的。Kubernetes并不是为命名空间管理员创建一个巨大的`ClusterRole`，而是通过控制器动态生成`ClusterRole`，基于标签选择器，这样更容易维护。根据我的经验，这个示例也应该应用于安全默认设置。
- en: Gatekeeper’s mutation isn’t built on Rego the way its validation policies are.
    While you can write mutating webhooks in Rego, and I can say this from experience,
    it’s not well suited to it. What makes Rego a great policy definition language
    also makes it very hard to build mutations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Gatekeeper的变更功能不像它的验证策略那样基于Rego构建。虽然你可以用Rego编写变更webhook，我可以从经验中告诉你，它并不适合这种用途。Rego作为一个优秀的策略定义语言，使得它在构建变更时非常困难。
- en: Now that we know what mutations are useful and that we can use Gatekeeper, let’s
    build a mutation that will configure all containers to run as a default user if
    none is specified.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了哪些变更是有用的，并且可以使用Gatekeeper，让我们构建一个变更，它将在没有指定用户时将所有容器配置为以默认用户身份运行。
- en: 'First, let’s deploy something that we can test our mutations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们部署一些可以测试变更的内容：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can deploy the policy in `chapter11/defaultUser/addDefaultUser.yaml`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`chapter11/defaultUser/addDefaultUser.yaml`中部署该策略：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let’s walk through this mutation. The first part of the `spec`, `applyTo`, tells
    Gatekeeper what objects you want this mutation to act on. For us, we want it to
    work on all pods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地走过这个变更过程。`spec`的第一部分，`applyTo`，告诉 Gatekeeper 你希望变更应用到哪些对象。对于我们来说，我们希望它作用于所有
    pod。
- en: The next section, `match`, gives you the chance to specify conditions on which
    pods we want the mutation to apply to. In our case, we’re applying to all of them
    except in the `kube-system` namespace. In general, I tend to avoid making changes
    to anything in the `kube-system` namespace because it’s the domain of whoever
    is managing your clusters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分，`match`，让你有机会指定我们希望变更应用到哪些 pod。在我们的例子中，我们应用于所有 pod，除了 `kube-system` 命名空间。一般来说，我倾向于避免更改
    `kube-system` 命名空间中的任何内容，因为这是管理集群的人负责的领域。
- en: 'Making changes there can have permanent impacts on your cluster. In addition
    to specifying which namespaces you don’t want to apply your mutation to, you can
    also specify additional conditions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里做更改可能会对集群产生永久性影响。除了指定你不希望应用变更的命名空间外，你还可以指定额外的条件：
- en: '`kind` – What kind of object to match on'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind` – 要匹配的对象类型'
- en: '`labelSelectors` – Labels on the object that must match'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labelSelectors` – 对象上的标签，必须匹配'
- en: '`namespaces` – List of namespaces to apply the mutation policy to'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespaces` – 要应用变更策略的命名空间列表'
- en: '`namespaceSelector` – Labels on the container namespaces'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespaceSelector` – 容器命名空间上的标签'
- en: We’ll talk more about label matching in *Chapter 12*, *Node Security with GateKeeper*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第 12 章*，*使用 GateKeeper 进行节点安全*中详细讨论标签匹配。
- en: After defining how to match objects to mutate, we specify what mutation to perform.
    For us, we want to set `spec.securityContext.runAsUser` to a randomly chosen user
    ID if one isn’t specified. The last part, `pathTests`, is what lets us set this
    value if the `spec.securityContext.runAsUser` isn’t already set.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义如何匹配要变更的对象后，我们指定要执行的变更。对于我们来说，如果没有指定用户 ID，我们希望将 `spec.securityContext.runAsUser`
    设置为随机选择的用户 ID。最后一部分，`pathTests`，允许我们在 `spec.securityContext.runAsUser` 尚未设置时设置该值。
- en: 'Once you’ve applied your mutation policy, verify that the test pod isn’t running
    as a specific user:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了变更策略，验证测试 pod 是否没有以特定用户身份运行：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, delete the pod and check again:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，删除 pod 并重新检查：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our pod is now running as user `70391`! Now, let’s edit our `deployment` so
    that the user is set the user identity:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 pod 现在以用户 `70391` 运行！现在，让我们编辑 `deployment` 以便设置用户身份：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our mutation didn’t apply because we already had a user specified in our `Deployment`
    object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变更没有生效，因为我们在 `Deployment` 对象中已经指定了一个用户。
- en: 'One last note on setting values: you’ll often find that you want to set a value
    for an object in a list. For instance, you may want to create a policy that will
    set any container as unprivileged unless specifically set to be privileged. In
    `chapter11/defaultUser/yaml/setUnprivileged.yaml`, our `location` (and `subPath`)
    have changed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置值的最后一点：你会发现你经常需要为列表中的对象设置一个值。例如，你可能想要创建一个策略，使任何容器默认为非特权（unprivileged），除非明确设置为特权（privileged）。在
    `chapter11/defaultUser/yaml/setUnprivileged.yaml` 中，我们的 `location`（以及 `subPath`）已发生变化：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This reads as “Match all objects in the list `spec.containers` that have an
    attribute called `image`.” Since every container must have an image, this will
    match all containers. Apply this object and test it out again on the test pod:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段话的意思是：“匹配 `spec.containers` 列表中所有具有 `image` 属性的对象。”由于每个容器都必须有镜像，这将匹配所有容器。应用这个对象后，再次在测试
    pod 上测试：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now our pod is marked as unprivileged!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 pod 被标记为非特权（unprivileged）！
- en: In this section, we looked at how you can set defaults using Gatekeeper’s built-in
    mutation support. We discussed the benefits of mutating webhooks that set defaults,
    enabled Gatekeeper’s support for mutations, and built policies that set a default
    user identity and disable privileged containers. Using what you’ve learned in
    this section, you can use Gatekeeper not only to enforce your policies but also
    to set sane defaults to make compliance easier for your developers. Using GateKeeper
    for policy management is great, but it does require additional skills and the
    management of an additional system. Next, we’ll learn how to create policies with
    alternatives to Rego or using Kubernetes’ new built-in policy engine.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何使用Gatekeeper的内置变更支持设置默认值。我们讨论了变更webhook设置默认值的好处，启用了Gatekeeper对变更的支持，并创建了设置默认用户身份和禁用特权容器的策略。通过本节所学，您可以使用GateKeeper不仅执行策略，还可以设置合理的默认值，帮助开发人员更容易地遵循合规要求。使用GateKeeper进行策略管理很不错，但它确实需要额外的技能和管理额外的系统。接下来，我们将学习如何创建不依赖Rego或使用Kubernetes新内置策略引擎的替代方案。
- en: Creating policies without Rego
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建没有Rego的策略
- en: Rego is a very powerful way to build complex policies that are then implemented
    by the GateKeeper project. That power comes with a steep learning curve and complexity.
    It may not be the right choice for you or your clusters. It isn’t the only way
    to implement an admission controller. We’re not going to go into too many details,
    as these other projects all have their own capabilities that are worth exploring
    and I won’t be able to do them justice in one section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Rego是一种非常强大的方式，用于构建复杂的策略，随后由GateKeeper项目实现。虽然它强大，但也伴随着陡峭的学习曲线和复杂性。它可能不适合您或您的集群。它并不是实现准入控制器的唯一方式。我们不会深入讨论太多细节，因为这些其他项目各自都有值得探索的能力，我无法在一个部分中详细介绍它们。
- en: 'The two most common alternatives to GateKeeper are:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: GateKeeper的两个最常见替代方案是：
- en: '**Kyverno**: Kverno is a specialized policy engine for Kubernetes. It’s not
    designed as a generic authorization engine the way OPA is so it can make assumptions
    that provide a simpler experience for building Kubernetes policies ([https://kyverno.io/](https://kyverno.io/)).'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kyverno**：Kyverno是Kubernetes的一个专用策略引擎。它不像OPA那样设计为通用授权引擎，因此可以做出一些假设，从而提供更简化的Kubernetes策略构建体验（[https://kyverno.io/](https://kyverno.io/)）。'
- en: '**jsPolicy**: The jsPolicy project allows you to build your policies in JavaScript
    or TypeScript instead of a **domain-specific language** (**DSL**) like Rego. The
    idea is that many of the quirks that come from Rego being a policy language, not
    a programming language, are eliminated by using a common language like JavaScript
    ([https://github.com/loft-sh/jspolicy](https://github.com/loft-sh/jspolicy)).'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jsPolicy**：jsPolicy项目允许您使用JavaScript或TypeScript构建策略，而不是像Rego那样使用**领域特定语言**（**DSL**）。其理念是，许多由于Rego作为策略语言而非编程语言所带来的怪癖，通过使用像JavaScript这样的通用语言得以消除（[https://github.com/loft-sh/jspolicy](https://github.com/loft-sh/jspolicy)）。'
- en: These projects both have their own strengths and I encourage you to evaluate
    them for your use cases. If your policies are straightforward and don’t require
    the power of one of these engines, you can also look at Kubernetes’ new built-in
    capabilities, which is what we’ll cover next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个项目各有其优势，我鼓励您根据自己的使用场景评估它们。如果您的策略比较简单，不需要这些引擎的强大功能，您还可以考虑Kubernetes的新内置功能，这也是我们接下来要介绍的内容。
- en: Using Kubernetes’ validating admission policies
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kubernetes的验证入站策略
- en: In 1.28 Kubernetes, validating admission policies went into beta, which allows
    you to create simpler policies without an external admission controller. For simpler
    policies, this eliminates a component that needs to be deployed. We’re not going
    to dive too deeply into building admission policies, but we wanted to give you
    an overview so that you have it as an option.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.28中，验证入站策略进入了Beta阶段，这使得您可以在不需要外部准入控制器的情况下创建更简单的策略。对于简单的策略，这消除了一个需要部署的组件。我们不会深入探讨如何构建入站策略，但我们希望为您提供一个概览，让您知道这是一个选项。
- en: From a policy development perspective, the biggest difference between using
    Gatekeeper and validating admission policies is that while Gatekeeper uses Rego,
    validating admission policies use the **Common Expression Language** (**CEL**).
    CEL is not a Turing Complete language, which means that it isn’t as expressive
    and capable as JavaScript but is easier to secure. CEL is being integrated into
    multiple layers of Kubernetes. It’s being used to provide more expressive validation
    for custom resource definitions and is also being integrated into the new authentication
    configuration options that are being developed. You can learn more about CEL at
    [https://github.com/google/cel-spec](https://github.com/google/cel-spec).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从策略开发的角度来看，使用Gatekeeper和验证准入策略之间的最大区别在于，Gatekeeper使用Rego，而验证准入策略使用**通用表达式语言**（**CEL**）。CEL不是图灵完备的语言，这意味着它不像JavaScript那样具有表现力和能力，但它更容易安全。CEL正被集成到Kubernetes的多个层次中。它用于为自定义资源定义提供更具表现力的验证，也正在集成到正在开发的新身份验证配置选项中。你可以在[https://github.com/google/cel-spec](https://github.com/google/cel-spec)上了解更多关于CEL的信息。
- en: 'From a capability perspective, you can use CEL to validate any of the data
    inside of the object to be created. There are two components to build a validating
    admission policy:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，你可以使用CEL来验证要创建的对象中的任何数据。构建验证准入策略有两个组件：
- en: '`ValidatingAdmissionPolicy`: This is the object that describes the policy and
    the expressions to run as part of that policy. This is similar to `ConstraintTemplate`
    from Gatekeeper.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidatingAdmissionPolicy`：这是描述策略和在该策略中执行的表达式的对象。这类似于Gatekeeper中的`ConstraintTemplate`。'
- en: '`ValidatingAdmissionPolicyBinding`: This is how Kubernetes knows when to apply
    our `ValidatingAdmissionPolicy`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidatingAdmissionPolicyBinding`：这是Kubernetes了解何时应用我们的`ValidatingAdmissionPolicy`的方式。'
- en: 'To implement our example from above where we want to limit Ingress objects
    to namespaces with a specific label, first, we’d create the `ValidatingAdmissionPolicy`
    (`chapter11/enforce-ingress-vap/vap-ingress.yaml`):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们上面的示例，我们希望将Ingress对象限制在具有特定标签的命名空间中，首先，我们将创建`ValidatingAdmissionPolicy`（`chapter11/enforce-ingress-vap/vap-ingress.yaml`）：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The above policy will fail if the namespace that the `Ingress` is added to
    doesn’t have the label `allowingress` with a value of `true`. Next, we need to
    tell Kubernetes to bind our policy. We want this to apply to all namespaces, but
    similar to a policy implementation for Gatekeeper, we can specify specific namespaces
    or namespace labels. We do this using a `ValidatingAdmissionPolicy` (`chapter11/enforce-ingress-vap/vap-binding-ingress.yaml`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`Ingress`添加到的命名空间没有`allowingress`标签，且其值为`true`，上述策略将会失败。接下来，我们需要告诉Kubernetes绑定我们的策略。我们希望这适用于所有命名空间，但类似于Gatekeeper的策略实现，我们也可以指定特定的命名空间或命名空间标签。我们通过使用`ValidatingAdmissionPolicy`（`chapter11/enforce-ingress-vap/vap-binding-ingress.yaml`）来实现：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This binding will bind our policy to all namespaces, and on failure, deny the
    request. We could also warn the user or just audit the event. In our case, we
    want the request to fail. With these two objects created, we can try to create
    `Ingress` objects again:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绑定将把我们的策略绑定到所有命名空间，并且在失败时拒绝请求。我们也可以警告用户或仅仅审核事件。在我们的案例中，我们希望请求失败。创建了这两个对象后，我们可以再次尝试创建`Ingress`对象：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Just as with our Gatekeeper examples, we see that we’re able to deny the creation
    of an `Ingress` rule if our namespace doesn’t have the appropriate label.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的Gatekeeper示例一样，我们可以看到如果命名空间没有适当的标签，我们能够拒绝创建`Ingress`规则。
- en: The addition of validating access policies to Kubernetes adds a powerful tool,
    but it does have its limits. It’s tempting to say we’ll use validating access
    policies for simple use cases, and Gatekeeper for more complex ones, but there
    are other things to keep in mind beyond the implementation complexity. For one,
    how are you monitoring failures? If you use both solutions, then even though you
    may have some simpler rule implementations, you’ll need to audit both solutions,
    which will create more work.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将验证访问策略添加到Kubernetes为其增加了一个强大的工具，但它也有一定的限制。很容易说我们会将验证访问策略用于简单的用例，将Gatekeeper用于更复杂的用例，但除了实现复杂性之外，还有其他需要考虑的因素。首先，你如何监控失败？如果你同时使用这两种解决方案，即使你可能有一些更简单的规则实现，你仍然需要审核这两种解决方案，这将增加工作量。
- en: While we introduced validating access policies so you’re aware of their capability,
    we’re going to continue to focus on OPA and Gatekeeper in future chapters. In
    the next chapter, we’re going to apply what we’ve learned about OPA and Gatekeeper
    to help secure Kubernetes nodes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们引入了验证访问策略，以便让你了解它们的能力，但我们将继续在后续章节中聚焦于 OPA 和 Gatekeeper。在下一章中，我们将应用所学的 OPA
    和 Gatekeeper 知识来帮助确保 Kubernetes 节点的安全。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored how to use Gatekeeper as a dynamic admission controller
    to provide additional authorization policies on top of Kubernetes’ built-in RBAC
    capabilities. We looked at how Gatekeeper and OPA are architected. Then, we learned
    how to build, deploy, and test policies in Rego. Finally, you were shown how to
    use Gatekeeper’s built-in mutation support to create default configuration options
    in pods.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们探讨了如何使用 Gatekeeper 作为动态准入控制器，为 Kubernetes 内建的 RBAC 功能提供额外的授权策略。我们了解了 Gatekeeper
    和 OPA 的架构。然后，我们学习了如何在 Rego 中构建、部署和测试策略。最后，你将看到如何使用 Gatekeeper 内置的变异支持在 pod 中创建默认的配置选项。
- en: Extending Kubernetes’ policies leads to a stronger security profile in your
    clusters and provides greater confidence in the integrity of the workloads you
    are running.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes 的策略可以增强集群的安全性，并提供对正在运行的工作负载完整性的更大信心。
- en: Using Gatekeeper can also help catch previously missed policy violations through
    its application of continuous audits. Using these capabilities will provide a
    stronger foundation for your cluster.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gatekeeper 还可以通过其持续审计的应用，捕获之前遗漏的策略违规行为。利用这些功能将为你的集群提供更强大的基础。
- en: This chapter focused on whether or not to launch a pod based on our specific
    policies. In the next chapter, we’ll learn how to protect your nodes from the
    processes running in those pods.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关注的是是否根据我们的特定策略启动 pod。在下一章中，我们将学习如何保护节点免受运行在这些 pod 中的进程的影响。
- en: Questions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Are OPA and Gatekeeper the same thing?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OPA 和 Gatekeeper 是同一回事吗？
- en: 'Yes'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的
- en: 'No'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: How is Rego code stored in Gatekeeper?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rego 代码如何存储在 Gatekeeper 中？
- en: It is stored as `ConfigMap` objects that are watched.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它作为被监视的 `ConfigMap` 对象存储。
- en: Rego has to be mounted to the pod.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rego 必须挂载到 pod 上。
- en: Rego needs to be stored as secret objects.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rego 需要作为密钥对象存储。
- en: Rego is saved as a `ConstraintTemplate`.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rego 被保存为一个 `ConstraintTemplate`。
- en: How do you test Rego policies?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何测试 Rego 策略？
- en: In production
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中
- en: Using an automated framework built directly into OPA
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用直接内嵌于 OPA 的自动化框架
- en: By first compiling to WebAssembly
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先编译为 WebAssembly
- en: In Rego, how do you write a `for` loop?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Rego 中，如何编写 `for` 循环？
- en: You don’t need to; Rego will identify iterative steps.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不需要这样做；Rego 会识别迭代步骤。
- en: By using the `for all` syntax.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `for all` 语法。
- en: By initializing counters in a loop.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在循环中初始化计数器。
- en: There are no loops in Rego.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rego 中没有循环。
- en: What is the best way to debug Rego policies?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试 Rego 策略的最佳方法是什么？
- en: Use an IDE to attach to the Gatekeeper container in a cluster.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 IDE 连接到集群中的 Gatekeeper 容器。
- en: In production.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中。
- en: Add trace functions to your code and run the `opa test` command with `-v` to
    see execution traces.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向代码中添加 trace 函数，并使用 `-v` 参数运行 `opa test` 命令来查看执行追踪。
- en: Include `System.out` statements.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `System.out` 语句。
- en: Constraints all need to be hardcoded.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有约束都需要硬编码。
- en: 'True'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Gatekeeper can replace pod security policies.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gatekeeper 可以替代 pod 安全策略。
- en: 'True'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Answers
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b – No, Gatekeeper is a Kubernetes-native policy engine built on OPA.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b – 不，Gatekeeper 是一个基于 OPA 构建的 Kubernetes 原生策略引擎。
- en: d – Rego is saved as a `ConstraintTemplate`
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d – Rego 被保存为一个 `ConstraintTemplate`
- en: b – Please don’t test in production!
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b – 请不要在生产环境中进行测试！
- en: a – Everything is built on policy, not iterative control loops.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – 一切都建立在策略上，而非迭代控制循环。
- en: c – Add trace functions to your code and run the `opa test` command with `-v`
    to see execution traces
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c – 向代码中添加 trace 函数，并使用 `-v` 参数运行 `opa test` 命令来查看执行追踪
- en: b – False. You can have variable constraints.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b – 错误。你可以有变量约束。
- en: a – True, and we’ll cover that in the next chapter!
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – 正确，我们将在下一章中详细讲解！
- en: Join our book’s Discord space
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的 Discord 交流群
- en: 'Join the book’s Discord workspace for a monthly *Ask Me Anything* session with
    the authors:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 加入本书的 Discord 交流群，参加每月的 *问我任何问题* 环节，与作者互动：
- en: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/K8EntGuide](https://packt.link/K8EntGuide)'
- en: '![](img/QR_Code965214276169525265.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code965214276169525265.png)'
