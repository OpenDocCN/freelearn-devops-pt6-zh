- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Kubernetes
- en: '**Kubernetes** is an open source container orchestration engine that automates
    how container applications are deployed, scaled, and managed. Since it was first
    released 7 years ago, it has made great strides in a short period. It has previously
    had to compete with and outperform container orchestration engines such as Cloud
    Foundry Diego, CoreOS''s Fleet, Docker Swarm, Kontena, HashiCorp''s Nomad, Apache
    Mesos, Rancher''s Cattle, Amazon ECS, and more. Kubernetes is now operating in
    an entirely different landscape. This indicates that developers only need to master
    one container orchestration engine so that they can be employed for 90% of container-related
    jobs.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes**是一个开源容器编排引擎，自动化了容器应用程序的部署、扩展和管理。自7年前首次发布以来，它在短短的时间内取得了巨大的进展。它曾经需要与像Cloud
    Foundry Diego、CoreOS的Fleet、Docker Swarm、Kontena、HashiCorp的Nomad、Apache Mesos、Rancher的Cattle、Amazon
    ECS等容器编排引擎竞争并超越它们。如今，Kubernetes正在一个完全不同的环境中运行。这表明，开发人员只需要掌握一个容器编排引擎，就能够应对90%的容器相关工作。'
- en: The Kubernetes container orchestration framework is a ready-for-production open
    source platform built on Google's 15+ years of experience running production workloads,
    as well as community-contributed best-of-breed principles and concepts. Kubernetes
    divides an application's containers into logical units for easier administration
    and discovery. Containers (cgroups) have been around since early 2007 when they
    were first included in the mainline Linux kernel. A container's small size and
    portability allows it to host an exponentially higher number of containers than
    VMs, lowering infrastructure costs and allowing more programs to be deployed faster.
    However, until Docker (2013) came along, it didn't generate significant interest
    due to usability concerns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes容器编排框架是一个适用于生产的开源平台，建立在谷歌15年以上运行生产工作负载的经验基础上，同时结合了社区贡献的最佳实践和理念。Kubernetes将应用程序的容器划分为逻辑单元，以便更容易地进行管理和发现。容器（cgroups）自2007年初首次被包含在主线Linux内核中以来便存在。容器的小巧和可移植性使得它能够比虚拟机容纳更多的容器，降低了基础设施成本，并使得更多的程序能够更快地部署。然而，直到Docker（2013年）问世之前，由于可用性问题，它并未引起显著关注。
- en: 'Docker is different from standard virtualization; it is based on operating-system-level
    virtualization. Containers, unlike hypervisor virtualization, which uses an intermediation
    layer (hypervisor) to run virtual machines on physical hardware, run in user space
    on top of the kernel of an operating system. As a result, they''re incredibly
    light and fast. This can be seen in the following diagram:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Docker与标准虚拟化不同；它基于操作系统级虚拟化。容器不同于使用中介层（虚拟机监控器）在物理硬件上运行虚拟机的虚拟化，容器运行在操作系统内核之上的用户空间中。因此，容器非常轻量且快速。这可以从下图中看到：
- en: '![Figure 1.1 – Virtual machines versus containers ](img/Figure_1.1_B18115.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 虚拟机与容器](img/Figure_1.1_B18115.jpg)'
- en: Figure 1.1 – Virtual machines versus containers
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 虚拟机与容器
- en: 'The Kubernetes container orchestration framework automates much of the operational
    effort that''s necessary to run containerized workloads and services. This covers
    provisioning, deployment, scaling (up and down), networking, load balancing, and
    other tasks that software teams must perform to manage a container''s life cycle.
    Some of the key benefits that Kubernetes brings to developers are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes容器编排框架自动化了运行容器化工作负载和服务所需的大部分操作工作。这涵盖了资源配置、部署、扩展（上下）、网络、负载均衡以及软件团队必须执行的其他任务，以管理容器的生命周期。Kubernetes为开发人员带来的一些关键好处如下：
- en: '**Declarative Application Topology**: This describes how each service should
    be implemented, as well as their reliance on other services and resource requirements.
    Because we have all of this data in an executable format, we can test the application''s
    deployment parts early on in development and treat it like programmable application
    infrastructure:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式应用拓扑**：描述了每个服务的实现方式，以及它们对其他服务的依赖关系和资源需求。由于我们将这些数据以可执行格式呈现，我们可以在开发初期就测试应用的部署部分，并将其视为可编程的应用基础设施：'
- en: '![Figure 1.2 – Declarative application topology ](img/Figure_1.2_B18115.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 声明式应用拓扑](img/Figure_1.2_B18115.jpg)'
- en: Figure 1.2 – Declarative application topology
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 声明式应用拓扑
- en: '**Declarative Service Deployments**: The update and rollback process for a
    set of containers is encapsulated, making it a repetitive and automated procedure.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式服务部署**：一组容器的更新和回滚过程被封装，使其成为一个重复的自动化过程。'
- en: '**Dynamically Placed Applications**: This allows applications to be deployed
    in a predictable sequence on the cluster, based on application requirements, resources
    available, and governing policies.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态部署应用程序**：这允许根据应用程序需求、可用资源和管理策略，在集群上以可预测的顺序部署应用程序。'
- en: '**Flexible scheduler**: There is a lot of flexibility in terms of defining
    conditions for assigning pods to a specific or a set of worker nodes that meet
    those conditions.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的调度器**：在定义条件方面具有很大的灵活性，能够将 Pods 分配到满足这些条件的特定或一组工作节点。'
- en: '**Application Resilience**: Containers and management platforms help applications
    be more robust in a variety of ways, as follows:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序弹性**：容器和管理平台通过多种方式帮助应用程序提高韧性，如下所示：'
- en: Resource consumption policies such as CPU and memory quotas
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源消耗策略，如 CPU 和内存配额
- en: Handling the failures using a circuit breaker, timeout, retry, and so on
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断路器、超时、重试等处理故障
- en: Failover and service discovery
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障切换和服务发现
- en: Autoscaling and self-healing
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展和自愈
- en: '**Self-Service Environments**: These allow teams and individuals to create
    secluded environments for CI/CD, experimentation, and testing purposes from the
    cluster in real time.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自服务环境**：这些环境允许团队和个人实时从集群中创建隔离的环境，用于持续集成/持续交付（CI/CD）、实验和测试。'
- en: '**Service Discovery, Load Balancing, and Circuit Breaker**: Without the use
    of application agents, services can discover and consume other services. There''s
    more to this than what is listed here.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现、负载均衡和断路器**：在不使用应用程序代理的情况下，服务可以发现并消费其他服务。这里列举的内容远不止这些。'
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: The evolution of containers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的演变
- en: Kubernetes overview – understanding Kubernetes components
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 概述 – 理解 Kubernetes 组件
- en: Understanding pods
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Pods
- en: Understanding deployments
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解部署（Deployments）
- en: Understanding StatefulSets and DaemonSets
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 StatefulSets 和 DaemonSets
- en: Understanding jobs and CronJobs
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解作业和 CronJobs
- en: Understanding services
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务
- en: The evolution of containers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的演变
- en: 'Container technology is a means of packaging an application so that it may
    run with separated dependencies, and its compartmentalization of a computer system
    has radically transformed software development today. In this section, we''ll
    look at some of the key aspects, including where this technology originated and
    the background behind the container technology:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术是一种将应用程序打包的方式，使其能够在分离的依赖项中运行，计算机系统的隔离性已经彻底改变了今天的软件开发。在本节中，我们将探讨一些关键方面，包括这项技术的起源以及容器技术背后的背景：
- en: '![Figure 1.3 – A brief history of container technology ](img/Figure_1.3_B18115.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 容器技术简史](img/Figure_1.3_B18115.jpg)'
- en: Figure 1.3 – A brief history of container technology
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 容器技术简史
- en: Early containers (chroot systems with Unix version 7), developed in the 1970s,
    offered an isolated environment in which services and applications could operate
    without interfering with other processes, thereby creating a sandbox for testing
    programs, services, and other processes. The original concept was to separate
    the workload of the container from that of production systems, allowing developers
    to test their apps and procedures on production hardware without disrupting other
    services. Containers have improved their abilities to isolate users, data, networking,
    and more throughout time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的容器（带有 Unix 版本 7 的 chroot 系统），在 1970 年代开发，提供了一种隔离的环境，使服务和应用程序能够在不干扰其他进程的情况下运行，从而为程序、服务和其他进程的测试创建了沙箱。最初的概念是将容器的工作负载与生产系统的工作负载分离，使开发者能够在不干扰其他服务的情况下，在生产硬件上测试他们的应用程序和过程。随着时间的推移，容器在用户、数据、网络等方面的隔离能力不断提升。
- en: With the release of Free BSD Jails in the 2000s, container technology finally
    gained traction. "Jails" are computer partitions that can have several jails/partitions
    on the same system. This jail architecture was developed in 2001 with Linux VServer,
    which included resource partitioning and was later linked to the Linux kernel
    with OpenVZ in 2005\. Jails were merged with boundary separation to become Solaris
    Containers in 2004.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 2000 年代初期 Free BSD Jails 的发布，容器技术终于得到了广泛关注。"Jails" 是计算机分区，可以在同一系统上有多个监狱/分区。这种监狱架构是在
    2001 年通过 Linux VServer 开发的，它包括资源分区，并在 2005 年通过 OpenVZ 与 Linux 内核连接。监狱架构与边界分离技术合并，成为了
    2004 年的 Solaris 容器。
- en: Container technology advanced substantially after the introduction of control
    groups in 2006\. Control groups, or cgroups, were created to track and isolate
    resource utilization, such as CPU and memory. They were quickly adopted and improved
    upon in **Linux Containers** (**LXC**) in 2008, which was the most full and stable
    version of any container technology at the time since it functioned without changes
    having to be made to the Linux kernel. Many new technologies have sprung up because
    of LXC's reliability and stability, the first of which was Warden in 2011 and,
    more importantly, Docker in 2013.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术在 2006 年引入控制组后得到了显著进展。控制组（或 cgroups）用于跟踪和隔离资源使用情况，如 CPU 和内存。它们很快被采纳，并在 2008
    年的**Linux 容器**（**LXC**）中得到了改进，这是当时最完整和稳定的容器技术版本，因为它在运行时不需要对 Linux 内核进行任何更改。许多新技术因为
    LXC 的可靠性和稳定性而应运而生，最早的是 2011 年的 Warden，更重要的是 2013 年的 Docker。
- en: Containers have gained a lot of usage since 2013 due to a slew of Linux distributions
    releasing new deployment and management tools. Containers running on Linux systems
    have been transformed into virtualization solutions at the operating system level,
    aiming to provide several isolated Linux environments on a single Linux host.
    Linux containers don't need their own guest operating systems; instead, they share
    the kernel of the host operating system. Containers spin up significantly faster
    than virtual machines since they don't require a specialized operating system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2013 年以来，容器得到了广泛应用，因为许多 Linux 发行版发布了新的部署和管理工具。运行在 Linux 系统上的容器已经转变为操作系统级别的虚拟化解决方案，旨在为单个
    Linux 主机提供多个隔离的 Linux 环境。Linux 容器无需拥有自己的客户操作系统；它们共享主机操作系统的内核。容器的启动速度远快于虚拟机，因为它们不需要专门的操作系统。
- en: Containers can employ Linux kernel technologies such as namespaces, Apparmor,
    SELinux profiles, chroot, and cgroups to create an isolated operational environment,
    while Linux security modules offer an extra degree of protection, ensuring that
    containers can't access the host machine or kernel. Containerization in terms
    of Linux provided even more versatility by allowing containers to run various
    Linux distributions from their host operating system if both were running on the
    same CPU architecture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以利用 Linux 内核技术，如命名空间、Apparmor、SELinux 配置文件、chroot 和 cgroups 来创建一个隔离的操作环境，同时
    Linux 安全模块提供额外的保护，确保容器无法访问主机机器或内核。从 Linux 角度看，容器化通过允许容器在同一 CPU 架构下运行各种 Linux 发行版，提供了更大的灵活性。
- en: Linux containers provided us with a way to build container images based on a
    variety of Linux distributions, as well as an API for managing the containers'
    lifespan. Linux distributions also included client tools for dealing with the
    API, as well as snapshot features and support for moving container instances from
    one container host to another.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器为我们提供了一种基于各种 Linux 发行版构建容器镜像的方法，以及一个管理容器生命周期的 API。Linux 发行版还包括用于处理 API
    的客户端工具，以及快照功能和支持将容器实例从一个容器主机迁移到另一个容器主机的功能。
- en: However, while containers running on a Linux platform broadened their applicability,
    they still faced several fundamental hurdles, including unified management, real
    portability, compatibility, and scaling control.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然在 Linux 平台上运行的容器拓宽了其适用性，但它们仍然面临一些基本的难题，包括统一管理、真正的可移植性、兼容性和扩展控制。
- en: The emergence of Apache Mesos, Google Borg, and Facebook Tupperware, all of
    which provided varying degrees of container orchestration and cluster management
    capabilities, marked a significant advancement in the use of containers on Linux
    platforms. These platforms allowed hundreds of containers to be created instantly,
    and also provided support for automated failover and other mission-critical features
    that are required for container management at scale. However, it wasn't until
    Docker, a variation of containers, that the container revolution began in earnest.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Mesos、Google Borg 和 Facebook Tupperware 的出现，标志着容器编排和集群管理能力的显著进展，这些平台提供了不同程度的容器编排和集群管理功能，允许即时创建数百个容器，并提供支持自动故障转移等容器大规模管理所需的关键功能。然而，直到
    Docker —— 容器的一种变体 —— 的出现，容器革命才真正开始。
- en: 'Because of Docker''s popularity, several management platforms have emerged,
    including Marathon, Kubernetes, Docker Swarm, and, more broadly, the DC/OS environment
    that Mesosphere built on top of Mesos to manage not only containers but also a
    wide range of legacy applications and data services written in, for example, Java.
    Even though each platform has its unique approach to orchestration and administration,
    they all share one goal: to make containers more mainstream in the workplace.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 的流行，出现了多个管理平台，包括 Marathon、Kubernetes、Docker Swarm，以及更广泛的 DC/OS 环境，Mesosphere
    基于 Mesos 构建了该环境来管理不仅是容器，还包括各种遗留应用程序和数据服务，例如使用 Java 编写的程序。尽管每个平台在编排和管理上的方法不同，但它们都有一个共同的目标：使容器在工作场所中更加主流。
- en: The momentum of container technology accelerated in 2017 with the launch of
    Kubernetes, a highly effective container orchestration solution. Kubernetes became
    the industry norm after being adopted by CNCF and receiving backing from Docker.
    Thus, using a combination of Kubernetes and other container tools became the industry
    standard.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术的势头在 2017 年随着 Kubernetes 的发布而加速，Kubernetes 是一种高效的容器编排解决方案。Kubernetes 被 CNCF
    采纳并获得 Docker 的支持后，成为行业标准。因此，结合 Kubernetes 和其他容器工具的使用成为了行业的标准做法。
- en: With the release of cgroups v2 (Linux version 4.5), several new features have
    been added, including rootless containers, enhanced management, and, most crucially,
    the simplicity of cgroup controllers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 cgroups v2（Linux 版本 4.5）的发布，增加了多个新特性，包括无根容器、增强的管理功能，以及最重要的，cgroup 控制器的简化。
- en: Container usage has exploded in the last few years ([https://juju.is/cloud-native-kubernetes-usage-report-2021](https://juju.is/cloud-native-kubernetes-usage-report-2021))
    in both emerging "*cloud-native*" apps and situations where IT organizations wish
    to "containerize" an existing legacy program to make it easier to lift and shift
    onto the cloud. Containers have now become the de facto standard for application
    delivery as acceptance of cloud-native development approaches mature.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，容器的使用爆炸式增长（[https://juju.is/cloud-native-kubernetes-usage-report-2021](https://juju.is/cloud-native-kubernetes-usage-report-2021)），不仅在新兴的
    "*云原生*" 应用中，也在 IT 组织希望将现有遗留程序“容器化”以便更容易迁移到云端的场景中。随着云原生开发方法的成熟，容器现已成为应用交付的事实标准。
- en: We'll dive more into Kubernetes components in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中深入探讨 Kubernetes 组件。
- en: Kubernetes overview – understanding Kubernetes components
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 概述 – 理解 Kubernetes 组件
- en: In this section, we'll go through the various components of the Kubernetes system,
    as well as their abstractions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Kubernetes 系统的各个组件及其抽象。
- en: 'The following diagram depicts the various components that are required for
    a fully functional Kubernetes cluster:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了构建一个功能齐全的 Kubernetes 集群所需的各个组件：
- en: '![Figure 1.4 – A Kubernetes system and its abstractions ](img/Figure_1.4_B18115.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 一个 Kubernetes 系统及其抽象 ](img/Figure_1.4_B18115.jpg)'
- en: Figure 1.4 – A Kubernetes system and its abstractions
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 一个 Kubernetes 系统及其抽象
- en: 'Let''s describe the components of a Kubernetes cluster:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下 Kubernetes 集群的组件：
- en: '*Nodes*, which are worker machines that run containerized work units, make
    up a Kubernetes cluster. Every cluster has at least one worker node.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*节点*，即运行容器化工作单元的工作机器，构成了 Kubernetes 集群。每个集群至少有一个工作节点。'
- en: There is an API layer (Kubernetes API) that can communicate with Kubernetes
    clusters, which may be accessed via a command-line interface called *kubectl*.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 API 层（Kubernetes API）可以与 Kubernetes 集群进行通信，用户可以通过一个名为 *kubectl* 的命令行界面访问该层。
- en: 'There are two types of resources in a Kubernetes cluster (as shown in the preceding
    diagram):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中有两种资源类型（如前面的图所示）：
- en: The control plane, which controls and manages the cluster
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面，负责控制和管理集群
- en: The nodes, which are the workers' nodes that run applications
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点，即运行应用程序的工作节点
- en: All the operations in your cluster are coordinated by the control plane, including
    application scheduling, maintaining the intended state of applications, scaling
    applications, and deploying new updates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在集群中的操作都由控制平面协调，包括应用程序调度、维持应用程序的预期状态、扩展应用程序以及部署新更新。
- en: A cluster's nodes might be **virtual machines** (**VMs**) or physical computers
    that serve as worker machines. A kubelet is a node-managing agent that connects
    each of the nodes to Kubernetes control plane. Container management tools, such
    as Docker, should be present on the node as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 集群的节点可以是**虚拟机**（**VMs**）或作为工作机器的物理计算机。Kubelet 是一个节点管理代理，它将每个节点连接到 Kubernetes
    控制平面。容器管理工具，如 Docker，也应该在节点上存在。
- en: The control plane executes a command to start the application containers whenever
    an application needs to be started on Kubernetes. Containers are scheduled to
    run on the cluster's nodes by the control plane.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面执行命令以启动应用程序容器，每当需要在 Kubernetes 上启动应用程序时。容器由控制平面调度到集群的节点上运行。
- en: The nodes connect to the control plane using the Kubernetes API that the control
    plane provides. The Kubernetes API allows end users to interface directly with
    the cluster. The master components offer the cluster's control plane capabilities.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 节点通过控制平面提供的 Kubernetes API 连接到控制平面。Kubernetes API 允许最终用户直接与集群接口。主组件提供集群的控制平面功能。
- en: 'API Server, Controller-Manager, and Scheduler are the three processes that
    make up the Kubernetes control plane. The Kubernetes API is exposed through the
    API Server. It is the Kubernetes control plane''s frontend. Controller-Manager
    is in charge of the cluster''s controllers, which are responsible for handling
    everyday activities. The Scheduler keeps an eye out for new pods that don''t have
    a node assigned to them and assigns them one. Each worker node in the cluster
    is responsible for the following processes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务器、控制器管理器和调度器是构成 Kubernetes 控制平面的三个进程。Kubernetes API 通过 API 服务器暴露，它是 Kubernetes
    控制平面的前端。控制器管理器负责管理集群的控制器，这些控制器处理日常活动。调度器监视没有分配节点的新 pod，并为其分配一个节点。集群中的每个工作节点负责以下进程：
- en: '**Kubelet**: This handles all the communication with the Kubernetes MasterControl
    plane.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubelet**：负责与 Kubernetes 主控平面进行所有通信。'
- en: '**kube-proxy**: This handles all the networking proxy services on each node.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-proxy**：处理每个节点上的所有网络代理服务。'
- en: The container runtime, such as Docker.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时，例如 Docker。
- en: Control plane components are in charge of making global cluster decisions (such
    as application scheduling), as well as monitoring and responding to cluster events.
    For clusters, there is a web-based Kubernetes dashboard. This allows users to
    administer and debug cluster-based applications, as well as the cluster itself.
    Kubernetes clusters may run on a wide range of platforms, including your laptop,
    cloud-hosted virtual machines, and bare-metal servers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面组件负责做出全局集群决策（如应用程序调度），以及监控和响应集群事件。对于集群，有一个基于 Web 的 Kubernetes 仪表盘。这允许用户管理和调试基于集群的应用程序以及集群本身。Kubernetes
    集群可以运行在各种平台上，包括你的笔记本电脑、云托管的虚拟机和裸机服务器。
- en: '**MicroK8s** is a simplistic streamlined Kubernetes implementation that builds
    a Kubernetes cluster on your local workstation and deploys all the Kubernetes
    services on a tiny cluster that only includes one node. It can be used to experiment
    with your local Kubernetes setup. MicroK8s is compatible with Linux, macOS X,
    Raspberry Pi, and Windows and can be used to experiment with local Kubernetes
    setups or for edge production use cases. Start, stop, status, and delete are all
    basic bootstrapping procedures that are provided by the MicroK8s CLI for working
    with your cluster. We''ll learn how to install MicroK8s, check the status of the
    installation, monitor and control the Kubernetes cluster, and deploy sample applications
    and add-ons in the next chapter.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroK8s** 是一种简化的 Kubernetes 实现，它在本地工作站上构建一个 Kubernetes 集群，并在仅包含一个节点的小集群上部署所有
    Kubernetes 服务。它可以用来在本地 Kubernetes 环境中进行实验。MicroK8s 兼容 Linux、macOS X、树莓派和 Windows，并可以用于本地
    Kubernetes 设置的实验或边缘生产用例。启动、停止、查看状态和删除是 MicroK8s CLI 提供的基本引导程序，用于与集群进行交互。我们将在下一章学习如何安装
    MicroK8s，检查安装状态，监控和控制 Kubernetes 集群，以及部署示例应用和附加组件。'
- en: 'Other objects that indicate the state of the system exist in addition to the
    components listed in *Figure 1.4*. The following are some of the most fundamental
    Kubernetes objects:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*图 1.4*中列出的组件外，系统状态的其他对象也存在。以下是一些最基本的 Kubernetes 对象：
- en: Pods
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod
- en: Deployments
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署（Deployments）
- en: StatefulSets and DaemonSets
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态集（StatefulSets）和守护进程集（DaemonSets）
- en: Jobs and CronJobs
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业（Jobs）和定时作业（CronJobs）
- en: Services
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务（Services）
- en: 'In the Kubernetes system, Kubernetes objects are persistent entities. These
    entities are used by Kubernetes to represent the state of your cluster. It will
    operate indefinitely to verify that the object exists once it has been created.
    You''re simply telling the Kubernetes framework how your cluster''s workloads
    should look by building an object; this is your cluster''s ideal state. You must
    use the Kubernetes API to interact with Kubernetes objects, whether you want to
    create, update, or delete them. The CLI handles all Kubernetes API queries when
    you use the `kubectl` command-line interface, for example. You can also directly
    access the Kubernetes API in your apps by using any of the client libraries. The
    following diagram illustrates the various Kubernetes objects:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 系统中，Kubernetes 对象是持久性实体。这些实体由 Kubernetes 用来表示集群的状态。一旦创建，Kubernetes
    将无限期地运行，以验证该对象是否存在。你只是通过构建一个对象来告诉 Kubernetes 框架你的集群工作负载应该是什么样子；这就是你集群的理想状态。无论是创建、更新还是删除
    Kubernetes 对象，你都必须使用 Kubernetes API 与其交互。例如，当你使用 `kubectl` 命令行界面时，CLI 会处理所有 Kubernetes
    API 查询。你也可以通过使用任何客户端库，在你的应用程序中直接访问 Kubernetes API。以下图示展示了各种 Kubernetes 对象：
- en: '![Figure 1.5 – Overview of Kubernetes objects ](img/Figure_1.5_B18115.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – Kubernetes 对象概述](img/Figure_1.5_B18115.jpg)'
- en: Figure 1.5 – Overview of Kubernetes objects
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Kubernetes 对象概述
- en: Kubernetes provides the preceding set of objects (such as pods, services, and
    controllers) to satisfy our application's requirements and drive its architecture.
    The guiding design principles and design patterns we employ to build any new services
    are determined by these new primitives and platform abilities. A *deployment*
    object, for example, is a Kubernetes object that can represent an application
    running on your cluster. When you build the *deployment*, you can indicate that
    three replicas of the application should be running in the *deployment* specification.
    The Kubernetes system parses the *deployment* specification and deploys three
    instances of your desired application, altering its status as needed. If any of
    those instances fail for whatever reason, the Kubernetes framework responds to
    the discrepancy between the specification and the status by correcting it – in
    this case, by establishing a new instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了前述的一组对象（如 Pod、服务和控制器）来满足我们应用程序的需求并推动其架构。我们用来构建任何新服务的设计原则和设计模式，都是由这些新的原始对象和平台能力决定的。例如，*部署*对象是一个
    Kubernetes 对象，可以表示在集群中运行的应用程序。当你构建*部署*时，可以指示在*部署*规范中应运行三个副本。Kubernetes 系统解析*部署*规范，并部署你所需应用的三个实例，根据需要调整其状态。如果这些实例中的任何一个因任何原因失败，Kubernetes
    框架会通过纠正规范和状态之间的不一致来响应这一变化——在这种情况下，通过建立一个新的实例。
- en: Understanding how Kubernetes works is essential, but understanding how to communicate
    with Kubernetes is just as important. We'll go over some of the ways to interact
    with a Kubernetes cluster in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 如何工作是至关重要的，但理解如何与 Kubernetes 进行通信同样重要。在下一节中，我们将讨论与 Kubernetes
    集群交互的一些方式。
- en: Interacting with a Kubernetes cluster
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Kubernetes 集群交互
- en: In this section, we'll look at different ways to interface with a Kubernetes
    cluster.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨与 Kubernetes 集群交互的不同方式。
- en: '**Kubernetes Dashboard** is a user interface that can be accessed via the web.
    It can be used to deploy containerized applications to a Kubernetes cluster, troubleshoot
    them, and control the cluster''s resources. This dashboard can be used for a variety
    of purposes, including the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes 仪表盘**是一个可以通过 Web 访问的用户界面。它可用于将容器化应用程序部署到 Kubernetes 集群，进行故障排除并控制集群资源。该仪表盘可用于多种用途，包括以下几项：'
- en: All the nodes and persistent storage volumes are listed in the **Admin** overview,
    along with aggregated metrics for each node.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有节点和持久存储卷都列在 **管理员** 概览中，并附有每个节点的汇总指标。
- en: The **Workloads** view displays a list of all running applications by namespace,
    as well as current pod memory utilization and the number of pods in a deployment
    that are currently ready.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作负载**视图显示了按命名空间列出的所有正在运行的应用程序，以及当前 Pod 的内存利用率和在部署中当前就绪的 Pod 数量。'
- en: The **Discover** view displays a list of services that have been made public
    and have enabled cluster discovery.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现**视图显示了已公开并启用集群发现的服务列表。'
- en: You can drill down through logs from containers that belong to a single pod
    using the **Logs** view.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过 **日志** 视图深入查看属于同一个 Pod 的容器的日志。
- en: For each clustered application and all the Kubernetes resources running in the
    cluster, the **Storage** view identifies any persistent volume claims.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个集群中的应用程序以及集群中运行的所有 Kubernetes 资源，**存储**视图会识别任何持久卷声明。
- en: '![Figure 1.6 – Kubernetes Dashboard ](img/Figure_1.6_B18115.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – Kubernetes 仪表盘](img/Figure_1.6_B18115.jpg)'
- en: Figure 1.6 – Kubernetes Dashboard
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – Kubernetes 仪表盘
- en: With the help of the Kubernetes command-line tool, `kubectl`, you can perform
    commands against Kubernetes clusters. `kubectl` is a command-line tool for deploying
    applications, inspecting and managing cluster resources, and viewing logs. `kubectl`
    can be installed on a variety of Linux, macOS, and Windows platforms.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借助 Kubernetes 命令行工具 `kubectl`，你可以对 Kubernetes 集群执行命令。`kubectl` 是一个命令行工具，用于部署应用程序、检查和管理集群资源以及查看日志。`kubectl`
    可以安装在各种 Linux、macOS 和 Windows 平台上。
- en: 'The basic syntax for `kubectl` looks as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 的基本语法如下：'
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s look at `command`, `type`, `name`, and `flags` in more detail:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看一下`command`、`type`、`name`和`flags`：
- en: '`command`: This defines the action you wanted to obtain on one or more resources,
    such as `create`, `get`, `delete`, and `describe`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：这定义了你希望在一个或多个资源上执行的操作，如`create`、`get`、`delete`和`describe`。'
- en: '`type`: This defines the types of your resources, such as pods and jobs.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这定义了资源的类型，如 Pods 和 Jobs。'
- en: '`name`: This defines the name of the resource. Names are case-sensitive. If
    the name is omitted, details for all the resources are displayed; for example,
    `kubectl get pods`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这定义了资源的名称。名称区分大小写。如果省略名称，则显示所有资源的详细信息；例如，`kubectl get pods`。'
- en: '`flags`: This defines optional flags.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：这定义了可选的标志。'
- en: We'll take a closer look at each of these Kubernetes objects in the upcoming
    sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地了解这些 Kubernetes 对象。
- en: Understanding pods
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Pods
- en: 'Pods are the minimal deployable computing units that can be built and managed
    in Kubernetes. They are made up of one or more containers that share storage and
    network resources, as well as running instructions. Pods have the following components:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 是在 Kubernetes 中构建和管理的最小可部署计算单元。它们由一个或多个共享存储和网络资源以及运行指令的容器组成。Pods 具有以下组件：
- en: An exclusive IP address that enables them to converse with one another
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个专用的 IP 地址，使它们能够相互通信
- en: Persistent storage volumes based on the application's needs
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于应用程序需求的持久存储卷
- en: Configuration information that determines how a container should run
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定容器如何运行的配置信息
- en: 'The following diagram shows the various components of a pod:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了 Pod 的各个组件：
- en: '![Figure 1.7 – The components of a pod ](img/Figure_1.7_B18115.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – Pod 的组件](img/Figure_1.7_B18115.jpg)'
- en: Figure 1.7 – The components of a pod
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – Pod 的组件
- en: Workload resources known as controllers create pods and oversee the rollout,
    replication, and health of pods in the cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为工作负载资源的控制器创建 pod，并监督 pod 在集群中的部署、复制和健康状态。
- en: 'The most common types of controllers are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的控制器类型如下：
- en: '**Jobs** for batch-type jobs that are short-lived and will run a task to completion'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jobs** 适用于短生命周期的批处理任务，这些任务会执行直到完成。'
- en: '**Deployments** for applications that are stateless and persistent, such as
    web servers'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**适用于无状态和持久化的应用程序，如 Web 服务器。'
- en: '**StatefulSets** for applications that are both stateful and persistent, such
    as databases'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StatefulSets** 适用于既有状态又持久化的应用程序，如数据库。'
- en: These controllers build pods using configuration information from a pod template,
    and they guarantee that the operating pods meet the deployment specification provided
    in the pod template by creating replicas in the number of instances specified
    in the deployment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制器使用来自 pod 模板的配置信息构建 pod，并通过在部署中指定的实例数创建副本，确保运行的 pod 满足 pod 模板中提供的部署规范。
- en: As we mentioned previously, the Kubectl command-line interface includes various
    commands that allow users to build pods, deploy them, check on the status of operating
    pods, and delete pods that are no longer needed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kubectl 命令行界面包括各种命令，允许用户构建 pods、部署它们、检查正在运行的 pod 状态，并删除不再需要的 pod。
- en: 'The following are the most commonly used `kubectl` commands concerning pods:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用的关于 pods 的 `kubectl` 命令：
- en: 'The `create` command creates the pod:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create` 命令创建 pod：'
- en: '[PRE1]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For example, the `kubectl create -f ./mypod.yaml` command will create a new
    pod from the `mypod` YAML file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kubectl create -f ./mypod.yaml` 命令将从 `mypod` YAML 文件创建一个新的 pod。
- en: 'The `get pod`/`pods` command will display information about one or more resources.
    Information can be filtered using the respective label selectors:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get pod`/`pods` 命令将显示一个或多个资源的信息。可以使用相应的标签选择器来过滤信息：'
- en: '[PRE2]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `delete` command deletes the pod:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete` 命令删除 pod：'
- en: '[PRE3]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For example, the `kubectl delete -f ./mypod.yaml` command will delete the `mypod`
    pod from the cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kubectl delete -f ./mypod.yaml` 命令将从集群中删除 `mypod` pod。
- en: With that, we've learned that a pod is the smallest unit of a Kubernetes application
    and is made up of one or more Linux containers. In the next section, we will look
    at deployments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由此我们了解到，pod 是 Kubernetes 应用程序的最小单元，由一个或多个 Linux 容器组成。在下一部分中，我们将学习部署。
- en: Understanding deployments
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解部署
- en: Deployment allows you to make declarative changes to pods and ReplicaSets. You
    can provide a desired state for the deployment, and the deployment controller
    will incrementally change the actual state to the desired state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 部署允许你对 pods 和 ReplicaSets 进行声明式的变更。你可以为部署提供期望的状态，部署控制器将逐步将实际状态更改为期望状态。
- en: 'Deployments can be used to create new ReplicaSets or to replace existing deployments
    with new deployments. When a new version is ready to go live in production, the
    deployment can easily handle the upgrade with no downtime by using predefined
    rules. The following diagram shows an example of a deployment:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可用于创建新的 ReplicaSets，或者用新的部署替换现有部署。当新版本准备好上线时，部署可以通过使用预定义规则轻松处理升级，且无需停机。以下图示展示了一个部署的示例：
- en: '![Figure 1.8 – A deployment ](img/Figure_1.8_B18115.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 部署](img/Figure_1.8_B18115.jpg)'
- en: Figure 1.8 – A deployment
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 部署
- en: 'The following is an example of a deployment. It creates a ReplicaSet to bring
    up three `nginx` pods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个部署的示例。它创建了一个 ReplicaSet 来启动三个 `nginx` pod：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding example, the following occurred:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，发生了以下情况：
- en: A deployment called `nginx-sample-deployment` is created, as indicated by the
    `metadata.name` field.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个名为 `nginx-sample-deployment` 的部署，正如 `metadata.name` 字段所示。
- en: The image for this deployment is set by the `Spec.containers.image` field (`nginx:latest`).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此部署的镜像由 `Spec.containers.image` 字段设置（`nginx:latest`）。
- en: The deployment creates three replicated pods, as indicated by the `replicas`
    field.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署创建了三个副本 pod，如 `replicas` 字段所示。
- en: 'The most commonly used `kubectl` commands concerning deployment are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的关于部署的 `kubectl` 命令如下：
- en: 'The `apply` command creates the pod:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply` 命令创建 pod：'
- en: '[PRE5]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For example, the `kubectl apply -f ./nginx-deployment.yaml` command will create
    a new deployment from the `nginx-deployment.yaml` YAML file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kubectl apply -f ./nginx-deployment.yaml` 命令将从 `nginx-deployment.yaml` YAML
    文件创建一个新的部署。
- en: 'The `get deployments` command checks the status of the deployment:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get deployments` 命令检查部署的状态：'
- en: '[PRE6]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will produce the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following fields are displayed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 显示以下字段：
- en: '`NAME` indicates the names of the deployments in the namespace.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME` 表示命名空间中部署的名称。'
- en: '`READY` shows how many replicas of the application are available.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READY` 显示有多少副本的应用程序可用。'
- en: '`UP-TO-DATE` shows the number of replicas that have been updated to achieve
    the desired state.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UP-TO-DATE` 显示已更新到达所需状态的副本数量。'
- en: '`AVAILABLE` shows the number of available replicas.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVAILABLE` 显示可用副本的数量。'
- en: '`AGE` indicates the length of time the application has been running.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AGE` 表示应用程序运行的时间长度。'
- en: 'The `describe deployments` command indicates the details of the deployment:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe deployments` 命令显示部署的详细信息：'
- en: '[PRE8]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `delete` command removes the deployment that was made by the `apply` command:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete` 命令删除由 `apply` 命令创建的部署：'
- en: '[PRE9]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that, we have learned that deployments are used to define the life cycle
    of an application, including which container images to use, how many pods you
    should have, and how they should be updated. In the next section, we will look
    at StatefulSets and DaemonSets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们已经了解到，部署用于定义应用程序的生命周期，包括使用哪个容器镜像、应该有多少个 Pod，以及它们如何更新。在下一节中，我们将探讨 StatefulSets
    和 DaemonSets。
- en: Understanding StatefulSets and DaemonSets
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 StatefulSets 和 DaemonSets
- en: 'In this section, we''ll go over two distinct approaches to deploying our application
    on Kubernetes: using StatefulSets and DaemonSets.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两种在 Kubernetes 上部署应用程序的不同方法：使用 StatefulSets 和 DaemonSets。
- en: StatefulSets
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StatefulSets
- en: 'The StatefulSet API object is used to handle stateful applications. A StatefulSet,
    like a deployment, handles pods that have the same container specification. A
    StatefulSet, unlike a deployment, continues using a persistent identity for each
    of its pods. These pods are generated for identical specifications, but they can''t
    be exchanged: each has a unique identity that it keeps throughout any rescheduling.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet API 对象用于处理有状态的应用程序。像部署一样，StatefulSet 处理具有相同容器规范的 Pod。不同于部署，StatefulSet
    为每个 Pod 保持持久的身份。虽然这些 Pod 是基于相同的规范生成的，但它们不能相互替换：每个 Pod 都有一个独特的身份，并且这个身份会在任何重新调度过程中保留。
- en: 'The following example demonstrates the components of a StatefulSet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了 StatefulSet 的组成部分：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding example, we have the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有以下内容：
- en: '`nginx` is the headless service that is used to control the network domain.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx` 是一个无头服务，用于控制网络域。'
- en: '`web` is the StatefulSet that has a specification that indicates that three
    replicas from the `nginx` container will be launched in unique pods.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web` 是一个 StatefulSet，它的规范指示将在独立的 Pod 中启动三个来自 `nginx` 容器的副本。'
- en: '`volumeClaimTemplates` will use PersistentVolumes provisioned by a PersistentVolume
    provisioner to offer stable storage.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumeClaimTemplates` 将使用由 PersistentVolume 提供者提供的 PersistentVolumes 来提供稳定的存储。'
- en: Now, let's move on to DaemonSets.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论 DaemonSets。
- en: DaemonSets
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DaemonSets
- en: A DaemonSet guarantees that all (or some) nodes have a copy of a pod running.
    As nodes are added to the cluster, pods are added to them. As nodes are removed
    from the cluster, garbage is collected in pods. When you delete a DaemonSet, the
    pods it produced are also deleted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSet 确保所有（或部分）节点上都有一个副本的 Pod 在运行。随着节点被添加到集群中，Pod 会被添加到这些节点上。随着节点从集群中移除，Pod
    会被清理。当你删除一个 DaemonSet 时，它产生的 Pod 也会被删除。
- en: 'The following are some example use cases regarding DaemonSets:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于 DaemonSets 的示例用例：
- en: Run a daemon for cluster storage on each node, such as `glusterd` and `ceph`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上运行一个守护进程以进行集群存储，例如 `glusterd` 和 `ceph`。
- en: Run a daemon for logs to be collected on each node, such as `Fluentd` or `FluentBit`
    and `logstash`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上运行一个守护进程以收集日志，例如 `Fluentd`、`FluentBit` 和 `logstash`。
- en: Run a daemon for monitoring on every node, such as Prometheus Node Exporter,
    `collectd`, or Datadog agent.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上运行一个守护进程以进行监控，例如 Prometheus Node Exporter、`collectd` 或 Datadog agent。
- en: 'The following code shows a DaemonSet that''s running the `fluent-bit` Docker
    image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个正在运行 `fluent-bit` Docker 镜像的 DaemonSet：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, the `fluent-bit` DaemonSet has a specification that
    tells `fluent-bit` to run on all the nodes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`fluent-bit` DaemonSet 的规范告诉 `fluent-bit` 在所有节点上运行。
- en: 'The most commonly used `kubectl` commands concerning DaemonSets are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 DaemonSets，最常用的 `kubectl` 命令如下：
- en: 'The `create` or `apply` command creates the DaemonSet:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create` 或 `apply` 命令创建 DaemonSet：'
- en: '[PRE12]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For example, the `kubectl apply -f ./daemonset-deployment.yaml` command will
    create a new DaemonSet from the `daemonset-deployment.yaml` YAML file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kubectl apply -f ./daemonset-deployment.yaml` 命令将从 `daemonset-deployment.yaml`
    YAML 文件创建一个新的 DaemonSet。
- en: 'The `get daemonset` command is used to monitor the status of the DaemonSet:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get daemonset` 命令用于监控 DaemonSet 的状态：'
- en: '[PRE13]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will produce the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following fields are displayed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 显示以下字段：
- en: '`NAME` indicates the names of the DaemonSets in the namespace.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME` 表示命名空间中 DaemonSets 的名称。'
- en: '`READY` shows how many replicas of the application are available.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`READY` 显示应用程序可用的副本数量。'
- en: '`UP-TO-DATE` shows the number of replicas that have been updated to achieve
    the desired state.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UP-TO-DATE` 显示已更新的副本数，以实现所需状态。'
- en: '`AVAILABLE` shows how many replicas of the application are available.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVAILABLE` 显示应用程序可用的副本数量。'
- en: '`AGE` indicates the length of time the application has been running.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AGE` 表示应用程序运行的时间长度。'
- en: 'The `describe daemonset` command indicates the details of the DaemonSets:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe daemonset` 命令显示 DaemonSets 的详细信息：'
- en: '[PRE15]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `delete` command removes the deployment that was made by the `apply` command:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete` 命令删除由 `apply` 命令创建的部署：'
- en: '[PRE16]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that, we've learned that a DaemonSet ensures that all or a set of nodes
    run a copy of a pod, while a StatefulSet is used to manage stateful applications.
    In the next section, we will look at jobs and CronJobs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经学到，DaemonSet 确保所有或一组节点都运行一个 Pod 副本，而 StatefulSet 用于管理有状态应用程序。在下一节中，我们将学习作业和
    CronJobs。
- en: Understanding jobs and CronJobs
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解作业和 CronJobs
- en: In this section, we will learn how to use Kubernetes jobs to build temporary
    pods that do certain tasks. CronJobs are similar to jobs, but they run tasks according
    to a set schedule.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Kubernetes 作业构建执行特定任务的临时 Pod。CronJobs 类似于作业，但它们根据设定的时间表运行任务。
- en: Jobs
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作业
- en: A job launches one or more pods and continues to try executing them until a
    specific number of them succeed. The job keeps track of how many pods have been
    completed successfully. The task (that is, the job) is completed when a certain
    number of successful completions is met.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个作业启动一个或多个 Pod，并继续尝试执行它们，直到特定数量的 Pod 成功。作业会跟踪成功完成的 Pod 数量。当满足成功完成的数量时，任务（即作业）完成。
- en: 'When you delete a job, it also deletes all the pods it created. Suspending
    a job causes all the current pods to be deleted until the job is resumed. The
    following code shows a job config that runs every minute and prints `example Job
    Pod is Running` as its output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您删除作业时，它也会删除所有由其创建的 Pod。暂停作业会导致所有当前的 Pod 被删除，直到作业恢复。以下代码显示了一个每分钟运行的作业配置，并打印
    `example Job Pod is Running` 作为其输出：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The most commonly used `kubectl` commands concerning jobs are as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于作业的最常用 `kubectl` 命令如下：
- en: 'The `create` or `apply` command creates the pod:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create` 或 `apply` 命令创建 Pod：'
- en: '[PRE18]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For example, the `kubectl apply -f ./jobs-deployment.yaml` command will create
    new jobs from the `jobs-deployment.yaml` YAML file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kubectl apply -f ./jobs-deployment.yaml` 命令将从 `jobs-deployment.yaml` YAML
    文件创建新的作业。
- en: 'The `describe jobs` command indicates the details of the jobs:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe jobs` 命令显示作业的详细信息：'
- en: '[PRE19]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: CronJob
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CronJob
- en: A CronJob is a job that is created regularly. It is equivalent to a single line
    in a crontab (cron table) file. It executes a job that is written in Cron format
    regularly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: CronJob 是一个定期创建的作业。它相当于 crontab（cron 表格）文件中的一行。它定期执行以 Cron 格式编写的作业。
- en: CronJobs are used to automate common processes such as backups and report generation.
    You can decide when the work should begin within that period by setting each of
    those jobs to repeat indefinitely (for example, once a day, week, or month).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: CronJobs 用于自动化常见的过程，如备份和报告生成。您可以通过将每个作业设置为无限次重复（例如每天、每周或每月一次）来决定何时开始工作。
- en: 'The following is an example of a CronJob that prints the `example-cronjob Pod
    is Running` output every minute:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 CronJob 示例，它每分钟打印 `example-cronjob Pod is Running` 输出：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, `schedule: /1 *` indicates that the crontab syntax is used in Linux systems.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`schedule: /1 *` 表示在 Linux 系统中使用的是 crontab 语法。'
- en: Jobs and CronJobs are critical components of Kubernetes, particularly for performing
    batch processes and other critical ad hoc tasks. We'll examine service abstraction
    in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 作业和 CronJobs 是 Kubernetes 的关键组件，特别用于执行批处理过程和其他关键的临时任务。我们将在下一节中讨论服务抽象。
- en: Understanding services
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务
- en: 'In Kubernetes, a `9876` with the `app=exampleApp` label:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，带有 `app=exampleApp` 标签的 `9876`：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, a new `Service` object named `example-service` was
    created that routes TCP port `9876` to any pod with the `app=exampleApp` label.
    This service is given an IP address by Kubernetes, which is utilized by the service
    proxies. A Kubernetes service, in simple terms, connects a group of pods to an
    abstracted service name and IP address. Discovery and routing between pods are
    provided by services. Services, for example, connect an application's frontend
    to its backend, which are both deployed in different cluster deployments. Labels
    and selectors are used by services to match pods with other applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，创建了一个名为 `example-service` 的新 `Service` 对象，将 TCP 端口 `9876` 路由到具有 `app=exampleApp`
    标签的任何 pod。Kubernetes 会为该服务分配一个 IP 地址，供服务代理使用。简单来说，Kubernetes 服务将一组 pods 连接到一个抽象的服务名称和
    IP 地址。服务提供了 pods 之间的发现和路由。例如，服务将应用程序的前端与其后端连接，这两个部分部署在不同的集群部署中。服务通过标签和选择器来匹配与其他应用程序的
    pods。
- en: 'The core attributes of a Kubernetes service are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务的核心属性如下：
- en: A label selector that locates pods
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位 pods 的标签选择器
- en: The cluster IP address and the assigned port number
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群的 IP 地址和分配的端口号
- en: Port definitions
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口定义
- en: (Optional) Mapping for incoming ports to a targetPort
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）将入站端口映射到 targetPort
- en: Kubernetes will automatically assign a cluster IP address, which will be used
    to route traffic by service proxies. The selector's controller will check for
    pods that match the defined label. Some applications will require multiple ports
    to be exposed via the service. Kubernetes facilitates this by using multi-port
    services, where a user can define multiple ports in a single service object.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 会自动分配一个集群 IP 地址，供服务代理路由流量使用。选择器的控制器将检查与定义的标签匹配的 pods。一些应用程序需要通过服务暴露多个端口。Kubernetes
    通过使用多端口服务来简化这一点，用户可以在单个服务对象中定义多个端口。
- en: 'In the following example, we have exposed ports `80` and `443` to target ports
    `8080` and `8090` to route HTTP and HTTPS traffic to any underlying pods using
    the `app=webserver-nginx-multiport-example` selector:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们已将端口 `80` 和 `443` 暴露到目标端口 `8080` 和 `8090`，以便使用 `app=webserver-nginx-multiport-example`
    选择器将 HTTP 和 HTTPS 流量路由到任何底层的 pods：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A service can also be defined without the use of a selector; however, you must
    explicitly connect the service (IP address, port, and so on) using an `endpoints`
    object. This is because, unlike with a selector, Kubernetes does not know which
    pods the service should be connected to, so `endpoint` objects are not built automatically.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以不使用选择器来定义服务；但必须显式地使用 `endpoints` 对象连接服务（IP 地址、端口等）。这是因为与选择器不同，Kubernetes
    不知道服务应该连接到哪些 pods，因此不会自动构建 `endpoint` 对象。
- en: 'Some use cases for services without selectors are as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 没有选择器的服务的一些使用案例如下：
- en: Connecting to another service in a different namespace or cluster
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到不同命名空间或集群中的另一个服务
- en: Communicating with external services, data migration, testing services, deployments,
    and so on
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部服务的通信、数据迁移、测试服务、部署等
- en: 'Let''s create a deployment with three replicas of an Apache web server:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含三个副本的 Apache Web 服务器部署：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the deployment using the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建部署：
- en: '**kubectl apply -f apache-deployment.yaml**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl apply -f apache-deployment.yaml**'
- en: 'The following are the most common types of services:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的服务类型：
- en: '**ClusterIP**: This is the default type and exposes the service via the cluster''s
    internal IP address. These services are only accessible within the cluster. So,
    users need to implement port forwarding or a proxy to expose a ClusterIP to a
    wider ingress of traffic.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterIP**：这是默认类型，并通过集群的内部 IP 地址暴露服务。这些服务仅在集群内可访问。因此，用户需要实现端口转发或代理，以将 ClusterIP
    暴露给更广泛的流量入口。'
- en: '`NodeIP:NodePort>` from the outside allows users to communicate with the service.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NodeIP:NodePort>` 允许用户从外部与服务进行通信。'
- en: '**LoadBalancer**: This is the preferred solution for exposing the cluster to
    the wider internet. The LoadBalancer type of service will create a load balancer
    (the load balancer''s type depends on the cloud provider) and expose the service
    externally. It will also automatically create ClusterIP and NodePort services
    and route traffic accordingly.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadBalancer**：这是将集群暴露到更广泛互联网的首选解决方案。LoadBalancer 类型的服务会创建一个负载均衡器（负载均衡器的类型取决于云提供商），并将服务暴露到外部。它还会自动创建
    ClusterIP 和 NodePort 服务，并相应地路由流量。'
- en: '`externalName ex.sampleapp.test.com` field by returning a value for the `CNAME`
    record.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalName ex.sampleapp.test.com` 字段通过返回 `CNAME` 记录的值来实现。'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: To conclude, Kubernetes is a container orchestration system that maintains a
    highly available cluster of machines that work together as a single entity. In
    this chapter, we discovered that Kubernetes supports several abstractions that
    allow containerized applications to be deployed to a cluster without being bound
    to specific machines. We also learned that pods represent a set of operating containers
    on your cluster. A deployment is an excellent fit for managing a stateless application
    workload on your cluster. StatefulSets can be used to run one or more connected
    pods to manage stateful applications, while DaemonSets specify pods and provide
    node-specific functionality. Finally, jobs and CronJobs handle batch processing
    and other key ad hoc tasks. In a nutshell, Kubernetes is a container orchestration
    system that is portable, extensible, and self-healing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Kubernetes 是一个容器编排系统，它维护一个高度可用的机器集群，这些机器作为一个整体协同工作。在本章中，我们发现 Kubernetes
    支持多种抽象，使得容器化应用能够部署到集群中，而不受限于特定的机器。我们还了解了 pods 代表了集群中一组正在运行的容器。部署（Deployment）非常适合在集群上管理无状态的应用工作负载。StatefulSets
    可以用于运行一个或多个连接的 pods 来管理有状态应用，而 DaemonSets 则指定 pods 并提供节点特定的功能。最后，jobs 和 CronJobs
    负责批处理和其他关键的临时任务。简而言之，Kubernetes 是一个便携、可扩展、自愈的容器编排系统。
- en: In the next chapter, we'll look at the lightweight Kubernetes engine known as
    MicroK8s, which can run on the edge, IoT, and appliances. MicroK8s is also ideal
    for offline prototyping, testing, and development.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将了解被称为 MicroK8s 的轻量级 Kubernetes 引擎，它可以运行在边缘计算、物联网和设备上。MicroK8s 同样非常适合离线原型设计、测试和开发。
