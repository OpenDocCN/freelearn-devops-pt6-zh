- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Understanding Istio Control and Data Planes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Istio 控制平面和数据平面
- en: 'The previous chapter gave you an overview of Istio, what a simple installation
    looks like, and how to apply a Service Mesh to a sample application. In this chapter,
    we will dive deeper into Istio’s control plane and data plane. We will understand
    the role of each of these components by going through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章给你概述了 Istio，展示了简单安装的样子，并且说明了如何将 Service Mesh 应用于示例应用程序。在本章中，我们将深入探讨 Istio
    的控制平面和数据平面。我们将通过以下主题来了解这些组件的角色：
- en: Components of Istio control plane
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio 控制平面组件
- en: Deployment models for Istio control plane
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio 控制平面的部署模型
- en: Envoy, the Istio data plane
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Envoy，Istio 数据平面
- en: This chapter will help you understand the Istio control plane so you can plan
    the installation of control planes in a production environment. After reading
    this chapter, you should be able to identify the various components of the Istio
    control plane including istiod, along with the functionality they each deliver
    in the overall working of Istio.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你理解 Istio 控制平面，以便你能够规划在生产环境中安装控制平面。在阅读本章后，你应该能够识别 Istio 控制平面的各个组件，包括 istiod，并理解它们在
    Istio 整体工作中所发挥的作用。
- en: Exploring the components of a control plane
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索控制平面组件
- en: The following diagram summarizes the Istio architecture along with the interaction
    between various components. We used the Ingress gateway and istio-proxy in the
    previous chapter so we will not go into further details on those here. We will,
    however, unravel some of the other components of the Istio control plane not directly
    depicted in the following illustration.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下图总结了 Istio 架构以及各个组件之间的交互。我们在上一章中使用了 Ingress 网关和 istio-proxy，因此这里不再详细讲解这些内容。然而，我们将揭示一些在下图中没有直接描绘的
    Istio 控制平面其他组件。
- en: '![Figure 3.1 – Istio control plane](img/B17989_03_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Istio 控制平面](img/B17989_03_01.jpg)'
- en: Figure 3.1 – Istio control plane
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Istio 控制平面
- en: Before we delve into the components of the control plane, let’s first get the
    definition of the term out of the way – the **control plane** is a set of Istio
    services that are responsible for the operations of the Istio data plane. There
    is no single component that constitutes the control plane – rather, there are
    several.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨控制平面的组件之前，我们先把术语的定义搞清楚——**控制平面**是一组负责 Istio 数据平面操作的 Istio 服务。没有单一组件构成控制平面——而是由多个组件组成。
- en: Let’s look at the first component of the Istio control plane called istiod.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Istio 控制平面的第一个组件——istiod。
- en: istiod
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: istiod
- en: istiod is one of the Istio control plane components, providing service discovery,
    configuration, and certificate management. In prior versions of Istio, the control
    plane was made up of components called Galley, Pilot, Mixer, Citadel, WebHook
    Injector, and so on. istiod unifies the functionality of these components (Pilot,
    Galley, and Citadel) into a single binary to provide simplified installation,
    operation, and monitoring, as well as seamless upgrades between various Istio
    versions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: istiod 是 Istio 控制平面组件之一，提供服务发现、配置和证书管理。在 Istio 的早期版本中，控制平面由名为 Galley、Pilot、Mixer、Citadel、WebHook
    Injector 等组件组成。istiod 将这些组件（Pilot、Galley 和 Citadel）的功能统一到一个二进制文件中，从而提供简化的安装、操作和监控，并实现了不同
    Istio 版本之间的无缝升级。
- en: 'Let’s look at the `istiod` Pod running in the `istio-system` namespace:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下运行在 `istio-system` 命名空间中的 `istiod` Pod：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You must have noticed that the Pod itself is running `pilot-discovery` and
    is based on the following image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到，Pod 本身正在运行 `pilot-discovery` 并且基于以下镜像：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You must have also noticed that the image for the `istiod` Pod is different
    to the istio-proxy image inserted as a sidecar. The istiod image is based on `pilot-discovery`,
    whereas the sidecar is based on `proxyv2`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定也注意到，`istiod` Pod 的镜像与作为 sidecar 插入的 istio-proxy 镜像不同。istiod 镜像基于 `pilot-discovery`，而
    sidecar 则基于 `proxyv2`。
- en: 'The following command shows that the sidecar container is created from `proxyv2`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示 sidecar 容器是由 `proxyv2` 创建的：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we know that the `istiod` Pod is based on `pilot-discovery`, let’s
    look at some of the functions performed by istiod.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 `istiod` Pod 是基于 `pilot-discovery`，让我们来看一下 istiod 执行的一些功能。
- en: Configuration watch
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置监视
- en: istiod watches Istio **Custom Resource Definitions** (**CRDs**) and any other
    Istio-related configuration being sent to the Kubernetes API server. Any such
    configuration is then processed and distributed internally to various subcomponents
    of istiod. You interact with Istio Service Mesh via the Kubernetes API server,
    but all interactions with Kubernetes API server are not necessarily destined for
    the Service Mesh.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: istiod 监视 Istio **自定义资源定义**（**CRDs**）以及发送到 Kubernetes API 服务器的任何其他与 Istio 相关的配置。任何此类配置都将被处理并在内部分发到
    istiod 的各个子组件。你通过 Kubernetes API 服务器与 Istio 服务网格进行交互，但并非所有与 Kubernetes API 服务器的交互都是为了服务网格而进行的。
- en: istiod keeps an eye on various config resources, typically Kubernetes API server
    resources identified by certain characteristics such as labels, namespaces, annotations,
    and so on. These configuration updates are then intercepted, collected, and transformed
    into Istio-specific formats and distributed via the **Mesh Configuration Protocol**
    (**MCP**) to other components of istiod. istiod also implements configuration
    forwarding, which we will be looking at in later chapters when we do a multi-cluster
    installation of Istio. For now, let’s just say that istiod can also pass configurations
    to another istiod instance over MCP in both pull and push modes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: istiod 监视各种配置资源，通常是由 Kubernetes API 服务器识别的资源，通过某些特征（如标签、命名空间、注解等）进行识别。然后，这些配置更新会被拦截、收集，并转换为
    Istio 特定格式，通过 **Mesh 配置协议**（**MCP**）分发给 istiod 的其他组件。istiod 还实现了配置转发，我们将在后续章节中介绍它，当我们进行
    Istio 的多集群安装时。现在，我们可以先说，istiod 也可以通过 MCP 在拉取和推送模式下，将配置传递给另一个 istiod 实例。
- en: API validation
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 验证
- en: 'istiod also adds an admission controller to enforce the validation of Istio
    resources before they are accepted by the Kubernetes API server. In the previous
    chapter, we saw two admission controllers: the **mutating webhook** and the **validation
    webhook**.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: istiod 还添加了一个准入控制器，以确保在 Istio 资源被 Kubernetes API 服务器接受之前，进行验证。在上一章中，我们看到两个准入控制器：**mutating
    webhook** 和 **validation webhook**。
- en: The mutating webhook is responsible for augmenting the API calls for resources
    such as deployments by adding configuration for Istio sidecar injection. Similarly,
    the validation webhook auto registers itself with the Kubernetes API server to
    be called for each incoming call for Istio CRDs. When such calls to add/update/delete
    Istio CRDs arrive at the Kubernetes API server, they are passed to the validation
    webhook, which then validates the incoming request and, based on the outcome of
    the validation, the API calls are accepted or rejected.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: mutating webhook 负责增强诸如部署等资源的 API 调用，通过为 Istio sidecar 注入添加配置。同样，validation
    webhook 会自动向 Kubernetes API 服务器注册自己，以便在每次调用 Istio CRD 时被触发。当添加/更新/删除 Istio CRD
    的请求到达 Kubernetes API 服务器时，它们会被传递给 validation webhook，后者会验证传入的请求，并根据验证结果决定是否接受或拒绝该
    API 调用。
- en: Istio Certificate Authority
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio 证书颁发机构
- en: Istio provides comprehensive security for all communication in the mesh. All
    Pods are assigned an identity through the Istio PKI with x.509 key/cert in **Spifee
    Verifiable Identity Document** (**SVID**) format. The Istio **Certificate Authority**
    (**CA**) is responsible for signing requests from node agents deployed along with
    istio-proxy. The Istio CA is built on top of Citadel and is responsible for approving
    and signing the **Certificate signature requests**(**CSRs**) sent by Istio node
    agents. The Istio CA also performs the rotation and revocation of certificates
    and keys. It offers pluggability of different CAs as well as the flexibility to
    use the Kubernetes CA.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 为网格中的所有通信提供全面的安全保障。所有 Pod 都通过 Istio PKI 分配身份，并且采用 x.509 证书/密钥，以 **Spiffe
    可验证身份文档**（**SVID**）格式进行表示。Istio **证书颁发机构**（**CA**）负责签署与 istio-proxy 一起部署的节点代理发送的请求。Istio
    CA 基于 Citadel 构建，负责批准并签署 Istio 节点代理发送的 **证书签名请求**（**CSRs**）。Istio CA 还执行证书和密钥的轮换和吊销工作。它支持不同
    CA 的插件化，以及使用 Kubernetes CA 的灵活性。
- en: 'Some of the other functions and components of the Istio control plane are as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 控制平面的一些其他功能和组件如下：
- en: '**Sidecar injection**: The Istio control plane also manages sidecar injection
    via mutating webhooks.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sidecar 注入**：Istio 控制平面还通过 mutating webhooks 管理 sidecar 注入。'
- en: '**Istio node agent**: Node agents are deployed along with Envoy and take care
    of communication with the Istio CA, providing the cert and keys to Envoy.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Istio 节点代理**：节点代理与 Envoy 一起部署，负责与 Istio CA 进行通信，向 Envoy 提供证书和密钥。'
- en: '**Identity directory and registry**: The Istio control plane manages a directory
    of identities for various types of workloads that will be used by the Istio CA
    to issue key/certs for requested identities.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份目录和注册表**：Istio 控制平面管理用于各种工作负载的身份目录，这些工作负载将由 Istio CA 用来为请求的身份颁发密钥/证书。'
- en: '**End-user context propagation**: Istio provides a secure mechanism to perform
    end user authentication on Ingress and then propagate the user context to other
    services and apps within the Service Mesh. The user context is propagated in JWT
    format, which helps to pass on user information to services within the mesh without
    needing to pass the end user credentials.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端用户上下文传播**：Istio 提供了一种安全机制，在 Ingress 上执行终端用户认证，然后将用户上下文传播到服务网格内的其他服务和应用程序。用户上下文以
    JWT 格式传播，这有助于在不需要传递终端用户凭证的情况下，将用户信息传递到网格中的服务。'
- en: istiod is a key control plane component performing many key functions of the
    control plane, but is not the only control plane component worth remembering.
    In the next section, we will examine other components that are not part of istiod
    but still important components of the Istio control plane.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: istiod 是一个关键的控制平面组件，执行控制平面中的许多重要功能，但它并不是唯一值得记住的控制平面组件。在下一节中，我们将探讨其他不属于 istiod
    但仍然是 Istio 控制平面重要组成部分的组件。
- en: The Istio operator and istioctl
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Istio 操作员和 istioctl
- en: The Istio operator and istioctl are both control plane components and are optional
    to install. Both provide administrative functions to install and configure components
    of the control and data planes. You have used istioctl quite a lot in the previous
    chapter as a command-line tool to interact with the Istio control plane to pass
    on instructions. The instructions can be to fetch information and create, update,
    or delete a configuration related to the workings of the Istio data plane. The
    Istio operator and istioctl essentially perform the same functions with the exception
    that istioctl is explicitly invoked to make a change, whereas the Istio operator
    functions per the *operator* framework/pattern of Kubernetes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 操作员和 istioctl 都是控制平面组件，并且是可选安装的。它们都提供管理功能，用于安装和配置控制平面和数据平面的组件。在上一章中，您已经使用了不少
    istioctl 作为命令行工具与 Istio 控制平面进行交互并传达指令。这些指令可以用于获取信息、创建、更新或删除与 Istio 数据平面工作相关的配置。Istio
    操作员和 istioctl 本质上执行相同的功能，不同之处在于 istioctl 是显式调用以进行更改，而 Istio 操作员则按照 Kubernetes
    的 *operator* 框架/模式运行。
- en: 'We will not be using the Istio operator, but if you want, you can install it
    using the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用 Istio 操作员，但如果您愿意，您可以使用以下命令来安装它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The two main components of the Istio operator are the customer resource called
    **IstioOperator**, represented by high-level APIs, and a controller that has logic
    to transform the high-level API into low-level Kubernetes actions. The IstioOperator
    CRD wraps a second component called **IstioOperatorSpec**, a status field, and
    some additional metadata.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 操作员的两个主要组件是名为 **IstioOperator** 的客户资源，表示为高级 API，以及一个控制器，它具有将高级 API 转换为低级
    Kubernetes 操作的逻辑。IstioOperator CRD 封装了第二个组件 **IstioOperatorSpec**、一个状态字段以及一些附加元数据。
- en: 'You can use the following command to find details of the IstioOperator **Custom**
    **Resource** (**CR**):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令来查找 IstioOperator **自定义** **资源**（**CR**）的详细信息：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can find the output of the command here: [https://github.com/PacktPublishing/Bootstrap-Service-Mesh-Implementations-with-Istio/blob/main/Output%20references/Chapter%203/IstioOperator%20CR.docx](https://github.com/PacktPublishing/Bootstrap-Service-Mesh-Implementations-with-Istio/blob/main/Output%20references/Chapter%203/IstioOperator%20CR.docx)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到命令的输出：[https://github.com/PacktPublishing/Bootstrap-Service-Mesh-Implementations-with-Istio/blob/main/Output%20references/Chapter%203/IstioOperator%20CR.docx](https://github.com/PacktPublishing/Bootstrap-Service-Mesh-Implementations-with-Istio/blob/main/Output%20references/Chapter%203/IstioOperator%20CR.docx)
- en: As you can see in the output, the API is structured in line with the control
    plane components around the base Kubernetes resources, pilot, Ingress and Egress
    gateways, and finally, the optional third-party add-ons.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中所见，API 的结构与围绕基础 Kubernetes 资源、Pilot、Ingress 和 Egress 网关以及最终可选的第三方插件的控制平面组件一致。
- en: '![Figure 3.2 – The Istio operator](img/B17989_03_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – Istio 操作员](img/B17989_03_02.jpg)'
- en: Figure 3.2 – The Istio operator
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Istio 操作员
- en: 'The preceding diagram describes the operations of the IstioOperator, while
    the following describes the operations of istioctl:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图表描述了 IstioOperator 的操作，下面的内容描述了 istioctl 的操作：
- en: '![Figure 3.3 – istioctl](img/B17989_03_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – istioctl](img/B17989_03_03.jpg)'
- en: Figure 3.3 – istioctl
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – istioctl
- en: istioctl and the operator are very similar to each other except when in the
    *Actuation* phase. istioctl is a user-run command that takes an IstioOperator
    CR as input, while the controller runs whenever the in-cluster IstioOperator CR
    changes, but the remaining components are similar, if not the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: istioctl 和操作员非常相似，除了在 *执行* 阶段。istioctl 是用户运行的命令，它以 IstioOperator CR 作为输入，而控制器则在集群内的
    IstioOperator CR 更改时运行，但其余组件相似，甚至是相同的。
- en: 'The following is a brief summary of the various components of the Istio operator
    and istioctl:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Istio 操作员和 istioctl 各个组件的简要总结：
- en: '**Actuation**: Triggers the validator component in response to an event, for
    example, a request for a CR update. For istioctl, the actuation logic is triggered
    by the operator invoking the istioctl CLI, which is written in Go using Cobra,
    a library for creating powerful CLI applications.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：在事件发生时触发验证器组件，例如 CR 更新请求。对于 istioctl，执行逻辑通过操作员调用 istioctl CLI 来触发，istioctl
    CLI 是用 Go 编写的，使用 Cobra 库来创建强大的 CLI 应用程序。'
- en: '**Validator**: Verifies the input (the IstioOperator CR) against the original
    schema of the CR.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证器**：验证输入（IstioOperator CR）是否符合原始 CR 的模式。'
- en: '**Config generator**: In this phase, a full-blown configuration is created.
    The configuration includes parameters and values provided in the original event,
    as well as parameters that were omitted in the original event. The configuration
    contains the omitted parameters, along with their respective default values.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置生成器**：在此阶段，会创建完整的配置。配置包括原始事件中提供的参数和数值，以及原始事件中省略的参数。配置中包含了省略的参数及其各自的默认值。'
- en: '**Translator and renderer**: The translator maps IstioOperator’s Kubernetes
    resources specs to Kubernetes resources, while the renderer produces the output
    manifest after applying all configurations.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**翻译器和渲染器**：翻译器将 IstioOperator 的 Kubernetes 资源规格映射到 Kubernetes 资源，而渲染器则在应用所有配置后生成输出清单。'
- en: '**Resource Manager**: This is responsible for managing the resources in the
    cluster. It caches the recent state of resources in a built-in cache, which is
    then compared with the output manifests, and every time there is a deviation or
    inconsistency between the state of Kubernetes objects (namespaces, CRDs, ServiceAccounts,
    ClusterRoles, ClusterRoleBindings, MutatingWebhookConfigurations, ValidatingWebhookConfigurations,
    Services, Deployments, or ConfigMaps) and the output manifest, then the Resource
    Manager updates them as per the manifest.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器**：该组件负责管理集群中的资源。它将资源的最新状态缓存到内置缓存中，然后与输出清单进行比较，每当 Kubernetes 对象（命名空间、CRDs、ServiceAccounts、ClusterRoles、ClusterRoleBindings、MutatingWebhookConfigurations、ValidatingWebhookConfigurations、Services、Deployments
    或 ConfigMaps）的状态与输出清单之间存在偏差或不一致时，资源管理器将根据清单更新它们。'
- en: Steps to uninstall IstioOperator
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载 IstioOperator 的步骤
- en: 'As we will not be using IstioOperator for the rest of book, I suggest uninstalling
    it using the following commands:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们接下来不再使用 IstioOperator，建议使用以下命令卸载它：
- en: '`$ istioctl` `operator remove`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ istioctl` `operator remove`'
- en: '`Removing` `Istio operator...`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`正在删除` `Istio operator...`'
- en: '`Removed Deployment:istio-operator:istio-operator.`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`已移除 Deployment:istio-operator:istio-operator。`'
- en: '`Removed Service:istio-operator:istio-operator.`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`已移除 Service:istio-operator:istio-operator。`'
- en: '`Removed ServiceAccount:istio-operator:istio-operator.`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`已移除 ServiceAccount:istio-operator:istio-operator。`'
- en: '`Removed ClusterRole::istio-operator.`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`已移除 ClusterRole::istio-operator。`'
- en: '`Removed ClusterRoleBinding::istio-operator.`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`已移除 ClusterRoleBinding::istio-operator。`'
- en: `Removal complete`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: `删除完成`
- en: '`$ kubectl delete` `ns istio-operator`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete` `ns istio-operator`'
- en: '`namespace "``istio-operator" deleted`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`命名空间 "istio-operator" 已删除`'
- en: We briefly looked at the istio-proxy in the previous chapter. In the next section,
    we will examine the Istio agent, which is one of the containers deployed in the
    istio-proxy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章简要了解了 istio-proxy。接下来，我们将查看 Istio 代理，它是部署在 istio-proxy 中的容器之一。
- en: Istio agent
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Istio 代理
- en: 'The Istio agent (also called `pilot-agent`) is part of the control plane deployed
    in every istio-proxy to help connect to the mesh by securely passing configuration
    and secrets to the Envoy proxies. Let’s look at the istio-agent in one of the
    microservices of `bookinfo` by listing all running process in the istio-proxy
    sidecar of `details-v1`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 代理（也叫 `pilot-agent`）是控制平面的一部分，部署在每个 istio-proxy 中，帮助通过安全地将配置和机密传递给 Envoy
    代理来连接到服务网格。让我们通过列出 `details-v1` 的 istio-proxy sidecar 中所有运行的进程，来查看 `bookinfo`
    中的一个微服务的 istio-agent：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You must have noticed that pilot-agent is also running within the sidecar. pilot-agent
    not only bootstraps the Envoy proxy but also generates key and certificate pairs
    for Envoy proxies to establish the identity of Envoy proxies during mesh communication.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到，pilot-agent 也在侧车中运行。pilot-agent 不仅初始化了 Envoy 代理，还为 Envoy 代理生成密钥和证书对，以便在网格通信中建立
    Envoy 代理的身份。
- en: Before we talk about the role of the Istio agent in certificate generation,
    let’s just briefly talk about the Istio **Secret Discovery Service** (**SDS**).
    The SDS simplifies certificate management and was originally created by the Envoy
    project to provide a flexible API to deliver secrets/certificates to the Envoy
    proxy. The components needing the certificates are called SDS clients, and the
    component generating the certificates is called the SDS server. In the Istio data
    plane, the Envoy proxy acts as an SDS client and the Istio agent acts as the SDS
    server. The communication between the SDS client and SDS server happens using
    the SDS API specifications, mostly implemented over gRPC.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 Istio 代理在证书生成中的作用之前，让我们简单谈一下 Istio **秘密发现服务**（**SDS**）。SDS 简化了证书管理，并最初由
    Envoy 项目创建，目的是提供一个灵活的 API，将秘密/证书传递给 Envoy 代理。需要证书的组件称为 SDS 客户端，生成证书的组件称为 SDS 服务器。在
    Istio 数据平面中，Envoy 代理充当 SDS 客户端，Istio 代理充当 SDS 服务器。SDS 客户端和 SDS 服务器之间的通信是通过 SDS
    API 规范进行的，通常通过 gRPC 实现。
- en: 'The following steps, also illustrated in *Figure 3**.4*, are performed between
    the Istio agent, Envoy, and istiod to generate the certificate:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下列步骤，如 *图 3.4* 所示，在 Istio 代理、Envoy 和 istiod 之间执行，以生成证书：
- en: During sidecar injection, istiod passes information about the SDS, including
    the location of the SDS server to the Envoy proxy.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧车注入过程中，istiod 会将关于 SDS 的信息传递给 Envoy 代理，包括 SDS 服务器的位置。
- en: Envoy sends a request to pilot-agent (SDS server) for certificate generation
    over a **Unix domain socket** (**UDS**) via SDS protocols. pilot-agent generates
    a certificate signing request.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Envoy 通过 SDS 协议向 pilot-agent（SDS 服务器）发送请求，要求生成证书，使用 **Unix 域套接字**（**UDS**）进行通信。pilot-agent
    生成一个证书签名请求。
- en: pilot-agent then communicates with istiod and provides its identity along with
    the certificate signing request.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，pilot-agent 与 istiod 进行通信，提供其身份信息以及证书签名请求。
- en: istiod authenticates pilot-agent and if all is OK, signs the certificate.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: istiod 对 pilot-agent 进行身份验证，如果一切正常，便签署证书。
- en: pilot-agent passes the certificate and keys to the Envoy proxy over UDS.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pilot-agent 通过 UDS 将证书和密钥传递给 Envoy 代理。
- en: '![Figure 3.4 – Certificate generation for Envoy communication](img/B17989_03_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Envoy 通信的证书生成](img/B17989_03_04.jpg)'
- en: Figure 3.4 – Certificate generation for Envoy communication
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Envoy 通信的证书生成
- en: In this and prior sections, we covered the Istio control plane. Now it’s time
    to go through various options to deploy the Istio control plane.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节及前面的章节中，我们讨论了 Istio 控制平面。现在是时候介绍部署 Istio 控制平面的各种选项了。
- en: Deployment models for the Istio control plane
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio 控制平面的部署模型
- en: In the previous chapters, we installed Istio on minikube, which is one local
    cluster meant for development purposes on your local workstation. When deploying
    Istio in enterprise environments, the deployment will be not on minikube but rather
    on an enterprise-grade Kubernetes cluster. The Service Mesh might run on one Kubernetes
    cluster or be spread across multiple Kubernetes clusters. It might also be the
    case that all services will be on one network or may be on different networks
    with no direct connectivity between them. Every organization will have a different
    network and infrastructure disposition, and the deployment model for Istio will
    change accordingly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们在 minikube 上安装了 Istio，minikube 是一个本地集群，主要用于开发目的，运行在本地工作站上。当在企业环境中部署
    Istio 时，部署将不会在 minikube 上，而是在企业级的 Kubernetes 集群上。服务网格可能运行在一个 Kubernetes 集群上，或者分布在多个
    Kubernetes 集群之间。也可能所有服务都在一个网络中，或者位于不同的网络中，彼此之间没有直接连接。每个组织的网络和基础设施布局不同，Istio 的部署模式也会因此而有所不同。
- en: What is a cluster?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是集群？
- en: There are many definitions of a cluster depending on what context they are being
    referred to. In this section, when we say cluster, we are basically referring
    to a set of compute nodes hosting containerized applications interconnected with
    each other. You can also think of a cluster as a Kubernetes cluster.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 集群的定义有很多，具体取决于所处的上下文。在本节中，当我们提到集群时，基本上是指一组计算节点，这些节点托管着彼此互联的容器化应用程序。你也可以将集群视为
    Kubernetes 集群。
- en: We will be discussing various architecture options for Istio in *Chapter 8*,
    but for now, let’s just briefly go through various deployment models for the control
    plane.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第8章*讨论Istio的各种架构选项，但现在，让我们简要地回顾一下控制平面的各种部署模型。
- en: Single cluster with a local control plane
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单集群与本地控制平面
- en: All sidecar proxies across all namespaces in the cluster connect to the control
    plane deployed in the same cluster. Similarly, the control plane is watching,
    observing, and communicating with the Kubernetes API server and sidecars within
    the same cluster where it is deployed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中所有命名空间中的所有边车代理连接到部署在同一集群中的控制平面。类似地，控制平面正在观察、监控并与其部署所在集群中的Kubernetes API服务器和边车进行通信。
- en: '![Figure 3.5 – The data plane and control plane residing in the same Kubernetes
    cluster](img/B17989_03_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 数据平面和控制平面位于同一Kubernetes集群中](img/B17989_03_05.jpg)'
- en: Figure 3.5 – The data plane and control plane residing in the same Kubernetes
    cluster
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 数据平面和控制平面位于同一Kubernetes集群中
- en: The preceding illustration describes the deployment model we used in the previous
    chapter to deploy Istio. From the diagram, you can see that the Istio control
    plane and data plane both reside in the same Kubernetes cluster; in our case,
    it was minikube. istiod is installed in the `istio-system` namespace or any other
    namespace of your choosing. The data plane comprises various namespaces where
    applications are deployed along with istio-proxy sidecars.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述插图描述了我们在上一章中用于部署Istio的部署模型。从图中可以看出，Istio控制平面和数据平面都位于同一Kubernetes集群中；在我们的案例中，它是minikube。istiod安装在`istio-system`命名空间或您选择的其他命名空间中。数据平面由多个命名空间组成，应用程序与istio-proxy边车一同部署。
- en: Primary and remote cluster with a single control plane
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主集群和远程集群共享单一控制平面
- en: A Service Mesh cluster, where the data plane and control plane are deployed
    in the same Kubernetes cluster, is also called a *primary cluster*. A cluster
    where the control plane is not collocated with the data plane is called a *remote
    cluster*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据平面和控制平面部署在同一Kubernetes集群中的服务网格集群，也称为*主集群*。控制平面与数据平面不共存的集群称为*远程集群*。
- en: 'In this architecture, there is a primary cluster and a remote cluster both
    sharing a common control plane. With this model, additional configuration is required
    to provide interconnectivity between the control plane in the primary cluster
    and the data plane in the remote cluster. The connectivity between the remote
    cluster and primary cluster control plane can be achieved by adding an Ingress
    gateway to protect and route communication to the primary control plane. This
    is shown in the following diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种架构中，有一个主集群和一个远程集群，它们共享一个共同的控制平面。使用这种模型时，需要额外配置，以提供主集群中的控制平面和远程集群中的数据平面之间的互联。通过添加Ingress网关来保护并路由通信到主控制平面，可以实现远程集群与主集群控制平面之间的连接。这在以下图示中有所展示：
- en: '![Figure 3.6 – Uni-cluster control plane with data plane spread across multiple
    Kubernetes clusters](img/B17989_03_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 单集群控制平面，数据平面分布在多个Kubernetes集群中](img/B17989_03_06.jpg)'
- en: Figure 3.6 – Uni-cluster control plane with data plane spread across multiple
    Kubernetes clusters
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 单集群控制平面，数据平面分布在多个Kubernetes集群中
- en: 'The Istio control plane also needs to be configured to establish the following
    communications:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Istio控制平面还需要配置，以建立以下通信：
- en: Communication with the remote plane Kubernetes API server
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与远程平面Kubernetes API服务器通信
- en: Patch mutating webhooks into the remote plane to watch the namespaces configured
    for automated injection of istio-proxy
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将突变Webhook修补到远程平面，以监控配置为自动注入istio-proxy的命名空间
- en: Provide endpoints for CSR requests from Istio agents in the remote plane
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为来自远程平面Istio代理的CSR请求提供端点
- en: Single cluster with an external control plane
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单集群与外部控制平面
- en: 'In this configuration, instead of running a primary cluster with the control
    and data planes collocated on the same Kubernetes cluster, you can separate them
    from each other. This is done by deploying the control plane remotely on one Kubernetes
    cluster and having the data plane deployed on its own dedicated Kubernetes cluster.
    This deployment can be seen in the following diagram:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置中，您可以将控制平面与数据平面分开，而不是在同一个Kubernetes集群中同时运行控制平面和数据平面。这是通过将控制平面远程部署到一个Kubernetes集群中，并将数据平面部署到其自己的专用Kubernetes集群来实现的。这个部署可以通过以下图示来查看：
- en: '![Figure 3.7 – The control plane and data plane residing in separate Kubernetes
    clusters](img/B17989_03_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 控制平面和数据平面分别位于不同的Kubernetes集群中](img/B17989_03_07.jpg)'
- en: Figure 3.7 – The control plane and data plane residing in separate Kubernetes
    clusters
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 控制平面和数据平面分别位于不同的Kubernetes集群中
- en: For security, separation of concerns, and compliance requirements such as **Federal
    Information Processing Standards** (**FIPS**), we can be required to deploy the
    Istio control plane separately from the data plane. Separating the control plane
    from the data plane allows the enforcement of strict traffic and access policies
    for control plane traffic without impacting the traffic flow of the data plane.
    Also, in an enterprise environment, where you have teams who can provide control
    planes as a managed service to project teams, then this model of deploying the
    control plane is highly suitable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全性、关注点分离以及合规性要求（如**联邦信息处理标准**（**FIPS**）），我们可能需要将Istio控制平面与数据平面分开部署。将控制平面与数据平面分离，可以在不影响数据平面流量的情况下，严格执行控制平面流量的流量和访问策略。此外，在企业环境中，如果有团队可以将控制平面作为托管服务提供给项目团队，那么这种部署控制平面的模型非常适合。
- en: So far, the deployment models we have discussed reside over one or many Kubernetes
    clusters within a shared network. Where the network is not shared, the deployment
    model becomes more complex. We will go through some of those deployment models,
    along with the ones we covered in this chapter, with some hands-on exercises in
    *Chapter 10*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的部署模型都位于共享网络内的一个或多个Kubernetes集群中。当网络不共享时，部署模型变得更加复杂。我们将在*第10章*中通过一些动手练习，详细讨论这些部署模型以及本章中涉及的模型。
- en: In the next section, we will look at the Istio data plane and we will do that
    by understanding Envoy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过了解Envoy来研究Istio数据平面。
- en: Exploring Envoy, the Istio data plane
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Envoy，Istio数据平面
- en: Envoy is the key component of the Istio data plane. To understand the Istio
    data plane, it is important to understand and know about Envoy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy是Istio数据平面的关键组件。要理解Istio数据平面，了解和认识Envoy是非常重要的。
- en: Envoy is an open source project and CNCF graduate. You can find more details
    about Envoy as a CNCF project at [https://www.cncf.io/projects/Envoy/](https://www.cncf.io/projects/Envoy/).
    In this section, we will learn about Envoy and why it was selected as the service
    proxy for the Istio data plane.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy是一个开源项目，并且是CNCF的毕业项目。你可以在[https://www.cncf.io/projects/Envoy/](https://www.cncf.io/projects/Envoy/)找到更多关于Envoy作为CNCF项目的详细信息。在本节中，我们将学习Envoy，并了解为什么它被选为Istio数据平面的服务代理。
- en: What is Envoy?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Envoy？
- en: Envoy is a lightweight, highly performant Layer 7 and Layer 4 proxy with an
    easy-to-use configuration system, making it highly configurable and suitable for
    serving as a standalone edge-proxy in the API gateway architecture pattern, as
    well as running as a sidecar in the Service Mesh architecture pattern. In both
    architecture patterns, Envoy runs in its own single process alongside the applications/services,
    which makes it easier to upgrade and manage and also allows Envoy to be deployed
    and upgraded transparently across the entire infrastructure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy是一个轻量级、高性能的第7层和第4层代理，具有易于使用的配置系统，使其高度可配置，适合作为API网关架构模式中的独立边缘代理，也可以作为Service
    Mesh架构模式中的sidecar运行。在这两种架构模式中，Envoy以单独的进程形式与应用程序/服务并行运行，这使得它更容易升级和管理，同时也使得Envoy可以在整个基础设施中透明地进行部署和升级。
- en: To understand Envoy, let’s look at the following three distinctive features
    that make Envoy different from other proxies available today.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Envoy，我们来看一下以下三个使Envoy与今天市面上其他代理不同的特点。
- en: Threading model
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程模型
- en: One of the highlights of the Envoy architecture is its unique threading model.
    In Envoy, the majority of the threads run asynchronously without blocking each
    other. Instead of having one thread per connection, multiple connections share
    the same worker thread running in non-blocking order. The threading model helps
    to process requests asynchronously but in a non-blocking manner, resulting in
    very high throughput.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy架构的亮点之一是其独特的线程模型。在Envoy中，大多数线程异步运行，彼此不阻塞。与其为每个连接分配一个线程，不如让多个连接共享同一个工作线程，并以非阻塞的顺序运行。这个线程模型帮助异步处理请求，但以非阻塞的方式，从而实现非常高的吞吐量。
- en: 'Broadly, Envoy has three types of threads:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，Envoy有三种类型的线程：
- en: '**Main thread**: This owns the startup and shutdown of Envoy and xDS (more
    on xDS in the next section), API handling, runtime, and general process management.
    The main thread coordinates all management functionality in general, which does
    not require too much CPU. Therefore, the Envoy logic related to general management
    is single-threaded, making the code base simpler to write and manage.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主线程**：负责 Envoy 和 xDS 的启动与关闭（更多关于 xDS 的内容将在下一节介绍），API 处理、运行时管理和一般的进程管理。主线程协调所有管理功能，通常不需要过多的
    CPU 资源。因此，与一般管理相关的 Envoy 逻辑是单线程的，使得代码库更容易编写和管理。'
- en: '**Worker thread**: Generally, you run a worker thread per CPU core or per hardware
    thread if the CPU is hyper-threaded. The worker threads open one or more network
    locations (ports, sockets, etc) to which downstream systems can connect; this
    function of Envoy is called *listening*. Each worker thread runs a non-blocking
    event loop to perform listening, filtering, and forwarding.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作线程**：通常，每个 CPU 核心或每个硬件线程（如果 CPU 支持超线程）运行一个工作线程。工作线程打开一个或多个网络位置（端口、套接字等），以供下游系统连接；Envoy
    的这个功能称为 *监听*。每个工作线程运行一个非阻塞的事件循环，用于执行监听、过滤和转发操作。'
- en: '**File flusher thread**: This thread takes care of writing to files in a non-blocking
    fashion.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件刷新线程**：该线程负责以非阻塞的方式将数据写入文件。'
- en: Architecture
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构
- en: Another highlight of the Envoy architecture is its filter architecture. Envoy
    is also an L3/L4 network proxy. It features a pluggable filter chain to write
    filters to perform different TCP/UDP tasks. A **filter chain** is basically a
    set of steps where the output from one step is fed into the input of the second
    step, and so on, just as with pipes in Linux. You can construct logic and behavior
    by stacking your desired filters to form a filter chain. There are many filters
    available out of the box to support tasks, such as raw TCP proxy, UDP proxy, HTTP
    proxy, and TLS client cert authentication. Envoy also supports an additional HTTP
    L7 filter layer. Through filters, we can perform different tasks, such as buffering,
    rate limiting, routing, forwarding, and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 架构的另一个亮点是其过滤器架构。Envoy 也是一个 L3/L4 网络代理，具有可插拔的过滤器链，可以编写过滤器来执行不同的 TCP/UDP
    任务。**过滤器链** 本质上是一组步骤，每个步骤的输出作为输入传递到下一个步骤，就像 Linux 中的管道一样。你可以通过堆叠所需的过滤器来构建逻辑和行为，形成一个过滤器链。Envoy
    提供了许多开箱即用的过滤器来支持任务，如原始 TCP 代理、UDP 代理、HTTP 代理和 TLS 客户端证书认证。Envoy 还支持额外的 HTTP L7
    过滤器层。通过过滤器，我们可以执行不同的任务，如缓冲、速率限制、路由、转发等。
- en: Envoy supports both HTTP 1.1 and HTTP 2 and can operate as a transparent proxy
    in both HTTP protocols. This is particularly useful when you have legacy applications
    that support HTTP 1.1, but when you deploy them alongside Envoy proxy, you can
    bridge the transformation – meaning the application can communicate over HTTP
    1.1 with Envoy, which then uses HTTP 2 to communicate with others. Envoy supports
    a comprehensive routing subsystem that allows a very flexible routing and redirection
    functionality, making it suitable for building Ingress/Egress API gateways as
    well as being deployed as a proxy in the sidecar pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 支持 HTTP 1.1 和 HTTP 2，并且能够在这两种 HTTP 协议中作为透明代理运行。当你有支持 HTTP 1.1 的旧版应用程序时，这一点尤其有用；你可以将其与
    Envoy 代理一起部署，从而实现协议转换——也就是说，应用程序可以与 Envoy 使用 HTTP 1.1 通信，而 Envoy 会使用 HTTP 2 与其他系统通信。Envoy
    支持一个全面的路由子系统，提供灵活的路由和重定向功能，适用于构建 Ingress/Egress API 网关，也可以作为侧车模式下的代理部署。
- en: Envoy also supports modern protocols such as gRPC. **gRPC** is an open source
    remote procedure call framework that can run anywhere. It is widely used for service-to-service
    communication and is very performant and easy to use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 还支持现代协议，如 gRPC。**gRPC** 是一个开源的远程过程调用框架，可以在任何地方运行。它广泛用于服务间通信，性能优越且易于使用。
- en: Configuration
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'The other highlight of Envoy is how it can be configured. We can configure
    Envoy using static configuration files that describe the services and how to communicate
    with them. For advanced scenarios where statically configuring Envoy would be
    impractical, Envoy supports dynamic configuration and can automatically reload
    configuration at runtime without needing a restart. A set of discovery services
    called xDS can be used to dynamically configure Envoy through the network and
    provide Envoy information about hosts, clusters HTTP routing, listening sockets,
    and cryptographic material. This makes it possible to write different kind of
    control planes for Envoy. The control plane basically implements the specification
    of xDS API and keeps up-to-date information of various resources and information
    required to be fetched dynamically by Envoy via xDS APIs. There are many open
    source control plane implementations for Envoy; a couple are linked as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 的另一个亮点是它的配置方式。我们可以使用静态配置文件来配置 Envoy，这些文件描述了服务及其通信方式。在一些静态配置 Envoy 不切实际的高级场景下，Envoy
    支持动态配置，并且能够在运行时自动重新加载配置，无需重启。通过名为 xDS 的一组发现服务，可以通过网络动态配置 Envoy，并提供有关主机、集群、HTTP
    路由、监听套接字和加密材料的 Envoy 信息。这使得为 Envoy 编写不同类型的控制平面成为可能。控制平面基本上实现了 xDS API 的规范，并保持各种资源和信息的最新状态，供
    Envoy 通过 xDS APIs 动态获取。对于 Envoy，有许多开源的控制平面实现，以下是其中几个：
- en: '[https://github.com/envoyproxy/go-control-plane](https://github.com/envoyproxy/go-control-plane)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/envoyproxy/go-control-plane](https://github.com/envoyproxy/go-control-plane)'
- en: '[https://github.com/envoyproxy/java-control-plane](https://github.com/envoyproxy/java-control-plane)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/envoyproxy/java-control-plane](https://github.com/envoyproxy/java-control-plane)'
- en: Various Service Mesh implementations such as Istio, Kuma, Gloo, and so on.,
    which use Envoy as a sidecar, implement xDS APIs to provide configuration information
    to Envoy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 各种服务网格实现，如 Istio、Kuma、Gloo 等，它们将 Envoy 作为 sidecar，使用 xDS API 为 Envoy 提供配置信息。
- en: 'Envoy also supports the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 还支持以下内容：
- en: '**Automatic retries**: Envoy supports the retrying of requests any number of
    times or under a retry budget. The request can be configured to be retried for
    certain retry conditions depending on application requirement. If you want to
    read further about retry, head to https://www.abhinavpandey.dev/blog/retry-pattern.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重试**：Envoy 支持对请求进行任意次数的重试，或者在重试预算内进行重试。根据应用需求，可以为请求配置特定的重试条件。如果你想进一步了解重试机制，可以访问
    [https://www.abhinavpandey.dev/blog/retry-pattern](https://www.abhinavpandey.dev/blog/retry-pattern)。'
- en: '**Circuit breaking**: Circuit breaking is important for microservices architecture.
    Envoy provides circuit breaking at network level, so as to protect upstream systems
    across all HTTP request executions. Envoy provides various circuit breaking limits
    based on configurations such as maximum number of connections, maximum number
    of pending requests, maximum request, maximum active retries, and maximum concurrent
    connection pools supported by upstream systems. More details about circuit breaker
    pattern are available at https://microservices.io/patterns/reliability/circuit-breaker.html.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：断路器对于微服务架构至关重要。Envoy 在网络层面提供断路器功能，从而保护上游系统，确保所有 HTTP 请求执行的安全性。Envoy
    提供多种基于配置的断路器限制，如最大连接数、最大待处理请求数、最大请求数、最大活动重试次数和上游系统支持的最大并发连接池等。有关断路器模式的更多详情，请访问
    [https://microservices.io/patterns/reliability/circuit-breaker.html](https://microservices.io/patterns/reliability/circuit-breaker.html)。'
- en: '**Global rate limiting**: Envoy supports global rate limiting to control downstream
    systems from overwhelming upstream systems. The rate limiting can be performed
    at the network level as well at HTTP request level.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局速率限制**：Envoy 支持全局速率限制，以防止下游系统对上游系统造成过载。速率限制可以在网络层面或 HTTP 请求层面执行。'
- en: '**Traffic mirroring**: Envoy supports the shadowing of traffic from one cluster
    to another. This is very useful for testing as well as a myriad of other use cases,
    such as machine learning. An example of traffic mirroring at network level is
    AWS VPC, which provides options to mirror all traffic to VPC. You can read about
    AWS traffic mirroring at [https://docs.aws.amazon.com/vpc/latest/mirroring/what-is-traffic-mirroring.html](https://docs.aws.amazon.com/vpc/latest/mirroring/what-is-traffic-mirroring.html).'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量镜像**：Envoy 支持将流量从一个集群镜像到另一个集群。这在测试以及众多其他应用场景中非常有用，比如机器学习。一个网络层面的流量镜像示例是
    AWS VPC，它提供将所有流量镜像到 VPC 的选项。你可以阅读有关 AWS 流量镜像的内容，链接地址是 [https://docs.aws.amazon.com/vpc/latest/mirroring/what-is-traffic-mirroring.html](https://docs.aws.amazon.com/vpc/latest/mirroring/what-is-traffic-mirroring.html)。'
- en: '**Outlier detection**: Envoy supports dynamically determining unhealthy upstream
    systems and removing them from the healthy load-balancing set.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常检测**：Envoy支持动态检测不健康的上游系统，并将其从健康的负载均衡集中过滤掉。'
- en: '**Request hedging**: Envoy supports request hedging to deal with tail latency
    by issuing requests to multiple upstream systems and returning the most appropriate
    response to the downstream system. You can read more about request hedging at
    https://medium.com/star-gazers/improving-tail-latency-with-request-hedging-700c77cabeda.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求预处理**：Envoy支持请求预处理，以通过向多个上游系统发出请求并将最合适的响应返回给下游系统来应对尾延迟。你可以在[https://medium.com/star-gazers/improving-tail-latency-with-request-hedging-700c77cabeda](https://medium.com/star-gazers/improving-tail-latency-with-request-hedging-700c77cabeda)了解更多关于请求预处理的信息。'
- en: We discussed earlier how filter chain-based architecture is one of the differentiating
    features of Envoy. Now let’s read about those filters that make up the filter
    chain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，基于过滤器链的架构是Envoy的一个差异化特点。现在让我们了解一下构成过滤器链的那些过滤器。
- en: HTTP filters
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP过滤器
- en: HTTP is one of the most common application protocols, and it’s not unusual for
    the majority of a given workload to operate over HTTP. To support HTTP, Envoy
    ships with various HTTP-level filters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是最常见的应用协议之一，许多工作负载大多数情况下都通过HTTP进行操作。为了支持HTTP，Envoy附带了各种HTTP级别的过滤器。
- en: 'When configuring Envoy, you will have to deal primarily with the following
    configurations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Envoy时，您将主要处理以下配置：
- en: '**Envoy listeners**: These are the ports, sockets, and any other named network
    locations that downstream systems connect to'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Envoy监听器**：这些是下游系统连接的端口、套接字和任何其他命名的网络位置'
- en: '**Envoy routes**: These are Envoy configurations describing how the traffic
    should be routed to upstream systems'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Envoy路由**：这些是Envoy配置，描述流量如何路由到上游系统'
- en: '**Envoy clusters**: These are logical services formed of a group of similar
    upstream systems to which envoy routes or forwards the requests'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Envoy集群**：这些是由一组相似的上游系统组成的逻辑服务，Envoy将请求路由或转发到这些系统'
- en: '**Envoy endpoints**: These are individual upstream systems that serve requests'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Envoy端点**：这些是单个上游系统，用于处理请求'
- en: Important note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We will now be using Docker to play with Envoy. If you are running minikube,
    it will be a good idea to stop minikube now. If you don’t have Docker, you can
    install it by following the instructions at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Docker来操作Envoy。如果你正在运行minikube，最好现在停止minikube。如果你没有安装Docker，可以按照[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)上的说明进行安装。
- en: Armed with the knowledge we’ve obtained so far, let’s go and create some Envoy
    listeners.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 利用到目前为止获得的知识，我们来创建一些Envoy监听器。
- en: 'Download the `envoy` Docker image:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`envoy` Docker镜像：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you have pulled the Docker image, go ahead and run the following from
    the Git repository of this chapter:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拉取了Docker镜像，就可以从本章的Git仓库中运行以下命令：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding command, we are mounting the `envoy-config-1.yaml` file as
    a volume and passing it to the Envoy container with the `-c` option. We are also
    exposing `10000` to the localhost, which is mapped to port `10000` of the Envoy
    container.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们将`envoy-config-1.yaml`文件挂载为卷，并通过`-c`选项将其传递给Envoy容器。我们还将`10000`端口暴露给本地主机，并将其映射到Envoy容器的`10000`端口。
- en: 'Let’s now check the contents of `envoy-config-1.yaml`.The root of Envoy configuration
    is called bootstrap configuration. The first line describes whether it is in static
    or dynamic configuration. In this instance, we are proving a static configuration
    by specifying `static_resources`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下`envoy-config-1.yaml`的内容。Envoy配置的根节点称为引导配置。第一行描述它是静态配置还是动态配置。在这个实例中，我们通过指定`static_resources`来提供静态配置：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this instance, the configuration is very straightforward. We have defined
    a listener called `listener_http`, which is listening on `0.0.0.0` and port `10000`
    for incoming requests:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，配置非常简单。我们定义了一个名为`listener_http`的监听器，它在`0.0.0.0`和端口`10000`上监听传入的请求：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have not applied any filter specific to the listener, but we have applied
    a network filter called `HTTPConnectionManager,` or HCM:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有应用任何特定于监听器的过滤器，但我们应用了一个名为`HTTPConnectionManager`的网络过滤器，简称HCM：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The HCM filter is capable of translating raw bytes into HTTP-level messages.
    It can handle access logging, generate request IDs, manipulate headers, manage
    route tables, and collect statistics. Envoy also supports defining multiple HTTP-level
    filters within the HCM filter. We can define these HTTP filters under the `http_filters`
    field.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: HCM 过滤器能够将原始字节转换为 HTTP 级别的消息。它可以处理访问日志记录，生成请求 ID，操作头部，管理路由表，并收集统计信息。Envoy 还支持在
    HCM 过滤器内定义多个 HTTP 级别的过滤器。我们可以在 `http_filters` 字段下定义这些 HTTP 过滤器。
- en: 'In the following configuration, we have applied an HTTP router filter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下配置中，我们已经应用了一个 HTTP 路由器过滤器：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The router filter is responsible for performing routing tasks and is also the
    last filter to be applied in the HTTP filter chain. The router filter defines
    the routes under the `route_config` field. Within the route configuration, we
    can match the incoming requests by looking at metadata such as the URI, headers,
    and so on., and based on that, we define where the traffic should be routed or
    processed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器过滤器负责执行路由任务，也是在 HTTP 过滤器链中应用的最后一个过滤器。路由器过滤器在 `route_config` 字段下定义路由。在路由配置中，我们可以通过查看
    URI、头部等元数据来匹配传入请求，并基于此定义流量应路由或处理到哪里。
- en: A top-level element in routing configuration is a virtual host. Each virtual
    host has a name that’s used when emitting statistics (not used for routing) and
    a set of domains that get routed to it. In `envoy-config-1.yaml`, for all requests,
    irrespective of the host header, a hardcoded response is returned.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 路由配置中的顶层元素是虚拟主机。每个虚拟主机都有一个用于发出统计信息（不用于路由）的名称和一组域名，这些域名将被路由到它。在 `envoy-config-1.yaml`
    中，对于所有请求，无论主机头如何，都将返回硬编码的响应。
- en: 'To check the output of `envoy-config1.yaml`, you can use `curl` to test the
    response:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 `envoy-config1.yaml` 的输出，您可以使用 `curl` 来测试响应：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s manipulate the virtual host definition in `route_config` of `envoy-config1.yaml`
    with the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `envoy-config1.yaml` 的 `route_config` 中操作虚拟主机定义：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have defined two entries under `virtual_hosts`. If an incoming request’s
    host header is `acme.com`, then the routes defined in the `acme` virtual host
    will get processed. If the incoming request is destined for `acme.co`, then the
    routes defined under the `ace` virtual host will get processed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `virtual_hosts` 下定义了两个条目。如果传入请求的主机头是 `acme.com`，那么将处理在 `acme` 虚拟主机下定义的路由。如果传入请求是为
    `acme.co`，那么将处理在 `ace` 虚拟主机下定义的路由。
- en: 'Stop the Envoy container and restart it using the following commands:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 停止 Envoy 容器并使用以下命令重新启动它：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Check the output by passing different host headers to `curl`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将不同的主机头传递给 `curl` 来检查输出：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In most cases, you will not send a hardcoded response to HTTP requests. Realistically,
    you will want to route requests to real upstream services. To demonstrate this
    scenario, we will be making use of nginx to mock a dummy upstream service.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您不会对 HTTP 请求发送硬编码的响应。实际情况是，您希望将请求路由到真实的上游服务。为了演示这种情况，我们将使用 nginx 模拟一个虚拟的上游服务。
- en: 'Run the `nginx` Docker container using the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行 `nginx` Docker 容器：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Check the output from another terminal using `curl`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `curl` 从另一个终端检查输出：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will route the request being processed by Envoy to nginx by making use of
    cluster subsystem configurations. Whereas the `Listener` subsystem configurations
    handle downstream request processing and managing the downstream request life
    cycle, the cluster subsystem is responsible for selecting and connecting the upstream
    connection to an endpoint. In the cluster configuration, we define clusters and
    endpoints.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用集群子系统配置来将 Envoy 处理的请求路由到 nginx。而 `Listener` 子系统配置则处理下游请求处理和管理下游请求生命周期，集群子系统负责选择并连接到端点的上游连接。在集群配置中，我们定义集群和端点。
- en: 'Let’s edit `envoy-config-2.yaml` and modify the virtual host for `acme.co`
    with the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑 `envoy-config-2.yaml` 并修改 `acme.co` 的虚拟主机：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have removed the `direct_response` attribute and replaced it with the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已删除 `direct_response` 属性，并替换为以下内容：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have added cluster to the definition, which sits at the same level as the
    listener configuration. In the cluster definition, we defined the endpoints. In
    this case, the endpoint is the `nginx` Docker container running on port `80`.
    Please note that we are assuming that both Envoy and nginx are running on the
    same Docker network.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在定义中添加了集群，它与监听器配置处于同一层级。在集群定义中，我们定义了端点。在这种情况下，端点是运行在`80`端口上的`nginx` Docker容器。请注意，我们假设Envoy和nginx运行在同一个Docker网络上。
- en: 'You can find the IP of the `nginx` container by inspecting the container. The
    config is saved in `envoy-config-3.yaml`. Please update the `address` value with
    the correct IP address of the nginx container and run the Envoy container with
    the updated `envoy-config-3.yaml`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查容器来找到`nginx`容器的IP地址。配置保存在`envoy-config-3.yaml`文件中。请使用`nginx`容器的正确IP地址更新`address`值，并使用更新后的`envoy-config-3.yaml`运行Envoy容器：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Perform the `curl` test and you will notice the response for the request destined
    for `acme.co` is coming from the nginx container:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`curl`测试，你会注意到请求目标为`acme.co`的响应来自nginx容器：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Envoy provides several built-in HTTP filters. You can find the complete list
    of HTTP filters here: [https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/http_filters#config-http-filters.](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/http_filters#config-http-filters'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy提供了多个内置的HTTP过滤器。你可以在此查看完整的HTTP过滤器列表：[https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/http_filters#config-http-filters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/http_filters#config-http-filters)。
- en: )
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Listener filters
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听器过滤器
- en: We read previously that the listener subsystem handles the processing of incoming
    requests and the response to and from downstream systems. In addition to defining
    which addresses and ports Envoy *listens* on for incoming requests, we can optionally
    configure each listener with **listener filters**. The listener filters operate
    on newly accepted sockets and can stop or subsequently continue execution to further
    filters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，监听器子系统负责处理传入请求及与下游系统的响应。除了定义Envoy为接收传入请求而*监听*的地址和端口之外，我们还可以选择性地为每个监听器配置**监听器过滤器**。监听器过滤器作用于新接受的套接字，可以停止或继续执行进一步的过滤器。
- en: The order of the listener filters matters, as Envoy processes them sequentially
    right after the listener accepts a socket and before the connection is created.
    We use results from the listener filters to do filter matching to select appropriate
    network filter chains. For example, using a listener filter, we can determine
    the protocol type, and based on that, we might run specific network filters related
    to that protocol.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器过滤器的顺序很重要，因为Envoy会按顺序处理它们：在监听器接受一个套接字之后，连接创建之前。我们使用监听器过滤器的结果来进行过滤器匹配，从而选择合适的网络过滤器链。例如，通过使用监听器过滤器，我们可以确定协议类型，并基于此运行与该协议相关的特定网络过滤器。
- en: 'Let’s look at a simple example of listener filters in `envoy-config-4.yaml`
    under `listener_filters`. You will notice that we are using `envoy.filters.listener.http_inspector`
    of the following type: `type.googleapis.com/envoy.extensions.filters.listener.http_inspector.v3.HttpInspector`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的`envoy-config-4.yaml`中的监听器过滤器示例，位于`listener_filters`下。你会注意到，我们使用了以下类型的`envoy.filters.listener.http_inspector`：`type.googleapis.com/envoy.extensions.filters.listener.http_inspector.v3.HttpInspector`。
- en: 'The `HTTPInspector` listener filter can detect the underlying application protocol
    and whether it is `HTTP/1.1` or `HTTP/2`. You can read more about the `HTTPInspector`
    listener filter here: https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/listener_filters/http_inspector.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPInspector`监听器过滤器可以检测底层应用协议，并判断它是`HTTP/1.1`还是`HTTP/2`。你可以在此阅读有关`HTTPInspector`监听器过滤器的更多信息：https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/listener_filters/http_inspector。'
- en: In this example, we are using the listener filter to find the application protocol
    via the filter chain. Depending on which HTTP protocol is used by the downstream
    system, we then apply a variety of HTTP filters, as discussed in previous sections.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用监听器过滤器通过过滤器链找到应用协议。根据下游系统使用的HTTP协议，我们然后应用各种HTTP过滤器，如前面章节所讨论的。
- en: 'You can find this example in the `envoy-config-4.yaml` file. Go ahead and apply
    the configuration to Envoy, but do also remember to close down the Docker containers
    you created for previous examples:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`envoy-config-4.yaml`文件中找到这个示例。继续应用配置到Envoy，但也记得关闭你为之前的示例创建的Docker容器：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Perform `curl` with the `HTTP 1.1` and `HTTP 2` protocols, and you will see
    that Envoy is able to figure out the application protocol and route the request
    to the correct destination:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`命令并指定`HTTP 1.1`和`HTTP 2`协议，你会发现Envoy能够自动识别应用协议，并将请求路由到正确的目标：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As I mentioned earlier when introducing Envoy, it is highly configurable and
    can be configured dynamically. I believe the dynamic configurability of Envoy
    is what makes it so popular and makes it standout from the other proxies available
    today. Let’s look more into this next!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在介绍Envoy时提到的，它是高度可配置的，并且可以动态配置。我相信Envoy的动态可配置性正是它如此受欢迎并且使它在今天的其他代理中脱颖而出的原因。接下来我们将深入探讨这一点！
- en: Dynamic configuration via xDS APIs
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过xDS API进行动态配置
- en: So far, in our previous examples, we have been using static configuration by
    specifying `static_resources` at the beginning of the config file. Every time
    we wanted to change the config, we had to restart the Envoy container. To avoid
    this, we can make use of **dynamic configuration**, where Envoy dynamically reloads
    the configuration either by reading it from disk or over the network.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们之前的示例中，我们一直通过在配置文件开头指定`static_resources`来使用静态配置。每次我们想要更改配置时，都必须重新启动Envoy容器。为了避免这种情况，我们可以使用**动态配置**，让Envoy通过从磁盘或网络读取配置来动态重新加载配置。
- en: 'For dynamic configuration where Envoy fetches the configuration over the network,
    we need to make use of xDS APIs, which are basically a collection of various service
    discovery APIs related to various Envoy configurations. To make use of xDS APIs,
    you need to implement an application that can fetch the latest values of various
    Envoy configurations and then present them via gRPC # as per the xDS *protobuf*
    specifications (also called *protocol buffers*; you can find details about protocol
    buffers at [https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers),
    and more on gRPC at [https://grpc.io/](https://grpc.io/)). This application is
    commonly referred to as the control plane. The following diagram describes this
    concept.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '对于动态配置，Envoy通过网络获取配置，我们需要使用xDS API，xDS API基本上是一组与各种Envoy配置相关的服务发现API。为了使用xDS
    API，你需要实现一个应用程序，它能够获取各种Envoy配置的最新值，然后通过gRPC # 按照xDS *protobuf* 规范（也叫*协议缓冲区*；你可以在[https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers)找到关于协议缓冲区的详细信息，以及更多关于gRPC的信息在[https://grpc.io/](https://grpc.io/)）进行呈现。这个应用程序通常被称为控制平面。以下图表描述了这一概念。'
- en: '![Figure 3.8 – Control plane implementation of the xDS API](img/B17989_03_08.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – xDS API控制平面实现](img/B17989_03_08.jpg)'
- en: Figure 3.8 – Control plane implementation of the xDS API
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – xDS API控制平面实现
- en: 'Let’s see what the service discovery APIs provide:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看服务发现API提供了什么：
- en: '**Secret Discovery Service** (**SDS**): Provides secrets, such as certificates
    and private keys. This is required for MTLS, TLS, and so on.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密发现服务**（**SDS**）：提供密钥信息，如证书和私钥。这对于MTLS、TLS等是必需的。'
- en: '**Endpoint Discovery Service** (**EDS**): Provides details of members of the
    cluster.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点发现服务**（**EDS**）：提供集群成员的详细信息。'
- en: '**Cluster Discovery Service** (**CDS**): Provides cluster-related information
    including references to endpoints.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群发现服务**（**CDS**）：提供与集群相关的信息，包括对端点的引用。'
- en: '**Scope Route Discovery Service** (**SRDS**): Provides route information in
    chunks when the route confirmation is large.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围路由发现服务**（**SRDS**）：当路由确认较大时，按块提供路由信息。'
- en: '**Listener Discovery Service** (**LDS**): Provides details of listeners including
    the ports, addresses, and all associated filters.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监听器发现服务**（**LDS**）：提供关于监听器的详细信息，包括端口、地址以及所有相关的过滤器。'
- en: '**Extension Config Discovery Service** (**ECDS**): Provides extension configuration,
    such as HTTP filters, and so on. This API helps to fetch information independently
    from the listener.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展配置发现服务**（**ECDS**）：提供扩展配置，如HTTP过滤器等。此API帮助从监听器独立地获取信息。'
- en: '**Route Discovery Service** (**RDS**): Provides route information including
    a reference to the cluster.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由发现服务**（**RDS**）：提供包括对集群的引用在内的路由信息。'
- en: '**Virtual Host Discovery Service** (**VHDS**): Provides information about the
    virtual hosts .'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟主机发现服务**（**VHDS**）：提供有关虚拟主机的信息。'
- en: '**Runtime Discovery Service** (**RTDS**): This service provides information
    about the runtime. The runtime configuration specifies a virtual filesystem tree
    that contains reloadable configuration elements. This virtual filesystem can be
    realized via a series of local filesystems, static bootstrap configuration, RTDS,
    and admin console-derived overlays.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时发现服务**（**RTDS**）：该服务提供有关运行时的信息。运行时配置指定了一个虚拟文件系统树，包含可重载的配置元素。这个虚拟文件系统可以通过一系列本地文件系统、静态引导配置、RTDS
    和管理控制台派生的覆盖层来实现。'
- en: '**Aggregated Discovery Service** (**ADS**): ADS allows all APIs and their resources
    to be delivered via a single API interface. Through ADS APIs, you can sequence
    changes related to various resource types, including listeners, routes, and clusters,
    and deliver them via a single stream.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合发现服务**（**ADS**）：ADS 允许通过一个单一的 API 接口交付所有 API 及其资源。通过 ADS API，你可以对涉及多种资源类型的变化（包括监听器、路由和集群）进行排序，并通过单一流传送它们。'
- en: '**Delta Aggregated Discovery Service** (**DxDS**): With other APIs, every time
    there is a resource update, the API needs to include all resources in the API
    response. For example, every RDS update must contain every route. If we don’t
    include a route, Envoy will consider the route to have been deleted. Doing updates
    this way results in high bandwidth usage and computational costs, especially when
    a lot of resources are being sent over the network. Envoy supports a delta variant
    of xDS where we can include only resources we want to add/remove/update to improve
    on this scenario.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量聚合发现服务**（**DxDS**）：与其他 API 不同，每次资源更新时，API 需要将所有资源包含在响应中。例如，每次 RDS 更新时，必须包含所有路由。如果我们没有包含某个路由，Envoy
    会认为该路由已经被删除。采用这种方式更新会导致高带宽使用和计算成本，尤其是在大量资源通过网络传输时。Envoy 支持 xDS 的增量变体，在这种方式下，我们只需包含我们想要添加/删除/更新的资源，从而改善这一场景。'
- en: We covered Envoy filters in the previous section, but note that you are not
    limited to the built-in filters – you can easily build new filters, as we’ll see
    in the next section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中介绍了 Envoy 过滤器，但请注意，你并不局限于使用内建的过滤器——你可以轻松地构建新的过滤器，正如我们在下一节中将看到的那样。
- en: Extensibility
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: The filter architecture of Envoy makes it highly extensible; you can make use
    of various filters from the filter library as part of the filter chain. When you
    need some functionality not available in the filter library, then Envoy also provides
    the flexibility to write your own custom filter, which is then dynamically loaded
    by Envoy and can be used like any other filter. By default, Envoy filters are
    written in C++, but they can also be written using Lua script or any other programming
    language compiled into **WebAssembly** (**Wasm**).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 的过滤器架构使其具有高度可扩展性；你可以利用过滤器库中的各种过滤器作为过滤器链的一部分。当你需要某些过滤器库中没有的功能时，Envoy 还提供了编写自定义过滤器的灵活性，然后由
    Envoy 动态加载并像任何其他过滤器一样使用。默认情况下，Envoy 过滤器是用 C++ 编写的，但它们也可以使用 Lua 脚本或任何其他编译为 **WebAssembly**（**Wasm**）的编程语言编写。
- en: 'The following is a brief description of all three options currently available
    for writing Envoy filters:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是目前可用于编写 Envoy 过滤器的三种选项的简要描述：
- en: '**Native C++ API**: The most favorable option is to write native C++ filters
    and then package them with Envoy. But this option requires recompiling Envoy,
    which might not be ideal if you are not a big enterprise that wants to maintain
    its own version of Envoy.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生 C++ API**：最理想的选项是编写原生的 C++ 过滤器，然后将其与 Envoy 一起打包。但这种方式需要重新编译 Envoy，如果你不是一个大企业，且不打算维护自己版本的
    Envoy，这可能不是理想的选择。'
- en: '`envoy.filters.http.lua` that allows you to define a Lua script either inline
    or as an external file, and execute it during both the request and response flows.
    Lua is a free, fast, portable, and powerful scripting language that runs over
    LuaJIT, which is a just-in-time compiler for Lua. At runtime, Envoy creates a
    Lua environment for each worker thread and runs Lua scripts as coroutines. As
    the HTTP Lua filters are executed during request and response flows, you can do
    the following:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`envoy.filters.http.lua` 允许你定义一个 Lua 脚本，可以是内联的，也可以是外部文件，并在请求和响应流程中执行。Lua 是一种自由、快速、便携且强大的脚本语言，运行在
    LuaJIT 上，后者是一个为 Lua 提供即时编译的编译器。在运行时，Envoy 会为每个工作线程创建一个 Lua 环境，并以协程的形式运行 Lua 脚本。由于
    HTTP Lua 过滤器在请求和响应流程中执行，你可以做到以下几点：'
- en: Inspect and modify headers and trailers during request/response flows
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求/响应流程中检查和修改头部和尾部
- en: Inspect, block, or buffer the body during request/response flows
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求/响应流程中检查、拦截或缓冲主体
- en: Invoke upstream systems asynchronously
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步调用上游系统
- en: '**Wasm filter**: Last but not least is Wasm-based filters. We write these filters
    using our preferred programming language and then compile the code into a low-level
    assembly-like programming language called Wasm, which is then loaded by Envoy
    dynamically at runtime. Wasm is widely used in the open web, where it executes
    inside JavaScript virtual machines within web browsers. Envoy embeds a subset
    of the V8 VM ([https://v8.dev/](https://v8.dev/)) with every worker thread to
    execute Wasm modules. We will read more about Wasm and do hands-on exercises in
    *Chapter 9*.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wasm 过滤器**：最后但同样重要的是基于 Wasm 的过滤器。我们使用自己喜欢的编程语言编写这些过滤器，然后将代码编译成类似低级汇编语言的编程语言，称为
    Wasm，随后 Envoy 会在运行时动态加载这些过滤器。Wasm 被广泛应用于开放网络中，它在 Web 浏览器中的 JavaScript 虚拟机内执行。Envoy
    嵌入了 V8 虚拟机的一个子集（[https://v8.dev/](https://v8.dev/)），使每个工作线程能够执行 Wasm 模块。我们将在*第九章*中深入了解
    Wasm 并进行实际操作。'
- en: The ability to write custom filters makes Envoy extensible enough to implement
    for custom use cases. Support for Wasm-based filters brings down the learning
    curve of writing new filters as you can use a language you are most comfortable
    with. We hope that with the growing adoption of Envoy, there will be more tooling
    available to the developer to easily extend it using custom filters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 写自定义过滤器的能力使 Envoy 足够可扩展，可以实现自定义用例。对基于 Wasm 的过滤器的支持降低了编写新过滤器的学习曲线，因为你可以使用你最熟悉的编程语言。我们希望随着
    Envoy 的广泛应用，开发者可以获得更多工具，以便轻松使用自定义过滤器扩展它。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter provided you with details about Istio control plane components
    including istiod and its architecture. We also read about the Istio operator,
    the CLI, and how certificate distribution works. The Istio control plane can be
    deployed in various architecture patterns, and we had an overview of some of these
    deployment patterns as well.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你详细介绍了 Istio 控制平面组件，包括 istiod 及其架构。我们还了解了 Istio 操作员、CLI 以及证书分发的工作原理。Istio
    控制平面可以部署在多种架构模式下，我们也概述了一些这些部署模式。
- en: After covering the Istio control plane, we read about Envoy, a lightweight,
    highly performant `l3/l4/l7` proxy. It provides a range of configurations via
    the listener and cluster subsystems to control request processing. The filter-based
    architecture is easy to use, as well as extensible, as new filters can be written
    in Lua, Wasm, or C++ and can easily be plugged into Envoy. Last but not least
    is the ability of Envoy to support dynamic configuration via xDS APIs. Envoy is
    the best choice for the Istio data plane because of its flexibility and performance
    when serving as a proxy, as well as its easy configurability via xDS APIs, which
    are implemented by the Istio control plane. The istio-proxy, as discussed in the
    previous chapter, is made up of Envoy and the Istio agent.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在讲解 Istio 控制平面之后，我们了解了 Envoy，这是一款轻量级、高性能的 `l3/l4/l7` 代理。它通过监听器和集群子系统提供一系列配置来控制请求处理。基于过滤器的架构易于使用且可扩展，因为新的过滤器可以用
    Lua、Wasm 或 C++ 编写，并且可以轻松地插入到 Envoy 中。最后，Envoy 支持通过 xDS API 进行动态配置的能力也是其一大亮点。由于其在充当代理时的灵活性和性能，以及通过由
    Istio 控制平面实现的 xDS API 易于配置，Envoy 是 Istio 数据平面的最佳选择。前一章中讨论的 istio-proxy 由 Envoy
    和 Istio 代理组成。
- en: In the next chapter, we will put Istio to one side and instead immerse ourselves
    in experiencing a real-life application. We will take the application to a production-like
    environment and then discuss the problems that engineers would face in building
    and operating such an application. In *Part 2* and *Part 3* of this book, we will
    make use of this application in hands-on exercises. So, sit tight and brace yourselves
    for the next chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时搁置 Istio，转而沉浸于体验一个实际的应用场景。我们将把该应用带入类似生产环境的环境，并讨论工程师在构建和运营此类应用时可能面临的问题。在本书的*第二部分*和*第三部分*中，我们将通过实践操作使用这个应用。所以，系好安全带，准备迎接下一章。
- en: 'Part 2: Istio in Practice'
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：Istio 实践
- en: This part describes the application of Istio and how it is used to manage application
    traffic, provide resiliency to applications, and secure communication between
    microservices. With the help of numerous hands-on examples, you will learn about
    various Istio traffic management concepts and use them to perform application
    networking. The part concludes with a chapter on observability, in which you will
    read about how to observe the Service Mesh and use it to understand system behavior
    and the underlying causes behind faults so that you can confidently troubleshoot
    issues and analyze the effects of potential fixes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分描述了 Istio 的应用及其如何用于管理应用流量、提供应用弹性，并确保微服务之间的通信安全。在众多实践案例的帮助下，你将了解各种 Istio 流量管理概念，并使用它们进行应用网络配置。本部分最后以可观测性章节作为总结，介绍了如何观察服务网格，利用它了解系统行为及故障背后的根本原因，从而能够自信地进行故障排除并分析潜在修复方案的效果。
- en: 'This part contains the following chapters:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '*Chapter 4*, *Managing Application Traffic*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第四章*，*管理应用流量*'
- en: '*Chapter 5*, *Managing Application Resiliency*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第五章*，*管理应用弹性*'
- en: '*Chapter 6*, *Securing Microservices Communication*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第六章*，*确保微服务通信安全*'
- en: '*Chapter 7*, *Service Mesh Observability*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第七章*，*服务网格可观测性*'
