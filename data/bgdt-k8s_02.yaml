- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Kubernetes Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: Understanding Kubernetes architecture is crucial to properly leverage its capabilities.
    In this chapter, we will go over the main components and concepts that make up
    a Kubernetes cluster. Getting familiar with these building blocks will allow you
    to understand how Kubernetes works under the hood.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 架构对于正确利用其能力至关重要。在本章中，我们将介绍构成 Kubernetes 集群的主要组件和概念。熟悉这些构建块将帮助你了解
    Kubernetes 如何在幕后工作。
- en: We will start by looking at the different components that make up a Kubernetes
    cluster – the control plane and the worker nodes. The control plane—made up of
    components such as the API server, controller manager, and etcd—is responsible
    for managing and maintaining the desired state of the cluster. The worker nodes
    run your containerized applications in pods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看构成 Kubernetes 集群的不同组件——控制平面和工作节点。控制平面由 API 服务器、控制器管理器和 etcd 等组件组成，负责管理和维护集群的期望状态。工作节点在
    Pod 中运行容器化应用。
- en: After covering the cluster architecture, we will dive into the main Kubernetes
    abstractions and API resources such as pods, deployments, StatefulSets, services,
    ingress, and persistent volumes. These resources allow you to declare the desired
    state of your applications and have Kubernetes reconcile the actual state to match
    it. Understanding these concepts is key to being able to deploy and manage applications
    on Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍集群架构之后，我们将深入探讨 Kubernetes 的主要抽象和 API 资源，如 Pods、部署、StatefulSets、服务、Ingress
    和持久化卷。这些资源允许你声明应用的期望状态，并让 Kubernetes 调整实际状态以匹配它。理解这些概念是能够在 Kubernetes 上部署和管理应用的关键。
- en: We will also look at supporting resources such as ConfigMaps and Secrets, which
    allow you to separate configuration from code. Jobs provide support for batch
    workloads.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看支持资源，如 ConfigMaps 和 Secrets，这些可以将配置与代码分开。Jobs 提供对批处理工作负载的支持。
- en: By the end of this chapter, you will have a solid understanding of how a Kubernetes
    cluster is put together and how you can leverage its capabilities by utilizing
    its API resources. This will enable you to start deploying your own applications
    and managing them efficiently.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对 Kubernetes 集群的构建方式以及如何利用其 API 资源来发挥其能力有一个扎实的理解。这将使你能够开始部署自己的应用并高效地管理它们。
- en: 'We’ll be covering these concepts under the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下主要主题来讲解这些概念：
- en: Cluster architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群架构
- en: Pods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods
- en: Deployments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: StatefulSets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StatefulSets
- en: Jobs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jobs
- en: Services
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Ingress and ingress controllers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ingress 和 ingress 控制器
- en: Gateway
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关
- en: Persistent volumes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化卷
- en: ConfigMaps and Secrets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConfigMaps 和 Secrets
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no technical requirements for this chapter. All code presented here
    is generic and practical executable examples will be given in [*Chapter 3*](B21927_03.xhtml#_idTextAnchor053).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有技术要求。这里展示的所有代码都是通用的，实际可执行的示例将在 [*第 3 章*](B21927_03.xhtml#_idTextAnchor053)
    中给出。
- en: Kubernetes architecture
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: Kubernetes is a cluster architecture. This means that in a full production environment,
    you will usually have several machines running your workloads simultaneously to
    create a reliable and scalable architecture. (Note that Kubernetes can run on
    one machine also, which is great for testing but misses the whole point for production.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一种集群架构。这意味着在完整的生产环境中，通常会有多台机器同时运行工作负载，以创建可靠且可扩展的架构。（请注意，Kubernetes
    也可以在单台机器上运行，这非常适合测试，但对于生产环境来说并不合适。）
- en: 'To coordinate cluster functionalities, Kubernetes has two main feature groups:
    the **control plane** responsible for cluster management and the **node components**
    that communicate with the control plane and execute tasks in the worker machines.
    *Figure 2**.1* shows a representation of the whole system.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了协调集群功能，Kubernetes 有两个主要功能组：**控制平面**负责集群管理，**节点组件**与控制平面通信并在工作节点上执行任务。*图 2.1*
    展示了整个系统的表示。
- en: '![Figure 2.1 – Kubernetes architecture](img/B21927_02_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Kubernetes 架构](img/B21927_02_1.jpg)'
- en: Figure 2.1 – Kubernetes architecture
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Kubernetes 架构
- en: Let’s take a closer look at each group and its components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看每个组及其组件。
- en: Control plane
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制平面
- en: 'The main components of the control plane are the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面的主要组件如下：
- en: kube-apiserver
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-apiserver
- en: etcd
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd
- en: kube-scheduler
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: kube-controller-manager
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: When running a cloud-based Kubernetes cluster, we also have another component
    called cloud-controller-manager.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行基于云的 Kubernetes 集群时，我们还有一个组件叫做 cloud-controller-manager。
- en: kube-apiserver
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kube-apiserver
- en: The Kubernetes API is exposed to the administrator with **kube-apiserver**.
    It can be considered the “frontend” of the control plane. It is through the API
    server that we will interact with Kubernetes, sending instructions to the cluster
    or getting data from it. It is highly scalable and scales horizontally (deploying
    more worker nodes to the cluster).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 通过 **kube-apiserver** 向管理员开放。它可以看作是控制平面的“前端”。通过 API 服务器，我们与 Kubernetes
    进行交互，向集群发送指令或从集群获取数据。它具有高度的可扩展性，支持横向扩展（通过部署更多工作节点到集群中）。
- en: etcd
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: etcd
- en: Kubernetes utilizes etcd, a distributed key-value database, to persistently
    store all cluster data and state. Etcd serves as the backing store for the Kubernetes
    API server, providing a secure and resilient foundation for the orchestration
    of containers across nodes in a cluster. By leveraging etcd’s capabilities for
    consistency, high availability, and distribution, Kubernetes can reliably manage
    the desired state of applications and infrastructure. etcd is fault tolerant even
    if the failure happens in a leader node of the cluster.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用 etcd 作为一个分布式键值数据库，持久化存储所有集群数据和状态。etcd 作为 Kubernetes API 服务器的后端存储，提供了一个安全且具有韧性的基础，支持在集群节点之间协调容器的运行。通过利用
    etcd 在一致性、高可用性和分布式方面的能力，Kubernetes 可以可靠地管理应用程序和基础设施的期望状态。即使集群中的领导节点发生故障，etcd 仍具有容错能力。
- en: kube-scheduler
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: '**kube-scheduler** is responsible for distributing work or containers across
    multiple nodes. It watches for newly created pods that are not assigned to any
    node and selects a node for them to run on. To make scheduling decisions, kube-scheduler
    analyzes individual and collective available resources, hardware/software/policy
    constraints, affinity and anti-affinity instructions, deadlines, data locality
    and eventual interferences between workloads.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**kube-scheduler** 负责将工作负载或容器分配到多个节点。它会监控那些尚未分配到任何节点的已创建 Pod，并为它们选择一个运行节点。为了做出调度决策，kube-scheduler
    会分析单个和集体可用资源、硬件/软件/策略约束、亲和性和反亲和性规则、截止时间、数据位置以及工作负载之间的潜在干扰。'
- en: kube-controller-manager
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: '**kube-controller-manager** runs controllers that regulate behavior in the
    cluster, such as node controllers, job controllers, EndpointSlice controllers,
    and ServiceAccount controllers. The controllers reconcile the desired state with
    the current state.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**kube-controller-manager** 运行控制器来调节集群中的行为，如节点控制器、任务控制器、EndpointSlice 控制器和
    ServiceAccount 控制器。控制器通过对比期望状态和当前状态来进行调节。'
- en: cloud-controller-manager
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cloud-controller-manager
- en: '**cloud-controller-manager** interacts with the underlying cloud providers
    and sets up cloud-based networking services (such as networking routes and load
    balancers). It separates components that interact with the cloud provider from
    the components that run only inside the cluster. This controller manager only
    runs controllers that are specific to the cloud provider in use, thus, if you
    are running a test local Kubernetes instance, cloud-controller-manager will not
    be used, since it only deals with cloud-based services.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**cloud-controller-manager** 与底层云提供商进行交互，并设置基于云的网络服务（如网络路由和负载均衡器）。它将与云提供商交互的组件与仅在集群内运行的组件分离开来。此控制器管理器仅运行与所使用的云提供商相关的控制器，因此，如果你在运行本地测试
    Kubernetes 实例，cloud-controller-manager 将不会被使用，因为它只处理基于云的服务。'
- en: Next, let’s have a look at the node components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看节点组件。
- en: Node components
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点组件
- en: 'Node components are present in every single worker node of the cluster and
    are responsible for communicating with the control plane, running and maintaining
    workloads, and providing a runtime environment. The main components are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集群的工作节点中都包含节点组件，这些组件负责与控制平面通信、运行和维护工作负载，并提供运行时环境。主要组件如下：
- en: Container runtime
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时
- en: kubelet
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubelet
- en: kube-proxy
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-proxy
- en: Container runtime
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器运行时
- en: '**A container runtime** is the underlying software that is responsible for
    running containers. Kubernetes supports several container runtimes, but the most
    common ones are Docker and containerd. The container runtime is responsible for
    pulling the images from the registries, running the containers, and managing containers’
    lifecycles.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器运行时** 是负责运行容器的底层软件。Kubernetes 支持多种容器运行时，但最常见的是 Docker 和 containerd。容器运行时负责从镜像仓库拉取镜像、运行容器并管理容器的生命周期。'
- en: kubelet
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kubelet
- en: '**kubelet** is the primary node agent that watches the assigned pods and ensures
    containers are running and healthy. It interacts with the container runtime to
    pull images and run containers.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubelet** 是主要的节点代理，负责监视分配给节点的 Pods，并确保容器正在运行并且健康。它与容器运行时交互，以拉取镜像并运行容器。'
- en: kube-proxy
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kube-proxy
- en: '**kube-proxy** is a network proxy and load balancer that implements Kubernetes
    networking services on each node by maintaining network rules and performing connection
    forwarding.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**kube-proxy** 是一个网络代理和负载均衡器，通过维护网络规则和执行连接转发，在每个节点上实现 Kubernetes 网络服务。'
- en: Now, let’s move our attention to the Kubernetes components we will use to build
    our workloads.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向我们将在构建工作负载时使用的 Kubernetes 组件。
- en: Pods
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pods
- en: '**Pods** are the smallest deployable units in Kubernetes and represent a single
    instance of an application. Pods contain one or more containers (although the
    most common case is to have just one container inside a pod). When multiple containers
    live inside a pod, they are guaranteed to be co-located on the same node and can
    share resources.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pods** 是 Kubernetes 中最小的可部署单元，表示应用程序的单个实例。Pod 包含一个或多个容器（尽管最常见的情况是每个 Pod 仅包含一个容器）。当多个容器位于同一个
    Pod 中时，它们会保证被调度到同一个节点上，并且能够共享资源。'
- en: 'Pods provide two main benefits:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 提供两个主要的好处：
- en: '`localhost` and share resources such as volumes. This facilitates easy communication
    between related containers. It is important to notice, though, that this is an
    advanced use case and should be used only when your containers are tightly coupled.
    We regularly use pods for single-container deployments.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost` 并共享卷等资源。这有助于相关容器之间的轻松通信。不过，需要注意的是，这是一个高级用例，应该仅在容器紧密耦合时使用。我们通常使用
    Pods 来进行单容器部署。'
- en: '**Management and deployment**: Pods are the units that get deployed, scaled,
    and managed in Kubernetes. You don’t directly create or manage the containers
    within pods. This entire process is fully automated.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理与部署**：Pods 是在 Kubernetes 中部署、扩展和管理的单位。你不会直接创建或管理 Pod 内的容器。整个过程是完全自动化的。'
- en: Usually, you do not define pods directly. Pods can be created and managed though
    other resources such as deployments, jobs, and `StatefulSets`. Nevertheless, you
    can define a pod with a proper YAML file manifest.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会直接定义 Pods。Pods 可以通过其他资源（如部署、任务和 `StatefulSets`）创建和管理。然而，你也可以通过合适的 YAML
    文件清单来定义一个 Pod。
- en: '`.yaml` file. **YAML files** are often used for configuration. They are very
    close to JSON files, but they are more readable since they rely on indentation
    for code hierarchy structure rather than brackets and braces. The following is
    an example of a manifest to deploy a single pod:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`.yaml` 文件。**YAML 文件** 通常用于配置。它们与 JSON 文件非常相似，但由于依赖缩进来表示代码层次结构，而不是使用括号和大括号，因此更具可读性。以下是一个部署单个
    Pod 的清单示例：'
- en: pod.yaml
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: pod.yaml
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s have a closer look at each part of this manifest:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个清单的每个部分：
- en: '`apiVersion`: The Kubernetes API version for the objects in this manifest.
    For pods this is `v1`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`：此清单中对象的 Kubernetes API 版本。对于 Pods，版本为 `v1`。'
- en: '`kind`: The type of object being created, which is `Pod` for this manifest.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：正在创建的对象类型，对于此清单是 `Pod`。'
- en: '`metadata`: This section contains metadata for the pod, such as the name and
    labels. The name is a unique identifier. Labels will be particularly important
    in the future as they serve as identifiers for other Kubernetes resources such
    as deployments and services.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`：此部分包含 Pod 的元数据，例如名称和标签。名称是唯一标识符。标签将在未来特别重要，因为它们作为其他 Kubernetes 资源（如部署和服务）的标识符。'
- en: '`spec`: This section defines the desired state of the pod including its containers.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`：此部分定义 Pod 的期望状态，包括其容器。'
- en: '`containers`: Specifies the container(s) that run inside the pod. Includes
    the image, ports, etc.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers`：指定运行在 Pod 内的容器。包括镜像、端口等信息。'
- en: '`image`: The Docker image to use for the container. It can be a public or private
    image.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：容器使用的 Docker 镜像，可以是公共镜像或私有镜像。'
- en: '`ports`: Defines the ports exposed by the container.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`: 定义容器暴露的端口。'
- en: This covers the basic structure of a pod manifest. Pods provide a simple way
    to deploy and manage containers in Kubernetes. Now that we have discussed pods
    and how to define them, let’s discuss a way of automating more complex pod structures
    with deployments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了Pod清单的基本结构。Pods提供了一种在Kubernetes中部署和管理容器的简单方式。现在我们已经讨论了Pods及其定义方式，让我们讨论一种通过部署自动化更复杂Pod结构的方法。
- en: Deployments
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deployments
- en: '**Deployments** are one of the most important resources in Kubernetes for running
    applications. They provide a declarative way to manage pods and replicas.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Deployments**是Kubernetes中运行应用程序最重要的资源之一。它们提供了一种声明式的方法来管理Pods和副本。'
- en: A deployment defines the desired state for your application, including the container
    image, number of replicas, resource limits, and more. The Kubernetes control plane
    works to match the actual state of your cluster to the desired state in the deployment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 部署定义了应用程序的所需状态，包括容器镜像、副本数、资源限制等。Kubernetes控制平面会将集群的实际状态与部署中所需的状态进行匹配。
- en: 'For example, here is a simple deployment manifest:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个简单的部署清单：
- en: deployment.yaml
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.yaml
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s break this down section by section:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐节分析：
- en: '`apiVersion`: This specifies the Kubernetes API version for the Deployment
    resource. We want the `apps/v1` version which includes Deployments.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`: 这是指定Kubernetes API版本的字段，用于部署资源。我们需要使用`apps/v1`版本，该版本包含了Deployments。'
- en: '`kind: Deployment`: The type of resource we are creating, in this case, a Deployment.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind: Deployment`: 我们正在创建的资源类型，这里是Deployment。'
- en: '`metadata`: Standard metadata for the resource like a unique name.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`: 资源的标准元数据，如唯一名称。'
- en: '`spec`: The specification for the Deployment. This defines the desired state.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`: 部署的规格。它定义了所需的状态。'
- en: '`replicas: 3`: We want three pod replicas to be running. Kubernetes will maintain
    this number of pods.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicas: 3`: 我们希望运行三个Pod副本。Kubernetes将保持这个Pod数。'
- en: '`selector`: Used to match pods managed by this Deployment. Pods will be selected
    based on the label selector.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`: 用于匹配由此部署管理的Pod。Pod将根据标签选择器进行选择。'
- en: '`template`: The template for the pods that will be created. It defines the
    pod specifications. Note that the deployment will relate to the label specified.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`: 将要创建的Pod模板。它定义了Pod的规格。请注意，部署将与指定的标签相关联。'
- en: '`spec: containers`: Pod spec including the container(s) to run.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec: containers`: Pod的规格，包括要运行的容器。'
- en: '`image: nginx:1.16`: The container image to use.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image: nginx:1.16`: 使用的容器镜像。'
- en: '`ports`: Ports exposed by the container.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`: 容器暴露的端口。'
- en: When this Deployment is applied, Kubernetes will launch three pods matching
    the template, each running an Nginx container. The Deployment controller will
    monitor the pods and ensure the desired state matches the actual state, restarting
    pods if needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当此部署应用时，Kubernetes将启动三个与模板匹配的Pod，每个Pod运行一个Nginx容器。部署控制器将监控这些Pod，并确保所需状态与实际状态一致，必要时会重启Pod。
- en: 'Deployments provide powerful capabilities for running scalable and resilient
    applications on Kubernetes. Using declarative configuration makes deployments
    easy. Next, we will discuss a different approach for managing pods and replicas:
    StatefulSets.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 部署提供了强大的功能，用于在Kubernetes上运行可扩展和弹性的应用程序。使用声明式配置使得部署变得简便。接下来，我们将讨论管理Pods和副本的另一种方法：StatefulSets。
- en: StatefulSets
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StatefulSets
- en: StatefulSets are a Kubernetes resource used to manage stateful applications
    such as databases. They are similar to Deployments but are designed to handle
    stateful workloads that require persistent storage and unique network identifiers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets是Kubernetes资源，用于管理有状态应用程序，如数据库。它们类似于Deployments，但专门设计用于处理需要持久存储和唯一网络标识符的有状态工作负载。
- en: A StatefulSet manages Pods that contain stateful applications (applications
    that must keep track of data for other applications or other user sessions). The
    Pods in a StatefulSet have a sticky, unique identity that persists across rescheduling.
    This allows each Pod to maintain its state when restarted or rescheduled onto
    a new node. This makes StatefulSets ideal for stateful apps such as databases
    that require data persistence. Deployments, on the other hand, are designed for
    stateless workloads and provide identical Pods with no persistent storage. Thus,
    they are better for stateless web apps.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet 管理包含有状态应用的 Pods（必须为其他应用或用户会话跟踪数据的应用）。StatefulSet 中的 Pods 具有粘性的、唯一的身份，即使在重新调度时也能保持不变。这使得每个
    Pod 在重启或重新调度到新节点时能够保持其状态。因此，StatefulSets 非常适合像数据库这样的有状态应用，需要数据持久化。而 Deployments
    则是为无状态工作负载设计的，提供没有持久化存储的相同 Pods，因此更适用于无状态的 Web 应用。
- en: StatefulSets operate by creating PersistentVolumes (which will be covered later
    in this chapter) for each Pod to mount. This ensures data persists across Pod
    restarts. StatefulSets also provide a unique hostname and stable network ID per
    Pod using a predictable naming convention.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets 通过为每个 Pod 创建持久化存储卷（将在本章后续部分介绍）来运行。这样可以确保数据在 Pod 重启时得以持久保存。StatefulSets
    还为每个 Pod 提供独特的主机名和稳定的网络 ID，使用可预测的命名规则。
- en: 'Here is an example of a statefulset manifest for deploying a MySQL database:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个部署 MySQL 数据库的 StatefulSet 清单示例：
- en: statefulset.yaml
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: statefulset.yaml
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This manifest creates a StatefulSet for MySQL with one replica. It uses a `volumeClaimTemplate`
    to dynamically provision a PersistentVolume for each Pod. The MySQL data will
    be persisted in the `/``var/lib/mysql` path.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该清单为 MySQL 创建了一个包含一个副本的 StatefulSet。它使用 `volumeClaimTemplate` 动态为每个 Pod 配置一个持久化存储卷。MySQL
    数据将保存在 `/``var/lib/mysql` 路径下。
- en: Each Pod gets a unique name, such as `mysql-0`, and a stable hostname. If the
    Pod gets rescheduled, it will remount its PersistentVolume to continue running
    statefully.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Pod 都会得到一个唯一的名称，如 `mysql-0`，并且具有一个稳定的主机名。如果 Pod 被重新调度，它将重新挂载其持久化存储卷，继续以有状态的方式运行。
- en: In this way, StatefulSets provide powerful stateful management for databases
    and other stateful apps in Kubernetes. They ensure persistence, stable networking,
    ordered deployment, and graceful scaling. Next, we will continue with a discussion
    about Kubernetes jobs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，StatefulSets 为 Kubernetes 中的数据库和其他有状态应用提供了强大的有状态管理功能。它们确保数据持久化、稳定的网络、有序的部署以及平滑的扩展。接下来，我们将继续讨论
    Kubernetes 作业。
- en: Jobs
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: '**Jobs** are a fundamental resource type in Kubernetes used to run batch processes
    that run to completion. Unlike long-running services such as web servers, jobs
    are intended to terminate when the batch process finishes.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**作业**是 Kubernetes 中的一个基本资源类型，用于运行直到完成的批处理任务。与长时间运行的服务（如 Web 服务器）不同，作业旨在在批处理任务完成时终止。'
- en: A job creates one or more pods that run a defined workload and then terminates
    when the workload is complete. This is useful for tasks such as data processing,
    machine learning training, or any finite computation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个作业创建一个或多个 Pod，运行定义的工作负载，并在工作负载完成后终止。对于数据处理、机器学习训练或任何有限计算等任务，这种方式非常有用。
- en: 'To create a job, you define a Job resource in a YAML manifest like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个作业，你可以在 YAML 清单中定义一个 Job 资源，如下所示：
- en: job.yaml
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: job.yaml
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s have a closer look at this code, part by part:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐部分仔细看一下这段代码：
- en: '`apiVersion` `''` `batch/v1` for jobs'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion` `''` `batch/v1` 用于作业'
- en: '`kind` `''` `Job`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind` `''` `Job`'
- en: '`metadata.name` `''` Name of the job'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.name` `''` 作业的名称'
- en: '`spec.template` `''` Pod template defining the container(s) to run the same
    way we saw in the previous resource definitions'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.template` `''` Pod 模板，定义了容器（们），与我们在之前的资源定义中看到的方式相同'
- en: '`spec.template.spec.restartPolicy` `''` Set to `Never` since jobs shouldn’t
    restart'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.template.spec.restartPolicy` `''` 设置为 `Never`，因为作业不应该重启'
- en: '`spec.backoffLimit` `''` Optional limit on failed job retries'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.backoffLimit` `''` 可选的失败任务重试次数限制'
- en: The pod template under `spec.template` defines the container(s) to run just
    like a pod manifest. You can specify the image, commands, environment variables,
    and so on. An important setting is the `restartPolicy`, which should be `Never`
    for jobs. This ensures pods are not restarted if they fail or exit. The `backoffLimit`
    is optional and specifies the number of times a failed job pod can be retried.
    The default is **6**. Set this lower if jobs should not retry too many times on
    failure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec.template` 下的 pod 模板定义了要运行的容器，就像 pod 清单一样。你可以指定镜像、命令、环境变量等。一个重要的设置是 `restartPolicy`，对于作业来说，它应该设置为
    `Never`，以确保如果 pod 失败或退出时不会被重启。`backoffLimit` 是可选的，指定一个失败的作业 pod 可以重试的次数。默认值是 **6**。如果不希望作业在失败后重试太多次，可以将此值设置得更低。'
- en: When you create the job, Kubernetes will schedule one or more pods matching
    the template to run your workload. As the pods finish, Kubernetes will track their
    status and know when the job is completed. You can view job status and pod logs
    to monitor progress. Jobs make it easy to run batch computational workloads on
    Kubernetes. In the next section, we will take a look at Kubernetes services.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建作业时，Kubernetes 会调度一个或多个符合模板的 pod 来运行你的工作负载。当 pod 完成时，Kubernetes 会跟踪它们的状态并知道作业何时完成。你可以查看作业状态和
    pod 日志以监控进度。作业使得在 Kubernetes 上运行批量计算工作负载变得更容易。在接下来的部分中，我们将深入了解 Kubernetes 服务。
- en: Services
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: '**Services** provide stable endpoints to access pods running in a cluster,
    thus exposing our applications to users online. They allow pods to die and replicate
    without interrupting access to the applications running in those pods. There are
    several types of services in Kubernetes. We will discuss three of them in detail:
    ClusterIP, NodePort, and load balancer.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务** 提供了稳定的端点，以便访问在集群中运行的 pod，从而将我们的应用程序暴露给在线用户。它们允许 pod 死亡和复制，而不会中断对在这些
    pod 中运行的应用程序的访问。Kubernetes 中有几种类型的服务。我们将详细讨论其中的三种：ClusterIP、NodePort 和负载均衡器。'
- en: ClusterIP Service
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ClusterIP 服务
- en: 'A ClusterIP service provides an IP address that is only accessible inside the
    cluster. This IP does not change for the lifetime of the service, providing a
    stable endpoint to access the pods. Here is an example ClusterIP service manifest:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterIP 服务提供了一个仅在集群内部可访问的 IP 地址。这个 IP 地址在服务生命周期内不会改变，为访问 pod 提供了一个稳定的端点。以下是一个
    ClusterIP 服务清单的示例：
- en: service_clusterip.yaml
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: service_clusterip.yaml
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This manifest creates a service called `my-service` that will forward requests
    to pods with the label `app: my-app` on `port 80`. Requests will be forwarded
    to `port 9376` on the target pods. The ClusterIP will not change while this service
    exists.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '这个清单创建了一个名为 `my-service` 的服务，它会将请求转发到具有 `app: my-app` 标签的 pod，端口为 `80`。请求将被转发到目标
    pod 上的 `9376` 端口。在此服务存在期间，ClusterIP 不会改变。'
- en: NodePort Service
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NodePort 服务
- en: 'A NodePort service makes an internal ClusterIP service accessible externally
    through a port allocated on each node. The NodePort is allocated from a configured
    range (by default, `30000`-`32767`) and will be the same on every node. Traffic
    to `<NodeIP>:<NodePort>` will be forwarded to the ClusterIP service. Here is an
    example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: NodePort 服务通过在每个节点上分配的端口使得内部的 ClusterIP 服务能够在外部访问。NodePort 从配置的范围中分配（默认是 `30000`-`32767`），并且在每个节点上都是相同的。对
    `<NodeIP>:<NodePort>` 的流量将被转发到 ClusterIP 服务。以下是一个示例：
- en: service_nodeport.yaml
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: service_nodeport.yaml
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This exposes the internal ClusterIP on port `30007` on every node. Requests
    to `<NodeIP>:30007` will be forwarded to the service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每个节点的 `30007` 端口上暴露内部的 ClusterIP。对 `<NodeIP>:30007` 的请求将被转发到服务。
- en: LoadBalancer Service
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡器服务
- en: A load balancer service provisions an external load balancer to expose the service
    to external traffic. A ClusterIP exposes the service on an internal IP address
    within the Kubernetes cluster. This makes the service only reachable within the
    cluster. Load balancer, on the other hand, exposes the service externally using
    the cloud provider’s load balancer implementation. This makes the service reachable
    from outside the Kubernetes cluster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器服务提供了一个外部负载均衡器，用于将服务暴露给外部流量。ClusterIP 将服务暴露在 Kubernetes 集群内的内部 IP 地址上，这使得服务仅能在集群内访问。另一方面，负载均衡器通过云提供商的负载均衡器实现将服务暴露到外部，这使得服务能够从
    Kubernetes 集群外部进行访问。
- en: 'The load balancer implementation depends on the environment. For example, on
    AWS, this would create an **Elastic Load Balancer** (**ELB**), an AWS service
    to provide a managed load balancer. Here is an example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器的实现依赖于环境。例如，在 AWS 上，这将创建一个 **Elastic Load Balancer**（**ELB**），这是一个 AWS
    服务，用于提供托管的负载均衡器。以下是一个示例：
- en: service_loadbalancer.yaml
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: service_loadbalancer.yaml
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This creates a load balancer and assigns an external IP address. Traffic to
    the external IP is forwarded to the internal ClusterIP service. Next, we will
    discuss a different way of defining services with Ingress and Ingress Controller.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个负载均衡器并分配一个外部 IP 地址。流量到达外部 IP 后会被转发到内部的 ClusterIP 服务。接下来，我们将讨论另一种使用 Ingress
    和 Ingress 控制器定义服务的方法。
- en: Ingress and Ingress Controller
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ingress 和 Ingress 控制器
- en: An **Ingress** resource defines rules for external connectivity to Kubernetes
    services. It enables inbound HTTP and HTTPS connections to reach services running
    within the cluster. Traffic routing is controlled by rules defined on the Ingress
    resource. For an ingress to be able to run, you need to have a running ingress
    controller on Kubernetes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ingress** 资源定义了外部连接到 Kubernetes 服务的规则。它使得 HTTP 和 HTTPS 连接能够访问集群内运行的服务。流量路由由
    Ingress 资源中定义的规则控制。要使 Ingress 能够运行，你需要在 Kubernetes 上运行一个 Ingress 控制器。'
- en: An **Ingress controller** is responsible for fulfilling the Ingress, usually
    with a load balancer. It watches for Ingress resources and configures the load
    balancer accordingly. Different load balancers require different Ingress controller
    implementations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ingress 控制器** 负责实现 Ingress，通常通过负载均衡器完成。它监视 Ingress 资源，并相应地配置负载均衡器。不同的负载均衡器需要不同的
    Ingress 控制器实现。'
- en: 'Some examples of Ingress controllers include the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Ingress 控制器的示例如下：
- en: 'NGINX Ingress Controller: Uses NGINX as a load balancer and reverse proxy.
    It is one of the most common and fully featured controllers.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX Ingress Controller：使用 NGINX 作为负载均衡器和反向代理，是最常见和功能最全的控制器之一。
- en: 'HAProxy Ingress Controller: Uses HAProxy for load balancing. Provides high
    performance and reliability.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HAProxy Ingress Controller：使用 HAProxy 进行负载均衡，提供高性能和高可靠性。
- en: 'Traefik Ingress Controller: A cloud-native controller that integrates with
    Let’s Encrypt for automatic HTTPS certificate generation.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Traefik Ingress Controller：一种云原生控制器，集成了 Let’s Encrypt，用于自动生成 HTTPS 证书。
- en: 'AWS ALB Ingress Controller: Uses the AWS **Application Load Balancer** (**ALB**).
    Integrates natively with other AWS services.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS ALB Ingress Controller：使用 AWS **应用负载均衡器**（**ALB**）。与其他 AWS 服务本地集成。
- en: 'The Ingress resource contains two main parts – a backend and rules. The backend
    specifies the default service to route unmatched requests. The rules contain a
    set of paths and the services to route them to:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 资源包含两个主要部分——后端和规则。后端指定路由到默认服务的未匹配请求。规则包含一组路径和将它们路由到的服务：
- en: ingress.yaml
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ingress.yaml
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, requests to the root path `/` will be routed to the `example-service`
    on port `80`. The `pathType:` prefix indicates that any subpath should also be
    routed to the service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，根路径 `/` 的请求将被路由到 `example-service` 的端口 `80`。`pathType:` 前缀表示任何子路径也应该路由到该服务。
- en: 'Multiple rules can be defined to route different paths to different services:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义多个规则，将不同的路径路由到不同的服务：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the preceding code, requests to `/foo` will go to `foo-service` and requests
    to `/bar` will go to `bar-service`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，请求 `/foo` 会被路由到 `foo-service`，而请求 `/bar` 会被路由到 `bar-service`。
- en: 'In some cases, we have to configure secure connections with in-transit encryption.
    When this is the case, we can configure advanced encryption options in Ingress
    controllers using annotations:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们必须配置具有传输加密的安全连接。当出现这种情况时，我们可以在 Ingress 控制器中使用注解配置高级加密选项：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Host-based routing can also be configured by specifying host names:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过指定主机名来配置基于主机的路由：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now `foo.example.com` will route to `foo-service` and `bar.example.com` to `bar-service`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `foo.example.com` 将路由到 `foo-service`，而 `bar.example.com` 将路由到 `bar-service`。
- en: In summary, Ingress provides a way to intelligently route HTTP and HTTPS traffic
    to services in a Kubernetes cluster. Ingress controllers handle the actual load
    balancing and reverse proxy functionality. Common use cases for Ingress include
    exposing services to external users and handling TLS/SSL. Careful Ingress configuration
    is crucial for production-grade Kubernetes deployments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Ingress 提供了一种智能路由 HTTP 和 HTTPS 流量到 Kubernetes 集群中服务的方式。Ingress 控制器处理实际的负载均衡和反向代理功能。Ingress
    的常见用例包括将服务暴露给外部用户和处理 TLS/SSL。对于生产级 Kubernetes 部署，谨慎配置 Ingress 至关重要。
- en: '**It is important to note that the ingress API is frozen.** That means that
    this API will not be receiving any more updates. It is replaced by the Gateway
    API. Nevertheless, it is important to know it since a lot of the big data tools
    that we will use in this book are still deployed using Ingress instructions. Now,
    let’s move to the Gateway API and understand how it works.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要注意的是，Ingress API 已被冻结。** 这意味着该 API 将不再接受任何更新，已被 Gateway API 取代。尽管如此，了解它仍然很重要，因为本书中我们将使用的许多大数据工具仍然是通过
    Ingress 指令部署的。现在，让我们转向 Gateway API，了解它是如何工作的。'
- en: Gateway
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gateway
- en: The Gateway API is a Kubernetes API that provides a way to dynamically configure
    load balancing and service mesh capabilities on Kubernetes. The Gateway API allows
    defining routes and policies to manage external traffic to Kubernetes services
    in a centralized, declarative way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Gateway API 是一个 Kubernetes API，提供了一种在 Kubernetes 上动态配置负载均衡和服务网格功能的方式。Gateway
    API 允许以集中声明的方式定义路由和策略来管理外部流量到 Kubernetes 服务。
- en: 'The main resources in Gateway API are the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Gateway API 中的主要资源如下：
- en: '`GatewayClass` `''` Defines a set of gateways with a common configuration and
    behavior. It is like the concept of StorageClass for persistent volumes.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GatewayClass` `''` 定义了一组具有共同配置和行为的网关。它类似于持久化存储卷的 StorageClass 概念。'
- en: '`Gateway` `''` Defines a set of routes for a given hostname. This binds GatewayClass,
    TLS certificate, and other configurations to a set of routes.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gateway` `''` 定义了一组给定主机名的路由。这将 GatewayClass、TLS 证书和其他配置绑定到一组路由。'
- en: '`HTTPRoute/TCPRoute` `''` Defines the actual routes to Kubernetes services
    and their policies, such as timeouts, retries, and so on.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPRoute/TCPRoute` `''` 定义了实际的路由到 Kubernetes 服务及其策略，如超时、重试等。'
- en: 'Here is an example GatewayClass resource:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 GatewayClass 资源的示例：
- en: gateway_class.yaml
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: gateway_class.yaml
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This defines a GatewayClass named `external-lb` that will be handled by a `lb.acme.io/gateway-controller`
    controller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `external-lb` 的 GatewayClass，将由 `lb.acme.io/gateway-controller` 控制器处理。
- en: 'A Gateway resource binds a hostname and TLS certificate to the GatewayClass
    as we can see in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Gateway 资源将主机名和 TLS 证书与 GatewayClass 绑定，如以下代码所示：
- en: gateway.yaml
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: gateway.yaml
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This Gateway named `my-gateway` uses the `external-lb` GatewayClass defined
    earlier. It handles HTTP traffic on port `80`. Note that the `addresses` field
    is not specified, so an address or hostname will be assigned to the gateway by
    its controller.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为 `my-gateway` 的网关使用了之前定义的 `external-lb` GatewayClass。它处理端口 `80` 上的 HTTP
    流量。请注意，`addresses` 字段没有指定，因此网关的控制器将为其分配一个地址或主机名。
- en: 'Finally, HTTPRoute and TCPRoute resources define the actual routes to backend
    services. Here is an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，HTTPRoute 和 TCPRoute 资源定义了实际的后端服务路由。这里是一个示例：
- en: http_route.yaml
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: http_route.yaml
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This HTTPRoute is a child of the `my-gateway` Gateway defined earlier. It routes
    requests to the `/foo` path to the `my-foo-service` service on port `80` and requests
    to `/bar` are routed to `my-bar-service` on port `80`. Also, additional features
    such as request timeouts, retries, and traffic splitting can be configured on
    the Route resources.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 HTTPRoute 是之前定义的 `my-gateway` 网关的子资源。它将请求路由到 `/foo` 路径，指向端口 `80` 上的 `my-foo-service`
    服务，且请求到 `/bar` 的流量将被路由到端口 `80` 上的 `my-bar-service`。此外，诸如请求超时、重试和流量拆分等附加功能可以在 Route
    资源中进行配置。
- en: Gateways are a new and great way of configuring networking and routing in Kubernetes.
    The centralized configuration for ingress traffic management acts as a single
    source of truth. While the Ingress resource presents a simple, declarative interface
    focused specifically on exposing HTTP applications, the Gateway API resource offers
    a more generalized abstraction for proxying diverse protocols beyond HTTP. Also,
    they decouple the data plane from the control plane. Any gateway controller can
    be used, including NGINX, HAProxy, and Istio. Gateways provide improved security
    with TLS handling and authentication and fine-grained traffic control using advanced
    routing rules and policies. Finally, they have easier management and operation
    for complex ingress configurations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 网关是配置 Kubernetes 中网络和路由的新方式，且非常有效。集中式的入口流量管理配置充当了单一的事实来源。虽然 Ingress 资源提供了一个简单、声明式的接口，专注于暴露
    HTTP 应用程序，但 Gateway API 资源则提供了一个更通用的抽象，用于代理 HTTP 以外的多种协议。此外，它们还将数据平面与控制平面解耦。任何网关控制器都可以使用，包括
    NGINX、HAProxy 和 Istio。网关通过 TLS 处理和身份验证提供了更好的安全性，并通过先进的路由规则和策略实现了精细的流量控制。最后，它们在复杂的入口配置中提供了更容易的管理和操作。
- en: Next, we will approach persistent volumes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨持久化存储卷（persistent volumes）。
- en: Persistent Volumes
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久卷（Persistent Volumes）
- en: 'Kubernetes was originally designed for stateless applications. So, one of the
    key challenges when running stateful applications on Kubernetes is managing storage.
    Kubernetes provides abstractions that allow storage to be provisioned and consumed
    in a portable manner across different environments. When designing storage infrastructure
    on Kubernetes, there are two main resources to understand: **PersistentVolumes**
    (**PVs**) and **PersistentVolumeClaims** (**PVCs**). A PV represents a networked
    storage unit provisioned by the cluster administrator. Much like compute nodes,
    PVs become a pool of cluster resources. In contrast, PVCs allow end users to request
    abstract storage with defined capacity and access modes. The PVC functions similarly
    to a pod resource request, but instead of CPU and memory, users can specify their
    desired volume size and read/write permissions. The Kubernetes control plane handles
    binding matching PV and PVC resources to provision storage for pods as declared.
    With this separation of roles, the underlying storage layer gains lifecycle independence
    from individual pods.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 最初是为无状态应用设计的。因此，当在 Kubernetes 上运行有状态应用时，管理存储是一个关键挑战。Kubernetes 提供了抽象，使得存储能够在不同环境中以可移植的方式进行配置和使用。在
    Kubernetes 上设计存储基础设施时，需要理解两个主要资源：**持久卷**（**PVs**）和 **持久卷声明**（**PVCs**）。PV 代表由集群管理员配置的网络存储单元。与计算节点类似，PVs
    成为集群资源池。相对而言，PVC 允许最终用户请求具有定义容量和访问模式的抽象存储。PVC 的功能类似于 pod 资源请求，但用户可以指定所需的卷大小和读/写权限，而不是
    CPU 和内存。Kubernetes 控制平面负责绑定匹配的 PV 和 PVC 资源，以根据声明为 pods 配置存储。通过这种角色分离，底层存储层从单个
    pod 的生命周期中独立出来。
- en: 'Here is an example PersistentVolume YAML manifest:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个持久卷 YAML 清单示例：
- en: persistent_volume.yaml
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: persistent_volume.yaml
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This defines an `/tmp` on the NFS server at `172.17.0.2`. The reclaim policy
    is set to `Recycle`, which means the volume will be recycled rather than deleted
    when released. `storageClassName` is set to `slow`, which can be used to match
    this PV to PVCs requesting specific storage classes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了 NFS 服务器 `172.17.0.2` 上的 `/tmp`。回收策略设置为 `Recycle`，这意味着当释放时，卷会被回收而不是删除。`storageClassName`
    设置为 `slow`，它可以用于将此 PV 与请求特定存储类的 PVC 匹配。
- en: 'Here is an example PersistentVolumeClaim YAML manifest:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个持久卷声明 YAML 清单示例：
- en: pvc.yaml
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: pvc.yaml
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This PVC requests 8GB of storage with `ReadWriteOnce` access. It specifies the
    `slow` `storageClassName`, which will match it to the preceding PV with the same
    storage class. There is also a selector that will match PVs with a `stable` release
    label.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 PVC 请求 8GB 的存储，并具有 `ReadWriteOnce` 访问权限。它指定了 `slow` 的 `storageClassName`，这将使其与前面具有相同存储类的
    PV 匹配。还有一个选择器会匹配具有 `stable` 版本标签的 PV。
- en: When a PVC is created, the Kubernetes control plane looks for a matching PV
    to bind to the PVC. This matching takes into account access modes, storage capacity,
    and `storageClassName` among other factors. Once bound, that storage is then available
    to be mounted by pods.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 PVC 时，Kubernetes 控制平面会寻找匹配的 PV 进行绑定。匹配条件考虑了访问模式、存储容量和 `storageClassName`
    等因素。一旦绑定，该存储就可以被 pods 挂载。
- en: 'Here is a pod YAML that mounts the preceding PVC:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个挂载前述 PVC 的 pod YAML：
- en: pod_with_pvc.yaml
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: pod_with_pvc.yaml
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This pod mounts the PVC into the container at `/var/www/html`. The PVC provides
    durable storage for the pod that persists even if the pod is deleted or moved
    to a different node.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该 pod 将 PVC 挂载到容器中的 `/var/www/html`。PVC 为 pod 提供了持久存储，即使 pod 被删除或迁移到其他节点，存储也会保留。
- en: StorageClasses
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储类（StorageClasses）
- en: 'The StorageClass objects define different *classes* of storage that can be
    requested. This allows administrators to offer different tiers of storage within
    the same cluster. The following code defines a standard hard disk StorageClass
    and a fast SSD StorageClass on GCE:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: StorageClass 对象定义了可以请求的不同 *存储类*。这允许管理员在同一集群内提供不同级别的存储。以下代码定义了一个标准硬盘 StorageClass
    和一个在 GCE 上的快速 SSD StorageClass：
- en: storage_classes.yaml
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: storage_classes.yaml
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `---` line tells Kubernetes that we aggregated two YAML manifests in just
    one file. After defining a StorageClass, PVCs can then request a particular class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`---` 行告诉 Kubernetes 我们将两个 YAML 清单聚合在一个文件中。在定义 StorageClass 后，PVC 可以请求特定的存储类：'
- en: pvc2.yaml
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: pvc2.yaml
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This allows a cluster to provide different types of storage without requiring
    users to understand how the details are implemented. Next, we will discuss the
    final subject in this chapter and one that is very important for security in Kubernetes:
    ConfigMaps and Secrets.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得集群能够提供不同类型的存储，而无需用户了解实现的细节。接下来，我们将讨论本章最后一个主题，也是 Kubernetes 安全性中非常重要的一个话题：配置映射和秘密（Secrets）。
- en: ConfigMaps and Secrets
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置映射和秘密
- en: ConfigMaps and Secrets are two important Kubernetes objects that allow you to
    separate configuration data from your application code. This makes your applications
    more portable, manageable, and secure.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 配置映射和秘密是两个重要的 Kubernetes 对象，它们允许你将配置数据与应用程序代码分离。这使得你的应用程序更具可移植性、可管理性和安全性。
- en: ConfigMaps
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置映射（ConfigMaps）
- en: ConfigMaps provide a convenient way to pass configuration data into pods in
    a declarative manner. They allow you to store configuration information without
    putting them directly in a pod definition or container image. Pods can access
    the data stored in a ConfigMap through environment variables, command-line arguments,
    or by mounting the ConfigMap as a volume. Using ConfigMaps enables you to separate
    your configuration data from your application code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 配置映射提供了一种便捷的方式，以声明的方式将配置数据传递给 Pod。它们允许你存储配置数据，而不直接将其放入 Pod 定义或容器镜像中。Pod 可以通过环境变量、命令行参数或将配置映射作为卷挂载来访问存储在配置映射中的数据。使用配置映射使得你能够将配置数据与应用程序代码分离。
- en: 'With the following manifest, you can create a ConfigMap to store configuration
    files:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下清单，你可以创建一个配置映射来存储配置文件：
- en: config_map.yaml
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: config_map.yaml
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This ConfigMap contains a `config.properties` file that pods can mount and consume.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置映射包含一个 `config.properties` 文件，Pod 可以挂载并使用它。
- en: 'You can also create ConfigMaps from directories, files, or literal values.
    The following commands show an example of each ConfigMap definition. Those commands
    are run in a shell using the `kubectl` executable (we will take a deeper look
    at it in the next chapter):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从目录、文件或字面值创建配置映射。以下命令展示了每种配置映射定义的示例。这些命令在 shell 中通过 `kubectl` 可执行文件运行（我们将在下一章深入探讨它）：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To consume a ConfigMap in a pod, you can do the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Pod 中使用配置映射，你可以执行以下操作：
- en: Set environment variables from ConfigMap data
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置映射数据设置环境变量
- en: Set command-line arguments from ConfigMap data
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从配置映射数据设置命令行参数
- en: Consume ConfigMap values in volumes
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在卷中使用配置映射的值
- en: 'This following YAML file defines a Kubernetes Pod that consumes configuration
    data from a ConfigMap using environment variables and consuming it as a volume.
    Let’s see how that is done:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 YAML 文件定义了一个 Kubernetes Pod，它通过环境变量和将配置映射作为卷来使用配置数据。让我们看看如何实现：
- en: pod_with_configmap.yaml
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: pod_with_configmap.yaml
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s take a closer look at this code and understand what it’s doing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这段代码，并理解它的作用：
- en: It defines a Pod with the name `configmap-demo`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为 `configmap-demo` 的 Pod。
- en: The Pod has one container called `demo` that uses the `alpine` image.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该 Pod 有一个名为 `demo` 的容器，使用 `alpine` 镜像。
- en: 'The container has two environment variables set:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器设置了两个环境变量：
- en: '`APP_COLOR` is set from the `app.color` key in the `app-config` ConfigMap'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_COLOR` 从 `app-config` 配置映射中的 `app.color` 键设置'
- en: '`APP_MODE` is set from the `app.mode` key in the `app-config` ConfigMap (this
    is defined as an argument to the run command)'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_MODE` 从 `app-config` 配置映射中的 `app.mode` 键设置（这是作为运行命令的参数定义的）'
- en: The container has one volume mount called `config-volume` that mounts the `/``etc/config`
    path.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器有一个名为 `config-volume` 的卷挂载，它挂载了 `/etc/config` 路径。
- en: The Pod defines a volume called `config-volume` that uses the `app-config` ConfigMap
    as a data source. This makes the data from the ConfigMap available to the container
    on the mount path.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该 Pod 定义了一个名为 `config-volume` 的卷，使用 `app-config` 配置映射作为数据源。这使得来自配置映射的数据在挂载路径上对容器可用。
- en: Although ConfigMaps are really useful, they don’t provide secrecy for confidential
    data. For that, Kubernetes provides Secrets.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管配置映射非常有用，但它们并不为机密数据提供保密性。为此，Kubernetes 提供了秘密（Secrets）。
- en: Secrets
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密（Secrets）
- en: A Secret is an object that contains a small amount of sensitive data such as
    passwords, tokens, or keys. Secrets allow you to store and manage this sensitive
    data without exposing it in your application code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密是一个对象，包含少量敏感数据，如密码、令牌或密钥。秘密允许你存储和管理这些敏感数据，而不会将其暴露在应用程序代码中。
- en: 'For example, you can create a Secret from literal values using `kubectl`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `kubectl` 从字面值创建一个秘密：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code would create a Secret containing confidential database credentials.
    You can also create Secrets from files or directories:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将创建一个包含机密数据库凭据的Secret。你还可以从文件或目录创建Secrets：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Secrets store data encoded in `base64` format. This prevents the values from
    being exposed as `plaintext` in `etcd`. However, the data is not encrypted. You
    can consume your secret data from pods like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets以`base64`格式存储数据。这可以防止值在`etcd`中以`plaintext`（明文）形式暴露。然而，这些数据并没有被加密。你可以通过以下方式从Pod中获取机密数据：
- en: pod_with_secrets.yaml
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: pod_with_secrets.yaml
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding YAML file defines a Kubernetes Pod that consumes secrets from
    the Kubernetes API. Let’s go through the code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的YAML文件定义了一个从Kubernetes API获取机密的Kubernetes Pod。我们来看看这段代码：
- en: It defines a Pod named `secret-demo`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为`secret-demo`的Pod。
- en: The Pod has one container named `demo` based on the NGINX image.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该Pod有一个名为`demo`的容器，基于NGINX镜像。
- en: 'The container has three environment variables that get their values from secrets:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器有三个环境变量，它们的值来自机密：
- en: '`DB_HOST` gets its value from the `DB_HOST` key in the `db-secret` secret'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_HOST`的值来自`db-secret`秘密中的`DB_HOST`键。'
- en: '`DB_USER` gets its value from the `DB_USER` key in the `db-secret` secret'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_USER`的值来自`db-secret`秘密中的`DB_USER`键。'
- en: '`DB_PASSWORD` gets its value from the `DB_PASSWORD` key in the `db-secret`
    secret'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_PASSWORD`的值来自`db-secret`秘密中的`DB_PASSWORD`键。'
- en: The container mounts a volume called `secrets-volume` at the `/etc/secrets`
    path. This volume is read-only.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器在`/etc/secrets`路径挂载了一个名为`secrets-volume`的卷。该卷为只读。
- en: The `secrets-volume` volume uses the `app-secret` secret as its backing store.
    So, any keys/values in `app-secret` will be exposed as files in `/etc/secrets`
    in the container.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secrets-volume`卷使用`app-secret`秘密作为其存储后端。因此，`app-secret`中的任何键/值都将作为文件暴露在容器中的`/etc/secrets`路径下。'
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the fundamental architecture and components that
    make up a Kubernetes cluster. Understanding the control plane, nodes, and their
    components is crucial for operating Kubernetes effectively.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了构成Kubernetes集群的基本架构和组件。了解控制平面、节点及其组件对于有效操作Kubernetes至关重要。
- en: We looked at how the API server, etcd, controller manager, and schedulers in
    the control plane manage and maintain desired cluster state. kubelet and kube-proxy
    run on nodes to communicate with the control plane and manage containers. Getting
    familiar with these building blocks provides a mental model for how Kubernetes
    functions internally.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了控制平面中的API服务器、etcd、控制器管理器和调度器如何管理和维护期望的集群状态。kubelet和kube-proxy在节点上运行，与控制平面通信并管理容器。熟悉这些构建块有助于建立一个关于Kubernetes内部运作的心智模型。
- en: We also explored the main API resources used to deploy and manage applications,
    including Pods, Deployments, StatefulSets, Jobs, and Services. Pods encapsulate
    containers and provide networking and storage for closely related containers.
    Deployments and StatefulSets allow declarative management of pod replicas and
    provide self-healing capabilities. Jobs enable batch workloads to run to completion.
    Services enable loose coupling between pods and provide stable networking.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了用于部署和管理应用程序的主要API资源，包括Pods、Deployments、StatefulSets、Jobs和Services。Pods封装了容器，并为紧密相关的容器提供网络和存储。Deployments和StatefulSets允许声明式地管理Pod副本，并提供自我修复能力。Jobs使得批量工作负载能够执行完毕。Services实现了Pods之间的松耦合，并提供稳定的网络。
- en: We discussed how ingress resources and ingress controllers configure external
    access to cluster services through routing rules. The new Gateway API provides
    a centralized way to manage ingress configuration. PersistentVolumes and PersistentVolumeClaims
    allow portable, network-attached storage to be provisioned and consumed efficiently.
    StorageClasses enable different classes of storage to be offered.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了ingress资源和ingress控制器如何通过路由规则配置对集群服务的外部访问。新的Gateway API提供了一种集中式的方式来管理ingress配置。PersistentVolumes和PersistentVolumeClaims允许有效地配置和消费可移植的网络附加存储。StorageClasses使得不同类别的存储可以被提供。
- en: Finally, we looked at how ConfigMaps and Secrets allow configuration data and
    sensitive data to be injected into pods in a decoupled manner. Overall, these
    API resources provide powerful abstractions for deploying and managing applications
    robustly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了ConfigMaps和Secrets如何以解耦的方式将配置信息和敏感数据注入到Pods中。总体而言，这些API资源为应用程序的部署和管理提供了强大的抽象。
- en: Learning these fundamental concepts equips you to use Kubernetes effectively.
    You now understand how a cluster is put together, how applications can be deployed
    and managed in line with the desired state, and how the supporting resources including
    storage, configuration, and secrets work. This critical foundation enables you
    to start deploying applications on Kubernetes and leverage its automation capabilities
    for self-healing, scaling, and management. The knowledge gained in this chapter
    will be indispensable as we move forward.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这些基础概念使你能够有效地使用 Kubernetes。你现在明白了集群是如何构建的，应用程序如何根据所需状态进行部署和管理，以及包括存储、配置和秘密在内的支持资源是如何工作的。这些关键基础知识使你能够开始在
    Kubernetes 上部署应用程序，并利用其自动化功能进行自愈、扩展和管理。本章获得的知识在我们继续前进时将是必不可少的。
- en: In the next chapter, we will do some hands-on exercises with Kubernetes to apply
    all the concepts that we studied here.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将通过一些动手练习使用 Kubernetes，来应用我们在这里学习的所有概念。
