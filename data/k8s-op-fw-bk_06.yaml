- en: '*Chapter 4*: Developing an Operator with the Operator SDK'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：使用 Operator SDK 开发 Operator'
- en: With a completed design outline for an **Operator**, it is now possible to begin
    the actual work of developing it. This means writing and compiling code that can
    be deployed onto an actual running **Kubernetes cluster**. For this chapter, the
    **Operator SDK** will be used to initialize the scaffolding of a boilerplate Operator
    project. From there, the technical steps to develop the rest of a basic Operator
    will be demonstrated as a tutorial. This guide will follow the Operator design
    already planned in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050), *Designing
    an Operator – CRD, API, and Target Reconciliation*, which focused on developing
    a *Level II* Operator to deploy and upgrade a simple **Nginx Pod**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了**Operator**的设计大纲之后，现在可以开始实际的开发工作了。这意味着编写并编译代码，将其部署到实际运行的**Kubernetes 集群**上。本章将使用**Operator
    SDK**来初始化一个模板化的 Operator 项目框架。从这里开始，将通过教程演示开发其余基本 Operator 的技术步骤。本指南将遵循在[*第 3
    章*](B18147_03_ePub.xhtml#_idTextAnchor050)中已规划的 Operator 设计，*设计一个 Operator – CRD、API
    和目标调和*，该章聚焦于开发一个*二级* Operator 来部署和升级一个简单的**Nginx Pod**。
- en: 'As a tutorial, this chapter will follow the process for building an Operator
    from scratch with **Go**. Beginning with the initialization of boilerplate project
    code, the guide will then follow through the steps of defining the Operator API
    and generating the corresponding **CustomResourceDefinition** (**CRD**). Then,
    we will see how to implement simple reconciliation logic that makes up the core
    functionality of the Operator. Finally, some basic troubleshooting and common
    issues will be addressed. The steps for developing an Operator with Operator SDK
    will be broken down into the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为教程，将遵循从头开始使用**Go**构建 Operator 的过程。首先是初始化模板化项目代码，然后按步骤定义 Operator API，并生成相应的**CustomResourceDefinition**（**CRD**）。接下来，我们将看到如何实现构成
    Operator 核心功能的简单调和逻辑。最后，还会介绍一些基本的故障排除和常见问题。使用 Operator SDK 开发 Operator 的步骤将分为以下几个部分：
- en: Setting up your project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的项目
- en: Defining an API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 API
- en: Adding resource manifests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加资源清单
- en: Writing a control loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写控制循环
- en: Troubleshooting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除
- en: These sections follow roughly the design pattern that is recommended in the
    official Operator SDK Go documentation ([https://sdk.operatorframework.io/docs/building-operators/golang/](https://sdk.operatorframework.io/docs/building-operators/golang/)),
    which is why we have chosen to follow this approach. At the end of this chapter,
    we will have an Operator that covers the Level II functionality described in the
    design that was outlined in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*. This functionality
    includes basic deployment of the Operand (in this case, Nginx) and seamless upgrades
    of the Operator and Operand. In later chapters, this guide will be built upon
    as a foundation for adding more complex functionality that graduates this sample
    Operator from lower to higher levels along the Capability Model.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节大致遵循官方 Operator SDK Go 文档中推荐的设计模式（[https://sdk.operatorframework.io/docs/building-operators/golang/](https://sdk.operatorframework.io/docs/building-operators/golang/)），因此我们选择遵循这种方法。在本章结束时，我们将拥有一个符合设计中描述的二级功能的
    Operator，该设计已在[*第 3 章*](B18147_03_ePub.xhtml#_idTextAnchor050)中概述，*设计一个 Operator
    – CRD、API 和目标调和*。该功能包括操作数（在此为 Nginx）的基本部署，以及 Operator 和操作数的无缝升级。在后续章节中，本指南将以此为基础，构建更多复杂的功能，使该示例
    Operator 从较低级别逐步向更高级别发展，符合能力模型。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The guided steps in this chapter will require the following technical prerequisites
    to follow along:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的引导步骤需要以下技术前提条件才能跟进：
- en: '`go` version 1.16+'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go` 版本 1.16+'
- en: An `operator-sdk` binary installed locally
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地安装 `operator-sdk` 二进制文件
- en: The `operator-sdk` binary can be installed either directly from a release, with
    Homebrew (for macOS), or compiled from GitHub from [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk).
    If choosing to install the Operator SDK from GitHub, `git` will also be required;
    however, it is recommended to use `git` anyway to take advantage of version control
    for the project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过直接从发布版本安装`operator-sdk`二进制文件，或者使用 Homebrew（适用于 macOS）进行安装，或从 GitHub 编译安装，网址为
    [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)。如果选择从
    GitHub 安装 Operator SDK，还需要`git`，不过建议还是使用`git`，以便利用版本控制管理项目。
- en: 'The Code in Action video for this chapter can be viewed at: [https://bit.ly/3N7yMDY](https://bit.ly/3N7yMDY)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的《代码实战》视频可以在以下链接观看：[https://bit.ly/3N7yMDY](https://bit.ly/3N7yMDY)
- en: Setting up your project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'The first step in starting a fresh Operator project is to initialize an empty
    project structure. First, create an empty project directory with `mkdir nginx-operator`
    and `cd` into it. Now, initialize a boilerplate project structure with the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的 Operator 项目的第一步是初始化一个空的项目结构。首先，通过 `mkdir nginx-operator` 创建一个空的项目目录并进入该目录。现在，使用以下命令初始化一个模板项目结构：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This command may take a few moments to complete the first time it is run.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令首次运行时可能需要几分钟才能完成。
- en: 'This command sets up a lot of different files and folders that will be filled
    in with the custom APIs and logic for the Operator we are building. The once-empty
    project directory should now contain the following files:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令设置了许多不同的文件和文件夹，这些文件和文件夹将被填充上我们正在构建的 Operator 的自定义 API 和逻辑。曾经空无一物的项目目录现在应该包含以下文件：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The purposes of these files are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的用途如下：
- en: '`config` – A directory that holds YAML definitions of Operator resources.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config` – 一个存放 Operator 资源 YAML 定义的目录。'
- en: '`hack` – A directory that is used by many projects to hold various `hack` scripts.
    These are scripts that can serve a variety of purposes but are often used to generate
    or verify changes (often employed as part of a continuous integration process
    to ensure code is properly generated before merging).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hack` – 一个目录，许多项目都用它来存放各种 `hack` 脚本。这些脚本可以用于多种用途，但通常用于生成或验证更改（通常作为持续集成过程的一部分，确保在合并之前代码已正确生成）。'
- en: '`.dockerignore` / `.gitignore` – Declarative lists of files to be ignored by
    Docker builds and Git, respectively.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dockerignore` / `.gitignore` – 用于声明在 Docker 构建和 Git 操作中应忽略的文件列表。'
- en: '`Dockerfile` – Container image build definitions.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile` – 容器镜像构建定义。'
- en: '`Makefile` – Operator build definitions.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile` – Operator 构建定义。'
- en: '`PROJECT` – File used by Kubebuilder to hold project config information ([https://book.kubebuilder.io/reference/project-config.html](https://book.kubebuilder.io/reference/project-config.html)).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT` – Kubebuilder 使用的文件，用于存储项目配置文件信息 ([https://book.kubebuilder.io/reference/project-config.html](https://book.kubebuilder.io/reference/project-config.html))。'
- en: '`go.mod` / `go.sum` – Dependency management lists for `go mod` (already populated
    with various Kubernetes dependencies).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.mod` / `go.sum` – `go mod` 的依赖管理列表（已经填充了各种 Kubernetes 依赖项）。'
- en: '`main.go` – The entry point file for the Operator''s main functional code.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.go` – Operator 主功能代码的入口文件。'
- en: With this boilerplate project structure initialized, it is possible to start
    building Operator logic on top. While this bare project will compile, it doesn't
    do much besides start an empty controller with `Readyz` and `Healthz` endpoints.
    To get it to do a little more, first, the Operator must have a defined API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化了这个模板项目结构后，就可以开始构建 Operator 逻辑了。尽管这个空项目可以编译，但它除了启动一个包含 `Readyz` 和 `Healthz`
    端点的空控制器外没有其他功能。为了让它做更多的事情，首先，Operator 必须有一个定义好的 API。
- en: Defining an API
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 API
- en: The Operator's API will be the definition of how it is represented within a
    Kubernetes cluster. The API is directly translated to a generated CRD, which describes
    the blueprint for the custom resource object that users will consume to interact
    with the Operator. Therefore, creating this API is a necessary first step before
    writing other logic for the Operator. Without this, there will be no way for the
    Operator's logic code to read values from the custom resource.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Operator 的 API 将定义它在 Kubernetes 集群中的表现方式。API 会直接转换为生成的 CRD，描述用户与 Operator 交互时使用的自定义资源对象的蓝图。因此，在编写其他逻辑之前，创建此
    API 是必要的第一步。没有它，Operator 的逻辑代码就无法从自定义资源中读取值。
- en: 'Building an Operator API is done by writing a Go struct to represent the object.
    The basic outline of this struct can be scaffolded by the Operator SDK with the
    following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Operator API 需要通过编写 Go 结构体来表示对象。这个结构体的基本框架可以通过 Operator SDK 使用以下命令来生成：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command does the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令执行以下操作：
- en: Creates the API types in a new directory called `api/`
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `api/` 的新目录中创建 API 类型
- en: Defines these types as belonging to the API group `operator.example.com` (since
    we initialized the project under the domain `example.com`)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些类型定义为属于 API 组 `operator.example.com`（因为我们是在 `example.com` 域下初始化的项目）。
- en: Creates the initial version of the API named `v1alpha1`
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `v1alpha1` 的 API 初始版本
- en: Names these types after our Operator, `NginxOperator`
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些类型命名为我们的 Operator，`NginxOperator`。
- en: Instantiates boilerplate controller code under a new directory called `controllers/`
    (which we will work with more under *Writing a control loop*)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为 `controllers/` 的新目录下实例化模板控制器代码（我们将在 *编写控制循环* 部分进一步操作此目录）。
- en: Updates `main.go` to add boilerplate code for starting the new controller
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `main.go`，添加启动新控制器的模板代码。
- en: For now, we are only concerned with the API types under `api/v1alpha1/nginxoperator_types.go`.
    There are two other files in this directory (`groupversion_info.go` and `zz_generated.deepcopy.go`)
    that do not usually need to be modified. In fact, the `zz_generated.` prefix is
    used as a standard to denote generated files that should never be manually modified.
    The `groupversion_info.go` file is used to define package variables for this API
    that instruct clients how to handle objects from it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只关心位于 `api/v1alpha1/nginxoperator_types.go` 下的 API 类型。该目录中还有另外两个文件（`groupversion_info.go`
    和 `zz_generated.deepcopy.go`），通常不需要修改。实际上，`zz_generated.` 前缀是用作标准，表示这些是生成的文件，应该避免手动修改。`groupversion_info.go`
    文件用于定义该 API 的包变量，指导客户端如何处理其中的对象。
- en: 'Looking at `nginxoperator_types.go`, there are already some empty structs with
    instructions to fill in additional fields. The three most important types in this
    file are `NginxOperator`, `NginxOperatorSpec`, and `NginxOperatorStatus`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `nginxoperator_types.go`，里面已经有一些空的结构体，并且有填写额外字段的说明。该文件中最重要的三种类型是 `NginxOperator`、`NginxOperatorSpec`
    和 `NginxOperatorStatus`：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As discussed in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050), *Designing
    an Operator – CRD, API, and Target Reconciliation*, all Kubernetes API objects
    should have `Spec` and `Status` fields, and Operators are no different. Therefore,
    `NginxOperatorSpec` and `NginxOperatorStatus` are those fields, which will be
    used to accept user input and report on the current state of the Operator, respectively.
    With `NginxOperator` representing the main object, the relationship between the
    three is hierarchical.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [*第 3 章*](B18147_03_ePub.xhtml#_idTextAnchor050) 所述，*设计 Operator – CRD、API
    和目标对账*，所有 Kubernetes API 对象都应包含 `Spec` 和 `Status` 字段，Operator 也不例外。因此，`NginxOperatorSpec`
    和 `NginxOperatorStatus` 就是这些字段，分别用于接受用户输入和报告 Operator 当前状态。`NginxOperator` 代表主要对象，它们之间的关系是层级性的。
- en: '![Figure 4.1 – The relationship between NginxOperator fields and logic](img/B18147_04_001.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – NginxOperator 字段与逻辑之间的关系](img/B18147_04_001.jpg)'
- en: Figure 4.1 – The relationship between NginxOperator fields and logic
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – NginxOperator 字段与逻辑之间的关系。
- en: 'Recalling the problem definition from [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*, this Operator needs
    to accept the following inputs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [*第 3 章*](B18147_03_ePub.xhtml#_idTextAnchor050) 中定义的问题，*设计 Operator –
    CRD、API 和目标对账*，该 Operator 需要接受以下输入：
- en: '`port`, which will define the port number to expose on the Nginx Pod'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`port`，定义了要在 Nginx Pod 上暴露的端口号。'
- en: '`replicas`, which defines the number of Pod replicas in order to allow scaling
    of this deployment through the Operator'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`replicas`，定义了 Pod 副本的数量，以便通过 Operator 实现该部署的扩展。'
- en: '`forceRedploy`, which is a `Nginx` Operand'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`forceRedploy`，这是一个 `Nginx` 操作数。'
- en: 'To implement these fields, we need to update the preceding code to modify `NginxOperatorSpec`
    with these new fields, as in the following. We are using pointers for the integer
    fields so that our Operator will be able to distinguish between a zero-value and
    an unset value, which should fall back to using a defined default:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些字段，我们需要更新前面的代码，通过以下方式修改 `NginxOperatorSpec` 以包含这些新字段。我们为整数类型的字段使用指针，这样我们的
    Operator 可以区分零值和未设置值，未设置值将回退为使用默认值：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: (Note, we also removed the sample `Foo` field that was generated by the Operator
    SDK as an example.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，我们还移除了由 Operator SDK 生成的示例 `Foo` 字段。）
- en: Regenerating Code
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重新生成代码。
- en: Once the Operator types have been modified, it is sometimes necessary to run
    `make generate` from the project root. This updates generated files, such as the
    previously mentioned `zz_generated.deepcopy.go`. It is good practice to develop
    the habit of regularly running this command whenever making changes to the API,
    even if it does not always produce any changes. It is even better practice to
    add pre-submit continuous integration checks to the Operator's repository to ensure
    that any incoming code includes these generated changes. Such an automated check
    can be implemented by running `make generate` followed by a simple `git diff`
    command to assess whether any changes have appeared. If so, the check should fail
    and instruct the developer to regenerate their code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦修改了 Operator 类型，有时需要从项目根目录运行 `make generate`。这将更新生成的文件，例如前面提到的 `zz_generated.deepcopy.go`。即使它不总是产生任何变化，养成在每次修改
    API 时定期运行此命令的习惯是一个好做法。更好的做法是，在 Operator 的代码库中添加预提交的持续集成检查，以确保任何传入的代码都包含这些生成的更改。这样的自动化检查可以通过运行
    `make generate` 然后执行简单的 `git diff` 命令来评估是否有任何变化。如果有变化，检查应失败并指导开发人员重新生成代码。
- en: For all three new fields, we have also added JSON tags in the form of `` `json:"...,omitempty"`
    ``. The first part of each of these tags defines how the field will appear when
    represented in JSON or YAML (when interacting with the object through `kubectl,`
    for example). `omitempty` specifies that if this field is empty, it should not
    show up in JSON output. This is good for hiding optional fields in order to provide
    a concise output when viewing the objects in the cluster (otherwise, empty fields
    will appear as nil or with an empty string).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这三个新字段，我们还添加了以`` `json:"...,omitempty"` ``形式表示的 JSON 标签。这些标签的第一部分定义了该字段在以
    JSON 或 YAML 表示时的显示方式（例如，当通过 `kubectl` 与对象交互时）。`omitempty` 指定如果该字段为空，则不应在 JSON
    输出中显示。这对于隐藏可选字段非常有用，以便在查看集群中的对象时提供简洁的输出（否则，空字段将显示为 nil 或空字符串）。
- en: 'We are going to initially make all three of these fields optional, with default
    values defined in the Operator. However, they could be designated as required
    with the removal of `omitempty` and the addition of more Kubebuilder tags, for
    example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最初将这三个字段都设置为可选，默认值在 Operator 中定义。然而，删除 `omitempty` 并添加更多 Kubebuilder 标签后，它们也可以被指定为必填字段，例如：
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With these settings, any attempt to modify an `NginxOperator` object without
    including the `port` field will result in an error from the API server. In current
    versions of Kubebuilder, the default assumption is that any field that is not
    designated as `omitempty` is required. However, there are ways to switch this
    default globally (with the `// +kubebuilder:validation:Optional` marker applied
    to the top level of an API). Therefore, whenever changing the requirement of a
    field, it is good practice to explicitly update that field's specific requirement
    value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，任何尝试在不包含 `port` 字段的情况下修改 `NginxOperator` 对象的操作都将导致 API 服务器返回错误。在当前版本的
    Kubebuilder 中，默认假设任何未被标记为 `omitempty` 的字段都是必填字段。然而，也有方法可以全局切换这个默认行为（通过在 API 顶层应用
    `// +kubebuilder:validation:Optional` 标记）。因此，每次更改字段的要求时，最好明确更新该字段的具体要求值。
- en: With the API types defined, it is now possible to generate an equivalent CRD
    manifest, which will be used to create objects matching these types in a Kubernetes
    cluster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 API 类型后，现在可以生成一个等效的 CRD 清单，之后将用于在 Kubernetes 集群中创建与这些类型匹配的对象。
- en: Adding resource manifests
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加资源清单
- en: 'The relevant resources for an Operator are important to package in a way that
    can be easily deployed and maintained. This includes the Operator''s CRD, but
    also other resources such as **ClusterRoles** and the matching **ServiceAccount**
    for those Roles. However, the first step is to generate a CRD from the Go types
    defined in the previous section with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Operator 相关资源，重要的是将它们打包成易于部署和维护的形式。这包括 Operator 的 CRD，但也包括其他资源，如 **ClusterRoles**
    以及与这些角色匹配的 **ServiceAccount**。然而，第一步是根据前一部分定义的 Go 类型生成一个 CRD，使用以下内容：
- en: '[PRE38]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This command generates a CRD that is based on the API we just defined. That
    CRD is placed under `config/crd/bases/operator.example.com_nginxoperators.yaml`.
    That CRD looks as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成一个基于我们刚才定义的 API 的 CRD。该 CRD 被放置在 `config/crd/bases/operator.example.com_nginxoperators.yaml`
    下。该 CRD 如下所示：
- en: '[PRE39]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: (In this output, we have added additional formatting to more clearly represent
    longer strings, such as field descriptions, and highlighted the three fields that
    were added to the API.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: （在此输出中，我们添加了额外的格式，以更清晰地表示较长的字符串，如字段描述，并突出显示了添加到 API 中的三个字段。）
- en: This CRD is fairly simple due to the basic structure of the Operator, but even
    that is a testament to the natural complexity of OpenAPI validation schemas. That
    complexity emphasizes the point that CRD manifests should always be generated
    and not manually edited.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Operator 的基本结构，CRD 相对简单，但这也证明了 OpenAPI 验证架构的固有复杂性。这种复杂性强调了 CRD 清单应该始终通过生成方式创建，而不是手动编辑。
- en: Customizing Generated Manifests
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定制生成的清单
- en: The default command for generating manifests creates a complex validation schema
    that should not be edited by hand. However, the underlying command for `make manifests`
    is actually calling an additional tool, `controller-gen` manually is an acceptable
    way to generate files and code in non-default ways. For example, the `controller-gen
    schemapatch` command will regenerate only the OpenAPI validation schema for a
    CRD. This can be useful if you wish to manually modify other parts of the CRD,
    which would be overwritten with a full regeneration, such as additional annotations
    or labels. The full list of commands can be found by installing `controller-gen`
    from the previously mentioned repository and running it with `controller-gen -h`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的生成清单命令会创建一个复杂的验证架构，通常不应手动编辑。不过，`make manifests` 的底层命令实际上是调用一个额外的工具，手动使用 `controller-gen`
    是以非默认方式生成文件和代码的可接受方法。例如，`controller-gen schemapatch` 命令将只重新生成 CRD 的 OpenAPI 验证架构。如果你希望手动修改
    CRD 的其他部分（例如附加的注释或标签），这将非常有用，因为这些修改会被完全重生成的操作覆盖。可以通过从之前提到的仓库安装 `controller-gen`
    并使用 `controller-gen -h` 运行它来查看完整的命令列表。
- en: 'The `make manifests` command also creates a corresponding **Role-Based Access
    Control** (**RBAC**) role with can be bound to the Operator''s ServiceAccount
    to give the Operator access to their own custom object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`make manifests` 命令还会创建一个相应的 **基于角色的访问控制** (**RBAC**) 角色，可以将该角色绑定到 Operator
    的 ServiceAccount，以便为 Operator 提供访问其自定义对象的权限：'
- en: 'config/rbac/role.yaml:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: config/rbac/role.yaml：
- en: '[PRE112]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: This Role grants full access to create, delete, get, list, patch, update, and
    watch all `nginxoperator` objects in the cluster. It is generally not a best practice
    for an Operator to manage the life cycle of their own custom resource object (for
    example, creation of the `config` object is best left to a manual action by the
    user), so some of the verbs, such as `create` and `delete`, are not strictly necessary
    here. However, we will leave them for now.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色授予对集群中所有 `nginxoperator` 对象的完整访问权限，包括创建、删除、获取、列出、修补、更新和监视。通常，不建议 Operator
    管理其自定义资源对象的生命周期（例如，`config` 对象的创建最好由用户手动操作），因此一些动词，如 `create` 和 `delete`，在这里并非严格必要。不过，我们暂时保留它们。
- en: Additional manifests and BinData
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他清单和二进制数据
- en: The remaining resource manifests that will need to be created include the Operator's
    `ClusterRole` and the Nginx Deployment definition. The `ClusterRole` can be conveniently
    generated with Kubebuilder tags in the code, which will be done later in the *Writing
    a control loop* section. Before that, the Deployment should be defined so that
    the control loop has access to it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建的其他资源清单包括 Operator 的 `ClusterRole` 和 Nginx 部署定义。`ClusterRole` 可以通过代码中的 Kubebuilder
    标签方便地生成，这将在稍后的 *编写控制循环* 部分中完成。在此之前，应定义部署，以便控制循环能够访问它。
- en: 'One way to define in-memory resources, such as the Deployment, is by creating
    them in the code. Many projects take such an approach, including the official
    example projects available at [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk).
    For the purpose of this Nginx Deployment, the approach would involve creating
    a function similar to the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 定义内存资源（例如部署）的一种方法是通过在代码中创建它们。许多项目采用这种方法，包括在 [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)
    上提供的官方示例项目。对于这个 Nginx 部署，方法将涉及创建一个类似于以下的函数：
- en: '[PRE144]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The preceding function returns a static Deployment Go struct, with default values
    prepopulated, such as the Deployment name and exposed port. This object could
    then be modified based on the specifications set in the Operator CRD before using
    a Kubernetes API client to update the Deployment in the cluster (for example,
    to update the number of replicas).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数返回一个静态的 Deployment Go 结构体，预填充了默认值，如 Deployment 名称和暴露的端口。然后可以根据 Operator
    CRD 中设置的规范修改该对象，再通过 Kubernetes API 客户端更新集群中的 Deployment（例如，更新副本数）。
- en: As discussed in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050), *Designing
    an Operator – CRD, API, and Target Reconciliation*, this approach is easy to code
    because the resource struct is immediately available as a Go type. However, in
    terms of maintainability and usability, there are better options. This is where
    tools such as **go-bindata** and **go:embed** are helpful.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 [*第 3 章*](B18147_03_ePub.xhtml#_idTextAnchor050) 中讨论的，*设计一个操作符 – CRD、API
    和目标协调*，这种方法易于编写代码，因为资源结构体可以直接作为 Go 类型使用。然而，从可维护性和可用性角度来看，仍然有更好的选择。这就是 **go-bindata**
    和 **go:embed** 等工具的作用。
- en: Using go-bindata and go:embed to access resources
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 go-bindata 和 go:embed 访问资源
- en: The go-bindata project is available on GitHub at [https://github.com/go-bindata/go-bindata](https://github.com/go-bindata/go-bindata).
    It works by converting arbitrary files into Go code, which is then compiled into
    the main program and available in memory. The benefit of using go-bindata is that
    project resources can be more concisely managed and maintained in a more readable
    format such as YAML, which provides familiarity with native Kubernetes resource
    creation. Since Go 1.16, the language has included its own compiler directive,
    `go:embed`, to essentially perform the same function; however, we will provide
    an example of both approaches for the benefit of users who have not yet updated
    to Go 1.16 or who wish to avoid reliance on compiler-specific directives in their
    development and production environments.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: go-bindata 项目可以在 GitHub 上找到，网址是 [https://github.com/go-bindata/go-bindata](https://github.com/go-bindata/go-bindata)。它通过将任意文件转换为
    Go 代码，随后将其编译到主程序中并在内存中使用。使用 go-bindata 的好处在于，项目资源可以更简洁地管理，并以更易读的格式（如 YAML）维护，从而提供与原生
    Kubernetes 资源创建的相似性。自 Go 1.16 起，语言已包含自己的编译器指令 `go:embed`，本质上执行相同的功能；然而，为了方便尚未更新到
    Go 1.16 或希望避免在开发和生产环境中依赖编译器特定指令的用户，我们将提供两种方法的示例。
- en: 'The first step for either approach is to create the resource manifests in a
    directory, such as `assets/nginx_deployment.yaml`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方法，第一步是将资源清单创建在一个目录中，例如 `assets/nginx_deployment.yaml`：
- en: '[PRE170]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This structure is already much easier to work with than the native Go types
    by saving us from having to define each embedded type (such as `map[string]string`
    for the labels and Pod command). It can also be easily parsed by continuous integration
    checks to ensure it maintains a valid structure.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构比原生 Go 类型更容易使用，因为它让我们无需为每个嵌入的类型（如 `map[string]string` 用于标签和 Pod 命令）定义类型。它还可以被持续集成检查轻松解析，以确保它保持有效的结构。
- en: The next two subsections will demonstrate the basic concepts of implementing
    either `go-bindata` or `go:embed`. These examples will do so by showing how you
    could add the foundational concepts for each approach. However, we will ultimately
    refactor most of the code in the section titled *Simplifying resource embedding*;
    therefore, you may choose not to write any of this code yourself until reaching
    the refactoring subsection.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个小节将演示实现 `go-bindata` 或 `go:embed` 的基本概念。这些示例将展示如何为每种方法添加基础概念。然而，我们最终将在
    *简化资源嵌入* 小节中重构大部分代码；因此，您可以选择在达到重构小节之前不编写任何这些代码。
- en: Go 1.15 and older – go-bindata
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 1.15 及更早版本 – go-bindata
- en: 'For older versions of Go, you must install the `go-bindata` package from GitHub
    to generate your files:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧版本的 Go，您必须从 GitHub 安装 `go-bindata` 包来生成您的文件：
- en: '[PRE191]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The generated code that contains the manifests can then be created with the
    following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用以下命令创建包含清单的生成代码：
- en: '[PRE192]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'This command will create an `assets.go` file under the `assets/` directory
    that contains generated functions and in-memory representations of the files in
    the `assets/` directory. Note that it can be easier to keep the assets themselves
    in a different directory than the generated code, as re-running the `go-bindata`
    command will now include a representation of the `assets.go` file itself unless
    it is excluded, like so:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在`assets/`目录下创建一个`assets.go`文件，其中包含生成的函数以及`assets/`目录中文件的内存表示。请注意，将资产文件与生成的代码放在不同目录下可能更方便，因为重新运行`go-bindata`命令时，除非排除，否则现在会包含`assets.go`文件本身的表示，方法如下：
- en: '[PRE193]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: This file will need to be re-generated whenever modifications are made to the
    underlying assets. Doing so will ensure the changes are made available in the
    compiled assets package that includes the accessibility functions for the files.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每次对底层资产进行修改时，都需要重新生成此文件。这样可以确保更改被应用到编译后的资产包中，该包包括对文件的访问功能。
- en: 'Once the assets have been generated, they can be accessed in code by importing
    the new `assets` package and using the `Asset()` function like so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 生成资产后，可以通过导入新的`assets`包并使用`Asset()`函数在代码中访问它们，方法如下：
- en: '[PRE194]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: For newer versions of Go (1.16 and above), it is even simpler to compile resource
    manifests into assets.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较新的Go版本（1.16及以上），编译资源清单为资产变得更加简单。
- en: Go 1.16 and newer – go:embed
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 1.16及更新版本 — `go:embed`
- en: The `go:embed` marker was included as a compiler directive in Go 1.16 to provide
    native resource embedding without the need for external tools such as go-bindata.
    To start with this approach, create the resource manifest files similarly to the
    go-bindata setup under a new directory called `assets/`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`go:embed`标记作为编译指令在Go 1.16中被加入，用于提供原生资源嵌入，而无需像go-bindata这样的外部工具。要使用这种方法，首先在名为`assets/`的新目录下创建与go-bindata设置类似的资源清单文件。'
- en: 'Next, the `main.go` file for the Operator project needs to be modified to import
    the `embed` package and declare the asset manifests as a variable like so (all
    of the following code in this section shows only the changes that you need to
    make):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要修改Operator项目的`main.go`文件，导入`embed`包，并声明资产清单作为变量，如下所示（以下所有代码仅显示需要进行的更改）：
- en: '[PRE200]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Note the `//go:embed` comment, which tells the compiler to store the contents
    of `assets/nginx_deployment.yaml` as filesystem data in the `deployment` variable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`//go:embed`注释，它告诉编译器将`assets/nginx_deployment.yaml`的内容作为文件系统数据存储在`deployment`变量中。
- en: 'The data can then be read and converted to a Deployment Go struct by utilizing
    the Kubernetes API scheme declarations like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以通过利用Kubernetes API架构声明将数据读取并转换为Deployment Go结构体，如下所示：
- en: '[PRE208]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'This code does a few things:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了几件事：
- en: 'It imports the relevant Kubernetes API packages that define the schema for
    Deployment API objects:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它导入了相关的Kubernetes API包，这些包定义了Deployment API对象的架构：
- en: '[PRE234]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'It initializes a `Scheme` and a set of codecs that can be used by the API''s
    UniversalDecoder in order to know how to convert the `[]byte` data representation
    of the file to a Go struct:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它初始化一个`Scheme`和一组编解码器，供API的UniversalDecoder使用，以便知道如何将文件的`[]byte`数据表示转换为Go结构体：
- en: '[PRE235]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'It uses the `deployment` variable we declared earlier (as part of setting up
    the `embed` directive) to read the `Deployment` file under `assets/nginx_deployment.yaml`
    (highlighted):'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用我们之前声明的`deployment`变量（作为设置`embed`指令的一部分）来读取`assets/nginx_deployment.yaml`文件（如高亮所示）：
- en: '[PRE236]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'It decodes the `[]byte` data returned from `deployment.ReadFile()` into an
    object that can be cast to the Go type for Deployments:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将`deployment.ReadFile()`返回的`[]byte`数据解码为一个可以转换为Go类型的Deployment对象：
- en: '[PRE237]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'It casts the object data to an in-memory representation of `*appsv1.Deployment`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将对象数据转换为`*appsv1.Deployment`的内存表示：
- en: '[PRE238]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: From this point, it will be necessary to find a way to pass the Deployment object
    to our Nginx Operator Controller. This can be done by modifying the `NginxOperatorReconciler`
    type to have a field that holds a type of `*appsv1.Deployment`. However, this
    is not convenient for all of the different types of resources the Operator will
    be managing. To simplify this and better organize the project's structure, we
    can move the resource embedding code to its own package.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们需要找到一种方法将Deployment对象传递给我们的Nginx Operator Controller。这可以通过修改`NginxOperatorReconciler`类型来实现，添加一个字段以保存`*appsv1.Deployment`类型。然而，对于Operator将要管理的各种资源类型来说，这并不方便。为了简化这一点，并更好地组织项目结构，我们可以将资源嵌入代码移到一个独立的包中。
- en: Simplifying resource embedding
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化资源嵌入
- en: 'The preceding examples showed the essential steps of embedding a YAML file
    into Go code. However, for our sample Nginx Operator, this can be better organized
    into its own package. To do this, we will keep the existing `assets/` directory
    (to use as an importable Go module path that holds helper functions for loading
    and processing the files) and place a new `manifests/` directory underneath it
    (which will hold the actual manifest files). This new file structure will look
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了将 YAML 文件嵌入 Go 代码中的基本步骤。然而，对于我们的示例 Nginx Operator，这可以更好地组织成一个独立的包。为此，我们将保留现有的
    `assets/` 目录（作为一个可导入的 Go 模块路径，用于加载和处理文件的辅助函数），并在其下创建一个新的 `manifests/` 目录（用来存放实际的清单文件）。新的文件结构如下所示：
- en: '[PRE239]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'The `assets.go` file will include the API schema initialization and wrapped
    object casting functionality from the preceding examples, like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`assets.go` 文件将包括前面示例中的 API 架构初始化和封装对象转换功能，代码如下：'
- en: '[PRE240]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'This new file makes a couple of changes from the implementation shared before:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新文件相比之前共享的实现做了一些修改：
- en: Now, the entire `manifests/` directory is embedded as a filesystem variable.
    This will make it easier to add functions to read other resources within the directory
    without having to declare new variables in this package for each one.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，整个 `manifests/` 目录作为一个文件系统变量被嵌入。这将使得在该目录中读取其他资源变得更加容易，而不需要为每个资源在这个包中声明新的变量。
- en: 'The main logic has been wrapped in a new function, `GetDeploymentFromFile()`.
    This function can be called and used by our control loop like this:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要逻辑已经被封装到一个新的函数 `GetDeploymentFromFile()` 中。我们的控制循环可以像下面这样调用并使用这个函数：
- en: '[PRE272]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: We can add other manifests to this directory so that the Operator can manage
    them (for example, additional Operand dependencies). But for now, we have enough
    to begin working on a control loop.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向这个目录添加其他清单文件，以便 Operator 管理它们（例如，额外的 Operand 依赖项）。但目前，我们已经有足够的内容开始编写控制循环了。
- en: Writing a control loop
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写控制循环
- en: With a strategy for the in-memory representation of resource manifests in place,
    it is now much easier to begin writing the Operator's control loop. As described
    in previous chapters, this control loop comprises a core state reconciliation
    function call that is triggered by certain relevant cluster events. This function
    does not run continuously on a loop, but rather the main thread of the Operator
    will be continuously observing the cluster for those events to kick off a call
    to the state reconciliation function.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立了内存中资源清单表示策略后，现在编写 Operator 的控制循环变得更容易了。正如前面章节所描述的，这个控制循环包含了一个核心的状态协调功能调用，该功能由某些相关的集群事件触发。这个功能不会持续运行，而是
    Operator 的主线程会不断观察集群，等待事件触发，从而启动状态协调函数的调用。
- en: 'The empty `Reconcile()` function has been scaffolded already by the Operator
    SDK in `controllers/nginxoperator_controller.go`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 空的 `Reconcile()` 函数已经由 Operator SDK 在 `controllers/nginxoperator_controller.go`
    中预先生成：
- en: '[PRE273]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Right now, this function does nothing but return an empty `ctrl.Result` and
    an empty `error`, which evaluates to a successful run and instructs the rest of
    the framework that there is no need to re-try this reconciliation run. If this
    function returns either a non-nil `error` or non-empty `ctrl.Result` struct, then
    the controller will instead re-queue this reconciliation attempt to be tried again.
    These cases will come up as we populate the controller's logic as indicated by
    the comment.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个函数什么都不做，只是返回一个空的 `ctrl.Result` 和一个空的 `error`，这表示成功执行，并指示框架的其余部分无需重试这个协调运行。如果该函数返回非
    `nil` 的 `error` 或非空的 `ctrl.Result` 结构，控制器则会重新排队该协调尝试，等待再次尝试。这些情况会出现在我们根据注释填写控制器逻辑时。
- en: 'Because the Operator SDK instantiates this controller with a Kubernetes client
    already accessible, we can use functions such as `Get()` to retrieve cluster resources.
    The first thing to do is to attempt to access the existing Nginx Operator resource
    object. If one is not found, we should log a message indicating so and terminate
    the reconciliation attempt. If there are any other errors retrieving the object,
    we will instead return an error, so this attempt gets re-queued and tried again.
    This approach can account for other failures, such as network issues or temporarily
    dropped connections to the API server. With these changes, the new `Reconcile()`
    function looks like the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Operator SDK 使用已经可以访问的 Kubernetes 客户端实例化此控制器，所以我们可以使用诸如`Get()`之类的函数来检索集群资源。首先要做的是尝试访问现有的
    Nginx Operator 资源对象。如果没有找到，我们应该记录一条消息并终止调和尝试。如果在检索对象时遇到任何其他错误，我们将返回错误，这样该尝试将被重新排队并再次尝试。此方法可以处理其他故障，例如网络问题或与
    API 服务器的连接暂时中断。通过这些更改，新的`Reconcile()`函数如下所示：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 'controllers/nginxoperator_controller.go:'
- en: '[PRE278]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: This error-handling pattern is common among Kubernetes projects, including examples
    from the official Operator SDK documentation. Rather than immediately returning
    the error, this code essentially ignores the case where the Operator object is
    simply not found. The `errors.IsNotFound()` check comes from the `k8s.io/apimachinery/pkg/api/errors`
    package, which provides several helper functions for a standard approach to handling
    specific Kubernetes errors. Using this pattern helps to minimize logging noise
    for the user and to ignore events where the Operator resource was deleted (which
    will still trigger a reconciliation attempt). In the event that the Operator object
    is not found, developers can go a step further and use that as a signal to take
    other steps (such as deleting other resources that depend on the Operator deployment).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误处理模式在 Kubernetes 项目中很常见，包括官方 Operator SDK 文档中的示例。与其立即返回错误，这段代码实际上忽略了 Operator
    对象简单地没有找到的情况。`errors.IsNotFound()` 检查来自`k8s.io/apimachinery/pkg/api/errors`包，该包提供了多个帮助函数，用于处理特定
    Kubernetes 错误的标准方法。使用这种模式有助于减少用户的日志噪声，并忽略删除了 Operator 资源（这仍会触发调和尝试）的事件。如果未找到 Operator
    对象，开发人员可以进一步采取措施，将其作为采取其他步骤的信号（例如删除依赖于 Operator 部署的其他资源）。
- en: 'Also, note that this code is using `req.NamespacedName` to get the `Name` and
    `Namespace` of the Operator config object. This follows one of the best practices
    laid out in the Operator Framework documentation ([https://sdk.operatorframework.io/docs/best-practices/best-practices/](https://sdk.operatorframework.io/docs/best-practices/best-practices/)):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意此代码使用`req.NamespacedName`来获取 Operator 配置对象的`Name`和`Namespace`。这符合 Operator
    框架文档中列出的最佳实践之一（[https://sdk.operatorframework.io/docs/best-practices/best-practices/](https://sdk.operatorframework.io/docs/best-practices/best-practices/)）：
- en: '*Operators shouldn''t make any assumptions about the namespace they are deployed
    in, and they should not use hardcoded names of resources that they expect to already
    exist.*'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*Operator 不应对其部署的命名空间做任何假设，也不应使用硬编码的资源名称来预期资源已经存在。*'
- en: In this case, the `req` parameter includes the name of the object event that
    triggered the reconciliation attempt. Using a consistent name across resources
    allows us to re-use the `req.NamespacedName` field in every call to `Reconcile()`,
    regardless of the object that triggered the reconciliation. In other words, if
    the Deployment has the same Name and Namespace as the Operator custom resource
    object, we can consistently eliminate the use of hardcoded assumptions for resource
    names.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`req`参数包括触发调和尝试的对象事件的名称。跨资源使用一致的名称使我们能够在每次调用`Reconcile()`时重用`req.NamespacedName`字段，而不管触发调和的对象是什么。换句话说，如果
    Deployment 与 Operator 自定义资源对象具有相同的名称和命名空间，我们可以始终消除硬编码资源名称假设的使用。
- en: 'With an Operator resource object successfully found, the controller can retrieve
    the values for each setting in the Operator''s `spec` in order to update them,
    if necessary. Similar to what we just did for the Operator resource, however,
    we must first check whether the Deployment exists. For this, we will follow a
    similar pattern utilizing `errors.IsNotFound()` to check for the non-existence
    of an Nginx Deployment. However, in this case, the function will not simply return
    if no Deployment is found, but instead the controller will create one from the
    embedded Deployment YAML file:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 成功找到 Operator 资源对象后，控制器可以获取 Operator `spec` 中每个设置的值，并根据需要进行更新。与我们刚刚为 Operator
    资源所做的类似，然而，我们必须首先检查 Deployment 是否存在。为此，我们将遵循类似的模式，利用 `errors.IsNotFound()` 来检查是否存在
    Nginx Deployment。不过，在这种情况下，如果没有找到 Deployment，函数不会直接返回，而是控制器将从嵌入的 Deployment YAML
    文件中创建一个新的 Deployment：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 'controllers/nginxoperator_controller.go:'
- en: '[PRE291]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: In this code, we are loading the embedded default manifest using the `assets.GetDeploymentFromFile()`
    function created earlier. We are also modifying that manifest declaration to include
    the values from the current Operator resource object.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们通过之前创建的 `assets.GetDeploymentFromFile()` 函数加载嵌入的默认清单文件。我们还修改了该清单声明，以包含来自当前
    Operator 资源对象的值。
- en: 'An alternative to this approach would be to create the Deployment with the
    default values, and then have the function immediately return with `ctrl.Result{Requeue:
    true}`. This would trigger another reconciliation attempt, where the Deployment
    should be found and then updated with the Operator resource settings. The trade
    - off here is the immediate creation of a new object without the need for another
    reconciliation cycle, in exchange for less atomic operation and some code duplication
    (because we will still need the following code to apply the Operator resource
    settings in the case where an existing Deployment was found). To eliminate that
    duplicate code, we can modify the preceding section like this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '这种方法的替代方案是创建一个具有默认值的 Deployment，然后让函数立即返回 `ctrl.Result{Requeue: true}`。这将触发另一次协调尝试，在该尝试中，应该能够找到
    Deployment 并根据 Operator 资源设置进行更新。这里的权衡是立即创建一个新对象，而无需另一个协调周期，换取的是操作不够原子和某些代码的重复（因为在找到现有的
    Deployment 时，我们仍然需要以下代码来应用 Operator 资源设置）。为了消除这些重复代码，我们可以像下面这样修改前面的部分：'
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'controllers/nginxoperator_controller.go:'
- en: '[PRE309]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Since the `Replicas` and `Port` fields in the Operator custom resource are optional
    (and pointers), we should use `nil` checks to see whether any value has been set.
    Otherwise, the Deployment will default to the values defined in its `manifest`
    file.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Operator 自定义资源中的 `Replicas` 和 `Port` 字段是可选的（并且是指针），我们应该使用 `nil` 检查来查看是否设置了任何值。否则，Deployment
    将默认使用其 `manifest` 文件中定义的值。
- en: 'Now, we are always making sure that the Deployment object is being modified
    to include the Operator settings, whether it is the existing Deployment or a new
    one. Then, the decision to call `Create()` or `Update()` will be made later based
    on the value of the `create` Boolean:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们始终确保无论是现有的 Deployment 还是新创建的，都正在修改 Deployment 对象，以包括 Operator 设置。然后，是否调用
    `Create()` 还是 `Update()` 的决定将在稍后根据 `create` 布尔值来做出：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'controllers/nginxoperator_controller.go:'
- en: '[PRE325]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'If either call results in an error, it will be returned and logged by the controller
    thanks to the scaffolded framework code. If the call to create or update the Deployment
    is successful, then `err` will be `nil` and the reconciliation call completes
    successfully. Our full `Reconcile()` function now looks like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何调用返回错误，控制器会通过脚手架框架代码返回并记录该错误。如果创建或更新 Deployment 的调用成功，则 `err` 将是 `nil`，并且协调调用将成功完成。我们的完整
    `Reconcile()` 函数现在看起来像这样：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 'controllers/nginxoperator_controller.go:'
- en: '[PRE331]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: In addition, we added a call to `ctrl.SetControllerReference()` to indicate
    that the Nginx Operator resource object should be listed as the `OwnerReference`
    (an API field denoting which object "owns" the specified object) of the Nginx
    Deployment, which helps with garbage collection.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们添加了对 `ctrl.SetControllerReference()` 的调用，以表明 Nginx Operator 资源对象应该列为 Nginx
    Deployment 的 `OwnerReference`（一个 API 字段，用来标识哪个对象“拥有”指定的对象），这有助于垃圾回收。
- en: 'Finally, we need to ensure that the Operator actually has the cluster permissions
    necessary to get, create, and update Deployments. To do that, we need to update
    the RBAC role for the Operator. This can be done automatically using Kubebuilder
    markers on the `Reconcile()` function, which helps keep permissions organized
    and their necessary usage clearly identified. There are already Kubebuilder markers
    that were generated for accessing the Operator custom resource, but now we can
    add additional ones for Deployments:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保操作符实际上具有获取、创建和更新Deployment的集群权限。为此，我们需要更新操作符的RBAC角色。这可以通过在`Reconcile()`函数上使用Kubebuilder标记自动完成，从而帮助保持权限的组织性，并明确标识所需的使用权限。已经生成了用于访问操作符自定义资源的Kubebuilder标记，但现在我们可以为Deployment添加额外的标记：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: controllers/nginxoperator_controller.go：
- en: '[PRE367]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'Now, running `make manifests` should produce this new section in the Operator''s
    `ClusterRole` (`config/rbac/role.yaml`):'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`make manifests`应该会在操作符的`ClusterRole`（`config/rbac/role.yaml`）中生成这个新部分：
- en: '[PRE371]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: 'At this point, we now have a basic control loop reconciling the specified Operator
    settings with the current state of the cluster. But what events will trigger this
    loop to run? This is set up in `SetupWithManager()`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经有了一个基本的控制循环，将指定的操作符设置与集群的当前状态进行协调。但是，什么事件会触发这个循环运行呢？这是在`SetupWithManager()`中设置的：
- en: 'controllers/nginxoperator_controller.go:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: controllers/nginxoperator_controller.go：
- en: '[PRE384]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: 'This code was generated to observe the cluster for changes to the `NginxOperator`
    objects, but we need it to also observe changes to Deployment objects (since the
    Operator is managing a Deployment). This can be done by modifying the function
    like this:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是为了观察集群中`NginxOperator`对象的变化，但我们还需要它来观察Deployment对象的变化（因为操作符正在管理一个Deployment）。可以通过如下方式修改函数来实现：
- en: '[PRE390]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: With the added call to `Owns(&appsv1.Deployment{})`, the controller manager
    now knows to also trigger calls to `Reconcile()` for changes to Deployment objects
    in the cluster. The controller will now evaluate any changes to a Deployment object
    as a relevant event for the `NginxOperator` object since we have listed it as
    the owner of the Deployment. Multiple types of objects can be chained into this
    watch list with subsequent calls to `Owns()`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加对`Owns(&appsv1.Deployment{})`的调用，控制器管理器现在知道也要在集群中Deployment对象发生变化时触发`Reconcile()`调用。由于我们已将Deployment列为`NginxOperator`对象的拥有者，因此控制器现在会将对Deployment对象的任何更改视为`NginxOperator`对象的相关事件。通过后续调用`Owns()`，可以将多种类型的对象链入这个监视列表。
- en: We now have an Operator that does something. When built and deployed, this controller
    will watch for changes to any `NginxOperator` custom resource in the cluster and
    react to them. This means that the first time a user creates the Operator custom
    resource object, the Operator will see that a configuration object now exists,
    and create a Deployment based on the values present. It will also observe for
    changes to Deployments. For example, if the Nginx Deployment is accidentally deleted,
    the Operator will respond by creating a new one with the existing settings from
    its custom resource.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个执行某些操作的操作符。当构建并部署后，这个控制器将监视集群中任何`NginxOperator`自定义资源的变化，并做出响应。这意味着，当用户第一次创建操作符自定义资源对象时，操作符会看到现在存在一个配置对象，并根据现有的值创建一个Deployment。它还会监视Deployment的变化。例如，如果Nginx
    Deployment被意外删除，操作符将通过根据自定义资源中的现有设置创建一个新的Deployment来响应。
- en: Troubleshooting
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: The steps outlined in this chapter involve using several different tools and
    libraries with varying dependency requirements. Understandably, this can lead
    to errors, especially in different development environments. While the authors
    of the software involved have taken steps to produce informative and helpful error
    messages when necessary, it is not always possible to provide a clear resolution
    with automated responses. Such is the unfortunate nature of rapidly evolving software
    development.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中概述的步骤涉及使用几种不同的工具和库，它们有不同的依赖要求。可以理解的是，这可能会导致错误，特别是在不同的开发环境中。尽管相关软件的作者在必要时采取措施生成有用的错误消息，但有时无法通过自动响应提供明确的解决方案。这就是快速发展的软件开发所带来的不幸局面。
- en: Fortunately, however, the benefits of open source software provide many resources
    and volunteers to help support and debug issues, should they arise. This section
    will highlight those resources as a guide for resolving technical issues. All
    of these tools offer documentation and how-to guides, but many of them also have
    community resources where users can ask for clarification and assistance from
    maintainers and other users.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，幸运的是，开源软件的优势提供了许多资源和志愿者，帮助支持和调试出现的问题。本节将重点介绍这些资源，作为解决技术问题的指南。所有这些工具都提供文档和使用指南，但其中许多也有社区资源，用户可以在这些资源中向维护者和其他用户寻求澄清和帮助。
- en: General Kubernetes resources
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般的 Kubernetes 资源
- en: The Operator SDK is foundationally built upon several Kubernetes libraries;
    therefore, it is very helpful to understand some of the Kubernetes packages that
    are used to build Operators with the framework. By doing so, it can sometimes
    be easier to find the root cause of an issue.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Operator SDK 基于多个 Kubernetes 库构建，因此了解一些用于构建 Operators 的 Kubernetes 包非常有帮助。通过这样做，有时能更容易找到问题的根本原因。
- en: The Kubernetes reference documents are located at [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).
    However, this home section is mostly oriented toward usage documentation. For
    support regarding the Kubernetes API (including API clients, standards, and object
    references), the API reference section is much more relevant to the topics covered
    in this chapter. That is located at [https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的参考文档位于 [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。然而，这个首页部分主要面向使用文档。关于
    Kubernetes API 的支持（包括 API 客户端、标准和对象引用），API 参考部分更为相关，涵盖了本章所讨论的主题。该部分位于 [https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/)。
- en: The entire Kubernetes source code is available on GitHub under various organizations,
    such as [https://github.com/kubernetes](https://github.com/kubernetes) (most of
    the project code) and [https://github.com/kubernetes-sigs](https://github.com/kubernetes-sigs)
    (subprojects, such as Kubebuilder). For example, the Go client library, which
    is used by the Operator SDK framework under the hood to provide resource functions
    such as `r.Get()`, is hosted at [https://github.com/kubernetes/client-go/](https://github.com/kubernetes/client-go/).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 Kubernetes 源代码可以在 GitHub 上通过不同的组织访问，例如 [https://github.com/kubernetes](https://github.com/kubernetes)（大部分项目代码）和
    [https://github.com/kubernetes-sigs](https://github.com/kubernetes-sigs)（子项目，例如
    Kubebuilder）。例如，Go 客户端库，它在 Operator SDK 框架下被用来提供诸如 `r.Get()` 的资源功能，托管地址为 [https://github.com/kubernetes/client-go/](https://github.com/kubernetes/client-go/)。
- en: Familiarity with the GitHub repositories that host the different code dependencies
    that the Operator Framework is built on provides an excellent resource for communication
    with the maintainers of these projects. Searching the *Issues* on GitHub can very
    often provide immediate relief to an issue (or at least provide insight into the
    current status of ongoing problems).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉托管 Operator Framework 所依赖的不同代码库的 GitHub 仓库，为与这些项目的维护者沟通提供了极好的资源。在 GitHub 上搜索
    *Issues* 通常可以立即缓解问题（或至少提供当前问题状态的见解）。
- en: 'For faster responses and a wider audience, the Kubernetes community is very
    active on the Slack messaging platform. The official Kubernetes Slack server is
    open to anyone, at [slack.k8s.io](http://slack.k8s.io). Helpful channels for developers
    working with general Kubernetes issues include the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更快的响应和更广泛的受众，Kubernetes 社区在 Slack 消息平台上非常活跃。官方的 Kubernetes Slack 服务器对任何人开放，网址为
    [slack.k8s.io](http://slack.k8s.io)。针对开发者处理一般 Kubernetes 问题的有用频道包括以下几个：
- en: '**#kubernetes-novice** – This channel is for new Kubernetes users and developers.'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#kubernetes-novice** – 这个频道是为新的 Kubernetes 用户和开发者准备的。'
- en: '**#kubernetes-contributors** – This channel is more dedicated to the development
    of Kubernetes itself, but there are still useful topics covered around relevant
    topics, such as API clients.'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#kubernetes-contributors** – 这个频道更多关注 Kubernetes 本身的开发，但仍然会涵盖一些相关话题，例如 API
    客户端。'
- en: '`#kubernetes-novice` with a focus on usage rather than development, but for
    more specific questions.'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#kubernetes-novice` 主要集中在使用方面，而非开发方面，但针对更具体的问题。'
- en: '`SIG-APIMachinery` is responsible for the ownership of the Kubernetes Go client,
    which we used by extension in this chapter. Here you will find the most knowledgeable
    contributors in regard to API topics.'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG-APIMachinery` 负责 Kubernetes Go 客户端的所有权，我们在本章中通过扩展使用了这个客户端。在这里，你会找到在 API
    主题方面最有经验的贡献者。'
- en: For the topics in this chapter, these resources are relevant for issues related
    to the Kubernetes API, including the generated client tools created with commands
    such as `make generate`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的主题，这些资源适用于与 Kubernetes API 相关的问题，包括使用 `make generate` 等命令生成的客户端工具。
- en: Operator SDK resources
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Operator SDK 资源
- en: The Operator SDK also provides a wealth of documentation, including example
    Operator development tutorials. In this chapter, developing an Operator in Go
    meant following similar steps to those outlined in the Operator SDK Go documentation,
    located at [https://sdk.operatorframework.io/docs/building-operators/golang/](https://sdk.operatorframework.io/docs/building-operators/golang/).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: Operator SDK 还提供了丰富的文档，包括示例 Operator 开发教程。在本章中，使用 Go 开发 Operator 的步骤与在 [https://sdk.operatorframework.io/docs/building-operators/golang/](https://sdk.operatorframework.io/docs/building-operators/golang/)
    上的 Operator SDK Go 文档中概述的步骤类似。
- en: Similar to other Kubernetes projects, Operator SDK is also available on GitHub
    at [https://github.com/operator-framework/operator-sdk/](https://github.com/operator-framework/operator-sdk/).
    This is a great resource for examples, issue tracking, and staying notified of
    updates and ongoing work with the project.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 Kubernetes 项目类似，Operator SDK 也可以在 GitHub 上找到，地址是 [https://github.com/operator-framework/operator-sdk/](https://github.com/operator-framework/operator-sdk/)。这是一个很好的资源，包含示例、问题追踪，以及项目更新和持续工作的通知。
- en: There are several Operator-specific channels on [slack.k8s.io](http://slack.k8s.io),
    including **#operator-sdk-dev** (which is meant for discussion related to the
    Operator SDK) and **#kubernetes-operators**, which is for general discussion purposes
    regarding Operators.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [slack.k8s.io](http://slack.k8s.io) 上有几个与 Operator 相关的频道，包括 **#operator-sdk-dev**（专门用于讨论与
    Operator SDK 相关的内容）和 **#kubernetes-operators**，该频道用于关于 Operators 的一般讨论。
- en: These resources are all helpful for problems related to the `operator-sdk` binary,
    or the patterns provided by the SDK's code libraries and patterns.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源对于解决与 `operator-sdk` 二进制文件相关的问题，或与 SDK 的代码库和模式提供的模式相关的问题非常有帮助。
- en: Kubebuilder resources
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubebuilder 资源
- en: Kubebuilder is the tool that is used by Operator SDK to generate manifests and
    some controller code. This includes commands that were run in this chapter, such
    as `make manifests`, so for most issues related to CRDs or generating them from
    code markers (for example, `//+kubebuilder…`), this is a good starting point for
    assistance.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Kubebuilder 是 Operator SDK 用于生成清单和一些控制器代码的工具。它包括在本章中运行的命令，例如 `make manifests`，因此，对于大多数与
    CRD 相关的问题，或从代码标记中生成它们的问题（例如 `//+kubebuilder…`），这是一个很好的起点。
- en: An excellent reference for Kubebuilder is the Kubebuilder Book, available at
    [https://book.kubebuilder.io/](https://book.kubebuilder.io/). This is the essential
    documentation reference for Kubebuilder and includes details on all of the available
    comment markers for generating code. Its code base is also available on GitHub
    at [https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder),
    and some of its sub-tools (such as controller-gen) are available at [https://github.com/kubernetes-sigs/controller-tools](https://github.com/kubernetes-sigs/controller-tools).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Kubebuilder 的一个优秀参考资料是《Kubebuilder 书籍》，可以在 [https://book.kubebuilder.io/](https://book.kubebuilder.io/)
    找到。这是 Kubebuilder 的核心文档，包含了生成代码的所有可用注释标记的详细信息。它的代码库也可以在 GitHub 上找到，地址是 [https://github.com/kubernetes-sigs/kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)，其中的一些子工具（如
    controller-gen）可以在 [https://github.com/kubernetes-sigs/controller-tools](https://github.com/kubernetes-sigs/controller-tools)
    找到。
- en: Finally, there is the **#kubebuilder** channel on the Kubernetes Slack server
    for interactive discussion and help with this tool.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Kubernetes Slack 服务器上有 **#kubebuilder** 频道，供大家进行互动讨论和寻求帮助。
- en: Summary
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter followed the design we outlined in [*Chapter 3*](B18147_03_ePub.xhtml#_idTextAnchor050),
    *Designing an Operator – CRD, API, and Target Reconciliation*, to produce functional
    code that achieves the minimum requirements for a *Level I* Operator (Basic Install).
    With the support of the Operator Lifecycle Manager (which will be demonstrated
    in later chapters) and good subsequent API design, this Operator will also support
    upgrades for itself and its Operand, which qualifies it for *Level II*.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 本章遵循我们在[*第3章*](B18147_03_ePub.xhtml#_idTextAnchor050)中概述的设计，*设计一个 Operator –
    CRD、API 和目标协调*，生成实现 *Level I* Operator（基本安装）最低要求的功能代码。在 Operator 生命周期管理器的支持下（将在后续章节中展示）以及良好的后续
    API 设计，本 Operator 还将支持自我升级及其 Operand 的升级，从而使其符合 *Level II* 的标准。
- en: The steps for creating a Go-based Operator, as recommended by the Operator SDK
    documentation approach, build upon each other to achieve base functionality. In
    this chapter, that pattern meant first designing the Operator's API types, which
    are then generated into a CRD using tools such as Kubebuilder. At this time, it
    is good to begin thinking about other resource manifests, such as the Operand
    Deployment, and how those will be represented in memory. This guide took the approach
    of embedding these additional resources directly into the Go binary using built-in
    Go compiler directives that allow the language to do this natively.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 Operator SDK 文档方法推荐的步骤，创建基于 Go 的 Operator 的过程是逐步进行的，以实现基本功能。在本章中，这一模式意味着首先设计
    Operator 的 API 类型，然后使用诸如 Kubebuilder 等工具将其生成到 CRD 中。此时，可以开始考虑其他资源清单，例如 Operand
    部署，以及它们如何在内存中表示。此指南采用了将这些附加资源直接嵌入 Go 二进制文件的方法，利用内建的 Go 编译器指令使语言本身支持这一操作。
- en: Finally, the core controller code was filled in. This is what makes the Operator
    a controller, and this control loop is used to reconcile the desired state of
    the cluster with the actual state of the cluster based on user input through the
    Operator's CRD. With some additional tweaks to the event triggers and added RBAC
    permissions, this code begins to observe Deployments, which is necessary to manage
    the Operand.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，核心控制器代码被填充完成。这使得 Operator 成为一个控制器，并且这个控制循环用于根据用户通过 Operator 的 CRD 输入的内容，将集群的期望状态与实际状态进行协调。通过对事件触发器和添加
    RBAC 权限的一些额外调整，这段代码开始观察 Deployments，这是管理 Operand 所必需的。
- en: In the next chapter, we will build on this basic functionality to add more advanced
    code. This will bring our Operator beyond Level II, as we add things such as metrics
    and leader election to create a more sophisticated controller capable of deeper
    insights and error handling.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在此基础功能上构建，添加更多高级代码。这将使我们的 Operator 超越 Level II，因为我们将加入指标和领导者选举等功能，从而创建一个更复杂的控制器，能够进行更深入的洞察和错误处理。
