- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: GitOps for Azure and AWS Deployments
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure 和 AWS 部署的 GitOps
- en: In the evolving landscape of cloud computing, the adoption of GitOps practices
    stands out as a transformative approach to streamlining the deployment and management
    of applications and infrastructure. This chapter embarks on a detailed exploration
    of applying GitOps principles within the robust ecosystems of Azure and **Amazon
    Web Services** (**AWS**), two of the world’s leading cloud platforms. This chapter
    aims to unravel the complexities of leveraging cloud-native capabilities, providing
    readers with a comprehensive understanding of how to harness the full potential
    of **Azure Kubernetes Service** (**AKS**), **Azure DevOps**, **Elastic Kubernetes
    Service** (**EKS**), and **AWS CodePipeline** in a GitOps workflow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断发展的云计算环境中，GitOps 实践的采用作为一种变革性方法，突显了简化应用程序和基础设施部署与管理的优势。本章将详细探讨如何在 Azure 和
    **亚马逊 Web 服务** (**AWS**) 这两大领先的云平台中应用 GitOps 原则。本章旨在解开利用云原生能力的复杂性，向读者全面展示如何在 GitOps
    工作流中充分发挥 **Azure Kubernetes 服务** (**AKS**)、**Azure DevOps**、**弹性 Kubernetes 服务**
    (**EKS**) 和 **AWS CodePipeline** 的潜力。
- en: Through real-world case studies, expert insights, and practical guidance, we
    delve into the nuances of setting up **continuous integration/continuous deployment**
    (**CI/CD**) pipelines, managing configurations, and ensuring consistent, automated
    deployments across these platforms. By the end of this chapter, readers will be
    equipped with the knowledge to implement efficient, secure, and scalable GitOps
    workflows, marking a significant step forward in their cloud-native journey.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过真实案例研究、专家见解和实用指导，我们将深入探讨如何设置 **持续集成/持续部署** (**CI/CD**) 管道、管理配置，并确保在这些平台上的一致性和自动化部署。到本章结束时，读者将具备实施高效、安全、可扩展的
    GitOps 工作流的知识，迈出云原生之旅的重要一步。
- en: 'In this chapter, we’ll focus on these key areas:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点关注以下几个关键领域：
- en: Cloud GitOps essentials – Azure and AWS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云 GitOps 基础知识 – Azure 和 AWS
- en: Deployment on Azure and AWS with GitOps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Azure 和 AWS 上使用 GitOps 部署
- en: Integrating Azure and AWS in GitOps workflows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GitOps 工作流中集成 Azure 和 AWS
- en: GitOps applications in cloud environments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps 在云环境中的应用
- en: GitOps strategies for Azure and AWS deployments for Kubernetes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 和 AWS 部署的 Kubernetes GitOps 策略
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before delving into the intricacies of implementing GitOps for Azure and AWS
    deployments, it’s important to build upon the foundational knowledge established
    in the preceding chapters of this book. The principles of GitOps, containerization
    technologies such as Docker, Kubernetes concepts, and CI/CD principles discussed
    earlier provide a solid starting point for understanding the advanced applications
    highlighted in this chapter. Additionally, access to Azure and AWS accounts and
    a basic understanding of their services will be crucial for following along with
    practical exercises and case studies. Familiarity with version control systems,
    especially Git, will not only enhance comprehension but also facilitate the effective
    application of the GitOps practices detailed in our exploration of cloud-native
    deployments across Azure and AWS.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨如何为 Azure 和 AWS 部署实现 GitOps 之前，必须基于本书前几章中建立的基础知识进行学习。此前讨论的 GitOps 原则、Docker
    等容器化技术、Kubernetes 概念以及 CI/CD 原则，为理解本章中突出的高级应用提供了坚实的起点。此外，访问 Azure 和 AWS 账户以及对其服务的基本理解，将对跟随实际操作和案例研究至关重要。对版本控制系统的熟悉，尤其是
    Git，不仅能提高理解力，还能促进有效应用我们在 Azure 和 AWS 上的云原生部署过程中详细介绍的 GitOps 实践。
- en: 'The relevant code and resource files for this chapter can be found in the `Chapter09`
    folder of our dedicated GitHub repository: [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的相关代码和资源文件可以在我们的专用 GitHub 仓库中的 `Chapter09` 文件夹找到：[https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes)。
- en: Azure and AWS accounts
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 和 AWS 账户
- en: While this book delves into the intricacies of implementing GitOps within Azure
    and AWS ecosystems, providing a comprehensive exploration of their respective
    tools and practices, a detailed, step-by-step guide for creating Azure and AWS
    accounts falls beyond our scope. To embark on the practical journey of applying
    the concepts and examples outlined in the upcoming sections, it is essential for
    readers to have active Azure and AWS accounts. We encourage you to consult the
    official documentation provided by Azure at [https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/),
    and AWS at [https://aws.amazon.com/](https://aws.amazon.com/), for the most current
    and detailed instructions on setting up your accounts. These accounts are indispensable
    for deploying the examples and applying the GitOps practices discussed, serving
    as the foundation upon which you can build and experiment with the cloud-native
    capabilities of Azure and AWS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书深入探讨了在 Azure 和 AWS 生态系统中实施 GitOps 的复杂性，全面探索了各自的工具和实践，但详细的创建 Azure 和 AWS 账户的步骤超出了本书的范围。为了开始实际应用接下来各章节中阐述的概念和示例，读者必须拥有有效的
    Azure 和 AWS 账户。我们鼓励您查阅 Azure 官方文档 [https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)
    和 AWS 官方文档 [https://aws.amazon.com/](https://aws.amazon.com/)，以获取最新和最详细的账户设置说明。这些账户对于部署示例和应用讨论中的
    GitOps 实践至关重要，是您构建和实验 Azure 和 AWS 云原生功能的基础。
- en: In the forthcoming section, we will assume that readers possess an active and
    properly configured Azure or AWS account, along with basic knowledge of the **Azure
    CLI**, **AWS CLI**, or their respective web portals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们假设读者拥有一个有效且已正确配置的 Azure 或 AWS 账户，并具备 **Azure CLI**、**AWS CLI** 或相应网页门户的基础知识。
- en: Cloud GitOps essentials – Azure and AWS
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云 GitOps 基础知识 – Azure 和 AWS
- en: As the cloud computing landscape continues to evolve, the adoption of GitOps
    principles has become a cornerstone for achieving operational excellence and automation
    in **cloud-native deployments**. This chapter introduces the GitOps essentials
    for both Azure and AWS, showcasing how these leading cloud platforms support the
    seamless integration of GitOps workflows to enhance deployment speed, reliability,
    and scalability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算领域的不断发展，GitOps 原则的采用已成为实现 **云原生部署**操作卓越性和自动化的基石。本章介绍了 Azure 和 AWS 的 GitOps
    基础知识，展示了这两大云平台如何支持 GitOps 工作流的无缝集成，以提升部署速度、可靠性和可扩展性。
- en: Cloud-native developments and deployments
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生开发与部署
- en: Cloud-native development represents a transformative approach to building and
    deploying applications that fully exploit the advantages of the cloud computing
    model. At its core, it involves leveraging managed services, microservices architectures,
    containers, and declarative APIs to create applications that are scalable, resilient,
    and easily updated. This paradigm shift encourages organizations to move away
    from monolithic architectures, enabling faster development cycles, enhanced scalability,
    and greater flexibility in responding to market demands. Cloud-native technologies,
    including Kubernetes, Docker, and serverless functions, play pivotal roles in
    this ecosystem, providing the tools necessary for developers to build applications
    that are not only highly available and fault tolerant but also capable of thriving
    in the dynamic environment of the cloud. By adopting cloud-native practices, businesses
    can accelerate their digital transformation journeys, enhancing their ability
    to innovate and compete in an increasingly digital world.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生开发代表了一种变革性的应用构建与部署方法，充分利用了云计算模型的优势。其核心在于利用托管服务、微服务架构、容器和声明式 API 来创建具有可扩展性、韧性并且易于更新的应用。这个范式的转变鼓励组织摆脱单体架构，实现更快速的开发周期、更强的可扩展性，以及在应对市场需求时的更大灵活性。云原生技术，包括
    Kubernetes、Docker 和无服务器功能，在这一生态系统中扮演着至关重要的角色，提供了开发人员构建不仅具有高可用性和容错能力，而且能够在动态的云环境中蓬勃发展的应用所需的工具。通过采用云原生实践，企业能够加速其数字化转型，提升创新和竞争能力，以应对日益数字化的世界。
- en: Azure and AWS each offer unique tools and services – such as AKS, Azure DevOps,
    EKS, and AWS CodePipeline – that empower teams to implement GitOps practices effectively.
    Through a comprehensive exploration of these essentials, readers will gain insight
    into leveraging the cloud-native capabilities of Azure and AWS to streamline their
    deployment processes, ensuring that infrastructure and application management
    is as efficient and error free as possible. This unified approach provides a solid
    foundation for understanding how GitOps can be optimally applied within the distinct
    but complementary ecosystems of Azure and AWS.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 和 AWS 各自提供独特的工具和服务——如 AKS、Azure DevOps、EKS 和 AWS CodePipeline——这些工具帮助团队有效实施
    GitOps 实践。通过对这些基础内容的全面探索，读者将深入了解如何利用 Azure 和 AWS 的云原生能力来简化部署流程，确保基础设施和应用管理尽可能高效且无错误。这种统一的方法为理解如何在
    Azure 和 AWS 这两个各具特色但互补的生态系统中最佳地应用 GitOps 提供了坚实的基础。
- en: Azure GitOps essentials
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure GitOps 基础
- en: Azure, with its rich ecosystem and integration capabilities, offers fertile
    ground for implementing GitOps principles, enhancing automation, consistency,
    and scalability in deployments. At the heart of Azure’s GitOps capabilities lies
    the AKS, which simplifies the deployment, management, and operations of Kubernetes,
    enabling a seamless GitOps workflow. Coupled with **Azure DevOps** – a suite that
    provides a range of tools including **Azure Repos** for Git hosting and **Azure
    Pipelines** for CI/CD – developers can establish a robust GitOps pipeline that
    ensures continuous integration and deployment with minimal manual intervention.
    Leveraging these services, users can maintain a high degree of control and visibility
    over their deployments, benefiting from the declarative nature of GitOps to manage
    infrastructure and applications efficiently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 以其丰富的生态系统和集成功能为实施 GitOps 原则提供了肥沃的土壤，增强了部署过程中的自动化、一致性和可扩展性。在 Azure 的 GitOps
    能力核心中，AKS 简化了 Kubernetes 的部署、管理和操作，实现了无缝的 GitOps 工作流。结合 **Azure DevOps** —— 一个提供多种工具套件，包括用于
    Git 托管的 **Azure Repos** 和用于 CI/CD 的 **Azure Pipelines** —— 开发者可以建立一个强大的 GitOps
    流水线，确保持续集成和部署，最大限度减少人工干预。通过利用这些服务，用户可以保持对部署的高度控制和可视化，借助 GitOps 的声明性特点，高效地管理基础设施和应用。
- en: Azure DevOps
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure DevOps
- en: Azure DevOps represents a suite of development tools provided by Microsoft,
    designed to support the complete software development life cycle. At its core,
    Azure DevOps facilitates CI/CD practices, enabling teams to automate the build,
    test, and deployment phases of their applications. Specifically, in the context
    of GitOps, Azure DevOps becomes a powerful ally, allowing teams to manage infrastructure
    and application code in a Git repository, automatically apply changes to Kubernetes
    environments, and maintain a consistent state across development, testing, and
    production environments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 是微软提供的一套开发工具，旨在支持完整的软件开发生命周期。在其核心，Azure DevOps 促进了 CI/CD 实践，使团队能够自动化应用程序的构建、测试和部署阶段。特别是在
    GitOps 环境下，Azure DevOps 成为一个强大的盟友，允许团队在 Git 仓库中管理基础设施和应用代码，自动将更改应用于 Kubernetes
    环境，并在开发、测试和生产环境中保持一致的状态。
- en: 'For implementing Kubernetes GitOps deployment with Azure DevOps, the following
    base steps can guide you through the process:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Azure DevOps 实施 Kubernetes GitOps 部署时，以下基本步骤可以帮助你完成该过程：
- en: '**Set up a Git repository**: Begin by setting up a Git repository within Azure
    Repos or any other Git hosting service. This repository will hold your Kubernetes
    manifest files, representing the desired state of your application and infrastructure
    in a declarative manner.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置 Git 仓库**：首先在 Azure Repos 或任何其他 Git 托管服务中设置一个 Git 仓库。这个仓库将保存你的 Kubernetes
    清单文件，以声明性方式表示应用和基础设施的期望状态。'
- en: '**Create Azure Pipelines**: Utilize Azure Pipelines to define your CI/CD workflows.
    For GitOps, the CD pipeline plays a crucial role. It should be configured to trigger
    automatically upon changes to the main branch of your repository, where your Kubernetes
    manifest files are stored.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建 Azure Pipelines**：利用 Azure Pipelines 来定义你的 CI/CD 工作流。对于 GitOps，CD 流水线起着至关重要的作用。它应当被配置为在仓库主分支发生更改时自动触发，主分支存放着
    Kubernetes 清单文件。'
- en: '**Define environments**: In Azure DevOps, define environments to represent
    your deployment targets, such as development, staging, and production. These environments
    can be linked to your Kubernetes clusters managed by AKS or any Kubernetes clusters.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义环境**：在 Azure DevOps 中，定义环境来表示你的部署目标，例如开发、预发布和生产环境。这些环境可以与由 AKS 管理的 Kubernetes
    集群或任何 Kubernetes 集群相关联。'
- en: '**Automate deployment with Helm or Kustomize**: Use Helm charts or Kustomize
    for managing complex Kubernetes applications. Azure Pipelines can be configured
    to use Helm or Kustomize to package and deploy applications, adhering to the GitOps
    principle of declarative configuration.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 Helm 或 Kustomize 自动化部署**：使用 Helm charts 或 Kustomize 来管理复杂的 Kubernetes
    应用程序。可以配置 Azure Pipelines 来使用 Helm 或 Kustomize 打包和部署应用程序，遵循 GitOps 声明式配置的原则。'
- en: '`kubectl`, Helm, or a GitOps tool such as Flux or Argo CD. This step involves
    fetching the latest configuration from your Git repository and applying it to
    the designated environment, ensuring that the actual state matches the desired
    state declared in Git.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl`、Helm 或 GitOps 工具，如 Flux 或 Argo CD。此步骤涉及从你的 Git 仓库中获取最新配置，并将其应用到指定环境中，确保实际状态与
    Git 中声明的期望状态相匹配。'
- en: '**Monitor and rollback**: Finally, leverage Azure Monitor and other observability
    tools to keep an eye on your deployments. In case of any issues, your GitOps workflow
    should support easy rollbacks by simply reverting changes in your Git repository
    and re-running the pipeline to restore the previous state.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控与回滚**：最后，利用 Azure Monitor 和其他可观察性工具来监控你的部署。如果出现任何问题，你的 GitOps 工作流应支持通过简单地还原
    Git 仓库中的更改并重新运行流水线来恢复先前的状态，从而实现轻松回滚。'
- en: Kubernetes deployment with Azure DevOps
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 部署与 Azure DevOps
- en: In this section, we embark on a hands-on journey to deploy a Kubernetes cluster
    on Azure, leveraging the powerful combination of Terraform, **Azure Container
    Registry** (**ACR**), and Azure DevOps pipelines. We’ll start by creating a straightforward
    AKS cluster and an ACR, and then establish a system-managed identity between them
    to facilitate secure interactions. The climax of our journey involves orchestrating
    the deployment of this image to the AKS cluster using a meticulously crafted Azure
    DevOps pipeline. This practical walkthrough is designed to illuminate the seamless
    integration of these components, illustrating how they converge to streamline
    the deployment process within a GitOps framework. Through this example, readers
    will gain a comprehensive understanding of deploying applications to Kubernetes
    using Azure’s robust ecosystem. The following are the necessary steps to successfully
    complete this example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进行实践操作，使用 Terraform、**Azure 容器注册表**（**ACR**）和 Azure DevOps 流水线的强大组合，在
    Azure 上部署 Kubernetes 集群。我们将从创建一个简单的 AKS 集群和 ACR 开始，然后在它们之间建立一个系统托管身份，以便进行安全的交互。我们的旅程高潮将涉及通过精心构建的
    Azure DevOps 流水线，将这个镜像部署到 AKS 集群中。本实践教程旨在展示这些组件的无缝集成，说明它们如何汇聚以简化 GitOps 框架中的部署过程。通过这个示例，读者将全面了解如何使用
    Azure 强大的生态系统将应用程序部署到 Kubernetes。以下是成功完成此示例所需的步骤。
- en: 'In a real-world scenario, executing the Terraform script would involve creating
    an **Azure service principal** with the appropriate permissions to provision resources.
    However, for this example, we are simplifying the process by using an Azure administrator
    account with full authorizations. It’s important to note that this approach is
    not recommended for production environments due to security concerns. Log in to
    Azure by typing the following command in a new terminal window:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，执行 Terraform 脚本需要创建一个具有适当权限的**Azure 服务主体**来配置资源。然而，在这个示例中，我们通过使用一个具有完全权限的
    Azure 管理员帐户来简化这一过程。需要注意的是，由于安全问题，这种方法不推荐用于生产环境。通过在新终端窗口中输入以下命令登录 Azure：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To initialize Terraform, we use the `terraform init` command. For this step,
    we will utilize the `main.tf` and `versions.tf` Terraform files located in the
    `iac/azure` folder of the GitHub repository accompanying this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 Terraform，我们使用 `terraform init` 命令。在此步骤中，我们将使用位于 GitHub 仓库 `iac/azure`
    文件夹中的 `main.tf` 和 `versions.tf` Terraform 文件，这些文件与本章内容一同提供。
- en: Why Terraform?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择 Terraform？
- en: Terraform is a preferred tool for **infrastructure as code** (**IaC**) because
    it uses a declarative configuration language, which simplifies defining and managing
    complex environments by specifying the desired end state of the infrastructure.
    It supports multiple cloud providers, including AWS, Azure, and Google Cloud,
    enabling consistent IaC practices across different platforms. Additionally, Terraform’s
    state management feature keeps track of the current infrastructure status, allowing
    it to efficiently plan and apply changes while minimizing errors. Its extensive
    module ecosystem and robust community support further enhance its capability to
    automate and manage infrastructure at scale.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一种首选的**基础设施即代码**（**IaC**）工具，因为它使用声明性配置语言，通过指定基础设施的期望最终状态，简化了复杂环境的定义和管理。它支持多个云提供商，包括
    AWS、Azure 和 Google Cloud，使得不同平台间能够一致地实践 IaC。此外，Terraform 的状态管理功能能够跟踪当前的基础设施状态，允许它高效地规划和应用更改，同时最小化错误。其广泛的模块生态系统和强大的社区支持，进一步增强了它在大规模自动化和管理基础设施方面的能力。
- en: The `main.tf` file orchestrates the setup of essential Azure services for a
    Kubernetes-based deployment. Initially, it establishes a resource group called
    `aks-k8s-deployments-rg` in the `switzerlandnorth` region, serving as a container
    for all related Azure resources. Following this, an ACR named `aksgitops3003204acr`
    is provisioned within the same resource group and region, with the `AKS` cluster
    named `aksgitopscluster`, is then created, featuring a single default node pool
    configured with minimal resources to ensure cost efficiency. The cluster is set
    up with a system-assigned identity, streamlining the authentication process across
    Azure services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.tf` 文件负责编排 Kubernetes 基于的部署所需的 Azure 服务的设置。首先，它在`switzerlandnorth`区域建立一个名为`aks-k8s-deployments-rg`的资源组，作为所有相关
    Azure 资源的容器。接下来，在同一资源组和区域中，提供了一个名为`aksgitops3003204acr`的 ACR，随后创建了一个名为`aksgitopscluster`的`AKS`集群，集群配置了一个默认的节点池，资源最小化以确保成本效率。该集群配置了系统分配的身份，从而简化了
    Azure 服务之间的身份验证过程。'
- en: 'Finally, the Terraform configuration secures the integration between the AKS
    cluster and the ACR by assigning the necessary role permissions, enabling seamless
    container image pulls from the registry to the Kubernetes environment. Feel free
    to modify the names of the resource group or ACR and the region where the resources
    are deployed. In a terminal window, execute the following commands. The entire
    process will take a few minutes to complete:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Terraform 配置确保 AKS 集群与 ACR 之间的集成，通过分配必要的角色权限，实现了从注册表到 Kubernetes 环境的无缝容器镜像拉取。你可以自由修改资源组或
    ACR 的名称，以及资源部署的区域。在终端窗口中执行以下命令。整个过程将需要几分钟才能完成：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Await the successful provisioning of resources, then integrate the `kubectl`
    configuration for cluster management:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 等待资源成功配置，然后整合 `kubectl` 配置以进行集群管理：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the necessary steps to create a new Azure DevOps project
    and properly set up an Azure DevOps pipeline:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建一个新的 Azure DevOps 项目并正确设置 Azure DevOps 管道的必要步骤：
- en: Establish a new Azure DevOps project, as illustrated in *Figure 9**.1*, within
    your existing Azure account to manage the CI/CD pipeline and project artifacts,
    opting for a `gitops-k8s-deployment`, and optionally add a project description.
    Select **Private** for **Visibility**, and then click the **Create** button.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的 Azure 账户中建立一个新的 Azure DevOps 项目，如*图 9.1*所示，用于管理 CI/CD 管道和项目工件，选择`gitops-k8s-deployment`，并可选择添加项目描述。将**可见性**设置为**私有**，然后点击**创建**按钮。
- en: '![Figure 9.1 – The Azure DevOps window for creating a new project](img/B22100_09_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 创建新项目的 Azure DevOps 窗口](img/B22100_09_01.jpg)'
- en: Figure 9.1 – The Azure DevOps window for creating a new project
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 创建新项目的 Azure DevOps 窗口
- en: In the **Where is your code?** window, select **Pick** next to the GitHub option
    to choose the correct GitHub repository you wish to associate with the Azure DevOps
    project you previously created. You can directly use the GitHub repository associated
    with this chapter or select one that you have created, as seen in *Figure 9**.2*.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**你的代码在哪里？**窗口中，选择 GitHub 选项旁的**选择**，以选择你希望与之前创建的 Azure DevOps 项目关联的 GitHub
    仓库。你可以直接使用本章关联的 GitHub 仓库，或者选择你创建的一个仓库，如*图 9.2*所示。
- en: '![Figure 9.2 – Selecting a repository panel](img/B22100_09_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 选择仓库面板](img/B22100_09_02.jpg)'
- en: Figure 9.2 – Selecting a repository panel
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 选择仓库面板
- en: At this stage, we’re prepared to configure the pipeline. In the configuration
    panel, select **Deploy to Azure Kubernetes Service** as illustrated in *Figure
    9**.3*.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，我们已准备好配置流水线。在配置面板中，选择**部署到 Azure Kubernetes 服务**，如*图 9.3*所示。
- en: '![Figure 9.3 – Configure your pipeline section of the wizard](img/B22100_09_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 配置向导中的流水线部分](img/B22100_09_03.jpg)'
- en: Figure 9.3 – Configure your pipeline section of the wizard
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 配置向导中的流水线部分
- en: When prompted, as visible in *Figure 9**.4*, select the Azure subscription where
    the AKS cluster was previously configured and deployed using the Terraform script.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按提示操作，如*图 9.4*所示，选择之前使用 Terraform 脚本配置和部署的 Azure 订阅。
- en: '![Figure 9.4 – Popup window for selecting the Azure subscription](img/B22100_09_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 弹出窗口，选择 Azure 订阅](img/B22100_09_04.jpg)'
- en: Figure 9.4 – Popup window for selecting the Azure subscription
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 弹出窗口，选择 Azure 订阅
- en: In the `weather-app-namespace`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `weather-app-namespace` 中。
- en: '![Figure 9.5 – Deploy to AKS settings window](img/B22100_09_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 部署到 AKS 设置窗口](img/B22100_09_05.jpg)'
- en: Figure 9.5 – Deploy to AKS settings window
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 部署到 AKS 设置窗口
- en: 'Click the `src` subdirectory, we need to edit the last line of the following
    code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `src` 子目录，我们需要编辑以下代码的最后一行：
- en: '[PRE3]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We edit the preceding code this way:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们按照如下方式编辑前面的代码：
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, click the **Save and run** button, leave the default values as they are,
    and click the **Save and run** button again. The pipeline will be triggered as
    illustrated in *Figure 9**.6*.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**保存并运行**按钮，保持默认值不变，再次点击**保存并运行**按钮。流水线将按照*图 9.6*所示触发。
- en: '![Figure 9.6 – Example of a triggered Azure DevOps pipeline](img/B22100_09_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 触发的 Azure DevOps 流水线示例](img/B22100_09_06.jpg)'
- en: Figure 9.6 – Example of a triggered Azure DevOps pipeline
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 触发的 Azure DevOps 流水线示例
- en: Click on the **Build** stage to view more details, as illustrated in *Figure
    9**.7*. This time, there’s no need to build the image locally and then push it
    to the registry, as everything is handled within the Azure DevOps pipeline.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建**阶段以查看更多详细信息，如*图 9.7*所示。这一次，无需在本地构建镜像并将其推送到注册表，因为所有操作都由 Azure DevOps
    流水线处理。
- en: '![Figure 9.7 – Details of building and pushing an image to the container registry](img/B22100_09_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 构建并推送镜像到容器注册表的详细信息](img/B22100_09_07.jpg)'
- en: Figure 9.7 – Details of building and pushing an image to the container registry
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 构建并推送镜像到容器注册表的详细信息
- en: If required, authorize permissions for the pipeline, as illustrated in *Figure
    9**.8*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，授权流水线的权限，如*图 9.8*所示。
- en: '![Figure 9.8 – Popup window to grant permissions for the current and subsequent
    runs of the pipeline](img/B22100_09_08.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 弹出窗口，授予当前及后续流水线运行的权限](img/B22100_09_08.jpg)'
- en: Figure 9.8 – Popup window to grant permissions for the current and subsequent
    runs of the pipeline
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 弹出窗口，授予当前及后续流水线运行的权限
- en: At this point, after a few seconds, the pipeline should complete successfully,
    as illustrated in *Figure 9**.9*. An email should be sent to your account notifying
    you of the pipeline’s successful completion.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，几秒钟后，流水线应该成功完成，如*图 9.9*所示。一封邮件将发送到您的账户，通知您流水线成功完成。
- en: '![Figure 9.9 – Successful completion of the pipeline](img/B22100_09_09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 流水线成功完成](img/B22100_09_09.jpg)'
- en: Figure 9.9 – Successful completion of the pipeline
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 流水线成功完成
- en: 'To verify the deployment, you can utilize tools such as Visual Studio Code
    or execute the following command in the terminal:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证部署，您可以使用 Visual Studio Code 等工具，或者在终端执行以下命令：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should be as follows:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this juncture, we can execute a `port-forward` command to display the app
    in the browser, as illustrated in *Figure 9**.10*.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此时，我们可以执行一个 `port-forward` 命令，将应用显示在浏览器中，如*图 9.10*所示。
- en: '![Figure 9.10 – A screenshot of weather-app running as a container on AKS](img/B22100_09_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 运行在 AKS 上的容器中的 weather-app 截图](img/B22100_09_10.jpg)'
- en: Figure 9.10 – A screenshot of weather-app running as a container on AKS
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 运行在 AKS 上的容器中的 weather-app 截图
- en: Now, to explore the CI/CD capabilities of Azure DevOps, you could, for example,
    edit the `data.csv` file, changing the value for the `2023-01-04` day from `4.0`
    to, say, `5.0` (see *Figure 9**.11*). This file can be edited directly in your
    GitHub repository or by cloning the repository locally and using Git.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了探索 Azure DevOps 的 CI/CD 功能，你可以编辑`data.csv`文件，将`2023-01-04`这一天的值从`4.0`改为例如`5.0`（参见*图
    9.11*）。这个文件可以直接在你的 GitHub 仓库中编辑，或者通过克隆仓库到本地并使用 Git 进行编辑。
- en: '![Figure 9.11 – The updated data.csv file used as a data source from our weather-app
    application](img/B22100_09_11.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 用作天气应用程序数据源的更新后的 data.csv 文件](img/B22100_09_11.jpg)'
- en: Figure 9.11 – The updated data.csv file used as a data source from our weather-app
    application
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 用作天气应用程序数据源的更新后的 data.csv 文件
- en: At this stage, the pipeline will be automatically triggered once more, as illustrated
    in *Figure 9**.12*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，一旦再次触发，管道将自动执行，如*图 9.12*所示。
- en: '![Figure 9.12 – New execution of the pipeline after pushing the updated data.csv
    file](img/B22100_09_12.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 推送更新后的 data.csv 文件后的新执行管道](img/B22100_09_12.jpg)'
- en: Figure 9.12 – New execution of the pipeline after pushing the updated data.csv
    file
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 推送更新后的 data.csv 文件后的新执行管道
- en: By executing a new `port-forward` command targeting the newly deployed pod,
    we will have the opportunity to visualize the updated chart (see *Figure 9**.13*).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行一个新的`port-forward`命令，目标是刚刚部署的新 pod，我们将有机会可视化更新后的图表（参见*图 9.13*）。
- en: '![Figure 9.13 – The weather-app application after a new deployment, triggered
    by pushing the updated data.csv file](img/B22100_09_13.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 新部署后天气应用程序，触发条件为推送更新后的 data.csv 文件](img/B22100_09_13.jpg)'
- en: Figure 9.13 – The weather-app application after a new deployment, triggered
    by pushing the updated data.csv file
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 新部署后的天气应用程序，触发条件为推送更新后的 data.csv 文件
- en: 'To avoid incurring unnecessary costs, remember to destroy all Azure resources
    created for this example by typing the following command (or using the Azure portal):'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免产生不必要的费用，请记得通过输入以下命令（或使用 Azure 门户）销毁为本示例创建的所有 Azure 资源：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Congratulations! You have successfully completed your Azure DevOps CI/CD pipeline
    with deployment to AKS using an ACR instance. Now, it’s time to transition to
    the AWS ecosystem to explore how things operate on that side.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功完成了 Azure DevOps CI/CD 管道，并将部署到 AKS，使用了 ACR 实例。现在，是时候转向 AWS 生态系统，探索那一侧的操作方式了。
- en: AWS GitOps essentials
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS GitOps 基础知识
- en: AWS embraces the GitOps model by offering a suite of services designed to facilitate
    the management of cloud-native applications and infrastructure with high efficiency
    and reliability. The EKS stands out as AWS’s managed Kubernetes service, compared
    to other major cloud providers’ offerings such as **Google Kubernetes Engine**
    (**GKE**) from Google Cloud and AKS from Microsoft Azure. Each provides similar
    functionalities but with unique features tailored to their respective ecosystems,
    optimizing the deployment process and ensuring the automatic scaling and management
    of containerized applications. Integrating EKS with AWS CodePipeline, a service
    that automates the build, test, and deploy phases of your release process, enables
    a GitOps approach where the entire infrastructure is treated as code. This integration
    empowers teams to implement CD practices, allowing for rapid and safe application
    updates. AWS’s commitment to GitOps is evident in its tooling and services, which
    support immutable infrastructure, automated deployments, and detailed monitoring,
    aligning with the GitOps principles of declarative configuration and version control.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 通过提供一套服务来支持 GitOps 模型，旨在以高效可靠的方式促进云原生应用程序和基础设施的管理。EKS 作为 AWS 的托管 Kubernetes
    服务，相较于其他主要云服务提供商的产品，如 Google Cloud 的**Google Kubernetes Engine**（**GKE**）和 Microsoft
    Azure 的 AKS，具有独特的功能。尽管它们提供类似的功能，但每个系统都针对其各自的生态系统进行了定制，优化了部署过程，并确保容器化应用程序的自动扩展和管理。将
    EKS 与 AWS CodePipeline 集成，这是一个自动化构建、测试和部署发布过程的服务，可以实现 GitOps 方法，将整个基础设施视为代码。这种集成使团队能够实施
    CD 实践，从而实现快速且安全的应用程序更新。AWS 对 GitOps 的承诺体现在其工具和服务中，这些工具支持不可变基础设施、自动化部署和详细监控，符合
    GitOps 的声明式配置和版本控制原则。
- en: AWS CodePipepline
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS CodePipeline
- en: '**AWS CodePipeline** (https://aws.amazon.com/codepipeline/) is a fully managed
    CI/CD service that automates the build, test, and deployment phases of your release
    process. It allows you to create pipelines that automate the steps required to
    release your software changes continuously. With CodePipeline, you can define
    your release process as a series of stages, where each stage performs a specific
    action, such as fetching source code from a version control system, building and
    testing your application, and deploying it to your infrastructure.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS CodePipeline** (https://aws.amazon.com/codepipeline/) 是一个完全托管的 CI/CD
    服务，自动化了发布过程中的构建、测试和部署阶段。它允许您创建管道，自动化发布软件变更所需的步骤。通过 CodePipeline，您可以将发布过程定义为一系列阶段，每个阶段执行特定操作，如从版本控制系统获取源代码、构建和测试应用程序，以及将其部署到您的基础设施。'
- en: One of the key features of AWS CodePipeline is its flexibility and integration
    with other AWS services. You can easily integrate CodePipeline with services such
    as **AWS CodeBuild** for building your application, **AWS CodeDeploy** for deploying
    it to EC2 instances or **AWS Lambda functions**, and **AWS Elastic Beanstalk**
    for deploying and managing web applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodePipeline 的一个关键特点是其灵活性和与其他 AWS 服务的集成。您可以轻松将 CodePipeline 与 **AWS CodeBuild**（用于构建应用程序）、**AWS
    CodeDeploy**（将其部署到 EC2 实例或 **AWS Lambda 函数**）、以及 **AWS Elastic Beanstalk**（用于部署和管理
    Web 应用程序）等服务集成。
- en: 'CodePipeline also supports integration with third-party tools and services
    through custom actions, allowing you to extend its capabilities to fit your specific
    requirements. Additionally, it provides visibility into your release process through
    its web-based console, allowing you to monitor the progress of your pipelines
    and troubleshoot any issues that arise. The following are the steps for implementing
    Kubernetes GitOps deployment with AWS CodePipeline:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: CodePipeline 还支持通过自定义操作与第三方工具和服务集成，允许您扩展其功能以满足您的特定需求。此外，它通过基于 Web 的控制台提供发布过程的可视化，您可以通过该控制台监控管道进度并排查出现的问题。以下是使用
    AWS CodePipeline 实现 Kubernetes GitOps 部署的步骤：
- en: '**Set up AWS CodePipeline**: Begin by setting up AWS CodePipeline, which orchestrates
    the CI/CD workflow for your Kubernetes deployment.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置 AWS CodePipeline**：首先设置 AWS CodePipeline，它负责协调 Kubernetes 部署的 CI/CD 工作流。'
- en: '**Connect to the GitHub repository**: In the CodePipeline configuration, connect
    to your GitHub repository where your Kubernetes manifests and deployment scripts
    are stored.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接到 GitHub 仓库**：在 CodePipeline 配置中，连接到存储 Kubernetes 清单和部署脚本的 GitHub 仓库。'
- en: '**Configure source stage**: Define the source stage in the CodePipeline configuration,
    specifying the GitHub repository and branch to pull the Kubernetes manifests from.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置源阶段**：在 CodePipeline 配置中定义源阶段，指定从中拉取 Kubernetes 清单的 GitHub 仓库和分支。'
- en: '**Add build stage**: Create a build stage in the CodePipeline configuration
    to execute any necessary build steps for your Kubernetes deployment, such as compiling
    code or packaging artifacts.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加构建阶段**：在 CodePipeline 配置中创建一个构建阶段，执行 Kubernetes 部署所需的构建步骤，例如编译代码或打包工件。'
- en: '**Integrate with EKS**: Incorporate EKS into your CodePipeline workflow. This
    may involve setting up connections or permissions between AWS services and CodePipeline.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与 EKS 集成**：将 EKS 纳入 CodePipeline 工作流。这可能涉及设置 AWS 服务和 CodePipeline 之间的连接或权限。'
- en: '**Implement GitOps principles**: Ensure that your CI/CD pipeline adheres to
    GitOps principles, such as storing all configuration and deployment manifests
    in version control, automating deployment processes, and using pull-based synchronization
    for cluster updates.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实施 GitOps 原则**：确保您的 CI/CD 管道遵循 GitOps 原则，例如将所有配置和部署清单存储在版本控制中，自动化部署流程，并使用基于拉取的同步方式进行集群更新。'
- en: '**Define deployment strategy**: Define the deployment strategy for your Kubernetes
    application, specifying parameters such as rollout strategy, scaling options,
    and health checks.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义部署策略**：定义 Kubernetes 应用程序的部署策略，指定如滚动策略、扩展选项和健康检查等参数。'
- en: '**Trigger deployments**: Configure AWS CodePipeline to trigger deployments
    automatically whenever changes are pushed to the GitHub repository, maintaining
    the CD of your Kubernetes application.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**触发部署**：配置 AWS CodePipeline，使其在每次推送更改到 GitHub 仓库时自动触发部署，保持 Kubernetes 应用程序的持续部署。'
- en: '**Monitor and debug**: Implement monitoring and logging mechanisms to track
    the performance and health of your Kubernetes deployments. Ensure that you have
    tools in place to debug and troubleshoot any issues that may arise during deployment.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控和调试**：实现监控和日志记录机制，以跟踪 Kubernetes 部署的性能和健康状况。确保您有工具来调试和排查部署过程中可能出现的任何问题。'
- en: '**Iterate and improve**: Continuously iterate on your CI/CD pipeline, incorporating
    feedback and making improvements to enhance the efficiency, reliability, and security
    of your Kubernetes deployments over time.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**迭代和改进**：持续迭代您的 CI/CD 流水线，结合反馈并进行改进，以提高 Kubernetes 部署的效率、可靠性和安全性。'
- en: Wrapping up, AWS CodePipeline streamlines the release process, empowering teams
    to deliver software changes more rapidly and reliably. By automating the deployment
    pipeline, CodePipeline helps accelerate time to market and enhances overall productivity,
    enabling organizations to respond swiftly to customer needs and market demands.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，AWS CodePipeline 精简了发布过程，帮助团队更快速、更可靠地交付软件更改。通过自动化部署流水线，CodePipeline 加速了市场投放时间，并提升了整体生产力，使组织能够迅速响应客户需求和市场变化。
- en: Kubernetes deployment with AWS CodePipeline
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS CodePipeline 下的 Kubernetes 部署
- en: In this section, we embark on a hands-on journey to deploy a Kubernetes cluster
    on AWS, leveraging Terraform, EKS, and AWS CodePipeline. We’ll start by provisioning
    an EKS cluster and an Amazon **Elastic Container Registry** (**ECR**). The highlight
    of our journey involves orchestrating the deployment of this image to the EKS
    cluster using AWS CodePipeline. As done for Azure in the *Kubernetes deployment
    with Azure DevOps* section, this practical walkthrough demonstrates the seamless
    integration of these components, showcasing how they streamline the deployment
    process within a GitOps framework. Through this example, readers will gain a comprehensive
    understanding of deploying applications to Kubernetes using AWS’s powerful services.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进行一次动手实践，通过 Terraform、EKS 和 AWS CodePipeline 部署 Kubernetes 集群。我们将从配置一个
    EKS 集群和一个 Amazon **Elastic Container Registry**（**ECR**）开始。我们旅程的亮点是使用 AWS CodePipeline
    将此镜像部署到 EKS 集群中。就像在 *Azure DevOps 下的 Kubernetes 部署* 部分对 Azure 所做的那样，本实践示范展示了这些组件的无缝集成，展示了它们如何在
    GitOps 框架中简化部署过程。通过这个示例，读者将全面理解如何利用 AWS 强大的服务将应用程序部署到 Kubernetes 上。
- en: 'For the following walkthrough example, we assume that the reader has a valid
    AWS account and has already installed and configured AWS CLI version 2\. Please
    review the following AWS links for reference:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下演示示例中，我们假设读者已拥有有效的 AWS 账户，并已安装并配置 AWS CLI 版本 2。请参考以下 AWS 链接以供参考：
- en: '**AWS CLI user** **guide**: [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CLI 用户** **指南**：[https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html)'
- en: '**AWS CLI** **examples**: [https://docs.aws.amazon.com/cli/latest/userguide/welcome-examples.html](https://docs.aws.amazon.com/cli/latest/userguide/welcome-examples.html)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CLI** **示例**：[https://docs.aws.amazon.com/cli/latest/userguide/welcome-examples.html](https://docs.aws.amazon.com/cli/latest/userguide/welcome-examples.html)'
- en: 'The following are the necessary steps to successfully complete this example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是成功完成本示例所需的步骤：
- en: 'Ensure that AWS CLI is correctly configured by typing the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令，确保 AWS CLI 配置正确：
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: IAM policy
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: IAM 策略
- en: An IAM policy is a document that defines permissions and is used to manage access
    to AWS resources. IAM policies grant specific rights to users, groups, or roles,
    determining what actions they can perform on which resources. These policies are
    made up of statements that include components such as **Effect** (allow or deny),
    **Action** (the specific actions permitted or denied), and **Resource** (the specific
    resources to which the actions apply). IAM policies help ensure secure and granular
    access control within an AWS environment, enabling administrators to enforce the
    principle of least privilege by giving entities only the permissions they need
    to perform their tasks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: IAM 策略是一个定义权限的文档，用于管理对 AWS 资源的访问。IAM 策略授予用户、组或角色特定的权限，决定他们可以在哪些资源上执行什么操作。这些策略由包含以下内容的声明组成：**Effect**（允许或拒绝）、**Action**（允许或拒绝的具体操作）、**Resource**（操作应用的特定资源）。IAM
    策略有助于确保 AWS 环境中的安全和精细化访问控制，使管理员能够通过只授予实体执行任务所需的权限来贯彻最小权限原则。
- en: 'Type the following commands to start the cluster creation:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以启动集群创建：
- en: '[PRE9]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The entire process will take nearly 10 minutes to complete. *Figure 9**.14*
    illustrates the EKS cluster in the AWS console, while *Figure 9**.15* shows the
    created ECR registry.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个过程大约需要 10 分钟才能完成。*图 9.14* 显示了 AWS 控制台中的 EKS 集群，而 *图 9.15* 显示了创建的 ECR 注册表。
- en: '![Figure 9.14 – The EKS cluster after the execution of the Terraform script](img/B22100_09_14.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 执行 Terraform 脚本后的 EKS 集群](img/B22100_09_14.jpg)'
- en: Figure 9.14 – The EKS cluster after the execution of the Terraform script
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 执行 Terraform 脚本后的 EKS 集群
- en: '![Figure 9.15 – The ECR registry after the execution of the Terraform script](img/B22100_09_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 执行 Terraform 脚本后的 ECR 注册表](img/B22100_09_15.jpg)'
- en: Figure 9.15 – The ECR registry after the execution of the Terraform script
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 执行 Terraform 脚本后的 ECR 注册表
- en: 'Integrate the `kubectl` configuration for cluster management:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成 `kubectl` 配置以进行集群管理：
- en: '[PRE10]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Type the following command to test the access:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令测试访问：
- en: '[PRE11]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output should be as follows:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE12]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you encounter authentication issues or generic issues after merging the
    cluster management, you need to add an access entry for the EKS cluster. This
    involves adding the following permissions to the user configured for the AWS CLI,
    as specified at the beginning of this section:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在合并集群管理后遇到身份验证问题或其他常规问题，您需要为 EKS 集群添加一个访问条目。这包括向为 AWS CLI 配置的用户添加以下权限，如本节开头所述：
- en: 'In the AWS console, navigate to the `eksgitopscluster`) and click on the **Create
    access entry** button, as illustrated in *Figure 9**.16*:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中，导航到 `eksgitopscluster` 并点击**创建访问条目**按钮，如*图 9.16*所示：
- en: "![Figure 9.16 – The EKS cluster page and the Access tab for creating a n\uFEFF\
    ew access entry](img/B22100_09_16.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – EKS 集群页面及创建新访问条目的“访问”标签](img/B22100_09_16.jpg)'
- en: Figure 9.16 – The EKS cluster page and the Access tab for creating a new access
    entry
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – EKS 集群页面及创建新访问条目的“访问”标签
- en: 'In the **IAM Principal ARN** field, you have to select the IAM ARN that has
    been used to configure the AWS CLI and execute AWS CLI commands, as illustrated
    in *Figure 9**.17*:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **IAM 主体 ARN** 字段中，您需要选择已用于配置 AWS CLI 并执行 AWS CLI 命令的 IAM ARN，如*图 9.17*所示：
- en: '![Figure 9.17 – The IAM principal ARN selection for AWS CLI configuration](img/B22100_09_17.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – AWS CLI 配置的 IAM 主体 ARN 选择](img/B22100_09_17.jpg)'
- en: Figure 9.17 – The IAM principal ARN selection for AWS CLI configuration
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – AWS CLI 配置的 IAM 主体 ARN 选择
- en: 'Then, click the **Next** button at the bottom of the page, and for this example,
    add all the following policy names (see *Figure 9**.18*) with **Cluster** as the
    selected **Access scope**:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击页面底部的 **下一步** 按钮，并为本示例添加以下所有策略名称（参见*图 9.18*），选择 **Cluster** 作为选定的 **访问范围**：
- en: '![Figure 9.18 – The Access policies section for attaching permissions to the
    new IAM principal](img/B22100_09_18.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 为新 IAM 主体附加权限的访问策略部分](img/B22100_09_18.jpg)'
- en: Figure 9.18 – The Access policies section for attaching permissions to the new
    IAM principal
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 为新 IAM 主体附加权限的访问策略部分
- en: 'Click the **Next** button and then **Create**. Now, you should be able to administer
    the cluster using AWS CLI without any issues. For more information and details,
    please refer to the official documentation: https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#updating-access-entries.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮，然后点击 **创建**。现在，您应该可以使用 AWS CLI 管理集群，而不会遇到任何问题。更多信息，请参阅官方文档：https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#updating-access-entries。
- en: Before proceeding with the creation of an instance of AWS CodePipeline, we first
    need to create an `GitOpsCodeBuildRole`. This role will allow the pipeline to
    build a new image for our `weather-app` application whenever new code is committed
    to the repository, push the image to the created ECR, and deploy it to EKS. In
    the AWS console, navigate to **IAM** |**Roles**, and click on the **Create role**
    button, as illustrated in *Figure 9**.19*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 AWS CodePipeline 实例之前，我们首先需要创建一个 `GitOpsCodeBuildRole`。该角色将允许管道在将新代码提交到仓库时为我们的
    `weather-app` 应用程序构建新镜像，推送该镜像到创建的 ECR，并将其部署到 EKS。在 AWS 控制台中，导航到 **IAM** |**角色**，然后点击
    **创建角色** 按钮，如*图 9.19*所示。
- en: '![Figure 9.19 – The Roles page in the AWS Management Console, where you can
    begin creating a new IAM role](img/B22100_09_19.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – AWS 管理控制台中的角色页面，您可以在此开始创建新 IAM 角色](img/B22100_09_19.jpg)'
- en: Figure 9.19 – The Roles page in the AWS Management Console, where you can begin
    creating a new IAM role
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 在 AWS 管理控制台中的角色页面，您可以开始创建新的 IAM 角色
- en: IAM role
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: IAM 角色
- en: An **IAM role** in AWS is a set of permissions that define what actions can
    be performed on AWS resources. Roles are used to delegate access to users, applications,
    or services within AWS, allowing them to interact securely with various AWS services.
    Roles are defined with policies that specify the actions allowed or denied, and
    they are assumed by entities such as AWS services, IAM users, or AWS resources.
    This approach ensures secure access control and helps enforce the principle of
    least privilege, where users and services have only the permissions necessary
    to perform their tasks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 中，**IAM 角色**是一组权限，用于定义可以对 AWS 资源执行哪些操作。角色用于在 AWS 内部将访问权限委托给用户、应用程序或服务，使它们能够与各种
    AWS 服务安全地交互。角色通过策略定义，这些策略指定了允许或拒绝的操作，并且角色由 AWS 服务、IAM 用户或 AWS 资源等实体来承担。这种方法确保了安全的访问控制，并有助于执行最小权限原则，即用户和服务仅获得执行其任务所需的权限。
- en: In the **Select trusted entity** section, choose **AWS service**, and in the
    **Use case** panel, select **CodeBuild**, as shown in *Figure 9**.20*.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **选择受信实体** 部分，选择 **AWS 服务**，在 **用例** 面板中选择 **CodeBuild**，如 *图 9.20* 所示。
- en: '![Figure 9.20 – The Trusted entity type and Use case section on the Create
    role page](img/B22100_09_20.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 创建角色页面上的受信实体类型和用例部分](img/B22100_09_20.jpg)'
- en: Figure 9.20 – The Trusted entity type and Use case section on the Create role
    page
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 创建角色页面上的受信实体类型和用例部分
- en: On the `AmazonEC2ContainerRegistryFullAccess`
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AmazonEC2ContainerRegistryFullAccess` 上
- en: '`AmazonS3FullAccess`'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AmazonS3FullAccess`'
- en: '`AWSCodeBuildAdminAccess`'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AWSCodeBuildAdminAccess`'
- en: '`AWSCodeCommitFullAccess`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AWSCodeCommitFullAccess`'
- en: '`CloudWatchLogsFullAccess`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CloudWatchLogsFullAccess`'
- en: 'Then, add the following **inline policy**:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下 **内联策略**：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inline policy
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内联策略
- en: An **inline policy** is a set of permissions that can be directly attached to
    an IAM user, group, or role. Unlike managed policies, which are standalone entities,
    inline policies are embedded directly within the resources they are intended to
    control. This allows for more granular control and management of permissions at
    a more specific level. Inline policies are often used when certain permissions
    need to be applied only to a specific user, group, or role, rather than being
    shared across multiple entities.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联策略**是一组可以直接附加到 IAM 用户、组或角色的权限。与托管策略不同，后者是独立的实体，内联策略是直接嵌入到它们所控制的资源中的。这允许在更具体的层次上进行更细粒度的权限控制和管理。内联策略通常用于仅将某些权限应用于特定用户、组或角色，而不是在多个实体之间共享。'
- en: 'Before reviewing and creating the new IAM role, it’s important to ensure the
    addition of the specified trust relationship to control who can assume the role,
    enhancing security and compliance. This setup prevents unauthorized access and
    ensures that only designated entities can access certain AWS resources:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在审核和创建新的 IAM 角色之前，确保添加指定的信任关系以控制谁可以承担该角色，从而增强安全性和合规性。此设置可防止未经授权的访问，并确保只有指定的实体才能访问某些
    AWS 资源：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To complete the process, simply click the **Create** button. Now, we’re all
    set to create the AWS CodePipeline instance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完成过程后，点击 **创建** 按钮。现在，我们已经准备好创建 AWS CodePipeline 实例。
- en: Following a similar approach as done for Azure DevOps, refer to the *Kubernetes
    deployment with Azure DevOps* section in this chapter; it’s time to automate the
    application deployment to AWS EKS using AWS CodePipeline.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循类似于 Azure DevOps 的方法，参考本章中的 *Kubernetes 部署与 Azure DevOps* 部分；现在是时候使用 AWS CodePipeline
    自动化将应用程序部署到 AWS EKS 了。
- en: To set up the CodePipeline correctly, navigate to the AWS console, go to `weather-app-pipeline`
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要正确设置 CodePipeline，请导航到 AWS 控制台，进入 `weather-app-pipeline`
- en: '**Pipeline** **type**: **V2**'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**管道** **类型**: **V2**'
- en: '**Execution** **mode**: **Queued**'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行** **模式**: **排队中**'
- en: '**Service role**: **New** **service role**'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务角色**: **新建** **服务角色**'
- en: Then, click the **Next** button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击 **下一步** 按钮。
- en: '![Figure 9.21 – Initial configurations for the new AWS CodePipeline](img/B22100_09_21.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 新的 AWS CodePipeline 的初始配置](img/B22100_09_21.jpg)'
- en: Figure 9.21 – Initial configurations for the new AWS CodePipeline
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 新的 AWS CodePipeline 的初始配置
- en: In `GitHub (Version 2)` as `main`. For `CodePipeline` default. Finally, click
    the **Next** button.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GitHub (版本 2)` 中选择 `main`。对于 `CodePipeline` 选择默认设置。最后，点击 **下一步** 按钮。
- en: '![Figure 9.22 – Connection with the GitHub repository source](img/B22100_09_22.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – 与 GitHub 仓库源的连接](img/B22100_09_22.jpg)'
- en: Figure 9.22 – Connection with the GitHub repository source
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – 与 GitHub 存储库源的连接
- en: In **Add build stage**, select **AWS CodeBuild** as the build provider (refer
    to *Figure 9**.23*). Choose the same region where EKS and ECR resources have been
    previously deployed, and then click on **Create project**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加构建阶段**中，选择**AWS CodeBuild**作为构建提供者（参见*图 9.23*）。选择之前已部署 EKS 和 ECR 资源的相同区域，然后点击**创建项目**。
- en: '![Figure 9.23 – The section of the Build panel related to selecting the build
    provider and region](img/B22100_09_23.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – 与选择构建提供者和区域相关的构建面板部分](img/B22100_09_23.jpg)'
- en: Figure 9.23 – The section of the Build panel related to selecting the build
    provider and region
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 与选择构建提供者和区域相关的构建面板部分
- en: In the `weather-app-build` as the project name and keep all other values as
    default, except for `arn:aws:iam::[AWS_ACCOUNT_ID]:role/GitOpsCodeBuildRole`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `weather-app-build` 作为项目名称，保持其他所有值为默认，除了 `arn:aws:iam::[AWS_ACCOUNT_ID]:role/GitOpsCodeBuildRole`。
- en: '![Figure 9.24 – The section of the Build panel related to the selection of
    service roles and roles](img/B22100_09_24.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 与选择服务角色和角色相关的构建面板部分](img/B22100_09_24.jpg)'
- en: Figure 9.24 – The section of the Build panel related to the selection of service
    roles and roles
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 与选择服务角色和角色相关的构建面板部分
- en: 'In the `buildspec.yaml` file. Then, click the `ECR_REPOSITORY_URI`: `[AWS_ACCOUNT_ID].dkr.ecr.eu-central-1.amazonaws.com`'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `buildspec.yaml` 文件中。然后，点击 `ECR_REPOSITORY_URI`：`[AWS_ACCOUNT_ID].dkr.ecr.eu-central-1.amazonaws.com`
- en: '`IMAGE_AND_TAG`: `weather-app:latest`'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IMAGE_AND_TAG`：`weather-app:latest`'
- en: '![Figure 9.25 – The section of the Build panel related to adding environment
    variables](img/B22100_09_25.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25 – 与添加环境变量相关的构建面板部分](img/B22100_09_25.jpg)'
- en: Figure 9.25 – The section of the Build panel related to adding environment variables
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – 与添加环境变量相关的构建面板部分
- en: For **Build type**, select **Single Build**. Click the **Next** button. At the
    **Add deploy stage** step, click on the **Skip deploy stage** button, and then
    on **Next**. Review the pipeline at the final stage and click the **Create pipeline**
    button. At this point, the CodePipeline will be triggered and completed successfully
    in one minute (see *Figure 9**.26*).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**构建类型**，选择**单一构建**。点击**下一步**按钮。在**添加部署阶段**步骤中，点击**跳过部署阶段**按钮，然后点击**下一步**。在最后阶段检查流水线并点击**创建流水线**按钮。此时，CodePipeline
    将触发并在一分钟内成功完成（见*图 9.26*）。
- en: '![Figure 9.26 – weather-app-pipeline immediately after its definition](img/B22100_09_26.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – 定义后的 weather-app-pipeline](img/B22100_09_26.jpg)'
- en: Figure 9.26 – weather-app-pipeline immediately after its definition
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 定义后的 weather-app-pipeline
- en: At the end of the pipeline execution, we can verify that the Docker image of
    `weather-app` has been correctly built and pushed to the ECR, as illustrated in
    *Figure 9**.27*.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在流水线执行结束时，我们可以验证 `weather-app` 的 Docker 镜像已正确构建并推送到 ECR，如*图 9.27*所示。
- en: '![Figure 9.27 – The weather-app:latest image successfully pushed to the ECR](img/B22100_09_27.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27 – weather-app:latest 镜像成功推送到 ECR](img/B22100_09_27.jpg)'
- en: Figure 9.27 – The weather-app:latest image successfully pushed to the ECR
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27 – weather-app:latest 镜像成功推送到 ECR
- en: 'To verify that the deployment has been successfully completed, execute the
    following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证部署是否成功完成，执行以下命令：
- en: '[PRE15]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the output:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE16]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, we can execute a `port-forward` command to display the app in
    the browser, as illustrated in *Figure 9**.28*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以执行 `port-forward` 命令，在浏览器中显示应用，如*图 9.28*所示。
- en: '![Figure 9.28 – weather-app rendered in the browser after the deployment](img/B22100_09_28.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.28 – 部署后在浏览器中呈现的 weather-app](img/B22100_09_28.jpg)'
- en: Figure 9.28 – weather-app rendered in the browser after the deployment
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28 – 部署后在浏览器中呈现的 weather-app
- en: Attempt to edit the data source file as described in *Step 11* of the *Kubernetes
    deployment with Azure DevOps* section. After pushing the changes, `weather-pipeline`
    will be triggered immediately, as illustrated in *Figure 9**.29*. Perform a new
    `port-forward` command to view the updated version of the chart.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试编辑数据源文件，按照*Kubernetes 部署与 Azure DevOps*部分的*步骤 11*进行操作。在推送更改后，`weather-pipeline`
    将立即触发，如*图 9.29*所示。执行新的 `port-forward` 命令以查看更新后的图表版本。
- en: '![Figure 9.29 – The pipeline is immediately triggered after pushing the updated
    data.csv file](img/B22100_09_29.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.29 – 推送更新后的 data.csv 文件后立即触发的流水线](img/B22100_09_29.jpg)'
- en: Figure 9.29 – The pipeline is immediately triggered after pushing the updated
    data.csv file
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.29 – 推送更新后的 data.csv 文件后，管道立即触发
- en: To avoid incurring unnecessary costs, remember to delete all AWS resources created
    for this example after you’ve finished by executing the appropriate commands or
    using the AWS Management Console.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免产生不必要的费用，请记得在完成示例后，通过执行适当的命令或使用 AWS 管理控制台删除为此示例创建的所有 AWS 资源。
- en: Congratulations! At this stage, you’ve successfully completed the deployment
    of the weather application on Azure using Azure DevOps and on AWS using CodePipeline.
    Now, let’s delve into GitOps applications in cloud environments in the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在这一阶段，你已经成功地通过 Azure DevOps 在 Azure 上部署了天气应用，并通过 CodePipeline 在 AWS 上部署了应用。接下来，让我们在下一节深入探讨云环境中的
    GitOps 应用。
- en: GitOps applications in cloud environments
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云环境中的 GitOps 应用
- en: The advent of GitOps has significantly revolutionized the way cloud environments
    are managed and deployed, by embedding the principles of version control and collaboration
    into the operational fabric of cloud-native applications. GitOps applications
    extend beyond mere deployment automation, encapsulating the entire life cycle
    of cloud resources and services. This includes provisioning, scaling, updating,
    and decommissioning, all governed through Git pull requests. The methodology fosters
    a transparent, auditable, and easily reversible process, enhancing both the security
    and compliance of cloud applications. Moreover, GitOps practices ensure that the
    desired state of the cloud environment is declaratively defined and maintained,
    promoting consistency and reliability across different stages of development and
    production. This systematic approach minimizes discrepancies between environments,
    significantly reducing *it works on my machine* issues and streamlining the path
    to production.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 的出现极大地革新了云环境的管理和部署方式，将版本控制和协作的原则嵌入到云原生应用的操作框架中。GitOps 应用不仅仅是自动化部署，它涵盖了云资源和服务的整个生命周期，包括资源配置、扩展、更新和退役，这一切都通过
    Git 拉取请求进行管理。该方法论促进了一个透明、可审计、且易于回滚的过程，提高了云应用的安全性和合规性。此外，GitOps 实践确保了云环境的期望状态被声明性地定义并维护，促进了不同开发和生产阶段的一致性和可靠性。这种系统化方法最小化了环境间的差异，显著减少了*在我机器上能运行*的问题，并简化了向生产环境的过渡。
- en: Cross-cloud strategies
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨云策略
- en: 'In today’s multi-cloud landscape, organizations often leverage the unique advantages
    of Azure, AWS, and other cloud providers to optimize their operations and costs.
    Managing deployments across such diverse environments can present challenges,
    particularly in maintaining consistency and efficiency. GitOps offers a unified
    strategy for managing these deployments, facilitating cross-cloud interoperability
    and configuration management. The following is a list of benefits of adopting
    GitOps in a cross-cloud setup:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的多云格局中，组织通常利用 Azure、AWS 和其他云提供商的独特优势来优化其操作和成本。管理跨这些多样化环境的部署可能会面临挑战，特别是在保持一致性和效率方面。GitOps
    提供了一种统一的策略来管理这些部署，促进了跨云的互操作性和配置管理。以下是采用 GitOps 跨云部署的好处列表：
- en: '**Unified configuration management**: By storing infrastructure definitions
    and configurations as code in a Git repository, teams can use the same GitOps
    workflows to manage deployments across Azure, AWS, and other clouds. This centralizes
    control and ensures consistency across cloud environments.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一的配置管理**：通过将基础设施定义和配置作为代码存储在 Git 仓库中，团队可以使用相同的 GitOps 工作流来管理 Azure、AWS 和其他云平台的部署。这使得控制集中化，并确保了云环境的一致性。'
- en: '**Interoperability and portability**: Leveraging containerization and Kubernetes,
    applications can be designed to run seamlessly across different clouds. GitOps
    practices, coupled with these technologies, simplify the process of deploying
    and managing these applications, irrespective of the underlying cloud platform.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性和可移植性**：利用容器化和 Kubernetes，应用程序可以设计为无缝地跨不同的云平台运行。结合这些技术的 GitOps 实践，简化了部署和管理这些应用程序的过程，无论基础云平台如何。'
- en: '**Automated synchronization**: Tools such as Argo CD or Flux can be used to
    automatically synchronize the desired state in the Git repository with the actual
    state in each cloud environment. This ensures that all environments adhere to
    the same configurations and policies, facilitating a smooth and consistent operational
    workflow across clouds.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动同步**：像Argo CD或Flux这样的工具可以用来自动同步Git仓库中的期望状态与各个云环境中的实际状态。这确保了所有环境遵循相同的配置和策略，从而在跨云操作中实现顺畅一致的工作流程。'
- en: '**Environment parity**: GitOps enables teams to replicate environments across
    different clouds with high fidelity. This is particularly useful for testing,
    where an application deployed on Azure can be tested under similar conditions
    on AWS, ensuring that the application behaves consistently across platforms.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境一致性**：GitOps使团队能够在不同的云平台间以高精度复制环境。这对于测试尤其有用，在Azure上部署的应用可以在AWS上以类似的条件进行测试，从而确保应用在不同平台上的行为一致。'
- en: '**Secrets management**: Managing secrets and sensitive information can be challenging
    in a cross-cloud setup. GitOps workflows can integrate with cloud-specific secrets
    management services such as Azure Key Vault or AWS Secrets Manager, allowing secure
    handling of secrets while maintaining the flexibility of cross-cloud deployments.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密管理**：在跨云环境中，管理机密和敏感信息可能具有挑战性。GitOps工作流可以与云平台特定的机密管理服务（如Azure Key Vault或AWS
    Secrets Manager）集成，既能安全处理机密，又能保持跨云部署的灵活性。'
- en: Adopting a GitOps approach for cross-cloud strategies not only simplifies the
    complexity inherent in multi-cloud environments but also enhances operational
    efficiency, security, and compliance. By treating infrastructure and application
    configurations as code, teams gain the agility to adapt to changes swiftly, ensuring
    their deployments remain aligned with organizational goals and industry best practices.
    In the next section, we will introduce which GitOps strategies should be adopted
    for Kubernetes deployments on Azure and AWS.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 采用GitOps方法进行跨云策略，不仅简化了多云环境固有的复杂性，还提高了操作效率、安全性和合规性。通过将基础设施和应用配置视为代码，团队能够迅速适应变化，确保部署始终与组织目标和行业最佳实践保持一致。在下一节中，我们将介绍在Azure和AWS上为Kubernetes部署应采用哪些GitOps策略。
- en: GitOps strategies for Azure and AWS deployments for Kubernetes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure和AWS上的Kubernetes部署的GitOps策略
- en: In the realm of Kubernetes deployments, GitOps strategies offer a paradigm shift
    towards more efficient, transparent, and reliable operations. By leveraging GitOps
    principles, organizations can automate deployment processes, ensure consistency
    across environments, and significantly enhance their operational workflows. The
    following are insights into GitOps strategies tailored for Kubernetes deployments
    on Azure and AWS.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes部署领域，GitOps策略提供了一种向更高效、透明和可靠的操作方式转变的模式。通过利用GitOps原则，组织可以自动化部署过程，确保环境一致性，并显著提升操作工作流。以下是针对Azure和AWS上的Kubernetes部署量身定制的GitOps策略见解。
- en: Azure GitOps strategies
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure GitOps策略
- en: Adopting GitOps strategies for AKS entails a detailed approach to integrating
    source control, CI/CD pipelines, and configuration management to enhance deployment
    processes. A pivotal strategy involves the deployment of IaC using tools such
    as ARM templates or Terraform, which are stored in Git repositories. This approach
    enables the declarative management of AKS configurations. *Chapters 10* and *11*
    will provide comprehensive examples of automating IaC with Terraform on Azure.
    These automations facilitate automated and repeatable deployments, thereby improving
    the stability and scalability of applications.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 采用GitOps策略管理AKS涉及将源代码控制、CI/CD管道和配置管理集成的详细方法，以增强部署过程。一项关键策略是使用ARM模板或Terraform等工具部署基础设施即代码（IaC），这些工具存储在Git仓库中。这种方法使AKS配置的声明性管理成为可能。*第10章*和*第11章*将提供关于如何在Azure上使用Terraform自动化IaC的全面示例。这些自动化流程促进了自动化和可重复的部署，从而提高了应用的稳定性和可扩展性。
- en: The use of Azure Policy in conjunction with GitOps further enforces compliance
    and governance across Kubernetes clusters, ensuring that deployments adhere to
    organizational and regulatory standards. Integrating Azure Monitor with GitOps
    workflows enables teams to implement observability as a core component of their
    operations, allowing for proactive monitoring and troubleshooting of AKS deployments.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Azure Policy 与 GitOps 配合使用，进一步加强了 Kubernetes 集群的合规性和治理，确保部署符合组织和监管标准。将 Azure
    Monitor 与 GitOps 工作流集成，使团队能够将可观察性作为其操作的核心组成部分，进行主动监控和排除 AKS 部署的故障。
- en: AWS GitOps strategies
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS GitOps 策略
- en: AWS offers a robust ecosystem for implementing GitOps with EKS. The foundation
    of AWS GitOps strategies lies in leveraging Amazon ECR for the Docker container
    registry, AWS CodeCommit for source control, and AWS CodePipeline for continuous
    integration and deployment. Similar to Azure, AWS advocates for the use of IaC,
    with AWS CloudFormation or Terraform as preferred tools, to manage EKS cluster
    configurations and resources in a declarative manner.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 提供了一个强大的生态系统，用于实施 GitOps 与 EKS。AWS GitOps 策略的基础在于利用 Amazon ECR 作为 Docker
    容器注册表，AWS CodeCommit 作为源代码管理工具，AWS CodePipeline 用于持续集成和部署。与 Azure 类似，AWS 提倡使用基础设施即代码（IaC），AWS
    CloudFormation 或 Terraform 是首选工具，用于声明式管理 EKS 集群配置和资源。
- en: An effective GitOps strategy on AWS encompasses the integration of AWS CodeBuild
    and AWS CodeDeploy within the CI/CD pipeline, automating the build, test, and
    deployment phases directly from Git repositories. Moreover, the AWS App Mesh service
    can be integrated into GitOps workflows to manage microservices more effectively,
    providing end-to-end visibility and network traffic control across applications.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 上，执行有效的 GitOps 策略包括将 AWS CodeBuild 和 AWS CodeDeploy 集成到 CI/CD 管道中，从 Git
    仓库直接自动化构建、测试和部署阶段。此外，AWS App Mesh 服务可以集成到 GitOps 工作流中，更有效地管理微服务，提供跨应用的端到端可见性和网络流量控制。
- en: 'For both Azure and AWS, implementing GitOps for Kubernetes deployments revolves
    around four key principles: version control, automated deployments, merge/pull
    requests for change management, and observability. By adhering to these principles,
    organizations can achieve automated, predictable, and secure application deployments
    at scale. Utilizing GitOps not only simplifies Kubernetes cluster management but
    also aligns operational practices with development workflows, fostering a culture
    of collaboration and continuous improvement.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Azure 和 AWS，实施 GitOps 进行 Kubernetes 部署围绕着四个关键原则：版本控制、自动化部署、通过合并/拉取请求进行变更管理，以及可观察性。通过遵循这些原则，组织能够实现自动化、可预测和安全的应用部署，规模化管理
    Kubernetes 集群。利用 GitOps 不仅简化了 Kubernetes 集群管理，还将操作实践与开发工作流对齐，促进了协作与持续改进的文化。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: By now, we have gained a thorough understanding of how GitOps can be effectively
    implemented within the Azure and AWS cloud environments. The chapter covered the
    necessary tools and processes, such as AKS, Azure DevOps, AWS EKS, and AWS CodePipeline,
    to establish robust CI/CD pipelines and manage deployments seamlessly. With practical
    examples and expert advice, this chapter ensured that readers can apply these
    concepts to achieve more automated, consistent, and secure cloud-native deployments.
    Emphasizing the importance of a solid foundation in Git, Docker, and Kubernetes,
    the chapter prepared readers to embrace the full potential of GitOps in their
    cloud computing ventures. In the next chapter, we will explore the integration
    of GitOps with Terraform and Flux, focusing on infrastructure. We’ll cover the
    essential steps to align infrastructure as code with real-time operations, using
    Terraform for provisioning and Flux for CD. The discussion will also highlight
    best practices and common challenges in this process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经深入理解了如何在 Azure 和 AWS 云环境中有效地实施 GitOps。本章介绍了必要的工具和流程，例如 AKS、Azure DevOps、AWS
    EKS 和 AWS CodePipeline，用于建立强大的 CI/CD 管道并无缝管理部署。通过实际示例和专家建议，本章确保读者能够将这些概念应用于实现更自动化、一致性和安全的云原生部署。强调了
    Git、Docker 和 Kubernetes 的基础知识的重要性，本章为读者准备了充分利用 GitOps 在云计算项目中发挥最大潜力的准备。在下一章中，我们将探讨
    GitOps 与 Terraform 和 Flux 的集成，重点讨论基础设施方面。我们将涵盖将基础设施作为代码与实时操作对齐的关键步骤，使用 Terraform
    进行资源配置，使用 Flux 实现 CD。讨论还将重点介绍这一过程中最佳实践和常见挑战。
