- en: DevOps with Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器进行 DevOps
- en: 'We''re now familiar with a wide variety of DevOps tools that can help us to
    automate tasks and manage configuration throughout the delivery journey of an
    application. Challenges still lie ahead, however, as applications have now become
    more diverse than ever. In this chapter, we''ll add another skill to our tool
    belt: the container. In particular, we''ll talk about the **Docker container**.
    In doing this, we''ll seek to understand the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在熟悉了各种各样的 DevOps 工具，这些工具可以帮助我们自动化任务，并在应用程序交付过程中管理配置。然而，随着应用程序变得比以往更加多样化，挑战仍然存在。在本章中，我们将增加工具箱中的另一项技能：容器。特别是，我们将讨论**Docker
    容器**。通过这样做，我们将努力理解以下内容：
- en: Key concepts related to containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与容器相关的关键概念
- en: Running Docker applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Docker 应用程序
- en: Building Docker applications with Dockerfile
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 构建 Docker 应用程序
- en: Orchestrating multiple containers with Docker compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 编排多个容器
- en: Understanding containers
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器
- en: One of the key features of containers is isolation. In this section, we'll establish
    a proper understanding of this powerful tool by looking at how a container achieves
    isolation and why this matters in the software development life cycle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的一个关键特性是隔离。在本节中，我们将通过查看容器如何实现隔离以及这在软件开发生命周期中的重要性来建立对这一强大工具的适当理解。
- en: Resource isolation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源隔离
- en: When an application launches, it consumes CPU time, occupies memory space, links
    to its dependent libraries, writes to the disk, transmits packets, and may access
    other devices as well. Everything it uses up is a kind of resource, which is shared
    by all the programs on the same host. To increase the efficiency of resource utilization,
    we may try to put as many applications as possible on a single machine. However,
    the complexity involved in making every application work in a box effectively
    increases exponentially, even if we just want to run two applications, let alone
    work with tons of applications and machines. Because of this, the idea to separate
    the resources of a physical computing unit into isolated pieces soon became a
    paradigm in the industry.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序启动时，它消耗 CPU 时间，占用内存空间，链接到其依赖库，写入磁盘，传输数据包，可能还会访问其他设备。它使用的所有资源都是一种资源，这些资源由同一主机上的所有程序共享。为了提高资源利用效率，我们可以尝试在单台机器上运行尽可能多的应用程序。然而，即使我们只想运行两个应用程序，使每个应用程序在容器中有效运行的复杂性也会呈指数增长，更不用说处理大量应用程序和机器了。正因如此，将物理计算单元的资源分隔为独立的部分的想法很快成为行业中的范例。
- en: 'You may have heard of terms such as **Virtual Machines** (**VMs**), BSD jails,
    Solaris containers, Linux containers, Docker, and others. All of these promise
    us similar isolation concepts but use fundamentally distinct mechanisms, so the
    actual level of isolation differs. For example, the implementation of a VM involves
    full virtualization of the hardware layer with a hypervisor. If you want to run
    an application on a VM, you have to start from a full operating system. In other
    words, the resources are isolated between guest operating systems running on the
    same hypervisor. In contrast, Linux and Docker containers are built on top of
    Linux primitives, which means they can only run in an operating system with those
    capabilities. BSD jails and Solaris containers work in a similar fashion, but
    on other operating systems. The following diagram illustrates the isolation relationship
    of the Linux container and VMs. The container isolates an application on the operating
    system layer, while VM-based separation is achieved by the underlying hypervisor
    or host operating system:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过**虚拟机**（**VMs**）、BSD jails、Solaris 容器、Linux 容器、Docker 等术语。所有这些技术都向我们承诺类似的隔离概念，但使用的机制基本上是不同的，因此实际的隔离级别也不同。例如，VM
    的实现涉及使用虚拟化技术完全虚拟化硬件层，并通过一个虚拟机监控程序来管理。如果你想在 VM 上运行一个应用程序，你必须从一个完整的操作系统开始。换句话说，资源在运行在同一个虚拟化管理程序下的客户操作系统之间是隔离的。相比之下，Linux
    和 Docker 容器是基于 Linux 原生技术构建的，这意味着它们只能在具有这些功能的操作系统上运行。BSD jails 和 Solaris 容器也以类似的方式工作，但在其他操作系统上。下图说明了
    Linux 容器与 VM 之间的隔离关系。容器通过操作系统层实现应用程序的隔离，而基于 VM 的隔离则是由底层的虚拟化管理程序或主机操作系统实现的：
- en: '![](img/e66656ae-d26e-4df1-a84d-b5f82716b601.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e66656ae-d26e-4df1-a84d-b5f82716b601.png)'
- en: Linux containers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 容器
- en: A Linux container is made up of several building blocks, the two most important
    of which are **namespaces** and **control groups** (**cgroups**). Both of these
    are Linux kernel features. Namespaces provide logical partitions of certain kinds
    of system resources, such as the mounting point (`mnt`), the process ID (`PID`),
    and the network (`net`). To further understand the concept of isolation, let's
    look at some simple examples on the `pid` namespace. The following examples are
    from Ubuntu 18.04.1 and util-linux 2.31.1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Linux 容器由多个构建模块组成，其中最重要的两个是 **命名空间** 和 **控制组**（**cgroups**）。这两者都是 Linux 内核特性。命名空间提供了对某些系统资源的逻辑划分，例如挂载点（`mnt`）、进程
    ID（`PID`）和网络（`net`）。为了更好地理解隔离的概念，我们来看看 `pid` 命名空间的一些简单示例。以下示例来自 Ubuntu 18.04.1
    和 util-linux 2.31.1。
- en: 'When we type `ps axf` in our Terminal, we''ll see a long list of running processes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在终端输入 `ps axf` 时，会看到一长串正在运行的进程：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ps` is a utility that is used to report current processes on the system. `ps
    axf` provides a list of all processes in a forest.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 是一个用于报告系统当前进程的工具。`ps axf` 提供了一个包含所有进程的树状列表。'
- en: 'Let''s now enter a new `pid` namespace with `unshare`, which is able to disassociate
    a process resource part by part into a new namespace. We''ll then check the processes
    again:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `unshare` 进入一个新的 `pid` 命名空间，`unshare` 能够将进程资源逐步分离到一个新的命名空间中。接下来，我们再检查一下进程：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You''ll find that the `pid` of the shell process at the new namespace becomes `1` and
    all other processes have disappeared. This means you''ve successfully created
    a `pid` container. Let''s switch to another session outside the namespace and
    list the processes again:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现新命名空间中 shell 进程的 `pid` 变成了 `1`，所有其他进程都消失了。这意味着你已经成功创建了一个 `pid` 容器。接下来，让我们切换到命名空间外的另一个会话，再次列出进程：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can still see the other processes and your shell process within the new
    namespace. With the `pid` namespace's isolation, processes inhabiting different
    namespaces can't see each other. However, if one process uses a considerable amount
    of system resources, such as the memory, it could cause the system to run out
    of that resource and become unstable. In other words, an isolated process could
    still disrupt other processes or even crash the whole system if we don't impose
    resource usage restrictions on it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以在新命名空间中看到其他进程和你的 shell 进程。由于 `pid` 命名空间的隔离，不同命名空间中的进程是无法相互看到的。然而，如果某个进程使用了大量的系统资源，比如内存，它可能会导致系统资源耗尽，进而变得不稳定。换句话说，一个隔离的进程仍然可能会干扰其他进程，甚至崩溃整个系统，如果我们没有对其资源使用进行限制的话。
- en: 'The following diagram illustrates the `PID` namespaces and how an **Out-Of-Memory**
    (**OOM**) event can affect other processes outside a child namespace. The numbered
    blocks are the processes in the system, and the numbers are their PIDs. Blocks
    with two numbers are processes created with the child namespace, where the second
    number represents their PIDs in the child namespace. In the upper part of the
    diagram, there''s still free memory available in the system. Later on, however,
    in the lower part of the diagram, the processes in the child namespace exhaust
    the remaining memory in the system. Due to the lack of free memory, the host kernel
    then starts the OOM killer to release memory, the victims of which are likely
    to be processes outside the child namespace. In the example here, processes **8**
    and **13** in the system are killed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 `PID` 命名空间以及 **内存不足**（**OOM**）事件如何影响子命名空间外的其他进程。图中的编号方块是系统中的进程，数字是它们的
    PID。带有两个数字的方块表示在子命名空间中创建的进程，其中第二个数字表示它们在子命名空间中的 PID。在图的上半部分，系统仍然有可用的空闲内存。然而，在图的下半部分，子命名空间中的进程耗尽了系统中的剩余内存。由于没有空闲内存，主机内核随后启动
    OOM 杀手来释放内存，受害者通常是子命名空间外的进程。这里的示例中，系统中的进程 **8** 和 **13** 被杀死：
- en: '![](img/f06dbc4f-0da3-43f6-a512-9f76754d83b6.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f06dbc4f-0da3-43f6-a512-9f76754d83b6.png)'
- en: 'In light of this, `cgroups` is utilized here to limit resource usage. Like
    namespaces, this can impose constraints on different kinds of system resources.
    Let''s continue from our `pid` namespace, generate some loadon the CPU with `yes
    > /dev/null`, and then monitor it with `top`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，`cgroups` 在此被用于限制资源的使用。与命名空间类似，它可以对不同种类的系统资源施加约束。接下来我们继续从 `pid` 命名空间出发，通过
    `yes > /dev/null` 来生成一些 CPU 负载，然后使用 `top` 监控它：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our CPU load reaches 100%, as expected. Let''s now limit it with the `cgroup`
    CPU. `cgroups` are organized as folders under `/sys/fs/cgroup/`. First, we need
    to switch to the host session:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 CPU 负载达到了 100%，正如预期的那样。现在让我们通过 `cgroup` CPU 来限制它。`cgroups` 被组织为 `/sys/fs/cgroup/`
    下的文件夹。首先，我们需要切换到宿主机会话：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each folder represents the resources it controls. It''s pretty easy to create
    a `cgroup` and control processes with it: just create a folder under the resource
    type with any name and append the process IDs you''d like to control to `tasks`.
    Here, we want to throttle the CPU usage of our `yes` process, so create a new folder
    under `cpu` and find out the `PID` of the `yes` process:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件夹代表它所控制的资源。创建一个 `cgroup` 并用它来控制进程非常容易：只需在资源类型下创建一个任意名称的文件夹，并将您想要控制的进程 ID
    添加到 `tasks` 中。这里，我们希望限制 `yes` 进程的 CPU 使用率，因此在 `cpu` 下创建一个新文件夹，并找出 `yes` 进程的 `PID`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ve just added `yes` into the newly created `box` CPU group, but the policy
    remains unset, and the process still runs without any restrictions. Set a limit
    by writing the desired number into the corresponding file and check the CPU usage
    again:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将 `yes` 加入了新创建的 `box` CPU 组，但策略仍未设置，进程仍然没有任何限制地运行。通过将所需的数字写入相应的文件来设置限制，然后再次检查
    CPU 使用情况：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The CPU usage is dramatically reduced, meaning that our CPU throttle works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 使用率显著降低，这意味着我们的 CPU 限制工作正常。
- en: The previous two examples elucidate how a Linux container isolates system resources.
    By putting more confinements in an application, we can build a fully isolated
    box, including filesystems and networks, without encapsulating an operating system
    within it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子阐明了 Linux 容器如何隔离系统资源。通过在应用程序中加入更多的限制，我们可以构建一个完全隔离的盒子，包括文件系统和网络，而无需在其中封装操作系统。
- en: Containerized delivery
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化交付
- en: 'The usual way to run applications consists of the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序的通常方式包括以下步骤：
- en: Provision machines and the corresponding infrastructure resources
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置机器和相应的基础设施资源
- en: Install an operating system
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装操作系统
- en: Install system programs and application dependencies
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装系统程序和应用程序依赖项
- en: Deploy the application
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Maintain the running states of the application
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 维护应用程序的运行状态
- en: The entire process is tedious and complicated, which is why we usually don't
    want to do it manually. The **configuration management tool**, introduced in [Chapter
    1](43698ec3-b595-4aa0-811a-111010763585.xhtml), *Introduction to DevOps*, is used
    to eliminate most of the effort otherwise required in the delivery process. Its
    modular and code-based configuration design works well until application stacks
    grow complex and diverse. Maintaining a large configuration base is hard, especially
    if it's a legacy configuration that contains various hacks. Although changing
    configuration codes with the configuration management tool has a direct impact
    on the production environment, the configuration code often gets less attention
    than application code. Whenever we want to update an installed package, we would
    have to work in entangled and fragile dependencies between the system and application
    packages. It's not uncommon that some applications break inadvertently after upgrading
    an unrelated package. Moreover, upgrading the configuration management tool itself
    is also a challenging task.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程繁琐而复杂，这也是为什么我们通常不希望手动进行。**配置管理工具**，在[第一章](43698ec3-b595-4aa0-811a-111010763585.xhtml)《DevOps简介》中介绍，旨在消除交付过程中大部分的劳动。其模块化和基于代码的配置设计能够有效工作，直到应用程序栈变得复杂和多样。维护庞大的配置库是困难的，尤其是当它是包含各种
    hack 的遗留配置时。尽管使用配置管理工具更改配置代码会直接影响生产环境，但配置代码通常比应用程序代码更少受到关注。每当我们想要更新已安装的包时，就必须处理系统和应用程序包之间错综复杂且脆弱的依赖关系。升级与之无关的包时，一些应用程序意外崩溃并不罕见。此外，升级配置管理工具本身也是一项具有挑战性的任务。
- en: In order to overcome this problem, immutable deployments with pre-baked VM images
    were introduced. This means that whenever we carry out any updates on the system
    or application packages, we would build a full VM image against the change and
    deploy it accordingly. This reduces some of the complexity, because we can test
    changes prior to roll-outs and we're able to customize runtimes for applications
    that can't share the same environments. Nevertheless, carrying out immutable deployment
    with VM images is costly. The overhead of booting, distributing, and running a
    bloated VM image is significantly larger than deploying packages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，推出了使用预先构建的虚拟机镜像进行不可变部署。这意味着每当我们对系统或应用程序包进行更新时，我们将根据更改构建完整的虚拟机镜像并进行部署。这减少了一些复杂性，因为我们可以在推出之前测试更改，并且能够为无法共享相同环境的应用程序定制运行时。然而，使用虚拟机镜像进行不可变部署是昂贵的。启动、分发和运行臃肿的虚拟机镜像的开销远大于部署软件包。
- en: The container, here, is a jigsaw piece that snugly fits the deployment needs.
    A manifestation of a container can be managed within VCS and built into a blob
    image, and the image can be deployed immutably as well. This enables developers
    to abstract from actual resources and infrastructure engineers to avoid dependency
    hell. Besides, since we only need to pack up the application itself and its dependent
    libraries, its image size would be significantly smaller than a VM's. Consequently,
    distributing a container image is more economical than distributing a VM image.
    Additionally, we already know that running a process inside a container is basically
    identical to running it on its Linux host and, as such, almost no overhead will
    be produced. To summarize, a container is lightweight, self-contained, and almost
    immutable. This provides clear borders to distinguish responsibilities between
    applications and infrastructure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的容器是一个与部署需求完美契合的拼图块。容器的表现形式可以在版本控制系统（VCS）中进行管理并构建为一个 Blob 镜像，这个镜像也可以不可变地部署。这使得开发人员能够抽象化实际资源，基础设施工程师则可以避免依赖地狱。此外，由于我们只需要打包应用程序本身及其依赖库，因此其镜像大小会比虚拟机的镜像小得多。因此，分发容器镜像比分发虚拟机镜像更加经济。此外，我们已经知道，在容器内运行一个进程与在其
    Linux 主机上运行几乎没有区别，因此几乎不会产生任何开销。总而言之，容器是轻量级的、自包含的，并且几乎不可变的。这为应用程序与基础设施之间的责任区分提供了明确的界限。
- en: Due to the fact that Linux containers share the same kernel, there are still
    potential security risks for the kernel from containers running on top of it.
    An emerging trend to address this concern is making running VMs as easy and efficient
    as operating system containers, such as **unikernel**-based solutions or the **Kata
    container**. Another approach is inserting a mediator layer between applications
    and the host kernel, such as **gVisor**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 容器共享相同的内核，因此容器运行在其上的时候，内核仍然存在潜在的安全风险。为了解决这个问题，一种新兴的趋势是使虚拟机（VM）的运行像操作系统容器一样简单高效，例如基于**unikernel**的解决方案或**Kata
    容器**。另一种方法是插入一个中介层，将应用程序与宿主内核分隔开来，例如**gVisor**。
- en: Getting started with containers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器入门
- en: There are many mature container engines such as **Docker** ([https://www.docker.com](https://www.docker.com))
    or **rkt** ([https://coreos.com/rkt](https://coreos.com/rkt)) that have already
    implemented features for production usage, so you don't need to build your own
    container from scratch. As well as this, the **Open Container Initiative** ([https://www.opencontainers.org](https://www.opencontainers.org)),
    an organization formed by container industry leaders, has standardized container
    specifications. Any implementation of standards, regardless of the underlying
    platform, should have similar properties, as the OCI aims to provide a seamless
    experience of using containers across a variety of operating systems. In fact,
    the core of Docker is **containerd**, which is an OCI-compatible runtime and can
    be used without Docker. In this book, we'll use the Docker (community edition)
    container engine to fabricate our containerized applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多成熟的容器引擎，例如**Docker**（[https://www.docker.com](https://www.docker.com)）或**rkt**（[https://coreos.com/rkt](https://coreos.com/rkt)），它们已经实现了用于生产环境的功能，因此你不需要从头开始构建自己的容器。此外，由容容器行业领导者组成的**开放容器倡议**（[https://www.opencontainers.org](https://www.opencontainers.org)）已经对容器规范进行了标准化。任何标准的实现，无论底层平台如何，都应具有类似的属性，因为
    OCI 旨在提供跨各种操作系统使用容器的无缝体验。事实上，Docker 的核心是**containerd**，它是一个兼容 OCI 的运行时，可以在没有 Docker
    的情况下使用。本书中，我们将使用 Docker（社区版）容器引擎来构建我们的容器化应用程序。
- en: Installing Docker for Ubuntu
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Ubuntu安装Docker
- en: Docker requires a 64-bit version of Bionic 18.04 LTS, Artful 17.10, Xenial 16.04
    LTS, or Trusty 14.04 LTS. You can install Docker with `apt-get install docker.io`,
    but its updates are usually slower than the Docker official repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker需要64位版本的Bionic 18.04 LTS、Artful 17.10、Xenial 16.04 LTS或Trusty 14.04 LTS。你可以通过`apt-get
    install docker.io`来安装Docker，但其更新通常比Docker官方仓库慢。
- en: 'Here are the installation steps from Docker ([https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository)):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自Docker的安装步骤（[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository)）：
- en: 'Make sure you have the packages to allow `apt` repositories; if not, you can get
    them with the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已安装允许`apt`使用仓库的包；如果没有，可以使用以下命令获取它们：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add Docker''s `gpg` key and verify whether its fingerprint matches `9DC8 5822
    9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Docker的`gpg`密钥并验证其指纹是否与`9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88`匹配：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set up the repository of the `amd64` arch:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`amd64`架构的仓库：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Update the package index and install Docker CE:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新包索引并安装Docker CE：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Installing Docker for CentOS
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为CentOS安装Docker
- en: 'A 64-bit version of CentOS 7 is required to run Docker. You can get the Docker
    package from CentOS''s repository via `sudo yum install docker`, but this might
    be an older version. Again, the installation steps from Docker''s official guide
    ([https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository))
    are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Docker需要64位版本的CentOS 7。你可以通过`sudo yum install docker`从CentOS的仓库获取Docker包，但这可能是旧版本。再次，Docker官方指南中的安装步骤如下：[https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository)。
- en: 'Install the utility to enable `yum` to use the extra repository:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装工具以使`yum`能够使用额外的仓库：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set up Docker''s repository:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Docker的仓库：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Install Docker CE and start it. If key verification is prompted, make sure
    it matches `060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker CE并启动。如果提示密钥验证，确保它与`060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`匹配：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Installing Docker for macOS
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为macOS安装Docker
- en: 'Docker wraps a micro Linux with the hypervisor framework to build a native
    application on macOS, which means we don''t need third-party virtualization tools
    to use Docker on a Mac. To benefit from the hypervisor framework, you must upgrade
    your macOS to version 10.10.3 or more:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将一个微型Linux与虚拟机管理框架结合，在macOS上构建本地应用程序，这意味着我们不需要第三方虚拟化工具就能在Mac上使用Docker。为了受益于虚拟机管理框架，必须将macOS升级到10.10.3或更高版本：
- en: Download the Docker package and install it: [https://download.docker.com/mac/stable/Docker.dmg](https://download.docker.com/mac/stable/Docker.dmg).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Docker包并安装：[https://download.docker.com/mac/stable/Docker.dmg](https://download.docker.com/mac/stable/Docker.dmg)。
- en: 'Docker for Windows requires no third-party tools either. Check for the installation
    guide at the following link: [https://docs.docker.com/docker-for-windows/install](https://docs.docker.com/docker-for-windows/install).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Docker for Windows也不需要任何第三方工具。可以在以下链接查找安装指南：[https://docs.docker.com/docker-for-windows/install](https://docs.docker.com/docker-for-windows/install)。
- en: 'You''re now in Docker. Try creating and running your very first Docker container.
    Run the command with `sudo` if you''re on Linux:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在进入Docker环境。尝试创建并运行你的第一个Docker容器。如果你在Linux上，可以使用`sudo`运行命令：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll see that you''re under a `root` directory instead of your current one.
    Let''s check the process list again:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会发现你现在在`root`目录下，而不是当前目录。让我们再次查看进程列表：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's isolated, as expected. You're now all ready to work with the container.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它是隔离的。你现在已经准备好与容器一起工作了。
- en: Alpine is a Linux distribution. Since it's really small in size, many people
    use it as their base image to build their application container. Do note, however,
    that it still has a few differences from mainstream Linux distributions. For example,
    Alpine uses `musl libc`, while most distributions use `glibc`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine是一个Linux发行版。由于其体积非常小，许多人使用它作为构建应用容器的基础镜像。然而需要注意的是，它与主流Linux发行版还是有一些差异。例如，Alpine使用`musl
    libc`，而大多数发行版使用`glibc`。
- en: The life cycle of a container
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的生命周期
- en: Using containers isn't as intuitive as most of the tools that we're used to
    working with, so we'll need to change the way we work. In this section, we'll
    go through how to use Docker so that we're able to benefit from containers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器不像我们习惯使用的大多数工具那样直观，因此我们需要改变工作方式。在本节中，我们将介绍如何使用Docker，以便能够从容器中受益。
- en: The basics of Docker
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 基础知识
- en: 'When `docker run alpine ls` is executed, Docker carries out the following steps
    behind the scenes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`docker run alpine ls`时，Docker 会在后台执行以下步骤：
- en: It finds the `alpine` image locally. If this is not found, Docker will try to
    locate and pull it from the public Docker registry to the local image storage.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在本地查找`alpine`镜像。如果找不到，Docker 会尝试从公共 Docker 仓库中拉取并存储到本地镜像库。
- en: It extracts the image and creates a container accordingly.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提取镜像并相应地创建一个容器。
- en: It executes the entry point defined in the image with commands, which are the
    arguments after the image name. In this example, the argument is `ls`. By default,
    the entry point is `/bin/sh -c` on Linux-based Docker.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它执行图像中定义的入口点命令，这些命令是图像名称后的参数。在此示例中，参数是`ls`。默认情况下，Linux 基础的 Docker 上的入口点是`/bin/sh
    -c`。
- en: When the entry point process is finished, the container then exits.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当入口点进程完成时，容器会退出。
- en: An image is an immutable bundle of code, libraries, configurations, and everything
    else we want to put in it. A container is an instance of an image, which is executed
    during runtime. You can use the `docker inspect IMAGE` and `docker inspect CONTAINER`
    commands to see the difference between an image and a container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是一个不可变的代码、库、配置等的捆绑包，包含了我们想要放入其中的所有内容。容器是镜像的一个实例，它在运行时执行。你可以使用`docker inspect
    IMAGE`和`docker inspect CONTAINER`命令查看镜像和容器之间的区别。
- en: 'Anything launched with `docker run` would take the foreground; the `-d` option (`--detach`)
    enables us to run a container in the detached mode. Sometimes, we may need to
    enter an active container to check the image or update something inside it. To
    do this, we could use the `-i` and `-t` options (`--interactive` and `--tty`).
    If we want to interact with a detached container, we can use the `exec` and `attach`
    command: the `exec` command allows us to run a process in a running container,
    while `attach` works as its name suggests. The following example demonstrates
    how to use these commands:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker run`启动的任何内容都会占据前台；`-d`选项（`--detach`）允许我们以分离模式运行容器。有时候，我们可能需要进入一个活动的容器，检查其中的镜像或更新某些内容。为此，我们可以使用`-i`和`-t`选项（`--interactive`和`--tty`）。如果我们想与一个分离的容器进行交互，我们可以使用`exec`和`attach`命令：`exec`命令允许我们在运行中的容器内运行进程，而`attach`命令则按字面意义工作。以下示例演示了如何使用这些命令：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Your Terminal should now be flooded with `meow~`. Switch to another Terminal
    and run `docker ps`, a command to get the status of containers, to find out the
    name and the ID of the container. Here, both the name and the ID are generated
    by Docker, and you can access a container with either of them:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的终端应该充满了`meow~`。切换到另一个终端并运行`docker ps`，这是一个获取容器状态的命令，用来查找容器的名称和 ID。在这里，名称和
    ID 都是由 Docker 生成的，你可以使用其中任何一个来访问容器：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As a matter of convenience, the name can be assigned upon `create` or `run` with
    the `--name` flag.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，可以在`create`或`run`时使用`--name`标志指定容器的名称。
- en: 'Once we access the container and inspect its processes, we''ll see two shells:
    one is meowing and the other is where we are. Kill the first shell with `kill
    -s 2 1` inside the container and we''ll see the whole container stopped as the
    entry point is exited. Finally, we''ll list the stopped containers with `docker
    ps -a` and clean them up with `docker rm CONTAINER_NAME` or `docker rm CONTAINER_ID`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们访问容器并检查其进程，我们会看到两个 shell：一个在发出 `meow~`，另一个是我们所在的位置。使用`kill -s 2 1`命令终止容器内的第一个
    shell，我们会看到整个容器停止，因为入口点进程已经退出。最后，我们使用`docker ps -a`列出已停止的容器，并通过`docker rm CONTAINER_NAME`或`docker
    rm CONTAINER_ID`清理它们：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since Docker 1.13, the `docker system prune` command has been introduced, which
    helps us clean up stopped containers and occupied resources with ease.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Docker 1.13 开始，`docker system prune`命令被引入，帮助我们轻松清理已停止的容器和占用的资源。
- en: The `PID 1` process is very special in UNIX-like operating systems. Regardless
    of what kind of process it is, it should reclaim its exited children and not take
    the `SIGKILL` signal. That's why the previous example uses `SIGINT` (2) instead
    of `SIGKILL`. Besides, most of the entry processes in a container don't handle
    terminated children, which may cause lots of un-reaped zombie processes in the
    system. If there's a need to run Docker containers in production without Kubernetes,
    use the `--init` flag upon `docker run`. This injects a `PID 1` process, which
    handles its terminated children correctly, into the container to run.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`PID 1`进程在类 UNIX 操作系统中非常特殊。无论它是什么类型的进程，它都应该回收已退出的子进程，并且不能接收`SIGKILL`信号。这就是为什么前面的例子使用了`SIGINT`（2）而不是`SIGKILL`的原因。此外，容器中的大多数入口进程并不处理已终止的子进程，这可能会导致系统中出现大量未回收的僵尸进程。如果需要在没有
    Kubernetes 的情况下运行 Docker 容器到生产环境，可以在`docker run`时使用`--init`标志。这样会在容器中注入一个`PID
    1`进程，它能够正确处理已终止的子进程。'
- en: Layers, images, containers, and volumes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层、镜像、容器和数据卷
- en: We know that an image is immutable and a container is ephemeral, and we know
    how to run an image as a container. Nevertheless, we are still missing some information with
    regard to packing an image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道镜像是不可变的，容器是短暂的，并且我们知道如何将镜像作为容器运行。然而，我们仍然缺少一些关于如何打包镜像的信息。
- en: An image is a read-only stack that consists of one or more layers, and a layer
    is a collection of files and directories in the filesystem. To improve disk space
    utilization, layers aren't locked to just one image but are shared among images,
    which means that Docker simply stores one copy of a base image locally, regardless
    of how many images are derived from it. You can utilize the `docker history [image]`
    command to understand how an image is built. For example, you will see that Alpine
    has only one layer if you check it with `docker history alpine`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是一个只读的堆栈，由一个或多个层组成，而层是文件系统中的文件和目录集合。为了提高磁盘空间的利用率，层不仅限于一个镜像，而是可以在多个镜像之间共享，这意味着
    Docker 只会在本地存储一份基础镜像的副本，无论从它衍生出多少镜像。你可以使用`docker history [image]`命令来了解一个镜像是如何构建的。例如，如果你用`docker
    history alpine`检查 Alpine，你会发现它只有一层。
- en: Whenever a container is created, it adds a thin, writable layer on top of the
    base image. Docker adopts the **Copy-On-Write** (**COW**) strategy on the thin
    layer. This means that a container reads the layers of the base image where the
    target files are stored and copies the file to its own writable layer if the file
    is modified. This approach prevents containers that are created from the same
    image from intervening with each other. The `docker diff [CONTAINER]` command
    shows the difference between the container and its base image in terms of their
    filesystem states. For example, if `/etc/hosts` in the base image is modified,
    Docker copies the file to the writable layer, and it'll be the only file in the
    output of `docker diff`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个容器时，它会在基础镜像上添加一个薄的、可写的层。Docker 在这个薄层上采用**写时复制**（**Copy-On-Write, COW**）策略。这意味着容器会读取基础镜像中存储目标文件的层，如果文件被修改，它就将文件复制到自己可写的层中。这种方式防止了从同一镜像创建的容器相互干扰。`docker
    diff [CONTAINER]`命令显示容器与其基础镜像在文件系统状态上的差异。例如，如果基础镜像中的`/etc/hosts`被修改，Docker会将该文件复制到可写层中，并且它将成为`docker
    diff`输出中的唯一文件。
- en: 'The following diagram illustrates the hierarchical structure of Docker images:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了 Docker 镜像的层级结构：
- en: '![](img/fabdc429-ba54-4123-9bf4-3ab0d77e337b.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fabdc429-ba54-4123-9bf4-3ab0d77e337b.png)'
- en: It's important to note that data in the writable layer is deleted along with
    its container. To persist data, you commit the container layer as a new image with
    the `docker commit [CONTAINER]` command or mount data volumes into a container.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，可写层中的数据会随着容器的删除而被删除。为了持久化数据，你可以通过`docker commit [CONTAINER]`命令将容器层提交为一个新镜像，或者将数据卷挂载到容器中。
- en: 'A data volume allows a container to carry out reading and writing operations,
    bypassing Docker''s filesystem. It can either be on a host''s directory or in
    other storage, such as Ceph or GlusterFS. Therefore, any disk I/O against the
    volume can operate at native speeds depending on the underlying storage. Since
    the data is persistent outside a container, it can be reused and shared by multiple
    containers. Mounting a volume is done by specifying the `-v` (`--volume`) flag
    with `docker run` or `docker create`. The following example mounts a volume under
    `/chest` in the container and leaves a file there. Afterwards, we use `docker
    inspect` to locate the data volume:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷允许容器执行读写操作，绕过Docker的文件系统。它可以位于主机的目录中，也可以位于其他存储介质中，如Ceph或GlusterFS。因此，任何针对卷的磁盘I/O操作都可以根据底层存储以原生速度运行。由于数据在容器之外是持久化的，因此可以被多个容器复用和共享。挂载卷是通过在`docker
    run`或`docker create`命令中指定`-v`（`--volume`）标志来完成的。以下示例将在容器的`/chest`目录下挂载一个卷，并在其中留下一个文件。之后，我们使用`docker
    inspect`定位数据卷：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The default `tty` path of the micro Linux provided by Docker CE on macOS can
    be found in the following location:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CE在macOS上提供的微型Linux的默认`tty`路径可以在以下位置找到：
- en: '`~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty`。'
- en: You can attach to it with `screen`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`screen`附加到它。
- en: 'One use case of data volumes is sharing data between containers. To do this,
    we first create a container and mount volumes on it, and then reference the volume
    with the `--volumes-from` flag when launching other containers. The following
    examples create a container with a data volume, `/share-vol`. Container A can
    put a file into it, and container B can read it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数据卷的一个使用场景是容器之间共享数据。为此，我们首先创建一个容器并在其上挂载卷，然后在启动其他容器时通过`--volumes-from`标志引用该卷。以下示例创建一个带有数据卷`/share-vol`的容器，容器A可以将文件放入该卷，容器B可以读取它：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition, data volumes can be mounted under a given `host` path, and of
    course the data inside is persistent:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据卷可以挂载到指定的`host`路径下，当然其中的数据是持久化的：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Distributing images
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发镜像
- en: A registry is a service that stores, manages, and distributes images. Public
    services, such as Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    and Quay ([https://quay.io](https://quay.io)), collect all kinds of pre-built
    images of popular tools, such as Ubuntu, `nginx`, and custom images from other
    developers. The Alpine Linux tool we've used many times already is actually pulled
    from Docker Hub ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)).
    You can upload your own tool onto these services and share them with everyone
    else as well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表是一个存储、管理和分发镜像的服务。公共服务，如Docker Hub（[https://hub.docker.com](https://hub.docker.com)）和Quay（[https://quay.io](https://quay.io)），收集了各种流行工具的预构建镜像，如Ubuntu、`nginx`，以及其他开发者的自定义镜像。我们已经使用过多次的Alpine
    Linux工具实际上是从Docker Hub（[https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)）拉取的。你也可以将自己的工具上传到这些服务，并与其他人共享。
- en: If you need a private registry, but for some reason you don't want to subscribe
    to the paid plans of registry service providers, you can always set up one on
    your own with the Docker Registry ([https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)).
    Other popular registry service providers include Harbor ([https://goharbor.io/](https://goharbor.io/))
    and Portus ([http://port.us.org/](http://port.us.org/)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个私有注册表，但由于某些原因不想订阅注册服务提供商的付费计划，你始终可以自己搭建一个Docker Registry（[https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)）。其他流行的注册服务提供商包括Harbor（[https://goharbor.io/](https://goharbor.io/)）和Portus（[http://port.us.org/](http://port.us.org/)）。
- en: 'Before provisioning a container, Docker will try to locate the specified image
    in a rule indicated in the image name. An image name consists of three sections, `[registry/]name[:tag]`,
    and it''s resolved with the following rules:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置容器之前，Docker会尝试根据镜像名称中指定的规则来定位指定的镜像。镜像名称由三个部分组成，`[registry/]name[:tag]`，并且会按以下规则解析：
- en: If the `registry` field is left out, Docker searches for the name on Docker
    Hub
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了`registry`字段，Docker会在Docker Hub上搜索该名称。
- en: If the `registry` field is a registry server, Docker searches the name for it
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`registry`字段是一个注册服务器，Docker会在该服务器上搜索名称。
- en: You can have more than one slash in a name
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称中可以包含多个斜杠。
- en: The tag defaults to `latest` if it's omitted
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略标签，默认标签为`latest`。
- en: 'For example, an image name such as `gcr.io/google-containers/guestbook:v3`
    instructs Docker to download `v3` of `google-containers/guestbook` from `gcr.io`.
    Likewise, if you want to push an image to a registry, tag your image in the same
    manner and push it with `docker push [IMAGE]`. To list the images you currently
    own locally, use `docker images`. You can remove an image with `docker rmi [IMAGE]`.
    The following example shows how to work between different registries: downloading
    an `nginx` image from Docker Hub, tagging it to a private registry path, and pushing
    it accordingly. The private registry is hosted locally with `docker run -p 5000:5000
    registry`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像 `gcr.io/google-containers/guestbook:v3` 这样的图像名称指示 Docker 从 `gcr.io` 下载
    `google-containers/guestbook` 的 `v3` 版本。同样，如果你想将图像推送到注册表，请以相同方式标记图像并使用 `docker
    push [IMAGE]` 推送它。要列出你当前在本地拥有的图像，可以使用 `docker images`。你可以使用 `docker rmi [IMAGE]`
    删除一个图像。以下示例展示了如何在不同的注册表之间操作：从 Docker Hub 下载一个 `nginx` 图像，将其标记为私有注册表路径，并相应地推送。私有注册表是通过
    `docker run -p 5000:5000 registry` 在本地托管的。
- en: 'Here, we use the registry mentioned previously with the most basic setup. A
    more detailed guide about the deployment can be found at the following link: [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用前面提到的注册表和最基本的设置。有关部署的更详细指南，请参阅以下链接：[https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/)。
- en: 'Notice that although the default tag is `latest`, you have to tag and `push`
    it explicitly:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管默认标签是 `latest`，但你必须显式地对其进行标签和 `push`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Most registry services ask for authentications if you're going to push images. `docker
    login` is designed for this purpose. For some older versions of Docker, you may sometimes receive
    an `image not found` error when attempting to pull an image, even though the image
    path is valid. This is likely to mean that you're unauthorized with the registry
    that keeps the image.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数注册表服务在你推送图像时都会要求认证。`docker login` 就是为此目的设计的。对于一些较旧版本的 Docker，当你尝试拉取图像时，即使图像路径有效，你有时也会收到
    `image not found` 错误。这通常意味着你没有权限访问存储该图像的注册表。
- en: 'In addition to images distributed via the registry service, there are options
    to dump images as a TAR archive and import them back into the local repository:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过注册表服务分发的图像外，还有将图像作为 TAR 存档导出并导入回本地仓库的选项：
- en: '`docker commit [CONTAINER]`: Commits the changes of the container layer into
    a new image'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker commit [CONTAINER]`：将容器层的更改提交到一个新的图像中'
- en: '`docker save --output [filename] IMAGE1 IMAGE2 ...`: Saves one or more images
    to a TAR archive'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker save --output [filename] IMAGE1 IMAGE2 ...`：将一个或多个图像保存为 TAR 存档'
- en: '`docker load -i [filename]`: Loads a TAR image into the local repository'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker load -i [filename]`：将 TAR 图像加载到本地仓库'
- en: '`docker export --output [filename] [CONTAINER]`: Exports a container''s filesystem
    as a TAR archive'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker export --output [filename] [CONTAINER]`：将容器的文件系统导出为 TAR 存档'
- en: '`docker import --output [filename] IMAGE1 IMAGE2`: Imports an exported TAR
    archive'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker import --output [filename] IMAGE1 IMAGE2`：导入导出的 TAR 存档'
- en: The `commit`, `save`, and `export` commands look pretty much the same. The main
    difference is that a saved image preserves files in between layers even if they
    are to be deleted eventually. On the other hand, an exported image squashes all
    intermediate layers into one final layer. Another difference is that a saved image
    keeps metadata such as layer histories, but this isn't available with an exported
    image. As a result, the exported image is usually smaller in size.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit`、`save` 和 `export` 命令看起来非常相似。主要区别在于，保存的图像即使最终会被删除，仍然会保留层与层之间的文件。而导出的图像则会将所有中间层压缩成一个最终层。另一个区别是，保存的图像会保留元数据，如层历史记录，但导出的图像没有这些信息。因此，导出的图像通常较小。'
- en: 'The following diagram depicts the relationship of states between a container
    and the images. The captions on the arrows are the corresponding Docker sub-commands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了容器与图像之间状态的关系。箭头上的说明是相应的 Docker 子命令：
- en: '![](img/7a5cfc93-ca67-4258-9142-e2d84b831e71.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a5cfc93-ca67-4258-9142-e2d84b831e71.png)'
- en: The container technology is tightly bound to operating system features, which
    means an image built for one platform can't run on another platform without recompiling
    a new image on the target platform. To make this simpler, Docker introduced the
    Image Manifest, which supports multi-arch builds. We won't discuss multi-arch
    builds in this book further, but you can find more information at the following
    link: [https://docs.docker.com/edge/engine/reference/commandline/manifest/](https://docs.docker.com/edge/engine/reference/commandline/manifest/).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术与操作系统功能紧密绑定，这意味着为一个平台构建的镜像无法在另一个平台上运行，除非在目标平台上重新编译新的镜像。为了简化这一过程，Docker 引入了镜像清单（Image
    Manifest），支持多架构构建。我们在本书中不会进一步讨论多架构构建，但你可以通过以下链接找到更多信息：[https://docs.docker.com/edge/engine/reference/commandline/manifest/](https://docs.docker.com/edge/engine/reference/commandline/manifest/)。
- en: Connecting containers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接容器
- en: 'Docker provides three kinds of networks to manage communications between containers
    and the hosts, namely `bridge`, `host`, and `none`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了三种网络来管理容器与主机之间的通信，分别是 `bridge`、`host` 和 `none`：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By default, every container is connected to the bridge network upon creation.
    In this mode, every container is allocated a virtual interface as well as a private
    IP address, and the traffic going through the interface is bridged to the host''s
    `docker0` interface. Containers within the same bridge network can also connect
    to each other via their IP address. Let''s run one container that''s feeding a
    short message over port `5000`, and observe its configuration. The `--expose`
    flag opens the given ports to the world outside the container:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个容器在创建时都会连接到桥接网络。在这种模式下，每个容器都会分配一个虚拟接口和一个私有 IP 地址，所有通过该接口的流量会桥接到主机的 `docker0`
    接口。位于同一桥接网络中的容器也可以通过 IP 地址相互连接。让我们运行一个容器，通过 `5000` 端口发送一条简短消息，并观察其配置。`--expose`
    标志会将指定端口暴露给容器外部：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, the `greeter` container is allocated to the IP address `172.17.0.2`.
    Now, run another container, connecting to it with this IP address:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`greeter` 容器被分配到 IP 地址 `172.17.0.2`。现在，运行另一个容器，通过这个 IP 地址连接它：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `docker network inspect bridge` command provides configuration details,
    such as attached containers, subnet segments, and gateway information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network inspect bridge` 命令提供了配置详情，比如已连接的容器、子网段和网关信息。'
- en: 'You can group some containers into one user-defined bridge network. This is
    the recommended way to connect multiple containers on a single host. The user-defined
    bridge network slightly differs from the default one, the major difference being
    that you can access a container from other containers with its name, rather than
    its IP address. Creating a network is done using the `docker network create [NW-NAME]` command,
    and we can attach containers to it by adding the `--network [NW-NAME]` flag at
    the time of creation. The network name of a container is its name by default,
    but it can be given another alias name with the `--network-alias` flag as well:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一些容器分组到一个用户定义的桥接网络中。这是连接单个主机上多个容器的推荐方式。用户定义的桥接网络与默认网络略有不同，主要的区别是你可以通过容器的名称而不是
    IP 地址来访问容器。创建网络可以使用 `docker network create [NW-NAME]` 命令，我们可以通过在创建时添加 `--network
    [NW-NAME]` 标志将容器连接到该网络。容器的网络名称默认为其名称，但也可以通过 `--network-alias` 标志为其指定其他别名：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `host` network works as its name suggests; every connected container shares
    the host''s network, but it loses the isolation property at the same time. The
    `none` network is a logically air-gapped box. Regardless of ingress or egress,
    traffic is isolated inside as there''s no network interface attached to the container.
    Here, we attach a container that listens on port `5000` to the `host` network
    and communicates with it locally:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`host` 网络如其名所示，每个连接的容器共享主机的网络，但同时失去了隔离特性。`none` 网络是一个逻辑上与外界隔绝的盒子。无论是进入流量还是出去流量，所有的流量都被隔离在容器内，因为容器没有附加任何网络接口。在这里，我们将一个监听
    `5000` 端口的容器连接到 `host` 网络，并与其进行本地通信：'
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you are using Docker CE for macOS, the host is the micro Linux on top of
    the hypervisor framework.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Docker CE for macOS，主机是运行在虚拟化框架上的微型 Linux。
- en: 'The interaction between the host and the three network modes is shown in the
    following diagram. Containers in the `host` and `bridge` networks are attached
    with proper network interfaces and communicate with containers within the same
    network, as well as the outside world, but the `none` network is kept away from
    the host interfaces:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 主机与三种网络模式之间的交互如下图所示。`host` 和 `bridge` 网络中的容器连接了适当的网络接口，并与同一网络中的容器以及外部世界进行通信，但
    `none` 网络与主机接口保持隔离：
- en: '![](img/b60d1e99-879c-46b7-8fde-5c8a47af6900.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60d1e99-879c-46b7-8fde-5c8a47af6900.png)'
- en: 'Other than sharing the host network, the `-p(--publish) [host]:[container]` flag,
    when creating a container, also allows you to map a host port to a container.
    We don''t need attaching a `--expose` flag together with the `--publish` flag,
    as you''ll need to open a container''s port in any case. The following command
    launches a simple HTTP server at port `80`. You can view it with a browser as
    well:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了共享主机网络外，`-p(--publish) [host]:[container]` 标志在创建容器时还允许你将主机端口映射到容器端口。我们不需要同时附加
    `--expose` 标志与 `--publish` 标志，因为无论如何你都需要打开容器的端口。以下命令将在端口 `80` 启动一个简单的 HTTP 服务器，你也可以用浏览器查看它：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Working with a Dockerfile
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfile
- en: When assembling an image, whether using `docker commit` or `export`, optimizing
    the outcome in a managed way is a challenge, let alone integrating it with a CI/CD
    pipeline. A `Dockerfile` represents the building task in the form of code, which
    significantly reduces the difficulty of building tasks for us. In this section,
    we'll describe how to map Docker commands into a `Dockerfile` and take a step
    towards optimizing it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，无论是使用 `docker commit` 还是 `export`，以可管理的方式优化构建结果都是一个挑战，更不用说将其与 CI/CD 流水线集成了。`Dockerfile`
    以代码的形式表示构建任务，这大大减少了构建任务的难度。在这一部分，我们将描述如何将 Docker 命令映射到 `Dockerfile`，并朝着优化它的方向迈出一步。
- en: Writing your first Dockerfile
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个 Dockerfile
- en: 'A `Dockerfile` consists of a series of text instructions to guide the Docker
    daemon to form an image, and a `Dockerfile` must start with the `FROM` directive.
    For example, we may have an image built from the following one-liner:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 由一系列文本指令组成，指导 Docker 守护进程形成一个镜像，`Dockerfile` 必须以 `FROM` 指令开始。例如，我们可能会从以下一行命令构建镜像：'
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This roughly equates to the following `Dockerfile`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致相当于以下的 `Dockerfile`：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Obviously, building with a `Dockerfile` is much more concise and precise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用 `Dockerfile` 构建要更加简洁和精确。
- en: The `docker build [OPTIONS] [CONTEXT]` command is the only command associated
    with building tasks. A context can be a local path, URL, or `stdin`, which denotes
    the location of the `Dockerfile`. Once a build is triggered, the `Dockerfile`,
    alongside everything under the context, will be sent to the Docker daemon beforehand
    and then the daemon will start to execute instructions in the `Dockerfile` sequentially.
    Every execution of the instructions results in a new cache layer, and the ensuing
    instruction is executed at the new cache layer in the cascade. Since the context
    will be sent somewhere that isn't guaranteed to be a local path, and sending too
    many irrelevant files takes time, it's a good practice to put the `Dockerfile`,
    code, necessary files, and a `.dockerignore` file in an `empty` folder to make
    sure the resultant image contains only the desired files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build [OPTIONS] [CONTEXT]` 命令是唯一与构建任务相关的命令。上下文可以是本地路径、URL 或 `stdin`，表示
    `Dockerfile` 的位置。一旦触发构建，`Dockerfile` 以及上下文中的所有内容都会提前发送到 Docker 守护进程，然后守护进程将按顺序执行
    `Dockerfile` 中的指令。每次执行指令都会生成一个新的缓存层，随后的指令将在新的缓存层上执行。由于上下文会被发送到一个不一定是本地路径的地方，且发送太多不相关的文件会浪费时间，因此最好将
    `Dockerfile`、代码、必要的文件和 `.dockerignore` 文件放在一个 `empty` 文件夹中，以确保最终生成的镜像只包含所需的文件。'
- en: 'The `.dockerignore` file is a list indicating which files under the same directory
    can be ignored at build time. It typically looks as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore` 文件是一个列表，指示在构建时可以忽略同一目录下哪些文件。它通常如下所示：'
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Generally, `docker build` will try to locate a file named `Dockerfile` under
    the context to start a build. Sometimes, however, we may want to give it another
    name, which we can do using the `-f` (`--file`) flag. Another useful flag, `-t` (`--tag`),
    is able to give an image one or more repository tags after an image is built.
    Let''s say we want to build a `Dockerfile` named `builder.dck` under `./deploy`
    and label it with the current date and the latest tag. The command to do this
    is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`docker build` 会尝试在上下文中找到一个名为 `Dockerfile` 的文件来开始构建。然而，有时我们可能希望给它一个不同的名字，可以使用
    `-f` (`--file`) 标志来指定。另一个有用的标志是 `-t` (`--tag`)，它可以在镜像构建完成后为镜像添加一个或多个仓库标签。假设我们想在
    `./deploy` 目录下构建一个名为 `builder.dck` 的 `Dockerfile` 并标记当前日期和最新标签，命令如下：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The syntax of a Dockerfile
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 的语法
- en: 'The building blocks of a `Dockerfile` are a dozen directives. Most of these
    are made up of functions of the `docker run/create` flags. Let''s take a look
    at the most essential ones:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 的构建模块由十几个指令组成。它们中的大多数由 `docker run/create` 标志的功能组成。让我们来看看其中最重要的几个：'
- en: '`FROM <IMAGE>[:TAG|[@DIGEST]`: This is to tell the Docker daemon which image
    the current `Dockerfile` is based on. It''s also the one and only instruction
    that has to be in a `Dockerfile`; you can have a `Dockerfile` that contains only
    this line. Like all of the other image-relevant commands, the tag defaults to
    the latest if unspecified.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM <IMAGE>[:TAG|[@DIGEST]]`：这是告诉 Docker 守护进程当前 `Dockerfile` 所基于的镜像。这也是唯一必须出现在
    `Dockerfile` 中的指令；你可以有一个只包含这一行的 `Dockerfile`。与所有其他与镜像相关的命令一样，如果没有指定标签，则默认为最新版本。'
- en: '`RUN`:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：'
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `RUN` instruction runs one line of a command at the current cache layer
    and commits the outcome. The main discrepancy between the two forms is with regards
    to how the command is executed. The first form is called **shell form**. This
    actually executes commands in the form of `/bin/sh -c <commands>`. The other form
    is **exec form**.This treats the command with `exec` directly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` 指令会在当前缓存层运行一行命令，并提交其结果。两种形式之间的主要区别在于命令的执行方式。第一种形式被称为 **shell 形式**，它实际上以
    `/bin/sh -c <commands>` 形式执行命令。另一种形式是 **exec 形式**，它直接使用 `exec` 处理命令。'
- en: Using the shell form is similar to writing shell scripts, hence concatenating
    multiple commands by shell operators and line continuation, condition tests, or
    variable substitutions is completely valid. Bear in mind, however, that commands
    aren't processed by `bash` but by `sh`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 shell 形式类似于编写 shell 脚本，因此通过 shell 操作符和行继续符来连接多个命令、条件测试或变量替换是完全有效的。然而，请记住，命令不是由
    `bash` 处理的，而是由 `sh` 处理的。
- en: The `exec` form is parsed as a JSON array, which means that you have to wrap
    texts with double quotes and escape the reserved characters. Besides, as the command
    is not processed by any shell, the shell variables in the array will not be evaluated.
    On the other hand, if the shell doesn't exist in the base image, you can still
    use the `exec` form to invoke executables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 形式被解析为 JSON 数组，这意味着你必须用双引号将文本括起来，并转义保留字符。此外，由于该命令不会由任何 shell 处理，因此数组中的
    shell 变量不会被评估。另一方面，如果基础镜像中不存在 shell，你仍然可以使用 `exec` 形式来调用可执行文件。'
- en: '`CMD`:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：'
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `CMD` it to set default commands for the built image, but it doesn't run
    the command at build time. If arguments are supplied upon executing `docker run`,
    the `CMD` configurations here are overridden. The syntax rules of `CMD` are almost
    identical to `RUN`; the previous two forms are the `exec` form, and the third
    one is the shell form, which prepends `/bin/sh -c` to the parameters as well.
    There's another `ENTRYPOINT` directive that would interact with `CMD`;the parameter
    of `ENTRYPOINT` would prepend to the three forms of `CMD` when a container starts.
    There can be many `CMD` directives in a `Dockerfile`, but only the last one will
    take effect.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD` 用于设置构建镜像的默认命令，但它不会在构建时运行该命令。如果在执行 `docker run` 时提供了参数，`CMD` 配置会被覆盖。`CMD`
    的语法规则几乎与 `RUN` 相同；前两种形式是 `exec` 形式，第三种是 shell 形式，它会将 `/bin/sh -c` 作为前缀加到参数前。还有一个与
    `CMD` 交互的 `ENTRYPOINT` 指令；当容器启动时，`ENTRYPOINT` 的参数会添加到三种 `CMD` 形式前面。在 `Dockerfile`
    中可以有多个 `CMD` 指令，但只有最后一个会生效。'
- en: '`ENTRYPOINT`:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`：'
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These two forms are, respectively, the `exec` form and the shell form, and
    the syntax rules are the same as `RUN`. The entry point is the default executable
    for an image. This means that when a container spins up, it runs the executable
    configured by `ENTRYPOINT`. When `ENTRYPOINT` is combined with the `CMD` and `docker
    run` arguments, writing it in a different form would lead to very different behavior.
    Here are the rules regarding their combinations:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种形式分别是`exec`形式和 shell 形式，语法规则与`RUN`相同。入口点是镜像的默认可执行文件。这意味着当容器启动时，它会运行由`ENTRYPOINT`配置的可执行文件。当`ENTRYPOINT`与`CMD`和`docker
    run`参数结合使用时，以不同的形式编写会导致截然不同的行为。以下是关于它们组合的规则：
- en: 'If the `ENTRYPOINT` is in shell form, then the `CMD` and `docker run` arguments
    would be ignored. The runtime command would be as follows:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ENTRYPOINT`是以 shell 形式出现，则`CMD`和`docker run`的参数将被忽略。运行时命令将如下所示：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the `ENTRYPOINT` is in `exec` form and the `docker run` arguments are specified,
    then the `CMD` commands are overridden. The runtime command would be as follows:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ENTRYPOINT`是`exec`形式且指定了`docker run`参数，则`CMD`命令会被覆盖。运行时命令将如下所示：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the `ENTRYPOINT` is in `exec` form and only `CMD` is configured, the runtime
    command would become the following for the three forms:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ENTRYPOINT`是`exec`形式且只配置了`CMD`，则对于三种形式，运行时命令将变为以下内容：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`ENV`:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：'
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ENV` instruction sets environment variables for the consequent instructions
    and the built image. The first form sets the key to the string after the first
    space, including special characters, except the line continuation character. The
    second form allows us to set multiple variables in a line, separated with spaces.
    If there are spaces in a value, either enclose them with double quotes or escape
    the space character. Moreover, the key defined with `ENV` also takes effect on
    variables in the same document. See the following examples to observe the behavior
    of `ENV`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`指令为随后的指令和构建的镜像设置环境变量。第一种形式将键设置为第一个空格后的字符串，包括特殊字符，但不包括行继续符。第二种形式允许我们在一行中设置多个变量，变量之间用空格分隔。如果值中包含空格，需用双引号括起来或转义空格字符。此外，使用`ENV`定义的键也会对同一文档中的变量生效。请参见以下示例以观察`ENV`的行为：'
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output during the `docker build` would be as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker build`过程中，输出将如下所示：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`ARG key[=<default value>]`: The `ARG` instruction can pass our arguments as
    environment variables into the building container via the `--build-arg` flag of `docker
    build`. For instance, building the following file using `docker build --build-arg
    FLAGS=--static` would result in `RUN ./build/dev/run --static` on the last line:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARG key[=<default value>]`：`ARG`指令可以通过`docker build`的`--build-arg`标志，将我们的参数作为环境变量传递到构建容器中。例如，使用`docker
    build --build-arg FLAGS=--static`构建以下文件，将导致最后一行出现`RUN ./build/dev/run --static`：'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Unlike `ENV`, only one argument can be assigned per line. If we are using `ARG`
    together with `ENV`, then the value of `ARG`, no matter where it is (either by `--build-arg`
    or the default value), would be overwritten by the value of `ENV`. Due to the
    frequent use of the proxy environment variables, these are all supported as arguments
    by default, including `HTTP_PROXY`, `http_proxy`, `HTTPS_PROXY`, `https_proxy`,
    `FTP_PROXY`, `ftp_proxy`, `NO_PROXY`, and `no_proxy`. This means we can pass these
    building arguments without defining them in the `Dockerfile` beforehand. One thing
    worth noting is that the value of `ARG` would remain in both the shell history
    on the building machine and the Docker history of the image, which means it''s
    wise not to pass sensitive data via `ARG`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ENV`不同，每行只能分配一个参数。如果我们将`ARG`和`ENV`一起使用，则`ARG`的值（无论是通过`--build-arg`传递还是默认值）将被`ENV`的值覆盖。由于代理环境变量的频繁使用，默认情况下所有这些变量都支持作为参数，包括`HTTP_PROXY`、`http_proxy`、`HTTPS_PROXY`、`https_proxy`、`FTP_PROXY`、`ftp_proxy`、`NO_PROXY`和`no_proxy`。这意味着我们可以在不事先在`Dockerfile`中定义它们的情况下传递这些构建参数。需要注意的一点是，`ARG`的值将保留在构建机器的
    shell 历史记录和镜像的 Docker 历史记录中，这意味着不建议通过`ARG`传递敏感数据：
- en: '`LABEL key1=value1 key2=value2 ...`: The use of `LABEL` resembles that of `ENV`,
    but a label is only stored in the metadata section of an image and is used by
    other host programs instead of programs in a container. For example, if we attach
    the maintainer of our image in the form `LABEL maintainer=johndoe@example.com`,
    we can filter the annotated image with the `-f(--filter)` flag in this query: `docker
    images --filter label=maintainer=johndoe@example.com`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL key1=value1 key2=value2 ...`：`LABEL`的使用类似于`ENV`，但标签仅存储在镜像的元数据部分，并由其他主机程序使用，而不是容器中的程序。例如，如果我们在镜像中附加了维护者信息，形式为`LABEL
    maintainer=johndoe@example.com`，则可以通过`-f(--filter)`标志在查询中筛选带有此标签的镜像：`docker images
    --filter label=maintainer=johndoe@example.com`。'
- en: '`EXPOSE <port> [<port> ...]`: This instruction is identical to the `--expose`
    flag used with `docker run/create`, exposing ports in the container created by
    the resulting image.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE <port> [<port> ...]`：此指令与`docker run/create`中使用的`--expose`标志相同，暴露由结果镜像创建的容器中的端口。'
- en: '`USER <name|uid>[:<group|gid>]`: The `USER` instruction switches the user to
    run the subsequent instructions, including the ones in `CMD` or `ENTRYPOINT`.
    However, it can''t work properly if the user doesn''t exist in the image. If you
    want to run instructions using a user that doesn''t exist, you have to run `adduser`
    before using the `USER` directive.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER <name|uid>[:<group|gid>]`：`USER`指令切换到指定的用户，以执行随后的指令，包括`CMD`或`ENTRYPOINT`中的指令。但是，如果镜像中不存在该用户，则无法正常工作。如果要使用不存在的用户运行指令，必须在使用`USER`指令之前运行`adduser`。'
- en: '`WORKDIR <path>`: This instruction sets the working directory to a certain
    path. Environment variables set with `ENV` take effect on the path. The path would
    be created automatically if it doesn''t already exist. It works like `cd` in a
    `Dockerfile`, as it takes both relative and absolute paths and can be used multiple
    times. If an absolute path is followed by a relative path, the result would be
    relative to the previous path:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR <path>`：此指令将工作目录设置为指定的路径。使用`ENV`设置的环境变量会在该路径上生效。如果路径不存在，系统会自动创建。它的工作方式类似于`Dockerfile`中的`cd`，可以接受相对路径和绝对路径，并且可以多次使用。如果在绝对路径后面跟着相对路径，则结果将相对于前一个路径。'
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`COPY`:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`:'
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This directive copies the source to a file or a directory in the building container. The
    source as well as the destination could be files or directories. The source must
    be within the context path and not excluded by `.dockerignore`, as only those
    will be sent to the Docker daemon. The second form is for cases in which the path
    contains spaces. The `--chown` flag enables us to set the file owner on the fly
    without running additional `chown` steps inside containers. It also accepts numeric
    user IDs and group IDs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将源文件复制到构建容器中的文件或目录中。源文件和目标路径可以是文件或目录。源路径必须位于上下文路径内，且不能被`.dockerignore`排除，因为只有这些文件会被发送到Docker守护进程。第二种形式适用于路径包含空格的情况。`--chown`标志使我们可以在运行时设置文件的所有者，而无需在容器内运行额外的`chown`步骤。它还接受数字的用户ID和组ID：
- en: '`ADD`:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`:'
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`ADD` is quite similar to `COPY` in terms of its functionality: it moves files
    into an image. The major differences are that `ADD` supports downloading files
    from a remote address and extracting compressed files from the container in one
    line. As such, `<src>` can also be a URL or compressed file. If `<src>` is a URL,
    `ADD` will download it and copy it into the image; if `<src>` is inferred as a
    compressed file, it''ll be extracted into the `<dest>` path:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`在功能上与`COPY`非常相似：它将文件移动到镜像中。主要的区别在于，`ADD`支持从远程地址下载文件并且可以在一行命令中解压容器中的压缩文件。因此，`<src>`也可以是一个URL或压缩文件。如果`<src>`是URL，`ADD`会将其下载并复制到镜像中；如果`<src>`是被推断为压缩文件，`ADD`会将其解压到`<dest>`路径中：'
- en: '`VOLUME`:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`:'
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `VOLUME` instruction creates data volumes at the given mount points. Once
    it''s been declared during build time, any change in the data volume at consequent
    directives would not persist. Besides, mounting host directories in a `Dockerfile`
    or `docker build` isn''t doable because of portability concerns: there''s no guarantee
    that the specified path would exist in the host. The effect of both syntax forms
    is identical; they only differ with regard to syntax parsing. The second form
    is a JSON array, so characters such as `\` should be escaped.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令在给定的挂载点创建数据卷。一旦在构建时声明，该数据卷在随后的指令中所做的任何更改都不会持久化。此外，由于可移植性问题，在`Dockerfile`或`docker
    build`中挂载主机目录不可行：无法保证指定的路径在主机上存在。这两种语法形式的效果是相同的，它们仅在语法解析上有所不同。第二种形式是JSON数组，因此像`\`这样的字符应该被转义。'
- en: '`ONBUILD [Other directives]`: `ONBUILD` allows you to postpone some instructions
    to later builds that happen in the derived image. For example, suppose we have
    the following two Dockerfiles:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONBUILD [Other directives]`：`ONBUILD`允许您将一些指令推迟到后续构建中的派生镜像中执行。例如，假设我们有以下两个Dockerfile：'
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The instruction then would be evaluated in the following order when running `docker
    build`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`docker build`时，指令将按以下顺序评估：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Organizing a Dockerfile
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织`Dockerfile`
- en: Even though writing a `Dockerfile` is pretty much the same as composing a build
    script, there are some more factors that we should consider to build efficient,
    secure, and stable images. Moreover, a `Dockerfile` itself is also a document.
    Keeping it readable makes it easier to manage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编写`Dockerfile`基本上与编写构建脚本相同，但还有一些因素我们应考虑，以构建高效、安全和稳定的镜像。此外，`Dockerfile`本身也是一个文档。保持其可读性使得它更易于管理。
- en: 'Let''s say we have an application stack that consists of application code,
    a database, and a cache. The initial `Dockerfile` of our stack could be the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用堆栈，其中包括应用程序代码、数据库和缓存。我们堆栈的初始`Dockerfile`可能如下所示：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first suggestion is to make sure a container is dedicated to one thing
    and one thing only. This gives our system better transparency since it helps us
    clarify the boundaries between components in the system. Also, packing unnecessary
    packages is discouraged, as it increases the image size, which could slow down
    the time it takes to build, distribute, and launch the image. We''ll remove the
    installation and configuration of both `mysql` and `redis` in our `Dockerfile`
    in the beginning. Next, the code is moved into the container with `ADD .`, which
    means that we''re very likely to move the whole code repository into the container.
    Usually, there''re lots of files that aren''t directly relevant to the application,
    including VCS files, CI server configurations, or even build caches, and we probably
    wouldn''t like to pack them into an image. For this reason, it is suggested to
    use `.dockerignore` to filter out these files as well. Lastly, using `COPY` is
    preferred over `ADD` in general, unless we want to extract a file in one step.
    This is because it is easier to predict the outcome when we use `COPY`. Now our
    `Dockerfile` is simpler, as shown in the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个建议是确保一个容器专注于一件事情，这样我们的系统就能更透明，因为它帮助我们澄清系统中组件之间的边界。此外，我们不鼓励打包不必要的软件包，因为它会增加镜像的大小，这可能会减慢构建、分发和启动镜像所需的时间。我们将在起初的`Dockerfile`中移除`mysql`和`redis`的安装和配置。接下来，使用`ADD
    .`将代码移到容器中，这意味着我们很可能会将整个代码库移入容器中。通常情况下，有许多与应用程序无直接关系的文件，包括VCS文件、CI服务器配置甚至构建缓存，我们可能不希望将它们打包到镜像中。因此，建议使用`.dockerignore`来过滤掉这些文件。最后，在一般情况下，优先使用`COPY`而不是`ADD`，除非我们希望在一步中提取一个文件。这是因为使用`COPY`时更容易预测结果。现在我们的`Dockerfile`更简单了，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While building an image, the Docker engine will try to reuse the cache layer
    as much as possible, which notably reduces the build time. In our `Dockerfile`,
    we have to go through all the updating and dependency installation processes if
    any package to be installed needs updating. To benefit from building caches, we''ll
    re-order the directives based on a rule of thumb: run less frequent instructions
    first.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，Docker引擎会尽可能地重用缓存层，这显著减少了构建时间。在我们的`Dockerfile`中，如果要安装的任何软件包需要更新，我们就必须进行所有更新和依赖安装过程。为了从构建缓存中受益，我们将根据一个经验法则重新排序指令：先运行较少频繁的指令。
- en: Additionally, as we've described before, any changes made to the container filesystem
    result in a new image layer. To be more specific, `ADD`, `RUN`, and `COPY` create
    layers. Even though we deleted certain files in the consequent layer, these files
    still occupy image layers as they're still being kept at intermediate layers.
    Therefore, our next step is to minimize the image layers by simply compacting
    multiple `RUN` instructions and cleaning the unused files at the end of the `RUN`.
    Moreover, to keep the readability of the `Dockerfile`, we tend to format the compacted
    `RUN` with the line continuation character, `\`. Although `ADD` can fetch a file
    from a remote location to the image, it's still not a good idea to do this as
    this would still occupy a layer in order to store the downloaded file. Downloading
    files with `RUN` and `wget/curl` is more common.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们之前所描述的，对容器文件系统所做的任何更改都会生成一个新的镜像层。更具体来说，`ADD`、`RUN`和`COPY`会创建层。即使我们在后续的层中删除了某些文件，这些文件仍然占用镜像层，因为它们仍然存在于中间层中。因此，我们的下一步是通过将多个`RUN`指令压缩到一起并在`RUN`的最后清理未使用的文件，来最小化镜像层。此外，为了保持`Dockerfile`的可读性，我们倾向于使用行续符号`\`来格式化压缩后的`RUN`指令。尽管`ADD`可以从远程位置获取文件到镜像中，但这仍然不是一个好主意，因为这仍然会占用一个层来存储下载的文件。使用`RUN`和`wget/curl`下载文件更为常见。
- en: 'In addition to working with the building mechanisms of Docker, we''d also like
    to write a maintainable `Dockerfile` to make it clearer, more predictable, and
    more stable. Here are some suggestions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理Docker的构建机制外，我们还希望编写一个可维护的`Dockerfile`，使其更加清晰、可预测和稳定。以下是一些建议：
- en: Use `WORKDIR` instead of the inline `cd`, and use the absolute path for `WORKDIR`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WORKDIR`代替内联的`cd`，并为`WORKDIR`指定绝对路径
- en: Explicitly expose the required ports
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确暴露所需的端口
- en: Specify a tag for the base image
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基础镜像指定标签
- en: Separate and sort packages line by line
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将软件包逐行分开并排序
- en: Use the `exec` form to launch an application
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`exec`形式来启动应用程序
- en: The first four suggestions are pretty straightforward, aimed at eliminating
    ambiguity. The last one refers to how an application is terminated. When a stop
    request from the Docker daemon is sent to a running container, the main process
    (`PID 1`) will receive a stop signal (`SIGTERM`). If the process is not stopped
    after a certain period of time, the Docker daemon will send another signal (`SIGKILL`)
    to kill the container. The `exec` form and shell form differ here. In the shell
    form, the `PID 1` process is `/bin/sh -c`, not the application. Furthermore, different
    shells don't handle signals in the same way. Some forward the stop signal to the
    child processes, while some do not. The shell at Alpine Linux doesn't forward
    them. As a result, to stop and clean up our application properly, using the `exec`
    form is encouraged.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个建议非常直接，旨在消除歧义。最后一个建议涉及到应用程序的终止方式。当Docker守护进程向正在运行的容器发送停止请求时，主进程（`PID 1`）将接收到停止信号（`SIGTERM`）。如果在一定时间内该进程没有停止，Docker守护进程将发送另一个信号（`SIGKILL`）来强制杀死容器。`exec`形式和shell形式在这里有所不同。在shell形式中，`PID
    1`进程是`/bin/sh -c`，而不是应用程序本身。此外，不同的shell处理信号的方式不同。有些会将停止信号转发给子进程，而有些则不会。Alpine
    Linux中的shell就不会转发信号。因此，为了正确停止并清理我们的应用程序，推荐使用`exec`形式。
- en: 'Combining those principles, we have the following `Dockerfile`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些原则，我们得到了以下的`Dockerfile`：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There are other practices that we can follow to make our `Dockerfile` better,
    including starting from a dedicated and smaller base image rather than general-purpose
    distributions, using users other than `root` for better security, and removing
    unnecessary files in the `RUN` in which they are joined.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循其他实践来优化我们的`Dockerfile`，包括使用专用的、更小的基础镜像，而不是通用的发行版，使用非`root`用户以提高安全性，以及在`RUN`命令中删除不必要的文件。
- en: Multi-stage builds
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段构建
- en: The principles we've discussed so far are all about how to make builds fast
    and how to make the final image smaller while keeping the maintainability of the
    `Dockerfile`. Instead of striving to optimize a `Dockerfile`, writing one to build
    the artifacts we need and then moving them to another image with runtime dependencies only
    makes it much easier to sort the different logic out. In the building stage, we
    can forget about minimizing the layers so that the build cache can be reused efficiently;
    when it comes to the release image, we can follow the previously recommended techniques
    to make our image clean and small. Before Docker CE 17.05, we had to write two
    Dockerfiles to implement this build pattern. Now, Docker has built-in support
    to define different stages in a single `Dockerfile`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们讨论的原则，都是关于如何加快构建速度、如何在保持 `Dockerfile` 可维护性的同时减少最终镜像的体积。与其努力优化一个 `Dockerfile`，不如写一个用来构建所需制品的
    `Dockerfile`，然后将它们移到另一个仅包含运行时依赖的镜像中，这样能更容易理清不同的逻辑。在构建阶段，我们可以不必太关心减少层数，以便高效地重用构建缓存；而在发布镜像时，我们可以遵循之前推荐的技巧来保持镜像干净且小巧。在
    Docker CE 17.05 之前，我们需要写两个 Dockerfile 来实现这种构建模式。现在，Docker 已经内建支持在一个 `Dockerfile`
    中定义不同的阶段。
- en: 'Take a `golang` build as an example: this requires lots of dependencies and
    a compiler, but the artifact can merely be a single binary. Let''s look at the
    following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `golang` 构建为例：这需要很多依赖和一个编译器，但最终的产物可能只是一个单一的二进制文件。我们来看下面的例子：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The delimiter for the different stages is the `FROM` directive, and we can name
    the stages with the `AS` keyword after the image name. At the `builder` stage,
    Docker starts a `golang` base image, and then builds the target binary as usual.
    Afterwards, during the second build, it copies the binary from the `builder` container
    with `--from=[stage name|image name]` to a `scratch` image—a reserved name for
    an entirely empty image. As there's only one binary file and one layer in the
    resultant image, its size is dramatically smaller than the `builder` one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不同阶段的分隔符是 `FROM` 指令，我们可以在镜像名称后使用 `AS` 关键字为阶段命名。在 `builder` 阶段，Docker 启动一个 `golang`
    基础镜像，然后像往常一样构建目标二进制文件。之后，在第二次构建中，Docker 使用 `--from=[stage name|image name]` 从
    `builder` 容器复制二进制文件到一个 `scratch` 镜像——一个完全空白的镜像名称。由于结果镜像中只有一个二进制文件和一个层，它的体积比 `builder`
    镜像小得多。
- en: 'The number of stages isn''t limited to two, and the source of the `COPY` directive
    can either be a previously defined stage or a built image. The `ARG` directive
    works against `FROM`, which is also the only exception that can be written before
    a `FROM` directive, as they belong to different stages. In order to use it, the `ARG` directive
    to be consumed in `FROM` should be declared before `FROM`, as shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段的数量不限于两个，`COPY` 指令的源可以是之前定义的阶段或构建的镜像。`ARG` 指令作用于 `FROM`，这也是唯一一个可以写在 `FROM`
    指令之前的例外，因为它们属于不同的阶段。为了使用它，`ARG` 指令必须在 `FROM` 之前声明，如下所示：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Multi-container orchestration
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多容器编排
- en: As we pack more and more applications into isolated boxes, we'll soon realize
    that we need a tool that is able to help us tackle many containers simultaneously.
    In this section, we'll move a step up from spinning up just one single container
    to orchestrating multiple containers in a band.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们将越来越多的应用程序打包进独立的容器中，我们很快就会意识到，需要一种工具帮助我们同时管理多个容器。在这一部分，我们将从启动单个容器逐步过渡到编排多个容器。
- en: Piling up containers
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆积容器
- en: Modern systems are usually built as stacks made up of multiple components that
    are distributed over networks, such as application servers, caches, databases,
    and message queues. Each individual component is also a self-contained system
    with many sub-components. What's more, the rising trend of microservices introduces
    additional degrees of complexity into these entangled relationships between systems.
    Because of this, even though container technology gives us a certain degree of
    relief regarding deployment tasks, coordinating components in a system is still
    difficult.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统通常作为由多个组件构成的堆栈来构建，这些组件分布在网络上，比如应用服务器、缓存、数据库和消息队列。每个组件也是一个自包含的系统，拥有许多子组件。而且，微服务的兴起进一步增加了这些系统间错综复杂关系的复杂性。因此，尽管容器技术在部署任务上为我们提供了一定的帮助，但在一个系统中协调各个组件仍然是一个难题。
- en: Let's say we have a simple application called `kiosk`, which connects to a `redis`
    to manage how many tickets we currently have. Once a ticket is sold, it publishes
    an event through a `redis` channel. The **recorder** subscribes the `redis` channel
    and writes a timestamp log into a MySQL database upon receiving any event.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的应用程序叫做`kiosk`，它连接到`redis`来管理我们当前拥有的票据数量。一旦有票据被售出，它就会通过`redis`频道发布一个事件。**记录器**订阅了这个`redis`频道，并在收到任何事件时，将时间戳日志写入MySQL数据库。
- en: 'For the `kiosk` and the `recorder`, you can find the code as well as their
    Dockerfiles here: [https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter2](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter2). The
    architecture is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`kiosk`和`recorder`，你可以在这里找到代码以及它们的Dockerfile：[https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter2](https://github.com/PacktPublishing/DevOps-with-Kubernetes-Second-Edition/tree/master/chapter2)。架构如下：
- en: '![](img/0adc75ae-67ca-499e-bf09-be8ca35c7489.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0adc75ae-67ca-499e-bf09-be8ca35c7489.png)'
- en: 'We know how to start those containers separately and connect them with each
    other. Based on what we''ve discussed before, we would first create a bridge network
    and run the containers inside:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何单独启动这些容器并将它们连接在一起。基于之前讨论的内容，我们将首先创建一个桥接网络，并在其中运行容器：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because our `kiosk` and `recorder` are much lighter than the database, our applications
    are very likely to start up earlier than the database's. In this case, our `kiosk`
    might fail if any incoming connection requests changes to the databases or to
    Redis. In other words, we have to consider the startup order in our startup scripts.
    We also have to deal with problems such as how to deal with random components
    crashing, how to manage variables, how to scale out certain components, and how
    to manage the states of every moving part.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`kiosk`和`recorder`比数据库轻量，所以我们的应用程序很可能会比数据库先启动。在这种情况下，如果有任何连接请求更改数据库或Redis，`kiosk`可能会失败。换句话说，我们必须在启动脚本中考虑启动顺序。我们还必须处理诸如如何应对随机组件崩溃、如何管理变量、如何扩展某些组件以及如何管理每个运动部件的状态等问题。
- en: An overview of Docker compose
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker compose概述
- en: 'Docker compose is a tool that enables us to run multiple containers with ease.
    It''s a built-in tool in the Docker CE distribution. All it does is read `docker-compose.yml`
    (or `.yaml`) to run the defined containers. A `docker-compose` file is a YAML-based
    template, and it typically looks like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Docker compose是一个让我们轻松运行多个容器的工具。它是Docker CE发行版中的内置工具。它所做的只是读取`docker-compose.yml`（或`.yaml`）文件以运行定义的容器。`docker-compose`文件是基于YAML的模板，通常如下所示：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Launching it is pretty simple: save the template to `docker-compose.yml` and
    use the `docker-compose up` command to start it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 启动它相当简单：将模板保存为`docker-compose.yml`，然后使用`docker-compose up`命令来启动它：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Let's take a look at what `docker-compose` did when the `up` command was executed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下当执行`up`命令时，`docker-compose`做了什么。
- en: Docker compose is basically a medley of Docker functions for multiple containers.
    For example, the counterpart of `docker build` is `docker-compose build`; the
    former builds a Docker image and the latter builds Docker images listed in `docker-compose.yml`.
    Remember, however, that the `docker-compose run` command doesn't correspond to `docker
    run`; it's actually used to run a specific container from the configuration in `docker-compose.yml`.
    In fact, the closest command to `docker run` is `docker-compose up`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Docker compose基本上是多个Docker功能的组合。例如，`docker build`的对应命令是`docker-compose build`；前者构建一个Docker镜像，后者则构建`docker-compose.yml`中列出的Docker镜像。请记住，`docker-compose
    run`命令并不对应于`docker run`；它实际上用于从`docker-compose.yml`中的配置运行特定的容器。实际上，与`docker run`最接近的命令是`docker-compose
    up`。
- en: The `docker-compose.yml` file consists of different configurations of volumes,
    networks, and services. There should be a version definition to indicate which
    version of the `docker-compose` format should be used. With this understanding
    of the template structure, what the previous `hello-world` example does is quite
    clear; it creates a service called `hello-world` that uses the `hello-world:latest` image.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`文件包含了不同的卷、网络和服务配置。应该有一个版本定义来指明应使用哪个版本的`docker-compose`格式。通过对模板结构的理解，我们可以很清楚地看到之前的`hello-world`示例是做了什么；它创建了一个名为`hello-world`的服务，使用`hello-world:latest`镜像。'
- en: Since there's no network defined, `docker-compose` will create a new network
    with a default driver and connect services to that network, as shown at the start
    of the output of the example.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有定义网络，`docker-compose` 将创建一个新的网络并使用默认驱动程序，将服务连接到该网络，如示例输出开始部分所示。
- en: The network name of a container will be the name of the service. You may notice
    that the name displayed in the console differs slightly from its original one
    in `docker-compose.yml`. This is because Docker compose tries to avoid name conflicts
    between containers. As a result, Docker compose runs the container with the name
    it generated and makes a network alias with the service name. In this example,
    both `hello-world` and `user_hello-world_1` are resolvable to other containers
    within the same network.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的网络名称将是服务的名称。你可能会注意到，在控制台中显示的名称与 `docker-compose.yml` 中的原始名称稍有不同。这是因为 Docker
    compose 尝试避免容器名称之间的冲突。因此，Docker compose 会使用其生成的名称运行容器，并用服务名称创建一个网络别名。在这个示例中，`hello-world`
    和 `user_hello-world_1` 都能在同一网络中的其他容器内解析。
- en: Docker compose is the easiest option to run multiple containers on a single
    machine, but it's not designed to orchestrate containers across networks. Other
    major container orchestration engines such as **Kubernetes**, **Docker Swarm**,
    **Mesos** (with **Marathon** or **Aurora**), or **Nomad** are better choices to
    run containers across multiple nodes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Docker compose 是在单台机器上运行多个容器的最简便选项，但它并非设计用来跨网络编排容器。其他主要的容器编排引擎，如 **Kubernetes**、**Docker
    Swarm**、**Mesos**（结合 **Marathon** 或 **Aurora**）或 **Nomad**，是跨多个节点运行容器的更好选择。
- en: Composing containers
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合容器
- en: 'As Docker compose is the same as Docker in many aspects, it''s more efficient
    to understand how to write `docker-compose.yml` with examples than start from
    `docker-compose` syntax. Let''s now go back to the `kiosk-example` we looked at
    earlier and start with a `version` definition and four `services`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker compose 在许多方面与 Docker 相同，因此通过示例学习如何编写 `docker-compose.yml` 要比从 `docker-compose`
    语法开始更有效。现在，让我们回到之前查看过的 `kiosk-example`，从 `version` 定义和四个 `services` 开始：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `docker run` arguments for `kiosk-example` are pretty simple. They include
    a publishing port and an environment variable. On the Docker compose side, we
    fill the source image, the publishing port, and environment variables accordingly.
    Because Docker compose is able to handle `docker build`, it can build images if
    those images can''t be found locally. We want to use this to decrease the effort
    of image management:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`kiosk-example` 的 `docker run` 参数非常简单，包括一个发布端口和一个环境变量。在 Docker compose 部分，我们相应地填写源镜像、发布端口和环境变量。由于
    Docker compose 能处理 `docker build`，如果本地找不到镜像，它可以构建镜像。我们希望利用这一点来减少镜像管理的工作量：'
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Converting the Docker run of the `recorder-example` and `redis` in the same
    manner, we have a template that looks as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `recorder-example` 和 `redis` 的 Docker run 以相同方式转换，我们得到了如下模板：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For the MySQL part, MySQL requires a data volume to keep its data as well as
    its configurations. In addition to the `lmysql` section, we add `volumes` at the
    level of `services` and an empty map called `mysql-vol` to claim a data volume:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 MySQL 部分，MySQL 需要一个数据卷来保存其数据及配置。除了 `lmysql` 部分外，我们还需要在 `services` 层级添加 `volumes`
    并声明一个名为 `mysql-vol` 的空映射，以申请一个数据卷：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: One of the benefits of this is that we can manage the launching order between
    the components with `depends_on`. What this does is maintain the order; it can't
    detect whether the components that it will use are ready. This means our application
    could still connect and write to the database before the database is ready. All
    in all, as our program is a part of a distributed system with many moving parts,
    it's a good idea to make it resilient to the changes of its dependencies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中的一个好处是，我们可以通过 `depends_on` 管理组件之间的启动顺序。它的作用是保持顺序；但它无法检测所依赖的组件是否已准备好。这意味着我们的应用程序仍然可能在数据库准备好之前连接并写入数据库。总的来说，由于我们的程序是一个分布式系统的一部分，包含许多移动组件，因此让它对依赖项的变化具有一定的弹性是一个好主意。
- en: 'Combining all of the preceding configurations, including `depends_on`, we have
    the final template, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 结合之前的所有配置，包括 `depends_on`，我们得到最终模板，如下所示：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This file is put in the `root` folder of a project. The corresponding file
    tree is shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件被放置在项目的 `root` 文件夹中。相应的文件树如下所示：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, run `docker-compose up` to check everything is fine. We can check
    every component is linked nicely using `kiosk`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行 `docker-compose up` 来检查一切是否正常。我们可以使用 `kiosk` 检查每个组件是否已正确链接：
- en: '[PRE63]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Writing a template for Docker compose is as simple as this. We're now able to
    run an application in the stack with ease.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Docker Compose的模板是如此简单。我们现在能够轻松地在堆栈中运行一个应用程序。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Starting from the very primitive elements of Linux containers and Docker tool
    stacks, we went through every aspect of containerizing an application, including
    packing and running a Docker container, writing a `Dockerfile` for code-based
    immutable deployment, and manipulating multiple containers with Docker compose.
    However, the abilities we gained in this chapter only allow us to run and connect
    containers within the same host, which limits our ability to build larger applications.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux容器和Docker工具栈的最基本元素开始，我们探讨了容器化应用程序的方方面面，包括打包和运行Docker容器、为基于代码的不可变部署编写`Dockerfile`，以及使用Docker
    Compose操作多个容器。然而，我们在本章中获得的能力仅限于在同一主机内运行和连接容器，这限制了我们构建更大应用程序的能力。
- en: In [Chapter 3](a5cf080a-372a-406e-bb48-019af313c676.xhtml), *Getting Started
    with Kubernetes*, we'll meet Kubernetes, unleashing the power of containers beyond
    the limits of scale.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](a5cf080a-372a-406e-bb48-019af313c676.xhtml)，《*Kubernetes入门*》中，我们将介绍Kubernetes，释放容器的力量，突破规模的限制。
