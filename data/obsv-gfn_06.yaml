- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Tracing Technicalities with Grafana Tempo
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Grafana Tempo 进行追踪技术细节
- en: '**Grafana Tempo** is the third telemetry storage tool from Grafana that we’ll
    discuss; it provides the capability to store and query trace data. This chapter
    will introduce the **Tempo query language** (**TraceQL**). TraceQL can be used
    to select and filter traces generated by your applications to gather insights
    from across traces; the language is very similar to LogQL and PromQL but tailored
    to trace data. In this chapter, we will explore the major tracing protocols and
    how they can be used to output traces from applications; this will help you make
    informed choices on which protocol to use in an application, or which protocols
    to support when collecting data. We’ll then explore the architecture of Tempo
    to understand how it can fulfill the need for a scalable platform for tracing.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grafana Tempo** 是 Grafana 提供的第三款遥测存储工具；它提供了存储和查询追踪数据的能力。本章将介绍 **Tempo 查询语言**（**TraceQL**）。TraceQL
    可用于选择和过滤由应用程序生成的追踪数据，从而收集跨追踪的见解；该语言与 LogQL 和 PromQL 非常相似，但针对追踪数据进行了定制。在本章中，我们将探索主要的追踪协议以及如何使用它们输出应用程序的追踪数据；这将帮助你在应用程序中做出明智的选择，选择合适的协议或在收集数据时支持哪些协议。接下来，我们将探索
    Tempo 的架构，以了解它如何满足可扩展的追踪平台需求。'
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Introducing Tempo and the TraceQL query language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Tempo 和 TraceQL 查询语言
- en: Exploring tracing protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索追踪协议
- en: Understanding the Tempo architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Tempo 架构
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you will use the demo application and Grafana Cloud instance
    (set up in [*Chapter 3*](B18277_03.xhtml#_idTextAnchor063)). You'll find the code
    for the chapter in the GitHub repository at [https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6](https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6).
    You'll find the *Code in Action* videos at [https://packt.link/fJVXi](https://packt.link/fJVXi).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用演示应用和 Grafana Cloud 实例（在 [*第三章*](B18277_03.xhtml#_idTextAnchor063)
    中设置）。你可以在 GitHub 仓库中的 [https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6](https://github.com/PacktPublishing/Observability-with-Grafana/tree/main/chapter6)
    找到本章的代码。你还可以在 [https://packt.link/fJVXi](https://packt.link/fJVXi) 找到 *Code in
    Action* 视频。
- en: Updating the OpenTelemetry Demo application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 OpenTelemetry 演示应用
- en: For this chapter, we have provided an updated `OTEL-Collector.yaml` with additional
    tracing configuration. This updated configuration is in the GitHub repository
    in the `chapter6` directory. Full details on the update process are available
    from the GitHub repository in `README.md`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们提供了一个更新的 `OTEL-Collector.yaml`，其中包含额外的追踪配置。这个更新的配置位于 GitHub 仓库的 `chapter6`
    目录中。更新过程的完整细节可以在 GitHub 仓库中的 `README.md` 文件中找到。
- en: 'To apply this updated configuration to the OpenTelemetry Collector, follow
    these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此更新的配置应用到 OpenTelemetry Collector，请按照以下步骤操作：
- en: 'Upgrade the Collector with Helm:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Helm 升级 Collector：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Validate that the upgrade was successful:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证升级是否成功：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your traces will now have more labels, and will also produce service graphs
    and span metrics.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的追踪数据现在将拥有更多标签，并且还将生成服务图和跨度指标。
- en: Now that our local installation is updated, let’s begin by exploring the third
    query language, TraceQL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的本地安装已更新，让我们从探索第三种查询语言 TraceQL 开始。
- en: Introducing Tempo and the TraceQL query language
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Tempo 和 TraceQL 查询语言
- en: Tempo and TraceQL are the newest of the tools and query languages we will explore
    in depth in this book. Like LogQL, TraceQL was built using PromQL as an inspiration
    and offers developers and operators a familiar set of filtering, aggregation,
    and mathematical tools that aid in the observability flow between metrics, logs,
    and traces.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Tempo 和 TraceQL 是我们将在本书中深入探索的最新工具和查询语言。像 LogQL 一样，TraceQL 是以 PromQL 为灵感构建的，为开发者和运维人员提供了一套熟悉的过滤、聚合和数学工具，帮助在指标、日志和追踪数据之间实现可观察性流。
- en: 'Let’s have a quick look at how Tempo sees trace data:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解 Tempo 如何查看追踪数据：
- en: '**Trace collection**: Introduced in [*Chapter 2*](B18277_02.xhtml#_idTextAnchor043),
    a trace (or distributed trace) is a collection of data that represents a request
    propagating through a system. Traces are often collected from multiple applications.
    Spans are sent by each application to some form of collection architecture and,
    ultimately, to Tempo for storage and querying.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trace 收集**：在[*第2章*](B18277_02.xhtml#_idTextAnchor043)中介绍了，trace（或分布式 trace）是一组数据，表示一个请求在系统中的传播。traces
    通常从多个应用程序收集。每个应用程序将 spans 发送到某种收集架构，最终发送到 Tempo 进行存储和查询。'
- en: '**Trace fields**: The following diagram introduces a simplified structure of
    a trace, similar to the simplified structure of logs, seen in [*Chapter 4*](B18277_04.xhtml#_idTextAnchor092),
    and traces, seen in [*Chapter 5*](B18277_05.xhtml#_idTextAnchor106):'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trace 字段**：以下图表介绍了 trace 的简化结构，类似于在[*第4章*](B18277_04.xhtml#_idTextAnchor092)中看到的日志的简化结构，以及在[*第5章*](B18277_05.xhtml#_idTextAnchor106)中看到的
    traces：'
- en: '![Figure 6.1 – A simplified view of a trace containing four spans](img/B18277_Figure_6.1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 包含四个 span 的 trace 简化视图](img/B18277_Figure_6.1.jpg)'
- en: Figure 6.1 – A simplified view of a trace containing four spans
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 包含四个 span 的 trace 简化视图
- en: Back in [*Chapter 2*](B18277_02.xhtml#_idTextAnchor043), we introduced the common
    fields of a trace. In the preceding figure, we can see that all four spans have
    the same `trace_id`, which is the unique identifier of the whole trace. Each span
    has a unique identifier, the `span_id`. Each span also records where it came from,
    using the `parent_id` field. Finally, the start and end times are recorded. This
    simplified view does exclude several of the fields seen in the **OpenTelemetry
    Protocol** (**OTLP**), **Zipkin**, and **Jaeger**, which are used to capture a
    lot of contextual information. We will discuss these later in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18277_02.xhtml#_idTextAnchor043)中，我们介绍了一个 trace 的常见字段。在前面的图示中，我们可以看到四个
    span 都具有相同的 `trace_id`，它是整个 trace 的唯一标识符。每个 span 都有一个唯一的标识符，即 `span_id`。每个 span
    还记录了它的来源，通过 `parent_id` 字段来表示。最后，记录了开始和结束时间。这个简化的视图排除了 **OpenTelemetry 协议** (**OTLP**)、**Zipkin**
    和 **Jaeger** 中的一些字段，这些字段用于捕捉大量的上下文信息。我们将在本章后面讨论这些内容。
- en: Now that we’ve seen the structure of trace data, let’s now explore the Tempo
    interface and how we can query data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过 trace 数据的结构，接下来我们来探索 Tempo 接口，以及如何查询数据。
- en: Exploring the Tempo features
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Tempo 特性
- en: In this section, we will introduce the major features of Tempo, the tracing
    platform available in Grafana, and its query language, TraceQL. In *Chapters 4*
    and *5*, we introduced the LogQL and PromQL languages, which focus on being able
    to select log or metric data and offer detailed functionality to perform a powerful
    analysis of the selected data. Currently, PromQL only offers the ability to select
    trace data. While there are powerful tools to select this data, there are no tools
    to perform an analysis. Such functionality is an eventual aim for the product,
    but we wanted to highlight the current state of Tempo at `v2.3.x`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Tempo 的主要功能，它是 Grafana 中的追踪平台，以及它的查询语言 TraceQL。在*第4章*和*第5章*中，我们介绍了
    LogQL 和 PromQL 语言，它们专注于选择日志或度量数据，并提供详细功能来对选定的数据进行强大的分析。目前，PromQL 仅提供选择 trace 数据的功能。尽管有强大的工具可以选择这些数据，但目前没有工具进行分析。这种功能是产品的最终目标，但我们想要强调的是
    Tempo 在 `v2.3.x` 版本中的当前状态。
- en: Let’s begin by exploring the user interface for Tempo and how it represents
    trace data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索 Tempo 的用户界面开始，看看它如何呈现 trace 数据。
- en: The Tempo interface
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tempo 接口
- en: 'The main view used to explore data in Tempo is split into two parts, the **query
    editor**, and the **trace view**. In the following screenshot, the query editor
    is on the left and the trace view is on the right. When you first enter the view,
    you will only see the query editor. The trace view is opened when a trace ID or
    span ID is clicked on:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用于探索 Tempo 数据的主要视图分为两部分，**查询编辑器**和**trace 视图**。在下图中，查询编辑器位于左侧，trace 视图位于右侧。当你首次进入视图时，你只会看到查询编辑器。点击
    trace ID 或 span ID 时，trace 视图会被打开：
- en: '![Figure 6.2 – The query editor (left) and the trace view (right)](img/B18277_Figure_6.2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 查询编辑器（左）和 trace 视图（右）](img/B18277_Figure_6.2.jpg)'
- en: Figure 6.2 – The query editor (left) and the trace view (right)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 查询编辑器（左）和 trace 视图（右）
- en: The results panel is contextual. If we use TraceQL to run a search, it will
    return a list of traces and spans that match; this is shown on the left in the
    preceding screenshot. However, if we search for a specific trace ID, we will be
    shown the trace view on the right, where we can explore the spans in the trace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果面板是上下文相关的。如果我们使用 TraceQL 进行搜索，它将返回一个匹配的追踪和跨度列表；这在前面的截图的左侧显示。然而，如果我们搜索特定的追踪
    ID，我们将在右侧显示追踪视图，在那里我们可以探索该追踪中的跨度。
- en: 'While we are examining the query panel, let’s look at two of the different
    search modes we can use, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看查询面板时，让我们来看一下我们可以使用的两种不同的搜索模式，如下所示：
- en: '![Figure 6.3 – Search modes](img/B18277_Figure_6.3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 搜索模式](img/B18277_Figure_6.3.jpg)'
- en: Figure 6.3 – Search modes
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 搜索模式
- en: 'The two search modes shown in the preceding screenshot are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图中显示的两种搜索模式如下：
- en: '**Basic Search mode**: Here, you are presented with drop-down menus to select
    the traces you are interested in. This is especially useful for people who are
    new to Tempo and want to get data quickly, but we will not explore this search
    mode in this book. Be aware that this mode is due to be deprecated in Grafana
    10.3.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本搜索模式**：在这个模式下，系统会提供下拉菜单，供你选择感兴趣的追踪。对于初次使用 Tempo 并且希望快速获取数据的人来说，这非常有用，但我们在本书中不会探讨这个搜索模式。请注意，此模式将在
    Grafana 10.3 中被弃用。'
- en: '**TraceQL mode**: This allows you to use TraceQL to search in a very granular
    way for the data you need. This is the default search mode.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TraceQL 模式**：这个模式允许你使用 TraceQL 以非常精细的方式搜索你需要的数据。这是默认的搜索模式。'
- en: 'As well as these, three search modes are available:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有三种搜索模式可用：
- en: '**Loki Search mode**: This should be familiar to you from [*Chapter 4*](B18277_04.xhtml#_idTextAnchor092);
    it is available in Tempo, so you can pivot between logs containing trace and span
    IDs and a full trace view very quickly.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Loki 搜索模式**：你应该对这个模式感到熟悉，它在[*第4章*](B18277_04.xhtml#_idTextAnchor092)中有所介绍；它可以在
    Tempo 中使用，因此你可以非常快速地在包含追踪和跨度 ID 的日志与完整追踪视图之间切换。'
- en: '**JSON File mode**: This allows for a trace saved in the JSON format to be
    imported and viewed directly. Combined with the export functionality, this allows
    for the simple preservation and sharing of interesting traces. Exploring the data
    in an exported JSON file is a good exercise for understanding the underlying data
    structures used in tracing.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON 文件模式**：这个模式允许直接导入并查看以 JSON 格式保存的追踪。结合导出功能，它使得有趣的追踪可以简单地保存和共享。在导出的 JSON
    文件中探索数据是理解追踪中使用的底层数据结构的一个很好的练习。'
- en: '**Service Graph mode**: One of the most powerful features of collecting distributed
    traces is the ability to visualize the connections between those services. This
    tool gives anyone a clear graphical representation of how applications in a system
    communicate with each other. This functionality leverages metrics and traces together
    to represent a system’s current state. The tool will also indicate erroring requests
    in red and successful requests in green.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务图模式**：收集分布式追踪的最强大功能之一就是能够可视化这些服务之间的连接。这个工具为任何人提供了一个清晰的图形表示，展示系统中应用程序之间是如何相互通信的。该功能结合了指标和追踪来表示系统的当前状态。工具还会用红色标示出出错的请求，用绿色标示出成功的请求。'
- en: 'The following screenshot shows the default view of a service graph:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下方截图显示了服务图的默认视图：
- en: '![Figure 6.4 – Service graphs](img/B18277_Figure_6.4.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 服务图](img/B18277_Figure_6.4.jpg)'
- en: Figure 6.4 – Service graphs
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 服务图
- en: As well as representing the connections between services, the preceding screenshot
    shows the request rates and average latency of the responses. Above the service
    graph, the **Requests, Errors, and Duration** (**RED**) metrics are shown. We
    will discuss these metrics in greater detail in [*Chapter 9*](B18277_09.xhtml#_idTextAnchor183).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示服务之间的连接，前面的截图还显示了请求率和响应的平均延迟。在服务图上方，显示了**请求、错误和持续时间**（**RED**）指标。我们将在[*第9章*](B18277_09.xhtml#_idTextAnchor183)中详细讨论这些指标。
- en: At the time of writing, this aspect of OpenTelemetry and Tempo is under active
    development, and the authors are looking forward to the features that are coming.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，OpenTelemetry 和 Tempo 的这一部分正在积极开发中，作者期待即将推出的功能。
- en: Now that we have seen the interface for Tempo, let us understand how to use
    TraceQL to query trace data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过 Tempo 的界面，接下来让我们了解如何使用 TraceQL 查询追踪数据。
- en: Exploring the Tempo Query language
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Tempo 查询语言
- en: Like Prometheus and Loki, Tempo offers a query language, **TraceQL**. Now that
    you are familiar with the interface of Tempo and the structure of traces, let’s
    explore the features of TraceQL.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Prometheus 和 Loki 一样，Tempo 提供了一种查询语言，**TraceQL**。现在你已经熟悉了 Tempo 的界面和跟踪结构，让我们来探索
    TraceQL 的功能。
- en: Field types
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段类型
- en: 'TraceQL uses two field types, **intrinsic fields** and **attribute fields**.
    Let’s look at these in detail:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: TraceQL 使用两种字段类型，**内在字段** 和 **属性字段**。让我们详细了解这些字段：
- en: '`status`: The value could be `error`, `ok`, or unset (`null`)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 该值可以是 `error`、`ok` 或未设置（`null`）'
- en: '`statusMessage`: Optional text to clarify the status'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusMessage`: 可选的文本，用于阐明状态'
- en: '`duration`: The time between the start and end of the span'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`: 跨度的开始和结束之间的时间'
- en: '`name`: The operation or span name'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 操作或跨度的名称'
- en: '`kind`: The value could be `server`, `client`, `producer`, `consumer`, `internal`,
    or `unspecified`, which is a fallback value'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`: 该值可以是 `server`、`client`、`producer`、`consumer`、`internal` 或 `unspecified`，其中
    `unspecified` 是回退值'
- en: '`traceDuration`: Number of milliseconds between the start and end of all spans
    in the trace'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceDuration`: 跟踪中所有跨度的开始和结束之间的毫秒数'
- en: '`rootName`: The name of the first span of the trace'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rootName`: 跟踪中第一个跨度的名称'
- en: '`rootServiceName`: The name of the first service of the trace'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rootServiceName`: 跟踪中第一个服务的名称'
- en: '`span.http.method` and `span.app.ads.ad_response_type`.*   `resource.container.id`
    and `resource.k8s.node.name`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span.http.method` 和 `span.app.ads.ad_response_type`。* `resource.container.id`
    和 `resource.k8s.node.name`。'
- en: For efficient querying, it is best practice to always include `span.` and `resource.`
    in an attribute query. However, it is possible to use a leading `.` to query when
    you are unsure whether a field is a span or resource – for example, `.http.method`
    or `.k8s.node.name`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高查询效率，最佳实践是始终在属性查询中包含 `span.` 和 `resource.`。然而，当你不确定某个字段是跨度还是资源时，可以使用前缀 `.`
    来进行查询，例如 `.http.method` 或 `.k8s.node.name`。
- en: 'When looking at an individual span, you can see the fields available under
    **Span Attributes** and **Resource Attributes**. This expanded view of a single
    trace shows the fields that are contained in the span:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 查看单个跨度时，你可以看到在 **跨度属性** 和 **资源属性** 下可用的字段。这个展开视图显示了包含在跨度中的字段：
- en: '![Figure 6.5 – Attributes for a span](img/B18277_Figure_6.5.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 跨度的属性](img/B18277_Figure_6.5.jpg)'
- en: Figure 6.5 – Attributes for a span
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 跨度的属性
- en: Now that you have a good grasp of the fields available when searching traces
    in Tempo, let’s have a look at how to search for traces and spans.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地掌握了在 Tempo 中搜索跟踪时可用的字段，让我们来看一下如何搜索跟踪和跨度。
- en: Selecting traces and spans
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择跟踪和跨度
- en: 'TraceQL offers tools to select data to show in a dashboard, or just to explore
    the current state of the system. These are described in the following table:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TraceQL 提供了工具来选择在仪表盘中显示的数据，或仅仅探索系统的当前状态。以下表格描述了这些工具：
- en: '| **Name** | **Syntax** | **Operators** | **Scope** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **语法** | **操作符** | **范围** |'
- en: '| Field selector | `{field = "` `value"}` | `=`, `!=`, `>`, `>=`, `<`, `<=`,
    `=~`, `!~` | Selects spans on the value of a field |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 字段选择器 | `{field = "` `value"}` | `=`, `!=`, `>`, `>=`, `<`, `<=`, `=~`, `!~`
    | 选择特定字段值的跨度 |'
- en: '| Field expressions | `{field1="value1" &&` `field2="value2"}` | `&&`, `&#124;&#124;`
    | Selects spans on the values of multiple fields |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 字段表达式 | `{field1="value1" &&` `field2="value2"}` | `&&`，`&#124;&#124;` |
    选择多个字段值匹配的跨度 |'
- en: '| Logical operators | `{field1="value1} && {``field1="value2}` | `&&`, `&#124;&#124;`
    | Selects spans where a logical check between sets of spans is `true`. This can
    check multiple fields. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑操作符 | `{field1="value1} && {``field1="value2}` | `&&`，`&#124;&#124;` |
    选择逻辑检查为 `true` 的跨度，这可以检查多个字段。 |'
- en: '| Structural operators | `{field1="value1"} > {``field2="value2}` | `>`, `>>`,
    `~` | Searches for spans in the second filter where they are related to the first
    filter.These are explained in more detail after this table. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 结构操作符 | `{field1="value1"} > {``field2="value2}` | `>`，`>>`，`~` | 在第二个过滤器中搜索跨度，检查它们与第一个过滤器的关系。后续将更详细解释这些操作符。
    |'
- en: Table 6.1 – The selection operators available in TraceQL
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – TraceQL 中可用的选择操作符
- en: 'Structural operators offer the ability to carry out queries that take account
    of where conditions are met upstream (parent) or downstream (child) in a trace.
    Let’s look at some examples:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结构操作符提供了执行查询的能力，考虑到条件是否在跟踪中的上游（父级）或下游（子级）满足。让我们看一些示例：
- en: '`>` or the **child operator** refers to the direct child, such as the following:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 或 **子操作符** 表示直接子跨度，如下所示：'
- en: '[PRE2]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding line would search for any span from the product catalog service,
    where the frontend service was the immediate parent.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述行将搜索来自产品目录服务的所有跨度，其中前端服务是直接父节点。
- en: '`>>` or the **descendent operator** refers to any descendent, such as the following:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>>` 或 **后代运算符** 表示任何后代，例如以下内容：'
- en: '[PRE3]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This would search for any span from the cart service where the frontend service
    was a parent in the trace but could have passed through another service first,
    such as the checkout service.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将搜索来自购物车服务的所有跨度，其中前端服务是追踪中的父节点，但它可能首先经过其他服务，例如结账服务。
- en: '`~` or the **sibling operator** refers to any spans that share the same parent,
    such as the following:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~` 或 **兄弟运算符** 表示共享相同父节点的任何跨度，例如以下内容：'
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would search for any span that visited the frontend multiple times. In
    the demo application, the frontend service would be the parent.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将搜索任何多次访问前端的跨度。在演示应用中，前端服务将是父节点。
- en: These operators allow us to select data. TraceQL also allows tools to carry
    out aggregation and mathematical functions on trace data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符允许我们选择数据。TraceQL 还允许工具对追踪数据执行聚合和数学函数操作。
- en: Aggregators and arithmetic
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合器和算术
- en: 'Aggregators and mathematical functions allow for more complex queries. These
    can display information aggregated across all traces. Some of these are described
    in the following table:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合器和数学函数允许进行更复杂的查询。它们可以显示跨所有追踪信息的聚合数据。以下表格中描述了一些聚合器：
- en: '| **Name** | **Syntax** | **Operators** | **Scope** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **语法** | **运算符** | **作用域** |'
- en: '| Count aggregator | `&#124; count()` `>` `10` | `count()` | Refines the returned
    spans by the total count of spans in the span set |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 计数聚合器 | `&#124; count()` `>` `10` | `count()` | 按跨度集中的跨度总数对返回的跨度进行精炼 |'
- en: '| Numeric aggregators | `&#124;` `avg(duration) >` `20ms` | `avg()`, `max()`,
    `min()`, and `sum()` | Refines the returned spans by the field in the span set
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 数值聚合器 | `&#124;` `avg(duration) >` `20ms` | `avg()`、`max()`、`min()` 和 `sum()`
    | 按字段对跨度集中的返回跨度进行精炼 |'
- en: '| Arithmetic operators | `{field1 < field2 *` `10}` | `+`, `-`, `*`, `/`, and
    `^` | Performs arithmetic on numeric fields |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算符 | `{field1 < field2 *` `10}` | `+`、`-`、`*`、`/` 和 `^` | 对数字字段执行算术运算
    |'
- en: Table 6.2 – Aggregation and mathematical operators in TraceQL
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 – TraceQL中的聚合和数学运算符
- en: It is worth noting that TraceQL is in active development at the time of writing,
    so this list of operators is expected to grow.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，TraceQL 在编写时处于积极开发阶段，因此此运算符列表预计会不断增长。
- en: Now that you have seen how to search trace data, let’s discuss the important
    topic of moving seamlessly between data types to get a full picture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何搜索追踪数据，让我们讨论如何无缝地在数据类型之间切换，以便获得完整的视图。
- en: Pivoting between data types
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型之间的转换
- en: When correctly instrumented, an application will produce data that can be used
    to move between traces, logs, and metrics to truly understand what is happening.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确地进行仪表化时，应用程序将生成数据，可用于在追踪、日志和指标之间切换，从而真正理解发生了什么。
- en: 'Let’s consider the following span, where an error was seen in `checkoutservice`.
    This could be a problematic error in a real shop, as it suggests a customer got
    to the checkout and was unable to complete their sale for some reason:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下跨度，其中在`checkoutservice`中发现了一个错误。这可能是实际商店中的一个问题，因为它表明客户到达了结账页面，却因某种原因无法完成销售：
- en: '![Figure 6.6 – Finding the logs for an error](img/B18277_Figure_6.6.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 查找错误的日志](img/B18277_Figure_6.6.jpg)'
- en: Figure 6.6 – Finding the logs for an error
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 查找错误的日志
- en: The query interface for Tempo offers a helpful link, `service_name` and `service_namespace`
    fields from the trace to query Loki. In a similar way, services can inject the
    trace context (`traceId` and `spanId`) into their log output where available.
    Loki can then be configured to provide contextual linking to Tempo, to see the
    trace view. Finally, as mentioned in [*Chapter 5*](B18277_05.xhtml#_idTextAnchor106),
    metrics can present exemplars, which allow users to see a sample trace from a
    metric graph.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Tempo的查询界面提供了一个有用的链接，`service_name` 和 `service_namespace` 字段可用于查询 Loki。以类似的方式，服务可以将追踪上下文（`traceId`
    和 `spanId`）注入到其日志输出中（如果可用）。然后，可以配置Loki提供上下文链接到Tempo，以查看追踪视图。最后，正如在 [*第5章*](B18277_05.xhtml#_idTextAnchor106)
    中提到的，指标可以呈现示例，这使得用户能够查看来自指标图表的样本追踪。
- en: We’ve explored the ways of seeing the data produced by applications. In the
    next section, we will understand the different protocols that are available to
    produce trace data for Grafana Tempo.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了查看应用程序生成数据的方法。在下一节中，我们将了解用于生成 Grafana Tempo 跟踪数据的不同协议。
- en: Exploring tracing protocols
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索跟踪协议
- en: In [*Chapter 2*](B18277_02.xhtml#_idTextAnchor043), we introduced the three
    main **tracing protocols**, OTLP, Zipkin, and Jaeger. In this section, we will
    explore some of the features of these protocols, how well-supported they are,
    and how to use them in the software services that you write. We will also discuss
    the different **headers** used by these protocols to propagate context to other
    services. A tracing protocol is made up of a set of headers that are added to
    the HTTP requests made by an instrumented application. These headers are what
    propagate the information of individual spans to downstream services. Once all
    of these spans are collected, they form a fully distributed trace.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18277_02.xhtml#_idTextAnchor043)中，我们介绍了三种主要的**跟踪协议**，OTLP、Zipkin 和
    Jaeger。在本节中，我们将探讨这些协议的一些特点、它们的支持情况，以及如何在你编写的软件服务中使用它们。我们还将讨论这些协议用于将上下文传递给其他服务的不同**头部**。一个跟踪协议由一组头部组成，这些头部会添加到由仪表化应用程序发出的
    HTTP 请求中。这些头部传递每个 span 的信息到下游服务。一旦所有这些 spans 被收集，它们就形成了一个完整的分布式跟踪。
- en: What are the main tracing protocols?
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要的跟踪协议有哪些？
- en: First, let’s look at the features and support of the main tracing protocols
    – OTLP, Zipkin, and Jaeger.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看主要跟踪协议的特点和支持情况——OTLP、Zipkin 和 Jaeger。
- en: OTLP
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OTLP
- en: OTLP tracing offers support for C++, .NET, Erlang, Go, Java, JavaScript, PHP,
    Python, Ruby, Rust, and Swift. There is good support for OTLP in popular development
    frameworks such as Spring, Django, ASP.NET, and Gin. With this wide support, it
    is best practice to search the documentation for your framework of choice on how
    to instrument an application; in most cases, instrumentation can be as simple
    as adding a few lines of dependencies.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: OTLP 跟踪支持 C++、.NET、Erlang、Go、Java、JavaScript、PHP、Python、Ruby、Rust 和 Swift。在流行的开发框架中，如
    Spring、Django、ASP.NET 和 Gin，都有很好的 OTLP 支持。由于支持范围广泛，最佳实践是查阅你选择的框架文档，了解如何对应用程序进行仪表化；在大多数情况下，仪表化操作可能仅仅是添加几行依赖项。
- en: Tracing is an inherently distributed process, and there have been several standards
    to propagate trace fields. This means that applications may need to use different
    HTTP or gRPC headers when handling traces, depending on other applications in
    their operating environment. OTLP provides native support for W3C TraceContext,
    B3, and Jaeger propagation headers, as well as support for W3C baggage headers,
    used to propagate other context information. The support of B3 and Jaeger headers
    means that applications instrumented with Zipkin and Jaeger libraries are natively
    supported. However, other trace headers such as AWS’s X-Ray protocol are not maintained
    as part of the mainline distribution. If these protocols are used, it is recommended
    to use the relevant vendor’s distribution of OpenTelemetry – for example, the
    *AWS Distro for OpenTelemetry* when X-Ray is used in a monitored environment ([https://aws.amazon.com/otel/](https://aws.amazon.com/otel/)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪本质上是一个分布式过程，已经有几个标准用于传播跟踪字段。这意味着应用程序在处理跟踪时可能需要使用不同的 HTTP 或 gRPC 头部，这取决于它们操作环境中的其他应用程序。OTLP
    原生支持 W3C TraceContext、B3 和 Jaeger 传播头部，并且支持用于传播其他上下文信息的 W3C 行李头部。B3 和 Jaeger 头部的支持意味着使用
    Zipkin 和 Jaeger 库仪表化的应用程序得到原生支持。然而，其他跟踪头部，如 AWS 的 X-Ray 协议，并未作为主流分发的一部分进行维护。如果使用这些协议，建议使用相关厂商的
    OpenTelemetry 分发版本——例如，当 X-Ray 在监控环境中使用时，可以使用 *AWS Distro for OpenTelemetry*（[https://aws.amazon.com/otel/](https://aws.amazon.com/otel/)）。
- en: In the data collection space, OTLP trace data has good support from the OpenTelemetry
    Collector, Grafana Agent, FluentBit via a plugin, and Telegraf via a plugin.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据收集领域，OTLP 跟踪数据得到了 OpenTelemetry Collector、Grafana Agent、通过插件支持的 FluentBit
    和通过插件支持的 Telegraf 的良好支持。
- en: Zipkin
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zipkin
- en: Zipkin offers support for C#, Go, Java, JavaScript, Ruby, Scalar, and PHP via
    supported libraries, and C++, C, Clojure, Elixir, Lua, and Scala, via community-supported
    libraries. As with OTLP, there is also good support for Zipkin in popular development
    frameworks, so it is good practice to check the framework documentation when instrumenting
    applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin 支持 C#、Go、Java、JavaScript、Ruby、Scalar 和 PHP，通过支持的库；以及 C++、C、Clojure、Elixir、Lua
    和 Scala，通过社区支持的库。与 OTLP 一样，Zipkin 在流行的开发框架中也有很好的支持，因此在进行应用程序仪表化时，最好查阅框架文档。
- en: Zipkin only natively supports the B3 propagation headers. However, as frameworks
    offer pluggable support for different trace protocols, support for alternative
    propagation headers is probably easy to implement in an application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin仅原生支持B3传播头。然而，由于框架提供了对不同追踪协议的可插拔支持，因此在应用程序中实现对其他传播头的支持可能相对容易。
- en: When it comes to data collection, Zipkin is supported by the OpenTelemetry Collector,
    Grafana Agent, and the native tools created by Zipkin.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据收集方面，Zipkin被OpenTelemetry Collector、Grafana Agent以及Zipkin本身的原生工具支持。
- en: Jaeger
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jaeger
- en: 'We have included Jaeger for historical reasons here, but it is not recommended
    for adoption. Jaeger was originally developed by *Uber*. Before January 2022,
    Jaeger offered SDKs for Java, Python, Node.js, Go, C#, and C++. These SDKs supported
    the OpenTracing APIs. OpenTelemetry was formed by the OpenTracing and OpenCensus
    projects merging. Jaeger now recommends the use of the OpenTelemetry SDKs for
    instrumenting applications. For applications already using the Jaeger client libraries,
    migration guides have been provided by OpenTelemetry: [https://opentelemetry.io/docs/migration/opentracing/](https://opentelemetry.io/docs/migration/opentracing/).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包括Jaeger是出于历史原因，但不推荐采用它。Jaeger最初由*Uber*开发。在2022年1月之前，Jaeger为Java、Python、Node.js、Go、C#和C++提供了SDK，这些SDK支持OpenTracing
    API。OpenTelemetry是由OpenTracing和OpenCensus项目合并而成。Jaeger现在推荐使用OpenTelemetry SDK来为应用程序提供监控。对于已经使用Jaeger客户端库的应用程序，OpenTelemetry提供了迁移指南：[https://opentelemetry.io/docs/migration/opentracing/](https://opentelemetry.io/docs/migration/opentracing/)。
- en: Jaeger libraries supported the Jaeger, Zipkin, and W3C TraceContext headers,
    but they had no support for any other propagation formats.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger库支持Jaeger、Zipkin和W3C TraceContext头，但不支持任何其他的传播格式。
- en: There was not wide support in data collectors for Jaeger while it was actively
    supported; the intended way to use the protocol was to collect data in a Jaeger
    backend locally in an environment. The OpenTelemetry Collector and Grafana Agent
    do offer receivers for Jaeger traces and allow you to collect these traces as
    applications migrate to the OpenTelemetry protocol.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jaeger得到积极支持期间，数据收集器对Jaeger的支持并不广泛；该协议的预期使用方式是在本地环境中将数据收集到Jaeger后端。OpenTelemetry
    Collector和Grafana Agent确实提供了对Jaeger追踪的接收器，并允许您在应用程序迁移到OpenTelemetry协议时收集这些追踪数据。
- en: Now that you are familiar with the tracing protocols, let’s look at the headers
    that are used to propagate information between services that use distributed tracing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了追踪协议，我们来看看用于在使用分布式追踪的服务之间传播信息的头部。
- en: Context propagation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文传播
- en: '**Distributed tracing** is relatively new in web technologies, with the **World
    Wide Web Consortium** (**W3C**) making **Trace Context** a recommended standard
    in November 2021, while the **Baggage** format is still currently in a working
    draft state. Tracing records information in two distinct ways:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式追踪**在Web技术中相对较新，**万维网联盟**（**W3C**）在2021年11月将**Trace Context**作为推荐标准，而**Baggage**格式目前仍处于工作草案阶段。追踪以两种不同的方式记录信息：'
- en: Traces and spans are sent to a collection agent by each application
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序将追踪和跨度信息发送到收集代理
- en: Applications also share data using HTTP or gRPC headers, which are picked up
    by the receiving application
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序还使用HTTP或gRPC头共享数据，这些数据会被接收方应用程序获取
- en: 'As tracing is a new technology, a couple of unofficial standard formats were
    used before the official W3C Trace Context headers were decided on. To provide
    some historical context on tracing, we’ll explore the following formats:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于追踪技术是一项新技术，在官方的W3C Trace Context头标准确定之前，曾使用过一些非正式的标准格式。为了提供一些追踪技术的历史背景，我们将探讨以下格式：
- en: Jaeger/Uber headers
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaeger/Uber头
- en: Zipkin B3 headers
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin B3头
- en: W3C Trace Context headers
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3C Trace Context头
- en: W3C baggage headers
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3C行李头
- en: Jaeger/Uber headers
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jaeger/Uber头
- en: Jaeger libraries historically used the following header formats; we’ve included
    these for historical reference, as these should be considered deprecated in favor
    of W3C Trace Context.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger库历史上使用了以下头格式；我们为历史参考包括了这些内容，因为这些格式应该被视为已弃用，推荐使用W3C Trace Context。
- en: 'The two HTTP headers used in Jaeger are `uber-trace-id` and `uberctx`, which
    look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger中使用的两个HTTP头是`uber-trace-id`和`uberctx`，它们的格式如下：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An example of the `uber-trace-id` header is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`uber-trace-id`头的示例如下：'
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s break this down the various fields in the `uber-trace-id` header:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拆解一下`uber-trace-id`头中的各个字段：
- en: '`trace-id`: This field is a 64-bit or 128-bit random number and is hex-encoded.
    In the example this is `269daf90c4589ce1`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace-id`：此字段是 64 位或 128 位的随机数，且为十六进制编码。在示例中，这是 `269daf90c4589ce1`。'
- en: '`span-id` and `parent-span-id`: These are 64-bit random numbers and are hex-encoded.
    These are `5c44cd976d8f8cd9` and `39e8e549de678267`, respectively.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span-id` 和 `parent-span-id`：这是 64 位的随机数，并且是十六进制编码的。分别为 `5c44cd976d8f8cd9`
    和 `39e8e549de678267`。'
- en: '`flags`: This field is used to convey additional information, such as whether
    the trace is being sampled. In this example, its value is `0x01`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：此字段用于传递附加信息，例如是否对跟踪进行采样。在此示例中，其值为 `0x01`。'
- en: 'In the `uberctx` baggage header, the fields are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `uberctx` 行李头部中，字段如下：
- en: '`baggage-key`: This is a unique string that is used to name the header.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baggage-key`：这是一个唯一的字符串，用于命名头部。'
- en: '`baggage-value`: This is a string that will be percent-encoded. Baggage as
    a concept will be explored further in the *W3C* *baggage* section.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baggage-value`：这是一个将被百分比编码的字符串。作为一个概念，行李将在 *W3C* *baggage* 部分进一步探讨。'
- en: Zipkin B3 headers
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zipkin B3 头部
- en: 'Zipkin libraries use `B3` headers; unlike the Uber headers, Zipkin has historically
    separated each field into its own header, as shown in the following snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin 库使用 `B3` 头部；与 Uber 头部不同，Zipkin 历史上将每个字段分离到自己的头部中，如以下代码片段所示：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s break these headers down:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这些头部：
- en: '`X-B3-TraceId`: Similar to the Jaeger format, `TraceId` is 64-bit or 128-bit
    hex-encoded. Here is an example of this header as it would be sent:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-B3-TraceId`：与 Jaeger 格式类似，`TraceId` 是 64 位或 128 位的十六进制编码。以下是此头部的一个示例，显示其发送方式：'
- en: '[PRE8]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`X-B3-ParentSpanId` and `X-B3-SpanId`: These are 64-bit and hex-encoded.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-B3-ParentSpanId` 和 `X-B3-SpanId`：这些是 64 位并且是十六进制编码的。'
- en: '`X-B3-Sampled`: This has a value of either `1` or `0`, although early implementations
    may use `true` or `false`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-B3-Sampled`：其值为 `1` 或 `0`，尽管早期实现可能使用 `true` 或 `false`。'
- en: '`X-B3-Flags`: This header is used to propagate debug decisions.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-B3-Flags`：此头部用于传播调试决策。'
- en: '`b3`: Zipkin predated the introduction of the W3C Trace Context standards.
    To aid in the transition to the newly agreed standard, Zipkin introduced the `b3`
    header. Later versions of Zipkin can propagate using both these headers and the
    W3C Trace Context headers for interoperability. The `b3` header exactly matches
    the `tracestate` header used in *W3C Trace Context* and represents the other headers
    combined into one mapping.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b3`：Zipkin 在 W3C Trace Context 标准引入之前就已存在。为了帮助过渡到新标准，Zipkin 引入了 `b3` 头部。Zipkin
    的后续版本可以使用这两个头部和 W3C Trace Context 头部来实现互操作性。`b3` 头部完全匹配 *W3C Trace Context* 中使用的
    `tracestate` 头部，表示将其他头部合并为一个映射。'
- en: W3C Trace Context
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: W3C Trace Context
- en: 'W3C specifies a standard pair of headers, as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: W3C 指定了一对标准头部，如下所示：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s break these headers down into their constituents:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些头部分解成它们的组成部分：
- en: 'The various fields in `traceparent` are as follows:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceparent` 中的各个字段如下：'
- en: The `trace-id` is a hex-encoded 16-byte array (128-bit).
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace-id` 是一个十六进制编码的 16 字节数组（128 位）。'
- en: '`parent-id` is a hex-encoded 8-byte array (64-bit); this field is equivalent
    to `span-id` or `SpanId` in Jaeger and B3, respectively, and represents the span
    ID used by the service that generated the header. It differs from the B3 `ParentSpanId`,
    as this can be used to represent a service further upstream that initiated a traced
    process.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent-id` 是一个十六进制编码的 8 字节数组（64 位）；此字段等同于 Jaeger 和 B3 中的 `span-id` 或 `SpanId`，表示生成该头部的服务所使用的跨度
    ID。它与 B3 的 `ParentSpanId` 不同，因为它可用于表示发起被跟踪过程的上游服务。'
- en: The `version` field is another hex-encoded 8-bit field; it represents the version
    of the standard being used. Currently, only version 00 exists.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version` 字段是另一个十六进制编码的 8 位字段；它表示所使用的标准版本。目前仅存在版本 00。'
- en: '`trace-flags` is another hex-encoded 8-bit field. In version 00 of the W3C
    standard, the only available flag is one to denote whether sampling is occurring
    or not.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace-flags` 是另一个十六进制编码的 8 位字段。在 W3C 标准的版本 00 中，唯一可用的标志是表示是否正在进行采样。'
- en: '`tracestate` is used to encode vendor-specific information. While `traceparent`
    is a fixed format and required by any vendor adopting the standard, `tracestate`
    is available for vendors to ensure that trace data is propagated while giving
    space for them to use and encode that data as desired. The only requirement regarding
    this header field is that the contents will be a comma-separated list of key-value
    pairs.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracestate` 用于编码特定于供应商的信息。虽然 `traceparent` 是一个固定格式，任何采用该标准的供应商都必须使用它，`tracestate`
    则为供应商提供了一个空间，以确保追踪数据能够传播，并允许他们根据需要使用和编码这些数据。关于这个头部字段的唯一要求是，内容将是一个以逗号分隔的键值对列表。'
- en: W3C baggage
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: W3C行李箱
- en: '`tenantId`, but when an application makes a request to a downstream application,
    that application may not need to know about `tenantId` for it to process the request.
    A baggage header allows us to propagate this `tenantId` field to the downstream
    application. The downstream application can then use this field in its observability
    instrumentation, while not polluting its data model with an unrelated field. This
    effectively separates *observability* concerns from *application* concerns. It’s
    important to note that data contained in baggage headers can be exposed to anyone
    inspecting network traffic, so it should not be used to share sensitive information.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`tenantId`，但是当一个应用程序向下游应用程序发起请求时，那个应用程序可能并不需要了解`tenantId`，就能够处理该请求。一个行李箱头部允许我们将`tenantId`字段传播到下游应用程序。下游应用程序可以在其可观察性工具中使用这个字段，同时又不会污染其数据模型，避免引入与业务无关的字段。这有效地将*可观察性*问题与*应用程序*问题分开。需要注意的是，行李箱头部中包含的数据可以被任何检查网络流量的人查看，因此不应使用它来共享敏感信息。'
- en: 'W3C `baggage` headers look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: W3C `baggage` 头部看起来像这样：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All fields must be percent-encoded; the full header must have 64 members or
    fewer, and it has a maximum size of 8,192 bytes. Using baggage gives systems a
    standardized way to propagate contextual information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字段必须进行百分号编码；整个头部最多包含64个成员，且最大大小为8,192字节。使用行李箱头部为系统提供了一种标准化的方式来传播上下文信息。
- en: We’ve now discussed how trace data is produced by applications and how it is
    shared, both with a collection agent and other applications. Let’s take some time
    to look at how data is processed and stored by Tempo.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论了应用程序如何产生追踪数据，以及如何将其共享，包括与收集代理和其他应用程序共享。接下来，让我们花些时间看看Tempo如何处理和存储数据。
- en: Understanding the Tempo architecture
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Tempo架构
- en: Like Loki and Mimir, Tempo leverages object stores such as Amazon S3, Google
    Cloud Storage, and Microsoft Azure Blob Storage. With the horizontal scalability
    of components in both the read and write pathways, Tempo has a fantastic ability
    to scale as data volumes increase.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 像Loki和Mimir一样，Tempo利用对象存储，如Amazon S3、Google Cloud Storage和Microsoft Azure Blob
    Storage。随着组件在读写路径上的水平扩展，Tempo在数据量增加时具备了极好的扩展能力。
- en: 'The following diagram shows the architecture used by Tempo:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了Tempo使用的架构：
- en: '![Figure 6.7 – The Tempo architecture](img/B18277_Figure_6.7.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – Tempo架构](img/B18277_Figure_6.7.jpg)'
- en: Figure 6.7 – The Tempo architecture
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – Tempo架构
- en: 'The *write* pathway for Tempo consists of the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Tempo的*写入*路径包括以下几个部分：
- en: '**Distributor**: The distributor is responsible for accepting spans and routing
    them to the correct instance of the ingester service, based on the trace ID of
    the span.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发器**：分发器负责接收跨度，并根据跨度的追踪ID将其路由到正确的ingester服务实例。'
- en: '**Ingester**: The ingester is responsible for grouping spans into traces, batching
    multiple traces into blocks, and writing bloom filters and indexes for querying.
    Once a block is complete, the ingester also flushes the data to the backend.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingester**：Ingester负责将跨度组合成追踪，批量处理多个追踪并将其打包成块，同时为查询编写布隆过滤器和索引。一旦一个块完成，Ingester还会将数据刷新到后端。'
- en: '**Metrics generator**: The metrics generator is an optional component; it receives
    spans from the distributor and uses them to produce service graphs and span metrics
    (such as the rate and the error duration). These are then written to a metrics
    backend.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度量生成器**：度量生成器是一个可选组件；它接收来自分发器的跨度，并利用这些跨度生成服务图和跨度度量（例如，速率和错误时长）。这些数据随后会被写入度量后端。'
- en: 'The *read* pathway has these components:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Tempo的*读取*路径包括以下组件：
- en: '**Query frontend**: The frontend is responsible for receiving a query and splitting
    it into smaller shards, based on the blocks (created by the ingester) that will
    be read to return the requested data. These shards are then queued with queriers.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询前端**：前端负责接收查询并将其拆分为更小的分片，基于将被读取的数据块（由ingester创建）来返回请求的数据。然后，这些分片会被排队等待查询器处理。'
- en: '**Querier**: This component is responsible for finding the requested data,
    either from the backend if the block has been flushed, or directly from the ingester
    if the block is still being collected.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询器**：该组件负责查找请求的数据，若数据块已经被刷新，则从后端获取数据，若数据块仍在收集，则直接从ingester获取数据。'
- en: The **compactor**, which is a standalone component, is responsible for optimizing
    the use of the backend storage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩器**，作为一个独立组件，负责优化后端存储的使用。'
- en: Now that we’re done exploring the system architecture of Tempo, you have seen
    all the major components of the tool, and how distributed tracing using Tempo
    can help provide great visibility of the components of the systems you run.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对Tempo系统架构的探索，你已经看到了工具的所有主要组件，以及如何通过Tempo进行分布式追踪，从而帮助你清晰地了解你运行的系统组件。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use TraceQL to query trace data stored in
    Tempo, which will help you build queries for dashboards using this rich data source.
    You have explored the Tempo user interface, so you will be confident in moving
    around the interface. Combined with the skills learned in *Chapters 4* and *5*
    you will be confident in moving between log, metric, and trace data in Grafana
    to be able to observe the systems you work with.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用TraceQL查询存储在Tempo中的追踪数据，这将帮助你为仪表板构建查询，利用这一丰富的数据源。你已经探索了Tempo的用户界面，因此你将能自信地在界面中操作。结合*第4章*和*第5章*中学到的技能，你将能够在Grafana中自信地在日志、度量和追踪数据之间切换，从而观察你所工作的系统。
- en: We took a detailed look at the different protocols and libraries you can use
    when instrumenting an application, and we saw the levels of support those tools
    have across different programming languages. We also explored the HTTP headers
    that are used to propagate trace data between applications. This will help you
    choose the best way to instrument an application and how to work with applications
    that are already instrumented with tracing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细了解了在为应用程序添加监控时，可以使用的不同协议和库，看到这些工具在不同编程语言中的支持程度。我们还探讨了用于在应用程序之间传播追踪数据的HTTP头信息。这将帮助你选择最佳的方式来为应用程序添加监控，并了解如何与已经启用了追踪的应用程序进行协作。
- en: Finally, we looked at the Tempo architecture and how it can horizontally scale
    to support your organization with however many traces you need to sample. With
    this knowledge, you will understand how to operate a Tempo installation and monitor
    the various components.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了Tempo的架构，以及它如何横向扩展以支持你的组织处理所需的任何数量的追踪数据。通过这些知识，你将理解如何操作Tempo的安装，并监控其各个组件。
- en: In the next chapter, we will conclude *Part 2* of the book by showing you how
    to collect data from your infrastructure layers, whether that is a cloud provider
    such as AWS, Azure, or GCP, or a Kubernetes cluster.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过展示如何从你的基础设施层收集数据来结束*第二部分*的内容，无论是来自AWS、Azure或GCP等云服务提供商，还是来自Kubernetes集群。
