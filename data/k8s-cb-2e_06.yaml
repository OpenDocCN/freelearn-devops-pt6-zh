- en: Building Kubernetes on AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 上构建 Kubernetes
- en: 'The following recipes are covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Playing with Amazon Web Services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转 Amazon Web Services
- en: Setting up Kubernetes by kops
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kops 设置 Kubernetes
- en: Using AWS as Kubernetes Cloud Provider
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS 作为 Kubernetes 云提供商
- en: Managing Kubernete cluster on AWS by kops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kops 管理 AWS 上的 Kubernetes 集群
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Based on a recent survey of the Cloud Native Computing Foundation, CNCF, **Amazon
    Web Services** (**AWS**) is a dominant solution for production-level Kubernetes
    systems ([https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/](https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/)).
    In this chapter, you will learn about the cloud services of AWS, and how these
    services work together to deliver a robust Kubernetes system. We will also introduce
    how kops works, a tool for Kubernetes operation, which helps us manage the Kubernetes
    cluster. Let's explore the world of Kubernetes in AWS!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据云原生计算基金会（CNCF）最近的调查，**Amazon Web Services**（**AWS**）是生产级 Kubernetes 系统的主流解决方案
    ([https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/](https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/))。在本章中，您将了解
    AWS 的云服务，以及这些服务如何协同工作以提供一个强大的 Kubernetes 系统。我们还将介绍 Kubernetes 运维工具 kops 的工作原理，帮助我们管理
    Kubernetes 集群。让我们一起探索 AWS 上的 Kubernetes 世界！
- en: Playing with Amazon Web Services
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转 Amazon Web Services
- en: Amazon Web Services ([https://aws.amazon.com](https://aws.amazon.com/)) is the
    most popular public cloud service. It provides the online service for Virtual
    Server (EC2), Software Defined Network (VPC), Object Store (S3), and so on. It
    is a suitable infrastructure to set up a Kubernetes cluster. We will explore AWS
    to understand the fundamental function of AWS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Web Services ([https://aws.amazon.com](https://aws.amazon.com/)) 是最受欢迎的公共云服务。它提供虚拟服务器（EC2）、软件定义网络（VPC）、对象存储（S3）等在线服务。它是搭建
    Kubernetes 集群的合适基础设施。我们将探索 AWS，了解其基础功能。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: First of all, you need to sign up to AWS. AWS gives a free tier that allows
    you to use some amount of AWS resources, free for 12 months. Go to [https://aws.amazon.com/free/](https://aws.amazon.com/free/) to
    register your information and credit card. It may take 24 hours to verify and
    activate your account.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要注册 AWS。AWS 提供免费的层级服务，允许您在 12 个月内免费使用一定数量的 AWS 资源。请访问 [https://aws.amazon.com/free/](https://aws.amazon.com/free/)
    注册您的信息和信用卡。验证和激活您的账户可能需要 24 小时。
- en: Once your AWS account is activated, we need to create one **Identity and Access
    Management** (**IAM**) user, which will control your AWS infrastructure via APIs.
    Then, install the AWS CLI on to your computer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的 AWS 账户激活，我们需要创建一个**身份与访问管理**（**IAM**）用户，该用户将通过 API 控制您的 AWS 基础设施。然后，安装
    AWS CLI 到您的计算机上。
- en: Creating an IAM user
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 IAM 用户
- en: 'Perform the following steps to create an IAM user:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建一个 IAM 用户：
- en: Go to AWS Web console [https://console.aws.amazon.com](https://console.aws.amazon.com).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 AWS Web 控制台 [https://console.aws.amazon.com](https://console.aws.amazon.com)。
- en: 'Click on IAM (use the search box, which makes it easier to find):'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 IAM（使用搜索框，这样更容易找到）：
- en: '![](img/e5cf92cc-6868-4735-a725-6d57a0725e32.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5cf92cc-6868-4735-a725-6d57a0725e32.png)'
- en: Access to IAM console
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 IAM 控制台
- en: 'Click on Users in the left navigation and then click on Add user:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航栏中点击 Users，然后点击 Add user：
- en: '![](img/35a36126-64d0-49e6-9a79-103209103aaa.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35a36126-64d0-49e6-9a79-103209103aaa.png)'
- en: Creating an IAM user
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 IAM 用户
- en: 'Type User name `chap6`, then choose Programmatic access:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入用户名 `chap6`，然后选择程序访问：
- en: '![](img/fe599cfc-8532-499e-9784-30dfc41a75cd.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe599cfc-8532-499e-9784-30dfc41a75cd.png)'
- en: Creating chap6 user
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 chap6 用户
- en: 'Choose Attach existing policies directly, as shown in the following screenshot, and
    then select the following policies:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“直接附加现有策略”（如以下截图所示），然后选择以下策略：
- en: AmazonEC2FullAccess
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonEC2FullAccess
- en: AmazonRoute53FullAcccess
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonRoute53FullAcccess
- en: AmazonS3FullAccess
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonS3FullAccess
- en: AmazonVPCFullAccess
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonVPCFullAccess
- en: IAMFullAccess
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAMFullAccess
- en: '![](img/301e2810-98e5-4151-94f4-c7983a5d6d22.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/301e2810-98e5-4151-94f4-c7983a5d6d22.png)'
- en: Attaching the necessary Policy
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 附加必要的策略
- en: 'Eventually, it generates Access key ID and Secret access key. Copy and paste
    into your text editor or click on Download .csv to preserve to your computer:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，它会生成访问密钥 ID 和秘密访问密钥。复制并粘贴到您的文本编辑器中，或者点击下载 .csv 以保存到您的计算机：
- en: '![](img/15b0a0e3-91ca-4c49-9074-48a042f112e9.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15b0a0e3-91ca-4c49-9074-48a042f112e9.png)'
- en: Downloading Access key ID and Secret access key
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下载访问密钥 ID 和秘密访问密钥
- en: Installing AWS CLI on macOS
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 AWS CLI
- en: Install `awscli` to macOS using HomeBrew ([https://brew.sh](https://brew.sh));
    this is the easiest way. HomeBrew has already been introduced in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building
    your own Kubernetes Cluster*, while installing minikube.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HomeBrew 在 macOS 上安装 `awscli`（[https://brew.sh](https://brew.sh)）；这是最简单的方法。HomeBrew
    已经在 [第 1 章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)中介绍过，*构建你自己的 Kubernetes
    集群*，同时安装 minikube。
- en: 'To install awscli by HomeBrew on your Mac, perform the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Mac 上通过 HomeBrew 安装 awscli，执行以下步骤：
- en: 'Type the following command to update the latest formula:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以更新最新的公式：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Specify `awscli` to install:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定安装 `awscli`：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Verify the `aws` command using the` --version` option:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `--version` 选项验证 `aws` 命令：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing AWS CLI on Windows
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 AWS CLI
- en: 'Install awscli on Windows; there is a Windows installer package, which is the
    easiest way to install  awscli on to your Windows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 awscli；有一个 Windows 安装程序包，这是在 Windows 上安装 awscli 的最简单方法：
- en: Go to AWS Command Line Interface page ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 AWS 命令行接口页面（[https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)）。
- en: Download Windows installer 64 bit ([https://s3.amazonaws.com/aws-cli/AWSCLI64.msi](https://s3.amazonaws.com/aws-cli/AWSCLI64.msi))
    or 32 bit ([https://s3.amazonaws.com/aws-cli/AWSCLI32.msi](https://s3.amazonaws.com/aws-cli/AWSCLI32.msi)),
    based on your Windows OS.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Windows 安装程序 64 位（[https://s3.amazonaws.com/aws-cli/AWSCLI64.msi](https://s3.amazonaws.com/aws-cli/AWSCLI64.msi)）或
    32 位（[https://s3.amazonaws.com/aws-cli/AWSCLI32.msi](https://s3.amazonaws.com/aws-cli/AWSCLI32.msi)），取决于你的
    Windows 操作系统。
- en: 'Launch AWS CLI installer, and then choose the default option to proceed with
    the installation:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 AWS CLI 安装程序，然后选择默认选项继续安装：
- en: '![](img/d30f75b4-ae98-4293-9f1c-bfde62241948.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d30f75b4-ae98-4293-9f1c-bfde62241948.png)'
- en: Installing AWS CLI for Windows
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 AWS CLI
- en: 'After complete installation, launch Command Prompt. Then, type the `aws` command
    with the `--version` option to verify:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，启动命令提示符。然后，输入 `aws` 命令并使用 `--version` 选项进行验证：
- en: '![](img/5f175700-22de-4607-9433-3c09cd6f7fad.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f175700-22de-4607-9433-3c09cd6f7fad.png)'
- en: Showing aws command on Windows
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上显示 aws 命令
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First of all, you need to set your AWS Access Key ID and AWS Secret Access Key
    for awscli. We've already acquired `chap6` for the IAM user. We will use this
    user's Access Key ID and Secret Access Key.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为 awscli 设置你的 AWS Access Key ID 和 AWS Secret Access Key。我们已经为 IAM 用户获取了
    `chap6`。我们将使用该用户的 Access Key ID 和 Secret Access Key。
- en: 'Launch terminal (Command Prompt for Windows), and then use the `aws` command
    to set `Access Key ID` and `Secret Access Key`. Also, set the default region as
    `us-east-1`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动终端（Windows 的命令提示符），然后使用 `aws` 命令设置 `Access Key ID` 和 `Secret Access Key`。同时，设置默认区域为
    `us-east-1`：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Check `chap6` IAM user using the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查 `chap6` IAM 用户：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's it! Now you can start using AWS to launch your own network and instances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在你可以开始使用 AWS 启动自己的网络和实例。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's explorer AWS to launch a typical infrastructure. Using awscli to build
    your own VPC, Subnet, Gateway, and Security group. Then, launch the EC2 instance
    to understand the basic usage of AWS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 AWS 来启动一个典型的基础设施。使用 awscli 构建自己的 VPC、子网、网关和安全组。然后，启动 EC2 实例，了解 AWS 的基本使用。
- en: Creating VPC and Subnets
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 VPC 和子网
- en: '**Virtual Private Cloud** (**VPC**) is a Software-Defined Network. You can
    configure a virtual network on AWS. Subnets are inside of VPC that define network
    block (**Classless Inter Domain Routing** (**CIDR**)) such as `192.168.1.0/24`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟私有云** (**VPC**) 是一种软件定义的网络。你可以在 AWS 上配置一个虚拟网络。子网位于 VPC 内，定义了网络块（**无类域间路由**（**CIDR**）），例如
    `192.168.1.0/24`。'
- en: 'Let''s create one VPC and two subnets using the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建一个 VPC 和两个子网：
- en: 'Create a new VPC that has `192.168.0.0/16` CIDR block (IP range: `192.168.0.0`
    – `192.168.255.255`). Then, capture `VpcId`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 VPC，CIDR 块为 `192.168.0.0/16`（IP 范围：`192.168.0.0` – `192.168.255.255`）。然后，捕获
    `VpcId`：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the first subnet under the VPC (`vpc-69cfbd12`) that has `192.168.0.0/24`
    CIDR block (IP range: `192.168.0.0` – `192.168.0.255`) and specify the availability
    zone as `us-east-1a`. Then, capture `SubnetId:`'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VPC (`vpc-69cfbd12`) 下创建第一个子网，该子网有 `192.168.0.0/24` 的 CIDR 块（IP 范围：`192.168.0.0`
    – `192.168.0.255`），并指定可用区为 `us-east-1a`。然后，捕获 `SubnetId:`
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the second subnet on `us-east-1b`, which has `192.168.1.0/24` CIDR block
    (IP range: `192.168.1.0` – `192.168.1.255`). Then, capture `SubnetId`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `us-east-1b` 上创建第二个子网，CIDR 块为 `192.168.1.0/24`（IP 范围：`192.168.1.0` – `192.168.1.255`）。然后，捕获
    `SubnetId`：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check the subnet list under VPC (`vpc-69cfbd12`) using the following command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查VPC（`vpc-69cfbd12`）下的子网列表：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This looks good!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！
- en: Internet gateway
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Internet网关
- en: To access your VPC network, you need to have a gateway that accesses it from
    the internet. **Internet Gateway** (**IGW**) is the one that connects the internet
    to your VPC.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问您的VPC网络，您需要有一个从互联网访问它的网关。**Internet网关**（**IGW**）就是将互联网连接到您的VPC的网关。
- en: Then, in the subnets under VPC, you can set the default route to go to IGW or
    not. If it routes to IGW, the subnet is classified as the public subnet. Then,
    you can assign the global IP address on the public subnet.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在VPC下的子网中，您可以设置默认路由是否指向IGW。如果指向IGW，该子网将被归类为公共子网。然后，您可以在公共子网上分配全球IP地址。
- en: 'Let''s configure the first subnet (`192.168.0.0/24`) as the public subnet that
    routes to IGW using the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤配置第一个子网（`192.168.0.0/24`）作为指向IGW的公共子网：
- en: 'Create IGW and capture `InternetGatewayId`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建IGW并捕获 `InternetGatewayId`：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Attach IGW (`igw-e50b849d`) to your VPC (`vpc-69cfbd12`):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将IGW（`igw-e50b849d`）附加到您的VPC（`vpc-69cfbd12`）上：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a routing table on VPC (`vpc-69cfbd12`) and then capture `RouteTableId:`
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VPC（`vpc-69cfbd12`）上创建路由表，然后捕获 `RouteTableId`：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set the default route (`0.0.0.0/0`) for route table (`rtb-a9e791d5`) as IGW
    (`igw-e50b849d`):'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由表（`rtb-a9e791d5`）的默认路由（`0.0.0.0/0`）设置为IGW（`igw-e50b849d`）：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Associate route table (`rtb-a9e791d5`) to public subnet (`subnet-6296863f`):'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由表（`rtb-a9e791d5`）关联到公共子网（`subnet-6296863f`）：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Enable autoassign public IP on the public subnet (`subnet-6296863f`):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共子网（`subnet-6296863f`）上启用自动分配公共IP：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: NAT-GW
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NAT-GW
- en: What happens if the subnet default route is not pointing to IGW? The subnet
    is classified as a private subnet with no connectivity to the internet. However,
    some of situation, your VM in private subnet needs to access to the Internet.
    For example, download some security patch.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子网的默认路由没有指向IGW，会发生什么情况？该子网将被归类为私有子网，并且无法连接到互联网。然而，在某些情况下，您在私有子网中的虚拟机可能需要访问互联网。例如，下载一些安全补丁。
- en: In this case, you can setup NAT-GW. It allows you access to the internet from
    the private subnet. However, it allows outgoing traffic only, so you cannot assign
    public IP address for a private subnet. Therefore, it is suitable for backend
    instances, such as the database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以设置NAT-GW。它允许您从私有子网访问互联网。然而，它仅允许出站流量，因此不能为私有子网分配公共IP地址。因此，它适用于后端实例，如数据库。
- en: 'Let''s create NAT-GW and configure a second subnet (`192.168.1.0/24`) as a
    private subnet that routes to NAT-GW using the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建NAT-GW，并通过以下步骤将第二个子网（`192.168.1.0/24`）配置为指向NAT-GW的私有子网：
- en: 'NAT-GW needs a Global IP address, so create **Elastic IP** (**EIP**):'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NAT-GW需要一个全球IP地址，因此创建**弹性IP**（**EIP**）：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create NAT-GW on the public subnet (`subnet-6296863f`) and assign EIP (`eipalloc-bad28bb3`).
    Then, capture `NatGatewayId`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共子网（`subnet-6296863f`）上创建NAT-GW并分配EIP（`eipalloc-bad28bb3`）。然后，捕获 `NatGatewayId`。
- en: Since NAT-GW needs to access the internet, it must be located on the public
    subnet instead of the private subnet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NAT-GW需要访问互联网，它必须位于公共子网，而不是私有子网。
- en: 'Input the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the route table and capture `RouteTableId`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建路由表并捕获`RouteTableId`：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set the default route (`0.0.0.0/0`) of the route table (`rtb-70f1870c`) to
    NAT-GW (`nat-0b12be42c575bba43`):'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由表（`rtb-70f1870c`）的默认路由（`0.0.0.0/0`）设置为NAT-GW（`nat-0b12be42c575bba43`）：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Associate route table (`rtb-70f1870c`) to private subnet (`subnet-ce947da`9):'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由表（`rtb-70f1870c`）关联到私有子网（`subnet-ce947da`9）：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Security group
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全组
- en: 'Before launching your Virtual Server (EC2), you need to create a Security Group
    that has an appropriate security rule. Now, we have two subnets, public and private.
    Let''s set public subnet such that it allows `ssh` (`22/tcp`) and `http` (`80/tcp`)
    from the internet. Then, set the private subnet such that it allows ssh from the
    public subnet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动虚拟服务器（EC2）之前，您需要创建一个具有适当安全规则的安全组。现在，我们有两个子网，公共子网和私有子网。我们来设置公共子网，使其允许来自互联网的`ssh`（`22/tcp`）和`http`（`80/tcp`）。然后，设置私有子网，使其允许从公共子网进行ssh连接：
- en: 'Create one security group for the public subnet on VPC (`vpc-69cfbd12`):'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VPC（`vpc-69cfbd12`）上为公共子网创建一个安全组：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the ssh allow rule to the public security group (`sg-dd8a3f94`):'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向公共安全组（`sg-dd8a3f94`）添加允许ssh的规则：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the `http` allow rule to the public security group (`sg-dd8a3f94`):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向公共安全组（`sg-dd8a3f94`）添加允许`http`的规则：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a second security group for the private subnet on VPC (`vpc-69cfbd12`):'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VPC（`vpc-69cfbd12`）上为私有子网创建第二个安全组：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add an `ssh` allow rule to the private security group (`sg-a18c39e8`):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向私有安全组 (`sg-a18c39e8`) 添加一个 `ssh` 允许规则：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check the Security Group list using the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查安全组列表：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: EC2
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EC2
- en: 'Now you need to upload your ssh public key and then launch the EC2 instance
    on both the public subnet and the private subnet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要上传你的 ssh 公钥，然后启动公共子网和私有子网的 EC2 实例：
- en: 'Upload your ssh public key (assume you have a public key that is located at `~/.ssh/id_rsa.pub`):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传你的 ssh 公钥（假设你的公钥位于 `~/.ssh/id_rsa.pub`）：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Launch the first EC2 instance with the following parameters:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动第一个 EC2 实例，使用以下参数：
- en: 'Use Amazon Linux image: `ami-1853ac65` (Amazon Linux)'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon Linux 镜像：`ami-1853ac65`（Amazon Linux）
- en: 'T2.nano instance type: `t2.nano`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: T2.nano 实例类型：`t2.nano`
- en: 'Ssh key: `chap6-key`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ssh 密钥：`chap6-key`
- en: 'Public Subnet: `subnet-6296863f`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共子网：`subnet-6296863f`
- en: 'Public Security Group: `sg-dd8a3f94`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共安全组：`sg-dd8a3f94`
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Launch the second EC2 instance with the following parameters:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动第二个 EC2 实例，使用以下参数：
- en: 'Use Amazon Linux image: `ami-1853ac65`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon Linux 镜像：`ami-1853ac65`
- en: 'T2.nano instance type: `t2.nano`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: T2.nano 实例类型：`t2.nano`
- en: 'Ssh key: `chap6-key`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ssh 密钥：`chap6-key`
- en: 'Private subnet: `subnet-ce947da9`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有子网：`subnet-ce947da9`
- en: 'Private Secuity Group: `sg-a18c39e8`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有安全组：`sg-a18c39e8`
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Check the status of the EC2 instances:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 EC2 实例的状态：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'SSH (use the `-A` option to forward your authentication info) to the public
    EC2 host from your computer:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的计算机通过 SSH（使用 `-A` 选项转发你的认证信息）连接到公共 EC2 主机：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Install and launch nginx to the public EC2 host:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装并启动 nginx 到公共 EC2 主机：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Make sure you can access the nginx server from your machine (see the following
    screenshot):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你能够从机器访问 nginx 服务器（见下图）：
- en: '![](img/ecb8ab27-c187-49c4-ab25-ce68e6d67977.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecb8ab27-c187-49c4-ab25-ce68e6d67977.png)'
- en: Accessing nginx web server on public host
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 访问公共主机上的 nginx 网络服务器
- en: 'SSH from the public host to the private host (you must use a private IP address):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从公共主机通过 SSH 连接到私有主机（必须使用私有 IP 地址）：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Make sure the private host can perform yum update via NAT-GW:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保私有主机能通过 NAT-GW 执行 yum 更新：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Congratulations! You can set up your own infrastructure on AWS, as shown in
    the following diagram, which has the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你可以在 AWS 上设置自己的基础设施，如下图所示，包含以下内容：
- en: One VPC with CIDR `192.168.0.0/16`
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 CIDR 为 `192.168.0.0/16` 的 VPC
- en: IGW
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IGW
- en: NAT-GW
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NAT-GW
- en: Two Subnets
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个子网
- en: 'public subnet: `192.168.0.0/24` route to IGW'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共子网：`192.168.0.0/24` 路由到 IGW
- en: 'private subnet: 192.168.1.0/24 route to NAT-GW'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有子网：192.168.1.0/24 路由到 NAT-GW
- en: Two EC2 instances (public and private)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 EC2 实例（公共和私有）
- en: Two Security Groups (allow public http/ssh and private ssh)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个安全组（允许公共 http/ssh 和私有 ssh）
- en: 'Now, take a look at the diagram:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来看一下下面的图示：
- en: '![](img/97480e7b-4918-4383-841c-372a6992a957.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97480e7b-4918-4383-841c-372a6992a957.png)'
- en: AWS components diagram
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 组件图
- en: In this section, you have learned how to use AWS from scratch. We have covered
    its basic uses, but it is important to know while setup Kubernetes on AWS. Next,
    we will explore how to set up Kubernetes on AWS.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你已经学习了如何从零开始使用 AWS。我们涵盖了它的基本用法，但在设置 Kubernetes 到 AWS 时，了解这些内容非常重要。接下来，我们将探索如何在
    AWS 上设置 Kubernetes。
- en: Setting up Kubernetes with kops
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 kops 设置 Kubernetes
- en: What is kops? It is the abbreviated term of Kubernetes Operation ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)).
    Similar to kubeadm, minikube, and kubespray, kops reduces the heavy duty of building
    up a Kubernetes cluster by ourselves. It helps in creation, and provides an interface
    to users for managing the clusters. Furthermore, kops achieves a more automatic
    installing procedure and delivers a production-level system. It targets to support
    dominate cloud platforms, such as AWS, GCE, and VMware vSphere. In this recipe,
    we will talk about how to run a Kubernetes cluster with kops.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 kops？它是 Kubernetes 操作的缩写（[https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)）。类似于
    kubeadm、minikube 和 kubespray，kops 减少了我们自己构建 Kubernetes 集群的繁重任务。它帮助创建集群，并为用户提供管理集群的接口。此外，kops
    实现了更自动化的安装过程，并交付了生产级别的系统。它旨在支持主流云平台，如 AWS、GCE 和 VMware vSphere。在本教程中，我们将讨论如何使用
    kops 运行 Kubernetes 集群。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before our major tutorial, we will need to install kops on to your local host.
    It is a straightforward step for downloading the binary file and moving it to
    the system directory of the execution file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行主要教程之前，需要在本地主机上安装 kops。这个步骤很简单，下载二进制文件并将其移动到执行文件的系统目录中：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we have to prepare some AWS configuration on your host and required services
    for cluster. Refer to the following items and make sure that they are ready:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在您的主机上准备一些AWS配置和集群所需的服务。请参考以下项目，并确保它们已经准备好：
- en: '**IAM user**: Since kops would create and build several AWS service components
    together for you, you must have an IAM user with kops required permissions. We''ve
    created an IAM user named chap6 in the previous section that has the following
    policies with the necessary permissions for kops:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IAM用户**：由于kops需要为您创建和构建多个AWS服务组件，您必须拥有一个具有kops所需权限的IAM用户。在前面的部分中，我们创建了一个名为chap6的IAM用户，并为其配置了以下具有kops所需权限的策略：'
- en: AmazonEC2FullAccess
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonEC2FullAccess
- en: AmazonRoute53FullAccess
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonRoute53FullAccess
- en: AmazonS3FullAccess
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonS3FullAccess
- en: IAMFullAccess
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAMFullAccess
- en: AmazonVPCFullAccess
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonVPCFullAccess
- en: 'Then, exposing the AWS access key ID and secret key as environment variables
    can make this role applied on host while firing `kops` commands:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，暴露AWS访问密钥ID和密钥作为环境变量，可以使该角色在执行`kops`命令时应用于主机：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Prepare an S3 bucket for storing cluster configuration**: In our demonstration
    later, the S3 bucket name will be `kubernetes-cookbook`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为存储集群配置的S3桶做好准备**：在接下来的演示中，S3桶的名称将是`kubernetes-cookbook`。'
- en: '**Prepare a Route53 DNS domain for accessing points of cluster**: In our demonstration
    later, the domain name we use will be `k8s-cookbook.net`.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为集群访问点准备一个Route53 DNS域名**：在接下来的演示中，我们使用的域名将是`k8s-cookbook.net`。'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can easily run up a Kubernetes cluster using a single command with parameters
    containing complete configurations. These parameters are described in the following
    table:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包含完整配置的参数，轻松运行一个单一命令来启动Kubernetes集群。以下表格描述了这些参数：
- en: '| **Parameter** | **Description** | **Value in example** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** | **示例中的值** |'
- en: '| `--name` | This is the name of the cluster. It will also be the domain name
    of the cluster''s entry point. So you can utilize your Route53 DNS domain with
    a customized name, for example, `{your cluster name}.{your Route53 domain name}`.
    | `my-cluster.k8s-cookbook.net` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `--name` | 这是集群的名称，也将是集群入口点的域名。因此，您可以使用自定义名称的Route53 DNS域名，例如`{您的集群名称}.{您的Route53域名}`。
    | `my-cluster.k8s-cookbook.net` |'
- en: '| `--state` | This indicates the S3 bucket that stores the status of the cluster
    in the format `s3://{bucket name}`. | `s3://kubernetes-cookbook` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `--state` | 这是指示存储集群状态的S3桶，格式为`s3://{桶名称}`。 | `s3://kubernetes-cookbook`
    |'
- en: '| `--zones` | This is the availability zone where you need to build your cluster.
    | `us-east-1a` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `--zones` | 这是您需要构建集群的可用区。 | `us-east-1a` |'
- en: '| `--cloud` | This is the cloud provider. | `aws` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `--cloud` | 这是云服务提供商。 | `aws` |'
- en: '| `--network-cidr` | Here, kops helps to create independent CIDR range for
    the new VPC. | `10.0.0.0/16` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `--network-cidr` | 这里，kops帮助创建一个新的VPC的独立CIDR范围。 | `10.0.0.0/16` |'
- en: '| `--master-size` | This is the instance size of Kubernetes master. | `t2.large`
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `--master-size` | 这是Kubernetes master的实例大小。 | `t2.large` |'
- en: '| `--node-size` | This is the instance size of Kubernetes nodes. | `t2.medium`
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `--node-size` | 这是Kubernetes节点的实例大小。 | `t2.medium` |'
- en: '| `--node-count` | This is the number of nodes in the cluster. | `2` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `--node-count` | 这是集群中的节点数量。 | `2` |'
- en: '| `--network` | This is the overlay network used in this cluster. | `calico`
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `--network` | 这是在该集群中使用的覆盖网络。 | `calico` |'
- en: '| `--topology` | This helps you decide whether the cluster is public facing.
    | `private` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `--topology` | 这帮助您决定集群是否为公开的。 | `private` |'
- en: '| `--ssh-public-key` | This helps you assign an SSH public key for bastion
    server, then we may log in through the private key. | `~/.ssh/id_rsa.pub` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `--ssh-public-key` | 这帮助您为堡垒服务器分配SSH公钥，然后我们可以通过私钥登录。 | `~/.ssh/id_rsa.pub`
    |'
- en: '| `--bastion` | This gives you an indication to create the bastion server.
    | N/A |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `--bastion` | 这告诉您创建堡垒服务器。 | N/A |'
- en: '| `--yes` | This gives you the confirmation for executing immediately. | N/A
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `--yes` | 这给出确认立即执行的权限。 | N/A |'
- en: 'Now we are ready to compose the configurations into a command and fire it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好将配置组合成一个命令并执行它：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After a few minutes, the command takes out the preceding logs showing what
    AWS services have been created and served for you kops-built Kubernetes cluster.
    You can even check your AWS console to verify their relationships, which will
    look similar to the following diagram:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，命令会输出前面的日志，显示AWS服务已为您创建并提供服务，供您使用kops构建的Kubernetes集群。您甚至可以检查AWS控制台，以验证它们的关系，查看类似下面的图示：
- en: '![](img/43f90e6c-c355-49df-8f2b-f59719ddca51.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43f90e6c-c355-49df-8f2b-f59719ddca51.png)'
- en: The components of Kubernetes cluster in AWS created by kops
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由 kops 创建的 AWS 上 Kubernetes 集群的组件
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'From localhost, users can interact with the cluster on AWS using the kops command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地用户可以通过 kops 命令与 AWS 上的集群进行交互：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Working with kops-built AWS cluster
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 kops 构建的 AWS 集群
- en: 'Furthermore, as you can see in the previous section, the last few logs of kops
    cluster creation shows that the environment of the client is also ready. It means
    that kops helps to bind the API server to our host securely as well. We may use
    the `kubectl` command like we were in Kubernetes master. What we need to do is
    install kubectl manually. It would be as simple as installing kops; just download
    the binary file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你在上一节中看到的，kops 集群创建的最后几条日志显示，客户端的环境也已经准备好。这意味着 kops 也帮助将 API 服务器安全地绑定到我们的主机。我们可以像在
    Kubernetes 主节点上一样使用 `kubectl` 命令。我们需要做的就是手动安装 kubectl。安装过程与安装 kops 一样简单，只需下载二进制文件：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, you can still access the nodes in the cluster. Since the cluster is
    set down in a private network, we will require to login to the bastion server
    first, and jump to the nodes for the next:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你仍然可以访问集群中的节点。由于集群部署在私有网络中，我们需要先登录到堡垒机服务器，然后跳转到节点进行下一步操作：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Deleting kops-built AWS cluster
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除 kops 构建的 AWS 集群
- en: 'We can simply remove our cluster using the kops command as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用 kops 命令删除集群，命令如下：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It will clean the AWS services for you. But some other services created by
    yourself: S3 bucket, IAM role with powerful authorization, and Route53 domain
    name; kops will not remove them on user''s behavior. Remember to delete the no
    used AWS services on your side.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它会为你清理 AWS 服务。但是一些你自己创建的服务，比如 S3 存储桶、具有强大授权的 IAM 角色，以及 Route53 域名；kops 不会删除它们。记得手动删除你不再使用的
    AWS 服务。
- en: See also
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '*Playing with Amazon Web Services*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*玩转亚马逊 Web 服务*'
- en: '*Using AWS as Kubernetes Cloud Provider*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将 AWS 作为 Kubernetes 云提供商*'
- en: '*Managing Kubernetes cluster on AWS by kops*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过 kops 管理 AWS 上的 Kubernetes 集群*'
- en: '*Setting up the Kubernetes cluster on Linux by kubeadm* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building your own Kubernetes Cluster*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)中，*通过 kubeadm 在 Linux 上设置
    Kubernetes 集群*，*构建你自己的 Kubernetes 集群*
- en: '*Setting up Kubernetes cluster on Linux by kubespray* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building your own Kubernetes* *Cluster*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)中，*通过 kubespray 在 Linux 上设置
    Kubernetes 集群*，*构建你自己的 Kubernetes* *集群*
- en: Using AWS as Kubernetes Cloud Provider
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 AWS 作为 Kubernetes 云提供商
- en: 'From Kubernetes 1.6, **Cloud Controller Manager** (**CCM**) was introduced,
    which defines a set of interfaces so that different cloud providers could evolve
    their own implementations out of the Kubernetes release cycle. Talking to the
    cloud providers, you can''t ignore the biggest player: Amazon Web Service. According
    to the Cloud Native Computing Foundation, in 2017, 63% of Kubernetes workloads
    run on AWS. AWS CloudProvider supports Service as **Elastic Load Balancer** (**ELB**)
    and Amazon **Elastic Block Store** (**EBS**) as StorageClass.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Kubernetes 1.6 开始，引入了 **云控制器管理器** (**CCM**)，它定义了一套接口，使得不同的云提供商能够在 Kubernetes
    发布周期之外演进自己的实现。谈到云提供商，你不能忽视最大的玩家：亚马逊 Web 服务。根据云原生计算基金会的数据，在 2017 年，63% 的 Kubernetes
    工作负载运行在 AWS 上。AWS CloudProvider 支持的服务有 **弹性负载均衡器** (**ELB**) 和亚马逊 **弹性块存储** (**EBS**)
    作为 StorageClass。
- en: At the time this book was written, Amazon Elastic Container Service for Kubernetes
    (Amazon EKS) was under preview, which is a hosted Kubernetes service in AWS. Ideally,
    it'll have better integration with Kubernetes, such as **Application Load Balancer**
    (**ALB**) for Ingress, authorization, and networking. Currently in AWS, the limitation
    of routes per route tables in VPC is 50; it could be up to 100 as requested. However,
    network performance may be impacted if the routes exceed 50 according to the official
    documentation of AWS. While kops uses kubenet networking by default, which allocates
    a/24 CIDR to each node and configures the routes in route table in AWS VPC. This
    might lead to the performance hit if the cluster has more than 50 nodes. Using
    a CNI network could address this problem.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写时，Amazon Elastic Container Service for Kubernetes（Amazon EKS）仍处于预览阶段，它是AWS中的托管Kubernetes服务。理想情况下，它将与Kubernetes更好地集成，例如**应用负载均衡器**（**ALB**）用于Ingress、授权和网络。目前，在AWS中，VPC中每个路由表的路由限制是50；根据要求，最多可达到100。然而，AWS官方文档指出，如果路由超过50，可能会影响网络性能。虽然kops默认使用kubenet网络，它为每个节点分配一个/24
    CIDR，并在AWS VPC的路由表中配置路由。如果集群有超过50个节点，这可能会导致性能下降。使用CNI网络可能解决这个问题。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备中
- en: 'For following along with the examples in this recipe, you''ll need to create
    a Kubernetes cluster in AWS. The following example is using kops to provision
    a Kubernetes cluster named `k8s-cookbook.net` in AWS; as the preceding recipes
    show, set `$KOPS_STATE_STORE` as a s3 bucket to store your kops configuration
    and metadata:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本食谱中的示例，您需要在AWS中创建一个Kubernetes集群。以下示例使用kops在AWS中提供一个名为`k8s-cookbook.net`的Kubernetes集群；如前面所示的食谱所示，设置`$KOPS_STATE_STORE`为一个s3桶来存储您的kops配置和元数据：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once we run the recommended kops update cluster `<cluster_name> --yes` command,
    after a few minutes, the cluster is up and running. We can use the kops validate
    cluster to check whether the cluster components are all up:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行推荐的`kops update cluster <cluster_name> --yes`命令，几分钟后，集群就会启动并运行。我们可以使用`kops
    validate cluster`来检查集群组件是否已全部启动：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We're good to go!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始了！
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'When running Kubernetes in AWS, there are two possible integrations we could
    use: ELB as Service with `LoadBalancer` Type and Amazon Elastic Block Store as
    `StorageClass`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS上运行Kubernetes时，我们可以使用两种可能的集成方式：作为`LoadBalancer`类型的服务的ELB，以及作为`StorageClass`的Amazon
    Elastic Block Store。
- en: Elastic load balancer as LoadBalancer service
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为LoadBalancer服务的弹性负载均衡器
- en: 'Let''s create a `LoadBalancer` Service with Pods underneath, which is what
    we learned in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing
    with Containers*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`LoadBalancer`服务，并在其下创建Pod，这是我们在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中学到的，*与容器玩耍*：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding template, we declared one nginx Pod and associated it with
    the `LoadBalancer` service. The service will direct the packet to container port
    `80`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们声明了一个nginx Pod，并将其与`LoadBalancer`服务关联。该服务将数据包定向到容器端口`80`：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s describe our `nginx` Service:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下我们的`nginx`服务：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After the service is created, we will find out that the AWS CloudProvider will
    provision a classic load balancer with the endpoint `adb576a05401911e8b1240ef0c7f25d3-1637943008.us-east-1.elb.amazonaws.com`.
    We can check its detailed settings via the aws command-line interface ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 服务创建后，我们会发现AWS CloudProvider将提供一个经典负载均衡器，端点为`adb576a05401911e8b1240ef0c7f25d3-1637943008.us-east-1.elb.amazonaws.com`。我们可以通过aws命令行界面检查其详细设置（[https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)）。
- en: To install aws CLI, you can use pip to install in Mac or Linux (`pip install
    awscli`); for Windows users, you'll have to download the installer from the official
    website.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装AWS CLI，您可以在Mac或Linux上使用pip安装（`pip install awscli`）；对于Windows用户，您需要从官方网站下载安装程序。
- en: 'The combination of AWS CLI commands is `aws [options] <command> <subcommand>
    [<subcommand> ...] [parameters]`. For listing load balancers, we''ll use `aws
    elb describe-load-balancers` as the major command. Using the `--load-balancer-names
    parameter` will filter load balancers by name, and for the `--output` parameter,
    you can choose text, JSON, or table:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI命令的组合是`aws [options] <command> <subcommand> [<subcommand> ...] [parameters]`。要列出负载均衡器，我们将使用`aws
    elb describe-load-balancers`作为主要命令。使用`--load-balancer-names`参数将按名称筛选负载均衡器，对于`--output`参数，您可以选择文本、JSON或表格格式：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we access this ELB endpoint port `80`, we''ll see the nginx welcome page:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问此ELB端点端口`80`，我们将看到nginx欢迎页面：
- en: '![](img/40c40acf-d984-4021-ab91-c7f7f92e54bd.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40c40acf-d984-4021-ab91-c7f7f92e54bd.png)'
- en: Access ELB endpoint to access LoadBalancer Service
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 ELB 端点以访问 LoadBalancer Service
- en: 'Behind the scene, AWS CloudProvider creates a AWS elastic load balancer and
    configures its ingress rules and listeners by the Service we just defined. The
    following is a diagram of how the traffic gets into the Pods:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，AWS CloudProvider 创建了一个 AWS 弹性负载均衡器，并通过我们刚刚定义的 Service 配置了其入口规则和监听器。以下是流量进入
    Pods 的示意图：
- en: '![](img/63c00acb-0240-4931-9813-9ffa62912489.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63c00acb-0240-4931-9813-9ffa62912489.png)'
- en: The illustration of Kubernetes resources and AWS resources for Service with
    LoadBalancer type
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 资源与 AWS 资源对于 LoadBalancer 类型 Service 的示意图
- en: The external load balancer receives the requests and forwards them to EC2 instances
    using a round-robin algorithm. For Kubernetes, the traffic gets into the Service
    via NodePort and starts a Service-to-Pod communication. For more information about
    external-to-Service and Service-to-Pod communications, you can refer to [Chapter
    3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing with Containers*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 外部负载均衡器接收请求并使用轮询算法将其转发到 EC2 实例。对于 Kubernetes，流量通过 NodePort 进入 Service，启动 Service
    到 Pod 的通信。关于外部到 Service 和 Service 到 Pod 的通信，您可以参考[第 3 章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)，*与容器玩耍*。
- en: Elastic Block Store as StorageClass
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性块存储作为 StorageClass
- en: We've learned about Volumes in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*. We know `PersistentVolumeClaims` is used
    to abstract storage resources from users. It can dynamically provision the `PersistentVolume`
    via `StorageClass`. The default provisioner in `StorageClass` in **AWS CloudProvider
    is Elastic Block Storage Service**‎ (**aws-ebs**). Whenever you request a PVC,
    aws-ebs provisioner will create a volume in AWS EBS.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 2 章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)，*Kubernetes 概念解析* 中了解了
    Volumes。我们知道 `PersistentVolumeClaims` 用于将存储资源从用户中抽象出来。它可以通过 `StorageClass` 动态提供
    `PersistentVolume`。`StorageClass` 中的默认提供者在 **AWS CloudProvider 中是弹性块存储服务**‎ (**aws-ebs**)。每当你请求一个
    PVC 时，aws-ebs 提供者会在 AWS EBS 中创建一个卷。
- en: 'Let''s check the storage class in our cluster:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们集群中的存储类：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After PVC is created, an associated PV will be created:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 PVC 后，将创建一个关联的 PV：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can take a closer look at PV here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里更仔细地查看 PV：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can find that it's associated with the claim we just created `pvclaim01`
    and the source type is `AWSElasticBlockStore`, as expected.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发现它与我们刚刚创建的 `pvclaim01` 相关联，并且源类型是 `AWSElasticBlockStore`，正如预期的那样。
- en: 'We can use AWS CLI to inspect the volume we created in EBS. Using the `--filter
    Name=tag-`value we can filter the volumes in EBS:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 AWS CLI 检查我们在 EBS 中创建的卷。使用 `--filter Name=tag-`value 我们可以筛选 EBS 中的卷：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can see that the EBS resource has been tagged with lots of different values: by
    observing these tags, we can know which Kubernetes cluster, namespace, PVC, and
    PV are associated with this EBS volume.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 EBS 资源已经被标记了许多不同的值：通过观察这些标签，我们可以知道这个 EBS 卷与哪个 Kubernetes 集群、命名空间、PVC
    和 PV 相关联。
- en: Thanks to dynamic provisioning that StorageClass and CloudProvider support,
    Volume management is no longer a huge pain. We can create and destroy PV on the
    fly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 StorageClass 和 CloudProvider 支持动态提供，卷管理不再是一个巨大痛点。我们可以即时创建和销毁 PV。
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: At the time of writing this book, there is no native way in Kubernetes 1.10
    to support Ingress integration in AWS CloudProvider yet (ideally with application
    load balancer). Alternatively, kops provides addons that allow you to do so. The
    first one is ingress-nginx ([https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx](https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx)),
    which is powered by nginx ([https://nginx.org](https://nginx.org)) and AWS Elastic
    Load Balancer. The requests will go through ELB to nginx, and nginx will dispatch
    the requests, based on the path definition in Ingress. Another alternative is
    running skipper as kubernetes-ingress-controller ([https://zalando.github.io/skipper/dataclients/kubernetes](https://zalando.github.io/skipper/dataclients/kubernetes)).
    Kops also provides add-ons to help you deploy and leverage skipper and AWS Application
    Load Balancer ([https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller](https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，Kubernetes 1.10 尚未提供支持 AWS CloudProvider 中 Ingress 集成的原生方式（理想情况下是通过应用负载均衡器）。作为替代方案，kops
    提供了可以实现这一功能的附加组件。第一个是 ingress-nginx ([https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx](https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx))，它由
    nginx ([https://nginx.org](https://nginx.org)) 和 AWS 弹性负载均衡器支持。请求会通过 ELB 到达 nginx，nginx
    会根据 Ingress 中的路径定义分发请求。另一个替代方案是运行 skipper 作为 kubernetes-ingress-controller ([https://zalando.github.io/skipper/dataclients/kubernetes](https://zalando.github.io/skipper/dataclients/kubernetes))。kops
    还提供了附加组件，帮助您部署并利用 skipper 和 AWS 应用负载均衡器 ([https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller](https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller))。
- en: We're expecting CCM and Amazon EKS ([https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)) to
    provide more native integration for Ingress via AWS Application Load Balancer,
    and there will be more to come!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计 CCM 和 Amazon EKS ([https://aws.amazon.com/eks/](https://aws.amazon.com/eks/))
    将通过 AWS 应用负载均衡器提供更多原生的 Ingress 集成，未来还会有更多更新！
- en: Managing Kubernetes cluster on AWS by kops
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 kops 管理 AWS 上的 Kubernetes 集群
- en: 'In kops, both Kubernetes masters and nodes are running as auto-scaling groups
    in AWS. In kops, the concept is called **instance groups** (**ig**), which indicate
    the same type of instances in your cluster. Similar to nodes across zones, or
    masters in each availability zone, we could check it via the kops command line:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 kops 中，Kubernetes 主节点和节点都作为 AWS 中的自动扩展组运行。在 kops 中，这个概念被称为 **实例组** (**ig**)，表示集群中相同类型的实例。类似于跨可用区的节点，或每个可用区的主节点，我们可以通过
    kops 命令行检查：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With kops, you can change the instance type, resize instance groups (masters
    and nodes), rolling-update, and upgrade cluster. Kops also supports configuration
    for specific AWS features, such as enable AWS detailed monitoring for the instances
    in the cluster.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 kops，您可以更改实例类型，调整实例组（主节点和节点）大小，进行滚动更新，升级集群。kops 还支持针对特定 AWS 功能的配置，例如为集群中的实例启用
    AWS 详细监控。
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For performing this recipe, you''ll need a Kubernetes cluster deployed by kops
    in AWS. You will need to follow the previous recipes in this chapter to launch
    a cluster. Here, we''ll use the same cluster we created in the previous recipe:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 执行本配方时，您需要在 AWS 上通过 kops 部署的 Kubernetes 集群。您需要按照本章前面的配方来启动一个集群。这里，我们将使用之前配方中创建的相同集群：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the previous recipe, we've had the `KOPS_STATE_STORE` environment variable
    set as one of our S3 bucket names by the format `s3://<bucket_name>` to store
    the kops configuration and metadata.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们将 `KOPS_STATE_STORE` 环境变量设置为我们的 S3 存储桶名称之一，格式为 `s3://<bucket_name>`，用于存储
    kops 配置和元数据。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: The upcoming subsections cover some common operational examples that cluster
    administrators may run into.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的子节将介绍集群管理员可能会遇到的一些常见操作示例。
- en: Modifying and resizing instance groups
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改和调整实例组
- en: Modifying instance groups may be cumbersome if you deploy all instances manually.
    You'll need to update instances one by one or relaunch them. By kops, we can easily
    perform the update without pain.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您手动部署所有实例，修改实例组可能会很麻烦。您需要逐一更新实例或重新启动它们。而使用 kops，我们可以轻松地执行更新而不感到困难。
- en: Updating nodes
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新节点
- en: 'Using the kops edit command, we can modify the instance type and the node count:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 kops edit 命令，我们可以修改实例类型和节点数量：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this example, we modify both minSize and maxSize from `2` to `3`. After
    the modification, we''ll need to run the kops update to see it take effect:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将 minSize 和 maxSize 从 `2` 修改为 `3`。修改后，我们需要运行 kops update 来使其生效：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Some updates will need a rolling-update cluster. In this example, kops has
    updated the configuration in the AWS auto scaling group. AWS will then launch
    a new instance to accommodate the change. The following is a screenshot from AWS
    Auto Scaling Group''s console:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 某些更新需要滚动更新集群。在这个示例中，kops 已经更新了 AWS 自动扩展组中的配置。AWS 将启动一个新实例以适应这个变化。以下是来自 AWS 自动扩展组控制台的截图：
- en: '![](img/544524b9-bc0f-422c-b4f7-3632b3e32a07.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/544524b9-bc0f-422c-b4f7-3632b3e32a07.png)'
- en: nodes_in_AWS_Auto_Scaling_Groups
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: nodes_in_AWS_Auto_Scaling_Groups
- en: 'We can see that the configuration has been updated, and AWS is scaling a new
    instance. After few minutes, we can check cluster status via `kops validate` or
    `kubectl get nodes`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到配置已更新，AWS 正在扩展新实例。几分钟后，我们可以通过 `kops validate` 或 `kubectl get nodes` 检查集群状态：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Everything looks good!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好！
- en: Updating masters
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新主节点
- en: Updating masters is the same as updating nodes. Note that masters in the same
    availability zone are in one instance group. This means that you can't add additional
    subnets into the master instance group. In the following example, we'll resize
    the master count from 1 to 2.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 更新主节点与更新节点相同。请注意，同一可用区中的主节点在同一实例组内。这意味着你无法向主节点实例组中添加额外的子网。在以下示例中，我们将把主节点数量从
    1 调整为 2。
- en: In this recipe, we only make the master count 1\. In the real world, the recommended
    way is to deploy masters to at least two availability zones and have three masters
    per zone (one kops instance group). You can achieve that via the `--master-count`
    and `--master-zones` parameters when launching the cluster.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们只将主节点数量设为 1。在实际应用中，推荐的做法是将主节点部署到至少两个可用区，每个可用区配置三个主节点（一个 kops 实例组）。你可以通过启动集群时使用
    `--master-count` 和 `--master-zones` 参数来实现。
- en: 'Now take a look at the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请看以下命令：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Before applying the change, we can run the update cluster command without `--yes`
    in the dry run mode:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用更改之前，我们可以在 dry run 模式下运行更新集群命令，不带 `--yes` 参数：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After we verify the dry run message as expected, we can perform the update as
    follows. In this case, we'll have to perform a rolling update.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证 dry run 消息符合预期后，我们可以按以下方式执行更新。在这种情况下，我们必须进行滚动更新。
- en: How to know whether a rolling update is needed
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如何判断是否需要滚动更新
- en: 'If we didn''t run a kops rolling update in the preceding example, kops will
    show a validation error when running the kops validate cluster:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在之前的示例中没有运行 kops 滚动更新，当运行 kops validate cluster 时，kops 会显示验证错误：
- en: VALIDATION ERRORS
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 验证错误
- en: KIND                NAME                          MESSAGE
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: KIND                NAME                          MESSAGE
- en: InstanceGroup     `master-us-east-1a` InstanceGroup `master-us-east-1a` did
    not have enough nodes 1 vs 2
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: InstanceGroup     `master-us-east-1a` 实例组 `master-us-east-1a` 的节点不足，1 对 2
- en: Remember to replace k8s-cookbook.net with your cluster name.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将 k8s-cookbook.net 替换为你的集群名称。
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Just like modifying nodes, we can use both `kubectl get nodes` and `kops validate
    cluster` to check whether the new master has joined the cluster.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就像修改节点一样，我们可以使用 `kubectl get nodes` 和 `kops validate cluster` 来检查新主节点是否已加入集群。
- en: Upgrading a cluster
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级集群
- en: 'For demonstrating how we upgrade the Kubernetes version, we''ll first launch
    the cluster with the 1.8.7 version. For detailed instructions of parameters, refer
    to the previous recipes in this chapter. Input the following command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何升级 Kubernetes 版本，我们将首先使用 1.8.7 版本启动集群。有关参数的详细说明，请参考本章前面的配方。请输入以下命令：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After few minutes, we can see that the master and the nodes are up with version
    1.8.7:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们可以看到主节点和节点都已经升级到版本 1.8.7：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the following example, we''ll walk through how to upgrade Kubernetes cluster
    from 1.8.7 to 1.9.3 using kops. Firstly, run the kops upgrade cluster command.
    Kops will show us the latest version that we could upgrade to:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将演示如何通过 kops 将 Kubernetes 集群从 1.8.7 升级到 1.9.3。首先，运行 kops upgrade cluster
    命令，kops 将显示我们可以升级到的最新版本：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It indicates that the configuration has been updated, and that we''ll need
    to update the cluster now. We run command with the dryrun mode to check what will
    be modified first:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明配置已经更新，我们现在需要更新集群。我们先运行 dryrun 模式的命令，检查将要修改的内容：
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We could see all of the components moved from v1.8.7 to v1.9.3 in Auto Scaling
    Launch Configuration. After verifying that everything is good, we can run the
    same command with the `--yes` parameter:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有组件已从 v1.8.7 升级到 v1.9.3，并出现在自动扩展启动配置中。验证一切正常后，我们可以运行相同的命令，并添加 `--yes`
    参数：
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this case, we need to run the rolling update for the cluster:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要对集群执行滚动更新：
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: All the nodes have been upgraded to 1.9.3! When performing the rolling update,
    kops drains one instance first then cordons the node. The auto-scaling group will
    bring up another node with the updated user data, which contains the Kubernetes
    component images with the updates. For avoiding downtime, you should have multiple
    masters and nodes as the basic deployment.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点已升级到1.9.3！在执行滚动更新时，kops会首先清空一个实例，然后将节点标记为不可调度（cordon）。自动扩展组将启动另一个带有更新用户数据的节点，该数据包含包含更新的Kubernetes组件镜像。为了避免停机，您应该将多个主节点和节点作为基本部署。
- en: 'After a rolling update is completed, we can check the cluster version via `kubectl
    get nodes`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新完成后，我们可以通过`kubectl get nodes`检查集群版本：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: All the nodes have been upgraded to 1.9.3!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点已升级到1.9.3！
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: In kops, there are lots of useful addons, such as autoscaling nodes ([https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler](https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler))
     and mapping the service to the record in Route53 ([https://github.com/kubernetes/kops/tree/master/addons/route53-mapper](https://github.com/kubernetes/kops/tree/master/addons/route53-mapper)).
    Refer to the add-ons page to find out more!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在kops中，有许多有用的插件，如自动扩展节点（[https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler](https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler)）和将服务映射到Route53中的记录（[https://github.com/kubernetes/kops/tree/master/addons/route53-mapper](https://github.com/kubernetes/kops/tree/master/addons/route53-mapper)）。请参考插件页面以了解更多信息！
- en: See also
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: '*Deployment API* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*部署API*，*走进Kubernetes概念*'
- en: '*Building multiple masters* in [Chapter 4](1a0d884d-59d3-4f67-adee-2d2e37030132.xhtml),
    *Building High-Availability Clusters*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](1a0d884d-59d3-4f67-adee-2d2e37030132.xhtml)中的*构建多个主节点*，*构建高可用性集群*'
- en: '*Managing Kubernetes cluster on GKE* in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml),
    *Building Kubernetes on GCP*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml)中的*管理GKE上的Kubernetes集群*，*在GCP上构建Kubernetes*'
