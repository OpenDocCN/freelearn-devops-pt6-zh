- en: 15\. Continuous integration and continuous deployment for AKS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. AKS 的持续集成与持续部署
- en: DevOps is the union of people, processes, and tools to deliver software faster,
    more frequently, and more reliably. Within the DevOps culture are the practices
    of **continuous integration and continuous deployment** (**CI/CD**). CI/CD is
    a set of practices, implemented through one or more tools, to automatically test,
    build, and deliver software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 是人、流程和工具的结合，旨在更快速、更频繁和更可靠地交付软件。在 DevOps 文化中包含了 **持续集成和持续部署**（**CI/CD**）的实践。CI/CD
    是一组通过一种或多种工具实施的实践，用于自动测试、构建和交付软件。
- en: The CI phase refers to the practice of continuously testing and building software.
    The outcome of the CI phase is a deployable artifact. That artifact could be many
    things; for instance, for a Java application it would be a `JAR` file, and in
    the case of a container-based application it would be a container image.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CI 阶段指的是持续测试和构建软件的实践。CI 阶段的结果是一个可部署的构件。这个构件可以是多种形式；例如，对于 Java 应用程序，它可能是一个 `JAR`
    文件，对于基于容器的应用程序，它可能是一个容器镜像。
- en: The CD phase refers to the practice of continuously releasing software. During
    the CD phase, the artifact that was generated during CI is deployed to multiple
    environments, typically going from test to QA to staging to production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CD 阶段指的是持续发布软件的实践。在 CD 阶段，CI 生成的构件将被部署到多个环境中，通常是从测试环境到质量保证（QA）环境，再到预发布环境，最后到生产环境。
- en: Multiple tools exist to implement CI/CD. GitHub Actions is one such tool. GitHub
    Actions is a workflow automation system built into GitHub. With GitHub Actions,
    you can build, test, and deploy applications written in any language to a variety
    of platforms. It also allows you to build container images and deploy applications
    to a Kubernetes cluster, which you'll do in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种工具可以实现 CI/CD，其中 GitHub Actions 就是一个这样的工具。GitHub Actions 是一个内置于 GitHub 的工作流自动化系统。使用
    GitHub Actions，你可以构建、测试和部署用任何语言编写的应用程序到多种平台。它还允许你构建容器镜像并将应用程序部署到 Kubernetes 集群中，你将在本章中进行操作。
- en: 'Specifically, this chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将具体覆盖以下主题：
- en: CI/CD process for containers and Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和 Kubernetes 的 CI/CD 流程
- en: Setting up Azure and GitHub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Azure 和 GitHub
- en: Setting up a CI pipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 CI 流水线
- en: Setting up a CD pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 CD 流水线
- en: Let's start by exploring the CI/CD lifecycle for containers and Kubernetes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索容器和 Kubernetes 的 CI/CD 生命周期开始。
- en: CI/CD process for containers and Kubernetes
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和 Kubernetes 的 CI/CD 流程
- en: 'Before you start building a pipeline, it''s good to understand the typical
    CI/CD process for containers and Kubernetes. In this section, the high-level process
    shown in *Figure 15.1* will be explored in more depth. For a more detailed exploration
    on CI/CD and DevOps for Kubernetes, you are encouraged to explore the following
    free online eBook by Microsoft: https://docs.microsoft.com/dotnet/architecture/containerized-lifecycle/.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建流水线之前，了解容器和 Kubernetes 的典型 CI/CD 流程是很有帮助的。在本节中，将更深入地探讨 *图 15.1* 所示的高层次流程。如果你想更详细地了解
    Kubernetes 的 CI/CD 和 DevOps，推荐你阅读微软提供的免费在线电子书：[https://docs.microsoft.com/dotnet/architecture/containerized-lifecycle/](https://docs.microsoft.com/dotnet/architecture/containerized-lifecycle/)。
- en: '![A representation of the container and Kubernetes CI/CD process](img/B17338_15_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![容器和 Kubernetes CI/CD 流程的示意图](img/B17338_15_01.jpg)'
- en: 'Figure 15.1: Container and Kubernetes CI/CD process'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：容器和 Kubernetes 的 CI/CD 流程
- en: The process starts with somebody making code changes. Code changes could mean
    application code changes, changes to the Dockerfile used to build the container,
    or changes to the Kubernetes YAML files used to deploy the application on a cluster.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程从某人进行代码更改开始。代码更改可能意味着应用程序代码的更改、更改用于构建容器的 Dockerfile，或更改用于在集群中部署应用程序的 Kubernetes
    YAML 文件。
- en: Once code changes are complete, those changes are committed to a source control
    system. Typically, this is a Git repository, but other systems, such as Subversion
    (SVN), also exist. In a Git repository, you would usually have multiple branches
    of your code. Branches enable multiple individuals and teams to work on the same
    code base in parallel without interfering with each other. Once the work done
    on a branch is complete, it is merged with the main (or master) branch. Once a
    branch is merged, the changes from that branch are shared with others using that
    code base.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码更改完成，这些更改会被提交到源代码管理系统。通常，这会是一个 Git 仓库，但也有其他系统，比如 Subversion（SVN）。在 Git 仓库中，通常会有多个代码分支。分支使得多个个人和团队可以并行在同一个代码库上工作，而不互相干扰。一旦一个分支上的工作完成，它会与主分支（或主分支）合并。分支合并后，该分支的更改将与使用该代码库的其他人共享。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Branches are a powerful functionality of the Git source control system. There
    are multiple ways to manage how you use branches in a code base. Please refer
    to the chapter on branches in Scott Chacon and Ben Straub''s *Pro Git* (Apress,
    2014) for a more in-depth exploration of this topic: https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 分支是 Git 源代码管理系统的强大功能。管理代码库中分支的使用有多种方式。请参考 Scott Chacon 和 Ben Straub 的 *Pro Git*（Apress，2014）一书中的分支章节，深入了解此主题：https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell。
- en: After code is pushed into source control, either in the main branch or a feature
    branch, a CI pipeline can be triggered. In a container-based application, this
    means that the code is built into a container image, that image is tested, and
    if tests succeed, it is pushed to a container registry. Depending on the branch,
    you could include different steps and different tests. For example, on feature
    branches you might only build and test the container to verify the code works
    but not push it to a registry, while on the main branch you might build and test
    the container and push it to a container registry.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码推送到源代码管理系统后，无论是在主分支还是功能分支，CI 流水线都可以被触发。在基于容器的应用程序中，这意味着代码被构建成容器镜像，镜像经过测试，如果测试通过，它会被推送到容器注册表中。根据分支的不同，你可能会包含不同的步骤和测试。例如，在功能分支上，你可能只构建并测试容器以验证代码是否有效，但不会将其推送到注册表中，而在主分支上，你可能会构建并测试容器，并将其推送到容器注册表中。
- en: Finally, a CD pipeline can be triggered to deploy or update your application
    on Kubernetes. Typically, in a CD pipeline, the deployment moves through different
    stages. You can deploy your updated application first to a staging environment,
    where you can run both automated and manual tests on the application before moving
    it to production.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，可以触发 CD 流水线来部署或更新你的 Kubernetes 应用程序。通常，在 CD 流水线中，部署会经过不同的阶段。你可以先将更新后的应用程序部署到暂存环境，在那里你可以对应用程序进行自动化和手动测试，然后再将其推送到生产环境。
- en: Now that you've got an understanding of the CI/CD process for containers and
    Kubernetes, you can start building the example part of this chapter. Let's start
    with setting up Azure and GitHub to do this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了容器和 Kubernetes 的 CI/CD 流程，你可以开始构建本章的示例部分。让我们从设置 Azure 和 GitHub 开始。
- en: Setting up Azure and GitHub
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Azure 和 GitHub
- en: 'In this section, you''ll set up the basic infrastructure you''ll use to create
    and run the pipeline that you will build. To host your container images, you need
    a container registry. You could use a number of container registries, but here
    you''ll create an Azure Container Registry instance because it is well integrated
    with **Azure Kubernetes Service** (**AKS**). After creating the container registry,
    you will need to link that container registry to your AKS cluster and create a
    new service principal, and then you''ll need to set up a GitHub repository to
    run the example part of this chapter. Execute the following seven steps to complete
    this activity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将设置用于创建和运行流水线的基本基础设施。为了托管容器镜像，你需要一个容器注册表。你可以使用多个容器注册表，但在这里你将创建一个 Azure
    容器注册表实例，因为它与 **Azure Kubernetes 服务**（**AKS**）集成得很好。在创建容器注册表后，你需要将该容器注册表与 AKS 集群链接，并创建一个新的服务主体，接着你需要设置一个
    GitHub 仓库来运行本章的示例部分。按照以下七个步骤完成此活动：
- en: To start, create a new container registry. In the Azure search bar, look for `container
    registry` and click on Container registries, as shown in *Figure 15.2:*![Searching
    for container registry in the Azure search bar](img/B17338_15_02.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的容器注册表。在 Azure 搜索栏中，搜索 `container registry` 并点击“容器注册表”，如*图 15.2*所示：![在
    Azure 搜索栏中搜索容器注册表](img/B17338_15_02.jpg)
- en: 'Figure 15.2: Navigating to the Container registry service through the Azure
    portal'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.2：通过 Azure 门户导航到容器注册表服务
- en: Click the Create button at the top to create a new registry. To organize the
    resources in this chapter together, create a new resource group. To do this, click
    on Create new to create a new resource group and call it `rg-pipelines`, as shown
    in *Figure 15.3:*![Clicking the Create new button to create a new resource group](img/B17338_15_03.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的“创建”按钮来创建新的注册表。为了将本章的资源组织在一起，创建一个新的资源组。为此，点击“创建新建”以创建一个新的资源组，并命名为 `rg-pipelines`，如*图
    15.3*所示：![点击“创建新建”按钮以创建新资源组](img/B17338_15_03.jpg)
- en: 'Figure 15.3: Creating a new resource group'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.3：创建一个新的资源组
- en: Provide the details required to create the registry. The registry name needs
    to be globally unique, so consider adding your initials to the registry name.
    It is recommended to create the registry in the same location as your cluster.
    To optimize the spend for the demo, you can change the SKU to Basic. Select the
    Review + Create button at the bottom to create the registry, as shown in *Figure 15.4:*
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供创建注册表所需的详细信息。注册表名称需要是全球唯一的，因此建议在注册表名称中添加你的首字母。建议在与你的集群相同的位置创建注册表。为了优化演示的开销，你可以将
    SKU 更改为 Basic。选择底部的“查看 + 创建”按钮来创建注册表，如*图 15.4*所示：
- en: '![Clicking the Review + create button to create a new container registry](img/B17338_15_04.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![点击“查看 + 创建”按钮以创建新的容器注册表](img/B17338_15_04.jpg)'
- en: 'Figure 15.4: Creating a new container registry'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.4：创建新的容器注册表
- en: In the resulting pane, click the Create button to create the registry.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在弹出的面板中，点击“创建”按钮以创建注册表。
- en: 'When your registry is created, open Cloud Shell so that you can configure your
    AKS cluster to get access to your container registry. Use the following command
    to give AKS permissions on your registry:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当注册表创建完成后，打开 Cloud Shell，以便配置你的 AKS 集群以获取对容器注册表的访问权限。使用以下命令授予 AKS 对注册表的权限：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will return an output similar to *Figure 15.5*, which has been cropped
    to show only the top part of the output:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回一个类似于*图 15.5*的输出，已裁剪为只显示输出的顶部部分：
- en: '![Configuring the AKS cluster to get access to the container registry](img/B17338_15_05.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![配置 AKS 集群以获取对容器注册表的访问权限](img/B17338_15_05.jpg)'
- en: 'Figure 15.5: Allowing AKS cluster to access the container registry'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.5：允许 AKS 集群访问容器注册表
- en: 'Next, you''ll need to create a service principal that will be used by GitHub
    Actions to connect to your subscription. You can create this service principal
    using the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个服务主体，GitHub Actions 将使用它来连接到你的订阅。你可以使用以下命令创建此服务主体：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will need the full output JSON of this command, as highlighted in *Figure 15.6*,
    later in GitHub. Copy this output:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要该命令的完整输出 JSON，如*图 15.6*所示，稍后在 GitHub 中使用。复制此输出：
- en: '![Creating a new service principal](img/B17338_15_06.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建新的服务主体](img/B17338_15_06.jpg)'
- en: 'Figure 15.6: Creating a new service principal'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.6：创建一个新的服务主体
- en: This completes the Azure part of the setup. Next, you'll need to log in to GitHub,
    fork the repo that comes with this book, and configure a secret in this repo.
    If you do not yet have a GitHub account, please create one via https://github.com/join.
    If you already have an account, please sign in using https://github.com/login.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了 Azure 部分的设置。接下来，你需要登录 GitHub，fork 本书附带的仓库，并在该仓库中配置一个 secret。如果你还没有 GitHub
    帐户，请通过 https://github.com/join 创建一个。如果你已有帐户，请通过 https://github.com/login 登录。
- en: Once you are logged in to GitHub, browse to the repository associated with this
    book at https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure-third-edition.
    Create a fork of this repo in your account by clicking on the Fork button in the
    top-right corner of the screen, as shown in *Figure 15.7:*![Forking the GitHub
    repo](img/B17338_15_07.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你登录 GitHub，浏览到本书相关的仓库：https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure-third-edition。通过点击屏幕右上角的“Fork”按钮，在你的帐户中创建一个该仓库的
    fork，如*图 15.7*所示：![Fork GitHub 仓库](img/B17338_15_07.jpg)
- en: 'Figure 15.7: Forking the GitHub repository'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.7：Fork GitHub 仓库
- en: Forking the repo will create a copy of the repository in your own GitHub account.
    This will allow you to make changes to the repository, as you will do as you build
    the pipeline in this chapter.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fork 仓库会在您自己的 GitHub 账户中创建一个副本。这将允许您对仓库进行更改，就像在本章中构建管道时所做的那样。
- en: Forking the repository takes a couple of seconds. Once you have the fork in
    your own account, you'll need to configure the Azure secret in this repo. Start
    by clicking on Settings in the top-right corner of your repo, as shown in *Figure 15.8:*
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fork 仓库只需要几秒钟。一旦在您自己的账户中有了 fork，您将需要在此仓库中配置 Azure 秘密。首先点击您仓库右上角的设置，如 *图 15.8:*
    所示。
- en: '![Clicking on the Settings button in the GitHub repo](img/B17338_15_08.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![点击 GitHub 仓库中的设置按钮](img/B17338_15_08.jpg)'
- en: 'Figure 15.8: Clicking on settings in the GitHub repository'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '图 15.8: 点击 GitHub 仓库中的设置按钮'
- en: This will take you to the setting of your repo. On the left-hand side, click
    on Secrets, and on the resulting screen click on the New repository secret button
    at the top, as shown in *Figure 15.9:*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您进入仓库的设置。在左侧，点击 Secrets，然后在结果屏幕上方点击 New repository secret 按钮，如 *图 15.9:*
    所示。
- en: '![Creating a new repository secret](img/B17338_15_09.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建新的仓库秘密](img/B17338_15_09.jpg)'
- en: 'Figure 15.9: Creating a new repository secret'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '图 15.9: 创建新的仓库秘密'
- en: This will take you to the screen to create the new secret. Call this secret
    `AZURE_CREDENTIALS`, and as the value for the secret, paste in the output from
    the CLI command you issued in *step 4* of this section, as shown in *Figure 15.10:*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您到创建新秘密的屏幕。将此秘密称为 `AZURE_CREDENTIALS`，作为秘密的值，粘贴 CLI 命令输出中的内容，该命令在本节的*步骤 4*
    中显示，如 *图 15.10:* 所示。
- en: '![Setting the value for the new secret](img/B17338_15_10.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![设置新秘密的值](img/B17338_15_10.jpg)'
- en: 'Figure 15.10: Setting of the value of the new secret'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '图 15.10: 设置新秘密的值'
- en: Finally, click on Add secret at the bottom of this screen to save the secret.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在此屏幕底部点击 Add secret 以保存秘密。
- en: Now you have set up Azure and GitHub to start building your pipeline. You have
    created a service principal that GitHub will use to interact with Azure, and you
    created a container registry that your CI pipeline can push images to and that
    AKS can pull images from. Let's now build a CI pipeline.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置好了 Azure 和 GitHub 来开始构建您的管道。您已经创建了一个服务主体，GitHub 将用它与 Azure 进行交互，并且您创建了一个容器注册表，您的
    CI 管道可以将镜像推送到其中，AKS 可以从中拉取镜像。现在让我们构建一个 CI 管道。
- en: Setting up a CI pipeline
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一个 CI 管道
- en: 'You are now ready to build a CI pipeline. As part of the demonstration in this
    section, you will build an `nginx` container with a small custom webpage loaded
    in it. After the container is built, you will push the `nginx` container to the
    container registry you created in the previous section. You will build the CI
    pipeline gradually over the next 13 steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经准备好构建一个 CI 管道了。作为本节演示的一部分，您将构建一个带有小型自定义网页的 `nginx` 容器。容器构建完成后，您将把 `nginx`
    容器推送到之前在上一节创建的容器注册表中。接下来的 13 个步骤中逐步构建 CI 管道：
- en: 'To start, open the forked GitHub repo and open the folder for `Chapter 15`.
    In that folder, you will find a couple of files, including `Dockerfile` and `index.html`.
    These files are used to build the custom container. Throughout the example, you
    will make changes to `index.html` to trigger changes in the GitHub action. Let''s
    have a look at the contents of `index.html`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 fork 后的 GitHub 仓库并打开 `Chapter 15` 文件夹。在该文件夹中，您会找到一些文件，包括 `Dockerfile`
    和 `index.html`。这些文件用于构建自定义容器。在示例中，您将更改 `index.html` 以触发 GitHub 动作中的更改。让我们来看看 `index.html`
    的内容：
- en: '[PRE2]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple HTML file, with a title and a header both saying `Version 1`.
    In the *Setting up a CD pipeline* section, you'll be asked to increment the version.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的 HTML 文件，具有标题和标题，都说 `Version 1`。在*设置 CD 管道*部分，您将被要求增加版本号。
- en: 'Next, you were also provided with a Dockerfile. The contents of that file are
    as follows:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，您还提供了一个 Dockerfile 文件。该文件的内容如下：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This Dockerfile starts from an `nginx-alpine` base image. Nginx is a popular
    open-source web server, and Alpine is a lightweight operating system often used
    for container images. In the second line, you copy the local `index.html` file
    into the container, into the location where `nginx` loads webpages from.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 从一个`nginx-alpine`基础镜像开始。Nginx 是一个流行的开源 Web 服务器，Alpine 是一个轻量级操作系统，通常用于容器镜像。在第二行，您将本地的`index.html`文件复制到容器中，复制到`nginx`加载网页的位置。
- en: Now that you have an understanding of the application itself, you're ready to
    start building the CI pipeline. For your reference, the full definition of the
    CI pipeline is provided as `pipeline-ci.yaml` in the code files with this chapter,
    but you'll be instructed to build this pipeline step by step in what follows.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你已经了解了应用程序本身，接下来可以开始构建 CI 流水线。供你参考，CI 流水线的完整定义已作为`pipeline-ci.yaml`文件包含在本章的代码文件中，但接下来会逐步指导你如何构建这条流水线。
- en: Let's start by creating a GitHub Actions workflow. At the top of the screen
    in GitHub, click on Actions and then click on the set up a workflow yourself link,
    as shown in *Figure 15.11:*![Clicking the Set up a workflow yourself button to
    create a new GitHub action](img/B17338_15_11.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个 GitHub Actions 工作流开始。在 GitHub 屏幕顶部，点击 "Actions"，然后点击 "set up a workflow
    yourself" 链接，如*图 15.11*所示：![点击 “Set up a workflow yourself” 按钮以创建新的 GitHub 操作](img/B17338_15_11.jpg)
- en: 'Figure 15.11: Creating a new GitHub action'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.11：创建新的 GitHub 操作
- en: This will take you to a code editor that is part of GitHub. First, change the
    name of the pipeline file to `pipeline.yaml` and change the name on *line 3* to
    `pipeline`, as shown in *Figure 15.12:*![Changing the name of the pipeline](img/B17338_15_12.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带你进入一个 GitHub 代码编辑器。首先，将流水线文件的名称改为 `pipeline.yaml`，并将*第 3 行*的名称改为 `pipeline`，如*图
    15.12*所示：![更改流水线名称](img/B17338_15_12.jpg)
- en: 'Figure 15.12: Changing the name of the pipeline'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.12：更改流水线名称
- en: 'Next, you''ll focus on the triggers of the workflow. In this demonstration,
    you''ll only work with the main branch. However, you do not want the workflow
    to run for every code change. You only want it to run when changes are made to
    either the pipeline definition or the code in the `Chapter 15` folder. To achieve
    this, you can set up the following code to control the workflow trigger:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将关注工作流的触发条件。在本示例中，你只会使用主分支。然而，你并不希望工作流对每个代码更改都执行。你只希望当对 `Chapter 15` 文件夹中的流水线定义或代码进行更改时，工作流才会运行。为此，你可以设置以下代码来控制工作流的触发：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What this code configures is the following:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码配置的是以下内容：
- en: '`Chapter15` directory as well as changes to the `pipeline.yaml` file in the
    `.github/workflows/` directory will trigger the workflow to run.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter15` 目录以及 `.github/workflows/` 目录中 `pipeline.yaml` 文件的更改将触发工作流的运行。'
- en: '`ACRNAME` variable to the name of the container registry you created. By using
    variables, you avoid having to configure the same value in multiple places.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `ACRNAME` 变量设置为你创建的容器注册表的名称。通过使用变量，你可以避免在多个地方配置相同的值。
- en: That explains how the pipeline is triggered and how you can configure variables;
    let's now look at what will run in the pipeline.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这解释了流水线是如何触发的，以及如何配置变量；接下来让我们看看流水线中将会运行什么。
- en: Before we define the commands that are executed in the pipeline, let's explore
    the structure of a GitHub Actions workflow, as shown in *Figure 15.13:*
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义流水线中执行的命令之前，让我们先了解 GitHub Actions 工作流的结构，如*图 15.13*所示：
- en: '![A representation of the GitHub action structure](img/B17338_15_13.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 操作结构的表示](img/B17338_15_13.jpg)'
- en: 'Figure 15.13: GitHub Actions workflow'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.13：GitHub Actions 工作流
- en: 'A GitHub Actions workflow is made up of multiple jobs. A job can then have
    multiple steps in it. Jobs run in parallel by default but can be configured to
    run sequentially. The steps in a job will be run sequentially. A step in a job
    will contain the actual commands that will be run as part of the pipeline. An
    example of a step would be building a container image. There are multiple ways
    to run commands in a workflow: you can either run direct shell commands as you
    would on a regular terminal, or you can run prebuilt actions from the GitHub community.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GitHub Actions 工作流由多个作业组成。每个作业可以包含多个步骤。作业默认并行运行，但可以配置为顺序运行。作业中的步骤将按顺序执行。作业中的每个步骤将包含作为流水线一部分实际执行的命令。一个步骤的例子可能是构建容器镜像。在工作流中有多种方式运行命令：你可以像在常规终端中一样直接运行
    shell 命令，也可以运行 GitHub 社区提供的预构建操作。
- en: The jobs and steps are run on what is called a runner. By default, workflows
    are run on hosted runners. These hosted runners run on infrastructure set up and
    managed by GitHub. Optionally, you can run the jobs and steps on a self-hosted
    runner. This gives you the ability to have more configuration capabilities on
    the runner, for instance, to allow you to use special hardware or have specific
    software installed. Self-hosted runners can be physical, virtual, in a container,
    on-premises, or in a cloud.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作业和步骤是在所谓的运行器上运行的。默认情况下，工作流在托管的运行器上运行。这些托管的运行器运行在由 GitHub 设置和管理的基础设施上。你也可以选择在自托管运行器上运行作业和步骤。这样可以让你对运行器有更多的配置能力，例如，允许使用特殊硬件或安装特定软件。自托管的运行器可以是物理的、虚拟的、容器中的、本地的或云中的。
- en: In this section, you will run workflow steps from the community as well as shell
    commands. For an overview of actions available from the community, please refer
    to the GitHub marketplace at https://github.com/marketplace?type=actions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将运行来自社区的工作流步骤以及 shell 命令。有关社区提供的动作的概览，请访问 GitHub Marketplace：https://github.com/marketplace?type=actions。
- en: 'In the CI pipeline you are building, you''ll need to execute the following
    steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在你正在构建的 CI 管道中，你需要执行以下步骤：
- en: Get the GitHub repo on the action runner, also called a check-out of your repository.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 GitHub 仓库到动作运行器，也称为检出你的仓库。
- en: Log in to the Azure CLI.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Azure CLI。
- en: Log in to Azure Container Registry.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Azure 容器注册表。
- en: Build a container image and push this container image to Azure Container Registry.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个容器镜像并将此容器镜像推送到 Azure 容器注册表。
- en: Let's build the pipeline step by step.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步构建管道。
- en: 'Before you build the actual steps in the pipeline, you''ll need to configure
    the jobs and the configuration of your job. Specifically, for this example, you
    can use the following configuration:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建实际步骤之前，你需要配置作业和作业的配置。具体来说，对于这个示例，你可以使用以下配置：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You are configuring the following:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你正在配置以下内容：
- en: '`CI` for now. You''ll add the CD job later.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前是 `CI`。你稍后会添加 CD 作业。
- en: '`ubuntu-latest`.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ubuntu-latest`。'
- en: This configures the GitHub runner for the steps. Let's now start building the
    individual steps.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这配置了 GitHub 运行器的步骤。现在，让我们开始构建各个步骤。
- en: 'The first step will be checking out the Git repo. This means that the code
    in the repo gets loaded by the runner. This can be achieved using the following
    lines of code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是检查 Git 仓库。这意味着代码将在运行器中加载。可以使用以下几行代码来实现：
- en: '[PRE6]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line represented here (*line 25*) is what opens the `steps` block
    and all the following steps. The first step is called `Git checkout` (*line 27*)
    and simply refers to a prebuilt action called `actions/checkout@v2`. The `@v2`
    means that you are using the second version of this action.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里表示的第一行（*第 25 行*）是打开 `steps` 块和所有后续步骤的地方。第一步叫做 `Git checkout`（*第 27 行*），指的是一个名为
    `actions/checkout@v2` 的预构建动作。`@v2` 表示你正在使用该动作的第二个版本。
- en: Next, you will need to log in to the Azure CLI and then use the Azure CLI to
    log in to the Azure Container Registry. To do so, you'll make use of an action
    from the marketplace. You can find items in the marketplace by using the search
    bar at the right side of your screen, as shown in *Figure 15.14:*![Searching for
    the Azure Login action in the GitHub Marketplace](img/B17338_15_14.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要登录 Azure CLI，然后使用 Azure CLI 登录到 Azure 容器注册表。为此，你将使用市场中的一个动作。你可以通过屏幕右侧的搜索栏找到市场中的项目，如*图
    15.14 所示：* ![在 GitHub Marketplace 中搜索 Azure 登录动作](img/B17338_15_14.jpg)
- en: '[PRE7]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first step logs in to the Azure CLI on the GitHub Actions runner. To log
    in to the Azure CLI, it uses the secret you configured in the previous section.
    The second job executes an Azure CLI command to log in to Azure Container Registry.
    It uses the variable you configured on *lines 14-15*. It executes the `login`
    command as a regular shell command. In the next step, you'll push the image to
    this container registry.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一步是在 GitHub Actions 运行器上登录 Azure CLI。为了登录 Azure CLI，它使用了你在上一节中配置的密钥。第二个任务执行一个
    Azure CLI 命令，以登录 Azure 容器注册表。它使用你在*第 14-15 行*配置的变量。它将 `login` 命令作为常规 shell 命令执行。在接下来的步骤中，你将把镜像推送到此容器注册表。
- en: 'Next, you build the container image. There are multiple ways to do this, and
    you''ll use `docker/build-push-action` in this example:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将构建容器镜像。虽然有多种方式可以做到这一点，但在这个示例中你将使用 `docker/build-push-action`：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This step will build your container image and push it to the registry. You
    configure the context to run within the `Chapter15` folder, so the reference in
    the Dockerfile to the `index.html` page remains valid. It will tag that image
    with the name of your container registry, and as a version number for the container
    image, it will use the run number of the GitHub action. To get the run number
    of the workflow, you are using one of the default environment variables that GitHub
    configures. For a full list, please refer to the GitHub documentation: https://docs.github.com/actions/reference/environment-variables.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步将构建你的容器镜像并推送到注册表。你配置了在`Chapter15`文件夹中运行，因此Dockerfile中对`index.html`页面的引用保持有效。它将使用你的容器注册表的名称为镜像打标签，并且将GitHub
    Actions的运行号作为容器镜像的版本号。为了获取工作流的运行号，你使用了GitHub配置的默认环境变量之一。有关完整的列表，请参考GitHub文档：[GitHub文档](https://docs.github.com/actions/reference/environment-variables)。
- en: Note
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, you are using the workflow run number as the version for your
    container image. Tagging container images is important since the tag version indicates
    the version of the container. There are multiple other strategies as well to version
    your container images.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用工作流的运行号作为容器镜像的版本。为容器镜像打标签很重要，因为标签版本表示容器的版本。还有许多其他策略可以用来为容器镜像版本化。
- en: One strategy that is discouraged is to tag container images with the latest
    tag and use that tag in your Kubernetes deployments. The `latest` tag is the default
    tag that Docker will add to images if no tag is supplied. The problem with the
    `latest` tag is that if the image with the `latest` tag in your container registry
    changes, Kubernetes will not pick up this change directly. On nodes that have
    a local copy of the image with the `latest` tag, Kubernetes will not pull the
    new image until a timeout expires; however, nodes that don't have a copy of the
    image will pull the updated version when they need to run a pod with this image.
    This can cause you to have different versions running in a single deployment,
    which should be avoided.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个不推荐的策略是使用`latest`标签标记容器镜像，并在Kubernetes部署中使用该标签。`latest`标签是Docker在未提供标签时会自动添加到镜像的默认标签。使用`latest`标签的问题在于，如果容器注册表中的`latest`标签的镜像发生变化，Kubernetes不会立即获取这个变化。在拥有本地`latest`标签镜像副本的节点上，Kubernetes不会在超时过期之前拉取新镜像；但是，没有该镜像副本的节点会在需要运行此镜像的Pod时拉取更新版本。这可能导致在单个部署中运行不同版本的镜像，这是应当避免的。
- en: You are now ready to save and run this GitHub Actions workflow. You can save
    the workflow configuration file by clicking on the Start Commit button and then
    confirming by clicking Commit new file, as shown in *Figure 15.16:*![Saving the
    action configuration file](img/B17338_15_16.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经准备好保存并运行这个GitHub Actions工作流了。你可以点击“Start Commit”按钮保存工作流配置文件，然后通过点击“Commit
    new file”进行确认，正如*图15.16*所示：![保存Action配置文件](img/B17338_15_16.jpg)
- en: 'Figure 15.16: Saving the action configuration file'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.16：保存Action配置文件
- en: Once the file has been saved, the workflow will be triggered to run. To follow
    the logs of the workflow run, you can click on Actions at the top of the screen.
    This should show you a screen similar to *Figure 15.17:*![Viewing the Actions
    run history](img/B17338_15_17.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件被保存，工作流将触发运行。要查看工作流运行的日志，你可以点击屏幕顶部的“Actions”。这应该会显示一个类似于*图15.17*的屏幕：![查看Actions运行历史](img/B17338_15_17.jpg)
- en: 'Figure 15.17: Getting the actions run history'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.17：获取Actions运行历史
- en: Click on the top entry to get more details of your workflow run. This will bring
    you to a screen similar to *Figure 15.18:*
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击顶部条目以获取更多关于你工作流运行的详情。这将带你到一个类似于*图15.18*的屏幕：
- en: '![A detailed view of the action run](img/B17338_15_18.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Action运行的详细视图](img/B17338_15_18.jpg)'
- en: 'Figure 15.18: Detail screen of the action run'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.18：Action运行的详细屏幕
- en: This shows you your workflow detail and shows you that you had a single job
    in your workflow. Click on CI to get the logs of that job. This will show you
    a screen similar to *Figure 15.19:*
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这显示了你的工作流详情，并告诉你在工作流中只有一个任务。点击CI查看该任务的日志。这将显示一个类似于*图15.19*的屏幕：
- en: '![Viewing logs of the CI job](img/B17338_15_19.jpg)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![查看CI任务的日志](img/B17338_15_19.jpg)'
- en: 'Figure 15.19: Logs of the CI job'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.19：CI任务的日志
- en: On this screen, you can see the output logs of each step in your workflow. You
    can expand the logs of each step by clicking on the arrow icon in front of that step.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个屏幕上，你可以看到工作流中每一步的输出日志。你可以通过点击每一步前面的箭头图标来展开该步骤的日志。
- en: In this example, you built a container image and pushed that to a container
    registry on Azure. Let's verify this image was indeed pushed to the registry.
    For this, go back to the Azure portal and, in the search bar, look for `container
    registry`, as shown in *Figure 15.20:*![Searching for container registry using
    the Azure search bar](img/B17338_15_20.jpg)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，你构建了一个容器镜像，并将其推送到 Azure 上的容器注册表。接下来，我们来验证这个镜像是否已经成功推送到注册表。为此，返回 Azure
    门户，在搜索栏中输入`container registry`，如*图 15.20 所示*：![通过 Azure 搜索栏搜索容器注册表](img/B17338_15_20.jpg)
- en: 'Figure 15.20: Navigating to the Container registries service through the Azure
    portal'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.20：通过 Azure 门户导航到容器注册服务
- en: In the resulting screen, click on the registry you created earlier. Now, click
    on Repositories on the left-hand side, which should show you the `website/website`
    repository, as shown in *Figure 15.21:*
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在结果页面中，点击你之前创建的注册表。接下来，点击左侧的Repositories选项，应该会显示出`website/website`仓库，如*图 15.21
    所示*：
- en: '![Viewing the website/website repository in the container registry](img/B17338_15_21.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![查看容器注册表中的网站/网站仓库](img/B17338_15_21.jpg)'
- en: 'Figure 15.21: Showing the website/website repository in the container registry'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.21：显示容器注册表中的网站/网站仓库
- en: If you click on the `website/website` repository link, you should see the image
    tags for your container image, as shown in *Figure 15.22:*
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果点击`website/website`仓库的链接，你应该会看到你的容器镜像的镜像标签，如*图 15.22 所示*：
- en: '![Viewing the image tags for the container image](img/B17338_15_22.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![查看容器镜像的镜像标签](img/B17338_15_22.jpg)'
- en: 'Figure 15.22: Image tags for the container image'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.22：容器镜像的镜像标签
- en: If you compare the output of *Figure 15.18* and *Figure 15.22*, you will see
    that the run number of the action is also the tag on the image. In your case,
    that run number and tag will likely be 1.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对比*图 15.18*和*图 15.22*的输出，你会发现动作的运行号也是镜像的标签。在你的例子中，运行号和标签可能是 1。
- en: You have now built a rudimentary CI pipeline. When the code in the `Chapter
    15` folder is changed, the pipeline will run and build a new container image that
    will be pushed to the container registry. In the next section, you will add a
    CD job to your pipeline to also deploy the image to a deployment in Kubernetes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经构建了一个基本的 CI 流水线。当`Chapter 15`文件夹中的代码发生变化时，流水线会运行并构建一个新的容器镜像，该镜像将被推送到容器注册表。在下一节中，你将向流水线中添加一个
    CD 任务，用于将镜像部署到 Kubernetes 中的部署。
- en: Setting up a CD pipeline
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 CD 流水线
- en: You already have a pipeline with a CI job that will build a new container image.
    In this section, you'll add a CD job to that pipeline that will deploy the updated
    container image to a deployment in Kubernetes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经拥有一个包含 CI 任务的流水线，该任务会构建一个新的容器镜像。在本节中，你将向该流水线中添加一个 CD 任务，该任务会将更新后的容器镜像部署到
    Kubernetes 中的部署。
- en: To simplify the application deployment, a Helm Chart for the application has
    been provided in the `website` folder inside `Chapter 15`. You can deploy the
    application by deploying the Helm Chart. By deploying using a Helm Chart, you
    can override the Helm values using the command line. You've done this in *Chapter
    12, Connecting an app to an Azure database*, when you configured WordPress to
    use an external database.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化应用部署，`website`文件夹中已提供应用程序的 Helm Chart。你可以通过部署 Helm Chart 来部署应用程序。通过 Helm
    Chart 部署时，你可以使用命令行覆盖 Helm 值。你在*第 12 章，将应用连接到 Azure 数据库*中也做过类似操作，当时你配置了 WordPress
    使用外部数据库。
- en: 'In this CD job you will need to execute the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 CD 任务中，你需要执行以下步骤：
- en: Check out the code.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看代码。
- en: Get AKS credentials.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 AKS 凭证。
- en: Set up the application.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应用程序。
- en: (Optional) Get the service's public IP.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）获取服务的公共 IP。
- en: 'Let''s start building the CD pipeline. For your reference, the full CI and
    CD pipeline has been provided in the `pipeline-cicd.yaml` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建 CD 流水线。为了方便参考，完整的 CI 和 CD 流水线已经在`pipeline-cicd.yaml`文件中提供：
- en: To add the CD job to the pipeline, you'll need to edit the `pipeline.yaml` file.
    To do this, from within your forked repository, click on Code at the top of the
    screen and go to the `.github/workflows` folder. In that folder, click on the
    `pipeline.yaml` file. Once that file is open, click on the pen icon in the top
    right, as highlighted in *Figure 15.23:*![Clicking on the pen icon to edit the
    pipeline.yaml file](img/B17338_15_23.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向流水线中添加 CD 任务，你需要编辑`pipeline.yaml`文件。为此，在你自己的仓库中，点击屏幕顶部的“Code”按钮，然后进入`.github/workflows`文件夹。在该文件夹中，点击`pipeline.yaml`文件。文件打开后，点击右上角的笔图标，如*图
    15.23 所示*：![点击笔图标编辑 pipeline.yaml 文件](img/B17338_15_23.jpg)
- en: 'Figure 15.23: Editing the pipeline.yaml file'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.23：编辑 pipeline.yaml 文件
- en: 'In the file, at the bottom, start by adding the following lines to define the
    CD job:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部，首先添加以下几行来定义 CD 作业：
- en: '[PRE9]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code block, you are creating the CD job. This will again run on an `ubuntu-latest`
    runner. On *line 48*, you are defining that this job has a dependency on the CI
    job. This means that this job will only start after the CI job finishes, and it
    will only run if the CI job finishes successfully. Finally, *line 49* opens the
    `steps` block, which you will fill in next.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这段代码中，你正在创建 CD 作业。该作业将再次在 `ubuntu-latest` 运行器上运行。在 *第 48 行*，你定义了该作业依赖于 CI 作业。这意味着该作业只有在
    CI 作业完成之后才会开始，并且只有在 CI 作业成功完成的情况下才会运行。最后，*第 49 行* 打开了 `steps` 块，接下来你将在其中填写内容。
- en: 'The first step will be a Git checkout. This will use the same step you use
    in the CI job as well:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步将是 Git 检出。这将使用你在 CI 作业中使用的相同步骤：
- en: '[PRE10]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, you''ll need to log in to the Azure CLI and get the AKS credentials.
    You could do this by using the same approach as you did in the CI job, meaning
    you could do an Azure CLI login and then run the `az aks get-credentials` command
    on the runner. However, there is a single GitHub action that can achieve this
    for AKS:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要登录到 Azure CLI 并获取 AKS 凭据。你可以使用与 CI 作业中相同的方法来完成这一步，意味着你可以执行 Azure CLI
    登录，然后在运行器上运行 `az aks get-credentials` 命令。不过，也有一个单独的 GitHub 动作可以为 AKS 完成这项工作：
- en: '[PRE11]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This step uses the `Azure/aks-set-context` action from Microsoft. You configure
    it with the Azure credentials secrets you created, and then define the resource
    group and cluster name you want to use. This will configure the GitHub action
    runner to use those AKS credentials.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步使用了 Microsoft 的 `Azure/aks-set-context` 动作。你使用你创建的 Azure 凭证密钥对其进行配置，然后定义你要使用的资源组和集群名称。这将配置
    GitHub 动作运行器使用这些 AKS 凭证。
- en: 'You can now create the application on the cluster. As mentioned in the introduction
    of this section, you will deploy the application using the Helm Chart created
    in the `website` folder for this chapter. To deploy this Helm Chart on your cluster,
    you can use the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在集群上创建应用程序。如本节开头所提到的，你将使用本章中的 `website` 文件夹中创建的 Helm Chart 部署该应用程序。要在集群上部署这个
    Helm Chart，你可以使用以下代码：
- en: '[PRE12]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code block executes a `Helm upgrade` command. The first argument (`website`)
    refers to the name of the Helm release. The second argument (`Chapter15/website`)
    refers to the location of the Helm Chart. The `--install` parameter configures
    Helm in such a way that if the chart isn't installed yet, it will be installed.
    This will be the case the first time you run this action.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码执行一个 `Helm upgrade` 命令。第一个参数（`website`）指的是 Helm 发布的名称。第二个参数（`Chapter15/website`）指的是
    Helm Chart 的位置。`--install` 参数将 Helm 配置为，如果 Chart 尚未安装，它会自动安装。这将在你第一次运行该动作时发生。
- en: In the following two lines, you set Helm values. You set the image repository
    to the `website/website` repo in your container registry, and you set the tag
    to the run number of the action. This is the same value you are using in the CI
    step to tag the image.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的两行中，你设置了 Helm 值。你将镜像仓库设置为容器注册表中的 `website/website` 仓库，并将标签设置为操作的运行编号。这是你在
    CI 步骤中用来标记镜像的相同值。
- en: 'Finally, there is one optional step you can include in your workflow. This
    is getting the public IP address of the service that will be created to serve
    your website. This is optional because you could get this IP address using `kubectl`
    in Azure Cloud Shell, but it has been provided for your convenience:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以在工作流中包括一个可选步骤。这是获取将被创建并用于服务你网站的服务的公网 IP 地址。这是可选的，因为你可以在 Azure Cloud Shell
    中使用 `kubectl` 获取该 IP 地址，但为了方便起见，这里为你提供了该步骤：
- en: '[PRE13]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code block will run a small Bash script. While the public IP hasn't been
    set, it will keep getting the public IP from the service using `kubectl`. Once
    the public IP has been set, the public IP will be shown in the GitHub Actions
    log.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码将运行一个小的 Bash 脚本。虽然公网 IP 尚未设置，它将不断使用 `kubectl` 从服务中获取公网 IP。一旦公网 IP 设置好，公网
    IP 将会显示在 GitHub Actions 日志中。
- en: You are now ready to save the updated pipeline and run it for the first time.
    To save the pipeline, click on the Start commit button at the top right of the
    screen and click on Commit changes in the pop-up window, as shown in *Figure 15.24:*![Saving
    the updated pipeline](img/B17338_15_24.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你已经准备好保存更新后的流水线并第一次运行它。要保存流水线，点击屏幕右上角的“开始提交”按钮，并在弹出的窗口中点击“提交更改”，如 *图 15.24
    所示：* ![保存更新后的流水线](img/B17338_15_24.jpg)
- en: 'Figure 15.24: Pipeline workflow'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.24：流水线工作流
- en: Once you have committed the changes to GitHub, the workflow will be triggered
    to run. To follow the deployment, click on Actions at the top of the screen. Click
    on the top entry here to see the details of the run. Initially, the output will
    look similar to *Figure 15.25:*![A detailed output of the action run while the
    action is running](img/B17338_15_25.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你提交了更改到GitHub，工作流将被触发运行。为了跟踪部署情况，点击屏幕顶部的Actions。点击这里的顶部条目查看运行的详细信息。最初，输出将类似于*图
    15.25：*![操作运行时的详细输出](img/B17338_15_25.jpg)
- en: 'Figure 15.25: Detailed output of the action run while the action is running'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.25：操作运行时的详细输出
- en: 'As you can see, you now have access to two jobs in this workflow run, the CI
    job and the CD job. While the CI job is running, the CD job''s logs won''t be
    available. Once the CI job finishes successfully, you''ll be able to access the
    logs of the CD job. Wait for a couple of seconds until the screen looks like *Figure
    15.26*, which indicates that the workflow successfully finished:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，现在你可以访问该工作流中两个作业，CI作业和CD作业。当CI作业正在运行时，CD作业的日志将不可用。一旦CI作业成功完成，你将能够访问CD作业的日志。等待几秒钟，直到屏幕显示如*图
    15.26*所示，表明工作流已成功完成：
- en: '![A detailed output of the action run after both jobs are finished](img/B17338_15_26.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![两个作业完成后操作运行的详细输出](img/B17338_15_26.jpg)'
- en: 'Figure 15.26: Detailed output of the action run after both jobs finished'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.26：两个作业完成后操作运行的详细输出
- en: Now, click on the CD job to see the logs of this job. Click on the arrow next
    to Get service IP to see the public IP of the service that got created, as shown
    in *Figure 15.27:*![Logs of the CD job showing the public IP address of the service](img/B17338_15_27.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击CD作业查看该作业的日志。点击“获取服务IP”旁边的箭头，查看创建的服务的公共IP，如*图 15.27：*所示。![CD作业日志，显示服务的公共IP地址](img/B17338_15_27.jpg)
- en: 'Figure 15.27: Logs of the CD job showing the public IP address of the service'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.27：CD作业日志，显示服务的公共IP地址
- en: Open a new tab in your web browser to visit your website. You should see an
    output similar to *Figure 15.28:*
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的网页浏览器中打开一个新标签页，访问你的网站。你应该能看到类似于*图 15.28：*的输出。
- en: '![Website running version 1](img/B17338_15_28.jpg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![网站运行版本1](img/B17338_15_28.jpg)'
- en: 'Figure 15.28: Website running version 1'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.28：网站运行版本1
- en: Let's now test the end-to-end pipeline by making a change to the `index.html`
    file. To do this, in GitHub, click on Code at the top of the screen, open `Chapter15`,
    and click on the `index.html` file. In the resulting window, click on the pen
    icon in the top right, as shown in *Figure 15.29:*![Clicking on the pen icon to
    edit the index.html file](img/B17338_15_29.jpg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过修改`index.html`文件来测试端到端的管道。为此，在GitHub中，点击屏幕顶部的Code，打开`Chapter15`，然后点击`index.html`文件。在打开的窗口中，点击右上角的铅笔图标，如*图
    15.29：*所示。![点击铅笔图标编辑index.html文件](img/B17338_15_29.jpg)
- en: 'Figure 15.29: Clicking on the pen icon to edit the index.html file'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.29：点击铅笔图标编辑index.html文件
- en: You can now edit the file. Change the version of the website to `version 2`
    (or any other changes you might want to make), and then scroll to the bottom of
    the screen to save the changes. Click on the Commit changes button to commit the
    changes to GitHub, as shown in *Figure 15.30:*![Saving the changes to the index.html
    file](img/B17338_15_30.jpg)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以编辑文件。将网站的版本更改为`version 2`（或进行其他你可能想要的更改），然后滚动到屏幕底部以保存更改。点击提交更改按钮将更改提交到GitHub，如*图
    15.30：*所示。![保存对index.html文件的更改](img/B17338_15_30.jpg)
- en: 'Figure 15.30: Saving the changes to the index.html file'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.30：保存对index.html文件的更改
- en: This will trigger the workflow to be run. It will run through both the CI and
    CD jobs. This means that a new container will be built, with an updated `index.html`
    file. You can follow the status of the workflow run as you've done before, by
    clicking on Actions at the top of the screen and clicking on the top run. Wait
    until the job has finished, as shown in *Figure 15.31:*![Action run after updating
    index.html](img/B17338_15_31.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将触发工作流运行。它将依次运行CI和CD作业。这意味着一个新容器将被构建，并更新`index.html`文件。你可以像之前一样，通过点击屏幕顶部的Actions并点击顶部的运行条目来跟踪工作流的状态。等待作业完成，如*图
    15.31：*所示。![更新index.html后的操作运行](img/B17338_15_31.jpg)
- en: 'Figure 15.31: Action run after updating index.html'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.31：更新index.html后的操作运行
- en: If you now browse back to the IP address you got as an output of *step 9*, you
    should see the updated webpage showing you Version 2, as shown in *Figure 15.32:*
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在返回到 *第 9 步* 输出的 IP 地址，你应该会看到更新后的网页，显示版本 2，如 *图 15.32：* 所示。
- en: '![The webpage has been updated to version 2](img/B17338_15_32.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![网页已更新为版本 2](img/B17338_15_32.jpg)'
- en: 'Figure 15.32: The web page has been updated to version 2'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.32：网页已更新为版本 2
- en: This has shown you that the pipeline executed successfully and has brought your
    code changes to production.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明流水线成功执行，并将你的代码更改部署到生产环境。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, you updated the production version of your website directly,
    without any approvals. GitHub Actions also allows you to configure manual approvals
    in case you want to test changes before promoting them to production. To configure
    manual approvals, you can use the environments functionality in GitHub Actions.
    For more information, please refer to https://docs.github.com/en/actions/reference/environments.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你直接更新了生产版本的网站，而没有任何审批流程。GitHub Actions 还允许你配置手动审批，以便在将更改推广到生产环境之前进行测试。要配置手动审批，你可以使用
    GitHub Actions 中的环境功能。有关更多信息，请参阅 https://docs.github.com/en/actions/reference/environments。
- en: 'This concludes this example of CI and CD using GitHub Actions. Let''s make
    sure to clean up the resource you created for this chapter. In Cloud Shell, execute
    the following commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的 CI 和 CD 使用 GitHub Actions 也到此结束。让我们确保清理为本章创建的资源。在 Cloud Shell 中执行以下命令：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since this also marks the end of the examples in this book, you can now also
    delete the cluster itself if you do not need it anymore. If you wish to do so,
    you can use the following command to delete the cluster:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这也标志着本书示例的结束，如果你不再需要集群，你现在也可以删除它。如果你想这么做，可以使用以下命令删除集群：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This way, you ensure you aren't paying for the resources if you're no longer
    using them after you've finished the examples in this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以确保在完成本书中的示例后，如果不再使用这些资源，你就不需要为它们支付费用。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You have now successfully created a CI/CD pipeline for your Kubernetes cluster.
    CI is the process of frequently building and testing software, whereas CD is the
    practice of regularly deploying software.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经成功创建了一个 CI/CD 流水线用于 Kubernetes 集群。CI 是频繁构建和测试软件的过程，而 CD 是定期部署软件的实践。
- en: In this chapter, you used GitHub Actions as a platform to build a CI/CD pipeline.
    You started by building the CI pipeline. In that pipeline, you built a container
    image and pushed it to the container registry.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用了 GitHub Actions 作为平台来构建 CI/CD 流水线。你首先构建了 CI 流水线。在该流水线中，你构建了一个容器镜像并将其推送到容器注册中心。
- en: Finally, you also added a CD pipeline to deploy that container image to your
    Kubernetes cluster. You were able to verify that by making code changes to a webpage,
    the pipeline was triggered and code changes were pushed to your cluster.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还添加了一个 CD 流水线，将容器镜像部署到 Kubernetes 集群。你能够通过修改网页代码来验证，当代码更改时，流水线被触发并将代码更改推送到集群中。
- en: The CI/CD pipeline you built in this chapter is a starter pipeline that lays
    the foundation for a more robust CI/CD pipeline that you can use to deploy applications
    to production. You should consider adding more tests to the pipeline and also
    integrate it with different branches before using it in production.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中构建的 CI/CD 流水线是一个入门流水线，为更强大的 CI/CD 流水线奠定基础，后者可用于将应用程序部署到生产环境。在将其投入生产之前，你应该考虑向流水线添加更多的测试，并将其与不同的分支进行集成。
- en: Final thoughts
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的思考
- en: This chapter also concludes this book. During the course of this book, you've
    learned how to work with AKS through a series of hands-on examples.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也标志着本书的结束。在本书的过程中，你通过一系列实践示例学习了如何使用 AKS。
- en: The book started by covering the basics; you learned about containers and Kubernetes
    and you created an AKS cluster.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本书从基础知识开始，你学习了容器和 Kubernetes，并创建了一个 AKS 集群。
- en: The next section focused on application deployment on AKS. You learned different
    ways of deploying applications to AKS, how to scale applications, how to debug
    failures, and how to secure services using HTTPS.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节聚焦于在 AKS 上部署应用程序。你学习了将应用程序部署到 AKS 的不同方式，如何扩展应用程序，如何调试故障，以及如何使用 HTTPS 来保护服务。
- en: The next sections focused on security in AKS. You learned about role-based access
    control in Kubernetes and how you can integrate AKS with Azure Active Directory.
    Then, you learned about pod identities, and pod identities were used in a couple
    of follow-up chapters. After that, you learned how to securely store secrets in
    AKS, and then we focused on network security.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节集中讨论了 AKS 的安全性。你了解了 Kubernetes 中的基于角色的访问控制以及如何将 AKS 与 Azure Active Directory
    集成。随后，你学习了 pod 身份，并且 pod 身份在接下来的几个章节中有应用。之后，你学习了如何在 AKS 中安全存储机密信息，接着我们专注于网络安全。
- en: The final section of this book focused on a number of advanced integrations
    of AKS with other services. You deployed an Azure database through the Kubernetes
    API and integrated it with a WordPress application on your cluster. You then explored
    how to monitor configuration and remediate threats on your cluster using Azure
    Security Center. You then deployed Azure functions on your cluster and scaled
    them using KEDA. In this final chapter, you configured a CI/CD pipeline to automatically
    deploy an application to Kubernetes based on code changes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的最后一部分集中讨论了 AKS 与其他服务的多种高级集成。你通过 Kubernetes API 部署了一个 Azure 数据库，并将其与集群中的 WordPress
    应用集成。接着，你探索了如何使用 Azure Security Center 监控配置并修复集群中的威胁。然后，你在集群中部署了 Azure Functions，并通过
    KEDA 进行扩展。在最后一章中，你配置了一个 CI/CD 管道，基于代码更改自动将应用部署到 Kubernetes。
- en: If you've successfully completed all the examples provided in this book, you
    should now be ready to build and run applications at scale on top of AKS.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经成功完成了本书中提供的所有示例，那么你现在应该已经准备好在 AKS 上构建和运行大规模应用。
