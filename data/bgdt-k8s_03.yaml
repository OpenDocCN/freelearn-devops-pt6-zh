- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Getting Hands-On with Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亲自实践 Kubernetes
- en: In this chapter, we will get hands-on experience with Kubernetes by deploying
    both a local and cloud-based Kubernetes cluster, and then deploying sample applications
    into those clusters. First, you will deploy a local cluster using **Kubernetes
    in Docker** (**Kind**). Then, you will deploy managed Kubernetes clusters on AWS,
    GCP, and Azure. For the cloud options, we will provide the minimal account setup
    required to deploy the clusters. Feel free to choose the cloud provider you are
    most comfortable with; the core Kubernetes functionality will be the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过部署本地和云端 Kubernetes 集群来实践 Kubernetes，并将示例应用程序部署到这些集群中。首先，你将使用 **Kubernetes
    in Docker**（**Kind**）部署一个本地集群。接着，你将部署在 AWS、GCP 和 Azure 上的托管 Kubernetes 集群。对于云选项，我们将提供部署集群所需的最基本账户设置。你可以自由选择你最熟悉的云服务提供商；核心的
    Kubernetes 功能是相同的。
- en: After deploying a cluster, this chapter will be divided into two parts. In the
    first part, you will take the simple API application you developed in [*Chapter
    1*](B21927_01.xhtml#_idTextAnchor015) and deploy it into your Kubernetes cluster.
    You will learn how to containerize applications and work with Kubernetes deployments
    and services to expose your application. In the second part, you will deploy the
    simple data processing batch job from *Chapter 1* into Kubernetes. This will demonstrate
    how to run one-off jobs using Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 部署集群后，本章将分为两部分。第一部分，你将把在 [*第 1 章*](B21927_01.xhtml#_idTextAnchor015) 中开发的简单
    API 应用程序部署到 Kubernetes 集群中。你将学习如何将应用程序容器化，并与 Kubernetes 部署和服务一起工作，暴露你的应用程序。第二部分，你将把
    *第 1 章* 中的简单数据处理批处理任务部署到 Kubernetes。这将演示如何使用 Kubernetes 运行一次性任务。
- en: By the end of this chapter, you will have first-hand experience deploying applications
    into Kubernetes. You will understand how to package and deploy containerized applications,
    expose them via services and ingress, and leverage Kubernetes for running both
    long-running services and batch jobs. With these skills, you will be ready to
    deploy applications into production Kubernetes environments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有亲自将应用程序部署到 Kubernetes 的经验。你将理解如何打包和部署容器化应用程序，如何通过服务和入口暴露它们，并利用 Kubernetes
    运行长期服务和批处理任务。有了这些技能，你将准备好将应用程序部署到生产 Kubernetes 环境中。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Installing `kubectl`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `kubectl`
- en: Deploying a local K8s cluster with Kind
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kind 部署本地 K8s 集群
- en: Deploying an AWS EKS cluster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 AWS EKS 集群
- en: Deploying a Google Cloud GKE cluster
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 Google Cloud GKE 集群
- en: Deploying an Azure AKS cluster
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 Azure AKS 集群
- en: Running your API on Kubernetes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行你的 API
- en: Running a data processing job in Kubernetes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行数据处理任务
- en: Let’s get to it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you will be required to have Docker installed (the instructions
    for this can be found in [*Chapter 1*](B21927_01.xhtml#_idTextAnchor015)). The
    main hands-on activities we are going to do will be cloud-based, but you can choose
    to do them locally with Kind. You will learn how to deploy a Kubernetes cluster
    locally using Kind or in the cloud (AWS, Google Cloud, and Azure) in this chapter.
    Finally, you will need `kubectl` to interact with your Kubernetes cluster. You’ll
    learn how to install it in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要安装 Docker（安装说明请参考 [*第 1 章*](B21927_01.xhtml#_idTextAnchor015)）。我们将进行的主要实践活动是基于云的，但你也可以选择使用
    Kind 在本地完成这些活动。在本章中，你将学习如何使用 Kind 或在云端（AWS、Google Cloud 和 Azure）部署 Kubernetes
    集群。最后，你需要安装 `kubectl` 来与 Kubernetes 集群进行交互。在下一节中，你将学习如何安装它。
- en: Installing kubectl
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 kubectl
- en: '`kubectl` is a CLI that we are going to use to send commands to a Kubernetes
    cluster. You must have this installed so that you can interact with the cluster
    (regardless of whether it’s running locally or in the cloud):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是我们将用来向 Kubernetes 集群发送命令的命令行工具。你必须安装它，才能与集群进行交互（无论集群是本地运行还是在云端）：'
- en: 'To install `kubectl` on macOS with Homebrew, use the following command:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在 macOS 上使用 Homebrew 安装 `kubectl`，请使用以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install `kubectl` in a Linux distribution, you can use `curl` to download
    the binary executable:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在 Linux 发行版上安装 `kubectl`，你可以使用 `curl` 下载二进制可执行文件：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To install it in a Windows system, you can use the `chocolatey` package manager:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在 Windows 系统上安装它，你可以使用 `chocolatey` 包管理器：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From this point on, every `kubectl` command will be the same, regardless of
    the OS you’re using. To check if the installation went successfully, run the following
    command. This will give you a nice, formatted view of the version of `kubectl`
    that’s running on your system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从此以后，每个 `kubectl` 命令都是相同的，无论你使用的是哪个操作系统。要检查安装是否成功，运行以下命令。这将为你提供 `kubectl` 版本的格式化视图，显示你系统上正在运行的版本：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let’s move and install `kind`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续安装 `kind`。
- en: Deploying a local cluster using Kind
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kind 部署本地集群
- en: Deploying a local Kubernetes cluster can be extremely helpful for learning,
    testing, and preparing deployments for a production environment as Kubernetes
    is the same, wherever you run it. Let’s start by deploying a single-node local
    cluster using Kind.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 部署本地 Kubernetes 集群对学习、测试和准备生产环境的部署非常有帮助，因为 Kubernetes 在任何运行环境下都是相同的。让我们从使用 Kind
    部署一个单节点本地集群开始。
- en: Installing kind
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 kind
- en: Kind is a tool that allows you to run Kubernetes on your local machine inside
    Docker containers. Besides being light and easy to set up, Kind delivers performance
    with the same Kubernetes standards. Kind clusters pass upstream Kubernetes conformance
    testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kind 是一个允许你在本地机器上通过 Docker 容器运行 Kubernetes 的工具。除了轻便和易于设置外，Kind 还能提供符合 Kubernetes
    标准的性能。Kind 集群通过了 Kubernetes 上游兼容性测试。
- en: 'Kind is distributed as a single binary file. You can install it easily with
    package managers (make sure you have Docker already installed):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kind 作为一个单一的二进制文件分发。你可以通过包管理器轻松安装它（确保你已经安装了 Docker）：
- en: 'If you’re using macOS, use Homebrew to install `kind`, like so:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 macOS，可以通过 Homebrew 安装 `kind`，方法如下：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you’re using a Linux distribution (Ubuntu, for instance), you can install
    it with `curl`:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux 发行版（例如 Ubuntu），你可以通过 `curl` 安装它：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you’re using a Windows system, install it with `chocolatey` ([https://chocolatey.org/packages/kind):](https://chocolatey.org/packages/kind):)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows 系统，可以通过 `chocolatey` 安装它（[https://chocolatey.org/packages/kind](https://chocolatey.org/packages/kind)）：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the installation is finished, you can check if it was installed correctly
    by running the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过运行以下命令来检查是否安装成功：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Deploying the cluster
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署集群
- en: 'Now, to deploy a single-node local cluster, just run the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要部署一个单节点本地集群，只需运行以下命令：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If this is the first time you’ve run this command, Kind will download the control
    plane image, create a Docker container for it, and configure a single-node Kubernetes
    cluster for you. The first time it runs, Kind will take 1-2 minutes to complete
    as it downloads the Kubernetes image. The next runs will be much faster.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次运行这个命令，Kind 会下载控制平面镜像，为它创建一个 Docker 容器，并为你配置一个单节点的 Kubernetes 集群。第一次运行时，由于要下载
    Kubernetes 镜像，Kind 需要 1-2 分钟才能完成。之后的运行会快得多。
- en: 'To verify that the cluster is up, run the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证集群是否已启动，运行以下命令：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will print connection details for the local cluster. And, that’s it! You’re
    good to go.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印本地集群的连接详情。就这样！你准备好了，可以开始了。
- en: If you’re willing to work with a cloud-based Kubernetes cluster, in the next
    few sections, we will deploy a cluster on AWS, Google Cloud, and Azure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意使用基于云的 Kubernetes 集群，在接下来的几节中，我们将部署一个 AWS、Google Cloud 和 Azure 上的集群。
- en: Deploying an AWS EKS cluster
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 AWS EKS 集群
- en: '`kubectl` to manage worker nodes.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 管理工作节点。
- en: To get started with EKS, you need an AWS account. Go to [http://aws.amazon.com](http://aws.amazon.com)
    and click **Create an AWS account**. Follow the steps to sign up for a new account;
    note that you will be requested to provide your credit card information. AWS offers
    a free usage tier that provides limited resources at no charge for 12 months.
    This is usually sufficient to run small workloads but not Kubernetes (although
    costs will not be high if you manage it wisely). AWS charges 73 dollars per month
    for every running cluster (assuming that the cluster is running for the whole
    month; if it runs just for a couple of days or hours, billing should be a fraction
    of that accordingly) plus the proper charging for each node that is running according
    to the size of the chosen machines.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用EKS，您需要一个AWS账户。请访问[http://aws.amazon.com](http://aws.amazon.com)并点击**创建AWS账户**。按照步骤注册新账户；请注意，您需要提供信用卡信息。AWS提供免费的使用层，提供有限的资源，在12个月内无需付费。通常这足以运行小型工作负载，但不适用于Kubernetes（尽管如果管理得当，费用不会很高）。AWS每月对每个运行的集群收费73美元（假设集群运行整个月；如果只运行几天或几小时，计费将相应按比例减少），并且按所选机器的大小为每个节点收取相应费用。
- en: 'After setting up the account, you must access it with your `root` user. We
    need to create an IAM user with specific permissions as this is the recommended
    usage. In the AWS console, go to the **IAM** service and click **Users** in the
    left panel. You should see a screen like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设置账户后，您必须使用`root`用户访问它。我们需要创建一个具有特定权限的IAM用户，因为这是推荐的使用方法。在AWS控制台中，进入**IAM**服务，并点击左侧面板中的**用户**。您应该看到如下屏幕：
- en: '![Figure 3.1 – The Users menu in IAM](img/B21927_03_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – IAM中的用户菜单](img/B21927_03_01.jpg)'
- en: Figure 3.1 – The Users menu in IAM
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – IAM中的用户菜单
- en: Then, define the username and password for access. When you click **Next**,
    choose to attach policies directly (since this is only a study account – this
    configuration is not suited for a production environment). Choose **AdministratorAccess**
    from the list (which will permit you to do everything in AWS) and click **Next**
    to review. Then, click the **Create user** button to finish the process. When
    all is set, remember to download the AWS secrets (AWS access key ID and AWS secret
    access key). You will need these secrets to authenticate in AWS from your computer.
    Now, log off the console and access it again with your new IAM user to validate
    that your new IAM user has been configured correctly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义访问的用户名和密码。当您点击**下一步**时，选择直接附加策略（由于这是一个学习账户——此配置不适合生产环境）。从列表中选择**AdministratorAccess**（这将允许您在AWS中做任何事情），然后点击**下一步**进行审查。接着，点击**创建用户**按钮完成该过程。设置完成后，记得下载AWS密钥（AWS访问密钥ID和AWS秘密访问密钥）。您需要这些密钥才能从您的计算机在AWS中进行身份验证。现在，注销控制台并使用新IAM用户重新登录，验证您的新IAM用户是否已正确配置。
- en: 'Before we look at the tools for setting up a Kubernetes cluster, we need to
    install the AWS CLI to interact with AWS from our local terminal. To do so, type
    the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设置Kubernetes集群的工具之前，需要安装AWS CLI以便从本地终端与AWS进行交互。为此，请输入以下命令：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After installed, now we run aws configure to set up our AWS credentials:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们运行`aws configure`来设置我们的AWS凭证：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will be prompted for your AWS credentials (AWS Access Key ID and AWS Secret
    Access Key). Copy and paste those credentials as you are asked for them. Then,
    the configuration will ask for the default AWS region. You can work in us-east-1\.
    For the output format, `json` is a good choice.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入您的AWS凭证（AWS访问密钥ID和AWS秘密访问密钥）。根据提示复制并粘贴这些凭证。然后，配置会要求您选择默认的AWS区域。您可以选择`us-east-1`。对于输出格式，`json`是一个不错的选择。
- en: This will save a config file with your credentials at `~/.aws/credentials`.
    Now, you can run AWS CLI commands to interact with AWS services.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把您的凭证保存为配置文件`~/.aws/credentials`。现在，您可以运行AWS CLI命令与AWS服务进行交互。
- en: Once you have an AWS account and your IAM user and the AWS CLI have been configured,
    install the `eksctl` command-line tool. This tool simplifies and automates the
    process of deploying EKS clusters. Go to [https://eksctl.io/installation/](https://eksctl.io/installation/)
    and follow the installation instructions. Note that the documentation page lists
    the permissions you should have to deploy a cluster with `eksctl`. The **AdministratorAccess**
    policy should englobe any of the permissions you need.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 AWS 账户并配置了 IAM 用户及 AWS CLI，安装 `eksctl` 命令行工具。此工具简化并自动化了部署 EKS 集群的过程。请访问
    [https://eksctl.io/installation/](https://eksctl.io/installation/) 并按照安装说明操作。注意，文档页面列出了你部署集群所需的权限。**AdministratorAccess**
    策略应包括你需要的所有权限。
- en: 'After the installation, to check if `eksctl` has been set up correctly, run
    the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，检查 `eksctl` 是否正确设置，可以运行以下命令：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see some output showing the version. Now, let’s create a cluster
    from scratch with a single command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到一些显示版本的输出。现在，让我们通过一个命令从零开始创建一个集群：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The base of this command is `eksctl create cluster`. From the second line on,
    we are stating some options. Let’s look at them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的基础是 `eksctl create cluster`。从第二行开始，我们正在陈述一些选项。让我们来看看它们：
- en: The `--managed` option tells `eksctl` to create a fully managed cluster. It
    will handle creating the EKS control plane, node groups, networking, and more.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--managed` 选项告诉 `eksctl` 创建一个完全托管的集群。它将处理 EKS 控制平面、节点组、网络等的创建。'
- en: The `--alb-ingress-access` option will configure the cluster to allow inbound
    traffic from load balancers. This is required for load balancer type services.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--alb-ingress-access` 选项将配置集群，允许来自负载均衡器的入站流量。这是负载均衡器类型服务所必需的。'
- en: The `--node-private-networking` option enables private networking between worker
    nodes. Nodes will have private IP addresses only.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--node-private-networking` 选项启用工作节点之间的私有网络连接。节点将仅拥有私有 IP 地址。'
- en: The `--full-ecr-access` option gives worker nodes full access to ECR container
    image repositories. This is needed to pull container images.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--full-ecr-access` 选项为工作节点提供对 ECR 容器镜像库的完全访问权限。这是拉取容器镜像所需的。'
- en: The `--name` option sets a user-defined name for the cluster.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name` 选项为集群设置一个用户定义的名称。'
- en: The `--instance-type` option configures the instance type that will be used
    for worker nodes. In this case, we are choosing to use the `m6i.xlarge` EC2 instance.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--instance-type` 选项配置用于工作节点的实例类型。在这种情况下，我们选择使用 `m6i.xlarge` EC2 实例。'
- en: The `--region` option sets the AWS region – in this case, N. Virginia (us-east-1).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--region` 选项设置 AWS 区域——在本例中为北弗吉尼亚（us-east-1）。'
- en: The `--nodes-min` and `--nodes-max` options set an autoscaling rule for the
    node group. Here, we set the minimum to `2` instances and the maximum to `4` instances.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--nodes-min` 和 `--nodes-max` 选项为节点组设置自动扩缩规则。在这里，我们将最小节点数设置为 `2` 个实例，最大节点数设置为
    `4` 个实例。'
- en: The `--nodegroup` option sets the node group’s name to `ng-studycluster`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--nodegroup` 选项将节点组的名称设置为 `ng-studycluster`。'
- en: This will take around 10-15 minutes to complete. `eksctl` handles all the details
    of creating VPCs, subnets, security groups, IAM policies, and other AWS resources
    needed to run an EKS cluster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将大约需要 10-15 分钟来完成。`eksctl` 处理创建 VPC、子网、安全组、IAM 策略以及运行 EKS 集群所需的其他 AWS 资源的所有细节。
- en: Under the hood, `eksctl` uses CloudFormation to provision the AWS infrastructure.
    The `eksctl` command generates a CloudFormation template based on the parameters
    provided. It then deploys this template to create the necessary resources.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，`eksctl` 使用 CloudFormation 来配置 AWS 基础设施。`eksctl` 命令根据提供的参数生成一个 CloudFormation
    模板，然后将此模板部署，以创建所需的资源。
- en: 'The following are some key components that are created by `eksctl`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些由 `eksctl` 创建的关键组件：
- en: '**Virtual private cloud (VPC)**: A VPC network where your cluster resources
    will run. This includes public and private subnets across multiple availability
    zones'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟私有云（VPC）**：一个 VPC 网络，您的集群资源将在其中运行。这包括跨多个可用区的公有和私有子网。'
- en: '**EKS cluster**: The Kubernetes control plane, which consists of the API server,
    etcd, controller manager, scheduler, and more. AWS operates and manages this'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EKS 集群**：Kubernetes 控制平面，包括 API 服务器、etcd、控制器管理器、调度器等。由 AWS 运营和管理。'
- en: '**Worker node groups**: Managed node groups containing EC2 instances that will
    run your Kubernetes workloads'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作节点组**：包含将运行 Kubernetes 工作负载的 EC2 实例的托管节点组。'
- en: '**Security groups**: Firewall rules to control access to the cluster'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全组**：控制集群访问的防火墙规则。'
- en: '**IAM roles and policies**: Access policies to allow worker nodes and Kubernetes
    to access AWS APIs and resources'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IAM 角色和策略**：访问策略，允许工作节点和 Kubernetes 访问 AWS API 和资源'
- en: 'Once the `eksctl` command completes, your EKS cluster will be ready to use.
    You can view details about the cluster by running the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`eksctl`命令完成，您的 EKS 集群就可以使用了。您可以通过运行以下命令来查看集群的详细信息：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we are going to create a Kubernetes cluster using Google Cloud.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Google Cloud 创建一个 Kubernetes 集群。
- en: Deploying a Google Cloud GKE cluster
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个 Google Cloud GKE 集群
- en: To deploy a Kubernetes cluster on Google Cloud, we need to set up a Google Cloud
    account and install the `gcloud` **command-line interface** (**CLI**). To do that,
    go to [https://cloud.google.com/](https://cloud.google.com/) and click on **Start
    free** to create a new account. Follow the instructions and, when your new account
    is created, navigate to the console at [https://console.cloud.google.com/](https://console.cloud.google.com/).
    This is where you can manage all your Google Cloud resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Google Cloud 上部署一个 Kubernetes 集群，我们需要设置一个 Google Cloud 账户并安装`gcloud` **命令行接口**（**CLI**）。为此，请访问
    [https://cloud.google.com/](https://cloud.google.com/)，点击**开始免费**以创建一个新账户。按照指示操作，当您的新账户创建完成后，进入
    [https://console.cloud.google.com/](https://console.cloud.google.com/) 控制台。在这里，您可以管理所有的
    Google Cloud 资源。
- en: Before we can deploy a GKE cluster, we need to enable the necessary APIs. Click
    on the navigation menu icon in the top left and go to `Kubernetes Engine API`
    and click on it. Make sure it is enabled. It is also a good practice to enable
    `gcloud` CLI. This will allow us to manage Google Cloud resources from the command
    line.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署 GKE 集群之前，我们需要启用必要的 API。在左上角点击导航菜单图标，进入`Kubernetes Engine API`并点击它。确保它已启用。启用`gcloud`
    CLI 也是一个好的实践，这将使我们能够通过命令行管理 Google Cloud 资源。
- en: 'The `gcloud` CLI can be installed on Linux, macOS, and Windows. In a Linux
    distribution, you can download the installation script like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcloud` CLI 可以安装在 Linux、macOS 和 Windows 上。在 Linux 发行版中，您可以通过以下方式下载安装脚本：'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, extract the archive:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，解压缩存档：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, run the install script:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行安装脚本：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For a macOS installation, you can use Homebrew:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 安装，您可以使用 Homebrew：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For Windows, you can download the `gcloud` installer from [https://cloud.google.com/sdk/docs/install#windows](https://cloud.google.com/sdk/docs/install#windows).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，您可以从 [https://cloud.google.com/sdk/docs/install#windows](https://cloud.google.com/sdk/docs/install#windows)
    下载`gcloud`安装程序。
- en: 'Once the installation is done, you can check it by running the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过运行以下命令来检查：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you’ve installed it, you must initiate the CLI:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您必须初始化 CLI：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will walk you through logging in with your Google account and configuring
    `gcloud`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将指导您使用 Google 账户登录并配置`gcloud`。
- en: 'Now that `gcloud` is installed and initialized, we can deploy a Kubernetes
    cluster on GKE. First, choose a Google Cloud project to deploy the cluster under.
    You can create a new project and set it as active like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`gcloud`已经安装并初始化完毕，我们可以在 GKE 上部署 Kubernetes 集群。首先，选择一个 Google Cloud 项目来部署该集群。您可以创建一个新项目并将其设置为活动项目，如下所示：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, you must set a compute zone to deploy the cluster in. Here, we will work
    in the `us-central1-a` zone:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须设置一个计算区域来部署集群。在这里，我们将在`us-central1-a`区域进行操作：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can deploy a Kubernetes cluster by running the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行以下命令来部署一个 Kubernetes 集群：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `–num-nodes` parameter controls how many nodes you are going to be deployed.
    Note that this will take several minutes to complete as Google Cloud will set
    up all the cluster components, networking, and so on. Once deployed, gather credentials
    to interact with the cluster:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`–num-nodes`参数控制将要部署的节点数量。请注意，这个过程需要几分钟时间，因为 Google Cloud 会设置所有集群组件、网络等。部署完成后，收集凭证以便与集群进行交互：'
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will save credentials to your Kubernetes config file. Finally, you can
    verify that you can connect to the cluster by running the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把凭证保存到您的 Kubernetes 配置文件中。最后，您可以通过运行以下命令来验证是否可以连接到集群：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should see information about the Kubernetes master and the cloud provider.
    And that’s it! You now have a fully functional Kubernetes cluster running on Google
    Cloud.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到有关 Kubernetes 主节点和云提供商的信息。就这样！您现在已经在 Google Cloud 上运行了一个完全功能的 Kubernetes
    集群。
- en: Next, we will do the same with Microsoft Azure Cloud.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用微软的 Azure 云执行相同的操作。
- en: Deploying an Azure AKS cluster
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个 Azure AKS 集群
- en: In this section, we will walk through the steps to deploy a Kubernetes cluster
    using **Azure Kubernetes Service** (**AKS**). To get started with AKS, you need
    an Azure account. First, go to [https://azure.com](https://azure.com), click **Try
    Azure for free**, and then click **Start free**. This will allow you to start
    a free trial account on Azure. You will need to provide some basic information,
    such as your email and phone number, to set up the account. Make sure you use
    a valid email as Azure will send a verification code to complete the signup process.
    Once your account has been created, you will be directed to the Azure portal.
    This is the main dashboard for managing all your Azure resources.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何使用 **Azure Kubernetes 服务**（**AKS**）部署 Kubernetes 集群的步骤。要开始使用 AKS，你需要一个
    Azure 账户。首先，访问 [https://azure.com](https://azure.com)，点击 **免费试用 Azure**，然后点击 **开始免费试用**。这样你就可以在
    Azure 上开始免费的试用账户了。你需要提供一些基本信息，如你的电子邮件和电话号码，以完成账户设置。确保使用有效的电子邮件地址，因为 Azure 会发送验证码来完成注册过程。账户创建完成后，你将进入
    Azure 门户。这是用于管理你所有 Azure 资源的主面板。
- en: At this point, it’s recommended to install the Azure CLI on your local machine.
    The Azure CLI allows you to manage Azure resources from the command line. Follow
    the instructions at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)
    to install it on Linux, macOS, or Windows.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，建议在本地机器上安装 Azure CLI。Azure CLI 允许你通过命令行管理 Azure 资源。请按照 [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)
    上的说明，在 Linux、macOS 或 Windows 上安装它。
- en: After installing the CLI, run `az login` and follow the prompts to authenticate
    with your account. This will allow you to run Azure commands from your terminal.
    With the Azure account set up and the CLI installed, you are ready to deploy an
    AKS cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 CLI 后，运行 `az login` 并按照提示进行身份验证。这样你就可以从终端运行 Azure 命令了。设置好 Azure 账户并安装好 CLI
    后，你就可以准备部署 AKS 集群了。
- en: 'The first thing you must do is create a resource group. Resource groups in
    Azure allow you to logically group resources such as AKS clusters, storage accounts,
    virtual networks, and more. Let’s start by creating a resource group for our AKS
    cluster:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须创建一个资源组。Azure 中的资源组允许你将 AKS 集群、存储账户、虚拟网络等资源逻辑地分组。让我们从为 AKS 集群创建一个资源组开始：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will create a resource group named `myResourceGroup` in the `eastus` region.
    You can specify any region close to you. Now, we can create an AKS cluster in
    this resource group. The basic command to create a cluster is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在 `eastus` 区域创建一个名为 `myResourceGroup` 的资源组。你可以指定任何靠近你的区域。现在，我们可以在这个资源组中创建
    AKS 集群。创建集群的基本命令如下：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will create a Kubernetes cluster named `studycluster` with two nodes.
    We generate SSH keys automatically to set up access to the nodes. Some other options
    you can specify are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会创建一个名为 `studycluster` 的 Kubernetes 集群，包含两个节点。我们会自动生成 SSH 密钥以设置访问节点的权限。你还可以指定一些其他选项，如下所示：
- en: '`--node-vm-size`: The size of the virtual machines for nodes. The default is
    `Standard_D2s_v3`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--node-vm-size`：节点虚拟机的大小。默认为 `Standard_D2s_v3`。'
- en: '`--kubernetes-version`: The Kubernetes version to use for the cluster. It defaults
    to the latest version.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--kubernetes-version`：要用于集群的 Kubernetes 版本。默认为最新版本。'
- en: '`--enable-addons`: Enables add-ons such as monitoring, virtual nodes, and more.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--enable-addons`：启用附加功能，如监控、虚拟节点等。'
- en: The `az aks create` command handles setting up the Kubernetes cluster, virtual
    machines, networking, storage, and more automatically. The process may take 5-10
    minutes to complete.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`az aks create` 命令会自动处理 Kubernetes 集群、虚拟机、网络、存储等的设置。该过程可能需要 5-10 分钟才能完成。'
- en: 'When it is done, you can connect to the cluster by running the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以通过运行以下命令连接到集群：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will display the nodes that are part of your AKS cluster. At this point,
    you have successfully deployed an AKS cluster and are ready to deploy our API
    and batch processing job on it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示属于你的 AKS 集群的节点。到此为止，你已经成功部署了 AKS 集群，并准备在其上部署我们的 API 和批处理任务。
- en: Running your API on Kubernetes
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行你的 API
- en: From this point, you can choose the Kubernetes deployment type you like the
    most (local or cloud-based) to run our API. The following examples will be shown
    with AWS but you also can choose another cloud provider. Feel free to do so.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你可以选择你最喜欢的 Kubernetes 部署类型（本地或基于云的）来运行我们的 API。以下示例将使用 AWS，但你也可以选择其他云提供商。随意选择。
- en: Now, it is time to retake the API we built in [*Chapter 1*](B21927_01.xhtml#_idTextAnchor015)
    and ship it to production. We developed a simple API that, when requested, can
    say hello to you or answer with a (very cool) joke.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了重拾我们在 [*第1章*](B21927_01.xhtml#_idTextAnchor015) 中构建的 API 并将其推向生产环境的时候了。我们开发了一个简单的
    API，当你请求时，它可以向你打招呼或回答一个（非常酷的）笑话。
- en: We already have the code for the API ([https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/app/main.py](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/app/main.py))
    and the Dockerfile to build the container image ([https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了 API 的代码（[https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/app/main.py](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/app/main.py)）以及构建容器镜像的
    Dockerfile（[https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile)）。
- en: 'For the image to be accessible to Kubernetes, it should be available on a container
    registry. Each cloud provider has a registry but to make things simple, we are
    working with DockerHub ([https://hub.docker.com/](https://hub.docker.com/)). So
    long as your images are public, you can store as many images as you want for free.
    Let’s get started:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Kubernetes 能够访问镜像，它应该在容器注册表中可用。每个云服务提供商都有一个注册表，但为了简化起见，我们使用 DockerHub（[https://hub.docker.com/](https://hub.docker.com/)）。只要你的镜像是公开的，你可以免费存储任意数量的镜像。让我们开始吧：
- en: 'To get started, in your terminal, type the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，请在终端中输入以下命令：
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Remember to replace `<USERNAME>` with your real DockerHub username. We are
    changing the image name to `jokeapi` so that it’s easier to locate. If you’re
    running Docker on a Mac M1, it is important to set the `--platform` parameter
    to make the container image compatible with AMD64 machines. To do so, run the
    following command:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得将 `<USERNAME>` 替换为你的真实 DockerHub 用户名。我们将镜像名称更改为 `jokeapi`，以便更容易找到。如果你在 Mac
    M1 上运行 Docker，那么设置 `--platform` 参数非常重要，以使容器镜像与 AMD64 机器兼容。为此，运行以下命令：
- en: '[PRE30]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can push the image to DockerHub:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将镜像推送到 DockerHub：
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Go to [https://hub.docker.com/](https://hub.docker.com/) and log in. You should
    see your image listed in the **Repositories** section.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://hub.docker.com/](https://hub.docker.com/) 并登录。你应该会在 **Repositories**
    部分看到你的镜像。
- en: Now, the image is available for Kubernetes. Next, we need to define some Kubernetes
    resources to run our API. We will create a deployment and a service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，镜像已可用于 Kubernetes。接下来，我们需要定义一些 Kubernetes 资源来运行我们的 API。我们将创建一个部署和一个服务。
- en: Creating the deployment
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建部署
- en: 'Follow these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'First, we’ll create the deployment. This specifies how many Pod replicas to
    run and their configuration:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建部署。这指定了要运行的 Pod 副本数量以及它们的配置：
- en: '**deployment_api.yaml**'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**deployment_api.yaml**'
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will run two Pod replicas using the Docker image we built. Note that we
    are opening port `8087` in the container. This is similar to the `EXPOSE` command
    in the Dockerfile.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使用我们构建的 Docker 镜像运行两个 Pod 副本。请注意，我们正在容器中打开端口 `8087`。这与 Dockerfile 中的 `EXPOSE`
    命令类似。
- en: 'Next, we will create a namespace to separate and organize our resources and
    apply the deployment:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个命名空间来分隔和组织我们的资源，并应用部署：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will create the deployment and the two Pod replicas in the `jokeapi` namespace.
    We can check that everything is working by running the following command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建部署并在 `jokeapi` 命名空间中创建两个 Pod 副本。我们可以通过运行以下命令检查一切是否正常：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see the following output:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到以下输出：
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s check if the Pods are running properly:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查 Pods 是否正常运行：
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should see an output like this:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到类似如下的输出：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating a service
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个服务
- en: 'Follow these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Here, we’ll specify a service to expose the Pods in the cluster:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将指定一个服务，以便在集群中暴露 Pods：
- en: '**service_api.yaml**'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**service_api.yaml**'
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This creates a ClusterIP service that exposes the API Pods on an internal IP
    address in the cluster. Note that the `type` parameter is not specified within
    the `spec` section of the YAML file, so, it defaults to ClusterIP.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个 ClusterIP 服务，在集群的内部 IP 地址上暴露 API Pods。请注意，`spec` 部分没有指定 `type` 参数，因此默认为
    ClusterIP。
- en: 'To make the API accessible externally, we can create a load balancer (not possible
    with a local `kind` cluster, only with cloud-based clusters):'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使 API 可供外部访问，我们可以创建一个负载均衡器（这在本地 `kind` 集群中不可行，只能在云基础集群中实现）：
- en: '**lb_api.yaml**'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**lb_api.yaml**'
- en: '[PRE39]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, the `type` definition is set and this code will define a load balancer
    and assign an external IP. Next, we will deploy the load balancer service:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`type` 定义已设置，这段代码将定义一个负载均衡器并分配一个外部 IP。接下来，我们将部署负载均衡器服务：
- en: '[PRE40]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we can test if the API is accessible. First, we must get the load balancer’s
    URL (here, we are working in AWS) by running the following command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以测试 API 是否可访问。首先，我们必须通过运行以下命令来获取负载均衡器的 URL（在这里，我们使用的是 AWS）：
- en: '[PRE41]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should see the following output:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Copy the content under `EXTERNAL-IP`, paste the URL in a browser, and add `/joke`.
    For instance, in my implementation here, I got `ab1cdd20ce1a349bab9af992211be654-1566834308.us-east-1.elb.amazonaws.com/joke`.
    You should see the following response on your screen:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `EXTERNAL-IP` 下的内容，将 URL 粘贴到浏览器中，并添加 `/joke`。例如，在我的实现中，我得到了 `ab1cdd20ce1a349bab9af992211be654-1566834308.us-east-1.elb.amazonaws.com/joke`。你应该能看到屏幕上的以下响应：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Success! We have a (great) joke in our browser! Now, we will deploy the API
    with an ingress instead of a load balancer (for cloud-based clusters only).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们在浏览器中看到（一个很棒的）笑话！现在，我们将使用 ingress 来部署 API，而不是负载均衡器（仅限云端集群）。
- en: Using an ingress to access the API
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ingress 访问 API
- en: 'For this deployment, we will use the NGINX ingress controller and connect it
    to the load Balancer provided by AWS (the process is very similar if you are working
    with any cloud provider). Follow these steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次部署，我们将使用 NGINX ingress 控制器，并将其连接到 AWS 提供的负载均衡器（如果你使用其他云提供商，过程非常相似）。请按以下步骤操作：
- en: 'First, we’ll create a new namespace for NGINX and deploy the controller on
    Kubernetes:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为 NGINX 创建一个新的命名空间，并在 Kubernetes 上部署控制器：
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will deploy the NGINX controller using the official manifests. Now, we
    have to edit one line in the deployment to make sure it uses the load balancer
    as an ingress deployment and not `NodePort`, its default. In your terminal, type
    the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将使用官方清单部署 NGINX 控制器。现在，我们必须在部署中编辑一行，确保它使用负载均衡器作为 ingress 部署，而不是默认的 `NodePort`。在终端中输入以下内容：
- en: '[PRE45]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Search for the `spec.type` field and change its value to `LoadBalancer`.After
    saving the file, let’s check the services that have been deployed with the controller:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `spec.type` 字段并将其值更改为 `LoadBalancer`。保存文件后，让我们检查已部署的服务：
- en: '[PRE46]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will see that the `ingress-nginx-controller` service is set to `LoadBalancer`
    and has an external IP related to it. Now, it is easy to set up an ingress that
    points to this ingress controller. First, we’ll create a service defined in the
    `service_api.yaml` file. This service should be set to a ClusterIP type (see the
    code in the previous section). Then, we can define an ingress with the following
    code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到 `ingress-nginx-controller` 服务被设置为 `LoadBalancer` 并且有一个与之相关的外部 IP 地址。现在，设置指向这个
    ingress 控制器的 ingress 变得简单了。首先，我们将在 `service_api.yaml` 文件中创建一个定义好的服务。这个服务应该设置为
    ClusterIP 类型（请参见上一节中的代码）。然后，我们可以用以下代码定义一个 ingress：
- en: '**ingress.yaml**'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**ingress.yaml**'
- en: '[PRE47]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This ingress will route external traffic to the internal service IP. Once the
    ingress has an external IP assigned, we should be able to access our API by hitting
    that URL. Type the following
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 ingress 会将外部流量路由到内部服务 IP。当 ingress 获得外部 IP 后，我们应该能够通过访问该 URL 来访问我们的 API。输入以下内容：
- en: '[PRE48]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Get the external URL for the controller and add `/joke` to it:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取控制器的外部 URL 并在其后添加 `/joke`：
- en: '[PRE49]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Et voilà! In the next section, we will deploy our data processing job on Kubernetes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！在下一节中，我们将在 Kubernetes 上部署我们的数据处理任务。
- en: Running a data processing job in Kubernetes
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中运行数据处理任务
- en: In this section, we will deploy the simple data processing job from [*Chapter
    1*](B21927_01.xhtml#_idTextAnchor015) on Kubernetes. We have already developed
    the job ([https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/run.py](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/run.py))
    and built a Dockerfile to package it into a container image ([https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile_job](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile_job)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将在 Kubernetes 上部署来自 [*第 1 章*](B21927_01.xhtml#_idTextAnchor015) 的简单数据处理任务。我们已经开发了这个任务（[https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/run.py](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/run.py)）并且编写了一个
    Dockerfile，将其打包为容器镜像（[https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile_job](https://github.com/PacktPublishing/Bigdata-on-Kubernetes/blob/main/Chapter01/Dockerfile_job)）。
- en: Now, we have to build a Docker image and push it to a repository that’s accessible
    to Kubernetes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须构建一个 Docker 镜像并将其推送到 Kubernetes 可访问的仓库。
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can create a Kubernetes job to run our data processing task. Here’s
    an example job manifest:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 Kubernetes 作业来运行我们的数据处理任务。以下是一个示例作业清单：
- en: job.yaml
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: job.yaml
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This configures a job named `dataprocessingjob` that will run one replica of
    the `<USERNAME>/dataprocessingjob:v1` image. Now, we can create a new namespace
    and deploy the job, like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这配置了一个名为`dataprocessingjob`的作业，它将运行一个副本的`<USERNAME>/dataprocessingjob:v1`镜像。现在，我们可以创建一个新的命名空间并像这样部署作业：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This defines a job called `dataprocessingjob` that will run a single Pod using
    our Docker image. We set `restartPolicy: Never` since we want the container to
    run to completion rather than restart.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '这定义了一个名为`dataprocessingjob`的作业，它将使用我们的 Docker 镜像运行一个单独的 Pod。我们设置`restartPolicy:
    Never`，因为我们希望容器运行完成，而不是重新启动。'
- en: 'We can check the status of the job like so:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样检查作业的状态：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After the job has been completed, we will see `1/1`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作业完成后，我们将看到`1/1`：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To view the logs from our job, we can use `kubectl logs` on the Pod created
    by the job:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们作业的日志，可以在由作业创建的 Pod 上使用`kubectl logs`：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In my case, I typed the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的案例中，我输入了以下内容：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'I got the following results:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到以下结果：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will print the application output from our Python program so that we can
    verify it ran correctly. And that’s it! You ran a data processing job inside Kubernetes!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印我们 Python 程序的应用程序输出，以便我们验证它是否正确运行。就这样！你在 Kubernetes 内部运行了一个数据处理作业！
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gained hands-on experience deploying Kubernetes clusters
    and running applications in them. We started by installing `kubectl` and deploying
    a local Kubernetes cluster using Kind. Then, we deployed managed Kubernetes clusters
    on AWS, GCP, and Azure. While the cloud providers differ, Kubernetes provides
    a consistent environment to run containers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们通过实践经验部署了 Kubernetes 集群并在其中运行了应用程序。我们从安装`kubectl`并使用 Kind 部署了一个本地 Kubernetes
    集群开始。然后，我们在 AWS、GCP 和 Azure 上部署了托管的 Kubernetes 集群。虽然云提供商有所不同，但 Kubernetes 提供了一个一致的环境来运行容器。
- en: After setting up our clusters, we containerized and deployed the simple API
    application from [*Chapter 1*](B21927_01.xhtml#_idTextAnchor015). This demonstrated
    how to define Kubernetes deployments, services, ingress, and load balancers to
    run web applications. Then, we deployed the data processing batch job from [*Chapter
    1*](B21927_01.xhtml#_idTextAnchor015) as a Kubernetes job. This showed us how
    to leverage Kubernetes for running one-off tasks and jobs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好集群后，我们将[*第 1 章*](B21927_01.xhtml#_idTextAnchor015)中的简单 API 应用程序容器化并部署。这展示了如何定义
    Kubernetes 部署、服务、入口和负载均衡器来运行 Web 应用程序。然后，我们将[*第 1 章*](B21927_01.xhtml#_idTextAnchor015)中的数据处理批量作业作为
    Kubernetes 作业进行了部署。这向我们展示了如何利用 Kubernetes 运行一次性任务和作业。
- en: By going through the process of deploying clusters and applications end-to-end,
    you now have first-hand experience with Kubernetes. You understand how to package
    applications as containers, expose them via services, ingress, or load balancers,
    and leverage Kubernetes abstractions such as deployments and jobs. With these
    skills, you are equipped to run applications and workloads on Kubernetes in development
    or production environments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成部署集群和应用程序的全过程，你现在已经有了 Kubernetes 的第一手经验。你了解如何将应用程序打包为容器，通过服务、入口或负载均衡器暴露它们，并利用
    Kubernetes 的抽象，如部署和作业。有了这些技能，你就具备了在开发或生产环境中运行 Kubernetes 上的应用程序和工作负载的能力。
- en: In the next chapter, we are going to take a closer look at the modern data stack,
    understanding each technology, why they are important, and how they link together
    to build a data solution.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地了解现代数据栈，理解每项技术，为什么它们很重要，以及它们如何相互关联以构建数据解决方案。
- en: 'Part 2: Big Data Stack'
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：大数据栈
- en: In this part, you will dive into the core technologies that make up the **modern
    data stack**, a set of tools and architectures designed for building robust and
    scalable data pipelines. You will gain a solid understanding of the Lambda architecture
    and its components, and gain some hands-on experience with powerful big data tools
    such as Apache Spark, Apache Airflow, and Apache Kafka.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将深入了解构成**现代数据栈**的核心技术，这是一组用于构建强大且可扩展的数据管道的工具和架构。你将深入理解 Lambda 架构及其组件，并获得一些使用强大的大数据工具（如
    Apache Spark、Apache Airflow 和 Apache Kafka）的实践经验。
- en: 'This part contains the following chapters:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含以下章节：
- en: '[*Chapter 4*](B21927_04.xhtml#_idTextAnchor070), *The Modern Data Stack*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 4 章*](B21927_04.xhtml#_idTextAnchor070)，*现代数据栈*'
- en: '[*Chapter 5*](B21927_05.xhtml#_idTextAnchor092), *Big Data Processing with
    Apache Spark*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B21927_05.xhtml#_idTextAnchor092)，*使用 Apache Spark 进行大数据处理*'
- en: '[*Chapter 6*](B21927_06.xhtml#_idTextAnchor112), *Apache Airflow for Building
    Pipelines*'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21927_06.xhtml#_idTextAnchor112), *用于构建流水线的Apache Airflow*'
- en: '[*Chapter 7*](B21927_07.xhtml#_idTextAnchor122), *Apache Kafka for Real-Time
    Events and Data Ingestion*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21927_07.xhtml#_idTextAnchor122), *用于实时事件和数据摄取的Apache Kafka*'
