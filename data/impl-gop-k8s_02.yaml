- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Navigating Cloud-native Operations with GitOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitOps导航云原生操作
- en: In [*Chapter 1*](B22100_01.xhtml#_idTextAnchor013), we delved into the foundational
    concepts of GitOps, contrasting its approach with traditional CI/CD and DevOps
    methodologies. We explored its historical evolution, key principles such as Git
    centralization and automated synchronization, and its integration with Kubernetes.
    This chapter will emphasize GitOps’ role in enhancing scalability and security
    in modern cloud environments. By the end of this chapter, you will have a comprehensive
    understanding of GitOps’ transformative impact on software deployment and operations,
    setting the stage for its application in cloud-native operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B22100_01.xhtml#_idTextAnchor013)中，我们深入探讨了GitOps的基础概念，并将其方法与传统的CI/CD和DevOps方法进行了对比。我们探讨了GitOps的历史发展、关键原则（如Git集中化和自动化同步）以及其与Kubernetes的融合。本章将强调GitOps在提升现代云环境中的可扩展性和安全性方面的作用。到本章结束时，你将对GitOps在软件部署和操作中的变革性影响有全面的理解，为其在云原生操作中的应用打下基础。
- en: 'In this chapter, we’ll focus on the following key areas:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讨论以下几个关键领域：
- en: GitOps and cloud-native tech
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps与云原生技术
- en: An introduction to Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: Exploring K3s as a lightweight Kubernetes distribution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索K3s作为一种轻量级的Kubernetes发行版
- en: Containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Sample workflow – effortless CD with Docker and K3s
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例工作流——使用Docker和K3s轻松实现持续交付（CD）
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To engage with the examples in this chapter, you’ll need a Kubernetes cluster.
    While we’ll guide you through how to install K3s in a way that’s suitable for
    these examples, any Kubernetes setup will suffice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作本章中的示例，你需要一个Kubernetes集群。虽然我们将引导你如何安装K3s以适应这些示例，但任何Kubernetes设置都可以满足需求。
- en: K3s is optimized for Linux systems, so ensure you have access to a Linux environment.
    If you’re using a non-Linux system, consider alternatives such as **Windows Subsystem
    for Linux** (**WSL**) or **Virtual Box** (see [*1*] and [*2*] in the *Further
    reading* section at the end of this chapter).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: K3s已针对Linux系统进行了优化，因此请确保你可以访问Linux环境。如果你使用的是非Linux系统，可以考虑使用**Windows子系统Linux**（**WSL**）或**Virtual
    Box**（参见本章末尾的*进一步阅读*部分中的[*1*]和[*2*]）。
- en: 'The code for this chapter is available in the `Chapter02` folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书GitHub仓库中的`Chapter02`文件夹中找到：[https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes](https://github.com/PacktPublishing/Implementing-GitOps-with-Kubernetes)。
- en: An overview of the integration of GitOps and cloud-native technology
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps与云原生技术融合的概述
- en: In [*Chapter 1*](B22100_01.xhtml#_idTextAnchor013), we explored GitOps, a fusion
    of DevOps and Git, emphasizing its ability to enhance operational efficiency and
    system stability by applying software development techniques to infrastructure
    management. Moving forward, [*Chapter 2*](B22100_02.xhtml#_idTextAnchor027) expands
    on this foundation, examining how GitOps integrates with cloud-native technology.
    This technology signifies a significant shift in application development, characterized
    by containerization, microservices, and dynamic orchestration, enhancing scalability
    and resilience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B22100_01.xhtml#_idTextAnchor013)中，我们探讨了GitOps，这是DevOps和Git的融合，强调其通过将软件开发技术应用于基础设施管理，从而提升操作效率和系统稳定性的能力。接下来，[*第二章*](B22100_02.xhtml#_idTextAnchor027)基于这一基础，进一步探讨了GitOps如何与云原生技术融合。这项技术标志着应用开发的重大转变，具有容器化、微服务和动态编排的特点，提升了可扩展性和弹性。
- en: GitOps complements this by enabling systematic, version-controlled management
    of complex systems. The synergy between GitOps and cloud-native technologies,
    particularly Kubernetes, leads to a more dynamic, agile, and reliable approach
    to system management. This chapter aims to show how GitOps simplifies and elevates
    the capabilities of cloud-native environments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps通过启用系统化、版本控制管理复杂系统，进一步补充了这一点。GitOps与云原生技术，特别是Kubernetes之间的协同作用，带来了更加动态、灵活和可靠的系统管理方式。本章旨在展示GitOps如何简化并提升云原生环境的能力。
- en: Additionally, GitOps, emerging from the confluence of DevOps and version control,
    leverages Git’s power for managing and automating software system deployments
    and operations. By treating infrastructure as code, GitOps facilitates reviewing,
    versioning, and deploying changes using Git’s familiar pull requests and merges.
    This approach ensures consistency, traceability, and ease of rolling back, proving
    especially potent in cloud-native settings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，GitOps 是从 DevOps 和版本控制的交汇处衍生出来的一种方法，它利用 Git 的强大功能来管理和自动化软件系统的部署与操作。通过将基础设施视为代码，GitOps
    使得使用 Git 的常见拉取请求和合并操作来审查、版本控制和部署更改变得容易。这种方法确保了一致性、可追溯性，并且易于回滚，特别在云原生环境中具有强大的作用。
- en: Cloud-native technology, in contrast, represents a paradigm shift in how applications
    are constructed and deployed. It involves using containers, microservices, and
    dynamic orchestration to create robust, scalable, and independently deployable
    applications. This technology maximizes cloud flexibility, enabling swift scaling
    and resilience. When integrated with GitOps, cloud-native technology becomes more
    robust, allowing teams to manage complex systems more effectively with increased
    confidence.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生技术则代表了一种关于应用程序构建和部署的范式转变。它涉及使用容器、微服务和动态编排来创建强大、可扩展且可独立部署的应用程序。这项技术最大化了云的灵活性，使得快速扩展和弹性变得可能。当与
    GitOps 集成时，云原生技术变得更加强大，使团队能够更有效地管理复杂系统，并且信心倍增。
- en: Before delving into the practical applications of GitOps, it is essential to
    introduce Kubernetes, the orchestration platform that’s central to cloud-native
    technology. Additionally, we will discuss **K3s**, a lightweight variant of Kubernetes.
    K3s is particularly suited for personal development environments as it allows
    Kubernetes clusters to be deployed on individual laptops. This setup allows for
    hands-on experimentation and learning, providing a practical foundation for understanding
    and applying GitOps techniques in a Kubernetes context. This knowledge will be
    crucial as we progress to more advanced topics and practical demonstrations of
    GitOps in action.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 GitOps 的实际应用之前，首先有必要介绍 Kubernetes，这是云原生技术的核心编排平台。此外，我们还将讨论 **K3s**，这是一个
    Kubernetes 的轻量级变体。K3s 特别适用于个人开发环境，因为它允许在单个笔记本电脑上部署 Kubernetes 集群。这种设置使得进行动手实验和学习成为可能，为理解和应用
    Kubernetes 环境中的 GitOps 技巧提供了一个实用的基础。随着我们进入更高级的话题和 GitOps 实践演示，这些知识将至关重要。
- en: An introduction to Kubernetes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 简介
- en: In the upcoming sections, we will introduce Kubernetes, including a brief historical
    overview of the original project and the core concepts of Kubernetes architecture.
    In the second part, we will delve deeper into K3s and explore how you can use
    it to run a local Kubernetes cluster on your laptop.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍 Kubernetes，包括该项目的简要历史概述以及 Kubernetes 架构的核心概念。在第二部分，我们将深入探讨 K3s，并探索如何使用它在笔记本电脑上运行本地的
    Kubernetes 集群。
- en: What is Kubernetes?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes？
- en: Kubernetes is a robust and open source platform that was crafted to streamline
    the automation of deploying, scaling, and managing application containers. It
    plays a central role in the kingdom of container orchestration, offering a solid
    framework for the effective management of containerized applications across multiple
    settings, including physical data centers and both public and private cloud environments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个强大且开源的平台，旨在简化应用容器的部署、扩展和管理的自动化过程。它在容器编排的领域中扮演着核心角色，提供了一个可靠的框架，能够有效地管理跨多个环境（包括物理数据中心、公有云和私有云）的容器化应用程序。
- en: Originally, the Kubernetes project at Google, codenamed *Project 7* as a nod
    to *Star Trek’s* Seven of Nine, symbolized a more approachable version of Google’s
    Borg system. Owing to licensing constraints, the term Kubernetes, Greek for helmsman,
    was adopted and reflected in its seven-spoked wheel logo, subtly honoring its
    *Star Trek*-inspired origins. Following its 2014 announcement, Joe Beda, Brendan
    Burns, and Craig McLuckie, among other Google engineers, spearheaded its development.
    Distinct from Borg’s C++ coding, Kubernetes utilized **Go**. Its first version,
    Kubernetes 1.0, was released in 2015\. Through collaboration with the Linux Foundation,
    Kubernetes became a cornerstone of the **Cloud Native Computing Foundation** (**CNCF**),
    rapidly garnering integration into services offered by major tech entities such
    as Red Hat, VMware, Mesosphere, Docker, Microsoft Azure, and AWS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Google 的 Kubernetes 项目代号为*Project 7*，向*《星际迷航》*中的“七人组”致敬，象征着一种更易接近的版本，改良自
    Google 的 Borg 系统。由于许可限制，采用了“Kubernetes”这一希腊语单词，意为舵手，并体现在其七辐车轮的标志中，巧妙地向其*《星际迷航》*的灵感来源致敬。2014
    年发布后，Joe Beda、Brendan Burns 和 Craig McLuckie 以及其他 Google 工程师共同推动了其开发。与 Borg 的
    C++ 编码不同，Kubernetes 使用了**Go**。其第一个版本 Kubernetes 1.0 于 2015 年发布。通过与 Linux 基金会的合作，Kubernetes
    成为了**云原生计算基金会**(**CNCF**)的基石，并迅速获得了红帽、VMware、Mesosphere、Docker、Microsoft Azure
    和 AWS 等主要技术公司提供的服务的整合。
- en: Kubernetes plays a critical role in cloud computing, facilitating both declarative
    configuration and automation. It supports a range of container tools, including
    Docker, and its ability to manage complex container architectures across multiple
    hosts makes it highly valuable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在云计算中扮演着至关重要的角色，促进了声明式配置和自动化。它支持多种容器工具，包括 Docker，并且能够跨多个主机管理复杂的容器架构，这使得它极具价值。
- en: Kubernetes simplifies the deployment and scaling of applications, and its automated
    rollouts and rollbacks for containerized applications enhance reliability and
    efficiency. It allows containers to be orchestrated across multiple hosts, handles
    how applications are deployed and scaled, and covers their networking and storage
    needs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 简化了应用程序的部署和扩展，其针对容器化应用的自动化发布和回滚功能增强了可靠性和效率。它允许在多个主机上编排容器，处理应用程序的部署和扩展，并覆盖它们的网络和存储需求。
- en: The platform’s self-healing feature automatically restarts, replaces, and reschedules
    containers if they fail. It also scales containers in response to varying loads
    and updates them without downtime using a variety of deployment patterns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台的自愈功能会在容器失败时自动重启、替换和重新调度容器。它还会根据负载变化扩展容器，并通过多种部署模式在不发生停机的情况下更新容器。
- en: Kubernetes supports a range of workloads, including **stateless**, **stateful**,
    and **data-processing** workloads. It’s flexible enough to deliver complex applications,
    offering scalability and reliability while managing workloads effectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 支持多种工作负载，包括**无状态**、**有状态**和**数据处理**工作负载。它足够灵活，可以交付复杂的应用程序，同时提供可扩展性和可靠性，并有效管理工作负载。
- en: Overall, Kubernetes has revolutionized the way containerized applications are
    deployed and managed, making it a key tool in the world of modern software development
    and operations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，Kubernetes 革新了容器化应用程序的部署和管理方式，成为现代软件开发和运维领域的关键工具。
- en: Kubernetes architecture
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: Kubernetes architecture is built to manage and orchestrate containerized applications.
    It consists of several components that work together.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 架构旨在管理和编排容器化应用程序。它由多个组件组成，这些组件共同协作。
- en: 'In Kubernetes architecture, the cluster is divided into two primary components:
    the **control plane** and the **worker nodes** (or **data plane**). The control
    plane is responsible for global decision-making and managing the cluster’s state.
    It includes essential elements such as the **API server**, **etcd**, **scheduler**,
    **controller manager**, and **cloud** **controller manager**.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 架构中，集群被分为两个主要组件：**控制平面**和**工作节点**（或**数据平面**）。控制平面负责全球决策和管理集群的状态。它包括如**API
    服务器**、**etcd**、**调度器**、**控制器管理器**和**云控制器管理器**等核心元素。
- en: Conversely, node components are responsible for running the actual workloads.
    Each node contains vital services such as **Kubelet**, a **container runtime**,
    and **kube-proxy**, which ensure that containers run as expected and handle network
    communication within and outside the cluster.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，节点组件负责运行实际的工作负载。每个节点包含至关重要的服务，如 **Kubelet**、**容器运行时** 和 **kube-proxy**，它们确保容器按预期运行，并处理集群内部和外部的网络通信。
- en: This architecture allows for a robust and scalable system where the control
    plane maintains control and nodes efficiently manage the workload.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构使得系统具有健壮性和可扩展性，控制平面保持控制，节点高效地管理工作负载。
- en: 'The control plane includes the following components:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面包括以下组件：
- en: '**API server (kube-apiserver)**: This central management entity processes REST
    requests, validates them, and updates the corresponding objects in etcd. It’s
    the main interface of the Kubernetes control plane.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器（kube-apiserver）**：该中央管理实体处理 REST 请求，验证请求，并更新对应的 etcd 中的对象。它是 Kubernetes
    控制平面的主要接口。'
- en: '**etcd**: This is a consistent and highly available **key-value store** that
    acts as the primary storage for all cluster data. It’s crucial for the cluster’s
    state management.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**：这是一个一致且高可用的 **键值存储**，作为所有集群数据的主要存储。它对集群状态管理至关重要。'
- en: '**Scheduler (kube-scheduler)**: The scheduler is responsible for assigning
    Pods to nodes based on resource availability, user-defined constraints, taints,
    and selectors. This ensures each Pod is placed on the optimal node that satisfies
    not only resource needs but also respects scheduling policies such as taints and
    affinity/anti-affinity selectors.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器（kube-scheduler）**：调度器负责根据资源可用性、用户定义的约束、污点和选择器将 Pods 分配到节点上。这确保每个 Pod
    被放置在满足资源需求且遵循调度策略（如污点和亲和性/反亲和性选择器）的最佳节点上。'
- en: '**Controller manager (kube-controller-manager)**: This component runs various
    controller processes in the background. It observes the state of the cluster,
    manages the life cycle of workloads, and handles operations on nodes to ensure
    the desired state of the Kubernetes cluster is maintained.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器管理器（kube-controller-manager）**：该组件在后台运行各种控制器过程。它监控集群的状态，管理工作负载的生命周期，并处理节点上的操作，以确保
    Kubernetes 集群的期望状态得到维持。'
- en: '**Cloud controller manager**: An architectural component that embeds cloud-specific
    control logic, allowing cloud vendors to link their platforms with Kubernetes.
    It abstracts away the cloud-specific code from core Kubernetes logic, enabling
    each cloud service to develop its plugins independently. Each node component,
    which hosts the pods, consists of essential components for maintaining and managing
    the containers and network communication:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云控制器管理器**：一个架构组件，嵌入了特定云平台的控制逻辑，允许云服务提供商将其平台与 Kubernetes 连接。它将与云平台相关的代码从 Kubernetes
    核心逻辑中抽象出来，使得每个云服务可以独立开发其插件。每个托管 Pods 的节点组件，包含了维护和管理容器及网络通信的基本组件：'
- en: '**Kubelet**: This agent ensures that containers are running in a **Pod**, as
    per the specifications defined in the Pod’s configuration. It manages the state
    of each Pod on the node, communicating with the control plane of the master node
    (or master nodes in the case of highly available Kubernetes clusters).'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubelet**：该代理确保容器按照 Pod 配置中定义的规范在 **Pod** 中运行。它管理每个节点上 Pod 的状态，并与主节点的控制平面（或在高可用
    Kubernetes 集群中与多个主节点）进行通信。'
- en: '**Container runtime**: This is the underlying software that is responsible
    for running containers. Kubernetes supports several container runtimes, such as
    Docker, containerd, and CRI-O, enabling it to run containerized applications.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器运行时**：这是负责运行容器的底层软件。Kubernetes 支持多种容器运行时，如 Docker、containerd 和 CRI-O，使其能够运行容器化应用。'
- en: '**kube-proxy**: This component oversees network interactions to and from the
    Pods. It routes TCP and UDP packets and facilitates connection forwarding, adding
    a Kubernetes service abstraction that acts as a proxy.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-proxy**：该组件负责管理 Pods 的网络交互。它路由 TCP 和 UDP 包，并促进连接转发，添加一个作为代理的 Kubernetes
    服务抽象。'
- en: '*Figure 2**.1* illustrates the Kubernetes architecture described here, with
    components for the control plane and each component node:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.1* 展示了此处描述的 Kubernetes 架构，包含了控制平面和每个组件节点：'
- en: '![Figure 2.1 – The Kubernetes cluster architecture](img/B22100_02_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Kubernetes 集群架构](img/B22100_02_01.jpg)'
- en: Figure 2.1 – The Kubernetes cluster architecture
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Kubernetes 集群架构
- en: For a more in-depth understanding of each component in the Kubernetes architecture,
    please refer to the official Kubernetes documentation ([https://kubernetes.io/](https://kubernetes.io/)).
    This resource provides comprehensive information and detailed explanations of
    various aspects of the Kubernetes system, including its master and node components.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 若要深入了解 Kubernetes 架构中的每个组件，请参考官方 Kubernetes 文档（[https://kubernetes.io/](https://kubernetes.io/)）。该资源提供了关于
    Kubernetes 系统各个方面的全面信息和详细说明，包括其主节点和节点组件。
- en: Now that we have a basic understanding of what Kubernetes is and the main components
    that run in a Kubernetes cluster, it’s time to learn how to set up a local cluster
    on your laptop using K3s, a lightweight Kubernetes distribution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了 Kubernetes 及其在 Kubernetes 集群中运行的主要组件，是时候学习如何使用 K3s（一种轻量级的 Kubernetes
    发行版）在笔记本电脑上设置本地集群了。
- en: Exploring K3s as a lightweight Kubernetes distribution
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 K3s 作为轻量级 Kubernetes 发行版
- en: As mentioned previously, throughout this book, and specifically in this chapter,
    we will utilize K3s, a **lightweight** Kubernetes distribution ([https://k3s.io/](https://k3s.io/)),
    to run our examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在本书中，特别是在本章中，我们将使用 K3s 这个**轻量级**的 Kubernetes 发行版（[https://k3s.io/](https://k3s.io/)）来运行我们的示例。
- en: K3s is particularly well-suited for scenarios where the **full-scale** implementation
    of Kubernetes may be too resource-intensive or complex.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: K3s 特别适合于那些**全规模** Kubernetes 实施可能过于消耗资源或复杂的场景。
- en: 'Its lightweight nature makes it ideal for edge computing and IoT scenarios,
    where resources are often limited, and efficiency is paramount. In these environments,
    K3s provides the necessary Kubernetes features without the overhead. Additionally,
    solutions such as vCluster from Loft have leveraged K3s to run Kubernetes within
    Kubernetes, facilitating multi-tenancy on a host cluster. This approach allows
    for isolated Kubernetes environments within a single cluster, optimizing resource
    usage and offering scalability in multi-tenant setups. These use cases highlight
    K3s’s versatility and efficiency in diverse computing environments. More information
    about K3s can be found in the official documentation: [https://docs.k3s.io/](https://docs.k3s.io/).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其轻量特性使其非常适合边缘计算和物联网（IoT）场景，这些环境中资源通常有限，而效率至关重要。在这些环境中，K3s 提供了必要的 Kubernetes
    特性，同时消除了额外的开销。此外，Loft 的 vCluster 等解决方案已经利用 K3s 在 Kubernetes 内部运行 Kubernetes，促进了宿主集群中的多租户管理。这种方式允许在单一集群内创建独立的
    Kubernetes 环境，优化了资源使用，并在多租户架构中提供了可扩展性。这些使用案例展示了 K3s 在多种计算环境中的多功能性和高效性。更多关于 K3s
    的信息，请参阅官方文档：[https://docs.k3s.io/](https://docs.k3s.io/)。
- en: Origin of the K3s name
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: K3s 名称的由来
- en: The name K3s, as explained in the official documentation (https://docs.k3s.io/),
    is derived from the intent to create a Kubernetes installation that’s significantly
    smaller in memory size. The naming convention follows that of Kubernetes, often
    abbreviated as K8s, which consists of 10 letters. Halving this led to K3s, which
    was stylized to represent a more compact version of Kubernetes. Unlike Kubernetes,
    K3s does not have an expanded form, and its pronunciation is not officially defined.
    This naming reflects the goal of a lighter, more efficient version of Kubernetes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如官方文档中所解释的（https://docs.k3s.io/），K3s 的名称源于创建一个内存占用显著更小的 Kubernetes 安装版本的意图。命名规则沿用了
    Kubernetes 的命名惯例，Kubernetes 常被缩写为 K8s，由 10 个字母组成。将其字母数减半得出了 K3s，并且这个命名风格代表了 Kubernetes
    更紧凑的版本。与 Kubernetes 不同，K3s 并没有扩展形式，其发音也未被官方定义。这个命名反映了创建一个更轻量、更高效的 Kubernetes 版本的目标。
- en: K3s simplifies the process of deploying a Kubernetes cluster, making it accessible
    even for small-scale operations or development purposes. By removing non-essential
    components and using lighter-weight alternatives, K3s significantly reduces the
    size and complexity of Kubernetes while maintaining its core functionalities.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: K3s 简化了 Kubernetes 集群的部署过程，使其即便对于小规模操作或开发用途也变得可行。通过去除非必要的组件并使用更轻量的替代方案，K3s 大幅减少了
    Kubernetes 的体积和复杂度，同时保持了其核心功能。
- en: K3s maintain compatibility with the larger Kubernetes ecosystem, ensuring that
    tools and applications designed for Kubernetes can generally be used with K3s
    as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: K3s 保持与更大 Kubernetes 生态系统的兼容性，确保为 Kubernetes 设计的工具和应用程序通常也能与 K3s 一起使用。
- en: One of the key features of K3s is its single binary installation, which includes
    both the Kubernetes server and agent, simplifying the setup process. This makes
    it an ideal choice for developers who want to quickly set up a Kubernetes environment
    for testing or development without the overhead of a full Kubernetes installation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: K3s的一个关键特点是其单一二进制文件安装，包含了Kubernetes服务器和代理，简化了设置过程。这使得它成为开发人员的理想选择，尤其是那些希望快速设置一个用于测试或开发的Kubernetes环境，而无需完整的Kubernetes安装。
- en: K3s also offers flexible networking and storage options, catering to a wide
    range of use cases – from small local clusters to larger, more complex environments.
    Its versatility and ease of use make it a popular choice for those looking to
    explore Kubernetes without the need for extensive infrastructure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: K3s还提供灵活的网络和存储选项，满足从小型本地集群到更大、更复杂环境的各种用例需求。它的多功能性和易用性使其成为那些希望探索Kubernetes而不需要庞大基础设施的人的热门选择。
- en: Lastly, K3s’s lightweight nature and efficiency make it a suitable choice for
    **continuous integration**/**continuous deployment** (**CI/CD**) pipelines, allowing
    for faster build and test cycles in environments where resources are a consideration.
    In [*Chapter 5*](B22100_05.xhtml#_idTextAnchor081), we’ll learn how to use K3s
    to run Kubernetes on Kubernetes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，K3s的轻量化和高效性使其成为**持续集成**/**持续部署**（**CI/CD**）管道的理想选择，在资源有限的环境中能够加快构建和测试周期。在[*第5章*](B22100_05.xhtml#_idTextAnchor081)中，我们将学习如何使用K3s在Kubernetes上运行Kubernetes。
- en: Local cluster setup
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地集群设置
- en: Before diving into our first deployment example, it’s essential to set up the
    environment and understand how Kubernetes, particularly K3s, facilitates our deployments.
    K3s is primarily designed for Linux environments, so make sure you have a modern
    Linux system such as Red Hat Enterprise Linux, CentOS, Fedora, Ubuntu/Debian,
    or even Raspberry Pi. If you’re a Windows user, you can still engage with K3s
    by setting up **WSL** or running a Linux **virtual machine** (**VM**) through
    **VirtualBox**. These setups will prepare you to harness the power of Kubernetes
    for your deployments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始我们的第一个部署示例之前，首先需要设置环境，并了解Kubernetes，特别是K3s，如何帮助我们完成部署。K3s主要设计用于Linux环境，因此请确保你有一个现代的Linux系统，如Red
    Hat Enterprise Linux、CentOS、Fedora、Ubuntu/Debian，甚至是Raspberry Pi。如果你是Windows用户，仍然可以通过设置**WSL**或通过**VirtualBox**运行Linux**虚拟机**（**VM**）来使用K3s。这些设置将帮助你准备好利用Kubernetes的强大功能进行部署。
- en: Choosing your local Kubernetes environment – K3s, Minikube, and alternatives
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择你的本地Kubernetes环境——K3s、Minikube和替代方案
- en: In this chapter, we have chosen to use K3s due to its lightweight nature and
    ease of setup, which makes it particularly suitable for developing and testing
    Kubernetes environments. However, there are several other alternatives for setting
    up local Kubernetes clusters that cater to different needs and platforms. For
    instance, Colima ([https://github.com/abiosoft/colima](https://github.com/abiosoft/colima))
    is an excellent choice for macOS users, offering a Docker and Kubernetes environment
    directly on macOS with minimal configuration. **Minikube** ([https://minikube.sigs.k8s.io](https://minikube.sigs.k8s.io))
    is another popular option that runs on Windows, macOS, and Linux and is ideal
    for those looking to simulate a Kubernetes cluster in a single node where they
    can experiment and test Kubernetes applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们选择使用K3s是因为它轻量化且易于设置，特别适合开发和测试Kubernetes环境。然而，还有许多其他替代方案可以用来设置本地Kubernetes集群，满足不同的需求和平台。例如，Colima（[https://github.com/abiosoft/colima](https://github.com/abiosoft/colima)）是macOS用户的一个优秀选择，提供了一个直接在macOS上运行的Docker和Kubernetes环境，几乎无需配置。**Minikube**（[https://minikube.sigs.k8s.io](https://minikube.sigs.k8s.io)）是另一个流行的选择，它支持Windows、macOS和Linux，适合那些希望在单个节点上模拟Kubernetes集群的人，在这个节点上可以进行Kubernetes应用程序的实验和测试。
- en: While K3s is our choice for this chapter, you are encouraged to use the local
    cluster setup that best fits your platform or preferences. In subsequent chapters,
    we will primarily focus on using K3s or Minikube. These platforms provide a convenient
    and consistent environment for learning and deploying applications using Kubernetes,
    ensuring that the concepts and procedures we’ll explore are accessible regardless
    of the specific local cluster technology used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本章中我们选择使用K3s，但我们鼓励你根据自己的平台或偏好使用最适合的本地集群设置。在后续章节中，我们将主要集中讨论如何使用K3s或Minikube。这些平台为学习和部署Kubernetes应用程序提供了一个便捷且一致的环境，确保无论使用何种本地集群技术，我们所探讨的概念和过程都能轻松掌握。
- en: Setting up WSL
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置WSL
- en: 'All details regarding the nature of WSL and the procedures for installing it
    on Windows are beyond the scope of this book. However, comprehensive guidance
    on setup steps and in-depth information about WSL can be accessed through the
    official Microsoft documentation (see [*1*] in the *Further reading* section at
    the end of this chapter):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 WSL 的性质以及在 Windows 上安装它的过程超出了本书的范围。然而，关于安装步骤的全面指南和 WSL 的深入信息可以通过官方的 Microsoft
    文档获取（请参见本章末尾的*进一步阅读*部分中的 [*1*]）：
- en: '![Figure 2.2 – A conceptual illustration representing WSL on a Windows operating
    system](img/B22100_02_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 一张表示 Windows 操作系统上运行 WSL 的概念图](img/B22100_02_02.jpg)'
- en: Figure 2.2 – A conceptual illustration representing WSL on a Windows operating
    system
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 一张表示 Windows 操作系统上运行 WSL 的概念图
- en: Remember, staying updated with the latest WSL versions and features through
    the official site will enhance your experience and ensure compatibility with the
    most recent Windows updates.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通过官方站点保持更新最新的 WSL 版本和功能，将增强您的体验，并确保与最新的 Windows 更新兼容。
- en: Setting up VirtualBox
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 VirtualBox
- en: '**VirtualBox** is an open source **virtualization software** developed by Oracle.
    It allows users to run multiple operating systems on a single physical computer,
    creating VMs that can operate independently. This makes it an invaluable tool
    for software testing, development, and educational purposes as it provides a flexible
    and isolated environment for running and experimenting with different operating
    systems without risk to the host system:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**VirtualBox** 是由 Oracle 开发的开源 **虚拟化软件**。它允许用户在一台物理计算机上运行多个操作系统，创建能够独立运行的虚拟机。这使得它成为软件测试、开发和教育目的的重要工具，因为它为运行和实验不同操作系统提供了一个灵活且隔离的环境，且不会影响宿主系统：'
- en: '![Figure 2.3 – The VirtualBox home page at https://www.virtualbox.org/.](img/B22100_02_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – VirtualBox 首页，网址：https://www.virtualbox.org/.](img/B22100_02_03.jpg)'
- en: Figure 2.3 – The VirtualBox home page at https://www.virtualbox.org/.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – VirtualBox 首页，网址：https://www.virtualbox.org/。
- en: The detailed steps for installing VirtualBox are beyond the scope of this book.
    However, comprehensive installation instructions and additional information can
    be found in the official documentation [*2*].
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 VirtualBox 的详细步骤超出了本书的范围。然而，您可以在官方文档中找到全面的安装说明和其他信息 [*2*]。
- en: For the most current information and tips, visiting the official VirtualBox
    documentation is highly recommended.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取最新的信息和技巧，强烈建议访问官方 VirtualBox 文档。
- en: Unless otherwise specified, for this chapter and the subsequent ones, we will
    assume the use of an **Ubuntu-22.04 LTS** installation within WSL. This setup
    provides a consistent and controlled environment for our examples and demonstrations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，本章及后续章节将假设在 WSL 中使用 **Ubuntu-22.04 LTS** 版本进行安装。此设置为我们的示例和演示提供了一个一致且可控的环境。
- en: By focusing on a specific version of Ubuntu, we ensure that the instructions
    and scenarios presented are as relevant and applicable as possible, aligning closely
    with the most common and stable Linux distribution used in WSL.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过聚焦于特定版本的 Ubuntu，我们确保所提供的指导和场景尽可能相关和适用，紧密契合在 WSL 中使用的最常见且稳定的 Linux 发行版。
- en: K3s setup and installation verification
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K3s 设置和安装验证
- en: In this section, we’ll cover the basic steps that are necessary to establish
    a Kubernetes cluster using K3s in its default configuration, assuming that WSL
    is already installed and functioning correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍使用默认配置的 K3s 建立 Kubernetes 集群所需的基本步骤，假设 WSL 已经安装并正常运行。
- en: Downloading and installing K3s
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载并安装 K3s
- en: 'Follow these steps to download and install K3s:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤下载并安装 K3s：
- en: 'Let’s start by opening a new Terminal window and typing the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开一个新的终端窗口并输入以下命令开始：
- en: '[PRE0]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 2.4 – Successfully installing an instance of Ubuntu 22.04.3 LTS on
    WSL](img/B22100_02_04.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 在 WSL 上成功安装 Ubuntu 22.04.3 LTS 实例](img/B22100_02_04.jpg)'
- en: Figure 2.4 – Successfully installing an instance of Ubuntu 22.04.3 LTS on WSL
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 在 WSL 上成功安装 Ubuntu 22.04.3 LTS 实例
- en: 'Before proceeding with the K3s setup, it is always better to execute commands
    to update the operating system with the latest patches:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续进行 K3s 设置之前，最好执行命令以更新操作系统并安装最新的补丁：
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This ensures that you are working with the most recent and secure versions of
    the software.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保您使用的是最新且安全的软件版本。
- en: The apt update and apt upgrade commands
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: apt update 和 apt upgrade 命令
- en: The `apt update` and `apt upgrade` commands are fundamental in maintaining the
    software on systems using the APT package manager, commonly found in Debian-based
    Linux distributions such as Ubuntu. The `apt update` command refreshes the local
    package index by retrieving the latest information about available packages and
    their versions from configured sources. This doesn’t install or upgrade any packages
    and instead updates the package lists to inform the system of new, removed, or
    updated software. Once the package index has been updated, the `apt upgrade` command
    is used to upgrade installed packages to their latest versions. It downloads and
    installs the updates for any packages where newer versions are available, ensuring
    the system is up-to-date and potentially more secure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`apt update` 和 `apt upgrade` 命令在使用 APT 包管理器的系统中，尤其是在基于 Debian 的 Linux 发行版（如
    Ubuntu）中，起着至关重要的作用。`apt update` 命令通过从配置的源获取可用软件包及其版本的最新信息来刷新本地包索引。这不会安装或升级任何软件包，而是更新包列表，以通知系统有关新软件、已删除软件或已更新软件的信息。包索引更新后，`apt
    upgrade` 命令用于将已安装的软件包升级到最新版本。它会下载并安装所有有新版本的软件包更新，确保系统是最新的，并可能更加安全。'
- en: 'If required, enter the password you set up while installing Ubuntu. After executing
    these commands, the Terminal should look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，输入在安装 Ubuntu 时设置的密码。执行这些命令后，终端窗口应如下所示：
- en: '![Figure 2.5 – Terminal window after executing the apt update and apt upgrade
    commands](img/B22100_02_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 执行 `apt update` 和 `apt upgrade` 命令后的终端窗口](img/B22100_02_05.jpg)'
- en: Figure 2.5 – Terminal window after executing the apt update and apt upgrade
    commands
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 执行 `apt update` 和 `apt upgrade` 命令后的终端窗口
- en: 'The next step is to install K3s using the following command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用以下命令安装 K3s：
- en: '[PRE2]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will download and set up the necessary tools, followed
    by launching the K3s server. The successful setup of a K3s instance is depicted
    in *Figure 2**.6*:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令将下载并设置必要的工具，随后启动 K3s 服务器。K3s 实例的成功设置如*图 2.6*所示：
- en: '![Figure 2.6 – Successfully setting up K3s](img/B22100_02_06.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 2.6 – 成功设置 K3s](img/B22100_02_06.jpg)'
- en: Figure 2.6 – Successfully setting up K3s
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 成功设置 K3s
- en: Verifying the K3s installation
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证 K3s 安装
- en: 'It is necessary to use two commands to check the correctness of the K3s setup
    and configuration. The first one is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用两个命令来检查 K3s 设置和配置的正确性。第一个命令如下：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding command is used to check which version of K3s we are running.
    If the K3s server is running correctly, we should be able to see a message similar
    to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令用于检查我们正在运行的 K3s 版本。如果 K3s 服务器运行正常，我们应该能看到类似以下内容的信息：
- en: '![Figure 2.7 – The result of executing the k3s –version command](img/B22100_02_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 执行 `k3s –version` 命令的结果](img/B22100_02_07.jpg)'
- en: Figure 2.7 – The result of executing the k3s –version command
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 执行 `k3s –version` 命令的结果
- en: 'The second command that checks the correctness of the K3s setup is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 K3s 设置正确性的第二个命令如下：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `k3s check-config` command performs a diagnostic check on the system’s
    configuration to ensure it is suitable for running a K3s cluster. It verifies
    critical aspects such as kernel compatibility, required system dependencies, and
    the presence of necessary features and modules. This command helps in identifying
    potential issues or missing configurations before proceeding with the K3s installation,
    ensuring a smoother setup process:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`k3s check-config` 命令对系统配置进行诊断检查，以确保其适合运行 K3s 集群。它验证关键方面，例如内核兼容性、所需的系统依赖项，以及必要功能和模块的存在。此命令有助于在进行
    K3s 安装之前识别潜在问题或缺失的配置，从而确保更顺利的安装过程：'
- en: '![Figure 2.8 – Successfully configuring the k3s check-config command](img/B22100_02_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 成功配置 k3s check-config 命令](img/B22100_02_08.jpg)'
- en: Figure 2.8 – Successfully configuring the k3s check-config command
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 成功配置 k3s check-config 命令
- en: Congratulations! You have confirmed that the K3s server has been installed in
    your local development environment. Now, it’s time to verify the Kubernetes cluster
    and deploy a test application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已确认 K3s 服务器已经在本地开发环境中安装成功。现在是时候验证 Kubernetes 集群并部署一个测试应用程序了。
- en: Checking the Kubernetes cluster
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 Kubernetes 集群
- en: 'To confirm that our K3s node is up and running, let’s type the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们的 K3s 节点正在运行，我们可以输入以下命令：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the Kubernetes cluster is working correctly, the preceding command will
    produce the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Kubernetes 集群正常工作，前述命令将产生以下输出：
- en: '![Figure 2.9 – Example output after running the kubectl get nodes command](img/B22100_02_09.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 运行 kubectl get nodes 命令后的示例输出](img/B22100_02_09.jpg)'
- en: Figure 2.9 – Example output after running the kubectl get nodes command
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 运行 kubectl get nodes 命令后的示例输出
- en: 'After confirming that the node is up and running correctly, we can run the
    following command to obtain more information about the running cluster:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 确认节点正常运行后，我们可以运行以下命令以获取更多关于运行中的集群的信息：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `kubectl cluster-info` command is a useful tool in Kubernetes for obtaining
    essential information about a cluster. When executed, it displays key details
    such as the Kubernetes master and services endpoint addresses. This command helps
    users quickly understand the state and connectivity of their cluster’s control
    plane and core services such as KubeDNS and, when applicable, the dashboard. It
    is particularly valuable for troubleshooting and ensuring that the Kubernetes
    cluster is configured correctly and operational. Easy to use, `kubectl cluster-info`
    is often one of the first commands you should run to verify the health and status
    of a Kubernetes environment, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl cluster-info` 命令是 Kubernetes 中一个非常有用的工具，用于获取关于集群的重要信息。执行此命令后，它会显示一些关键细节，如
    Kubernetes 主节点和服务端点地址。这个命令帮助用户快速了解集群的控制平面及核心服务（如 KubeDNS 和适用时的仪表板）的状态和连通性。它对于故障排除和确保
    Kubernetes 集群配置正确并正常运行特别有价值。使用简单，`kubectl cluster-info` 通常是验证 Kubernetes 环境健康状态和状态的第一个命令，如下所示：'
- en: '![Figure 2.10 – Information provided after executing the kubectl cluster-info
    command](img/B22100_02_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 执行 kubectl cluster-info 命令后提供的信息](img/B22100_02_10.jpg)'
- en: Figure 2.10 – Information provided after executing the kubectl cluster-info
    command
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 执行 kubectl cluster-info 命令后提供的信息
- en: kubectl
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl
- en: '**kubectl** is a command-line tool that serves as the primary interface for
    interacting with Kubernetes. It allows users to deploy applications, inspect and
    manage cluster resources, and view logs. Essentially, kubectl provides the necessary
    commands to control Kubernetes clusters effectively. Users can create, delete,
    and update parts of their Kubernetes applications and infrastructure using this
    versatile tool. It is designed to be user-friendly, offering comprehensive help
    commands and output formatting options, making it easier to understand and manage
    complex Kubernetes environments. kubectl is an indispensable tool for developers
    and system administrators working with Kubernetes, offering a robust and flexible
    way to handle containerized applications and services in various environments.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl** 是一个命令行工具，是与 Kubernetes 进行交互的主要接口。它允许用户部署应用程序、检查和管理集群资源以及查看日志。基本上，kubectl
    提供了有效控制 Kubernetes 集群所需的命令。用户可以使用这个多功能工具创建、删除和更新 Kubernetes 应用程序和基础设施的各个部分。它旨在用户友好，提供全面的帮助命令和输出格式选项，使用户更容易理解和管理复杂的
    Kubernetes 环境。kubectl 是开发人员和系统管理员处理 Kubernetes 的不可或缺的工具，为在各种环境中处理容器化应用程序和服务提供了一种强大且灵活的方式。'
- en: Kubernetes manifest
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 清单
- en: A Kubernetes manifest is a configuration file, typically written in YAML or
    JSON, that defines resources that should be deployed to a Kubernetes cluster.
    It specifies the desired state of objects, such as Pods, Services, or Deployments,
    that Kubernetes needs to create and manage. This manifest enables users to declare
    their applications’ requirements, networking, and storage configurations, among
    other settings, in a structured and versionable format.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 清单是一个配置文件，通常使用 YAML 或 JSON 编写，定义了应该部署到 Kubernetes 集群的资源。它指定了对象（如
    Pods、Services 或 Deployments）所需的状态，Kubernetes 需要根据这些清单创建和管理这些对象。这个清单使得用户能够以结构化且可版本化的格式声明应用程序的要求、网络和存储配置等设置。
- en: 'As an example, a basic Kubernetes manifest for deploying a simple application
    might look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，部署一个简单应用程序的基本 Kubernetes 清单可能如下所示：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this manifest, a Pod named `hw-gitops-folks` is defined. It contains one
    container named `hw-gitops-container`, which uses the `echoserver:1.4` image from
    Kubernetes’ container registry. The container exposes port `8080`. This manifest,
    when applied to a Kubernetes cluster, will create a Pod running a simple echo
    server that can be used for basic testing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单中，定义了一个名为 `hw-gitops-folks` 的 Pod。它包含一个名为 `hw-gitops-container` 的容器，该容器使用
    Kubernetes 容器注册表中的 `echoserver:1.4` 镜像。该容器暴露了 `8080` 端口。当这个清单应用到 Kubernetes 集群时，它将创建一个运行简单回显服务器的
    Pod，可用于基本的测试。
- en: Our first deployment with K3s
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一次 K3s 部署
- en: 'Now that we have successfully set up, configured, and verified our K3s cluster,
    we are poised to embark on an exciting phase: preparing for our first deployment.
    This step marks a significant milestone in our journey as we transition from the
    foundational aspects of K3s to actively utilizing the cluster for practical applications.
    The upcoming deployment process will not only reinforce our understanding of Kubernetes
    concepts but also demonstrate the real-world utility of our K3s environment. It’s
    a moment where theory meets practice, allowing us to see firsthand how our configured
    cluster can host and manage applications. Let’s proceed with an eagerness to explore
    the capabilities of our Kubernetes setup while keeping the practices we’ve learned
    and the robust infrastructure we’ve established in mind:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地设置、配置并验证了我们的 K3s 集群，我们准备开始一个激动人心的阶段：为我们的首次部署做准备。此步骤标志着我们旅程中的一个重要里程碑，标志着我们从
    K3s 的基础配置转向实际使用集群来进行实际应用。即将进行的部署过程不仅会加强我们对 Kubernetes 概念的理解，还将展示我们 K3s 环境的实际应用价值。这是一个理论与实践相结合的时刻，让我们亲眼看到我们配置的集群如何托管和管理应用程序。让我们带着探索
    Kubernetes 配置的能力的热情前进，同时牢记我们所学的实践和已建立的强大基础设施：
- en: 'Let’s begin by typing the following command, which should list all the running
    Pods:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先输入以下命令，这将列出所有正在运行的 Pods：
- en: '[PRE8]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result of its execution should look something like this:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行该命令的结果应该如下所示：
- en: '[PRE9]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding output is normal since no deployments have been performed so
    far. Let’s try another command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的输出是正常的，因为到目前为止还没有执行任何部署。让我们试试另一个命令：
- en: '[PRE10]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Figure 2.11 – Example of running Pods in the kube-system namespace](img/B22100_02_11.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 在 kube-system 命名空间中运行 Pods 的示例](img/B22100_02_11.jpg)'
- en: Figure 2.11 – Example of running Pods in the kube-system namespace
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 在 kube-system 命名空间中运行 Pods 的示例
- en: What is a namespace in Kubernetes?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes 中的命名空间？
- en: In Kubernetes, a namespace is a fundamental concept that’s used to organize
    clusters into logically isolated sub-groups. It provides a way to divide cluster
    resources between multiple users and applications. Essentially, namespaces are
    like virtual clusters within a physical Kubernetes cluster. They allow for resource
    management, access control, and quota management, enabling efficient and secure
    multi-tenancy environments. For instance, different development teams or projects
    can operate in separate namespaces, without interference. Namespaces also facilitate
    resource naming, ensuring that resources with the same name can coexist in different
    namespaces. They play a crucial role in Kubernetes for scalability and maintaining
    order, especially in larger systems with numerous applications and teams.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，命名空间是一个基本概念，用于将集群组织成逻辑上隔离的子组。它提供了一种在多个用户和应用程序之间划分集群资源的方法。本质上，命名空间就像是物理
    Kubernetes 集群中的虚拟集群。它们允许进行资源管理、访问控制和配额管理，从而实现高效、安全的多租户环境。例如，不同的开发团队或项目可以在各自的命名空间中操作，而不相互干扰。命名空间还便于资源命名，确保具有相同名称的资源可以在不同的命名空间中共存。命名空间在
    Kubernetes 中发挥着至关重要的作用，特别是在具有大量应用程序和团队的大型系统中，它们有助于实现可扩展性和维持秩序。
- en: 'Creating different namespaces in Kubernetes is widely regarded as a best practice
    for several compelling reasons. Namespaces provide a logical partitioning of the
    cluster, allowing for more organized and efficient resource management. This separation
    is particularly beneficial in environments with multiple teams or projects as
    it ensures a clear distinction between resources, reduces naming conflicts, and
    enhances security by isolating workloads. Additionally, namespaces facilitate
    fine-grained access control as administrators can assign specific permissions
    and resource limits to different namespaces, preventing accidental or unauthorized
    interactions between distinct parts of the cluster. By using namespaces, teams
    can also streamline deployment processes and monitor resource usage more effectively,
    leading to a more robust and scalable Kubernetes environment. In essence, namespaces
    are crucial in maintaining order, security, and efficiency in complex Kubernetes
    clusters. So, let’s get started by creating one:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中创建不同的命名空间被广泛认为是一种最佳实践，原因有很多。命名空间提供了集群的逻辑分区，使资源管理更加有序和高效。特别是在多个团队或项目的环境中，这种分隔尤为重要，它可以确保资源之间的清晰区分，减少命名冲突，并通过隔离工作负载来提高安全性。此外，命名空间还便于精细化访问控制，管理员可以为不同的命名空间分配特定的权限和资源限制，从而防止不同部分的集群之间发生意外或未经授权的互动。通过使用命名空间，团队还可以简化部署过程，更有效地监控资源使用情况，从而使
    Kubernetes 环境更加健壮和可扩展。本质上，命名空间在维护复杂 Kubernetes 集群的秩序、安全性和效率方面至关重要。那么，让我们开始创建一个命名空间吧：
- en: 'Let’s continue by creating a new namespace before continuing with our first
    deployment:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续，在继续进行首次部署之前，先创建一个新的命名空间：
- en: '[PRE11]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The response to this command should look something like this:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此命令后的响应应该类似于以下内容：
- en: '[PRE12]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command to delete a namespace is as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除命名空间的命令如下：
- en: '[PRE13]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'apiVersion: apps/v1'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'apiVersion: apps/v1'
- en: 'kind: Deployment'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'kind: Deployment'
- en: 'metadata:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: hello-world-deployment'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'name: hello-world-deployment'
- en: 'namespace: gitops-kubernetes'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'namespace: gitops-kubernetes'
- en: '...'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: 'spec:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: '...'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: 'spec:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'containers:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'containers:'
- en: '- name: hello-world'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- name: hello-world'
- en: 'image: nginxdemos/hello'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'image: nginxdemos/hello'
- en: 'ports:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'ports:'
- en: '- containerPort: 80'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- containerPort: 80'
- en: '---'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '---'
- en: 'apiVersion: v1'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'apiVersion: v1'
- en: 'kind: Service'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'kind: Service'
- en: 'metadata:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: hello-world-service'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'name: hello-world-service'
- en: 'namespace: gitops-kubernetes'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'namespace: gitops-kubernetes'
- en: 'spec:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'type: NodePort'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'type: NodePort'
- en: '...'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: 'ports:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'ports:'
- en: '- protocol: TCP'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- protocol: TCP'
- en: 'port: 80'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'port: 80'
- en: 'nodePort: 30007'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'nodePort: 30007'
- en: '[PRE14]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To edit the file, we can use an editor such as `nano` by running the following
    command:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编辑文件，我们可以使用像 `nano` 这样的编辑器，运行以下命令：
- en: '[PRE15]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`hello-world-service` of the `NodePort` type to expose the deployment. This
    service makes the hello-world application accessible on a port on the nodes in
    the cluster (in this example, `port 30007`). In the metadata section, we have
    specified to run the service in the namespace we created previously – that is,
    `namespace: gitops-kubernetes`.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hello-world-service` 是 `NodePort` 类型，用于暴露部署。这项服务使得 hello-world 应用程序可以通过集群节点上的端口访问（在这个例子中是
    `port 30007`）。在元数据部分，我们已指定在之前创建的命名空间中运行该服务——即 `namespace: gitops-kubernetes`。'
- en: NodePort
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: NodePort
- en: In this hello-world service example, the `NodePort` service type was chosen
    to demonstrate a simple way of exposing a service to external traffic in Kubernetes.
    `NodePort` opens a specific port on all the nodes; any traffic sent to this port
    is forwarded to the service. While this is useful for development and testing,
    it may not be ideal in a real-world cloud scenario, especially when running on
    a VM in the cloud. This is because `NodePort` exposes a port on the host VM/node,
    potentially posing a security risk by making the service accessible externally.
    In production environments, more secure and controlled methods of exposing services
    are typically preferred.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 hello-world 服务示例中，选择了 `NodePort` 服务类型，以展示在 Kubernetes 中暴露服务给外部流量的一种简单方式。`NodePort`
    会在所有节点上打开一个特定的端口，任何发送到该端口的流量都会被转发到该服务。虽然这对开发和测试很有用，但在实际的云环境中可能并不理想，特别是在云中的虚拟机（VM）上运行时。这是因为
    `NodePort` 会暴露主机虚拟机/节点的端口，可能会通过让服务对外部可访问，造成安全风险。在生产环境中，通常更倾向于使用更安全和可控的服务暴露方法。
- en: 'To apply this manifest, use the `kubectl apply -f <``filename>.yaml` command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要应用此清单，请使用 `kubectl apply -f <``filename>.yaml` 命令：
- en: '[PRE16]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The response to this command should look something like this:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此命令后的响应应该类似于以下内容：
- en: '[PRE17]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can list the Pods and services that are running in the `gitpos-kubernetes`
    namespace using the following command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令列出在 `gitpos-kubernetes` 命名空间中运行的 Pods 和服务：
- en: '[PRE18]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The result of this command is shown in *Figure 2**.12*:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令的结果显示在 *图 2.12* 中：
- en: '![Figure 2.12 – Results of applying the deployment file, where we can see useful
    information such as the Cluster-IP and the assigned ports](img/B22100_02_12.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 应用部署文件的结果，我们可以看到有用的信息，如集群IP和分配的端口](img/B22100_02_12.jpg)'
- en: Figure 2.12 – Results of applying the deployment file, where we can see useful
    information such as the Cluster-IP and the assigned ports
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 应用部署文件的结果，我们可以看到有用的信息，如集群IP和分配的端口
- en: Now that we have deployed our application in the Kubernetes cluster, the next
    crucial step is to test its functionality. This is where **port forwarding** plays
    a key role.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在 Kubernetes 集群中部署了应用程序，下一步是测试其功能。这就是 **端口转发** 起到关键作用的地方。
- en: Port forwarding
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口转发
- en: 'Port forwarding with kubectl allows us to temporarily route traffic from our
    local machine to a pod in the Kubernetes cluster. This method is especially useful
    for testing purposes as it enables us to interact with the application as if it
    were running locally, without the need to expose it publicly. By forwarding a
    local port to a port on the pod, we can verify the deployment’s operational aspects,
    ensuring that our application behaves as expected in a controlled environment
    before making it accessible to external traffic. The following steps outline the
    process for executing port forwarding on the running pod and testing its functionality
    using **curl**:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 kubectl 进行端口转发可以临时将流量从本地计算机路由到 Kubernetes 集群中的 Pod。此方法对于测试特别有用，因为它使我们能够像在本地运行应用程序一样与之交互，而无需公开暴露它。通过将本地端口转发到
    Pod 的端口，我们可以验证部署的运行情况，确保应用程序在受控环境中按预期运行，然后再将其暴露给外部流量。以下步骤概述了在运行中的 Pod 上执行端口转发并使用
    **curl** 测试其功能的过程：
- en: '`kubectl` command to start port forwarding from a local port to a port on the
    Pod:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl` 命令将本地端口转发到 Pod 的端口：'
- en: '[PRE19]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At this point, we are using the Pod’s name, `hello-world-deployment-6b7f766747-nxj44`.
    So, if we want to forward traffic from local port `9000` to the Pod’s port, `80`,
    the command would be as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们正在使用 Pod 的名称 `hello-world-deployment-6b7f766747-nxj44`。因此，如果我们想将本地端口 `9000`
    转发到 Pod 的端口 `80`，命令如下：
- en: '[PRE20]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will produce the following output:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE21]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding output indicates that port forwarding is set up on your machine
    to redirect traffic from a local port to a port on a Kubernetes Pod or another
    network service. Keep this command running as it maintains the port forwarding
    session.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述输出表明，端口转发已经在你的机器上设置好，将流量从本地端口重定向到 Kubernetes Pod 或其他网络服务的端口。保持此命令运行，因为它会维持端口转发会话。
- en: 'Open a new Terminal or Command Prompt and type the following command to open
    a new WSL shell:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端或命令提示符，并键入以下命令以打开新的 WSL shell：
- en: '[PRE22]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '9000, which kubectl then forwards to the Pod’s port (80). You should see the
    output of the request in your Terminal. Typically, this is the content that’s
    served by your application running in the Kubernetes Pod, as shown in *Figure
    2**.13*:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9000，kubectl 然后将其转发到 Pod 的端口（80）。你应该在终端中看到请求的输出。通常，这是由你的应用程序在 Kubernetes Pod
    中提供的内容，如 *图 2.13* 所示：
- en: '[PRE23]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 2.13 – Example of content served by our application running in the
    Kubernetes Pod](img/B22100_02_13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 我们的应用程序在 Kubernetes Pod 中运行时提供的内容示例](img/B22100_02_13.jpg)'
- en: Figure 2.13 – Example of content served by our application running in the Kubernetes
    Pod
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 我们的应用程序在 Kubernetes Pod 中运行时提供的内容示例
- en: Congratulations on achieving this remarkable result! You’ve successfully deployed
    your first application in Kubernetes, and the content is being correctly served,
    as evidenced by the successful `curl` call. This is a significant milestone in
    your journey with Kubernetes, showcasing your ability to not only deploy an application
    but also ensure its proper functioning within the cluster.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你取得了这一了不起的成果！你已经成功在 Kubernetes 中部署了第一个应用程序，并且内容已经正确提供，正如通过成功的 `curl` 调用所证明的那样。这是你在
    Kubernetes 旅程中的一个重要里程碑，展示了你不仅能部署应用程序，还能确保它在集群中的正常运行。
- en: In the upcoming section, we will delve deeper into Docker, closely examining
    its essential components, functionalities, and practical applications. We’ll build
    our first Docker image and demonstrate how to run it as a container locally.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨 Docker，详细研究其基本组件、功能和实际应用。我们将构建我们的第一个 Docker 镜像，并展示如何将其作为容器在本地运行。
- en: Getting started with containers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用容器
- en: Containers have become a cornerstone in cloud-native application development
    due to their ability to package and isolate applications with all their dependencies.
    This isolation ensures consistency across various environments, making them highly
    efficient for both development and deployment. **Container images**, which are
    static files containing executable code and dependencies, follow a **layered**
    structure for efficient modification and storage, with each layer representing
    changes or additions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其能够将应用程序及其所有依赖项打包和隔离，容器已成为云原生应用程序开发的基石。这种隔离确保了在各种环境中的一致性，使其在开发和部署中极为高效。**容器镜像**是包含可执行代码和依赖项的静态文件，采用**分层**结构以实现高效的修改和存储，每一层代表变更或添加。
- en: Despite the versatility of containers, Kubernetes does not provide a native
    mechanism for building these images, necessitating external tools such as **Docker**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器具有很强的多用途性，但 Kubernetes 并未提供用于构建这些镜像的原生机制，因此需要像**Docker**这样的外部工具。
- en: Docker, an open source platform, has transformed the world of containerization
    by simplifying the creation, deployment, and execution of applications in containers.
    It enables developers to encapsulate applications with their dependencies in a
    unified format, facilitating software development. Docker’s containers offer a
    **semi-isolated** environment, balancing isolation with efficiency, allowing multiple
    containers to run concurrently on a single host. These containers are both lightweight
    and portable, ensuring uniform functionality across diverse platforms, from local
    laptops to cloud infrastructures.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Docker，作为一个开放源代码平台，通过简化应用程序在容器中的创建、部署和执行，改变了容器化的世界。它使开发人员能够以统一的格式封装带有其依赖项的应用程序，从而促进软件开发。Docker
    的容器提供了半隔离的环境，平衡了隔离性与效率，允许多个容器在单个主机上并发运行。这些容器既轻量又便携，确保在从本地笔记本到云基础设施等各种平台上的统一功能性。
- en: Docker files are instrumental in creating these images, specifying the steps
    and components to be included.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 文件在创建这些镜像方面起着关键作用，指定包括的步骤和组件。
- en: The **Open Container Initiative** (**OCI**) standardizes container image formats
    and runtimes, further enhancing interoperability and portability across different
    containerization technologies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放容器倡议**（**OCI**）标准化容器镜像格式和运行时，进一步增强了在不同容器技术之间的互操作性和可移植性。'
- en: Docker setup
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 设置
- en: 'Up until now, we have focused on using Ubuntu 22.04 as an instance within WSL.
    While a step-by-step setup of Docker falls outside the scope of this book, you
    can find comprehensive installation guides and troubleshooting tips in the official
    Docker documentation: [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/).
    After successfully installing Docker, you can verify its installation and check
    that Docker is running correctly on your system by typing the following command
    in your Terminal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于在 WSL 中使用 Ubuntu 22.04 作为实例。虽然本书不涵盖 Docker 的逐步设置过程，但您可以在官方 Docker
    文档中找到全面的安装指南和故障排除提示：[https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/)。成功安装
    Docker 后，您可以在终端中输入以下命令验证其安装并检查 Docker 是否在系统上正常运行：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `sudo docker run hello-world` command quickly verifies the installation
    and setup of Docker by running a very simple container. When executed, it does
    the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo docker run hello-world` 命令通过运行一个非常简单的容器快速验证了 Docker 的安装和设置。执行时，它执行以下操作：'
- en: '`sudo`: Ensures the command is run with superuser privileges, which are often
    required for Docker commands.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo`：确保命令以超级用户权限运行，这通常是 Docker 命令所需的。'
- en: '`docker run`: Tells Docker to run a container.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run`：告诉 Docker 运行一个容器。'
- en: '`hello-world`: Specifies the image to use. In this case, it’s the `hello-world`
    image, a minimal Docker image created by Docker, Inc. It’s commonly used as a
    test image to validate that Docker is installed and running correctly.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hello-world`：指定要使用的镜像。在这种情况下，它是 `hello-world` 镜像，这是由 Docker, Inc 创建的一个最小的
    Docker 镜像，通常用作验证 Docker 是否安装和运行正常的测试镜像。'
- en: 'If Docker has been correctly installed and configured, this command will pull
    the `hello-world` image from Docker Hub (if it’s not already downloaded), create
    a new container from that image, and run it. The container simply displays a message
    confirming that Docker is installed correctly and then exits, as shown in *Figure
    2**.14*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Docker 已正确安装和配置，该命令将从 Docker Hub 拉取 `hello-world` 镜像（如果尚未下载），并基于该镜像创建一个新容器并运行。该容器仅显示一条消息，确认
    Docker 安装正确，然后退出，如 *图 2.14* 所示：
- en: '![Figure 2.14 – Result of executing the docker run hello-world command](img/B22100_02_14.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 执行 `docker run hello-world` 命令的结果](img/B22100_02_14.jpg)'
- en: Figure 2.14 – Result of executing the docker run hello-world command
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 执行 `docker run hello-world` 命令的结果
- en: Docker alternatives
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 替代方案
- en: 'Although Docker is one of the most popular tools for building container images,
    there are several alternative tools available:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Docker 是构建容器镜像的最流行工具之一，但也有多个可用的替代工具：
- en: '**Podman**: An open source, daemonless container engine that can run on Linux
    systems. It is compatible with Docker but does not require a running daemon. Podman
    is known for enabling easier management of containers and pods.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Podman**：一个开源的、无守护进程的容器引擎，可在 Linux 系统上运行。它与 Docker 兼容，但不需要运行守护进程。Podman 以简化容器和
    Pod 管理而闻名。'
- en: '**Rancherdesktop**: An open source application that provides all the essentials
    to work with containers and Kubernetes on desktop.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rancherdesktop**：一款开源应用程序，提供在桌面上与容器和 Kubernetes 配合使用的所有必需工具。'
- en: '**containerd**: A core container runtime that adheres to industry standards,
    available as a service for both Linux and Windows. It is capable of managing the
    entire life cycle of containers on its host system.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**containerd**：一个核心容器运行时，遵循行业标准，作为服务可用于 Linux 和 Windows。它能够管理主机系统上容器的整个生命周期。'
- en: '**CRI-O**: This is a realization of the Kubernetes Container Runtime Interface,
    facilitating the use of runtimes compatible with the OCI. It serves as a bridge,
    connecting OCI-compliant runtimes with kubelet.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRI-O**：这是 Kubernetes 容器运行时接口的实现，便于使用与 OCI 兼容的运行时。它充当桥梁，将 OCI 兼容的运行时与 kubelet
    连接起来。'
- en: '**rkt (pronounced ‘rocket’)**: Developed by CoreOS, it’s a Pod-native container
    engine for Linux. It’s designed for security, simplicity, and composability within
    modern cluster environments.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rkt（发音为“rocket”）**：由 CoreOS 开发，是一个适用于 Linux 的 Pod 原生容器引擎。它在现代集群环境中旨在提供安全性、简洁性和可组合性。'
- en: '**LXD**: A cutting-edge manager for system containers and VMs that provides
    a user experience akin to VMs but through the use of Linux containers.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LXD**：一个先进的系统容器和虚拟机管理器，通过使用 Linux 容器提供类似虚拟机的用户体验。'
- en: '**OpenVZ**: This is a virtualization solution built on container technology
    for Linux systems that’s capable of generating several secure and isolated Linux
    containers on a singular physical server.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenVZ**：这是一个基于容器技术的虚拟化解决方案，适用于 Linux 系统，能够在单一物理服务器上生成多个安全和隔离的 Linux 容器。'
- en: 'To assist in choosing the most suitable containerization tool for your specific
    needs, the following table provides a comparison of various Docker alternatives.
    It highlights their key features and ideal use cases, offering insights into which
    tool may best align with your project’s requirements or preferences:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助选择最适合您特定需求的容器化工具，以下表格提供了多个 Docker 替代方案的比较。它突出了它们的主要特点和理想使用场景，为您提供有关哪个工具最符合您项目需求或偏好的见解：
- en: '| **Alternative** | **Description** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **替代方案** | **描述** |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Podman | Best for environments that prioritize security and for users who
    prefer a solution without a daemon. It’s fully compatible with Docker’s CLI, making
    it a seamless replacement. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| Podman | 最适合优先考虑安全性并且用户希望使用无守护进程的解决方案的环境。它与 Docker 的 CLI 完全兼容，使其成为无缝替代方案。
    |'
- en: '| Rancherdesktop | A user-friendly, GUI-based tool tailored for developers
    who want an easier way to manage containers and Kubernetes, especially on desktop
    environments for development and testing purposes. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| Rancherdesktop | 一款用户友好的基于 GUI 的工具，专为希望更轻松地管理容器和 Kubernetes 的开发人员设计，特别适用于开发和测试环境中的桌面环境。
    |'
- en: '| Containerd | Chosen for its performance and reliability as a container runtime
    in production environments. Lacks Docker’s image-building features but excels
    in running containers efficiently. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| Containerd | 由于其在生产环境中作为容器运行时的性能和可靠性而被选中。缺乏 Docker 的镜像构建功能，但在高效运行容器方面表现出色。
    |'
- en: '| Rkt | Previously a viable alternative, but its development has ceased, potentially
    limiting its suitability for long-term projects. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| Rkt | 以前是一个可行的替代方案，但其开发已停止，可能会限制其在长期项目中的适用性。 |'
- en: '| OpenVZ | Ideal for hosting solutions or for scenarios requiring multiple,
    isolated Linux environments on a single host, with a focus on resource efficiency
    and scalability. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| OpenVZ | 适合托管解决方案或需要在单个主机上创建多个隔离的 Linux 环境的场景，专注于资源效率和可扩展性。 |'
- en: Table 2.1 – Comparative overview of containerization tools – evaluating alternatives
    to Docker for diverse development needs
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 容器化工具的比较概览 – 评估不同开发需求下 Docker 的替代方案
- en: Dockerfile
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile
- en: 'The first step in creating a container image involves defining a **Dockerfile**,
    which is essentially a **blueprint** for the image. This file contains a set of
    instructions and commands that tell Docker how to build the image. It starts with
    specifying a base image to build upon, often a minimal version of an operating
    system, such as Ubuntu or Alpine Linux. Then, additional layers are added by specifying
    dependencies, copying application files, and setting environment variables. Each
    command in a Dockerfile creates a new layer in the image, building up the environment
    that’s needed to run the application. The following is an example of a Dockerfile:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建容器镜像的第一步是定义一个 **Dockerfile**，它本质上是镜像的 **蓝图**。这个文件包含了一组指令和命令，告诉 Docker 如何构建镜像。它首先指定一个基础镜像，通常是一个操作系统的精简版本，比如
    Ubuntu 或 Alpine Linux。接着，通过指定依赖项、复制应用程序文件和设置环境变量，逐步添加额外的层。Dockerfile 中的每一条命令都会创建镜像中的新层，逐步构建运行应用程序所需的环境。以下是一个
    Dockerfile 的示例：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s take a closer look at this file:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地查看这个文件：
- en: '`FROM python:3.8-slim`: This line indicates the base image from which you are
    building. The Dockerfile starts with the Python 3.8 image, specifically the slim
    variant, which is a smaller, more compact version.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM python:3.8-slim`：这一行指定了构建时使用的基础镜像。该 Dockerfile 以 Python 3.8 镜像开始，特别是
    slim 版本，它是一个较小、更紧凑的版本。'
- en: '`WORKDIR /usr/src/app`: This line sets the working directory inside the container
    to `/usr/src/app`. Future commands will run in this directory.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /usr/src/app`：这一行设置容器内的工作目录为 `/usr/src/app`。以后所有的命令都将在该目录中运行。'
- en: '`COPY . .`: This line copies files from the Dockerfile’s current directory
    to the working directory in the container (`/usr/src/app`).'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY . .`：这一行将 Dockerfile 当前目录中的文件复制到容器中的工作目录(`/usr/src/app`)。'
- en: '`RUN pip install --no-cache-dir -r requirements.txt`: This line executes a
    command inside the container, which in this case is installing Python dependencies
    listed in `requirements.txt`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN pip install --no-cache-dir -r requirements.txt`：这一行在容器内执行一个命令，即安装 `requirements.txt`
    中列出的 Python 依赖项。'
- en: '`EXPOSE 80`: The line informs Docker that the container listens on port `80`
    at runtime. Note that this does not publish the port.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 80`：这一行通知 Docker 容器在运行时监听 `80` 端口。注意，这并不会发布端口。'
- en: '`ENV NAME World`: This line sets the `NAME` environment variable to `World`.
    This can be used by the application running in the container.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV NAME World`：这一行将 `NAME` 环境变量设置为 `World`。容器中运行的应用程序可以使用这个变量。'
- en: '`CMD ["python", "app.py"]`: The default command to run when a container starts.
    This line runs the Python application.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["python", "app.py"]`：容器启动时执行的默认命令。该行启动 Python 应用程序。'
- en: 'This Dockerfile provides a simple example of building an image of a simple
    `requirements.txt` file and you want to build a Docker image from this Dockerfile.
    The command you would use is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 提供了一个简单的示例，说明如何从一个简单的 `requirements.txt` 文件构建 Docker 镜像。你可以使用以下命令构建该镜像：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this stage, as shown in *Figure 2**.15*, your container image is in the
    process of being built. During this build, Docker retrieves any existing layers
    from **public container registries** such as DockerHub, Quay, or Red Hat Registry.
    The topic of container registries will be introduced in the upcoming pages. It
    then adds a new layer based on the instructions in your Dockerfile. If some layers
    are already present locally, Docker will use these from the container cache or
    Docker cache, speeding up the build process by avoiding redundant downloads:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，正如 *图 2.15* 所示，你的容器镜像正在构建过程中。在此过程中，Docker 会从 **公共容器注册表**（如 DockerHub、Quay
    或 Red Hat Registry）中获取任何现有的层。容器注册表的相关内容将在接下来的页面介绍。然后，它会根据 Dockerfile 中的指令添加新的层。如果某些层已经存在于本地，Docker
    会从容器缓存或 Docker 缓存中使用这些层，从而通过避免冗余下载来加速构建过程：
- en: '![Figure 2.15 – Result of the docker build command](img/B22100_02_15.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – docker build 命令的结果](img/B22100_02_15.jpg)'
- en: Figure 2.15 – Result of the docker build command
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – docker build 命令的结果
- en: 'The container image is now available in the local Docker cache and ready to
    be used. Its presence can be verified with the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像现在已在本地 Docker 缓存中可用，准备使用。可以使用以下命令验证其存在：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the image has been created, it can be used locally or uploaded to a public
    container registry for external use, such as within a CI/CD pipeline. For our
    purposes, we’ll run the container image locally. To do this, use the following
    command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像创建完成，就可以在本地使用或上传到公共容器注册表以供外部使用，例如在 CI/CD 流水线中。为了我们的目的，我们将在本地运行容器镜像。为此，请使用以下命令：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding command includes several options:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令包含几个选项：
- en: The `-p` option binds a port on the host to a port on the container, allowing
    external access to the container’s services
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`选项将主机上的端口绑定到容器上的端口，从而允许外部访问容器的服务'
- en: The `-t` option allocates a pseudo-TTY, which provides a Terminal within the
    container
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`选项分配一个伪 TTY，为容器提供一个终端'
- en: The `-i` option enables interactive mode, allowing interaction with the container
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`选项启用交互模式，允许与容器进行交互'
- en: The `-d` option runs the container in the background and outputs a hash, which
    can be used for asynchronous interaction with the container
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`选项将在后台运行容器并输出一个哈希值，可用于与容器进行异步交互'
- en: Public container registry
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 公共容器注册表
- en: A public container registry is an online service where users can store and share
    container images. It serves as a centralized repository, facilitating the distribution
    of containerized applications. To upload and manage images, users typically need
    to create an account with the registry provider. This account allows them to publish,
    update, and maintain their images, making them accessible to others. Public registries
    such as Docker Hub, Google Container Registry, and Amazon Elastic Container Registry
    are popular choices, offering easy access over the internet. These platforms not
    only provide storage for container images but often come with additional features
    such as version control, cataloging, and security scanning. An account with these
    services enables developers to deploy applications consistently across different
    environments, streamline software development, and collaborate more effectively
    with others in the community.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 公共容器注册表是一个在线服务，用户可以在其中存储和共享容器镜像。它作为一个集中式存储库，促进容器化应用程序的分发。为了上传和管理镜像，用户通常需要在注册表提供商处创建一个账户。该账户允许用户发布、更新和维护镜像，使其对他人可访问。Docker
    Hub、Google Container Registry 和 Amazon Elastic Container Registry 等公共注册表是流行的选择，提供便捷的互联网访问。这些平台不仅为容器镜像提供存储，还通常提供版本控制、目录管理和安全扫描等附加功能。拥有这些服务的账户使得开发人员能够在不同环境中一致地部署应用程序，简化软件开发，并更有效地与社区中的其他人进行协作。
- en: Please note that the process of creating an account with a public container
    registry, although a crucial step for managing and distributing container images,
    falls outside the scope of this chapter and book. Each registry, such as Docker
    Hub or Google Container Registry, has its own set of guidelines and procedures
    for account creation and management. You are encouraged to refer to the specific
    documentation provided by these services for detailed instructions on setting
    up an account.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，创建公共容器注册表账户的过程虽然是管理和分发容器镜像的关键步骤，但超出了本章和本书的范围。每个注册表（如 Docker Hub 或 Google
    Container Registry）都有自己的一套账户创建和管理指南和程序。建议您参考这些服务提供的具体文档，了解设置账户的详细说明。
- en: 'The preceding command will launch the application within the Docker network
    and bind it to port `8080` on our local machine. It will then wait for incoming
    requests, as illustrated in *Figure 2**.16*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在 Docker 网络内启动应用程序，并将其绑定到我们本地机器的端口`8080`。然后，它将等待传入的请求，如*图 2.16*所示：
- en: '![Figure 2.16 – Result of the docker run command](img/B22100_02_16.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – docker run 命令的结果](img/B22100_02_16.jpg)'
- en: Figure 2.16 – Result of the docker run command
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – docker run 命令的结果
- en: 'From a new Terminal, we can try to access the running container using `curl`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的终端中，我们可以尝试使用`curl`访问正在运行的容器：
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, we can run the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以运行以下命令：
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You’ll receive a response similar to the one shown in *Figure 2**.17*, where
    I used my name to obtain the output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到一个类似于*图 2.17*中的响应，我使用了我的名字来获取输出：
- en: '![Figure 2.17 – Example of responses received from our Python Flask application
    running as a containerized image](img/B22100_02_17.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 从我们作为容器化镜像运行的 Python Flask 应用程序接收到的响应示例](img/B22100_02_17.jpg)'
- en: Figure 2.17 – Example of responses received from our Python Flask application
    running as a containerized image
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 从我们作为容器化镜像运行的 Python Flask 应用程序接收到的响应示例
- en: Now that we are equipped with the necessary tools and understanding of Docker
    and containers, in the next section, will integrate these elements so that we
    can construct our first CD pipeline using Docker and K3s.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了必要的工具和对 Docker 及容器的理解，在接下来的章节中，我们将整合这些元素，构建第一个使用 Docker 和 K3s 的 CD
    管道。
- en: Sample workflow – effortless CD with Docker and K3s
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例工作流——使用 Docker 和 K3s 实现轻松的 CD
- en: At this point, we are ready to create a very simple CD pipeline using the tools
    we’ve explored so far. The basic idea is to simulate the operations performed
    by a developer who needs to update the Flask app we’ve used so far to add a new
    feature that allows the current date and time to be retrieved.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经准备好使用迄今为止探索的工具创建一个非常简单的 CD 管道。基本思路是模拟开发人员执行的操作，更新我们到目前为止使用的 Flask 应用程序，添加一个新功能，允许获取当前的日期和时间。
- en: 'Our example will consist of performing the following steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将包括执行以下步骤：
- en: '**Local development**: We will edit the previous Python Flask app to expose
    a new service that returns the current date and time.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本地开发**：我们将编辑之前的 Python Flask 应用程序，暴露一个新的服务，返回当前的日期和时间。'
- en: '**Dockerizing the application and running it locally**: We will build the new
    version of the Docker image locally using the docker build command, as we did
    previously. Use the *Dockerfile* section as a reference.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将应用程序 Docker 化并在本地运行**：我们将像之前一样使用 `docker build` 命令在本地构建新版本的 Docker 镜像。使用
    *Dockerfile* 部分作为参考。'
- en: After building the image, we will run it locally using Docker to ensure the
    containerized application works as expected. Use the *Dockerfile* section as a
    reference.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构建镜像后，我们将使用 Docker 在本地运行它，以确保容器化应用程序按预期工作。使用 *Dockerfile* 部分作为参考。
- en: '**Publishing the image to a public container registry**: We will publish the
    build image to a public registry repository.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将镜像发布到公共容器注册表**：我们将把构建的镜像发布到公共注册表仓库。'
- en: '**Deploying to K3s**: We will write the Kubernetes manifest file to specify
    how our application should be deployed on K3s, including which Docker image to
    use and the desired number of replicas.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署到 K3s**：我们将编写 Kubernetes 清单文件，指定应用程序如何在 K3s 上部署，包括使用哪个 Docker 镜像以及所需的副本数。'
- en: You will apply this configuration to your K3s cluster using the commands you
    learned about in the *Exploring K3s as a lightweight Kubernetes distribution*
    section of this chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用在本章 *探索 K3s 作为轻量级 Kubernetes 发行版* 部分中学到的命令，将此配置应用到你的 K3s 集群中。
- en: Let’s get started!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Local development
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地开发
- en: 'Edit the `app.py` file present in this book’s GitHub repository by adding the
    following Python code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑此书 GitHub 仓库中的 `app.py` 文件，添加以下 Python 代码：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’re free to use whatever code editor you like to edit this file – it doesn’t
    matter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由选择任何你喜欢的代码编辑器来编辑这个文件——这无关紧要。
- en: Dockerizing the application and running it locally
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用程序 Docker 化并在本地运行
- en: 'Follow these steps to Dockerize the application and run It locally:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将应用程序 Docker 化并在本地运行：
- en: 'In the *Dockerfile* section, we created the first version of our Docker image,
    tagged as `hello-world-py-app:1.0`. Now that we have added a new feature, it’s
    time to create a new version of that image. We will use a tag of `2.0` using the
    following `docker` `build` command:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *Dockerfile* 部分，我们创建了第一个版本的 Docker 镜像，标签为 `hello-world-py-app:1.0`。现在我们添加了一个新功能，是时候创建这个镜像的新版本了。我们将使用标签
    `2.0`，通过以下 `docker` `build` 命令进行构建：
- en: '[PRE32]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Upon typing the following command, you should be able to see both images listed:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令后，你应该能看到列出两个镜像：
- en: '[PRE33]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result of this command should look like this:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令的结果应如下所示：
- en: '[PRE34]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can run the Docker image locally with the following `docker` command:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下 `docker` 命令在本地运行 Docker 镜像：
- en: '[PRE35]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will produce a result similar to the following:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生类似以下的结果：
- en: '[PRE36]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'From a new Terminal, we can try to access the running container using `curl`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的终端中，我们可以尝试使用 `curl` 访问正在运行的容器：
- en: '[PRE37]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll obtain the current response:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将获得当前的响应：
- en: '[PRE38]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Well done – as a developer, you have tested that the new feature is working
    as expected! Now, we can publish our image to a public repository.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好——作为开发人员，你已经测试了新功能是否按预期工作！现在，我们可以将我们的镜像发布到公共仓库。
- en: Publishing the image to a container registry
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将镜像发布到容器注册表
- en: 'Publishing our `hello-world-py-app:2.0` Docker image to a public repository
    involves several steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的 `hello-world-py-app:2.0` Docker 镜像发布到公共仓库涉及几个步骤：
- en: 'Assuming that you have already an account on a public container registry such
    as Docker Hub, the first step is to open a new Terminal and log in to the registry
    using the Docker CLI:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经在公共容器注册表（例如 Docker Hub）上有一个账户，第一步是打开一个新的终端，并使用 Docker CLI 登录到注册表：
- en: '[PRE39]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: $ sudo docker tag hello-world-py-app:2.0 [yourusername]/hello-world-py-app:2.0
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ sudo docker tag hello-world-py-app:2.0 [yourusername]/hello-world-py-app:2.0
- en: '[PRE40]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we need to push the tagged image:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要推送标记的镜像：
- en: '[PRE41]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Deploying to K3s
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到 K3s
- en: 'The time to deploy our image to our local Kubernetes cluster has finally arrived!
    We can reuse the same Kubernetes manifest file that we used in the *Our first
    deployment with K3s* section, but we are going to apply a couple of edits, with
    the most important one being to update the manifest file so that it indicates
    where the Kubernetes cluster has to download the image, using our container repository.
    So, let’s get started:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在终于到了将镜像部署到本地 Kubernetes 集群的时刻！我们可以重用在 *我们的第一次 K3s 部署* 部分中使用的 Kubernetes 清单文件，但我们将做几个修改，最重要的是更新清单文件，指明
    Kubernetes 集群需要从哪里下载镜像，使用我们的容器仓库。现在，让我们开始吧：
- en: 'In the `deployment` section of the manifest file, we have to change the image
    value from `nginxdemos/hello` to `[yourusername]/hello-world-py-app:2.0`. Then,
    we have to change the name (where specified in the file) from `hello-world` to
    `first-cd-pipeline`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清单文件的 `deployment` 部分，我们需要将镜像值从 `nginxdemos/hello` 更改为 `[yourusername]/hello-world-py-app:2.0`。然后，我们需要将文件中指定的位置的名称从
    `hello-world` 更改为 `first-cd-pipeline`：
- en: '[PRE42]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we have also changed the name of the deployment to `first-cd-pipeline-deployment`.
    The deployment file can be found in the `Chapter02` folder in this book’s GitHub
    repository.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们还将部署的名称更改为 `first-cd-pipeline-deployment`。部署文件可以在本书的 GitHub 仓库中的 `Chapter02`
    文件夹找到。
- en: 'Save the new file, naming it as `first-cd-pipeline-deployment.yaml`, and apply
    the deployment with the following command:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存新文件，命名为 `first-cd-pipeline-deployment.yaml`，并使用以下命令应用该部署：
- en: '[PRE43]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The response should look like this:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应应该像这样：
- en: '[PRE44]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Before establishing port forwarding, as described at the end of the *Our first
    deployment with K3s* section, we need to get some useful information by running
    the following command:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在建立端口转发之前，如 *我们的第一次 K3s 部署* 部分末尾所述，我们需要通过运行以下命令获取一些有用的信息：
- en: '[PRE45]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will produce an output similar to the following:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '[PRE46]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, we have all the information we need to perform port forwarding:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到此为止，我们已经拥有执行端口转发所需的所有信息：
- en: '[PRE47]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: $ curl http://localhost:8080/datetime
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ curl http://localhost:8080/datetime
- en: '[PRE48]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '2024-01-13 17:59:39'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '2024-01-13 17:59:39'
- en: '[PRE49]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To delete the deployment, type the following command:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除部署，输入以下命令：
- en: '[PRE50]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Congratulations on reaching this milestone with a manual CD deployment!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你通过手动 CD 部署达到了这个里程碑！
- en: The steps outlined here for publishing a Docker image to a public container
    registry should be viewed as a manual example that illustrates the basic principles
    of CD. In practice, however, this process is typically automated using tools such
    as Git Actions, which streamline and optimize the deployment cycle. While these
    manual steps provide a foundational understanding, real-world applications often
    rely on more sophisticated automation for efficiency and consistency. In the next
    chapter, we’ll delve into how such tools can be integrated into your workflow,
    thereby enhancing the CD process and reducing the need for manual intervention.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里概述的将 Docker 镜像发布到公共容器注册表的步骤，应该视为一个手动示例，展示了 CD 的基本原理。然而，在实际操作中，这个过程通常使用 Git
    Actions 等工具进行自动化，从而简化和优化部署周期。尽管这些手动步骤提供了基础理解，现实应用中通常依赖更复杂的自动化工具来提高效率和一致性。在下一章中，我们将深入探讨如何将这些工具集成到工作流程中，从而增强
    CD 过程并减少手动干预。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we navigated the practical aspects of deploying cloud-native
    applications using Kubernetes and K3s, highlighting key techniques for efficient
    container management and orchestration. This chapter focused on building foundational
    skills that are crucial for managing cloud-native environments, including understanding
    Kubernetes resources and deployment methodologies.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Kubernetes 和 K3s 部署云原生应用的实践方面，重点介绍了高效的容器管理和编排的关键技术。本章侧重于构建管理云原生环境所需的基础技能，包括理解
    Kubernetes 资源和部署方法。
- en: As we move to the next chapter, the emphasis will shift to introducing Git tools.
    We’ll explore how these tools can be leveraged to create an automated CI/CD pipeline,
    an essential component for seamlessly deploying and managing cloud-native applications,
    as well as enhancing development and operational workflows.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一章，重点将转向介绍 Git 工具。我们将探讨如何利用这些工具创建一个自动化的 CI/CD 流水线，这是无缝部署和管理云原生应用的核心组件，同时提升开发和运营工作流程。
- en: Further reading
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: '[*1*] [https://learn.microsoft.com/en-us/windows/wsl/about](https://learn.microsoft.com/en-us/windows/wsl/about)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*1*] [https://learn.microsoft.com/en-us/windows/wsl/about](https://learn.microsoft.com/en-us/windows/wsl/about)'
- en: '[*2*] [https://www.virtualbox.org/](https://www.virtualbox.org/)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*2*] [https://www.virtualbox.org/](https://www.virtualbox.org/)'
